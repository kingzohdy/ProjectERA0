; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	i:\svnroot\client\Plugins\RenderSystem_D3D9\Md5.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	?Process@CMd5@@AAEXPBE@Z			; CMd5::Process
EXTRN	_memcpy:PROC
; Function compile flags: /Odtp
; File i:\svnroot\client\plugins\rendersystem_d3d9\md5.cpp
_TEXT	SEGMENT
_this$ = -92						; size = 4
_t$ = -88						; size = 4
_c$ = -84						; size = 4
_d$ = -80						; size = 4
_X$ = -76						; size = 4
_xbuf$ = -72						; size = 64
_b$ = -8						; size = 4
_a$ = -4						; size = 4
_pData$ = 8						; size = 4
?Process@CMd5@@AAEXPBE@Z PROC				; CMd5::Process
; _this$ = ecx

; 81   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH
	mov	DWORD PTR _this$[ebp], ecx

; 82   : 	unsigned int
; 83   : 		a =	m_pDigestBuffer[0],	b =	m_pDigestBuffer[1],

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _a$[ebp], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR _b$[ebp], eax

; 84   : 		c =	m_pDigestBuffer[2],	d =	m_pDigestBuffer[3];

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR _c$[ebp], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR _d$[ebp], ecx

; 85   : 	unsigned int t;
; 86   : 
; 87   : #if	defined(BIG_ENDIAN)	//faster
; 88   : 
; 89   : 	unsigned int X[16];
; 90   : 	const unsigned char	*xp	= pData;
; 91   : 	unsigned int i;
; 92   : 
; 93   : 	for	(i = 0;	i <	16;	++i, xp	+= 4)
; 94   : 		X[i] = xp[0] + (xp[1] << 8)	+ (xp[2] <<	16)	+ (xp[3] <<	24);
; 95   : 
; 96   : #elif defined(LITTLE_ENDIAN)
; 97   : 
; 98   : 	unsigned int xbuf[16];
; 99   : 	const unsigned int *X;
; 100  : 
; 101  : 	if (!((pData - (const unsigned char	*)0) & 3))

	mov	edx, DWORD PTR _pData$[ebp]
	and	edx, 3
	jne	SHORT $LN2@Process

; 102  : 	{
; 103  : 		/* pData are properly aligned */
; 104  : 		X =	(const unsigned int	*)pData;

	mov	eax, DWORD PTR _pData$[ebp]
	mov	DWORD PTR _X$[ebp], eax

; 105  : 	} else {

	jmp	SHORT $LN1@Process
$LN2@Process:

; 106  : 		/* not aligned */
; 107  : 		memcpy(xbuf, pData,	64);

	push	64					; 00000040H
	mov	ecx, DWORD PTR _pData$[ebp]
	push	ecx
	lea	edx, DWORD PTR _xbuf$[ebp]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 108  : 		X =	xbuf;

	lea	eax, DWORD PTR _xbuf$[ebp]
	mov	DWORD PTR _X$[ebp], eax
$LN1@Process:

; 109  : 	}
; 110  : #else
; 111  : #error Either LITTLE_ENDIAN	or BIG_ENDIAN must be defined to compile this file.(LITTLE_ENDIAN for intel	cpu.)
; 112  : #endif
; 113  : 
; 114  : 	/* Round 1.	*/
; 115  : 	/* Let [m_pDigestBuffer	k s	i] denote the operation
; 116  : 	a =	b +	((a	+ F(b,c,d) + X[k] +	T[i]) <<< s). */
; 117  : #define	SET(a, b, c, d,	k, s, Ti)\
; 118  : t =	a +	F(b,c,d) + X[k]	+ Ti;\
; 119  : a =	ROTATE_LEFT(t, s) +	b
; 120  : 	/* Do the following	16 operations. */
; 121  : 	SET(a, b, c, d,	0, 7, T1);

	mov	ecx, DWORD PTR _d$[ebp]
	push	ecx
	mov	edx, DWORD PTR _c$[ebp]
	push	edx
	mov	eax, DWORD PTR _b$[ebp]
	push	eax
	call	?F@@YAIIII@Z				; F
	add	esp, 12					; 0000000cH
	add	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR _X$[ebp]
	mov	edx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [eax+edx-680876936]
	mov	DWORD PTR _t$[ebp], eax
	push	7
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	call	?ROTATE_LEFT@@YAIII@Z			; ROTATE_LEFT
	add	esp, 8
	add	eax, DWORD PTR _b$[ebp]
	mov	DWORD PTR _a$[ebp], eax

; 122  : 	SET(d, a, b, c,	1, 12, T2);

	mov	edx, DWORD PTR _c$[ebp]
	push	edx
	mov	eax, DWORD PTR _b$[ebp]
	push	eax
	mov	ecx, DWORD PTR _a$[ebp]
	push	ecx
	call	?F@@YAIIII@Z				; F
	add	esp, 12					; 0000000cH
	add	eax, DWORD PTR _d$[ebp]
	mov	edx, DWORD PTR _X$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	lea	edx, DWORD PTR [eax+ecx-389564586]
	mov	DWORD PTR _t$[ebp], edx
	push	12					; 0000000cH
	mov	eax, DWORD PTR _t$[ebp]
	push	eax
	call	?ROTATE_LEFT@@YAIII@Z			; ROTATE_LEFT
	add	esp, 8
	add	eax, DWORD PTR _a$[ebp]
	mov	DWORD PTR _d$[ebp], eax

; 123  : 	SET(c, d, a, b,	2, 17, T3);

	mov	ecx, DWORD PTR _b$[ebp]
	push	ecx
	mov	edx, DWORD PTR _a$[ebp]
	push	edx
	mov	eax, DWORD PTR _d$[ebp]
	push	eax
	call	?F@@YAIIII@Z				; F
	add	esp, 12					; 0000000cH
	add	eax, DWORD PTR _c$[ebp]
	mov	ecx, DWORD PTR _X$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	lea	eax, DWORD PTR [eax+edx+606105819]
	mov	DWORD PTR _t$[ebp], eax
	push	17					; 00000011H
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	call	?ROTATE_LEFT@@YAIII@Z			; ROTATE_LEFT
	add	esp, 8
	add	eax, DWORD PTR _d$[ebp]
	mov	DWORD PTR _c$[ebp], eax

; 124  : 	SET(b, c, d, a,	3, 22, T4);

	mov	edx, DWORD PTR _a$[ebp]
	push	edx
	mov	eax, DWORD PTR _d$[ebp]
	push	eax
	mov	ecx, DWORD PTR _c$[ebp]
	push	ecx
	call	?F@@YAIIII@Z				; F
	add	esp, 12					; 0000000cH
	add	eax, DWORD PTR _b$[ebp]
	mov	edx, DWORD PTR _X$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	lea	edx, DWORD PTR [eax+ecx-1044525330]
	mov	DWORD PTR _t$[ebp], edx
	push	22					; 00000016H
	mov	eax, DWORD PTR _t$[ebp]
	push	eax
	call	?ROTATE_LEFT@@YAIII@Z			; ROTATE_LEFT
	add	esp, 8
	add	eax, DWORD PTR _c$[ebp]
	mov	DWORD PTR _b$[ebp], eax

; 125  : 	SET(a, b, c, d,	4, 7, T5);

	mov	ecx, DWORD PTR _d$[ebp]
	push	ecx
	mov	edx, DWORD PTR _c$[ebp]
	push	edx
	mov	eax, DWORD PTR _b$[ebp]
	push	eax
	call	?F@@YAIIII@Z				; F
	add	esp, 12					; 0000000cH
	add	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR _X$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	lea	eax, DWORD PTR [eax+edx-176418897]
	mov	DWORD PTR _t$[ebp], eax
	push	7
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	call	?ROTATE_LEFT@@YAIII@Z			; ROTATE_LEFT
	add	esp, 8
	add	eax, DWORD PTR _b$[ebp]
	mov	DWORD PTR _a$[ebp], eax

; 126  : 	SET(d, a, b, c,	5, 12, T6);

	mov	edx, DWORD PTR _c$[ebp]
	push	edx
	mov	eax, DWORD PTR _b$[ebp]
	push	eax
	mov	ecx, DWORD PTR _a$[ebp]
	push	ecx
	call	?F@@YAIIII@Z				; F
	add	esp, 12					; 0000000cH
	add	eax, DWORD PTR _d$[ebp]
	mov	edx, DWORD PTR _X$[ebp]
	mov	ecx, DWORD PTR [edx+20]
	lea	edx, DWORD PTR [eax+ecx+1200080426]
	mov	DWORD PTR _t$[ebp], edx
	push	12					; 0000000cH
	mov	eax, DWORD PTR _t$[ebp]
	push	eax
	call	?ROTATE_LEFT@@YAIII@Z			; ROTATE_LEFT
	add	esp, 8
	add	eax, DWORD PTR _a$[ebp]
	mov	DWORD PTR _d$[ebp], eax

; 127  : 	SET(c, d, a, b,	6, 17, T7);

	mov	ecx, DWORD PTR _b$[ebp]
	push	ecx
	mov	edx, DWORD PTR _a$[ebp]
	push	edx
	mov	eax, DWORD PTR _d$[ebp]
	push	eax
	call	?F@@YAIIII@Z				; F
	add	esp, 12					; 0000000cH
	add	eax, DWORD PTR _c$[ebp]
	mov	ecx, DWORD PTR _X$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	lea	eax, DWORD PTR [eax+edx-1473231341]
	mov	DWORD PTR _t$[ebp], eax
	push	17					; 00000011H
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	call	?ROTATE_LEFT@@YAIII@Z			; ROTATE_LEFT
	add	esp, 8
	add	eax, DWORD PTR _d$[ebp]
	mov	DWORD PTR _c$[ebp], eax

; 128  : 	SET(b, c, d, a,	7, 22, T8);

	mov	edx, DWORD PTR _a$[ebp]
	push	edx
	mov	eax, DWORD PTR _d$[ebp]
	push	eax
	mov	ecx, DWORD PTR _c$[ebp]
	push	ecx
	call	?F@@YAIIII@Z				; F
	add	esp, 12					; 0000000cH
	add	eax, DWORD PTR _b$[ebp]
	mov	edx, DWORD PTR _X$[ebp]
	mov	ecx, DWORD PTR [edx+28]
	lea	edx, DWORD PTR [eax+ecx-45705983]
	mov	DWORD PTR _t$[ebp], edx
	push	22					; 00000016H
	mov	eax, DWORD PTR _t$[ebp]
	push	eax
	call	?ROTATE_LEFT@@YAIII@Z			; ROTATE_LEFT
	add	esp, 8
	add	eax, DWORD PTR _c$[ebp]
	mov	DWORD PTR _b$[ebp], eax

; 129  : 	SET(a, b, c, d,	8, 7, T9);

	mov	ecx, DWORD PTR _d$[ebp]
	push	ecx
	mov	edx, DWORD PTR _c$[ebp]
	push	edx
	mov	eax, DWORD PTR _b$[ebp]
	push	eax
	call	?F@@YAIIII@Z				; F
	add	esp, 12					; 0000000cH
	add	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR _X$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	lea	eax, DWORD PTR [eax+edx+1770035416]
	mov	DWORD PTR _t$[ebp], eax
	push	7
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	call	?ROTATE_LEFT@@YAIII@Z			; ROTATE_LEFT
	add	esp, 8
	add	eax, DWORD PTR _b$[ebp]
	mov	DWORD PTR _a$[ebp], eax

; 130  : 	SET(d, a, b, c,	9, 12, T10);

	mov	edx, DWORD PTR _c$[ebp]
	push	edx
	mov	eax, DWORD PTR _b$[ebp]
	push	eax
	mov	ecx, DWORD PTR _a$[ebp]
	push	ecx
	call	?F@@YAIIII@Z				; F
	add	esp, 12					; 0000000cH
	add	eax, DWORD PTR _d$[ebp]
	mov	edx, DWORD PTR _X$[ebp]
	mov	ecx, DWORD PTR [edx+36]
	lea	edx, DWORD PTR [eax+ecx-1958414417]
	mov	DWORD PTR _t$[ebp], edx
	push	12					; 0000000cH
	mov	eax, DWORD PTR _t$[ebp]
	push	eax
	call	?ROTATE_LEFT@@YAIII@Z			; ROTATE_LEFT
	add	esp, 8
	add	eax, DWORD PTR _a$[ebp]
	mov	DWORD PTR _d$[ebp], eax

; 131  : 	SET(c, d, a, b,	10,	17,	T11);

	mov	ecx, DWORD PTR _b$[ebp]
	push	ecx
	mov	edx, DWORD PTR _a$[ebp]
	push	edx
	mov	eax, DWORD PTR _d$[ebp]
	push	eax
	call	?F@@YAIIII@Z				; F
	add	esp, 12					; 0000000cH
	add	eax, DWORD PTR _c$[ebp]
	mov	ecx, DWORD PTR _X$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	lea	eax, DWORD PTR [eax+edx-42063]
	mov	DWORD PTR _t$[ebp], eax
	push	17					; 00000011H
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	call	?ROTATE_LEFT@@YAIII@Z			; ROTATE_LEFT
	add	esp, 8
	add	eax, DWORD PTR _d$[ebp]
	mov	DWORD PTR _c$[ebp], eax

; 132  : 	SET(b, c, d, a,	11,	22,	T12);

	mov	edx, DWORD PTR _a$[ebp]
	push	edx
	mov	eax, DWORD PTR _d$[ebp]
	push	eax
	mov	ecx, DWORD PTR _c$[ebp]
	push	ecx
	call	?F@@YAIIII@Z				; F
	add	esp, 12					; 0000000cH
	add	eax, DWORD PTR _b$[ebp]
	mov	edx, DWORD PTR _X$[ebp]
	mov	ecx, DWORD PTR [edx+44]
	lea	edx, DWORD PTR [eax+ecx-1990404162]
	mov	DWORD PTR _t$[ebp], edx
	push	22					; 00000016H
	mov	eax, DWORD PTR _t$[ebp]
	push	eax
	call	?ROTATE_LEFT@@YAIII@Z			; ROTATE_LEFT
	add	esp, 8
	add	eax, DWORD PTR _c$[ebp]
	mov	DWORD PTR _b$[ebp], eax

; 133  : 	SET(a, b, c, d,	12,	7, T13);

	mov	ecx, DWORD PTR _d$[ebp]
	push	ecx
	mov	edx, DWORD PTR _c$[ebp]
	push	edx
	mov	eax, DWORD PTR _b$[ebp]
	push	eax
	call	?F@@YAIIII@Z				; F
	add	esp, 12					; 0000000cH
	add	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR _X$[ebp]
	mov	edx, DWORD PTR [ecx+48]
	lea	eax, DWORD PTR [eax+edx+1804603682]
	mov	DWORD PTR _t$[ebp], eax
	push	7
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	call	?ROTATE_LEFT@@YAIII@Z			; ROTATE_LEFT
	add	esp, 8
	add	eax, DWORD PTR _b$[ebp]
	mov	DWORD PTR _a$[ebp], eax

; 134  : 	SET(d, a, b, c,	13,	12,	T14);

	mov	edx, DWORD PTR _c$[ebp]
	push	edx
	mov	eax, DWORD PTR _b$[ebp]
	push	eax
	mov	ecx, DWORD PTR _a$[ebp]
	push	ecx
	call	?F@@YAIIII@Z				; F
	add	esp, 12					; 0000000cH
	add	eax, DWORD PTR _d$[ebp]
	mov	edx, DWORD PTR _X$[ebp]
	mov	ecx, DWORD PTR [edx+52]
	lea	edx, DWORD PTR [eax+ecx-40341101]
	mov	DWORD PTR _t$[ebp], edx
	push	12					; 0000000cH
	mov	eax, DWORD PTR _t$[ebp]
	push	eax
	call	?ROTATE_LEFT@@YAIII@Z			; ROTATE_LEFT
	add	esp, 8
	add	eax, DWORD PTR _a$[ebp]
	mov	DWORD PTR _d$[ebp], eax

; 135  : 	SET(c, d, a, b,	14,	17,	T15);

	mov	ecx, DWORD PTR _b$[ebp]
	push	ecx
	mov	edx, DWORD PTR _a$[ebp]
	push	edx
	mov	eax, DWORD PTR _d$[ebp]
	push	eax
	call	?F@@YAIIII@Z				; F
	add	esp, 12					; 0000000cH
	add	eax, DWORD PTR _c$[ebp]
	mov	ecx, DWORD PTR _X$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	lea	eax, DWORD PTR [eax+edx-1502002290]
	mov	DWORD PTR _t$[ebp], eax
	push	17					; 00000011H
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	call	?ROTATE_LEFT@@YAIII@Z			; ROTATE_LEFT
	add	esp, 8
	add	eax, DWORD PTR _d$[ebp]
	mov	DWORD PTR _c$[ebp], eax

; 136  : 	SET(b, c, d, a,	15,	22,	T16);

	mov	edx, DWORD PTR _a$[ebp]
	push	edx
	mov	eax, DWORD PTR _d$[ebp]
	push	eax
	mov	ecx, DWORD PTR _c$[ebp]
	push	ecx
	call	?F@@YAIIII@Z				; F
	add	esp, 12					; 0000000cH
	add	eax, DWORD PTR _b$[ebp]
	mov	edx, DWORD PTR _X$[ebp]
	mov	ecx, DWORD PTR [edx+60]
	lea	edx, DWORD PTR [eax+ecx+1236535329]
	mov	DWORD PTR _t$[ebp], edx
	push	22					; 00000016H
	mov	eax, DWORD PTR _t$[ebp]
	push	eax
	call	?ROTATE_LEFT@@YAIII@Z			; ROTATE_LEFT
	add	esp, 8
	add	eax, DWORD PTR _c$[ebp]
	mov	DWORD PTR _b$[ebp], eax

; 137  : #undef SET
; 138  : 
; 139  : 	/* Round 2.	*/
; 140  : 	/* Let [m_pDigestBuffer	k s	i] denote the operation
; 141  : 	a =	b +	((a	+ G(b,c,d) + X[k] +	T[i]) <<< s). */
; 142  : #define	G(x, y,	z) (((x) & (z))	| ((y) & ~(z)))
; 143  : #define	SET(a, b, c, d,	k, s, Ti)\
; 144  : t =	a +	G(b,c,d) + X[k]	+ Ti;\
; 145  : a =	ROTATE_LEFT(t, s) +	b
; 146  : 	/* Do the following	16 operations. */
; 147  : 	SET(a, b, c, d,	1, 5, T17);

	mov	ecx, DWORD PTR _b$[ebp]
	and	ecx, DWORD PTR _d$[ebp]
	mov	edx, DWORD PTR _d$[ebp]
	not	edx
	and	edx, DWORD PTR _c$[ebp]
	or	ecx, edx
	add	ecx, DWORD PTR _a$[ebp]
	mov	eax, DWORD PTR _X$[ebp]
	mov	edx, DWORD PTR [eax+4]
	lea	eax, DWORD PTR [ecx+edx-165796510]
	mov	DWORD PTR _t$[ebp], eax
	push	5
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	call	?ROTATE_LEFT@@YAIII@Z			; ROTATE_LEFT
	add	esp, 8
	add	eax, DWORD PTR _b$[ebp]
	mov	DWORD PTR _a$[ebp], eax

; 148  : 	SET(d, a, b, c,	6, 9, T18);

	mov	edx, DWORD PTR _a$[ebp]
	and	edx, DWORD PTR _c$[ebp]
	mov	eax, DWORD PTR _c$[ebp]
	not	eax
	and	eax, DWORD PTR _b$[ebp]
	or	edx, eax
	add	edx, DWORD PTR _d$[ebp]
	mov	ecx, DWORD PTR _X$[ebp]
	mov	eax, DWORD PTR [ecx+24]
	lea	ecx, DWORD PTR [edx+eax-1069501632]
	mov	DWORD PTR _t$[ebp], ecx
	push	9
	mov	edx, DWORD PTR _t$[ebp]
	push	edx
	call	?ROTATE_LEFT@@YAIII@Z			; ROTATE_LEFT
	add	esp, 8
	add	eax, DWORD PTR _a$[ebp]
	mov	DWORD PTR _d$[ebp], eax

; 149  : 	SET(c, d, a, b,	11,	14,	T19);

	mov	eax, DWORD PTR _d$[ebp]
	and	eax, DWORD PTR _b$[ebp]
	mov	ecx, DWORD PTR _b$[ebp]
	not	ecx
	and	ecx, DWORD PTR _a$[ebp]
	or	eax, ecx
	add	eax, DWORD PTR _c$[ebp]
	mov	edx, DWORD PTR _X$[ebp]
	mov	ecx, DWORD PTR [edx+44]
	lea	edx, DWORD PTR [eax+ecx+643717713]
	mov	DWORD PTR _t$[ebp], edx
	push	14					; 0000000eH
	mov	eax, DWORD PTR _t$[ebp]
	push	eax
	call	?ROTATE_LEFT@@YAIII@Z			; ROTATE_LEFT
	add	esp, 8
	add	eax, DWORD PTR _d$[ebp]
	mov	DWORD PTR _c$[ebp], eax

; 150  : 	SET(b, c, d, a,	0, 20, T20);

	mov	ecx, DWORD PTR _c$[ebp]
	and	ecx, DWORD PTR _a$[ebp]
	mov	edx, DWORD PTR _a$[ebp]
	not	edx
	and	edx, DWORD PTR _d$[ebp]
	or	ecx, edx
	add	ecx, DWORD PTR _b$[ebp]
	mov	eax, DWORD PTR _X$[ebp]
	mov	edx, DWORD PTR [eax]
	lea	eax, DWORD PTR [ecx+edx-373897302]
	mov	DWORD PTR _t$[ebp], eax
	push	20					; 00000014H
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	call	?ROTATE_LEFT@@YAIII@Z			; ROTATE_LEFT
	add	esp, 8
	add	eax, DWORD PTR _c$[ebp]
	mov	DWORD PTR _b$[ebp], eax

; 151  : 	SET(a, b, c, d,	5, 5, T21);

	mov	edx, DWORD PTR _b$[ebp]
	and	edx, DWORD PTR _d$[ebp]
	mov	eax, DWORD PTR _d$[ebp]
	not	eax
	and	eax, DWORD PTR _c$[ebp]
	or	edx, eax
	add	edx, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR _X$[ebp]
	mov	eax, DWORD PTR [ecx+20]
	lea	ecx, DWORD PTR [edx+eax-701558691]
	mov	DWORD PTR _t$[ebp], ecx
	push	5
	mov	edx, DWORD PTR _t$[ebp]
	push	edx
	call	?ROTATE_LEFT@@YAIII@Z			; ROTATE_LEFT
	add	esp, 8
	add	eax, DWORD PTR _b$[ebp]
	mov	DWORD PTR _a$[ebp], eax

; 152  : 	SET(d, a, b, c,	10,	9, T22);

	mov	eax, DWORD PTR _a$[ebp]
	and	eax, DWORD PTR _c$[ebp]
	mov	ecx, DWORD PTR _c$[ebp]
	not	ecx
	and	ecx, DWORD PTR _b$[ebp]
	or	eax, ecx
	add	eax, DWORD PTR _d$[ebp]
	mov	edx, DWORD PTR _X$[ebp]
	mov	ecx, DWORD PTR [edx+40]
	lea	edx, DWORD PTR [eax+ecx+38016083]
	mov	DWORD PTR _t$[ebp], edx
	push	9
	mov	eax, DWORD PTR _t$[ebp]
	push	eax
	call	?ROTATE_LEFT@@YAIII@Z			; ROTATE_LEFT
	add	esp, 8
	add	eax, DWORD PTR _a$[ebp]
	mov	DWORD PTR _d$[ebp], eax

; 153  : 	SET(c, d, a, b,	15,	14,	T23);

	mov	ecx, DWORD PTR _d$[ebp]
	and	ecx, DWORD PTR _b$[ebp]
	mov	edx, DWORD PTR _b$[ebp]
	not	edx
	and	edx, DWORD PTR _a$[ebp]
	or	ecx, edx
	add	ecx, DWORD PTR _c$[ebp]
	mov	eax, DWORD PTR _X$[ebp]
	mov	edx, DWORD PTR [eax+60]
	lea	eax, DWORD PTR [ecx+edx-660478335]
	mov	DWORD PTR _t$[ebp], eax
	push	14					; 0000000eH
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	call	?ROTATE_LEFT@@YAIII@Z			; ROTATE_LEFT
	add	esp, 8
	add	eax, DWORD PTR _d$[ebp]
	mov	DWORD PTR _c$[ebp], eax

; 154  : 	SET(b, c, d, a,	4, 20, T24);

	mov	edx, DWORD PTR _c$[ebp]
	and	edx, DWORD PTR _a$[ebp]
	mov	eax, DWORD PTR _a$[ebp]
	not	eax
	and	eax, DWORD PTR _d$[ebp]
	or	edx, eax
	add	edx, DWORD PTR _b$[ebp]
	mov	ecx, DWORD PTR _X$[ebp]
	mov	eax, DWORD PTR [ecx+16]
	lea	ecx, DWORD PTR [edx+eax-405537848]
	mov	DWORD PTR _t$[ebp], ecx
	push	20					; 00000014H
	mov	edx, DWORD PTR _t$[ebp]
	push	edx
	call	?ROTATE_LEFT@@YAIII@Z			; ROTATE_LEFT
	add	esp, 8
	add	eax, DWORD PTR _c$[ebp]
	mov	DWORD PTR _b$[ebp], eax

; 155  : 	SET(a, b, c, d,	9, 5, T25);

	mov	eax, DWORD PTR _b$[ebp]
	and	eax, DWORD PTR _d$[ebp]
	mov	ecx, DWORD PTR _d$[ebp]
	not	ecx
	and	ecx, DWORD PTR _c$[ebp]
	or	eax, ecx
	add	eax, DWORD PTR _a$[ebp]
	mov	edx, DWORD PTR _X$[ebp]
	mov	ecx, DWORD PTR [edx+36]
	lea	edx, DWORD PTR [eax+ecx+568446438]
	mov	DWORD PTR _t$[ebp], edx
	push	5
	mov	eax, DWORD PTR _t$[ebp]
	push	eax
	call	?ROTATE_LEFT@@YAIII@Z			; ROTATE_LEFT
	add	esp, 8
	add	eax, DWORD PTR _b$[ebp]
	mov	DWORD PTR _a$[ebp], eax

; 156  : 	SET(d, a, b, c,	14,	9, T26);

	mov	ecx, DWORD PTR _a$[ebp]
	and	ecx, DWORD PTR _c$[ebp]
	mov	edx, DWORD PTR _c$[ebp]
	not	edx
	and	edx, DWORD PTR _b$[ebp]
	or	ecx, edx
	add	ecx, DWORD PTR _d$[ebp]
	mov	eax, DWORD PTR _X$[ebp]
	mov	edx, DWORD PTR [eax+56]
	lea	eax, DWORD PTR [ecx+edx-1019803690]
	mov	DWORD PTR _t$[ebp], eax
	push	9
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	call	?ROTATE_LEFT@@YAIII@Z			; ROTATE_LEFT
	add	esp, 8
	add	eax, DWORD PTR _a$[ebp]
	mov	DWORD PTR _d$[ebp], eax

; 157  : 	SET(c, d, a, b,	3, 14, T27);

	mov	edx, DWORD PTR _d$[ebp]
	and	edx, DWORD PTR _b$[ebp]
	mov	eax, DWORD PTR _b$[ebp]
	not	eax
	and	eax, DWORD PTR _a$[ebp]
	or	edx, eax
	add	edx, DWORD PTR _c$[ebp]
	mov	ecx, DWORD PTR _X$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	lea	ecx, DWORD PTR [edx+eax-187363961]
	mov	DWORD PTR _t$[ebp], ecx
	push	14					; 0000000eH
	mov	edx, DWORD PTR _t$[ebp]
	push	edx
	call	?ROTATE_LEFT@@YAIII@Z			; ROTATE_LEFT
	add	esp, 8
	add	eax, DWORD PTR _d$[ebp]
	mov	DWORD PTR _c$[ebp], eax

; 158  : 	SET(b, c, d, a,	8, 20, T28);

	mov	eax, DWORD PTR _c$[ebp]
	and	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR _a$[ebp]
	not	ecx
	and	ecx, DWORD PTR _d$[ebp]
	or	eax, ecx
	add	eax, DWORD PTR _b$[ebp]
	mov	edx, DWORD PTR _X$[ebp]
	mov	ecx, DWORD PTR [edx+32]
	lea	edx, DWORD PTR [eax+ecx+1163531501]
	mov	DWORD PTR _t$[ebp], edx
	push	20					; 00000014H
	mov	eax, DWORD PTR _t$[ebp]
	push	eax
	call	?ROTATE_LEFT@@YAIII@Z			; ROTATE_LEFT
	add	esp, 8
	add	eax, DWORD PTR _c$[ebp]
	mov	DWORD PTR _b$[ebp], eax

; 159  : 	SET(a, b, c, d,	13,	5, T29);

	mov	ecx, DWORD PTR _b$[ebp]
	and	ecx, DWORD PTR _d$[ebp]
	mov	edx, DWORD PTR _d$[ebp]
	not	edx
	and	edx, DWORD PTR _c$[ebp]
	or	ecx, edx
	add	ecx, DWORD PTR _a$[ebp]
	mov	eax, DWORD PTR _X$[ebp]
	mov	edx, DWORD PTR [eax+52]
	lea	eax, DWORD PTR [ecx+edx-1444681467]
	mov	DWORD PTR _t$[ebp], eax
	push	5
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	call	?ROTATE_LEFT@@YAIII@Z			; ROTATE_LEFT
	add	esp, 8
	add	eax, DWORD PTR _b$[ebp]
	mov	DWORD PTR _a$[ebp], eax

; 160  : 	SET(d, a, b, c,	2, 9, T30);

	mov	edx, DWORD PTR _a$[ebp]
	and	edx, DWORD PTR _c$[ebp]
	mov	eax, DWORD PTR _c$[ebp]
	not	eax
	and	eax, DWORD PTR _b$[ebp]
	or	edx, eax
	add	edx, DWORD PTR _d$[ebp]
	mov	ecx, DWORD PTR _X$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	lea	ecx, DWORD PTR [edx+eax-51403784]
	mov	DWORD PTR _t$[ebp], ecx
	push	9
	mov	edx, DWORD PTR _t$[ebp]
	push	edx
	call	?ROTATE_LEFT@@YAIII@Z			; ROTATE_LEFT
	add	esp, 8
	add	eax, DWORD PTR _a$[ebp]
	mov	DWORD PTR _d$[ebp], eax

; 161  : 	SET(c, d, a, b,	7, 14, T31);

	mov	eax, DWORD PTR _d$[ebp]
	and	eax, DWORD PTR _b$[ebp]
	mov	ecx, DWORD PTR _b$[ebp]
	not	ecx
	and	ecx, DWORD PTR _a$[ebp]
	or	eax, ecx
	add	eax, DWORD PTR _c$[ebp]
	mov	edx, DWORD PTR _X$[ebp]
	mov	ecx, DWORD PTR [edx+28]
	lea	edx, DWORD PTR [eax+ecx+1735328473]
	mov	DWORD PTR _t$[ebp], edx
	push	14					; 0000000eH
	mov	eax, DWORD PTR _t$[ebp]
	push	eax
	call	?ROTATE_LEFT@@YAIII@Z			; ROTATE_LEFT
	add	esp, 8
	add	eax, DWORD PTR _d$[ebp]
	mov	DWORD PTR _c$[ebp], eax

; 162  : 	SET(b, c, d, a,	12,	20,	T32);

	mov	ecx, DWORD PTR _c$[ebp]
	and	ecx, DWORD PTR _a$[ebp]
	mov	edx, DWORD PTR _a$[ebp]
	not	edx
	and	edx, DWORD PTR _d$[ebp]
	or	ecx, edx
	add	ecx, DWORD PTR _b$[ebp]
	mov	eax, DWORD PTR _X$[ebp]
	mov	edx, DWORD PTR [eax+48]
	lea	eax, DWORD PTR [ecx+edx-1926607734]
	mov	DWORD PTR _t$[ebp], eax
	push	20					; 00000014H
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	call	?ROTATE_LEFT@@YAIII@Z			; ROTATE_LEFT
	add	esp, 8
	add	eax, DWORD PTR _c$[ebp]
	mov	DWORD PTR _b$[ebp], eax

; 163  : #undef SET
; 164  : #undef G
; 165  : 	/* Round 3.	*/
; 166  : 	/* Let [m_pDigestBuffer	k s	t] denote the operation
; 167  : 	a =	b +	((a	+ H(b,c,d) + X[k] +	T[i]) <<< s). */
; 168  : #define	H(x, y,	z) ((x)	^ (y) ^	(z))
; 169  : #define	SET(a, b, c, d,	k, s, Ti)\
; 170  : t =	a +	H(b,c,d) + X[k]	+ Ti;\
; 171  : a =	ROTATE_LEFT(t, s) +	b
; 172  : 	/* Do the following	16 operations. */
; 173  : 	SET(a, b, c, d,	5, 4, T33);

	mov	edx, DWORD PTR _b$[ebp]
	xor	edx, DWORD PTR _c$[ebp]
	xor	edx, DWORD PTR _d$[ebp]
	add	edx, DWORD PTR _a$[ebp]
	mov	eax, DWORD PTR _X$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	lea	edx, DWORD PTR [edx+ecx-378558]
	mov	DWORD PTR _t$[ebp], edx
	push	4
	mov	eax, DWORD PTR _t$[ebp]
	push	eax
	call	?ROTATE_LEFT@@YAIII@Z			; ROTATE_LEFT
	add	esp, 8
	add	eax, DWORD PTR _b$[ebp]
	mov	DWORD PTR _a$[ebp], eax

; 174  : 	SET(d, a, b, c,	8, 11, T34);

	mov	ecx, DWORD PTR _a$[ebp]
	xor	ecx, DWORD PTR _b$[ebp]
	xor	ecx, DWORD PTR _c$[ebp]
	add	ecx, DWORD PTR _d$[ebp]
	mov	edx, DWORD PTR _X$[ebp]
	mov	eax, DWORD PTR [edx+32]
	lea	ecx, DWORD PTR [ecx+eax-2022574463]
	mov	DWORD PTR _t$[ebp], ecx
	push	11					; 0000000bH
	mov	edx, DWORD PTR _t$[ebp]
	push	edx
	call	?ROTATE_LEFT@@YAIII@Z			; ROTATE_LEFT
	add	esp, 8
	add	eax, DWORD PTR _a$[ebp]
	mov	DWORD PTR _d$[ebp], eax

; 175  : 	SET(c, d, a, b,	11,	16,	T35);

	mov	eax, DWORD PTR _d$[ebp]
	xor	eax, DWORD PTR _a$[ebp]
	xor	eax, DWORD PTR _b$[ebp]
	add	eax, DWORD PTR _c$[ebp]
	mov	ecx, DWORD PTR _X$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	lea	eax, DWORD PTR [eax+edx+1839030562]
	mov	DWORD PTR _t$[ebp], eax
	push	16					; 00000010H
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	call	?ROTATE_LEFT@@YAIII@Z			; ROTATE_LEFT
	add	esp, 8
	add	eax, DWORD PTR _d$[ebp]
	mov	DWORD PTR _c$[ebp], eax

; 176  : 	SET(b, c, d, a,	14,	23,	T36);

	mov	edx, DWORD PTR _c$[ebp]
	xor	edx, DWORD PTR _d$[ebp]
	xor	edx, DWORD PTR _a$[ebp]
	add	edx, DWORD PTR _b$[ebp]
	mov	eax, DWORD PTR _X$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	lea	edx, DWORD PTR [edx+ecx-35309556]
	mov	DWORD PTR _t$[ebp], edx
	push	23					; 00000017H
	mov	eax, DWORD PTR _t$[ebp]
	push	eax
	call	?ROTATE_LEFT@@YAIII@Z			; ROTATE_LEFT
	add	esp, 8
	add	eax, DWORD PTR _c$[ebp]
	mov	DWORD PTR _b$[ebp], eax

; 177  : 	SET(a, b, c, d,	1, 4, T37);

	mov	ecx, DWORD PTR _b$[ebp]
	xor	ecx, DWORD PTR _c$[ebp]
	xor	ecx, DWORD PTR _d$[ebp]
	add	ecx, DWORD PTR _a$[ebp]
	mov	edx, DWORD PTR _X$[ebp]
	mov	eax, DWORD PTR [edx+4]
	lea	ecx, DWORD PTR [ecx+eax-1530992060]
	mov	DWORD PTR _t$[ebp], ecx
	push	4
	mov	edx, DWORD PTR _t$[ebp]
	push	edx
	call	?ROTATE_LEFT@@YAIII@Z			; ROTATE_LEFT
	add	esp, 8
	add	eax, DWORD PTR _b$[ebp]
	mov	DWORD PTR _a$[ebp], eax

; 178  : 	SET(d, a, b, c,	4, 11, T38);

	mov	eax, DWORD PTR _a$[ebp]
	xor	eax, DWORD PTR _b$[ebp]
	xor	eax, DWORD PTR _c$[ebp]
	add	eax, DWORD PTR _d$[ebp]
	mov	ecx, DWORD PTR _X$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	lea	eax, DWORD PTR [eax+edx+1272893353]
	mov	DWORD PTR _t$[ebp], eax
	push	11					; 0000000bH
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	call	?ROTATE_LEFT@@YAIII@Z			; ROTATE_LEFT
	add	esp, 8
	add	eax, DWORD PTR _a$[ebp]
	mov	DWORD PTR _d$[ebp], eax

; 179  : 	SET(c, d, a, b,	7, 16, T39);

	mov	edx, DWORD PTR _d$[ebp]
	xor	edx, DWORD PTR _a$[ebp]
	xor	edx, DWORD PTR _b$[ebp]
	add	edx, DWORD PTR _c$[ebp]
	mov	eax, DWORD PTR _X$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	lea	edx, DWORD PTR [edx+ecx-155497632]
	mov	DWORD PTR _t$[ebp], edx
	push	16					; 00000010H
	mov	eax, DWORD PTR _t$[ebp]
	push	eax
	call	?ROTATE_LEFT@@YAIII@Z			; ROTATE_LEFT
	add	esp, 8
	add	eax, DWORD PTR _d$[ebp]
	mov	DWORD PTR _c$[ebp], eax

; 180  : 	SET(b, c, d, a,	10,	23,	T40);

	mov	ecx, DWORD PTR _c$[ebp]
	xor	ecx, DWORD PTR _d$[ebp]
	xor	ecx, DWORD PTR _a$[ebp]
	add	ecx, DWORD PTR _b$[ebp]
	mov	edx, DWORD PTR _X$[ebp]
	mov	eax, DWORD PTR [edx+40]
	lea	ecx, DWORD PTR [ecx+eax-1094730640]
	mov	DWORD PTR _t$[ebp], ecx
	push	23					; 00000017H
	mov	edx, DWORD PTR _t$[ebp]
	push	edx
	call	?ROTATE_LEFT@@YAIII@Z			; ROTATE_LEFT
	add	esp, 8
	add	eax, DWORD PTR _c$[ebp]
	mov	DWORD PTR _b$[ebp], eax

; 181  : 	SET(a, b, c, d,	13,	4, T41);

	mov	eax, DWORD PTR _b$[ebp]
	xor	eax, DWORD PTR _c$[ebp]
	xor	eax, DWORD PTR _d$[ebp]
	add	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR _X$[ebp]
	mov	edx, DWORD PTR [ecx+52]
	lea	eax, DWORD PTR [eax+edx+681279174]
	mov	DWORD PTR _t$[ebp], eax
	push	4
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	call	?ROTATE_LEFT@@YAIII@Z			; ROTATE_LEFT
	add	esp, 8
	add	eax, DWORD PTR _b$[ebp]
	mov	DWORD PTR _a$[ebp], eax

; 182  : 	SET(d, a, b, c,	0, 11, T42);

	mov	edx, DWORD PTR _a$[ebp]
	xor	edx, DWORD PTR _b$[ebp]
	xor	edx, DWORD PTR _c$[ebp]
	add	edx, DWORD PTR _d$[ebp]
	mov	eax, DWORD PTR _X$[ebp]
	mov	ecx, DWORD PTR [eax]
	lea	edx, DWORD PTR [edx+ecx-358537222]
	mov	DWORD PTR _t$[ebp], edx
	push	11					; 0000000bH
	mov	eax, DWORD PTR _t$[ebp]
	push	eax
	call	?ROTATE_LEFT@@YAIII@Z			; ROTATE_LEFT
	add	esp, 8
	add	eax, DWORD PTR _a$[ebp]
	mov	DWORD PTR _d$[ebp], eax

; 183  : 	SET(c, d, a, b,	3, 16, T43);

	mov	ecx, DWORD PTR _d$[ebp]
	xor	ecx, DWORD PTR _a$[ebp]
	xor	ecx, DWORD PTR _b$[ebp]
	add	ecx, DWORD PTR _c$[ebp]
	mov	edx, DWORD PTR _X$[ebp]
	mov	eax, DWORD PTR [edx+12]
	lea	ecx, DWORD PTR [ecx+eax-722521979]
	mov	DWORD PTR _t$[ebp], ecx
	push	16					; 00000010H
	mov	edx, DWORD PTR _t$[ebp]
	push	edx
	call	?ROTATE_LEFT@@YAIII@Z			; ROTATE_LEFT
	add	esp, 8
	add	eax, DWORD PTR _d$[ebp]
	mov	DWORD PTR _c$[ebp], eax

; 184  : 	SET(b, c, d, a,	6, 23, T44);

	mov	eax, DWORD PTR _c$[ebp]
	xor	eax, DWORD PTR _d$[ebp]
	xor	eax, DWORD PTR _a$[ebp]
	add	eax, DWORD PTR _b$[ebp]
	mov	ecx, DWORD PTR _X$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	lea	eax, DWORD PTR [eax+edx+76029189]
	mov	DWORD PTR _t$[ebp], eax
	push	23					; 00000017H
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	call	?ROTATE_LEFT@@YAIII@Z			; ROTATE_LEFT
	add	esp, 8
	add	eax, DWORD PTR _c$[ebp]
	mov	DWORD PTR _b$[ebp], eax

; 185  : 	SET(a, b, c, d,	9, 4, T45);

	mov	edx, DWORD PTR _b$[ebp]
	xor	edx, DWORD PTR _c$[ebp]
	xor	edx, DWORD PTR _d$[ebp]
	add	edx, DWORD PTR _a$[ebp]
	mov	eax, DWORD PTR _X$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	lea	edx, DWORD PTR [edx+ecx-640364487]
	mov	DWORD PTR _t$[ebp], edx
	push	4
	mov	eax, DWORD PTR _t$[ebp]
	push	eax
	call	?ROTATE_LEFT@@YAIII@Z			; ROTATE_LEFT
	add	esp, 8
	add	eax, DWORD PTR _b$[ebp]
	mov	DWORD PTR _a$[ebp], eax

; 186  : 	SET(d, a, b, c,	12,	11,	T46);

	mov	ecx, DWORD PTR _a$[ebp]
	xor	ecx, DWORD PTR _b$[ebp]
	xor	ecx, DWORD PTR _c$[ebp]
	add	ecx, DWORD PTR _d$[ebp]
	mov	edx, DWORD PTR _X$[ebp]
	mov	eax, DWORD PTR [edx+48]
	lea	ecx, DWORD PTR [ecx+eax-421815835]
	mov	DWORD PTR _t$[ebp], ecx
	push	11					; 0000000bH
	mov	edx, DWORD PTR _t$[ebp]
	push	edx
	call	?ROTATE_LEFT@@YAIII@Z			; ROTATE_LEFT
	add	esp, 8
	add	eax, DWORD PTR _a$[ebp]
	mov	DWORD PTR _d$[ebp], eax

; 187  : 	SET(c, d, a, b,	15,	16,	T47);

	mov	eax, DWORD PTR _d$[ebp]
	xor	eax, DWORD PTR _a$[ebp]
	xor	eax, DWORD PTR _b$[ebp]
	add	eax, DWORD PTR _c$[ebp]
	mov	ecx, DWORD PTR _X$[ebp]
	mov	edx, DWORD PTR [ecx+60]
	lea	eax, DWORD PTR [eax+edx+530742520]
	mov	DWORD PTR _t$[ebp], eax
	push	16					; 00000010H
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	call	?ROTATE_LEFT@@YAIII@Z			; ROTATE_LEFT
	add	esp, 8
	add	eax, DWORD PTR _d$[ebp]
	mov	DWORD PTR _c$[ebp], eax

; 188  : 	SET(b, c, d, a,	2, 23, T48);

	mov	edx, DWORD PTR _c$[ebp]
	xor	edx, DWORD PTR _d$[ebp]
	xor	edx, DWORD PTR _a$[ebp]
	add	edx, DWORD PTR _b$[ebp]
	mov	eax, DWORD PTR _X$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	lea	edx, DWORD PTR [edx+ecx-995338651]
	mov	DWORD PTR _t$[ebp], edx
	push	23					; 00000017H
	mov	eax, DWORD PTR _t$[ebp]
	push	eax
	call	?ROTATE_LEFT@@YAIII@Z			; ROTATE_LEFT
	add	esp, 8
	add	eax, DWORD PTR _c$[ebp]
	mov	DWORD PTR _b$[ebp], eax

; 189  : #undef SET
; 190  : #undef H
; 191  : 	/* Round 4.	*/
; 192  : 	/* Let [m_pDigestBuffer	k s	t] denote the operation
; 193  : 	a =	b +	((a	+ I(b,c,d) + X[k] +	T[i]) <<< s). */
; 194  : #define	I(x, y,	z) ((y)	^ ((x) | ~(z)))
; 195  : #define	SET(a, b, c, d,	k, s, Ti)\
; 196  : t =	a +	I(b,c,d) + X[k]	+ Ti;\
; 197  : a =	ROTATE_LEFT(t, s) +	b
; 198  : 	/* Do the following	16 operations. */
; 199  : 	SET(a, b, c, d,	0, 6, T49);

	mov	ecx, DWORD PTR _d$[ebp]
	not	ecx
	or	ecx, DWORD PTR _b$[ebp]
	xor	ecx, DWORD PTR _c$[ebp]
	add	ecx, DWORD PTR _a$[ebp]
	mov	edx, DWORD PTR _X$[ebp]
	mov	eax, DWORD PTR [edx]
	lea	ecx, DWORD PTR [ecx+eax-198630844]
	mov	DWORD PTR _t$[ebp], ecx
	push	6
	mov	edx, DWORD PTR _t$[ebp]
	push	edx
	call	?ROTATE_LEFT@@YAIII@Z			; ROTATE_LEFT
	add	esp, 8
	add	eax, DWORD PTR _b$[ebp]
	mov	DWORD PTR _a$[ebp], eax

; 200  : 	SET(d, a, b, c,	7, 10, T50);

	mov	eax, DWORD PTR _c$[ebp]
	not	eax
	or	eax, DWORD PTR _a$[ebp]
	xor	eax, DWORD PTR _b$[ebp]
	add	eax, DWORD PTR _d$[ebp]
	mov	ecx, DWORD PTR _X$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	lea	eax, DWORD PTR [eax+edx+1126891415]
	mov	DWORD PTR _t$[ebp], eax
	push	10					; 0000000aH
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	call	?ROTATE_LEFT@@YAIII@Z			; ROTATE_LEFT
	add	esp, 8
	add	eax, DWORD PTR _a$[ebp]
	mov	DWORD PTR _d$[ebp], eax

; 201  : 	SET(c, d, a, b,	14,	15,	T51);

	mov	edx, DWORD PTR _b$[ebp]
	not	edx
	or	edx, DWORD PTR _d$[ebp]
	xor	edx, DWORD PTR _a$[ebp]
	add	edx, DWORD PTR _c$[ebp]
	mov	eax, DWORD PTR _X$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	lea	edx, DWORD PTR [edx+ecx-1416354905]
	mov	DWORD PTR _t$[ebp], edx
	push	15					; 0000000fH
	mov	eax, DWORD PTR _t$[ebp]
	push	eax
	call	?ROTATE_LEFT@@YAIII@Z			; ROTATE_LEFT
	add	esp, 8
	add	eax, DWORD PTR _d$[ebp]
	mov	DWORD PTR _c$[ebp], eax

; 202  : 	SET(b, c, d, a,	5, 21, T52);

	mov	ecx, DWORD PTR _a$[ebp]
	not	ecx
	or	ecx, DWORD PTR _c$[ebp]
	xor	ecx, DWORD PTR _d$[ebp]
	add	ecx, DWORD PTR _b$[ebp]
	mov	edx, DWORD PTR _X$[ebp]
	mov	eax, DWORD PTR [edx+20]
	lea	ecx, DWORD PTR [ecx+eax-57434055]
	mov	DWORD PTR _t$[ebp], ecx
	push	21					; 00000015H
	mov	edx, DWORD PTR _t$[ebp]
	push	edx
	call	?ROTATE_LEFT@@YAIII@Z			; ROTATE_LEFT
	add	esp, 8
	add	eax, DWORD PTR _c$[ebp]
	mov	DWORD PTR _b$[ebp], eax

; 203  : 	SET(a, b, c, d,	12,	6, T53);

	mov	eax, DWORD PTR _d$[ebp]
	not	eax
	or	eax, DWORD PTR _b$[ebp]
	xor	eax, DWORD PTR _c$[ebp]
	add	eax, DWORD PTR _a$[ebp]
	mov	ecx, DWORD PTR _X$[ebp]
	mov	edx, DWORD PTR [ecx+48]
	lea	eax, DWORD PTR [eax+edx+1700485571]
	mov	DWORD PTR _t$[ebp], eax
	push	6
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	call	?ROTATE_LEFT@@YAIII@Z			; ROTATE_LEFT
	add	esp, 8
	add	eax, DWORD PTR _b$[ebp]
	mov	DWORD PTR _a$[ebp], eax

; 204  : 	SET(d, a, b, c,	3, 10, T54);

	mov	edx, DWORD PTR _c$[ebp]
	not	edx
	or	edx, DWORD PTR _a$[ebp]
	xor	edx, DWORD PTR _b$[ebp]
	add	edx, DWORD PTR _d$[ebp]
	mov	eax, DWORD PTR _X$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	lea	edx, DWORD PTR [edx+ecx-1894986606]
	mov	DWORD PTR _t$[ebp], edx
	push	10					; 0000000aH
	mov	eax, DWORD PTR _t$[ebp]
	push	eax
	call	?ROTATE_LEFT@@YAIII@Z			; ROTATE_LEFT
	add	esp, 8
	add	eax, DWORD PTR _a$[ebp]
	mov	DWORD PTR _d$[ebp], eax

; 205  : 	SET(c, d, a, b,	10,	15,	T55);

	mov	ecx, DWORD PTR _b$[ebp]
	not	ecx
	or	ecx, DWORD PTR _d$[ebp]
	xor	ecx, DWORD PTR _a$[ebp]
	add	ecx, DWORD PTR _c$[ebp]
	mov	edx, DWORD PTR _X$[ebp]
	mov	eax, DWORD PTR [edx+40]
	lea	ecx, DWORD PTR [ecx+eax-1051523]
	mov	DWORD PTR _t$[ebp], ecx
	push	15					; 0000000fH
	mov	edx, DWORD PTR _t$[ebp]
	push	edx
	call	?ROTATE_LEFT@@YAIII@Z			; ROTATE_LEFT
	add	esp, 8
	add	eax, DWORD PTR _d$[ebp]
	mov	DWORD PTR _c$[ebp], eax

; 206  : 	SET(b, c, d, a,	1, 21, T56);

	mov	eax, DWORD PTR _a$[ebp]
	not	eax
	or	eax, DWORD PTR _c$[ebp]
	xor	eax, DWORD PTR _d$[ebp]
	add	eax, DWORD PTR _b$[ebp]
	mov	ecx, DWORD PTR _X$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	lea	eax, DWORD PTR [eax+edx-2054922799]
	mov	DWORD PTR _t$[ebp], eax
	push	21					; 00000015H
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	call	?ROTATE_LEFT@@YAIII@Z			; ROTATE_LEFT
	add	esp, 8
	add	eax, DWORD PTR _c$[ebp]
	mov	DWORD PTR _b$[ebp], eax

; 207  : 	SET(a, b, c, d,	8, 6, T57);

	mov	edx, DWORD PTR _d$[ebp]
	not	edx
	or	edx, DWORD PTR _b$[ebp]
	xor	edx, DWORD PTR _c$[ebp]
	add	edx, DWORD PTR _a$[ebp]
	mov	eax, DWORD PTR _X$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	lea	edx, DWORD PTR [edx+ecx+1873313359]
	mov	DWORD PTR _t$[ebp], edx
	push	6
	mov	eax, DWORD PTR _t$[ebp]
	push	eax
	call	?ROTATE_LEFT@@YAIII@Z			; ROTATE_LEFT
	add	esp, 8
	add	eax, DWORD PTR _b$[ebp]
	mov	DWORD PTR _a$[ebp], eax

; 208  : 	SET(d, a, b, c,	15,	10,	T58);

	mov	ecx, DWORD PTR _c$[ebp]
	not	ecx
	or	ecx, DWORD PTR _a$[ebp]
	xor	ecx, DWORD PTR _b$[ebp]
	add	ecx, DWORD PTR _d$[ebp]
	mov	edx, DWORD PTR _X$[ebp]
	mov	eax, DWORD PTR [edx+60]
	lea	ecx, DWORD PTR [ecx+eax-30611744]
	mov	DWORD PTR _t$[ebp], ecx
	push	10					; 0000000aH
	mov	edx, DWORD PTR _t$[ebp]
	push	edx
	call	?ROTATE_LEFT@@YAIII@Z			; ROTATE_LEFT
	add	esp, 8
	add	eax, DWORD PTR _a$[ebp]
	mov	DWORD PTR _d$[ebp], eax

; 209  : 	SET(c, d, a, b,	6, 15, T59);

	mov	eax, DWORD PTR _b$[ebp]
	not	eax
	or	eax, DWORD PTR _d$[ebp]
	xor	eax, DWORD PTR _a$[ebp]
	add	eax, DWORD PTR _c$[ebp]
	mov	ecx, DWORD PTR _X$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	lea	eax, DWORD PTR [eax+edx-1560198380]
	mov	DWORD PTR _t$[ebp], eax
	push	15					; 0000000fH
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	call	?ROTATE_LEFT@@YAIII@Z			; ROTATE_LEFT
	add	esp, 8
	add	eax, DWORD PTR _d$[ebp]
	mov	DWORD PTR _c$[ebp], eax

; 210  : 	SET(b, c, d, a,	13,	21,	T60);

	mov	edx, DWORD PTR _a$[ebp]
	not	edx
	or	edx, DWORD PTR _c$[ebp]
	xor	edx, DWORD PTR _d$[ebp]
	add	edx, DWORD PTR _b$[ebp]
	mov	eax, DWORD PTR _X$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	lea	edx, DWORD PTR [edx+ecx+1309151649]
	mov	DWORD PTR _t$[ebp], edx
	push	21					; 00000015H
	mov	eax, DWORD PTR _t$[ebp]
	push	eax
	call	?ROTATE_LEFT@@YAIII@Z			; ROTATE_LEFT
	add	esp, 8
	add	eax, DWORD PTR _c$[ebp]
	mov	DWORD PTR _b$[ebp], eax

; 211  : 	SET(a, b, c, d,	4, 6, T61);

	mov	ecx, DWORD PTR _d$[ebp]
	not	ecx
	or	ecx, DWORD PTR _b$[ebp]
	xor	ecx, DWORD PTR _c$[ebp]
	add	ecx, DWORD PTR _a$[ebp]
	mov	edx, DWORD PTR _X$[ebp]
	mov	eax, DWORD PTR [edx+16]
	lea	ecx, DWORD PTR [ecx+eax-145523070]
	mov	DWORD PTR _t$[ebp], ecx
	push	6
	mov	edx, DWORD PTR _t$[ebp]
	push	edx
	call	?ROTATE_LEFT@@YAIII@Z			; ROTATE_LEFT
	add	esp, 8
	add	eax, DWORD PTR _b$[ebp]
	mov	DWORD PTR _a$[ebp], eax

; 212  : 	SET(d, a, b, c,	11,	10,	T62);

	mov	eax, DWORD PTR _c$[ebp]
	not	eax
	or	eax, DWORD PTR _a$[ebp]
	xor	eax, DWORD PTR _b$[ebp]
	add	eax, DWORD PTR _d$[ebp]
	mov	ecx, DWORD PTR _X$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	lea	eax, DWORD PTR [eax+edx-1120210379]
	mov	DWORD PTR _t$[ebp], eax
	push	10					; 0000000aH
	mov	ecx, DWORD PTR _t$[ebp]
	push	ecx
	call	?ROTATE_LEFT@@YAIII@Z			; ROTATE_LEFT
	add	esp, 8
	add	eax, DWORD PTR _a$[ebp]
	mov	DWORD PTR _d$[ebp], eax

; 213  : 	SET(c, d, a, b,	2, 15, T63);

	mov	edx, DWORD PTR _b$[ebp]
	not	edx
	or	edx, DWORD PTR _d$[ebp]
	xor	edx, DWORD PTR _a$[ebp]
	add	edx, DWORD PTR _c$[ebp]
	mov	eax, DWORD PTR _X$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	lea	edx, DWORD PTR [edx+ecx+718787259]
	mov	DWORD PTR _t$[ebp], edx
	push	15					; 0000000fH
	mov	eax, DWORD PTR _t$[ebp]
	push	eax
	call	?ROTATE_LEFT@@YAIII@Z			; ROTATE_LEFT
	add	esp, 8
	add	eax, DWORD PTR _d$[ebp]
	mov	DWORD PTR _c$[ebp], eax

; 214  : 	SET(b, c, d, a,	9, 21, T64);

	mov	ecx, DWORD PTR _a$[ebp]
	not	ecx
	or	ecx, DWORD PTR _c$[ebp]
	xor	ecx, DWORD PTR _d$[ebp]
	add	ecx, DWORD PTR _b$[ebp]
	mov	edx, DWORD PTR _X$[ebp]
	mov	eax, DWORD PTR [edx+36]
	lea	ecx, DWORD PTR [ecx+eax-343485551]
	mov	DWORD PTR _t$[ebp], ecx
	push	21					; 00000015H
	mov	edx, DWORD PTR _t$[ebp]
	push	edx
	call	?ROTATE_LEFT@@YAIII@Z			; ROTATE_LEFT
	add	esp, 8
	add	eax, DWORD PTR _c$[ebp]
	mov	DWORD PTR _b$[ebp], eax

; 215  : #undef SET
; 216  : #undef I
; 217  : 	/* Then	perform	the	following additions. (That is increment	each
; 218  : 	of the four	registers by the value it had before this block
; 219  : 	was	started.) */
; 220  : 	m_pDigestBuffer[0] += a;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	add	ecx, DWORD PTR _a$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 221  : 	m_pDigestBuffer[1] += b;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	add	ecx, DWORD PTR _b$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+12], ecx

; 222  : 	m_pDigestBuffer[2] += c;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	add	ecx, DWORD PTR _c$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+16], ecx

; 223  : 	m_pDigestBuffer[3] += d;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	add	ecx, DWORD PTR _d$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+20], ecx

; 224  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?Process@CMd5@@AAEXPBE@Z ENDP				; CMd5::Process
; Function compile flags: /Odtp
_x$ = 8						; size = 4
_n$ = 12						; size = 4
?ROTATE_LEFT@@YAIII@Z PROC				; ROTATE_LEFT

; 71   : {

	push	ebp
	mov	ebp, esp

; 72   : 	return (x<<n) | (x >> (32-n));

	mov	eax, DWORD PTR _x$[ebp]
	mov	ecx, DWORD PTR _n$[ebp]
	shl	eax, cl
	mov	ecx, 32					; 00000020H
	sub	ecx, DWORD PTR _n$[ebp]
	mov	edx, DWORD PTR _x$[ebp]
	shr	edx, cl
	or	eax, edx

; 73   : }

	pop	ebp
	ret	0
?ROTATE_LEFT@@YAIII@Z ENDP				; ROTATE_LEFT
; Function compile flags: /Odtp
_x$ = 8						; size = 4
_y$ = 12						; size = 4
_z$ = 16						; size = 4
?F@@YAIIII@Z PROC					; F

; 76   : {

	push	ebp
	mov	ebp, esp

; 77   : 	return (x & y)	| (~x & z);

	mov	eax, DWORD PTR _x$[ebp]
	and	eax, DWORD PTR _y$[ebp]
	mov	ecx, DWORD PTR _x$[ebp]
	not	ecx
	and	ecx, DWORD PTR _z$[ebp]
	or	eax, ecx

; 78   : }

	pop	ebp
	ret	0
?F@@YAIIII@Z ENDP					; F
_TEXT	ENDS
PUBLIC	?Begin@CMd5@@QAEXXZ				; CMd5::Begin
; Function compile flags: /Odtp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Begin@CMd5@@QAEXXZ PROC				; CMd5::Begin
; _this$ = ecx

; 227  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 228  : 	m_pCount[0]	= m_pCount[1] =	0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], 0

; 229  : 	m_pDigestBuffer[0] = 0x67452301;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], 1732584193		; 67452301H

; 230  : 	m_pDigestBuffer[1] = 0xefcdab89;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], -271733879		; efcdab89H

; 231  : 	m_pDigestBuffer[2] = 0x98badcfe;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], -1732584194		; 98badcfeH

; 232  : 	m_pDigestBuffer[3] = 0x10325476;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+20], 271733878		; 10325476H

; 233  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?Begin@CMd5@@QAEXXZ ENDP				; CMd5::Begin
_TEXT	ENDS
PUBLIC	?Append@CMd5@@QAEXPBEI@Z			; CMd5::Append
; Function compile flags: /Odtp
_TEXT	SEGMENT
tv82 = -28						; size = 4
_this$ = -24						; size = 4
_copy$62793 = -20					; size = 4
_nbits$ = -16						; size = 4
_left$ = -12						; size = 4
_offset$ = -8						; size = 4
_p$ = -4						; size = 4
_pData$ = 8						; size = 4
_uLength$ = 12						; size = 4
?Append@CMd5@@QAEXPBEI@Z PROC				; CMd5::Append
; _this$ = ecx

; 236  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR _this$[ebp], ecx

; 237  : 	const unsigned char	*p = pData;

	mov	eax, DWORD PTR _pData$[ebp]
	mov	DWORD PTR _p$[ebp], eax

; 238  : 	unsigned int left =	uLength;

	mov	ecx, DWORD PTR _uLength$[ebp]
	mov	DWORD PTR _left$[ebp], ecx

; 239  : 	unsigned int offset	= (m_pCount[0] >> 3) & 63;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	shr	eax, 3
	and	eax, 63					; 0000003fH
	mov	DWORD PTR _offset$[ebp], eax

; 240  : 	unsigned int nbits = (unsigned int)(uLength	<< 3);

	mov	ecx, DWORD PTR _uLength$[ebp]
	shl	ecx, 3
	mov	DWORD PTR _nbits$[ebp], ecx

; 241  : 
; 242  : 	if (uLength	<= 0)

	cmp	DWORD PTR _uLength$[ebp], 0
	ja	SHORT $LN8@Append

; 243  : 		return;

	jmp	$LN9@Append
$LN8@Append:

; 244  : 
; 245  : 	/* Update the message length. */
; 246  : 	m_pCount[1]	+= uLength >> 29;

	mov	edx, DWORD PTR _uLength$[ebp]
	shr	edx, 29					; 0000001dH
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], edx

; 247  : 	m_pCount[0]	+= nbits;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	add	eax, DWORD PTR _nbits$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 248  : 	if (m_pCount[0]	< nbits)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	cmp	eax, DWORD PTR _nbits$[ebp]
	jae	SHORT $LN7@Append

; 249  : 		m_pCount[1]++;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], edx
$LN7@Append:

; 250  : 
; 251  : 	/* Process an initial partial block. */
; 252  : 	if (offset){

	cmp	DWORD PTR _offset$[ebp], 0
	je	SHORT $LN6@Append

; 253  : 		unsigned int copy =	(offset	+ uLength >	64 ? 64	- offset : uLength);

	mov	ecx, DWORD PTR _offset$[ebp]
	add	ecx, DWORD PTR _uLength$[ebp]
	cmp	ecx, 64					; 00000040H
	jbe	SHORT $LN11@Append
	mov	edx, 64					; 00000040H
	sub	edx, DWORD PTR _offset$[ebp]
	mov	DWORD PTR tv82[ebp], edx
	jmp	SHORT $LN12@Append
$LN11@Append:
	mov	eax, DWORD PTR _uLength$[ebp]
	mov	DWORD PTR tv82[ebp], eax
$LN12@Append:
	mov	ecx, DWORD PTR tv82[ebp]
	mov	DWORD PTR _copy$62793[ebp], ecx

; 254  : 
; 255  : 		memcpy(m_pBuffer + offset, p, copy);

	mov	edx, DWORD PTR _copy$62793[ebp]
	push	edx
	mov	eax, DWORD PTR _p$[ebp]
	push	eax
	mov	ecx, DWORD PTR _offset$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	lea	eax, DWORD PTR [edx+ecx+24]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 256  : 		if (offset + copy <	64)

	mov	ecx, DWORD PTR _offset$[ebp]
	add	ecx, DWORD PTR _copy$62793[ebp]
	cmp	ecx, 64					; 00000040H
	jae	SHORT $LN5@Append

; 257  : 			return;

	jmp	SHORT $LN9@Append
$LN5@Append:

; 258  : 		p += copy;

	mov	edx, DWORD PTR _p$[ebp]
	add	edx, DWORD PTR _copy$62793[ebp]
	mov	DWORD PTR _p$[ebp], edx

; 259  : 		left -=	copy;

	mov	eax, DWORD PTR _left$[ebp]
	sub	eax, DWORD PTR _copy$62793[ebp]
	mov	DWORD PTR _left$[ebp], eax

; 260  : 		Process(m_pBuffer);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Process@CMd5@@AAEXPBE@Z		; CMd5::Process
$LN6@Append:

; 261  : 	}
; 262  : 
; 263  : 	/* Process full	blocks.	*/
; 264  : 	for	(; left	>= 64; p +=	64,	left -=	64)

	jmp	SHORT $LN4@Append
$LN3@Append:
	mov	edx, DWORD PTR _p$[ebp]
	add	edx, 64					; 00000040H
	mov	DWORD PTR _p$[ebp], edx
	mov	eax, DWORD PTR _left$[ebp]
	sub	eax, 64					; 00000040H
	mov	DWORD PTR _left$[ebp], eax
$LN4@Append:
	cmp	DWORD PTR _left$[ebp], 64		; 00000040H
	jb	SHORT $LN2@Append

; 265  : 		Process(p);

	mov	ecx, DWORD PTR _p$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Process@CMd5@@AAEXPBE@Z		; CMd5::Process
	jmp	SHORT $LN3@Append
$LN2@Append:

; 266  : 
; 267  : 	/* Process a final partial block. */
; 268  : 	if (left)

	cmp	DWORD PTR _left$[ebp], 0
	je	SHORT $LN9@Append

; 269  : 		memcpy(m_pBuffer, p, left);

	mov	edx, DWORD PTR _left$[ebp]
	push	edx
	mov	eax, DWORD PTR _p$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN9@Append:

; 270  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?Append@CMd5@@QAEXPBEI@Z ENDP				; CMd5::Append
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?End@CMd5@@QAEXQAE@Z				; CMd5::End
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:PROC
;	COMDAT ?pad@?1??End@CMd5@@QAEXQAE@Z@4QBEB
CONST	SEGMENT
?pad@?1??End@CMd5@@QAEXQAE@Z@4QBEB DB 080H		; `CMd5::End'::`2'::pad
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
; Function compile flags: /Odtp
CONST	ENDS
_TEXT	SEGMENT
_this$ = -20						; size = 4
_i$ = -16						; size = 4
_pData$ = -12						; size = 8
__$ArrayPad$ = -4					; size = 4
_pDigest$ = 8						; size = 4
?End@CMd5@@QAEXQAE@Z PROC				; CMd5::End
; _this$ = ecx

; 273  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 274  : 	static const unsigned char pad[64] =
; 275  : 	{
; 276  : 		0x80, 0, 0,	0, 0, 0, 0,	0, 0, 0, 0,	0, 0, 0, 0,	0,
; 277  : 			0, 0, 0, 0,	0, 0, 0, 0,	0, 0, 0, 0,	0, 0, 0, 0,
; 278  : 			0, 0, 0, 0,	0, 0, 0, 0,	0, 0, 0, 0,	0, 0, 0, 0,
; 279  : 			0, 0, 0, 0,	0, 0, 0, 0,	0, 0, 0, 0,	0, 0, 0, 0
; 280  : 	};
; 281  : 	unsigned char pData[8];
; 282  : 	unsigned int i;
; 283  : 
; 284  : 	/* Save	the	length before padding. */
; 285  : 	for	(i = 0;	i <	8; ++i)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN6@End
$LN5@End:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN6@End:
	cmp	DWORD PTR _i$[ebp], 8
	jae	SHORT $LN4@End

; 286  : 		pData[i] = (unsigned char)(m_pCount[i >> 2]	>> ((i & 3)	<< 3));

	mov	ecx, DWORD PTR _i$[ebp]
	shr	ecx, 2
	mov	edx, DWORD PTR _i$[ebp]
	and	edx, 3
	shl	edx, 3
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+ecx*4]
	mov	ecx, edx
	shr	eax, cl
	mov	ecx, DWORD PTR _i$[ebp]
	mov	BYTE PTR _pData$[ebp+ecx], al
	jmp	SHORT $LN5@End
$LN4@End:

; 287  : 	/* Pad to 56 b
; 288  : 	ytes mod 64. */
; 289  : 	Append(pad,	((55 - (m_pCount[0]	>> 3)) & 63) + 1);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	shr	eax, 3
	mov	ecx, 55					; 00000037H
	sub	ecx, eax
	and	ecx, 63					; 0000003fH
	add	ecx, 1
	push	ecx
	push	OFFSET ?pad@?1??End@CMd5@@QAEXQAE@Z@4QBEB
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Append@CMd5@@QAEXPBEI@Z		; CMd5::Append

; 290  : 	/* Append the length. */
; 291  : 	Append(pData, 8);

	push	8
	lea	edx, DWORD PTR _pData$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?Append@CMd5@@QAEXPBEI@Z		; CMd5::Append

; 292  : 	for	(i = 0;	i <	16;	++i)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN3@End
$LN2@End:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN3@End:
	cmp	DWORD PTR _i$[ebp], 16			; 00000010H
	jae	SHORT $LN7@End

; 293  : 		pDigest[i] = (unsigned char)(m_pDigestBuffer[i >> 2] >>	((i	& 3) <<	3));

	mov	ecx, DWORD PTR _i$[ebp]
	shr	ecx, 2
	mov	edx, DWORD PTR _i$[ebp]
	and	edx, 3
	shl	edx, 3
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+ecx*4+8]
	mov	ecx, edx
	shr	eax, cl
	mov	ecx, DWORD PTR _pDigest$[ebp]
	add	ecx, DWORD PTR _i$[ebp]
	mov	BYTE PTR [ecx], al
	jmp	SHORT $LN2@End
$LN7@End:

; 294  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
?End@CMd5@@QAEXQAE@Z ENDP				; CMd5::End
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?GetMD5Base16Str@CMd5@@QAEXPAD@Z		; CMd5::GetMD5Base16Str
; Function compile flags: /Odtp
_TEXT	SEGMENT
_this$ = -24						; size = 4
_pDigest$ = -20						; size = 16
__$ArrayPad$ = -4					; size = 4
_pBase16$ = 8						; size = 4
?GetMD5Base16Str@CMd5@@QAEXPAD@Z PROC			; CMd5::GetMD5Base16Str
; _this$ = ecx

; 320  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 321  : 	unsigned char pDigest[16];
; 322  : 	End( pDigest );

	lea	eax, DWORD PTR _pDigest$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?End@CMd5@@QAEXQAE@Z			; CMd5::End

; 323  : 	ArkUint82Base16(pDigest, 16, pBase16, 33);

	push	33					; 00000021H
	mov	ecx, DWORD PTR _pBase16$[ebp]
	push	ecx
	push	16					; 00000010H
	lea	edx, DWORD PTR _pDigest$[ebp]
	push	edx
	call	?ArkUint82Base16@@YAIPBEIPADI@Z		; ArkUint82Base16
	add	esp, 16					; 00000010H

; 324  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
?GetMD5Base16Str@CMd5@@QAEXPAD@Z ENDP			; CMd5::GetMD5Base16Str
; Function compile flags: /Odtp
_pBuf$62823 = -12					; size = 4
_nPos$ = -8						; size = 4
_pTail$ = -4						; size = 4
_pUint8$ = 8						; size = 4
_sizeCode$ = 12						; size = 4
_pBase16$ = 16						; size = 4
_sizeBuf$ = 20						; size = 4
?ArkUint82Base16@@YAIPBEIPADI@Z PROC			; ArkUint82Base16

; 297  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 298  : 	size_t nPos = 0;

	mov	DWORD PTR _nPos$[ebp], 0

; 299  :     const unsigned char * pTail = pUint8 + sizeCode;

	mov	eax, DWORD PTR _pUint8$[ebp]
	add	eax, DWORD PTR _sizeCode$[ebp]
	mov	DWORD PTR _pTail$[ebp], eax

; 300  : 	for( unsigned char* pBuf = (unsigned char*)pUint8; pBuf != pTail; nPos++ )

	mov	ecx, DWORD PTR _pUint8$[ebp]
	mov	DWORD PTR _pBuf$62823[ebp], ecx
	jmp	SHORT $LN6@ArkUint82B
$LN5@ArkUint82B:
	mov	edx, DWORD PTR _nPos$[ebp]
	add	edx, 1
	mov	DWORD PTR _nPos$[ebp], edx
$LN6@ArkUint82B:
	mov	eax, DWORD PTR _pBuf$62823[ebp]
	cmp	eax, DWORD PTR _pTail$[ebp]
	je	$LN4@ArkUint82B

; 301  : 	{
; 302  : 		if(pBase16)

	cmp	DWORD PTR _pBase16$[ebp], 0
	je	$LN3@ArkUint82B

; 303  : 		{
; 304  : 			if( 2 * nPos + 1>= sizeBuf )

	mov	ecx, DWORD PTR _nPos$[ebp]
	lea	edx, DWORD PTR [ecx+ecx+1]
	cmp	edx, DWORD PTR _sizeBuf$[ebp]
	jb	SHORT $LN2@ArkUint82B

; 305  : 				break;

	jmp	$LN4@ArkUint82B
$LN2@ArkUint82B:

; 306  : 			pBase16[2 * nPos + 1] = pUint8[nPos] & 0x0f;

	mov	eax, DWORD PTR _pUint8$[ebp]
	add	eax, DWORD PTR _nPos$[ebp]
	movzx	ecx, BYTE PTR [eax]
	and	ecx, 15					; 0000000fH
	mov	edx, DWORD PTR _nPos$[ebp]
	mov	eax, DWORD PTR _pBase16$[ebp]
	mov	BYTE PTR [eax+edx*2+1], cl

; 307  : 			pBase16[2 * nPos] = pUint8[nPos]>>4;

	mov	ecx, DWORD PTR _pUint8$[ebp]
	add	ecx, DWORD PTR _nPos$[ebp]
	movzx	edx, BYTE PTR [ecx]
	sar	edx, 4
	mov	eax, DWORD PTR _nPos$[ebp]
	mov	ecx, DWORD PTR _pBase16$[ebp]
	mov	BYTE PTR [ecx+eax*2], dl

; 308  : 			pBase16[2 * nPos + 1] += pBase16[2 * nPos + 1] < 10 ? '0' : 'a' - 10;

	mov	edx, DWORD PTR _nPos$[ebp]
	mov	eax, DWORD PTR _pBase16$[ebp]
	movsx	ecx, BYTE PTR [eax+edx*2+1]
	xor	edx, edx
	cmp	ecx, 10					; 0000000aH
	setge	dl
	sub	edx, 1
	and	edx, -39				; ffffffd9H
	add	edx, 87					; 00000057H
	mov	eax, DWORD PTR _nPos$[ebp]
	mov	ecx, DWORD PTR _pBase16$[ebp]
	movsx	eax, BYTE PTR [ecx+eax*2+1]
	add	eax, edx
	mov	ecx, DWORD PTR _nPos$[ebp]
	mov	edx, DWORD PTR _pBase16$[ebp]
	mov	BYTE PTR [edx+ecx*2+1], al

; 309  : 			pBase16[2 * nPos] += pBase16[2 * nPos] < 10 ? '0' : 'a' - 10;

	mov	eax, DWORD PTR _nPos$[ebp]
	mov	ecx, DWORD PTR _pBase16$[ebp]
	movsx	edx, BYTE PTR [ecx+eax*2]
	xor	eax, eax
	cmp	edx, 10					; 0000000aH
	setge	al
	sub	eax, 1
	and	eax, -39				; ffffffd9H
	add	eax, 87					; 00000057H
	mov	ecx, DWORD PTR _nPos$[ebp]
	mov	edx, DWORD PTR _pBase16$[ebp]
	movsx	ecx, BYTE PTR [edx+ecx*2]
	add	ecx, eax
	mov	edx, DWORD PTR _nPos$[ebp]
	mov	eax, DWORD PTR _pBase16$[ebp]
	mov	BYTE PTR [eax+edx*2], cl
$LN3@ArkUint82B:

; 310  : 		}
; 311  : 	}

	jmp	$LN5@ArkUint82B
$LN4@ArkUint82B:

; 312  : 	if(pBase16 && 2 * nPos < sizeBuf)

	cmp	DWORD PTR _pBase16$[ebp], 0
	je	SHORT $LN1@ArkUint82B
	mov	ecx, DWORD PTR _nPos$[ebp]
	shl	ecx, 1
	cmp	ecx, DWORD PTR _sizeBuf$[ebp]
	jae	SHORT $LN1@ArkUint82B

; 313  : 		pBase16[2 * nPos] = '\0';

	mov	edx, DWORD PTR _nPos$[ebp]
	mov	eax, DWORD PTR _pBase16$[ebp]
	mov	BYTE PTR [eax+edx*2], 0
$LN1@ArkUint82B:

; 314  : 
; 315  : 	return 2 * nPos + 1;

	mov	ecx, DWORD PTR _nPos$[ebp]
	lea	eax, DWORD PTR [ecx+ecx+1]

; 316  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?ArkUint82Base16@@YAIPBEIPADI@Z ENDP			; ArkUint82Base16
_TEXT	ENDS
END

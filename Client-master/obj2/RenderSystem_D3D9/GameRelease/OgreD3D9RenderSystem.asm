; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	i:\svnroot\client\Plugins\RenderSystem_D3D9\OgreD3D9RenderSystem.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	?_Value@?$_Is_swap_move@U_Swap_move_tag@std@@@std@@2_NB ; std::_Is_swap_move<std::_Swap_move_tag>::_Value
PUBLIC	?collate@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::collate
PUBLIC	?ctype@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::ctype
PUBLIC	?monetary@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::monetary
PUBLIC	?numeric@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::numeric
PUBLIC	?time@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::time
PUBLIC	?messages@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::messages
PUBLIC	?all@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::all
PUBLIC	?none@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::none
PUBLIC	?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::skipws
PUBLIC	?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::unitbuf
PUBLIC	?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::uppercase
PUBLIC	?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showbase
PUBLIC	?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpoint
PUBLIC	?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpos
PUBLIC	?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::left
PUBLIC	?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::right
PUBLIC	?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::internal
PUBLIC	?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::dec
PUBLIC	?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::oct
PUBLIC	?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::hex
PUBLIC	?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::scientific
PUBLIC	?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::fixed
PUBLIC	?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::hexfloat
PUBLIC	?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::boolalpha
PUBLIC	?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::_Stdio
PUBLIC	?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::adjustfield
PUBLIC	?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::basefield
PUBLIC	?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::floatfield
PUBLIC	?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::goodbit
PUBLIC	?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::eofbit
PUBLIC	?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::failbit
PUBLIC	?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::badbit
PUBLIC	?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::_Hardfail
PUBLIC	?in@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::in
PUBLIC	?out@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::out
PUBLIC	?ate@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::ate
PUBLIC	?app@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::app
PUBLIC	?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::trunc
PUBLIC	?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Nocreate
PUBLIC	?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Noreplace
PUBLIC	?binary@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::binary
PUBLIC	?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::beg
PUBLIC	?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::cur
PUBLIC	?end@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::end
PUBLIC	?value@?$integral_constant@_N$0A@@tr1@std@@2_NB	; std::tr1::integral_constant<bool,0>::value
PUBLIC	?value@?$integral_constant@_N$00@tr1@std@@2_NB	; std::tr1::integral_constant<bool,1>::value
;	COMDAT ?value@?$integral_constant@_N$00@tr1@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$00@tr1@std@@2_NB DB 01H	; std::tr1::integral_constant<bool,1>::value
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$0A@@tr1@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$0A@@tr1@std@@2_NB DB 00H	; std::tr1::integral_constant<bool,0>::value
CONST	ENDS
;	COMDAT ?end@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?end@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 02H		; std::_Iosb<int>::end
CONST	ENDS
;	COMDAT ?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 01H		; std::_Iosb<int>::cur
CONST	ENDS
;	COMDAT ?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 00H		; std::_Iosb<int>::beg
CONST	ENDS
;	COMDAT ?binary@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?binary@?$_Iosb@H@std@@2W4_Openmode@12@B DD 020H	; std::_Iosb<int>::binary
CONST	ENDS
;	COMDAT ?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B DD 080H	; std::_Iosb<int>::_Noreplace
CONST	ENDS
;	COMDAT ?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 040H	; std::_Iosb<int>::_Nocreate
CONST	ENDS
;	COMDAT ?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B DD 010H		; std::_Iosb<int>::trunc
CONST	ENDS
;	COMDAT ?app@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?app@?$_Iosb@H@std@@2W4_Openmode@12@B DD 08H		; std::_Iosb<int>::app
CONST	ENDS
;	COMDAT ?ate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?ate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 04H		; std::_Iosb<int>::ate
CONST	ENDS
;	COMDAT ?out@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?out@?$_Iosb@H@std@@2W4_Openmode@12@B DD 02H		; std::_Iosb<int>::out
CONST	ENDS
;	COMDAT ?in@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?in@?$_Iosb@H@std@@2W4_Openmode@12@B DD 01H		; std::_Iosb<int>::in
CONST	ENDS
;	COMDAT ?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B DD 010H	; std::_Iosb<int>::_Hardfail
CONST	ENDS
;	COMDAT ?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 04H		; std::_Iosb<int>::badbit
CONST	ENDS
;	COMDAT ?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 02H		; std::_Iosb<int>::failbit
CONST	ENDS
;	COMDAT ?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 01H		; std::_Iosb<int>::eofbit
CONST	ENDS
;	COMDAT ?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 00H		; std::_Iosb<int>::goodbit
CONST	ENDS
;	COMDAT ?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 03000H	; std::_Iosb<int>::floatfield
CONST	ENDS
;	COMDAT ?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0e00H	; std::_Iosb<int>::basefield
CONST	ENDS
;	COMDAT ?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01c0H	; std::_Iosb<int>::adjustfield
CONST	ENDS
;	COMDAT ?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08000H	; std::_Iosb<int>::_Stdio
CONST	ENDS
;	COMDAT ?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04000H	; std::_Iosb<int>::boolalpha
CONST	ENDS
;	COMDAT ?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 03000H	; std::_Iosb<int>::hexfloat
CONST	ENDS
;	COMDAT ?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02000H	; std::_Iosb<int>::fixed
CONST	ENDS
;	COMDAT ?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01000H	; std::_Iosb<int>::scientific
CONST	ENDS
;	COMDAT ?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0800H		; std::_Iosb<int>::hex
CONST	ENDS
;	COMDAT ?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0400H		; std::_Iosb<int>::oct
CONST	ENDS
;	COMDAT ?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0200H		; std::_Iosb<int>::dec
CONST	ENDS
;	COMDAT ?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0100H	; std::_Iosb<int>::internal
CONST	ENDS
;	COMDAT ?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 080H		; std::_Iosb<int>::right
CONST	ENDS
;	COMDAT ?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 040H		; std::_Iosb<int>::left
CONST	ENDS
;	COMDAT ?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 020H	; std::_Iosb<int>::showpos
CONST	ENDS
;	COMDAT ?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 010H	; std::_Iosb<int>::showpoint
CONST	ENDS
;	COMDAT ?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08H	; std::_Iosb<int>::showbase
CONST	ENDS
;	COMDAT ?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04H	; std::_Iosb<int>::uppercase
CONST	ENDS
;	COMDAT ?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02H	; std::_Iosb<int>::unitbuf
CONST	ENDS
;	COMDAT ?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01H		; std::_Iosb<int>::skipws
CONST	ENDS
;	COMDAT ?none@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?none@?$_Locbase@H@std@@2HB DD 00H			; std::_Locbase<int>::none
CONST	ENDS
;	COMDAT ?all@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?all@?$_Locbase@H@std@@2HB DD 03fH			; std::_Locbase<int>::all
CONST	ENDS
;	COMDAT ?messages@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?messages@?$_Locbase@H@std@@2HB DD 020H			; std::_Locbase<int>::messages
CONST	ENDS
;	COMDAT ?time@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?time@?$_Locbase@H@std@@2HB DD 010H			; std::_Locbase<int>::time
CONST	ENDS
;	COMDAT ?numeric@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?numeric@?$_Locbase@H@std@@2HB DD 08H			; std::_Locbase<int>::numeric
CONST	ENDS
;	COMDAT ?monetary@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?monetary@?$_Locbase@H@std@@2HB DD 04H			; std::_Locbase<int>::monetary
CONST	ENDS
;	COMDAT ?ctype@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?ctype@?$_Locbase@H@std@@2HB DD 02H			; std::_Locbase<int>::ctype
CONST	ENDS
;	COMDAT ?collate@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?collate@?$_Locbase@H@std@@2HB DD 01H			; std::_Locbase<int>::collate
CONST	ENDS
;	COMDAT ?_Value@?$_Is_swap_move@U_Swap_move_tag@std@@@std@@2_NB
CONST	SEGMENT
?_Value@?$_Is_swap_move@U_Swap_move_tag@std@@@std@@2_NB DB 01H ; std::_Is_swap_move<std::_Swap_move_tag>::_Value
CONST	ENDS
_DATA	SEGMENT
__bad_alloc_Message DD FLAT:$SG5714
_DATA	ENDS
CONST	SEGMENT
$SG5714	DB	'bad allocation', 00H
	ORG $+1
_MAX_FLOAT DD	07f7fffffr			; 3.40282e+038
_ONE_PI	DD	040490fd0r			; 3.14159
_EPSILON DD	03727c5acr			; 1e-005
_RADS_PER_DEG DD 03c8efa35r			; 0.0174533
_DEGS_PER_RAD DD 042652ee1r			; 57.2958
$SG151586 DB	'.\OgreD3D9RenderSystem.cpp', 00H
	ORG $+1
$SG151587 DB	'Failed to create Direct3D', 00H
	ORG $+2
$SG151589 DB	'.\OgreD3D9RenderSystem.cpp', 00H
	ORG $+1
$SG151590 DB	'D3D Driver: %s', 0aH, 00H
$SG151591 DB	'.\OgreD3D9RenderSystem.cpp', 00H
	ORG $+1
$SG151592 DB	'Description: %s', 0aH, 00H
	ORG $+3
$SG151601 DB	'.\OgreD3D9RenderSystem.cpp', 00H
	ORG $+1
$SG151602 DB	'Version: %d.%d.%d.%d', 0aH, 00H
	ORG $+2
$SG151606 DB	'.\OgreD3D9RenderSystem.cpp', 00H
	ORG $+1
$SG151607 DB	'Date: %02d.%02d.%d, %02d:%02d:%02d', 0aH, 00H
$SG151608 DB	'.\OgreD3D9RenderSystem.cpp', 00H
	ORG $+1
$SG151609 DB	'OS: Windows %ld.%ld.%ld', 0aH, 00H
	ORG $+3
$SG151610 DB	'.\OgreD3D9RenderSystem.cpp', 00H
	ORG $+1
$SG151611 DB	'Memory: %ldK total, %ldK free', 0aH, 00H
	ORG $+1
$SG151613 DB	'.\OgreD3D9RenderSystem.cpp', 00H
	ORG $+1
$SG151614 DB	'Failed to enumerate device', 00H
	ORG $+1
$SG151648 DB	'shaders\materials.xml', 00H
	ORG $+2
$SG151654 DB	'.\OgreD3D9RenderSystem.cpp', 00H
	ORG $+1
$SG151655 DB	'load material template file error: %s', 00H
	ORG $+2
$SG151870 DB	'PerfHUD', 00H
$SG151941 DB	'.\OgreD3D9RenderSystem.cpp', 00H
	ORG $+1
$SG151942 DB	'D3D9RenderSystem::setViewport--GetRenderTarget--', 0bbH, 0f1H
	DB	0c8H, 0a1H, 0c1H, 0cbH, 'RenderTarget', 0a3H, 0acH, 0b5H, 0abH
	DB	0caH, 0c7H, 0c3H, 0bbH, 0caH, 0cdH, 0b7H, 0c5H, '--479', 00H
$SG151957 DB	'.\OgreD3D9RenderSystem.cpp', 00H
	ORG $+1
$SG151958 DB	'D3D9RenderSystem::setViewport--GetRenderTarget--', 0bbH, 0f1H
	DB	0c8H, 0a1H, 0c1H, 0cbH, 'RenderTarget', 0a3H, 0acH, 0b5H, 0abH
	DB	0caH, 0c7H, 0c3H, 0bbH, 0caH, 0cdH, 0b7H, 0c5H, '--505', 00H
$SG152497 DB	'shaders\test\', 00H
	ORG $+2
$SG152498 DB	'%s%s', 00H
	ORG $+3
$SG152534 DB	'.\OgreD3D9RenderSystem.cpp', 00H
	ORG $+1
$SG152535 DB	'Open shader file failed: %s', 00H
$SG152556 DB	'wb', 00H
	ORG $+1
$SG152557 DB	'log/error.fx', 00H
	ORG $+3
$SG152560 DB	'wb', 00H
	ORG $+1
$SG152561 DB	'log/fx_error.txt', 00H
	ORG $+3
$SG152563 DB	0aH, 00H
	ORG $+2
$SG152644 DB	'.\OgreD3D9RenderSystem.cpp', 00H
	ORG $+1
$SG152645 DB	'D3D9RenderSystem::setViewport--GetRenderTarget--', 0bbH, 0f1H
	DB	0c8H, 0a1H, 0c1H, 0cbH, 'RenderTarget', 0a3H, 0acH, 0b5H, 0abH
	DB	0caH, 0c7H, 0c3H, 0bbH, 0caH, 0cdH, 0b7H, 0c5H, '--1200', 00H
CONST	ENDS
PUBLIC	?GetBehaviorFlags@Ogre@@YAKW4VERTPROCESS_T@1@@Z	; Ogre::GetBehaviorFlags
; Function compile flags: /Odtp
; File i:\svnroot\client\plugins\rendersystem_d3d9\ogred3d9rendersystem.cpp
_TEXT	SEGMENT
tv64 = -4						; size = 4
_vp$ = 8						; size = 4
?GetBehaviorFlags@Ogre@@YAKW4VERTPROCESS_T@1@@Z PROC	; Ogre::GetBehaviorFlags

; 32   : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 33   : 		switch(vp)

	mov	eax, DWORD PTR _vp$[ebp]
	mov	DWORD PTR tv64[ebp], eax
	cmp	DWORD PTR tv64[ebp], 3
	ja	SHORT $LN1@GetBehavio
	mov	ecx, DWORD PTR tv64[ebp]
	jmp	DWORD PTR $LN10@GetBehavio[ecx*4]
$LN5@GetBehavio:

; 34   : 		{
; 35   : 		case SOFTWARE_VP:
; 36   : 			return D3DCREATE_SOFTWARE_VERTEXPROCESSING;

	mov	eax, 32					; 00000020H
	jmp	SHORT $LN8@GetBehavio
$LN4@GetBehavio:

; 37   : 
; 38   : 		case MIXED_VP:
; 39   : 			return D3DCREATE_MIXED_VERTEXPROCESSING;

	mov	eax, 128				; 00000080H
	jmp	SHORT $LN8@GetBehavio
$LN3@GetBehavio:

; 40   : 
; 41   : 		case HARDWARE_VP:
; 42   : 			return D3DCREATE_HARDWARE_VERTEXPROCESSING;

	mov	eax, 64					; 00000040H
	jmp	SHORT $LN8@GetBehavio
$LN2@GetBehavio:

; 43   : 
; 44   : 		case PURE_HARDWARE_VP:
; 45   : 			return D3DCREATE_HARDWARE_VERTEXPROCESSING | D3DCREATE_FPU_PRESERVE | D3DCREATE_PUREDEVICE;

	mov	eax, 82					; 00000052H
	jmp	SHORT $LN8@GetBehavio
$LN1@GetBehavio:

; 46   : 
; 47   : 		default:
; 48   : 			assert(0);
; 49   : 			return 0;

	xor	eax, eax
$LN8@GetBehavio:

; 50   : 		}
; 51   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
$LN10@GetBehavio:
	DD	$LN5@GetBehavio
	DD	$LN4@GetBehavio
	DD	$LN3@GetBehavio
	DD	$LN2@GetBehavio
?GetBehaviorFlags@Ogre@@YAKW4VERTPROCESS_T@1@@Z ENDP	; Ogre::GetBehaviorFlags
_TEXT	ENDS
PUBLIC	??1?$vector@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >::~vector<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >
PUBLIC	??1?$vector@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >::~vector<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >
PUBLIC	??0?$vector@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >::vector<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >
PUBLIC	??0?$vector@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >::vector<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >
PUBLIC	??_7D3D9RenderSystem@Ogre@@6B@			; Ogre::D3D9RenderSystem::`vftable'
PUBLIC	??0D3D9RenderSystem@Ogre@@QAE@PAUHINSTANCE__@@@Z ; Ogre::D3D9RenderSystem::D3D9RenderSystem
PUBLIC	??_R4D3D9RenderSystem@Ogre@@6B@			; Ogre::D3D9RenderSystem::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVD3D9RenderSystem@Ogre@@@8		; Ogre::D3D9RenderSystem `RTTI Type Descriptor'
PUBLIC	??_R3D3D9RenderSystem@Ogre@@8			; Ogre::D3D9RenderSystem::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2D3D9RenderSystem@Ogre@@8			; Ogre::D3D9RenderSystem::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@D3D9RenderSystem@Ogre@@8		; Ogre::D3D9RenderSystem::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@RenderSystem@Ogre@@8		; Ogre::RenderSystem::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVRenderSystem@Ogre@@@8			; Ogre::RenderSystem `RTTI Type Descriptor'
PUBLIC	??_R3RenderSystem@Ogre@@8			; Ogre::RenderSystem::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2RenderSystem@Ogre@@8			; Ogre::RenderSystem::`RTTI Base Class Array'
PUBLIC	??_R13?0A@EA@?$Singleton@VRenderSystem@Ogre@@@Ogre@@8 ; Ogre::Singleton<Ogre::RenderSystem>::`RTTI Base Class Descriptor at (4,-1,0,64)'
PUBLIC	??_R0?AV?$Singleton@VRenderSystem@Ogre@@@Ogre@@@8 ; Ogre::Singleton<Ogre::RenderSystem> `RTTI Type Descriptor'
PUBLIC	??_R3?$Singleton@VRenderSystem@Ogre@@@Ogre@@8	; Ogre::Singleton<Ogre::RenderSystem>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$Singleton@VRenderSystem@Ogre@@@Ogre@@8	; Ogre::Singleton<Ogre::RenderSystem>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$Singleton@VRenderSystem@Ogre@@@Ogre@@8 ; Ogre::Singleton<Ogre::RenderSystem>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?initialise@D3D9RenderSystem@Ogre@@UAE_NABUInitDesc@RenderSystem@2@@Z ; Ogre::D3D9RenderSystem::initialise
PUBLIC	?shutdown@D3D9RenderSystem@Ogre@@UAEXXZ		; Ogre::D3D9RenderSystem::shutdown
PUBLIC	?createRenderWindow@D3D9RenderSystem@Ogre@@UAEPAVRenderWindow@2@ABUInitDesc@RenderSystem@2@@Z ; Ogre::D3D9RenderSystem::createRenderWindow
PUBLIC	?clear@D3D9RenderSystem@Ogre@@UAEXIIMI@Z	; Ogre::D3D9RenderSystem::clear
PUBLIC	?setViewport@D3D9RenderSystem@Ogre@@UAEXABUViewport@2@@Z ; Ogre::D3D9RenderSystem::setViewport
PUBLIC	?beginFrame@D3D9RenderSystem@Ogre@@UAE_NXZ	; Ogre::D3D9RenderSystem::beginFrame
PUBLIC	?endFrame@D3D9RenderSystem@Ogre@@UAEXXZ		; Ogre::D3D9RenderSystem::endFrame
PUBLIC	?present@D3D9RenderSystem@Ogre@@UAEHXZ		; Ogre::D3D9RenderSystem::present
PUBLIC	?getMainWindow@D3D9RenderSystem@Ogre@@UAEPAVRenderWindow@2@XZ ; Ogre::D3D9RenderSystem::getMainWindow
PUBLIC	?getInputLayout@D3D9RenderSystem@Ogre@@UAEIABVVertexFormat@2@@Z ; Ogre::D3D9RenderSystem::getInputLayout
PUBLIC	?resetDevice@D3D9RenderSystem@Ogre@@UAEHXZ	; Ogre::D3D9RenderSystem::resetDevice
PUBLIC	?testDeviceReset@D3D9RenderSystem@Ogre@@UAEHXZ	; Ogre::D3D9RenderSystem::testDeviceReset
PUBLIC	?restoreLostDevice@D3D9RenderSystem@Ogre@@UAE_NXZ ; Ogre::D3D9RenderSystem::restoreLostDevice
PUBLIC	?findRenderWindow@D3D9RenderSystem@Ogre@@UAEPAVRenderWindow@2@PAX@Z ; Ogre::D3D9RenderSystem::findRenderWindow
PUBLIC	?setContextQueDesc@D3D9RenderSystem@Ogre@@UAEXABUContextQueDesc@2@@Z ; Ogre::D3D9RenderSystem::setContextQueDesc
PUBLIC	?setCursorProperty@D3D9RenderSystem@Ogre@@UAEXPAVTextureData@2@HHHHHH@Z ; Ogre::D3D9RenderSystem::setCursorProperty
PUBLIC	?setCursorPosition@D3D9RenderSystem@Ogre@@UAEXHH@Z ; Ogre::D3D9RenderSystem::setCursorPosition
PUBLIC	?showCursor@D3D9RenderSystem@Ogre@@UAEX_N@Z	; Ogre::D3D9RenderSystem::showCursor
PUBLIC	?snapShotAll@D3D9RenderSystem@Ogre@@UAEXPBD@Z	; Ogre::D3D9RenderSystem::snapShotAll
PUBLIC	?snapShot@D3D9RenderSystem@Ogre@@UAEXXZ		; Ogre::D3D9RenderSystem::snapShot
PUBLIC	?CreateShaderTechniqueFromRawFile@D3D9RenderSystem@Ogre@@UAEPAVShaderTechnique@2@PBD@Z ; Ogre::D3D9RenderSystem::CreateShaderTechniqueFromRawFile
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	__imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:PROC
EXTRN	__imp_??1RenderSystem@Ogre@@QAE@XZ:PROC
EXTRN	??0D3DEnumeration@Ogre@@QAE@XZ:PROC		; Ogre::D3DEnumeration::D3DEnumeration
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:PROC
EXTRN	__imp_??0RenderSystem@Ogre@@QAE@XZ:PROC
EXTRN	___security_cookie:DWORD
EXTRN	___CxxFrameHandler3:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
;	COMDAT ??_R1A@?0A@EA@?$Singleton@VRenderSystem@Ogre@@@Ogre@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$Singleton@VRenderSystem@Ogre@@@Ogre@@8 DD FLAT:??_R0?AV?$Singleton@VRenderSystem@Ogre@@@Ogre@@@8 ; Ogre::Singleton<Ogre::RenderSystem>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$Singleton@VRenderSystem@Ogre@@@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R2?$Singleton@VRenderSystem@Ogre@@@Ogre@@8
rdata$r	SEGMENT
??_R2?$Singleton@VRenderSystem@Ogre@@@Ogre@@8 DD FLAT:??_R1A@?0A@EA@?$Singleton@VRenderSystem@Ogre@@@Ogre@@8 ; Ogre::Singleton<Ogre::RenderSystem>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3?$Singleton@VRenderSystem@Ogre@@@Ogre@@8
rdata$r	SEGMENT
??_R3?$Singleton@VRenderSystem@Ogre@@@Ogre@@8 DD 00H	; Ogre::Singleton<Ogre::RenderSystem>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$Singleton@VRenderSystem@Ogre@@@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$Singleton@VRenderSystem@Ogre@@@Ogre@@@8
_DATA	SEGMENT
??_R0?AV?$Singleton@VRenderSystem@Ogre@@@Ogre@@@8 DD FLAT:??_7type_info@@6B@ ; Ogre::Singleton<Ogre::RenderSystem> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$Singleton@VRenderSystem@Ogre@@@Ogre@@', 00H
_DATA	ENDS
;	COMDAT ??_R13?0A@EA@?$Singleton@VRenderSystem@Ogre@@@Ogre@@8
rdata$r	SEGMENT
??_R13?0A@EA@?$Singleton@VRenderSystem@Ogre@@@Ogre@@8 DD FLAT:??_R0?AV?$Singleton@VRenderSystem@Ogre@@@Ogre@@@8 ; Ogre::Singleton<Ogre::RenderSystem>::`RTTI Base Class Descriptor at (4,-1,0,64)'
	DD	00H
	DD	04H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$Singleton@VRenderSystem@Ogre@@@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R2RenderSystem@Ogre@@8
rdata$r	SEGMENT
??_R2RenderSystem@Ogre@@8 DD FLAT:??_R1A@?0A@EA@RenderSystem@Ogre@@8 ; Ogre::RenderSystem::`RTTI Base Class Array'
	DD	FLAT:??_R13?0A@EA@?$Singleton@VRenderSystem@Ogre@@@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R3RenderSystem@Ogre@@8
rdata$r	SEGMENT
??_R3RenderSystem@Ogre@@8 DD 00H			; Ogre::RenderSystem::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2RenderSystem@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVRenderSystem@Ogre@@@8
_DATA	SEGMENT
??_R0?AVRenderSystem@Ogre@@@8 DD FLAT:??_7type_info@@6B@ ; Ogre::RenderSystem `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVRenderSystem@Ogre@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@RenderSystem@Ogre@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@RenderSystem@Ogre@@8 DD FLAT:??_R0?AVRenderSystem@Ogre@@@8 ; Ogre::RenderSystem::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3RenderSystem@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@D3D9RenderSystem@Ogre@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@D3D9RenderSystem@Ogre@@8 DD FLAT:??_R0?AVD3D9RenderSystem@Ogre@@@8 ; Ogre::D3D9RenderSystem::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3D3D9RenderSystem@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R2D3D9RenderSystem@Ogre@@8
rdata$r	SEGMENT
??_R2D3D9RenderSystem@Ogre@@8 DD FLAT:??_R1A@?0A@EA@D3D9RenderSystem@Ogre@@8 ; Ogre::D3D9RenderSystem::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@RenderSystem@Ogre@@8
	DD	FLAT:??_R13?0A@EA@?$Singleton@VRenderSystem@Ogre@@@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R3D3D9RenderSystem@Ogre@@8
rdata$r	SEGMENT
??_R3D3D9RenderSystem@Ogre@@8 DD 00H			; Ogre::D3D9RenderSystem::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2D3D9RenderSystem@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVD3D9RenderSystem@Ogre@@@8
_DATA	SEGMENT
??_R0?AVD3D9RenderSystem@Ogre@@@8 DD FLAT:??_7type_info@@6B@ ; Ogre::D3D9RenderSystem `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVD3D9RenderSystem@Ogre@@', 00H
_DATA	ENDS
;	COMDAT ??_R4D3D9RenderSystem@Ogre@@6B@
rdata$r	SEGMENT
??_R4D3D9RenderSystem@Ogre@@6B@ DD 00H			; Ogre::D3D9RenderSystem::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVD3D9RenderSystem@Ogre@@@8
	DD	FLAT:??_R3D3D9RenderSystem@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_7D3D9RenderSystem@Ogre@@6B@
CONST	SEGMENT
??_7D3D9RenderSystem@Ogre@@6B@ DD FLAT:??_R4D3D9RenderSystem@Ogre@@6B@ ; Ogre::D3D9RenderSystem::`vftable'
	DD	FLAT:?initialise@D3D9RenderSystem@Ogre@@UAE_NABUInitDesc@RenderSystem@2@@Z
	DD	FLAT:?shutdown@D3D9RenderSystem@Ogre@@UAEXXZ
	DD	FLAT:?createRenderWindow@D3D9RenderSystem@Ogre@@UAEPAVRenderWindow@2@ABUInitDesc@RenderSystem@2@@Z
	DD	FLAT:?clear@D3D9RenderSystem@Ogre@@UAEXIIMI@Z
	DD	FLAT:?setViewport@D3D9RenderSystem@Ogre@@UAEXABUViewport@2@@Z
	DD	FLAT:?beginFrame@D3D9RenderSystem@Ogre@@UAE_NXZ
	DD	FLAT:?endFrame@D3D9RenderSystem@Ogre@@UAEXXZ
	DD	FLAT:?present@D3D9RenderSystem@Ogre@@UAEHXZ
	DD	FLAT:?getMainWindow@D3D9RenderSystem@Ogre@@UAEPAVRenderWindow@2@XZ
	DD	FLAT:?getInputLayout@D3D9RenderSystem@Ogre@@UAEIABVVertexFormat@2@@Z
	DD	FLAT:?resetDevice@D3D9RenderSystem@Ogre@@UAEHXZ
	DD	FLAT:?testDeviceReset@D3D9RenderSystem@Ogre@@UAEHXZ
	DD	FLAT:?restoreLostDevice@D3D9RenderSystem@Ogre@@UAE_NXZ
	DD	FLAT:?findRenderWindow@D3D9RenderSystem@Ogre@@UAEPAVRenderWindow@2@PAX@Z
	DD	FLAT:?setContextQueDesc@D3D9RenderSystem@Ogre@@UAEXABUContextQueDesc@2@@Z
	DD	FLAT:?setCursorProperty@D3D9RenderSystem@Ogre@@UAEXPAVTextureData@2@HHHHHH@Z
	DD	FLAT:?setCursorPosition@D3D9RenderSystem@Ogre@@UAEXHH@Z
	DD	FLAT:?showCursor@D3D9RenderSystem@Ogre@@UAEX_N@Z
	DD	FLAT:?snapShotAll@D3D9RenderSystem@Ogre@@UAEXPBD@Z
	DD	FLAT:?snapShot@D3D9RenderSystem@Ogre@@UAEXXZ
	DD	FLAT:?CreateShaderTechniqueFromRawFile@D3D9RenderSystem@Ogre@@UAEPAVShaderTechnique@2@PBD@Z
CONST	ENDS
xdata$x	SEGMENT
__ehfuncinfo$??0D3D9RenderSystem@Ogre@@QAE@PAUHINSTANCE__@@@Z DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$??0D3D9RenderSystem@Ogre@@QAE@PAUHINSTANCE__@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__unwindtable$??0D3D9RenderSystem@Ogre@@QAE@PAUHINSTANCE__@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0D3D9RenderSystem@Ogre@@QAE@PAUHINSTANCE__@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0D3D9RenderSystem@Ogre@@QAE@PAUHINSTANCE__@@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0D3D9RenderSystem@Ogre@@QAE@PAUHINSTANCE__@@@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$??0D3D9RenderSystem@Ogre@@QAE@PAUHINSTANCE__@@@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$??0D3D9RenderSystem@Ogre@@QAE@PAUHINSTANCE__@@@Z$4
; Function compile flags: /Odtp
xdata$x	ENDS
_TEXT	SEGMENT
tv139 = -28						; size = 4
_this$ = -24						; size = 4
$T159620 = -20						; size = 4
$T159619 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_hinst$ = 8						; size = 4
??0D3D9RenderSystem@Ogre@@QAE@PAUHINSTANCE__@@@Z PROC	; Ogre::D3D9RenderSystem::D3D9RenderSystem
; _this$ = ecx

; 71   : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0D3D9RenderSystem@Ogre@@QAE@PAUHINSTANCE__@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 16					; 00000010H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0RenderSystem@Ogre@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7D3D9RenderSystem@Ogre@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _hinst$[ebp]
	mov	DWORD PTR [ecx+96], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+100], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+104], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 464				; 000001d0H
	call	??0?$vector@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >::vector<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 488				; 000001e8H
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 520				; 00000208H
	call	??0?$vector@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >::vector<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+556], 0

; 72   : 		m_pD3DEnum = new D3DEnumeration;

	push	144					; 00000090H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T159620[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	cmp	DWORD PTR $T159620[ebp], 0
	je	SHORT $LN3@D3D9Render
	mov	ecx, DWORD PTR $T159620[ebp]
	call	??0D3DEnumeration@Ogre@@QAE@XZ		; Ogre::D3DEnumeration::D3DEnumeration
	mov	DWORD PTR tv139[ebp], eax
	jmp	SHORT $LN4@D3D9Render
$LN3@D3D9Render:
	mov	DWORD PTR tv139[ebp], 0
$LN4@D3D9Render:
	mov	eax, DWORD PTR tv139[ebp]
	mov	DWORD PTR $T159619[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T159619[ebp]
	mov	DWORD PTR [ecx+420], edx

; 73   : 		m_restoreDeviceCallBack = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+92], 0

; 74   : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$??0D3D9RenderSystem@Ogre@@QAE@PAUHINSTANCE__@@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1RenderSystem@Ogre@@QAE@XZ
__unwindfunclet$??0D3D9RenderSystem@Ogre@@QAE@PAUHINSTANCE__@@@Z$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 464				; 000001d0H
	jmp	??1?$vector@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >::~vector<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >
__unwindfunclet$??0D3D9RenderSystem@Ogre@@QAE@PAUHINSTANCE__@@@Z$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 488				; 000001e8H
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$??0D3D9RenderSystem@Ogre@@QAE@PAUHINSTANCE__@@@Z$3:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 520				; 00000208H
	jmp	??1?$vector@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >::~vector<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >
__unwindfunclet$??0D3D9RenderSystem@Ogre@@QAE@PAUHINSTANCE__@@@Z$4:
	mov	eax, DWORD PTR $T159620[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$??0D3D9RenderSystem@Ogre@@QAE@PAUHINSTANCE__@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0D3D9RenderSystem@Ogre@@QAE@PAUHINSTANCE__@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0D3D9RenderSystem@Ogre@@QAE@PAUHINSTANCE__@@@Z ENDP	; Ogre::D3D9RenderSystem::D3D9RenderSystem
PUBLIC	??_GD3DEnumeration@Ogre@@QAEPAXI@Z		; Ogre::D3DEnumeration::`scalar deleting destructor'
PUBLIC	??1D3D9RenderSystem@Ogre@@QAE@XZ		; Ogre::D3D9RenderSystem::~D3D9RenderSystem
xdata$x	SEGMENT
__unwindtable$??1D3D9RenderSystem@Ogre@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1D3D9RenderSystem@Ogre@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1D3D9RenderSystem@Ogre@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??1D3D9RenderSystem@Ogre@@QAE@XZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$??1D3D9RenderSystem@Ogre@@QAE@XZ$3
__ehfuncinfo$??1D3D9RenderSystem@Ogre@@QAE@XZ DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$??1D3D9RenderSystem@Ogre@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
_TEXT	SEGMENT
tv85 = -28						; size = 4
_this$ = -24						; size = 4
$T159639 = -20						; size = 4
$T159638 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1D3D9RenderSystem@Ogre@@QAE@XZ PROC			; Ogre::D3D9RenderSystem::~D3D9RenderSystem
; _this$ = ecx

; 77   : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1D3D9RenderSystem@Ogre@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 16					; 00000010H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7D3D9RenderSystem@Ogre@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], 3

; 78   : 		delete m_pD3DEnum;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+420]
	mov	DWORD PTR $T159639[ebp], edx
	mov	eax, DWORD PTR $T159639[ebp]
	mov	DWORD PTR $T159638[ebp], eax
	cmp	DWORD PTR $T159638[ebp], 0
	je	SHORT $LN3@D3D9Render@2
	push	1
	mov	ecx, DWORD PTR $T159638[ebp]
	call	??_GD3DEnumeration@Ogre@@QAEPAXI@Z
	mov	DWORD PTR tv85[ebp], eax
	jmp	SHORT $LN1@D3D9Render@2
$LN3@D3D9Render@2:
	mov	DWORD PTR tv85[ebp], 0
$LN1@D3D9Render@2:

; 79   : 	}

	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 520				; 00000208H
	call	??1?$vector@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >::~vector<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 488				; 000001e8H
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 464				; 000001d0H
	call	??1?$vector@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >::~vector<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1RenderSystem@Ogre@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$??1D3D9RenderSystem@Ogre@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1RenderSystem@Ogre@@QAE@XZ
__unwindfunclet$??1D3D9RenderSystem@Ogre@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 464				; 000001d0H
	jmp	??1?$vector@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >::~vector<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >
__unwindfunclet$??1D3D9RenderSystem@Ogre@@QAE@XZ$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 488				; 000001e8H
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$??1D3D9RenderSystem@Ogre@@QAE@XZ$3:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 520				; 00000208H
	jmp	??1?$vector@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >::~vector<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >
__ehhandler$??1D3D9RenderSystem@Ogre@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1D3D9RenderSystem@Ogre@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1D3D9RenderSystem@Ogre@@QAE@XZ ENDP			; Ogre::D3D9RenderSystem::~D3D9RenderSystem
EXTRN	??1D3DEnumeration@Ogre@@QAE@XZ:PROC		; Ogre::D3DEnumeration::~D3DEnumeration
; Function compile flags: /Odtp
;	COMDAT ??_GD3DEnumeration@Ogre@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GD3DEnumeration@Ogre@@QAEPAXI@Z PROC			; Ogre::D3DEnumeration::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1D3DEnumeration@Ogre@@QAE@XZ		; Ogre::D3DEnumeration::~D3DEnumeration
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GD3DEnumeration@Ogre@@QAEPAXI@Z ENDP			; Ogre::D3DEnumeration::`scalar deleting destructor'
; Function compile flags: /Odtp
_TEXT	ENDS
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pfilename$ = 8						; size = 4
?CreateShaderTechniqueFromRawFile@D3D9RenderSystem@Ogre@@UAEPAVShaderTechnique@2@PBD@Z PROC ; Ogre::D3D9RenderSystem::CreateShaderTechniqueFromRawFile
; _this$ = ecx

; 82   : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 83   : 		return NULL;

	xor	eax, eax

; 84   : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
?CreateShaderTechniqueFromRawFile@D3D9RenderSystem@Ogre@@UAEPAVShaderTechnique@2@PBD@Z ENDP ; Ogre::D3D9RenderSystem::CreateShaderTechniqueFromRawFile
_TEXT	ENDS
EXTRN	__fltused:DWORD
; Function compile flags: /Odtp
_TEXT	SEGMENT
_this$ = -8						; size = 4
_i$151533 = -4						; size = 4
_desc$ = 8						; size = 4
?setContextQueDesc@D3D9RenderSystem@Ogre@@UAEXABUContextQueDesc@2@@Z PROC ; Ogre::D3D9RenderSystem::setContextQueDesc
; _this$ = ecx

; 87   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 88   : 		setViewport(desc.viewport);

	mov	eax, DWORD PTR _desc$[ebp]
	add	eax, 20					; 00000014H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	call	eax

; 89   : 
; 90   : 		if(desc.clearflags)

	mov	ecx, DWORD PTR _desc$[ebp]
	cmp	DWORD PTR [ecx+4], 0
	je	SHORT $LN7@setContext

; 91   : 		{
; 92   : 			clear(desc.clearflags, desc.clearcolor, desc.cleardepth, desc.clearstencil);

	mov	edx, DWORD PTR _desc$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR _desc$[ebp]
	push	ecx
	fld	DWORD PTR [ecx+12]
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _desc$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	mov	ecx, DWORD PTR _desc$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	call	eax
$LN7@setContext:

; 93   : 		}
; 94   : 		
; 95   : 		if(desc.clipflags)

	mov	ecx, DWORD PTR _desc$[ebp]
	cmp	DWORD PTR [ecx+44], 0
	je	SHORT $LN6@setContext

; 96   : 		{
; 97   : 			m_pd3dDevice->SetRenderState(D3DRS_CLIPPLANEENABLE, 1);

	push	1
	push	152					; 00000098H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+104]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+104]
	mov	eax, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR [eax+228]
	call	ecx

; 98   : 			for(uint i=0; i<6; i++)

	mov	DWORD PTR _i$151533[ebp], 0
	jmp	SHORT $LN5@setContext
$LN4@setContext:
	mov	edx, DWORD PTR _i$151533[ebp]
	add	edx, 1
	mov	DWORD PTR _i$151533[ebp], edx
$LN5@setContext:
	cmp	DWORD PTR _i$151533[ebp], 6
	jae	SHORT $LN3@setContext

; 99   : 			{
; 100  : 				if(desc.clipflags&(1<<i))

	mov	eax, 1
	mov	ecx, DWORD PTR _i$151533[ebp]
	shl	eax, cl
	mov	ecx, DWORD PTR _desc$[ebp]
	and	eax, DWORD PTR [ecx+44]
	je	SHORT $LN2@setContext

; 101  : 				{
; 102  : 					m_pd3dDevice->SetClipPlane(i, desc.clipplane[i]);

	mov	edx, DWORD PTR _i$151533[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _desc$[ebp]
	lea	ecx, DWORD PTR [eax+edx+48]
	push	ecx
	mov	edx, DWORD PTR _i$151533[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+104]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+104]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	mov	edx, DWORD PTR [ecx+220]
	call	edx
$LN2@setContext:

; 103  : 				}
; 104  : 			}

	jmp	SHORT $LN4@setContext
$LN3@setContext:

; 105  : 		}
; 106  : 		else m_pd3dDevice->SetRenderState(D3DRS_CLIPPLANEENABLE, 0);

	jmp	SHORT $LN1@setContext
$LN6@setContext:
	push	0
	push	152					; 00000098H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+104]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+104]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	mov	edx, DWORD PTR [ecx+228]
	call	edx
$LN1@setContext:

; 107  : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
?setContextQueDesc@D3D9RenderSystem@Ogre@@UAEXABUContextQueDesc@2@@Z ENDP ; Ogre::D3D9RenderSystem::setContextQueDesc
_TEXT	ENDS
EXTRN	_D3DXLoadSurfaceFromSurface@32:PROC
; Function compile flags: /Odtp
_TEXT	SEGMENT
_this$ = -80						; size = 4
_x$151567 = -76						; size = 4
_p$151565 = -72						; size = 4
_y$151561 = -68						; size = 4
_pd3dtex$ = -64						; size = 4
_surfdesc$ = -60					; size = 32
_lockedrect$ = -28					; size = 8
_srcrect$ = -20						; size = 16
_psurface$ = -4						; size = 4
_ptex$ = 8						; size = 4
_hotspotx$ = 12						; size = 4
_hotspoty$ = 16						; size = 4
_u$ = 20						; size = 4
_v$ = 24						; size = 4
_width$ = 28						; size = 4
_height$ = 32						; size = 4
?setCursorProperty@D3D9RenderSystem@Ogre@@UAEXPAVTextureData@2@HHHHHH@Z PROC ; Ogre::D3D9RenderSystem::setCursorProperty
; _this$ = ecx

; 110  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	mov	DWORD PTR _this$[ebp], ecx

; 111  : 		RECT srcrect;
; 112  : 		srcrect.left = u;

	mov	eax, DWORD PTR _u$[ebp]
	mov	DWORD PTR _srcrect$[ebp], eax

; 113  : 		srcrect.top = v;

	mov	ecx, DWORD PTR _v$[ebp]
	mov	DWORD PTR _srcrect$[ebp+4], ecx

; 114  : 		srcrect.right = u + width;

	mov	edx, DWORD PTR _u$[ebp]
	add	edx, DWORD PTR _width$[ebp]
	mov	DWORD PTR _srcrect$[ebp+8], edx

; 115  : 		srcrect.bottom = v + height;

	mov	eax, DWORD PTR _v$[ebp]
	add	eax, DWORD PTR _height$[ebp]
	mov	DWORD PTR _srcrect$[ebp+12], eax

; 116  : 
; 117  : 		if(ptex == NULL) return;

	cmp	DWORD PTR _ptex$[ebp], 0
	jne	SHORT $LN10@setCursorP
	jmp	$LN11@setCursorP
$LN10@setCursorP:

; 118  : 		D3D9HardwarePixelBuffer *pd3dtex = static_cast<D3D9HardwarePixelBuffer *>(ptex->getHardwareTexture());

	mov	ecx, DWORD PTR _ptex$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _ptex$[ebp]
	mov	eax, DWORD PTR [edx+32]
	call	eax
	mov	DWORD PTR _pd3dtex$[ebp], eax

; 119  : 		if(pd3dtex->m_pSysTex == NULL) return;

	mov	ecx, DWORD PTR _pd3dtex$[ebp]
	cmp	DWORD PTR [ecx+20], 0
	jne	SHORT $LN9@setCursorP
	jmp	$LN11@setCursorP
$LN9@setCursorP:

; 120  : 
; 121  : 		IDirect3DSurface9 *psurface;
; 122  : 		if(FAILED(static_cast<IDirect3DTexture9 *>(pd3dtex->m_pSysTex)->GetSurfaceLevel(0, &psurface))) return;

	lea	edx, DWORD PTR _psurface$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _pd3dtex$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	edx, DWORD PTR _pd3dtex$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	mov	edx, DWORD PTR [ecx+72]
	call	edx
	test	eax, eax
	jge	SHORT $LN8@setCursorP
	jmp	$LN11@setCursorP
$LN8@setCursorP:

; 123  : 
; 124  : 		D3DSURFACE_DESC surfdesc;
; 125  : 		psurface->GetDesc(&surfdesc);

	lea	eax, DWORD PTR _surfdesc$[ebp]
	push	eax
	mov	ecx, DWORD PTR _psurface$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _psurface$[ebp]
	push	eax
	mov	ecx, DWORD PTR [edx+48]
	call	ecx

; 126  : 		D3DXLoadSurfaceFromSurface(m_pCursorSurface, NULL, NULL, psurface, NULL, &srcrect, D3DX_DEFAULT, 0);

	push	0
	push	-1
	lea	edx, DWORD PTR _srcrect$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _psurface$[ebp]
	push	eax
	push	0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+556]
	push	edx
	call	_D3DXLoadSurfaceFromSurface@32

; 127  : 
; 128  : 		D3DLOCKED_RECT lockedrect;
; 129  : 		m_pCursorSurface->LockRect(&lockedrect, NULL, 0);

	push	0
	push	0
	lea	eax, DWORD PTR _lockedrect$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+556]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+556]
	mov	edx, DWORD PTR [edx]
	push	ecx
	mov	eax, DWORD PTR [edx+52]
	call	eax

; 130  : 		for(int y=0; y<32; y++)

	mov	DWORD PTR _y$151561[ebp], 0
	jmp	SHORT $LN7@setCursorP
$LN6@setCursorP:
	mov	ecx, DWORD PTR _y$151561[ebp]
	add	ecx, 1
	mov	DWORD PTR _y$151561[ebp], ecx
$LN7@setCursorP:
	cmp	DWORD PTR _y$151561[ebp], 32		; 00000020H
	jge	SHORT $LN5@setCursorP

; 131  : 		{
; 132  : 			unsigned char *p = (unsigned char *)lockedrect.pBits + y*lockedrect.Pitch;

	mov	edx, DWORD PTR _y$151561[ebp]
	imul	edx, DWORD PTR _lockedrect$[ebp]
	add	edx, DWORD PTR _lockedrect$[ebp+4]
	mov	DWORD PTR _p$151565[ebp], edx

; 133  : 			for(int x=0; x<32; x++)

	mov	DWORD PTR _x$151567[ebp], 0
	jmp	SHORT $LN4@setCursorP
$LN3@setCursorP:
	mov	eax, DWORD PTR _x$151567[ebp]
	add	eax, 1
	mov	DWORD PTR _x$151567[ebp], eax
$LN4@setCursorP:
	cmp	DWORD PTR _x$151567[ebp], 32		; 00000020H
	jge	SHORT $LN2@setCursorP

; 134  : 			{
; 135  : 				if(p[x*4+3] > 0) p[x*4+3] = 255; 

	mov	ecx, DWORD PTR _x$151567[ebp]
	mov	edx, DWORD PTR _p$151565[ebp]
	movzx	eax, BYTE PTR [edx+ecx*4+3]
	test	eax, eax
	jle	SHORT $LN1@setCursorP
	mov	ecx, DWORD PTR _x$151567[ebp]
	mov	edx, DWORD PTR _p$151565[ebp]
	mov	BYTE PTR [edx+ecx*4+3], 255		; 000000ffH
$LN1@setCursorP:

; 136  : 				//p[x*4+0] = 0xff;
; 137  : 				//p[x*4+1] = 0xff;
; 138  : 				//p[x*4+2] = 0xff;
; 139  : 				//p[x*4+3] = 0xff;
; 140  : 			}

	jmp	SHORT $LN3@setCursorP
$LN2@setCursorP:

; 141  : 		}

	jmp	SHORT $LN6@setCursorP
$LN5@setCursorP:

; 142  : 		m_pCursorSurface->UnlockRect();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+556]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+556]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	mov	edx, DWORD PTR [ecx+56]
	call	edx

; 143  : 		m_pd3dDevice->SetCursorProperties(hotspotx, hotspoty, m_pCursorSurface);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+556]
	push	ecx
	mov	edx, DWORD PTR _hotspoty$[ebp]
	push	edx
	mov	eax, DWORD PTR _hotspotx$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+104]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+104]
	mov	edx, DWORD PTR [edx]
	push	ecx
	mov	eax, DWORD PTR [edx+40]
	call	eax

; 144  : 		psurface->Release();

	mov	ecx, DWORD PTR _psurface$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _psurface$[ebp]
	push	eax
	mov	ecx, DWORD PTR [edx+8]
	call	ecx
$LN11@setCursorP:

; 145  : 
; 146  : 		/*
; 147  : 		SurfaceData *psurfdata = ptex->lockSurface(0, 0, true);
; 148  : 		D3DFORMAT srcfmt = fromPixelFormat(psurfdata->m_Format);
; 149  : 		D3DXLoadSurfaceFromMemory(m_pCursorSurface, NULL, NULL, psurfdata->getBits(), srcfmt, psurfdata->m_RowPitch, NULL, &srcrect, D3DX_DEFAULT, 0);
; 150  : 		ptex->unlockSurface(0, 0);
; 151  : 
; 152  : 		
; 153  : 		//!!! 光标的surface的alpha通道一定要是0, 255吗？
; 154  : 		D3DLOCKED_RECT lockedrect;
; 155  : 		m_pCursorSurface->LockRect(&lockedrect, NULL, 0);
; 156  : 		for(int y=0; y<32; y++)
; 157  : 		{
; 158  : 			unsigned char *p = (unsigned char *)lockedrect.pBits + y*lockedrect.Pitch;
; 159  : 			for(int x=0; x<32; x++)
; 160  : 			{
; 161  : 				if(p[x*4+3] > 0) p[x*4+3] = 255; 
; 162  : 				//p[x*4+0] = 0xff;
; 163  : 				//p[x*4+1] = 0xff;
; 164  : 				//p[x*4+2] = 0xff;
; 165  : 				//p[x*4+3] = 0xff;
; 166  : 			}
; 167  : 		}
; 168  : 		m_pCursorSurface->UnlockRect();
; 169  : 
; 170  : 		HRESULT hr = m_pd3dDevice->SetCursorProperties(hotspotx, hotspoty, m_pCursorSurface);
; 171  : 		if(FAILED(hr))
; 172  : 		{
; 173  : 			int aaa = 0;
; 174  : 		}*/
; 175  : 	}

	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
?setCursorProperty@D3D9RenderSystem@Ogre@@UAEXPAVTextureData@2@HHHHHH@Z ENDP ; Ogre::D3D9RenderSystem::setCursorProperty
; Function compile flags: /Odtp
_this$ = -4						; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
?setCursorPosition@D3D9RenderSystem@Ogre@@UAEXHH@Z PROC	; Ogre::D3D9RenderSystem::setCursorPosition
; _this$ = ecx

; 178  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 179  : 		m_pd3dDevice->SetCursorPosition(x, y, D3DCURSOR_IMMEDIATE_UPDATE);

	push	1
	mov	eax, DWORD PTR _y$[ebp]
	push	eax
	mov	ecx, DWORD PTR _x$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+104]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+104]
	mov	eax, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR [eax+44]
	call	ecx

; 180  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?setCursorPosition@D3D9RenderSystem@Ogre@@UAEXHH@Z ENDP	; Ogre::D3D9RenderSystem::setCursorPosition
; Function compile flags: /Odtp
_this$ = -4						; size = 4
_b$ = 8							; size = 1
?showCursor@D3D9RenderSystem@Ogre@@UAEX_N@Z PROC	; Ogre::D3D9RenderSystem::showCursor
; _this$ = ecx

; 183  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 184  : 		m_pd3dDevice->ShowCursor(b?TRUE:FALSE);

	movzx	eax, BYTE PTR _b$[ebp]
	neg	eax
	sbb	eax, eax
	neg	eax
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+104]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+104]
	mov	edx, DWORD PTR [edx]
	push	ecx
	mov	eax, DWORD PTR [edx+48]
	call	eax

; 185  : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
?showCursor@D3D9RenderSystem@Ogre@@UAEX_N@Z ENDP	; Ogre::D3D9RenderSystem::showCursor
_TEXT	ENDS
PUBLIC	??0D3D9HardwareBufferManager@Ogre@@QAE@PAVD3D9RenderSystem@1@@Z ; Ogre::D3D9HardwareBufferManager::D3D9HardwareBufferManager
PUBLIC	?push_back@?$vector@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@QAEXABQAVD3DRenderWindow@Ogre@@@Z ; std::vector<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >::push_back
PUBLIC	__$ArrayPad$
EXTRN	__imp_??3MemoryDelegation@Ogre@@SAXPAXI@Z:PROC
EXTRN	?loadShaderEnvKeys@D3D9MaterialManager@Ogre@@QAEXXZ:PROC ; Ogre::D3D9MaterialManager::loadShaderEnvKeys
EXTRN	?loadCompiledSahdersFromDataStream@D3D9MaterialManager@Ogre@@QAEXXZ:PROC ; Ogre::D3D9MaterialManager::loadCompiledSahdersFromDataStream
EXTRN	__imp_?isLoadShaderCache@Root@Ogre@@QAE_NXZ:PROC
EXTRN	__imp_?getSingletonPtr@?$Singleton@VRoot@Ogre@@@Ogre@@SAPAVRoot@2@XZ:PROC
EXTRN	__imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ:PROC
EXTRN	__imp_?loadTemplates@MaterialManager@Ogre@@QAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z:PROC
EXTRN	??0D3D9MaterialManager@Ogre@@QAE@PAVD3D9RenderSystem@1@@Z:PROC ; Ogre::D3D9MaterialManager::D3D9MaterialManager
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z:PROC
EXTRN	??0D3D9HardwarePixelBufferManager@Ogre@@QAE@PAVD3D9RenderSystem@1@@Z:PROC ; Ogre::D3D9HardwarePixelBufferManager::D3D9HardwarePixelBufferManager
EXTRN	?onInitialise@D3DRenderWindow@Ogre@@QAE_NXZ:PROC ; Ogre::D3DRenderWindow::onInitialise
EXTRN	??0D3DRenderWindow@Ogre@@QAE@PAVD3D9RenderSystem@1@ABUInitDesc@RenderSystem@1@_N@Z:PROC ; Ogre::D3DRenderWindow::D3DRenderWindow
EXTRN	__imp_??2MemoryDelegation@Ogre@@SAPAXI@Z:PROC
EXTRN	?Enumerate@D3DEnumeration@Ogre@@QAEHPAUIDirect3D9@@P6AHPAU_D3DCAPS9@@W4VERTPROCESS_T@2@W4_D3DFORMAT@@3@Z@Z:PROC ; Ogre::D3DEnumeration::Enumerate
EXTRN	__imp__GlobalMemoryStatus@4:PROC
EXTRN	__imp__GetVersionExA@4:PROC
EXTRN	__imp__GetLocalTime@4:PROC
EXTRN	__imp_?LogMessage@Ogre@@YAXPBDZZ:PROC
EXTRN	__imp_?LogSetCurParam@Ogre@@YAXPBDHI@Z:PROC
EXTRN	_Direct3DCreate9@4:PROC
xdata$x	SEGMENT
__ehfuncinfo$?initialise@D3D9RenderSystem@Ogre@@UAE_NABUInitDesc@RenderSystem@2@@Z DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$?initialise@D3D9RenderSystem@Ogre@@UAE_NABUInitDesc@RenderSystem@2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__unwindtable$?initialise@D3D9RenderSystem@Ogre@@UAE_NABUInitDesc@RenderSystem@2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?initialise@D3D9RenderSystem@Ogre@@UAE_NABUInitDesc@RenderSystem@2@@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?initialise@D3D9RenderSystem@Ogre@@UAE_NABUInitDesc@RenderSystem@2@@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?initialise@D3D9RenderSystem@Ogre@@UAE_NABUInitDesc@RenderSystem@2@@Z$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?initialise@D3D9RenderSystem@Ogre@@UAE_NABUInitDesc@RenderSystem@2@@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$?initialise@D3D9RenderSystem@Ogre@@UAE_NABUInitDesc@RenderSystem@2@@Z$4
; Function compile flags: /Odtp
xdata$x	ENDS
_TEXT	SEGMENT
tv349 = -1432						; size = 4
tv336 = -1428						; size = 4
tv327 = -1424						; size = 4
tv255 = -1420						; size = 4
tv241 = -1416						; size = 4
_this$ = -1412						; size = 4
$T159682 = -1407					; size = 1
$T159681 = -1406					; size = 1
$T159680 = -1405					; size = 1
$T159677 = -1404					; size = 4
$T159676 = -1400					; size = 4
$T159673 = -1396					; size = 4
$T159672 = -1392					; size = 4
$T159669 = -1388					; size = 4
$T159668 = -1384					; size = 4
$T159665 = -1380					; size = 4
$T159664 = -1376					; size = 4
$T159661 = -1372					; size = 4
$T159660 = -1368					; size = 4
_AdID$ = -1364						; size = 1100
_vsModel$ = -256					; size = 4
_os_ver$ = -252						; size = 148
_mem_st$ = -100						; size = 32
_tm$ = -68						; size = 16
_ptarget$ = -52						; size = 4
_mtlpath$ = -48						; size = 28
__$ArrayPad$ = -20					; size = 4
_psModel$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_desc$ = 8						; size = 4
?initialise@D3D9RenderSystem@Ogre@@UAE_NABUInitDesc@RenderSystem@2@@Z PROC ; Ogre::D3D9RenderSystem::initialise
; _this$ = ecx

; 188  : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?initialise@D3D9RenderSystem@Ogre@@UAE_NABUInitDesc@RenderSystem@2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 1420				; 0000058cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 189  : 		m_bDebugVS  = desc.debug_vs;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _desc$[ebp]
	mov	dl, BYTE PTR [ecx+7]
	mov	BYTE PTR [eax+516], dl

; 190  : 		m_bDebugPS  = desc.debug_ps;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _desc$[ebp]
	mov	dl, BYTE PTR [ecx+8]
	mov	BYTE PTR [eax+517], dl

; 191  : 		m_bDebug_nv = desc.debug_nv;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _desc$[ebp]
	mov	dl, BYTE PTR [ecx+9]
	mov	BYTE PTR [eax+518], dl

; 192  : 
; 193  : 		// Create the Direct3D object
; 194  : 		m_pD3D = Direct3DCreate9( D3D_SDK_VERSION );

	push	32					; 00000020H
	call	_Direct3DCreate9@4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+100], eax

; 195  : 		if( m_pD3D == NULL )

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+100], 0
	jne	SHORT $LN19@initialise

; 196  : 		{
; 197  : 			LOG_SEVERE( "Failed to create Direct3D" );

	push	8
	push	197					; 000000c5H
	push	OFFSET $SG151586
	call	DWORD PTR __imp_?LogSetCurParam@Ogre@@YAXPBDHI@Z
	add	esp, 12					; 0000000cH
	push	OFFSET $SG151587
	call	DWORD PTR __imp_?LogMessage@Ogre@@YAXPBDZZ
	add	esp, 4

; 198  : 			return false;

	xor	al, al
	jmp	$LN20@initialise
$LN19@initialise:

; 199  : 		}
; 200  : 
; 201  : 		//本机硬件信息
; 202  : 		D3DADAPTER_IDENTIFIER9 AdID;
; 203  : 		m_pD3D->GetAdapterIdentifier(D3DADAPTER_DEFAULT, 0, &AdID);

	lea	eax, DWORD PTR _AdID$[ebp]
	push	eax
	push	0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+100]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+100]
	mov	edx, DWORD PTR [edx]
	push	ecx
	mov	eax, DWORD PTR [edx+20]
	call	eax

; 204  : 		LOG_INFO("D3D Driver: %s\n",AdID.Driver);

	push	2
	push	204					; 000000ccH
	push	OFFSET $SG151589
	call	DWORD PTR __imp_?LogSetCurParam@Ogre@@YAXPBDHI@Z
	add	esp, 12					; 0000000cH
	lea	ecx, DWORD PTR _AdID$[ebp]
	push	ecx
	push	OFFSET $SG151590
	call	DWORD PTR __imp_?LogMessage@Ogre@@YAXPBDZZ
	add	esp, 8

; 205  : 		LOG_INFO("Description: %s\n",AdID.Description);

	push	2
	push	205					; 000000cdH
	push	OFFSET $SG151591
	call	DWORD PTR __imp_?LogSetCurParam@Ogre@@YAXPBDHI@Z
	add	esp, 12					; 0000000cH
	lea	edx, DWORD PTR _AdID$[ebp+512]
	push	edx
	push	OFFSET $SG151592
	call	DWORD PTR __imp_?LogMessage@Ogre@@YAXPBDZZ
	add	esp, 8

; 206  : 		LOG_INFO("Version: %d.%d.%d.%d\n",
; 207  : 			HIWORD(AdID.DriverVersion.HighPart),
; 208  : 			LOWORD(AdID.DriverVersion.HighPart),
; 209  : 			HIWORD(AdID.DriverVersion.LowPart),
; 210  : 			LOWORD(AdID.DriverVersion.LowPart));

	push	2
	push	206					; 000000ceH
	push	OFFSET $SG151601
	call	DWORD PTR __imp_?LogSetCurParam@Ogre@@YAXPBDHI@Z
	add	esp, 12					; 0000000cH
	mov	eax, DWORD PTR _AdID$[ebp+1056]
	and	eax, 65535				; 0000ffffH
	movzx	ecx, ax
	push	ecx
	mov	edx, DWORD PTR _AdID$[ebp+1056]
	shr	edx, 16					; 00000010H
	and	edx, 65535				; 0000ffffH
	movzx	eax, dx
	push	eax
	mov	ecx, DWORD PTR _AdID$[ebp+1060]
	and	ecx, 65535				; 0000ffffH
	movzx	edx, cx
	push	edx
	mov	eax, DWORD PTR _AdID$[ebp+1060]
	shr	eax, 16					; 00000010H
	and	eax, 65535				; 0000ffffH
	movzx	ecx, ax
	push	ecx
	push	OFFSET $SG151602
	call	DWORD PTR __imp_?LogMessage@Ogre@@YAXPBDZZ
	add	esp, 20					; 00000014H

; 211  : 
; 212  : 		SYSTEMTIME		tm;
; 213  : 		OSVERSIONINFO	os_ver;
; 214  : 		MEMORYSTATUS	mem_st;
; 215  : 
; 216  : 		GetLocalTime(&tm);

	lea	edx, DWORD PTR _tm$[ebp]
	push	edx
	call	DWORD PTR __imp__GetLocalTime@4

; 217  : 		LOG_INFO("Date: %02d.%02d.%d, %02d:%02d:%02d\n", tm.wDay, tm.wMonth, tm.wYear, tm.wHour, tm.wMinute, tm.wSecond);

	push	2
	push	217					; 000000d9H
	push	OFFSET $SG151606
	call	DWORD PTR __imp_?LogSetCurParam@Ogre@@YAXPBDHI@Z
	add	esp, 12					; 0000000cH
	movzx	eax, WORD PTR _tm$[ebp+12]
	push	eax
	movzx	ecx, WORD PTR _tm$[ebp+10]
	push	ecx
	movzx	edx, WORD PTR _tm$[ebp+8]
	push	edx
	movzx	eax, WORD PTR _tm$[ebp]
	push	eax
	movzx	ecx, WORD PTR _tm$[ebp+2]
	push	ecx
	movzx	edx, WORD PTR _tm$[ebp+6]
	push	edx
	push	OFFSET $SG151607
	call	DWORD PTR __imp_?LogMessage@Ogre@@YAXPBDZZ
	add	esp, 28					; 0000001cH

; 218  : 
; 219  : 		os_ver.dwOSVersionInfoSize=sizeof(os_ver);

	mov	DWORD PTR _os_ver$[ebp], 148		; 00000094H

; 220  : 		GetVersionEx(&os_ver);

	lea	eax, DWORD PTR _os_ver$[ebp]
	push	eax
	call	DWORD PTR __imp__GetVersionExA@4

; 221  : 		LOG_INFO("OS: Windows %ld.%ld.%ld\n",os_ver.dwMajorVersion,os_ver.dwMinorVersion,os_ver.dwBuildNumber);

	push	2
	push	221					; 000000ddH
	push	OFFSET $SG151608
	call	DWORD PTR __imp_?LogSetCurParam@Ogre@@YAXPBDHI@Z
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR _os_ver$[ebp+12]
	push	ecx
	mov	edx, DWORD PTR _os_ver$[ebp+8]
	push	edx
	mov	eax, DWORD PTR _os_ver$[ebp+4]
	push	eax
	push	OFFSET $SG151609
	call	DWORD PTR __imp_?LogMessage@Ogre@@YAXPBDZZ
	add	esp, 16					; 00000010H

; 222  : 
; 223  : 		GlobalMemoryStatus(&mem_st);

	lea	ecx, DWORD PTR _mem_st$[ebp]
	push	ecx
	call	DWORD PTR __imp__GlobalMemoryStatus@4

; 224  : 		LOG_INFO("Memory: %ldK total, %ldK free\n",mem_st.dwTotalPhys/1024L,mem_st.dwAvailPhys/1024L);

	push	2
	push	224					; 000000e0H
	push	OFFSET $SG151610
	call	DWORD PTR __imp_?LogSetCurParam@Ogre@@YAXPBDHI@Z
	add	esp, 12					; 0000000cH
	mov	edx, DWORD PTR _mem_st$[ebp+12]
	shr	edx, 10					; 0000000aH
	push	edx
	mov	eax, DWORD PTR _mem_st$[ebp+8]
	shr	eax, 10					; 0000000aH
	push	eax
	push	OFFSET $SG151611
	call	DWORD PTR __imp_?LogMessage@Ogre@@YAXPBDZZ
	add	esp, 12					; 0000000cH

; 225  : 
; 226  : 		if( !m_pD3DEnum->Enumerate(m_pD3D, ConfirmDeviceHelper) )

	push	OFFSET ?ConfirmDeviceHelper@Ogre@@YAHPAU_D3DCAPS9@@W4VERTPROCESS_T@1@W4_D3DFORMAT@@2@Z ; Ogre::ConfirmDeviceHelper
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+100]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+420]
	call	?Enumerate@D3DEnumeration@Ogre@@QAEHPAUIDirect3D9@@P6AHPAU_D3DCAPS9@@W4VERTPROCESS_T@2@W4_D3DFORMAT@@3@Z@Z ; Ogre::D3DEnumeration::Enumerate
	test	eax, eax
	jne	SHORT $LN18@initialise

; 227  : 		{
; 228  : 			LOG_SEVERE( "Failed to enumerate device" );

	push	8
	push	228					; 000000e4H
	push	OFFSET $SG151613
	call	DWORD PTR __imp_?LogSetCurParam@Ogre@@YAXPBDHI@Z
	add	esp, 12					; 0000000cH
	push	OFFSET $SG151614
	call	DWORD PTR __imp_?LogMessage@Ogre@@YAXPBDZZ
	add	esp, 4

; 229  : 			return false;

	xor	al, al
	jmp	$LN20@initialise
$LN18@initialise:

; 230  : 		}
; 231  : 
; 232  : 		D3DRenderWindow *ptarget = new D3DRenderWindow(this, desc, true);

	push	128					; 00000080H
	call	DWORD PTR __imp_??2MemoryDelegation@Ogre@@SAPAXI@Z
	add	esp, 4
	mov	DWORD PTR $T159661[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T159661[ebp], 0
	je	SHORT $LN22@initialise
	push	1
	mov	ecx, DWORD PTR _desc$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T159661[ebp]
	call	??0D3DRenderWindow@Ogre@@QAE@PAVD3D9RenderSystem@1@ABUInitDesc@RenderSystem@1@_N@Z ; Ogre::D3DRenderWindow::D3DRenderWindow
	mov	DWORD PTR tv241[ebp], eax
	jmp	SHORT $LN23@initialise
$LN22@initialise:
	mov	DWORD PTR tv241[ebp], 0
$LN23@initialise:
	mov	eax, DWORD PTR tv241[ebp]
	mov	DWORD PTR $T159660[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR $T159660[ebp]
	mov	DWORD PTR _ptarget$[ebp], ecx

; 233  : 		if(!ptarget->onInitialise())

	mov	ecx, DWORD PTR _ptarget$[ebp]
	call	?onInitialise@D3DRenderWindow@Ogre@@QAE_NXZ ; Ogre::D3DRenderWindow::onInitialise
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN17@initialise

; 234  : 		{
; 235  : 			delete ptarget;

	mov	eax, DWORD PTR _ptarget$[ebp]
	mov	DWORD PTR $T159665[ebp], eax
	mov	ecx, DWORD PTR $T159665[ebp]
	mov	DWORD PTR $T159664[ebp], ecx
	cmp	DWORD PTR $T159664[ebp], 0
	je	SHORT $LN24@initialise
	push	1
	mov	edx, DWORD PTR $T159664[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR $T159664[ebp]
	mov	edx, DWORD PTR [eax+20]
	call	edx
	mov	DWORD PTR tv255[ebp], eax
	jmp	SHORT $LN25@initialise
$LN24@initialise:
	mov	DWORD PTR tv255[ebp], 0
$LN25@initialise:

; 236  : 			return false;

	xor	al, al
	jmp	$LN20@initialise
$LN17@initialise:

; 237  : 		}
; 238  : 
; 239  : 		m_WindowTargets.push_back(ptarget);

	lea	eax, DWORD PTR _ptarget$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 464				; 000001d0H
	call	?push_back@?$vector@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@QAEXABQAVD3DRenderWindow@Ogre@@@Z ; std::vector<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >::push_back

; 240  : 
; 241  : 		// Store device Caps
; 242  : 		m_pd3dDevice->GetDeviceCaps( &m_d3dCaps );

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 108				; 0000006cH
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+104]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+104]
	mov	eax, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR [eax+28]
	call	ecx

; 243  : 
; 244  : 		// shdermodel判断
; 245  : 		DWORD vsModel = m_d3dCaps.VertexShaderVersion;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+304]
	mov	DWORD PTR _vsModel$[ebp], eax

; 246  : 		if (vsModel < D3DVS_VERSION(2,0))

	cmp	DWORD PTR _vsModel$[ebp], -130560	; fffe0200H
	jae	SHORT $LN16@initialise

; 247  : 		{
; 248  : 			m_iLevel = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+56], 0
	jmp	SHORT $LN15@initialise
$LN16@initialise:

; 249  : 		}
; 250  : 		else if (vsModel == D3DVS_VERSION(2,0))

	cmp	DWORD PTR _vsModel$[ebp], -130560	; fffe0200H
	jne	SHORT $LN14@initialise

; 251  : 		{
; 252  : 			m_iLevel = 1;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+56], 1
	jmp	SHORT $LN15@initialise
$LN14@initialise:

; 253  : 		}
; 254  : 		else if (vsModel >= D3DVS_VERSION(3,0))

	cmp	DWORD PTR _vsModel$[ebp], -130304	; fffe0300H
	jb	SHORT $LN12@initialise

; 255  : 		{
; 256  : 			m_iLevel = 3;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+56], 3

; 257  : 		}
; 258  : 		else

	jmp	SHORT $LN15@initialise
$LN12@initialise:

; 259  : 		{
; 260  : 			m_iLevel = 2;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+56], 2
$LN15@initialise:

; 261  : 		}
; 262  : 
; 263  : 		DWORD psModel = m_d3dCaps.PixelShaderVersion;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+312]
	mov	DWORD PTR _psModel$[ebp], eax

; 264  : 		if (psModel < D3DVS_VERSION(2,0))

	cmp	DWORD PTR _psModel$[ebp], -130560	; fffe0200H
	jae	SHORT $LN10@initialise

; 265  : 		{
; 266  : 			m_iLevel = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+56], 0
	jmp	SHORT $LN9@initialise
$LN10@initialise:

; 267  : 		}
; 268  : 		else if (psModel == D3DVS_VERSION(2,0))

	cmp	DWORD PTR _psModel$[ebp], -130560	; fffe0200H
	jne	SHORT $LN8@initialise

; 269  : 		{
; 270  : 			m_iLevel = 1;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+56], 1
	jmp	SHORT $LN9@initialise
$LN8@initialise:

; 271  : 		}
; 272  : 		else if (psModel >= D3DVS_VERSION(3,0))

	cmp	DWORD PTR _psModel$[ebp], -130304	; fffe0300H
	jb	SHORT $LN6@initialise

; 273  : 		{
; 274  : 			m_iLevel = 3;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+56], 3

; 275  : 		}
; 276  : 		else

	jmp	SHORT $LN9@initialise
$LN6@initialise:

; 277  : 		{
; 278  : 			m_iLevel = 2;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+56], 2
$LN9@initialise:

; 279  : 		}
; 280  : 
; 281  : 		m_pPBufMgr = new D3D9HardwarePixelBufferManager(this);

	push	92					; 0000005cH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T159669[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	cmp	DWORD PTR $T159669[ebp], 0
	je	SHORT $LN26@initialise
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T159669[ebp]
	call	??0D3D9HardwarePixelBufferManager@Ogre@@QAE@PAVD3D9RenderSystem@1@@Z ; Ogre::D3D9HardwarePixelBufferManager::D3D9HardwarePixelBufferManager
	mov	DWORD PTR tv327[ebp], eax
	jmp	SHORT $LN27@initialise
$LN26@initialise:
	mov	DWORD PTR tv327[ebp], 0
$LN27@initialise:
	mov	eax, DWORD PTR tv327[ebp]
	mov	DWORD PTR $T159668[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T159668[ebp]
	mov	DWORD PTR [ecx+544], edx

; 282  : 		m_pBufMgr = new D3D9HardwareBufferManager(this);

	push	40					; 00000028H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T159673[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 2
	cmp	DWORD PTR $T159673[ebp], 0
	je	SHORT $LN28@initialise
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T159673[ebp]
	call	??0D3D9HardwareBufferManager@Ogre@@QAE@PAVD3D9RenderSystem@1@@Z ; Ogre::D3D9HardwareBufferManager::D3D9HardwareBufferManager
	mov	DWORD PTR tv336[ebp], eax
	jmp	SHORT $LN29@initialise
$LN28@initialise:
	mov	DWORD PTR tv336[ebp], 0
$LN29@initialise:
	mov	ecx, DWORD PTR tv336[ebp]
	mov	DWORD PTR $T159672[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR $T159672[ebp]
	mov	DWORD PTR [edx+552], eax

; 283  : 
; 284  : 		String mtlpath("shaders\\materials.xml");

	push	OFFSET $SG151648
	lea	ecx, DWORD PTR _mtlpath$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 3

; 285  : 		m_pMtlMgr = new D3D9MaterialManager(this);

	push	44					; 0000002cH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T159677[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	cmp	DWORD PTR $T159677[ebp], 0
	je	SHORT $LN30@initialise
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T159677[ebp]
	call	??0D3D9MaterialManager@Ogre@@QAE@PAVD3D9RenderSystem@1@@Z ; Ogre::D3D9MaterialManager::D3D9MaterialManager
	mov	DWORD PTR tv349[ebp], eax
	jmp	SHORT $LN31@initialise
$LN30@initialise:
	mov	DWORD PTR tv349[ebp], 0
$LN31@initialise:
	mov	edx, DWORD PTR tv349[ebp]
	mov	DWORD PTR $T159676[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR $T159676[ebp]
	mov	DWORD PTR [eax+548], ecx

; 286  : 		if(!m_pMtlMgr->loadTemplates(mtlpath))

	lea	edx, DWORD PTR _mtlpath$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+548]
	call	DWORD PTR __imp_?loadTemplates@MaterialManager@Ogre@@QAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN4@initialise

; 287  : 		{
; 288  : 			LOG_SEVERE("load material template file error: %s", mtlpath.c_str());

	push	8
	push	288					; 00000120H
	push	OFFSET $SG151654
	call	DWORD PTR __imp_?LogSetCurParam@Ogre@@YAXPBDHI@Z
	add	esp, 12					; 0000000cH
	lea	ecx, DWORD PTR _mtlpath$[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	push	OFFSET $SG151655
	call	DWORD PTR __imp_?LogMessage@Ogre@@YAXPBDZZ
	add	esp, 8

; 289  : 			return false;

	mov	BYTE PTR $T159680[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _mtlpath$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	al, BYTE PTR $T159680[ebp]
	jmp	$LN20@initialise
$LN4@initialise:

; 290  : 		}
; 291  : 
; 292  : 		if (Root::getSingletonPtr())

	call	DWORD PTR __imp_?getSingletonPtr@?$Singleton@VRoot@Ogre@@@Ogre@@SAPAVRoot@2@XZ
	test	eax, eax
	je	SHORT $LN3@initialise

; 293  : 		{
; 294  : 			if (Root::getSingletonPtr()->isLoadShaderCache())

	call	DWORD PTR __imp_?getSingletonPtr@?$Singleton@VRoot@Ogre@@@Ogre@@SAPAVRoot@2@XZ
	mov	ecx, eax
	call	DWORD PTR __imp_?isLoadShaderCache@Root@Ogre@@QAE_NXZ
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN3@initialise

; 295  : 			{
; 296  : 				static_cast<D3D9MaterialManager *>(m_pMtlMgr)->loadCompiledSahdersFromDataStream();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+548]
	call	?loadCompiledSahdersFromDataStream@D3D9MaterialManager@Ogre@@QAEXXZ ; Ogre::D3D9MaterialManager::loadCompiledSahdersFromDataStream

; 297  : 
; 298  : 				static_cast<D3D9MaterialManager *>(m_pMtlMgr)->loadShaderEnvKeys();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+548]
	call	?loadShaderEnvKeys@D3D9MaterialManager@Ogre@@QAEXXZ ; Ogre::D3D9MaterialManager::loadShaderEnvKeys
$LN3@initialise:

; 299  : 				//static_cast<D3D9MaterialManager *>(m_pMtlMgr)->loadCompiledShaders();
; 300  : 			}
; 301  : 		}
; 302  : 
; 303  : 		if(FAILED(m_pd3dDevice->CreateOffscreenPlainSurface(32, 32, D3DFMT_A8R8G8B8, D3DPOOL_SCRATCH, &m_pCursorSurface, NULL)))

	push	0
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 556				; 0000022cH
	push	edx
	push	3
	push	21					; 00000015H
	push	32					; 00000020H
	push	32					; 00000020H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+104]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+104]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	mov	edx, DWORD PTR [ecx+144]
	call	edx
	test	eax, eax
	jge	SHORT $LN1@initialise

; 304  : 		{
; 305  : 			return false;

	mov	BYTE PTR $T159681[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _mtlpath$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	al, BYTE PTR $T159681[ebp]
	jmp	SHORT $LN20@initialise
$LN1@initialise:

; 306  : 		}
; 307  : 
; 308  : 		m_bDeviceLost = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+417], 0

; 309  : 		return true;

	mov	BYTE PTR $T159682[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _mtlpath$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	al, BYTE PTR $T159682[ebp]
$LN20@initialise:

; 310  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?initialise@D3D9RenderSystem@Ogre@@UAE_NABUInitDesc@RenderSystem@2@@Z$0:
	push	128					; 00000080H
	mov	eax, DWORD PTR $T159661[ebp]
	push	eax
	call	DWORD PTR __imp_??3MemoryDelegation@Ogre@@SAXPAXI@Z
	add	esp, 8
	ret	0
__unwindfunclet$?initialise@D3D9RenderSystem@Ogre@@UAE_NABUInitDesc@RenderSystem@2@@Z$1:
	mov	eax, DWORD PTR $T159669[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?initialise@D3D9RenderSystem@Ogre@@UAE_NABUInitDesc@RenderSystem@2@@Z$2:
	mov	eax, DWORD PTR $T159673[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?initialise@D3D9RenderSystem@Ogre@@UAE_NABUInitDesc@RenderSystem@2@@Z$3:
	lea	ecx, DWORD PTR _mtlpath$[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?initialise@D3D9RenderSystem@Ogre@@UAE_NABUInitDesc@RenderSystem@2@@Z$4:
	mov	eax, DWORD PTR $T159677[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?initialise@D3D9RenderSystem@Ogre@@UAE_NABUInitDesc@RenderSystem@2@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-1424]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?initialise@D3D9RenderSystem@Ogre@@UAE_NABUInitDesc@RenderSystem@2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?initialise@D3D9RenderSystem@Ogre@@UAE_NABUInitDesc@RenderSystem@2@@Z ENDP ; Ogre::D3D9RenderSystem::initialise
PUBLIC	??_7D3D9HardwareBufferManager@Ogre@@6B@		; Ogre::D3D9HardwareBufferManager::`vftable'
PUBLIC	??_R4D3D9HardwareBufferManager@Ogre@@6B@	; Ogre::D3D9HardwareBufferManager::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVD3D9HardwareBufferManager@Ogre@@@8	; Ogre::D3D9HardwareBufferManager `RTTI Type Descriptor'
PUBLIC	??_R3D3D9HardwareBufferManager@Ogre@@8		; Ogre::D3D9HardwareBufferManager::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2D3D9HardwareBufferManager@Ogre@@8		; Ogre::D3D9HardwareBufferManager::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@D3D9HardwareBufferManager@Ogre@@8	; Ogre::D3D9HardwareBufferManager::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@HardwareBufferManager@Ogre@@8	; Ogre::HardwareBufferManager::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVHardwareBufferManager@Ogre@@@8		; Ogre::HardwareBufferManager `RTTI Type Descriptor'
PUBLIC	??_R3HardwareBufferManager@Ogre@@8		; Ogre::HardwareBufferManager::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2HardwareBufferManager@Ogre@@8		; Ogre::HardwareBufferManager::`RTTI Base Class Array'
PUBLIC	??_R13?0A@EA@?$Singleton@VHardwareBufferManager@Ogre@@@Ogre@@8 ; Ogre::Singleton<Ogre::HardwareBufferManager>::`RTTI Base Class Descriptor at (4,-1,0,64)'
PUBLIC	??_R0?AV?$Singleton@VHardwareBufferManager@Ogre@@@Ogre@@@8 ; Ogre::Singleton<Ogre::HardwareBufferManager> `RTTI Type Descriptor'
PUBLIC	??_R3?$Singleton@VHardwareBufferManager@Ogre@@@Ogre@@8 ; Ogre::Singleton<Ogre::HardwareBufferManager>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$Singleton@VHardwareBufferManager@Ogre@@@Ogre@@8 ; Ogre::Singleton<Ogre::HardwareBufferManager>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$Singleton@VHardwareBufferManager@Ogre@@@Ogre@@8 ; Ogre::Singleton<Ogre::HardwareBufferManager>::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	__imp_??1HardwareBufferManager@Ogre@@UAE@XZ:PROC
EXTRN	__imp_??0HardwareBufferManager@Ogre@@QAE@XZ:PROC
EXTRN	??_ED3D9HardwareBufferManager@Ogre@@UAEPAXI@Z:PROC ; Ogre::D3D9HardwareBufferManager::`vector deleting destructor'
EXTRN	?newPool@D3D9HardwareBufferManager@Ogre@@UAEPAVHardwareBufferPool@2@_NW4HardwareBufferUsage@2@II@Z:PROC ; Ogre::D3D9HardwareBufferManager::newPool
;	COMDAT ??_R1A@?0A@EA@?$Singleton@VHardwareBufferManager@Ogre@@@Ogre@@8
; File i:\svnroot\client\plugins\rendersystem_d3d9\ogred3d9hardwarebuffer.h
rdata$r	SEGMENT
??_R1A@?0A@EA@?$Singleton@VHardwareBufferManager@Ogre@@@Ogre@@8 DD FLAT:??_R0?AV?$Singleton@VHardwareBufferManager@Ogre@@@Ogre@@@8 ; Ogre::Singleton<Ogre::HardwareBufferManager>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$Singleton@VHardwareBufferManager@Ogre@@@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R2?$Singleton@VHardwareBufferManager@Ogre@@@Ogre@@8
rdata$r	SEGMENT
??_R2?$Singleton@VHardwareBufferManager@Ogre@@@Ogre@@8 DD FLAT:??_R1A@?0A@EA@?$Singleton@VHardwareBufferManager@Ogre@@@Ogre@@8 ; Ogre::Singleton<Ogre::HardwareBufferManager>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3?$Singleton@VHardwareBufferManager@Ogre@@@Ogre@@8
rdata$r	SEGMENT
??_R3?$Singleton@VHardwareBufferManager@Ogre@@@Ogre@@8 DD 00H ; Ogre::Singleton<Ogre::HardwareBufferManager>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$Singleton@VHardwareBufferManager@Ogre@@@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$Singleton@VHardwareBufferManager@Ogre@@@Ogre@@@8
_DATA	SEGMENT
??_R0?AV?$Singleton@VHardwareBufferManager@Ogre@@@Ogre@@@8 DD FLAT:??_7type_info@@6B@ ; Ogre::Singleton<Ogre::HardwareBufferManager> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$Singleton@VHardwareBufferManager@Ogre@@@Ogre@@', 00H
_DATA	ENDS
;	COMDAT ??_R13?0A@EA@?$Singleton@VHardwareBufferManager@Ogre@@@Ogre@@8
rdata$r	SEGMENT
??_R13?0A@EA@?$Singleton@VHardwareBufferManager@Ogre@@@Ogre@@8 DD FLAT:??_R0?AV?$Singleton@VHardwareBufferManager@Ogre@@@Ogre@@@8 ; Ogre::Singleton<Ogre::HardwareBufferManager>::`RTTI Base Class Descriptor at (4,-1,0,64)'
	DD	00H
	DD	04H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$Singleton@VHardwareBufferManager@Ogre@@@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R2HardwareBufferManager@Ogre@@8
rdata$r	SEGMENT
??_R2HardwareBufferManager@Ogre@@8 DD FLAT:??_R1A@?0A@EA@HardwareBufferManager@Ogre@@8 ; Ogre::HardwareBufferManager::`RTTI Base Class Array'
	DD	FLAT:??_R13?0A@EA@?$Singleton@VHardwareBufferManager@Ogre@@@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R3HardwareBufferManager@Ogre@@8
rdata$r	SEGMENT
??_R3HardwareBufferManager@Ogre@@8 DD 00H		; Ogre::HardwareBufferManager::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2HardwareBufferManager@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVHardwareBufferManager@Ogre@@@8
_DATA	SEGMENT
??_R0?AVHardwareBufferManager@Ogre@@@8 DD FLAT:??_7type_info@@6B@ ; Ogre::HardwareBufferManager `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVHardwareBufferManager@Ogre@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@HardwareBufferManager@Ogre@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@HardwareBufferManager@Ogre@@8 DD FLAT:??_R0?AVHardwareBufferManager@Ogre@@@8 ; Ogre::HardwareBufferManager::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3HardwareBufferManager@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@D3D9HardwareBufferManager@Ogre@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@D3D9HardwareBufferManager@Ogre@@8 DD FLAT:??_R0?AVD3D9HardwareBufferManager@Ogre@@@8 ; Ogre::D3D9HardwareBufferManager::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3D3D9HardwareBufferManager@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R2D3D9HardwareBufferManager@Ogre@@8
rdata$r	SEGMENT
??_R2D3D9HardwareBufferManager@Ogre@@8 DD FLAT:??_R1A@?0A@EA@D3D9HardwareBufferManager@Ogre@@8 ; Ogre::D3D9HardwareBufferManager::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@HardwareBufferManager@Ogre@@8
	DD	FLAT:??_R13?0A@EA@?$Singleton@VHardwareBufferManager@Ogre@@@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R3D3D9HardwareBufferManager@Ogre@@8
rdata$r	SEGMENT
??_R3D3D9HardwareBufferManager@Ogre@@8 DD 00H		; Ogre::D3D9HardwareBufferManager::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2D3D9HardwareBufferManager@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVD3D9HardwareBufferManager@Ogre@@@8
_DATA	SEGMENT
??_R0?AVD3D9HardwareBufferManager@Ogre@@@8 DD FLAT:??_7type_info@@6B@ ; Ogre::D3D9HardwareBufferManager `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVD3D9HardwareBufferManager@Ogre@@', 00H
_DATA	ENDS
;	COMDAT ??_R4D3D9HardwareBufferManager@Ogre@@6B@
rdata$r	SEGMENT
??_R4D3D9HardwareBufferManager@Ogre@@6B@ DD 00H		; Ogre::D3D9HardwareBufferManager::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVD3D9HardwareBufferManager@Ogre@@@8
	DD	FLAT:??_R3D3D9HardwareBufferManager@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_7D3D9HardwareBufferManager@Ogre@@6B@
CONST	SEGMENT
??_7D3D9HardwareBufferManager@Ogre@@6B@ DD FLAT:??_R4D3D9HardwareBufferManager@Ogre@@6B@ ; Ogre::D3D9HardwareBufferManager::`vftable'
	DD	FLAT:??_ED3D9HardwareBufferManager@Ogre@@UAEPAXI@Z
	DD	FLAT:?newPool@D3D9HardwareBufferManager@Ogre@@UAEPAVHardwareBufferPool@2@_NW4HardwareBufferUsage@2@II@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0D3D9HardwareBufferManager@Ogre@@QAE@PAVD3D9RenderSystem@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0D3D9HardwareBufferManager@Ogre@@QAE@PAVD3D9RenderSystem@1@@Z$0
__ehfuncinfo$??0D3D9HardwareBufferManager@Ogre@@QAE@PAVD3D9RenderSystem@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0D3D9HardwareBufferManager@Ogre@@QAE@PAVD3D9RenderSystem@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0D3D9HardwareBufferManager@Ogre@@QAE@PAVD3D9RenderSystem@1@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_prs$ = 8						; size = 4
??0D3D9HardwareBufferManager@Ogre@@QAE@PAVD3D9RenderSystem@1@@Z PROC ; Ogre::D3D9HardwareBufferManager::D3D9HardwareBufferManager, COMDAT
; _this$ = ecx

; 73   : 		{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0D3D9HardwareBufferManager@Ogre@@QAE@PAVD3D9RenderSystem@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0HardwareBufferManager@Ogre@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7D3D9HardwareBufferManager@Ogre@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _prs$[ebp]
	mov	DWORD PTR [ecx+36], edx

; 74   : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0D3D9HardwareBufferManager@Ogre@@QAE@PAVD3D9RenderSystem@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1HardwareBufferManager@Ogre@@UAE@XZ
__ehhandler$??0D3D9HardwareBufferManager@Ogre@@QAE@PAVD3D9RenderSystem@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0D3D9HardwareBufferManager@Ogre@@QAE@PAVD3D9RenderSystem@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0D3D9HardwareBufferManager@Ogre@@QAE@PAVD3D9RenderSystem@1@@Z ENDP ; Ogre::D3D9HardwareBufferManager::D3D9HardwareBufferManager
PUBLIC	??1D3D9HardwareBufferManager@Ogre@@UAE@XZ	; Ogre::D3D9HardwareBufferManager::~D3D9HardwareBufferManager
; Function compile flags: /Odtp
;	COMDAT ??_GD3D9HardwareBufferManager@Ogre@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GD3D9HardwareBufferManager@Ogre@@UAEPAXI@Z PROC	; Ogre::D3D9HardwareBufferManager::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1D3D9HardwareBufferManager@Ogre@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@2
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@2:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GD3D9HardwareBufferManager@Ogre@@UAEPAXI@Z ENDP	; Ogre::D3D9HardwareBufferManager::`scalar deleting destructor'
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1D3D9HardwareBufferManager@Ogre@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1D3D9HardwareBufferManager@Ogre@@UAE@XZ$0
__ehfuncinfo$??1D3D9HardwareBufferManager@Ogre@@UAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1D3D9HardwareBufferManager@Ogre@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1D3D9HardwareBufferManager@Ogre@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1D3D9HardwareBufferManager@Ogre@@UAE@XZ PROC		; Ogre::D3D9HardwareBufferManager::~D3D9HardwareBufferManager, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1D3D9HardwareBufferManager@Ogre@@UAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1HardwareBufferManager@Ogre@@UAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1D3D9HardwareBufferManager@Ogre@@UAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1HardwareBufferManager@Ogre@@UAE@XZ
__ehhandler$??1D3D9HardwareBufferManager@Ogre@@UAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1D3D9HardwareBufferManager@Ogre@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1D3D9HardwareBufferManager@Ogre@@UAE@XZ ENDP		; Ogre::D3D9HardwareBufferManager::~D3D9HardwareBufferManager
; Function compile flags: /Odtp
; File i:\svnroot\client\plugins\rendersystem_d3d9\ogred3d9rendersystem.cpp
_TEXT	SEGMENT
_dwBehavior$ = -4					; size = 4
_pCaps$ = 8						; size = 4
_vptype$ = 12						; size = 4
_adapterFormat$ = 16					; size = 4
_backBufferFormat$ = 20					; size = 4
?ConfirmDeviceHelper@Ogre@@YAHPAU_D3DCAPS9@@W4VERTPROCESS_T@1@W4_D3DFORMAT@@2@Z PROC ; Ogre::ConfirmDeviceHelper

; 54   : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 55   : 		DWORD dwBehavior = GetBehaviorFlags( vptype );

	mov	eax, DWORD PTR _vptype$[ebp]
	push	eax
	call	?GetBehaviorFlags@Ogre@@YAKW4VERTPROCESS_T@1@@Z ; Ogre::GetBehaviorFlags
	add	esp, 4
	mov	DWORD PTR _dwBehavior$[ebp], eax

; 56   : 
; 57   : 		if( ((pCaps->VertexShaderVersion>=MIN_D3DVS_VERSION)&&(pCaps->DevCaps&D3DDEVCAPS_HWTRANSFORMANDLIGHT)) || (dwBehavior&D3DCREATE_SOFTWARE_VERTEXPROCESSING) )

	mov	ecx, DWORD PTR _pCaps$[ebp]
	cmp	DWORD PTR [ecx+196], -130560		; fffe0200H
	jb	SHORT $LN1@ConfirmDev
	mov	edx, DWORD PTR _pCaps$[ebp]
	mov	eax, DWORD PTR [edx+28]
	and	eax, 65536				; 00010000H
	jne	SHORT $LN2@ConfirmDev
$LN1@ConfirmDev:
	mov	ecx, DWORD PTR _dwBehavior$[ebp]
	and	ecx, 32					; 00000020H
	je	SHORT $LN3@ConfirmDev
$LN2@ConfirmDev:

; 58   : 		{
; 59   : 			return TRUE;

	mov	eax, 1
	jmp	SHORT $LN4@ConfirmDev
$LN3@ConfirmDev:

; 60   : 		}
; 61   : 
; 62   : 		return FALSE;

	xor	eax, eax
$LN4@ConfirmDev:

; 63   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?ConfirmDeviceHelper@Ogre@@YAHPAU_D3DCAPS9@@W4VERTPROCESS_T@1@W4_D3DFORMAT@@2@Z ENDP ; Ogre::ConfirmDeviceHelper
_TEXT	ENDS
PUBLIC	??A?$vector@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@QAEAAPAVD3DRenderWindow@Ogre@@I@Z ; std::vector<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >::operator[]
PUBLIC	?size@?$vector@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >::size
PUBLIC	?findRenderWindowByHWnd@D3D9RenderSystem@Ogre@@QAEPAVD3DRenderWindow@2@PAUHWND__@@@Z ; Ogre::D3D9RenderSystem::findRenderWindowByHWnd
; Function compile flags: /Odtp
_TEXT	SEGMENT
tv79 = -12						; size = 4
_this$ = -8						; size = 4
_i$151669 = -4						; size = 4
_hwnd$ = 8						; size = 4
?findRenderWindowByHWnd@D3D9RenderSystem@Ogre@@QAEPAVD3DRenderWindow@2@PAUHWND__@@@Z PROC ; Ogre::D3D9RenderSystem::findRenderWindowByHWnd
; _this$ = ecx

; 313  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 314  : 		for(size_t i=0; i<m_WindowTargets.size(); i++)

	mov	DWORD PTR _i$151669[ebp], 0
	jmp	SHORT $LN4@findRender
$LN3@findRender:
	mov	eax, DWORD PTR _i$151669[ebp]
	add	eax, 1
	mov	DWORD PTR _i$151669[ebp], eax
$LN4@findRender:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 464				; 000001d0H
	call	?size@?$vector@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >::size
	cmp	DWORD PTR _i$151669[ebp], eax
	jae	SHORT $LN2@findRender

; 315  : 		{
; 316  : 			if(m_WindowTargets[i]->getHWnd() == hwnd) return m_WindowTargets[i];

	mov	ecx, DWORD PTR _i$151669[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 464				; 000001d0H
	call	??A?$vector@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@QAEAAPAVD3DRenderWindow@Ogre@@I@Z ; std::vector<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >::operator[]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR tv79[ebp], edx
	mov	eax, DWORD PTR tv79[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR tv79[ebp]
	mov	eax, DWORD PTR [edx+56]
	call	eax
	cmp	eax, DWORD PTR _hwnd$[ebp]
	jne	SHORT $LN1@findRender
	mov	ecx, DWORD PTR _i$151669[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 464				; 000001d0H
	call	??A?$vector@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@QAEAAPAVD3DRenderWindow@Ogre@@I@Z ; std::vector<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >::operator[]
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN5@findRender
$LN1@findRender:

; 317  : 		}

	jmp	SHORT $LN3@findRender
$LN2@findRender:

; 318  : 		return NULL;

	xor	eax, eax
$LN5@findRender:

; 319  : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
?findRenderWindowByHWnd@D3D9RenderSystem@Ogre@@QAEPAVD3DRenderWindow@2@PAUHWND__@@@Z ENDP ; Ogre::D3D9RenderSystem::findRenderWindowByHWnd
_TEXT	ENDS
PUBLIC	?erase@?$vector@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@2@@Z ; std::vector<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >::erase
PUBLIC	??D?$_Vector_iterator@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@QBEAAPAVD3DRenderWindow@Ogre@@XZ ; std::_Vector_iterator<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >::operator*
PUBLIC	??9?$_Vector_const_iterator@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >::operator!=
PUBLIC	?end@?$vector@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@2@XZ ; std::vector<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >::end
PUBLIC	??E?$_Vector_iterator@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@QAE?AV01@H@Z ; std::_Vector_iterator<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >::operator++
PUBLIC	?begin@?$vector@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@2@XZ ; std::vector<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >::begin
PUBLIC	?removeD3DRenderWindow@D3D9RenderSystem@Ogre@@QAEXPAVD3DRenderWindow@2@@Z ; Ogre::D3D9RenderSystem::removeD3DRenderWindow
; Function compile flags: /Odtp
_TEXT	SEGMENT
_this$ = -44						; size = 4
$T159718 = -40						; size = 8
$T159717 = -32						; size = 8
$T159716 = -24						; size = 8
$T159715 = -16						; size = 8
_iter$ = -8						; size = 8
_pwnd$ = 8						; size = 4
?removeD3DRenderWindow@D3D9RenderSystem@Ogre@@QAEXPAVD3DRenderWindow@2@@Z PROC ; Ogre::D3D9RenderSystem::removeD3DRenderWindow
; _this$ = ecx

; 322  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	mov	DWORD PTR _this$[ebp], ecx

; 323  : 		std::vector<D3DRenderWindow *>::iterator iter = m_WindowTargets.begin();

	lea	eax, DWORD PTR _iter$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 464				; 000001d0H
	call	?begin@?$vector@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@2@XZ ; std::vector<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >::begin
	jmp	SHORT $LN4@removeD3DR
$LN3@removeD3DR:

; 324  : 		for(; iter!=m_WindowTargets.end(); iter++)

	push	0
	lea	ecx, DWORD PTR $T159715[ebp]
	push	ecx
	lea	ecx, DWORD PTR _iter$[ebp]
	call	??E?$_Vector_iterator@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@QAE?AV01@H@Z ; std::_Vector_iterator<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >::operator++
$LN4@removeD3DR:
	lea	edx, DWORD PTR $T159716[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 464				; 000001d0H
	call	?end@?$vector@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@2@XZ ; std::vector<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >::end
	push	eax
	lea	ecx, DWORD PTR _iter$[ebp]
	call	??9?$_Vector_const_iterator@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >::operator!=
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN5@removeD3DR

; 325  : 		{
; 326  : 			if(*iter == pwnd)

	lea	ecx, DWORD PTR _iter$[ebp]
	call	??D?$_Vector_iterator@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@QBEAAPAVD3DRenderWindow@Ogre@@XZ ; std::_Vector_iterator<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >::operator*
	mov	ecx, DWORD PTR [eax]
	cmp	ecx, DWORD PTR _pwnd$[ebp]
	jne	SHORT $LN1@removeD3DR

; 327  : 			{
; 328  : 				m_WindowTargets.erase(iter);

	mov	edx, DWORD PTR _iter$[ebp]
	mov	DWORD PTR $T159717[ebp], edx
	mov	eax, DWORD PTR _iter$[ebp+4]
	mov	DWORD PTR $T159717[ebp+4], eax
	mov	ecx, DWORD PTR $T159717[ebp+4]
	push	ecx
	mov	edx, DWORD PTR $T159717[ebp]
	push	edx
	lea	eax, DWORD PTR $T159718[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 464				; 000001d0H
	call	?erase@?$vector@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@2@@Z ; std::vector<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >::erase

; 329  : 				return;

	jmp	SHORT $LN5@removeD3DR
$LN1@removeD3DR:

; 330  : 			}
; 331  : 		}

	jmp	SHORT $LN3@removeD3DR
$LN5@removeD3DR:

; 332  : 		assert(0);
; 333  : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
?removeD3DRenderWindow@D3D9RenderSystem@Ogre@@QAEXPAVD3DRenderWindow@2@@Z ENDP ; Ogre::D3D9RenderSystem::removeD3DRenderWindow
_TEXT	ENDS
PUBLIC	?strstr@@YAPADPADPBD@Z				; strstr
PUBLIC	__$ArrayPad$
PUBLIC	?createD3DDevice@D3D9RenderSystem@Ogre@@QAE_NPAUHWND__@@ABUD3DSETTING_T@2@AAU_D3DPRESENT_PARAMETERS_@@@Z ; Ogre::D3D9RenderSystem::createD3DDevice
; Function compile flags: /Odtp
_TEXT	SEGMENT
_this$ = -1140						; size = 4
_Identifier$151867 = -1136				; size = 1100
__$ArrayPad$ = -32					; size = 4
_Res$151868 = -28					; size = 4
_Adapter$151863 = -24					; size = 4
_AdapterToUse$ = -20					; size = 4
_hr$ = -16						; size = 4
_behaviorflags$ = -12					; size = 4
_pdevice$ = -8						; size = 4
_DeviceType$ = -4					; size = 4
_hwnd$ = 8						; size = 4
_setting$ = 12						; size = 4
_d3dpp$ = 16						; size = 4
?createD3DDevice@D3D9RenderSystem@Ogre@@QAE_NPAUHWND__@@ABUD3DSETTING_T@2@AAU_D3DPRESENT_PARAMETERS_@@@Z PROC ; Ogre::D3D9RenderSystem::createD3DDevice
; _this$ = ecx

; 345  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 1140				; 00000474H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 346  : 		DWORD behaviorflags = GetBehaviorFlags( setting.vptype );

	mov	eax, DWORD PTR _setting$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	push	ecx
	call	?GetBehaviorFlags@Ogre@@YAKW4VERTPROCESS_T@1@@Z ; Ogre::GetBehaviorFlags
	add	esp, 4
	mov	DWORD PTR _behaviorflags$[ebp], eax

; 347  : 
; 348  : 		if(m_bDebugVS && setting.pdevcombo->devtype!=D3DDEVTYPE_REF)

	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+516]
	test	eax, eax
	je	SHORT $LN5@createD3DD
	mov	ecx, DWORD PTR _setting$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	cmp	DWORD PTR [edx+4], 2
	je	SHORT $LN5@createD3DD

; 349  : 		{
; 350  : 			behaviorflags &= ~D3DCREATE_HARDWARE_VERTEXPROCESSING;

	mov	eax, DWORD PTR _behaviorflags$[ebp]
	and	eax, -65				; ffffffbfH
	mov	DWORD PTR _behaviorflags$[ebp], eax

; 351  : 			behaviorflags &= ~D3DCREATE_PUREDEVICE;

	mov	ecx, DWORD PTR _behaviorflags$[ebp]
	and	ecx, -17				; ffffffefH
	mov	DWORD PTR _behaviorflags$[ebp], ecx

; 352  : 			behaviorflags |= D3DCREATE_SOFTWARE_VERTEXPROCESSING;

	mov	edx, DWORD PTR _behaviorflags$[ebp]
	or	edx, 32					; 00000020H
	mov	DWORD PTR _behaviorflags$[ebp], edx
$LN5@createD3DD:

; 353  : 		}
; 354  : 
; 355  : 		// Create the device
; 356  : 		IDirect3DDevice9 *pdevice = NULL;

	mov	DWORD PTR _pdevice$[ebp], 0

; 357  : 		HRESULT hr;
; 358  : 		/*
; 359  : 		if(m_bDebug_nv)
; 360  : 		{
; 361  : 		UINT AdapterToUse=D3DADAPTER_DEFAULT;
; 362  : 		D3DDEVTYPE DeviceType=D3DDEVTYPE_HAL;
; 363  : 		UINT nadapter = m_pD3D->GetAdapterCount();
; 364  : 
; 365  : 		// Look for 'NVIDIA PerfHUD' adapter
; 366  : 		// If it is present, override default settings
; 367  : 		for(UINT Adapter=0; Adapter<nadapter; Adapter++)
; 368  : 		{
; 369  : 		D3DADAPTER_IDENTIFIER9 Identifier;
; 370  : 		HRESULT Res;
; 371  : 		Res = m_pD3D->GetAdapterIdentifier(Adapter,0,&Identifier);
; 372  : 		if(strstr(Identifier.Description,"PerfHUD") != 0)
; 373  : 		{
; 374  : 		AdapterToUse=Adapter;
; 375  : 		DeviceType=D3DDEVTYPE_REF;
; 376  : 		break;
; 377  : 		}
; 378  : 		}
; 379  : 
; 380  : 		hr = m_pD3D->CreateDevice(AdapterToUse, DeviceType,	hwnd, behaviorflags, &d3dpp, &pdevice );
; 381  : 		}
; 382  : 		else
; 383  : 		{
; 384  : 		hr = m_pD3D->CreateDevice( setting.pdevcombo->iadapter, setting.pdevcombo->devtype, hwnd, behaviorflags, &d3dpp, &pdevice );
; 385  : 		}
; 386  : 		*/
; 387  : 		UINT AdapterToUse=D3DADAPTER_DEFAULT;

	mov	DWORD PTR _AdapterToUse$[ebp], 0

; 388  : 		D3DDEVTYPE DeviceType=D3DDEVTYPE_HAL;

	mov	DWORD PTR _DeviceType$[ebp], 1

; 389  : 		for (UINT Adapter=0;Adapter<m_pD3D->GetAdapterCount();Adapter++)

	mov	DWORD PTR _Adapter$151863[ebp], 0
	jmp	SHORT $LN4@createD3DD
$LN3@createD3DD:
	mov	eax, DWORD PTR _Adapter$151863[ebp]
	add	eax, 1
	mov	DWORD PTR _Adapter$151863[ebp], eax
$LN4@createD3DD:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+100]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+100]
	mov	edx, DWORD PTR [edx]
	push	ecx
	mov	eax, DWORD PTR [edx+16]
	call	eax
	cmp	DWORD PTR _Adapter$151863[ebp], eax
	jae	SHORT $LN2@createD3DD

; 390  : 		{
; 391  : 			D3DADAPTER_IDENTIFIER9 Identifier;
; 392  : 			HRESULT Res;
; 393  : 			Res = m_pD3D->GetAdapterIdentifier(Adapter,0,&Identifier);

	lea	ecx, DWORD PTR _Identifier$151867[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _Adapter$151863[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+100]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+100]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	mov	edx, DWORD PTR [ecx+20]
	call	edx
	mov	DWORD PTR _Res$151868[ebp], eax

; 394  : 			if (strstr(Identifier.Description,"PerfHUD") != 0)

	push	OFFSET $SG151870
	lea	eax, DWORD PTR _Identifier$151867[ebp+512]
	push	eax
	call	?strstr@@YAPADPADPBD@Z			; strstr
	add	esp, 8
	test	eax, eax
	je	SHORT $LN1@createD3DD

; 395  : 			{
; 396  : 				AdapterToUse=Adapter;

	mov	ecx, DWORD PTR _Adapter$151863[ebp]
	mov	DWORD PTR _AdapterToUse$[ebp], ecx

; 397  : 				DeviceType=D3DDEVTYPE_REF;

	mov	DWORD PTR _DeviceType$[ebp], 2

; 398  : 				break;

	jmp	SHORT $LN2@createD3DD
$LN1@createD3DD:

; 399  : 			}
; 400  : 		}

	jmp	SHORT $LN3@createD3DD
$LN2@createD3DD:

; 401  : 
; 402  : 		behaviorflags |= D3DCREATE_MULTITHREADED;

	mov	edx, DWORD PTR _behaviorflags$[ebp]
	or	edx, 4
	mov	DWORD PTR _behaviorflags$[ebp], edx

; 403  : 		hr = m_pD3D->CreateDevice( AdapterToUse, DeviceType, hwnd,
; 404  : 			behaviorflags,&d3dpp, &pdevice);

	lea	eax, DWORD PTR _pdevice$[ebp]
	push	eax
	mov	ecx, DWORD PTR _d3dpp$[ebp]
	push	ecx
	mov	edx, DWORD PTR _behaviorflags$[ebp]
	push	edx
	mov	eax, DWORD PTR _hwnd$[ebp]
	push	eax
	mov	ecx, DWORD PTR _DeviceType$[ebp]
	push	ecx
	mov	edx, DWORD PTR _AdapterToUse$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+100]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+100]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	mov	edx, DWORD PTR [ecx+64]
	call	edx
	mov	DWORD PTR _hr$[ebp], eax

; 405  : 
; 406  : 		m_dwCreateFlags = behaviorflags;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _behaviorflags$[ebp]
	mov	DWORD PTR [eax+412], ecx

; 407  : 		m_pd3dDevice = pdevice;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _pdevice$[ebp]
	mov	DWORD PTR [edx+104], eax

; 408  : 		return SUCCEEDED(hr);

	xor	eax, eax
	cmp	DWORD PTR _hr$[ebp], 0
	setge	al

; 409  : 	}

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?createD3DDevice@D3D9RenderSystem@Ogre@@QAE_NPAUHWND__@@ABUD3DSETTING_T@2@AAU_D3DPRESENT_PARAMETERS_@@@Z ENDP ; Ogre::D3D9RenderSystem::createD3DDevice
_TEXT	ENDS
EXTRN	__imp__strstr:PROC
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\string.h
;	COMDAT ?strstr@@YAPADPADPBD@Z
_TEXT	SEGMENT
__Str$ = 8						; size = 4
__SubStr$ = 12						; size = 4
?strstr@@YAPADPADPBD@Z PROC				; strstr, COMDAT

; 190  : 	{ return (char*)strstr((const char*)_Str, _SubStr); }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR __SubStr$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Str$[ebp]
	push	ecx
	call	DWORD PTR __imp__strstr
	add	esp, 8
	pop	ebp
	ret	0
?strstr@@YAPADPADPBD@Z ENDP				; strstr
_TEXT	ENDS
PUBLIC	?destroyD3DDevice@D3D9RenderSystem@Ogre@@QAEXXZ	; Ogre::D3D9RenderSystem::destroyD3DDevice
; Function compile flags: /Odtp
; File i:\svnroot\client\plugins\rendersystem_d3d9\ogred3d9rendersystem.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?destroyD3DDevice@D3D9RenderSystem@Ogre@@QAEXXZ PROC	; Ogre::D3D9RenderSystem::destroyD3DDevice
; _this$ = ecx

; 412  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 413  : 		SAFE_RELEASE(m_pCursorSurface);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+556], 0
	je	SHORT $LN2@destroyD3D
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+556]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+556]
	mov	edx, DWORD PTR [edx]
	push	ecx
	mov	eax, DWORD PTR [edx+8]
	call	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+556], 0
$LN2@destroyD3D:

; 414  : 		SAFE_RELEASE(m_pd3dDevice);

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+104], 0
	je	SHORT $LN3@destroyD3D
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+104]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+104]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	mov	edx, DWORD PTR [ecx+8]
	call	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+104], 0
$LN3@destroyD3D:

; 415  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?destroyD3DDevice@D3D9RenderSystem@Ogre@@QAEXXZ ENDP	; Ogre::D3D9RenderSystem::destroyD3DDevice
_TEXT	ENDS
PUBLIC	??$DeletePointerArray@VD3D9VertexDecl@Ogre@@@Ogre@@YAXAAV?$vector@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@@Z ; Ogre::DeletePointerArray<Ogre::D3D9VertexDecl>
EXTRN	?saveShaderEnvKeys@D3D9MaterialManager@Ogre@@QAEXXZ:PROC ; Ogre::D3D9MaterialManager::saveShaderEnvKeys
EXTRN	__imp_?isSaveShaderEnvKeys@Root@Ogre@@QAE_NXZ:PROC
EXTRN	__imp_?getSingleton@?$Singleton@VRoot@Ogre@@@Ogre@@SAAAVRoot@2@XZ:PROC
EXTRN	?saveCompiledShaders@D3D9MaterialManager@Ogre@@QAEXXZ:PROC ; Ogre::D3D9MaterialManager::saveCompiledShaders
; Function compile flags: /Odtp
_TEXT	SEGMENT
tv184 = -60						; size = 4
tv163 = -56						; size = 4
tv151 = -52						; size = 4
tv139 = -48						; size = 4
_this$ = -44						; size = 4
$T159738 = -40						; size = 4
$T159737 = -36						; size = 4
$T159734 = -32						; size = 4
$T159733 = -28						; size = 4
$T159730 = -24						; size = 4
$T159729 = -20						; size = 4
$T159726 = -16						; size = 4
$T159725 = -12						; size = 4
_i$151898 = -8						; size = 4
_saveShaderEnvKeys$151890 = -1				; size = 1
?shutdown@D3D9RenderSystem@Ogre@@UAEXXZ PROC		; Ogre::D3D9RenderSystem::shutdown
; _this$ = ecx

; 418  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 60					; 0000003cH
	mov	DWORD PTR _this$[ebp], ecx

; 419  : 		SAFE_RELEASE(m_pCursorSurface);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+556], 0
	je	SHORT $LN7@shutdown
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+556]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+556]
	mov	edx, DWORD PTR [edx]
	push	ecx
	mov	eax, DWORD PTR [edx+8]
	call	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+556], 0
$LN7@shutdown:

; 420  : 
; 421  : 		DeletePointerArray(m_VertexDecls);

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 520				; 00000208H
	push	edx
	call	??$DeletePointerArray@VD3D9VertexDecl@Ogre@@@Ogre@@YAXAAV?$vector@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@@Z ; Ogre::DeletePointerArray<Ogre::D3D9VertexDecl>
	add	esp, 4

; 422  : 		if (m_bSaveCompiledShader)

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+60]
	test	ecx, ecx
	je	SHORT $LN6@shutdown

; 423  : 		{
; 424  : 			m_pMtlMgr->saveCompiledShaders();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+548]
	call	?saveCompiledShaders@D3D9MaterialManager@Ogre@@QAEXXZ ; Ogre::D3D9MaterialManager::saveCompiledShaders

; 425  : 
; 426  : 			bool saveShaderEnvKeys = Root::getSingleton().isSaveShaderEnvKeys();

	call	DWORD PTR __imp_?getSingleton@?$Singleton@VRoot@Ogre@@@Ogre@@SAAAVRoot@2@XZ
	mov	ecx, eax
	call	DWORD PTR __imp_?isSaveShaderEnvKeys@Root@Ogre@@QAE_NXZ
	mov	BYTE PTR _saveShaderEnvKeys$151890[ebp], al

; 427  : 			if (saveShaderEnvKeys)

	movzx	eax, BYTE PTR _saveShaderEnvKeys$151890[ebp]
	test	eax, eax
	je	SHORT $LN6@shutdown

; 428  : 				m_pMtlMgr->saveShaderEnvKeys();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+548]
	call	?saveShaderEnvKeys@D3D9MaterialManager@Ogre@@QAEXXZ ; Ogre::D3D9MaterialManager::saveShaderEnvKeys
$LN6@shutdown:

; 429  : 		}
; 430  : 
; 431  : 		delete m_pMtlMgr;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+548]
	mov	DWORD PTR $T159726[ebp], eax
	mov	ecx, DWORD PTR $T159726[ebp]
	mov	DWORD PTR $T159725[ebp], ecx
	cmp	DWORD PTR $T159725[ebp], 0
	je	SHORT $LN10@shutdown
	push	1
	mov	edx, DWORD PTR $T159725[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR $T159725[ebp]
	mov	edx, DWORD PTR [eax]
	call	edx
	mov	DWORD PTR tv139[ebp], eax
	jmp	SHORT $LN11@shutdown
$LN10@shutdown:
	mov	DWORD PTR tv139[ebp], 0
$LN11@shutdown:

; 432  : 		delete m_pBufMgr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+552]
	mov	DWORD PTR $T159730[ebp], ecx
	mov	edx, DWORD PTR $T159730[ebp]
	mov	DWORD PTR $T159729[ebp], edx
	cmp	DWORD PTR $T159729[ebp], 0
	je	SHORT $LN12@shutdown
	push	1
	mov	eax, DWORD PTR $T159729[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR $T159729[ebp]
	mov	eax, DWORD PTR [edx]
	call	eax
	mov	DWORD PTR tv151[ebp], eax
	jmp	SHORT $LN13@shutdown
$LN12@shutdown:
	mov	DWORD PTR tv151[ebp], 0
$LN13@shutdown:

; 433  : 		delete m_pPBufMgr;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+544]
	mov	DWORD PTR $T159734[ebp], edx
	mov	eax, DWORD PTR $T159734[ebp]
	mov	DWORD PTR $T159733[ebp], eax
	cmp	DWORD PTR $T159733[ebp], 0
	je	SHORT $LN14@shutdown
	push	1
	mov	ecx, DWORD PTR $T159733[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR $T159733[ebp]
	mov	eax, DWORD PTR [edx]
	call	eax
	mov	DWORD PTR tv163[ebp], eax
	jmp	SHORT $LN15@shutdown
$LN14@shutdown:
	mov	DWORD PTR tv163[ebp], 0
$LN15@shutdown:

; 434  : 
; 435  : 		for(int i=int(m_WindowTargets.size())-1; i>=0; i--)

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 464				; 000001d0H
	call	?size@?$vector@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >::size
	sub	eax, 1
	mov	DWORD PTR _i$151898[ebp], eax
	jmp	SHORT $LN4@shutdown
$LN3@shutdown:
	mov	ecx, DWORD PTR _i$151898[ebp]
	sub	ecx, 1
	mov	DWORD PTR _i$151898[ebp], ecx
$LN4@shutdown:
	cmp	DWORD PTR _i$151898[ebp], 0
	jl	SHORT $LN2@shutdown

; 436  : 		{
; 437  : 			delete m_WindowTargets[i];

	mov	edx, DWORD PTR _i$151898[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 464				; 000001d0H
	call	??A?$vector@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@QAEAAPAVD3DRenderWindow@Ogre@@I@Z ; std::vector<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >::operator[]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR $T159738[ebp], eax
	mov	ecx, DWORD PTR $T159738[ebp]
	mov	DWORD PTR $T159737[ebp], ecx
	cmp	DWORD PTR $T159737[ebp], 0
	je	SHORT $LN16@shutdown
	push	1
	mov	edx, DWORD PTR $T159737[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR $T159737[ebp]
	mov	edx, DWORD PTR [eax+20]
	call	edx
	mov	DWORD PTR tv184[ebp], eax
	jmp	SHORT $LN17@shutdown
$LN16@shutdown:
	mov	DWORD PTR tv184[ebp], 0
$LN17@shutdown:

; 438  : 		}

	jmp	SHORT $LN3@shutdown
$LN2@shutdown:

; 439  : 
; 440  : 		SAFE_RELEASE(m_pD3D);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+100], 0
	je	SHORT $LN8@shutdown
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+100]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+100]
	mov	edx, DWORD PTR [edx]
	push	ecx
	mov	eax, DWORD PTR [edx+8]
	call	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+100], 0
$LN8@shutdown:

; 441  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?shutdown@D3D9RenderSystem@Ogre@@UAEXXZ ENDP		; Ogre::D3D9RenderSystem::shutdown
_TEXT	ENDS
xdata$x	SEGMENT
__unwindtable$?createRenderWindow@D3D9RenderSystem@Ogre@@UAEPAVRenderWindow@2@ABUInitDesc@RenderSystem@2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?createRenderWindow@D3D9RenderSystem@Ogre@@UAEPAVRenderWindow@2@ABUInitDesc@RenderSystem@2@@Z$0
__ehfuncinfo$?createRenderWindow@D3D9RenderSystem@Ogre@@UAEPAVRenderWindow@2@ABUInitDesc@RenderSystem@2@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?createRenderWindow@D3D9RenderSystem@Ogre@@UAEPAVRenderWindow@2@ABUInitDesc@RenderSystem@2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
_TEXT	SEGMENT
tv89 = -44						; size = 4
tv75 = -40						; size = 4
_this$ = -36						; size = 4
$T159747 = -32						; size = 4
$T159746 = -28						; size = 4
$T159743 = -24						; size = 4
$T159742 = -20						; size = 4
_ptarget$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_desc$ = 8						; size = 4
?createRenderWindow@D3D9RenderSystem@Ogre@@UAEPAVRenderWindow@2@ABUInitDesc@RenderSystem@2@@Z PROC ; Ogre::D3D9RenderSystem::createRenderWindow
; _this$ = ecx

; 444  : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?createRenderWindow@D3D9RenderSystem@Ogre@@UAEPAVRenderWindow@2@ABUInitDesc@RenderSystem@2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 32					; 00000020H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 445  : 		D3DRenderWindow *ptarget = new D3DRenderWindow(this, desc, false);

	push	128					; 00000080H
	call	DWORD PTR __imp_??2MemoryDelegation@Ogre@@SAPAXI@Z
	add	esp, 4
	mov	DWORD PTR $T159743[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T159743[ebp], 0
	je	SHORT $LN5@createRend
	push	0
	mov	eax, DWORD PTR _desc$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	ecx, DWORD PTR $T159743[ebp]
	call	??0D3DRenderWindow@Ogre@@QAE@PAVD3D9RenderSystem@1@ABUInitDesc@RenderSystem@1@_N@Z ; Ogre::D3DRenderWindow::D3DRenderWindow
	mov	DWORD PTR tv75[ebp], eax
	jmp	SHORT $LN6@createRend
$LN5@createRend:
	mov	DWORD PTR tv75[ebp], 0
$LN6@createRend:
	mov	edx, DWORD PTR tv75[ebp]
	mov	DWORD PTR $T159742[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR $T159742[ebp]
	mov	DWORD PTR _ptarget$[ebp], eax

; 446  : 		if(!ptarget->onInitialise())

	mov	ecx, DWORD PTR _ptarget$[ebp]
	call	?onInitialise@D3DRenderWindow@Ogre@@QAE_NXZ ; Ogre::D3DRenderWindow::onInitialise
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN2@createRend

; 447  : 		{
; 448  : 			delete ptarget;

	mov	edx, DWORD PTR _ptarget$[ebp]
	mov	DWORD PTR $T159747[ebp], edx
	mov	eax, DWORD PTR $T159747[ebp]
	mov	DWORD PTR $T159746[ebp], eax
	cmp	DWORD PTR $T159746[ebp], 0
	je	SHORT $LN7@createRend
	push	1
	mov	ecx, DWORD PTR $T159746[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR $T159746[ebp]
	mov	eax, DWORD PTR [edx+20]
	call	eax
	mov	DWORD PTR tv89[ebp], eax
	jmp	SHORT $LN8@createRend
$LN7@createRend:
	mov	DWORD PTR tv89[ebp], 0
$LN8@createRend:

; 449  : 			return NULL;

	xor	eax, eax
	jmp	SHORT $LN3@createRend

; 450  : 		}
; 451  : 		else

	jmp	SHORT $LN3@createRend
$LN2@createRend:

; 452  : 		{
; 453  : 			m_WindowTargets.push_back(ptarget);

	lea	ecx, DWORD PTR _ptarget$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 464				; 000001d0H
	call	?push_back@?$vector@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@QAEXABQAVD3DRenderWindow@Ogre@@@Z ; std::vector<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >::push_back

; 454  : 			return ptarget;

	mov	eax, DWORD PTR _ptarget$[ebp]
$LN3@createRend:

; 455  : 		}
; 456  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?createRenderWindow@D3D9RenderSystem@Ogre@@UAEPAVRenderWindow@2@ABUInitDesc@RenderSystem@2@@Z$0:
	push	128					; 00000080H
	mov	eax, DWORD PTR $T159743[ebp]
	push	eax
	call	DWORD PTR __imp_??3MemoryDelegation@Ogre@@SAXPAXI@Z
	add	esp, 8
	ret	0
__ehhandler$?createRenderWindow@D3D9RenderSystem@Ogre@@UAEPAVRenderWindow@2@ABUInitDesc@RenderSystem@2@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-36]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?createRenderWindow@D3D9RenderSystem@Ogre@@UAEPAVRenderWindow@2@ABUInitDesc@RenderSystem@2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?createRenderWindow@D3D9RenderSystem@Ogre@@UAEPAVRenderWindow@2@ABUInitDesc@RenderSystem@2@@Z ENDP ; Ogre::D3D9RenderSystem::createRenderWindow
; Function compile flags: /Odtp
_TEXT	SEGMENT
_this$ = -8						; size = 4
_d3dflag$ = -4						; size = 4
_flags$ = 8						; size = 4
_color$ = 12						; size = 4
_z$ = 16						; size = 4
_stencil$ = 20						; size = 4
?clear@D3D9RenderSystem@Ogre@@UAEXIIMI@Z PROC		; Ogre::D3D9RenderSystem::clear
; _this$ = ecx

; 459  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 460  : 		DWORD d3dflag = 0;

	mov	DWORD PTR _d3dflag$[ebp], 0

; 461  : 		if( flags&CLEAR_STENCIL ) d3dflag |= D3DCLEAR_STENCIL;

	mov	eax, DWORD PTR _flags$[ebp]
	and	eax, 1
	je	SHORT $LN3@clear
	mov	ecx, DWORD PTR _d3dflag$[ebp]
	or	ecx, 4
	mov	DWORD PTR _d3dflag$[ebp], ecx
$LN3@clear:

; 462  : 		if( flags&CLEAR_TARGET ) d3dflag |= D3DCLEAR_TARGET;

	mov	edx, DWORD PTR _flags$[ebp]
	and	edx, 2
	je	SHORT $LN2@clear
	mov	eax, DWORD PTR _d3dflag$[ebp]
	or	eax, 1
	mov	DWORD PTR _d3dflag$[ebp], eax
$LN2@clear:

; 463  : 		if( flags&CLEAR_ZBUFFER ) d3dflag |= D3DCLEAR_ZBUFFER;

	mov	ecx, DWORD PTR _flags$[ebp]
	and	ecx, 4
	je	SHORT $LN1@clear
	mov	edx, DWORD PTR _d3dflag$[ebp]
	or	edx, 2
	mov	DWORD PTR _d3dflag$[ebp], edx
$LN1@clear:

; 464  : 
; 465  : 		m_pd3dDevice->Clear(0, NULL, d3dflag, color, z, stencil);

	mov	eax, DWORD PTR _stencil$[ebp]
	push	eax
	push	ecx
	fld	DWORD PTR _z$[ebp]
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _color$[ebp]
	push	ecx
	mov	edx, DWORD PTR _d3dflag$[ebp]
	push	edx
	push	0
	push	0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+104]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+104]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	mov	edx, DWORD PTR [ecx+172]
	call	edx

; 466  : 	}

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?clear@D3D9RenderSystem@Ogre@@UAEXIIMI@Z ENDP		; Ogre::D3D9RenderSystem::clear
_TEXT	ENDS
PUBLIC	__real@3ff0000000000000
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
; Function compile flags: /Odtp
CONST	ENDS
_TEXT	SEGMENT
tv306 = -260						; size = 8
tv304 = -252						; size = 4
tv301 = -246						; size = 2
tv297 = -244						; size = 8
tv295 = -236						; size = 4
tv292 = -230						; size = 2
tv288 = -228						; size = 8
tv286 = -220						; size = 4
tv283 = -214						; size = 2
tv279 = -212						; size = 8
tv277 = -204						; size = 4
tv274 = -198						; size = 2
tv270 = -196						; size = 8
tv268 = -188						; size = 4
tv265 = -182						; size = 2
tv260 = -180						; size = 8
tv257 = -172						; size = 8
tv255 = -164						; size = 4
tv252 = -158						; size = 2
tv247 = -156						; size = 8
tv244 = -148						; size = 8
tv242 = -140						; size = 4
tv239 = -134						; size = 2
tv234 = -132						; size = 8
tv231 = -124						; size = 8
tv229 = -116						; size = 4
tv226 = -110						; size = 2
tv221 = -108						; size = 8
_this$ = -100						; size = 4
_ptarget$151953 = -96					; size = 4
_desc$151959 = -92					; size = 32
_ptarget$151937 = -60					; size = 4
_desc$151943 = -56					; size = 32
_vp$ = -24						; size = 24
_viewport$ = 8						; size = 4
?setViewport@D3D9RenderSystem@Ogre@@UAEXABUViewport@2@@Z PROC ; Ogre::D3D9RenderSystem::setViewport
; _this$ = ecx

; 469  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 260				; 00000104H
	mov	DWORD PTR _this$[ebp], ecx

; 470  : 		D3DVIEWPORT9 vp;
; 471  : 
; 472  : 		if(viewport.width <= 1.0f)

	mov	eax, DWORD PTR _viewport$[ebp]
	fld	DWORD PTR [eax+8]
	fcomp	QWORD PTR __real@3ff0000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jp	$LN6@setViewpor

; 473  : 		{
; 474  : 			IDirect3DSurface9* ptarget = NULL;

	mov	DWORD PTR _ptarget$151937[ebp], 0

; 475  : 			if(FAILED(m_pd3dDevice->GetRenderTarget(0, &ptarget))) //!!!会不会有效率问题？

	lea	ecx, DWORD PTR _ptarget$151937[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+104]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+104]
	mov	eax, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR [eax+152]
	call	ecx
	test	eax, eax
	jge	SHORT $LN5@setViewpor

; 476  : 			{
; 477  : 				if ( ptarget != NULL )

	cmp	DWORD PTR _ptarget$151937[ebp], 0
	je	SHORT $LN4@setViewpor

; 478  : 				{
; 479  : 					LOG_PRIVATE( "D3D9RenderSystem::setViewport--GetRenderTarget--获取了RenderTarget，但是没释放--479" );

	push	64					; 00000040H
	push	479					; 000001dfH
	push	OFFSET $SG151941
	call	DWORD PTR __imp_?LogSetCurParam@Ogre@@YAXPBDHI@Z
	add	esp, 12					; 0000000cH
	push	OFFSET $SG151942
	call	DWORD PTR __imp_?LogMessage@Ogre@@YAXPBDZZ
	add	esp, 4
$LN4@setViewpor:

; 480  : 				}
; 481  : 				return;

	jmp	$LN7@setViewpor
$LN5@setViewpor:

; 482  : 			}
; 483  : 
; 484  : 			D3DSURFACE_DESC desc;
; 485  : 			ptarget->GetDesc(&desc);

	lea	edx, DWORD PTR _desc$151943[ebp]
	push	edx
	mov	eax, DWORD PTR _ptarget$151937[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _ptarget$151937[ebp]
	push	edx
	mov	eax, DWORD PTR [ecx+48]
	call	eax

; 486  : 			ptarget->Release();

	mov	ecx, DWORD PTR _ptarget$151937[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _ptarget$151937[ebp]
	push	eax
	mov	ecx, DWORD PTR [edx+8]
	call	ecx

; 487  : 
; 488  : 			vp.X = (UINT)(viewport.left*desc.Width);

	mov	edx, DWORD PTR _desc$151943[ebp+24]
	mov	DWORD PTR tv221[ebp], edx
	mov	DWORD PTR tv221[ebp+4], 0
	fild	QWORD PTR tv221[ebp]
	mov	eax, DWORD PTR _viewport$[ebp]
	fmul	DWORD PTR [eax]
	fnstcw	WORD PTR tv226[ebp]
	movzx	eax, WORD PTR tv226[ebp]
	or	eax, 3072				; 00000c00H
	mov	DWORD PTR tv229[ebp], eax
	fldcw	WORD PTR tv229[ebp]
	fistp	QWORD PTR tv231[ebp]
	fldcw	WORD PTR tv226[ebp]
	mov	ecx, DWORD PTR tv231[ebp]
	mov	DWORD PTR _vp$[ebp], ecx

; 489  : 			vp.Width = (UINT)(viewport.width*desc.Width);

	mov	edx, DWORD PTR _desc$151943[ebp+24]
	mov	DWORD PTR tv234[ebp], edx
	mov	DWORD PTR tv234[ebp+4], 0
	fild	QWORD PTR tv234[ebp]
	mov	eax, DWORD PTR _viewport$[ebp]
	fmul	DWORD PTR [eax+8]
	fnstcw	WORD PTR tv239[ebp]
	movzx	eax, WORD PTR tv239[ebp]
	or	eax, 3072				; 00000c00H
	mov	DWORD PTR tv242[ebp], eax
	fldcw	WORD PTR tv242[ebp]
	fistp	QWORD PTR tv244[ebp]
	fldcw	WORD PTR tv239[ebp]
	mov	ecx, DWORD PTR tv244[ebp]
	mov	DWORD PTR _vp$[ebp+8], ecx

; 490  : 			vp.Y = (UINT)(viewport.top*desc.Height);

	mov	edx, DWORD PTR _desc$151943[ebp+28]
	mov	DWORD PTR tv247[ebp], edx
	mov	DWORD PTR tv247[ebp+4], 0
	fild	QWORD PTR tv247[ebp]
	mov	eax, DWORD PTR _viewport$[ebp]
	fmul	DWORD PTR [eax+4]
	fnstcw	WORD PTR tv252[ebp]
	movzx	eax, WORD PTR tv252[ebp]
	or	eax, 3072				; 00000c00H
	mov	DWORD PTR tv255[ebp], eax
	fldcw	WORD PTR tv255[ebp]
	fistp	QWORD PTR tv257[ebp]
	fldcw	WORD PTR tv252[ebp]
	mov	ecx, DWORD PTR tv257[ebp]
	mov	DWORD PTR _vp$[ebp+4], ecx

; 491  : 			vp.Height = (UINT)(viewport.height*desc.Height);

	mov	edx, DWORD PTR _desc$151943[ebp+28]
	mov	DWORD PTR tv260[ebp], edx
	mov	DWORD PTR tv260[ebp+4], 0
	fild	QWORD PTR tv260[ebp]
	mov	eax, DWORD PTR _viewport$[ebp]
	fmul	DWORD PTR [eax+12]
	fnstcw	WORD PTR tv265[ebp]
	movzx	eax, WORD PTR tv265[ebp]
	or	eax, 3072				; 00000c00H
	mov	DWORD PTR tv268[ebp], eax
	fldcw	WORD PTR tv268[ebp]
	fistp	QWORD PTR tv270[ebp]
	fldcw	WORD PTR tv265[ebp]
	mov	ecx, DWORD PTR tv270[ebp]
	mov	DWORD PTR _vp$[ebp+12], ecx

; 492  : 		}
; 493  : 		else

	jmp	$LN3@setViewpor
$LN6@setViewpor:

; 494  : 		{
; 495  : 			vp.X = (DWORD)viewport.left;

	mov	edx, DWORD PTR _viewport$[ebp]
	fld	DWORD PTR [edx]
	fnstcw	WORD PTR tv274[ebp]
	movzx	eax, WORD PTR tv274[ebp]
	or	eax, 3072				; 00000c00H
	mov	DWORD PTR tv277[ebp], eax
	fldcw	WORD PTR tv277[ebp]
	fistp	QWORD PTR tv279[ebp]
	fldcw	WORD PTR tv274[ebp]
	mov	eax, DWORD PTR tv279[ebp]
	mov	DWORD PTR _vp$[ebp], eax

; 496  : 			vp.Y = (DWORD)viewport.top;

	mov	ecx, DWORD PTR _viewport$[ebp]
	fld	DWORD PTR [ecx+4]
	fnstcw	WORD PTR tv283[ebp]
	movzx	eax, WORD PTR tv283[ebp]
	or	eax, 3072				; 00000c00H
	mov	DWORD PTR tv286[ebp], eax
	fldcw	WORD PTR tv286[ebp]
	fistp	QWORD PTR tv288[ebp]
	fldcw	WORD PTR tv283[ebp]
	mov	edx, DWORD PTR tv288[ebp]
	mov	DWORD PTR _vp$[ebp+4], edx

; 497  : 			vp.Width = (DWORD)viewport.width;

	mov	eax, DWORD PTR _viewport$[ebp]
	fld	DWORD PTR [eax+8]
	fnstcw	WORD PTR tv292[ebp]
	movzx	eax, WORD PTR tv292[ebp]
	or	eax, 3072				; 00000c00H
	mov	DWORD PTR tv295[ebp], eax
	fldcw	WORD PTR tv295[ebp]
	fistp	QWORD PTR tv297[ebp]
	fldcw	WORD PTR tv292[ebp]
	mov	ecx, DWORD PTR tv297[ebp]
	mov	DWORD PTR _vp$[ebp+8], ecx

; 498  : 			vp.Height = (DWORD)viewport.height;

	mov	edx, DWORD PTR _viewport$[ebp]
	fld	DWORD PTR [edx+12]
	fnstcw	WORD PTR tv301[ebp]
	movzx	eax, WORD PTR tv301[ebp]
	or	eax, 3072				; 00000c00H
	mov	DWORD PTR tv304[ebp], eax
	fldcw	WORD PTR tv304[ebp]
	fistp	QWORD PTR tv306[ebp]
	fldcw	WORD PTR tv301[ebp]
	mov	eax, DWORD PTR tv306[ebp]
	mov	DWORD PTR _vp$[ebp+12], eax

; 499  : 
; 500  : 			IDirect3DSurface9 *ptarget = NULL;

	mov	DWORD PTR _ptarget$151953[ebp], 0

; 501  : 			if(FAILED(m_pd3dDevice->GetRenderTarget(0, &ptarget))) //!!!会不会有效率问题？

	lea	ecx, DWORD PTR _ptarget$151953[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+104]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+104]
	mov	eax, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR [eax+152]
	call	ecx
	test	eax, eax
	jge	SHORT $LN2@setViewpor

; 502  : 			{
; 503  : 				if ( ptarget != NULL )

	cmp	DWORD PTR _ptarget$151953[ebp], 0
	je	SHORT $LN1@setViewpor

; 504  : 				{
; 505  : 					LOG_PRIVATE( "D3D9RenderSystem::setViewport--GetRenderTarget--获取了RenderTarget，但是没释放--505" );

	push	64					; 00000040H
	push	505					; 000001f9H
	push	OFFSET $SG151957
	call	DWORD PTR __imp_?LogSetCurParam@Ogre@@YAXPBDHI@Z
	add	esp, 12					; 0000000cH
	push	OFFSET $SG151958
	call	DWORD PTR __imp_?LogMessage@Ogre@@YAXPBDZZ
	add	esp, 4
$LN1@setViewpor:

; 506  : 				}
; 507  : 				return;

	jmp	SHORT $LN7@setViewpor
$LN2@setViewpor:

; 508  : 			}
; 509  : 
; 510  : 			D3DSURFACE_DESC desc;
; 511  : 			ptarget->GetDesc(&desc);

	lea	edx, DWORD PTR _desc$151959[ebp]
	push	edx
	mov	eax, DWORD PTR _ptarget$151953[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _ptarget$151953[ebp]
	push	edx
	mov	eax, DWORD PTR [ecx+48]
	call	eax

; 512  : 			ptarget->Release();

	mov	ecx, DWORD PTR _ptarget$151953[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _ptarget$151953[ebp]
	push	eax
	mov	ecx, DWORD PTR [edx+8]
	call	ecx
$LN3@setViewpor:

; 513  : 		}
; 514  : 
; 515  : 		vp.MinZ = viewport.minz;

	mov	edx, DWORD PTR _viewport$[ebp]
	fld	DWORD PTR [edx+16]
	fstp	DWORD PTR _vp$[ebp+16]

; 516  : 		vp.MaxZ = viewport.maxz;

	mov	eax, DWORD PTR _viewport$[ebp]
	fld	DWORD PTR [eax+20]
	fstp	DWORD PTR _vp$[ebp+20]

; 517  : 
; 518  : 		m_pd3dDevice->SetViewport(&vp);

	lea	ecx, DWORD PTR _vp$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+104]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+104]
	mov	eax, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR [eax+188]
	call	ecx
$LN7@setViewpor:

; 519  : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
?setViewport@D3D9RenderSystem@Ogre@@UAEXABUViewport@2@@Z ENDP ; Ogre::D3D9RenderSystem::setViewport
; Function compile flags: /Odtp
_this$ = -8						; size = 4
_hr$ = -4						; size = 4
?beginFrame@D3D9RenderSystem@Ogre@@UAE_NXZ PROC		; Ogre::D3D9RenderSystem::beginFrame
; _this$ = ecx

; 522  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 523  : 		HRESULT hr = m_pd3dDevice->BeginScene();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+104]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+104]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	mov	edx, DWORD PTR [ecx+164]
	call	edx
	mov	DWORD PTR _hr$[ebp], eax

; 524  : 
; 525  : 		m_RenderStats.nprimitive_d = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+28], 0

; 526  : 		m_RenderStats.ncontext_d = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+36], 0

; 527  : 		m_RenderStats.ndraw_d = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+32], 0

; 528  : 		m_RenderStats.nshaderswitch_d = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+40], 0

; 529  : 
; 530  : 		return SUCCEEDED(hr);

	xor	eax, eax
	cmp	DWORD PTR _hr$[ebp], 0
	setge	al

; 531  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?beginFrame@D3D9RenderSystem@Ogre@@UAE_NXZ ENDP		; Ogre::D3D9RenderSystem::beginFrame
; Function compile flags: /Odtp
_this$ = -4						; size = 4
?endFrame@D3D9RenderSystem@Ogre@@UAEXXZ PROC		; Ogre::D3D9RenderSystem::endFrame
; _this$ = ecx

; 534  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 535  : 		m_pd3dDevice->EndScene();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+104]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+104]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	mov	edx, DWORD PTR [ecx+168]
	call	edx

; 536  : 
; 537  : 		m_RenderStats.nprimitive = m_RenderStats.nprimitive_d;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	DWORD PTR [eax+12], edx

; 538  : 		m_RenderStats.ncontext = m_RenderStats.ncontext_d;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	DWORD PTR [eax+20], edx

; 539  : 		m_RenderStats.ndraw = m_RenderStats.ndraw_d;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	DWORD PTR [eax+16], edx

; 540  : 		m_RenderStats.nshaderswitch = m_RenderStats.nshaderswitch_d;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	mov	DWORD PTR [eax+24], edx

; 541  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?endFrame@D3D9RenderSystem@Ogre@@UAEXXZ ENDP		; Ogre::D3D9RenderSystem::endFrame
; Function compile flags: /Odtp
_this$ = -4						; size = 4
?getMainWindow@D3D9RenderSystem@Ogre@@UAEPAVRenderWindow@2@XZ PROC ; Ogre::D3D9RenderSystem::getMainWindow
; _this$ = ecx

; 544  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 545  : 		return m_WindowTargets[0];

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 464				; 000001d0H
	call	??A?$vector@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@QAEAAPAVD3DRenderWindow@Ogre@@I@Z ; std::vector<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >::operator[]
	mov	eax, DWORD PTR [eax]

; 546  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?getMainWindow@D3D9RenderSystem@Ogre@@UAEPAVRenderWindow@2@XZ ENDP ; Ogre::D3D9RenderSystem::getMainWindow
; Function compile flags: /Odtp
tv84 = -28						; size = 4
tv79 = -24						; size = 4
_this$ = -20						; size = 4
_temp$151980 = -16					; size = 4
_i$151976 = -12						; size = 4
_ret$ = -8						; size = 4
_windowtargetsize$ = -4					; size = 4
?present@D3D9RenderSystem@Ogre@@UAEHXZ PROC		; Ogre::D3D9RenderSystem::present
; _this$ = ecx

; 549  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR _this$[ebp], ecx

; 550  : 		int ret =0;

	mov	DWORD PTR _ret$[ebp], 0

; 551  : 		size_t windowtargetsize = m_WindowTargets.size();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 464				; 000001d0H
	call	?size@?$vector@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >::size
	mov	DWORD PTR _windowtargetsize$[ebp], eax

; 552  : 		for(size_t i=0;i<windowtargetsize;i++)

	mov	DWORD PTR _i$151976[ebp], 0
	jmp	SHORT $LN3@present
$LN2@present:
	mov	eax, DWORD PTR _i$151976[ebp]
	add	eax, 1
	mov	DWORD PTR _i$151976[ebp], eax
$LN3@present:
	mov	ecx, DWORD PTR _i$151976[ebp]
	cmp	ecx, DWORD PTR _windowtargetsize$[ebp]
	jae	SHORT $LN1@present

; 553  : 		{
; 554  : 			int temp = m_WindowTargets[i]->present();

	mov	edx, DWORD PTR _i$151976[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 464				; 000001d0H
	call	??A?$vector@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@QAEAAPAVD3DRenderWindow@Ogre@@I@Z ; std::vector<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >::operator[]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR tv79[ebp], eax
	mov	ecx, DWORD PTR tv79[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv79[ebp]
	mov	eax, DWORD PTR [edx+52]
	call	eax
	mov	DWORD PTR _temp$151980[ebp], eax

; 555  : 			ret = max(ret,temp);

	mov	ecx, DWORD PTR _ret$[ebp]
	cmp	ecx, DWORD PTR _temp$151980[ebp]
	jle	SHORT $LN6@present
	mov	edx, DWORD PTR _ret$[ebp]
	mov	DWORD PTR tv84[ebp], edx
	jmp	SHORT $LN7@present
$LN6@present:
	mov	eax, DWORD PTR _temp$151980[ebp]
	mov	DWORD PTR tv84[ebp], eax
$LN7@present:
	mov	ecx, DWORD PTR tv84[ebp]
	mov	DWORD PTR _ret$[ebp], ecx

; 556  : 		}

	jmp	SHORT $LN2@present
$LN1@present:

; 557  : 		return ret;

	mov	eax, DWORD PTR _ret$[ebp]

; 558  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?present@D3D9RenderSystem@Ogre@@UAEHXZ ENDP		; Ogre::D3D9RenderSystem::present
_TEXT	ENDS
PUBLIC	?push_back@?$vector@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@QAEXABQAVD3D9VertexDecl@Ogre@@@Z ; std::vector<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >::push_back
PUBLIC	??_GD3D9VertexDecl@Ogre@@QAEPAXI@Z		; Ogre::D3D9VertexDecl::`scalar deleting destructor'
PUBLIC	??D?$_Vector_iterator@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@QBEAAPAVD3D9VertexDecl@Ogre@@XZ ; std::_Vector_iterator<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >::operator*
PUBLIC	??9?$_Vector_const_iterator@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >::operator!=
PUBLIC	?end@?$vector@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@2@XZ ; std::vector<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >::end
PUBLIC	??E?$_Vector_iterator@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@QAE?AV01@H@Z ; std::_Vector_iterator<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >::operator++
PUBLIC	?begin@?$vector@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@2@XZ ; std::vector<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >::begin
EXTRN	?create@D3D9VertexDecl@Ogre@@QAE_NXZ:PROC	; Ogre::D3D9VertexDecl::create
EXTRN	??0D3D9VertexDecl@Ogre@@QAE@PAVD3D9RenderSystem@1@ABVVertexFormat@1@@Z:PROC ; Ogre::D3D9VertexDecl::D3D9VertexDecl
EXTRN	__imp_??8VertexFormat@Ogre@@QBE_NABV01@@Z:PROC
xdata$x	SEGMENT
__unwindtable$?getInputLayout@D3D9RenderSystem@Ogre@@UAEIABVVertexFormat@2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?getInputLayout@D3D9RenderSystem@Ogre@@UAEIABVVertexFormat@2@@Z$0
__ehfuncinfo$?getInputLayout@D3D9RenderSystem@Ogre@@UAEIABVVertexFormat@2@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?getInputLayout@D3D9RenderSystem@Ogre@@UAEIABVVertexFormat@2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
_TEXT	SEGMENT
tv144 = -72						; size = 4
tv136 = -68						; size = 4
_this$ = -64						; size = 4
$T159773 = -60						; size = 4
$T159772 = -56						; size = 4
$T159769 = -52						; size = 4
$T159768 = -48						; size = 4
$T159767 = -44						; size = 8
$T159766 = -36						; size = 8
_pdecl$152154 = -28					; size = 4
_pdecl$ = -24						; size = 4
_iter$ = -20						; size = 8
__$EHRec$ = -12						; size = 12
_vertfmt$ = 8						; size = 4
?getInputLayout@D3D9RenderSystem@Ogre@@UAEIABVVertexFormat@2@@Z PROC ; Ogre::D3D9RenderSystem::getInputLayout
; _this$ = ecx

; 561  : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?getInputLayout@D3D9RenderSystem@Ogre@@UAEIABVVertexFormat@2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 60					; 0000003cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 562  : 		std::vector<D3D9VertexDecl *>::iterator iter = m_VertexDecls.begin();

	lea	eax, DWORD PTR _iter$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 520				; 00000208H
	call	?begin@?$vector@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@2@XZ ; std::vector<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >::begin
	jmp	SHORT $LN5@getInputLa
$LN4@getInputLa:

; 563  : 		for(; iter!=m_VertexDecls.end(); iter++)

	push	0
	lea	ecx, DWORD PTR $T159766[ebp]
	push	ecx
	lea	ecx, DWORD PTR _iter$[ebp]
	call	??E?$_Vector_iterator@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@QAE?AV01@H@Z ; std::_Vector_iterator<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >::operator++
$LN5@getInputLa:
	lea	edx, DWORD PTR $T159767[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 520				; 00000208H
	call	?end@?$vector@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@2@XZ ; std::vector<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >::end
	push	eax
	lea	ecx, DWORD PTR _iter$[ebp]
	call	??9?$_Vector_const_iterator@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >::operator!=
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@getInputLa

; 564  : 		{
; 565  : 			D3D9VertexDecl *pdecl = *iter;

	lea	ecx, DWORD PTR _iter$[ebp]
	call	??D?$_Vector_iterator@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@QBEAAPAVD3D9VertexDecl@Ogre@@XZ ; std::_Vector_iterator<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >::operator*
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _pdecl$152154[ebp], ecx

; 566  : 			if(pdecl->m_VertFmt == vertfmt) return (VertexDeclHandle)pdecl;

	mov	edx, DWORD PTR _vertfmt$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pdecl$152154[ebp]
	add	ecx, 4
	call	DWORD PTR __imp_??8VertexFormat@Ogre@@QBE_NABV01@@Z
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@getInputLa
	mov	eax, DWORD PTR _pdecl$152154[ebp]
	jmp	$LN6@getInputLa
$LN2@getInputLa:

; 567  : 		}

	jmp	SHORT $LN4@getInputLa
$LN3@getInputLa:

; 568  : 
; 569  : 		D3D9VertexDecl *pdecl = new D3D9VertexDecl(this, vertfmt);

	push	32					; 00000020H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T159769[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T159769[ebp], 0
	je	SHORT $LN8@getInputLa
	mov	ecx, DWORD PTR _vertfmt$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T159769[ebp]
	call	??0D3D9VertexDecl@Ogre@@QAE@PAVD3D9RenderSystem@1@ABVVertexFormat@1@@Z ; Ogre::D3D9VertexDecl::D3D9VertexDecl
	mov	DWORD PTR tv136[ebp], eax
	jmp	SHORT $LN9@getInputLa
$LN8@getInputLa:
	mov	DWORD PTR tv136[ebp], 0
$LN9@getInputLa:
	mov	eax, DWORD PTR tv136[ebp]
	mov	DWORD PTR $T159768[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR $T159768[ebp]
	mov	DWORD PTR _pdecl$[ebp], ecx

; 570  : 		if(!pdecl->create())

	mov	ecx, DWORD PTR _pdecl$[ebp]
	call	?create@D3D9VertexDecl@Ogre@@QAE_NXZ	; Ogre::D3D9VertexDecl::create
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN1@getInputLa

; 571  : 		{
; 572  : 			delete pdecl;

	mov	eax, DWORD PTR _pdecl$[ebp]
	mov	DWORD PTR $T159773[ebp], eax
	mov	ecx, DWORD PTR $T159773[ebp]
	mov	DWORD PTR $T159772[ebp], ecx
	cmp	DWORD PTR $T159772[ebp], 0
	je	SHORT $LN10@getInputLa
	push	1
	mov	ecx, DWORD PTR $T159772[ebp]
	call	??_GD3D9VertexDecl@Ogre@@QAEPAXI@Z
	mov	DWORD PTR tv144[ebp], eax
	jmp	SHORT $LN11@getInputLa
$LN10@getInputLa:
	mov	DWORD PTR tv144[ebp], 0
$LN11@getInputLa:

; 573  : 			return NULL;

	xor	eax, eax
	jmp	SHORT $LN6@getInputLa
$LN1@getInputLa:

; 574  : 		}
; 575  : 
; 576  : 		m_VertexDecls.push_back(pdecl);

	lea	edx, DWORD PTR _pdecl$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 520				; 00000208H
	call	?push_back@?$vector@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@QAEXABQAVD3D9VertexDecl@Ogre@@@Z ; std::vector<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >::push_back

; 577  : 		return (VertexDeclHandle)pdecl;

	mov	eax, DWORD PTR _pdecl$[ebp]
$LN6@getInputLa:

; 578  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?getInputLayout@D3D9RenderSystem@Ogre@@UAEIABVVertexFormat@2@@Z$0:
	mov	eax, DWORD PTR $T159769[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?getInputLayout@D3D9RenderSystem@Ogre@@UAEIABVVertexFormat@2@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-64]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?getInputLayout@D3D9RenderSystem@Ogre@@UAEIABVVertexFormat@2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?getInputLayout@D3D9RenderSystem@Ogre@@UAEIABVVertexFormat@2@@Z ENDP ; Ogre::D3D9RenderSystem::getInputLayout
EXTRN	??1D3D9VertexDecl@Ogre@@QAE@XZ:PROC		; Ogre::D3D9VertexDecl::~D3D9VertexDecl
; Function compile flags: /Odtp
;	COMDAT ??_GD3D9VertexDecl@Ogre@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GD3D9VertexDecl@Ogre@@QAEPAXI@Z PROC			; Ogre::D3D9VertexDecl::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1D3D9VertexDecl@Ogre@@QAE@XZ		; Ogre::D3D9VertexDecl::~D3D9VertexDecl
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@3
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@3:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GD3D9VertexDecl@Ogre@@QAEPAXI@Z ENDP			; Ogre::D3D9VertexDecl::`scalar deleting destructor'
; Function compile flags: /Odtp
_TEXT	ENDS
_TEXT	SEGMENT
_this$ = -8						; size = 4
_hr$ = -4						; size = 4
?testDeviceReset@D3D9RenderSystem@Ogre@@UAEHXZ PROC	; Ogre::D3D9RenderSystem::testDeviceReset
; _this$ = ecx

; 581  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 582  : 		HRESULT hr = m_pd3dDevice->TestCooperativeLevel();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+104]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+104]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	mov	edx, DWORD PTR [ecx+12]
	call	edx
	mov	DWORD PTR _hr$[ebp], eax

; 583  : 		if( D3DERR_DEVICELOST == hr )

	cmp	DWORD PTR _hr$[ebp], -2005530520	; 88760868H
	jne	SHORT $LN7@testDevice

; 584  : 		{
; 585  : 			return RenderWindow::PRESENT_LOSTDEVICE;

	mov	eax, 1
	jmp	SHORT $LN8@testDevice
	jmp	SHORT $LN6@testDevice
$LN7@testDevice:

; 586  : 		}
; 587  : 		else if(D3DERR_DRIVERINTERNALERROR == hr)

	cmp	DWORD PTR _hr$[ebp], -2005530585	; 88760827H
	jne	SHORT $LN5@testDevice

; 588  : 		{
; 589  : 			return RenderWindow::PRESENT_ERROR;

	mov	eax, 3
	jmp	SHORT $LN8@testDevice
	jmp	SHORT $LN6@testDevice
$LN5@testDevice:

; 590  : 		}
; 591  : 		else if(D3DERR_DEVICENOTRESET == hr)

	cmp	DWORD PTR _hr$[ebp], -2005530519	; 88760869H
	jne	SHORT $LN3@testDevice

; 592  : 		{
; 593  : 			return RenderWindow::PRESENT_RESTORE;

	mov	eax, 2
	jmp	SHORT $LN8@testDevice
	jmp	SHORT $LN6@testDevice
$LN3@testDevice:

; 594  : 		}
; 595  : 		else if(static_cast<D3DRenderWindow *>(getMainWindow())->m_bNeedResetDevice)

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+32]
	call	eax
	movzx	ecx, BYTE PTR [eax+12]
	test	ecx, ecx
	je	SHORT $LN6@testDevice

; 596  : 		{
; 597  : 			return RenderWindow::PRESENT_RESTORE;

	mov	eax, 2
	jmp	SHORT $LN8@testDevice
$LN6@testDevice:

; 598  : 		}
; 599  : 
; 600  : 		return RenderWindow::PRESENT_OK;

	xor	eax, eax
$LN8@testDevice:

; 601  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?testDeviceReset@D3D9RenderSystem@Ogre@@UAEHXZ ENDP	; Ogre::D3D9RenderSystem::testDeviceReset
; Function compile flags: /Odtp
_this$ = -8						; size = 4
_hr$ = -4						; size = 4
?resetDevice@D3D9RenderSystem@Ogre@@UAEHXZ PROC		; Ogre::D3D9RenderSystem::resetDevice
; _this$ = ecx

; 604  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 605  : 		HRESULT hr = m_pd3dDevice->TestCooperativeLevel();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+104]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+104]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	mov	edx, DWORD PTR [ecx+12]
	call	edx
	mov	DWORD PTR _hr$[ebp], eax

; 606  : 		if( D3DERR_DEVICELOST == hr )

	cmp	DWORD PTR _hr$[ebp], -2005530520	; 88760868H
	jne	SHORT $LN7@resetDevic

; 607  : 		{
; 608  : 			return RenderWindow::PRESENT_LOSTDEVICE;

	mov	eax, 1
	jmp	SHORT $LN8@resetDevic
	jmp	SHORT $LN6@resetDevic
$LN7@resetDevic:

; 609  : 		}
; 610  : 		else if(D3DERR_DRIVERINTERNALERROR == hr)

	cmp	DWORD PTR _hr$[ebp], -2005530585	; 88760827H
	jne	SHORT $LN5@resetDevic

; 611  : 		{
; 612  : 			return RenderWindow::PRESENT_ERROR;

	mov	eax, 3
	jmp	SHORT $LN8@resetDevic
	jmp	SHORT $LN6@resetDevic
$LN5@resetDevic:

; 613  : 		}
; 614  : 		else if(D3DERR_DEVICENOTRESET == hr)

	cmp	DWORD PTR _hr$[ebp], -2005530519	; 88760869H
	jne	SHORT $LN3@resetDevic

; 615  : 		{
; 616  : 			restoreLostDevice();

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+48]
	call	eax
	jmp	SHORT $LN6@resetDevic
$LN3@resetDevic:

; 617  : 		}
; 618  : 		else if(static_cast<D3DRenderWindow *>(getMainWindow())->m_bNeedResetDevice)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+32]
	call	eax
	movzx	ecx, BYTE PTR [eax+12]
	test	ecx, ecx
	je	SHORT $LN6@resetDevic

; 619  : 		{
; 620  : 			restoreLostDevice();

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+48]
	call	edx
$LN6@resetDevic:

; 621  : 		}
; 622  : 
; 623  : 		return RenderWindow::PRESENT_OK;

	xor	eax, eax
$LN8@resetDevic:

; 624  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?resetDevice@D3D9RenderSystem@Ogre@@UAEHXZ ENDP		; Ogre::D3D9RenderSystem::resetDevice
_TEXT	ENDS
EXTRN	?onResetDevice@D3D9MaterialManager@Ogre@@QAE_NXZ:PROC ; Ogre::D3D9MaterialManager::onResetDevice
EXTRN	?onResetDevice@D3D9HardwareBufferManager@Ogre@@QAE_NXZ:PROC ; Ogre::D3D9HardwareBufferManager::onResetDevice
EXTRN	?onResetDevice@D3D9HardwarePixelBufferManager@Ogre@@QAE_NXZ:PROC ; Ogre::D3D9HardwarePixelBufferManager::onResetDevice
EXTRN	?onResetDevice@D3D9VertexDecl@Ogre@@QAE_NXZ:PROC ; Ogre::D3D9VertexDecl::onResetDevice
EXTRN	?onResetDevice@D3DRenderWindow@Ogre@@QAE_NXZ:PROC ; Ogre::D3DRenderWindow::onResetDevice
EXTRN	?onLostDevice@D3DRenderWindow@Ogre@@QAEXXZ:PROC	; Ogre::D3DRenderWindow::onLostDevice
EXTRN	?onLostDevice@D3D9MaterialManager@Ogre@@QAEXXZ:PROC ; Ogre::D3D9MaterialManager::onLostDevice
EXTRN	?onLostDevice@D3D9HardwareBufferManager@Ogre@@QAEXXZ:PROC ; Ogre::D3D9HardwareBufferManager::onLostDevice
EXTRN	?onLostDevice@D3D9HardwarePixelBufferManager@Ogre@@QAEXXZ:PROC ; Ogre::D3D9HardwarePixelBufferManager::onLostDevice
EXTRN	?onLostDevice@D3D9VertexDecl@Ogre@@QAEXXZ:PROC	; Ogre::D3D9VertexDecl::onLostDevice
; Function compile flags: /Odtp
_TEXT	SEGMENT
_this$ = -64						; size = 4
$T159790 = -60						; size = 8
$T159789 = -52						; size = 8
$T159788 = -44						; size = 8
$T159787 = -36						; size = 8
$T159786 = -28						; size = 8
_pdecl$152247 = -20					; size = 4
_pdecl$152234 = -16					; size = 4
_i$ = -12						; size = 4
_iter$ = -8						; size = 8
?restoreLostDevice@D3D9RenderSystem@Ogre@@UAE_NXZ PROC	; Ogre::D3D9RenderSystem::restoreLostDevice
; _this$ = ecx

; 627  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	mov	DWORD PTR _this$[ebp], ecx

; 628  : 		size_t i;
; 629  : 
; 630  : 		SAFE_RELEASE(m_pCursorSurface);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+556], 0
	je	SHORT $LN14@restoreLos
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+556]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+556]
	mov	edx, DWORD PTR [edx]
	push	ecx
	mov	eax, DWORD PTR [edx+8]
	call	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+556], 0
$LN14@restoreLos:

; 631  : 		//m_pd3dDevice->EvictManagedResources();
; 632  : 
; 633  : 		std::vector<D3D9VertexDecl *>::iterator iter = m_VertexDecls.begin();

	lea	edx, DWORD PTR _iter$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 520				; 00000208H
	call	?begin@?$vector@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@2@XZ ; std::vector<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >::begin
	jmp	SHORT $LN13@restoreLos
$LN12@restoreLos:

; 634  : 		for(; iter!=m_VertexDecls.end(); iter++)

	push	0
	lea	eax, DWORD PTR $T159786[ebp]
	push	eax
	lea	ecx, DWORD PTR _iter$[ebp]
	call	??E?$_Vector_iterator@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@QAE?AV01@H@Z ; std::_Vector_iterator<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >::operator++
$LN13@restoreLos:
	lea	ecx, DWORD PTR $T159787[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 520				; 00000208H
	call	?end@?$vector@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@2@XZ ; std::vector<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >::end
	push	eax
	lea	ecx, DWORD PTR _iter$[ebp]
	call	??9?$_Vector_const_iterator@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >::operator!=
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN11@restoreLos

; 635  : 		{
; 636  : 			D3D9VertexDecl *pdecl = *iter;

	lea	ecx, DWORD PTR _iter$[ebp]
	call	??D?$_Vector_iterator@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@QBEAAPAVD3D9VertexDecl@Ogre@@XZ ; std::_Vector_iterator<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >::operator*
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR _pdecl$152234[ebp], eax

; 637  : 			pdecl->onLostDevice();

	mov	ecx, DWORD PTR _pdecl$152234[ebp]
	call	?onLostDevice@D3D9VertexDecl@Ogre@@QAEXXZ ; Ogre::D3D9VertexDecl::onLostDevice

; 638  : 		}

	jmp	SHORT $LN12@restoreLos
$LN11@restoreLos:

; 639  : 
; 640  : 		m_pPBufMgr->onLostDevice();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+544]
	call	?onLostDevice@D3D9HardwarePixelBufferManager@Ogre@@QAEXXZ ; Ogre::D3D9HardwarePixelBufferManager::onLostDevice

; 641  : 		m_pBufMgr->onLostDevice();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+552]
	call	?onLostDevice@D3D9HardwareBufferManager@Ogre@@QAEXXZ ; Ogre::D3D9HardwareBufferManager::onLostDevice

; 642  : 		m_pMtlMgr->onLostDevice();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+548]
	call	?onLostDevice@D3D9MaterialManager@Ogre@@QAEXXZ ; Ogre::D3D9MaterialManager::onLostDevice

; 643  : 
; 644  : 
; 645  : 		//顺序不能颠倒
; 646  : 		for(i=m_WindowTargets.size(); i>0; i--)

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 464				; 000001d0H
	call	?size@?$vector@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >::size
	mov	DWORD PTR _i$[ebp], eax
	jmp	SHORT $LN10@restoreLos
$LN9@restoreLos:
	mov	ecx, DWORD PTR _i$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _i$[ebp], ecx
$LN10@restoreLos:
	cmp	DWORD PTR _i$[ebp], 0
	jbe	SHORT $LN8@restoreLos

; 647  : 		{
; 648  : 			m_WindowTargets[i-1]->onLostDevice();

	mov	edx, DWORD PTR _i$[ebp]
	sub	edx, 1
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 464				; 000001d0H
	call	??A?$vector@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@QAEAAPAVD3DRenderWindow@Ogre@@I@Z ; std::vector<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >::operator[]
	mov	ecx, DWORD PTR [eax]
	call	?onLostDevice@D3DRenderWindow@Ogre@@QAEXXZ ; Ogre::D3DRenderWindow::onLostDevice

; 649  : 		}

	jmp	SHORT $LN9@restoreLos
$LN8@restoreLos:

; 650  : 
; 651  : 
; 652  : 		//顺序不能颠倒
; 653  : 		for(i=0; i<m_WindowTargets.size(); i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN7@restoreLos
$LN6@restoreLos:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN7@restoreLos:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 464				; 000001d0H
	call	?size@?$vector@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >::size
	cmp	DWORD PTR _i$[ebp], eax
	jae	SHORT $LN5@restoreLos

; 654  : 		{
; 655  : 			m_WindowTargets[i]->onResetDevice();

	mov	ecx, DWORD PTR _i$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 464				; 000001d0H
	call	??A?$vector@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@QAEAAPAVD3DRenderWindow@Ogre@@I@Z ; std::vector<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >::operator[]
	mov	ecx, DWORD PTR [eax]
	call	?onResetDevice@D3DRenderWindow@Ogre@@QAE_NXZ ; Ogre::D3DRenderWindow::onResetDevice

; 656  : 		}

	jmp	SHORT $LN6@restoreLos
$LN5@restoreLos:

; 657  : 
; 658  : 		//restore default resource
; 659  : 		iter = m_VertexDecls.begin();

	lea	edx, DWORD PTR $T159788[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 520				; 00000208H
	call	?begin@?$vector@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@2@XZ ; std::vector<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >::begin
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _iter$[ebp], ecx
	mov	DWORD PTR _iter$[ebp+4], edx
	jmp	SHORT $LN4@restoreLos
$LN3@restoreLos:

; 660  : 		for(; iter!=m_VertexDecls.end(); iter++)

	push	0
	lea	eax, DWORD PTR $T159789[ebp]
	push	eax
	lea	ecx, DWORD PTR _iter$[ebp]
	call	??E?$_Vector_iterator@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@QAE?AV01@H@Z ; std::_Vector_iterator<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >::operator++
$LN4@restoreLos:
	lea	ecx, DWORD PTR $T159790[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 520				; 00000208H
	call	?end@?$vector@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@2@XZ ; std::vector<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >::end
	push	eax
	lea	ecx, DWORD PTR _iter$[ebp]
	call	??9?$_Vector_const_iterator@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >::operator!=
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN2@restoreLos

; 661  : 		{
; 662  : 			D3D9VertexDecl *pdecl = *iter;

	lea	ecx, DWORD PTR _iter$[ebp]
	call	??D?$_Vector_iterator@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@QBEAAPAVD3D9VertexDecl@Ogre@@XZ ; std::_Vector_iterator<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >::operator*
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR _pdecl$152247[ebp], eax

; 663  : 			pdecl->onResetDevice();

	mov	ecx, DWORD PTR _pdecl$152247[ebp]
	call	?onResetDevice@D3D9VertexDecl@Ogre@@QAE_NXZ ; Ogre::D3D9VertexDecl::onResetDevice

; 664  : 		}

	jmp	SHORT $LN3@restoreLos
$LN2@restoreLos:

; 665  : 		
; 666  : 		m_pPBufMgr->onResetDevice();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+544]
	call	?onResetDevice@D3D9HardwarePixelBufferManager@Ogre@@QAE_NXZ ; Ogre::D3D9HardwarePixelBufferManager::onResetDevice

; 667  : 		m_pBufMgr->onResetDevice();

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+552]
	call	?onResetDevice@D3D9HardwareBufferManager@Ogre@@QAE_NXZ ; Ogre::D3D9HardwareBufferManager::onResetDevice

; 668  : 		m_pMtlMgr->onResetDevice();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+548]
	call	?onResetDevice@D3D9MaterialManager@Ogre@@QAE_NXZ ; Ogre::D3D9MaterialManager::onResetDevice

; 669  : 
; 670  : 		m_pd3dDevice->CreateOffscreenPlainSurface(32, 32, D3DFMT_A8R8G8B8, D3DPOOL_SCRATCH, &m_pCursorSurface, NULL);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 556				; 0000022cH
	push	ecx
	push	3
	push	21					; 00000015H
	push	32					; 00000020H
	push	32					; 00000020H
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+104]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+104]
	mov	eax, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR [eax+144]
	call	ecx

; 671  : 
; 672  : 		if (m_restoreDeviceCallBack)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+92], 0
	je	SHORT $LN1@restoreLos

; 673  : 		{
; 674  : 			m_restoreDeviceCallBack();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+92]
	call	ecx
$LN1@restoreLos:

; 675  : 		}
; 676  : 		return true;

	mov	al, 1

; 677  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?restoreLostDevice@D3D9RenderSystem@Ogre@@UAE_NXZ ENDP	; Ogre::D3D9RenderSystem::restoreLostDevice
; Function compile flags: /Odtp
_this$ = -4						; size = 4
_hwnd$ = 8						; size = 4
?findRenderWindow@D3D9RenderSystem@Ogre@@UAEPAVRenderWindow@2@PAX@Z PROC ; Ogre::D3D9RenderSystem::findRenderWindow
; _this$ = ecx

; 680  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 681  : 		return findRenderWindowByHWnd((HWND)hwnd);

	mov	eax, DWORD PTR _hwnd$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?findRenderWindowByHWnd@D3D9RenderSystem@Ogre@@QAEPAVD3DRenderWindow@2@PAUHWND__@@@Z ; Ogre::D3D9RenderSystem::findRenderWindowByHWnd

; 682  : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
?findRenderWindow@D3D9RenderSystem@Ogre@@UAEPAVRenderWindow@2@PAX@Z ENDP ; Ogre::D3D9RenderSystem::findRenderWindow
_TEXT	ENDS
PUBLIC	?fromPixelFormat@D3D9RenderSystem@Ogre@@QAE?AW4_D3DFORMAT@@W4PixelFormat@2@@Z ; Ogre::D3D9RenderSystem::fromPixelFormat
; Function compile flags: /Odtp
_TEXT	SEGMENT
tv64 = -8						; size = 4
_this$ = -4						; size = 4
_pfmt$ = 8						; size = 4
?fromPixelFormat@D3D9RenderSystem@Ogre@@QAE?AW4_D3DFORMAT@@W4PixelFormat@2@@Z PROC ; Ogre::D3D9RenderSystem::fromPixelFormat
; _this$ = ecx

; 685  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 686  : 		switch(pfmt)

	mov	eax, DWORD PTR _pfmt$[ebp]
	mov	DWORD PTR tv64[ebp], eax
	mov	ecx, DWORD PTR tv64[ebp]
	sub	ecx, 1
	mov	DWORD PTR tv64[ebp], ecx
	cmp	DWORD PTR tv64[ebp], 38			; 00000026H
	ja	$LN1@fromPixelF
	mov	edx, DWORD PTR tv64[ebp]
	jmp	DWORD PTR $LN38@fromPixelF[edx*4]
$LN33@fromPixelF:

; 687  : 		{
; 688  : 		case PF_L8:
; 689  : 			return D3DFMT_L8;

	mov	eax, 50					; 00000032H
	jmp	$LN36@fromPixelF
$LN32@fromPixelF:

; 690  : 		case PF_L16:
; 691  : 			return D3DFMT_L16;

	mov	eax, 81					; 00000051H
	jmp	$LN36@fromPixelF
$LN31@fromPixelF:

; 692  : 		case PF_A8:
; 693  : 			return D3DFMT_A8;

	mov	eax, 28					; 0000001cH
	jmp	$LN36@fromPixelF
$LN30@fromPixelF:

; 694  : 		case PF_A4L4:
; 695  : 			return D3DFMT_A4L4;

	mov	eax, 52					; 00000034H
	jmp	$LN36@fromPixelF
$LN29@fromPixelF:

; 696  : 		case PF_BYTE_LA:
; 697  : 			return D3DFMT_A8L8; // Assume little endian here

	mov	eax, 51					; 00000033H
	jmp	$LN36@fromPixelF
$LN28@fromPixelF:

; 698  : 		case PF_R5G6B5:
; 699  : 			return D3DFMT_R5G6B5;

	mov	eax, 23					; 00000017H
	jmp	$LN36@fromPixelF
$LN27@fromPixelF:

; 700  : 		case PF_R3G3B2:
; 701  : 			return D3DFMT_R3G3B2;

	mov	eax, 27					; 0000001bH
	jmp	$LN36@fromPixelF
$LN26@fromPixelF:

; 702  : 		case PF_A4R4G4B4:
; 703  : 			return D3DFMT_A4R4G4B4;

	mov	eax, 26					; 0000001aH
	jmp	$LN36@fromPixelF
$LN25@fromPixelF:

; 704  : 		case PF_A1R5G5B5:
; 705  : 			return D3DFMT_A1R5G5B5;

	mov	eax, 25					; 00000019H
	jmp	$LN36@fromPixelF
$LN24@fromPixelF:

; 706  : 		case PF_R8G8B8:
; 707  : 			return D3DFMT_R8G8B8;

	mov	eax, 20					; 00000014H
	jmp	$LN36@fromPixelF
$LN23@fromPixelF:

; 708  : 		case PF_A8R8G8B8:
; 709  : 			return D3DFMT_A8R8G8B8;

	mov	eax, 21					; 00000015H
	jmp	$LN36@fromPixelF
$LN22@fromPixelF:

; 710  : 		case PF_A8B8G8R8:
; 711  : 			return D3DFMT_A8B8G8R8;

	mov	eax, 32					; 00000020H
	jmp	$LN36@fromPixelF
$LN21@fromPixelF:

; 712  : 		case PF_X8R8G8B8:
; 713  : 			return D3DFMT_X8R8G8B8;

	mov	eax, 22					; 00000016H
	jmp	$LN36@fromPixelF
$LN20@fromPixelF:

; 714  : 		case PF_X8B8G8R8:
; 715  : 			return D3DFMT_X8B8G8R8;

	mov	eax, 33					; 00000021H
	jmp	$LN36@fromPixelF
$LN19@fromPixelF:

; 716  : 		case PF_A2B10G10R10:
; 717  : 			return D3DFMT_A2B10G10R10;

	mov	eax, 31					; 0000001fH
	jmp	SHORT $LN36@fromPixelF
$LN18@fromPixelF:

; 718  : 		case PF_A2R10G10B10:
; 719  : 			return D3DFMT_A2R10G10B10;

	mov	eax, 35					; 00000023H
	jmp	SHORT $LN36@fromPixelF
$LN17@fromPixelF:

; 720  : 		case PF_FLOAT16_R:
; 721  : 			return D3DFMT_R16F;

	mov	eax, 111				; 0000006fH
	jmp	SHORT $LN36@fromPixelF
$LN16@fromPixelF:

; 722  : 		case PF_FLOAT16_GR:
; 723  : 			return D3DFMT_G16R16F;

	mov	eax, 112				; 00000070H
	jmp	SHORT $LN36@fromPixelF
$LN15@fromPixelF:

; 724  : 		case PF_FLOAT16_RGBA:
; 725  : 			return D3DFMT_A16B16G16R16F;

	mov	eax, 113				; 00000071H
	jmp	SHORT $LN36@fromPixelF
$LN14@fromPixelF:

; 726  : 		case PF_FLOAT32_R:
; 727  : 			return D3DFMT_R32F;

	mov	eax, 114				; 00000072H
	jmp	SHORT $LN36@fromPixelF
$LN13@fromPixelF:

; 728  : 		case PF_FLOAT32_GR:
; 729  : 			return D3DFMT_G32R32F;

	mov	eax, 115				; 00000073H
	jmp	SHORT $LN36@fromPixelF
$LN12@fromPixelF:

; 730  : 		case PF_FLOAT32_RGBA:
; 731  : 			return D3DFMT_A32B32G32R32F;

	mov	eax, 116				; 00000074H
	jmp	SHORT $LN36@fromPixelF
$LN11@fromPixelF:

; 732  : 		case PF_SHORT_RGBA:
; 733  : 			return D3DFMT_A16B16G16R16;

	mov	eax, 36					; 00000024H
	jmp	SHORT $LN36@fromPixelF
$LN10@fromPixelF:

; 734  : 		case PF_SHORT_GR:
; 735  : 			return D3DFMT_G16R16;

	mov	eax, 34					; 00000022H
	jmp	SHORT $LN36@fromPixelF
$LN9@fromPixelF:

; 736  : 		case PF_DXT1:
; 737  : 			return D3DFMT_DXT1;

	mov	eax, 827611204				; 31545844H
	jmp	SHORT $LN36@fromPixelF
$LN8@fromPixelF:

; 738  : 		case PF_DXT2:
; 739  : 			return D3DFMT_DXT2;

	mov	eax, 844388420				; 32545844H
	jmp	SHORT $LN36@fromPixelF
$LN7@fromPixelF:

; 740  : 		case PF_DXT3:
; 741  : 			return D3DFMT_DXT3;

	mov	eax, 861165636				; 33545844H
	jmp	SHORT $LN36@fromPixelF
$LN6@fromPixelF:

; 742  : 		case PF_DXT4:
; 743  : 			return D3DFMT_DXT4;

	mov	eax, 877942852				; 34545844H
	jmp	SHORT $LN36@fromPixelF
$LN5@fromPixelF:

; 744  : 		case PF_DXT5:
; 745  : 			return D3DFMT_DXT5;

	mov	eax, 894720068				; 35545844H
	jmp	SHORT $LN36@fromPixelF
$LN4@fromPixelF:

; 746  : 		case PF_D24X8:
; 747  : 			return D3DFMT_D24X8;

	mov	eax, 77					; 0000004dH
	jmp	SHORT $LN36@fromPixelF
$LN3@fromPixelF:

; 748  : 		case PF_D24S8:
; 749  : 			return D3DFMT_D24S8;

	mov	eax, 75					; 0000004bH
	jmp	SHORT $LN36@fromPixelF
$LN2@fromPixelF:

; 750  : 		case PF_D16:
; 751  : 			return D3DFMT_D16;

	mov	eax, 80					; 00000050H
	jmp	SHORT $LN36@fromPixelF
$LN1@fromPixelF:

; 752  : 		case PF_UNKNOWN:
; 753  : 		default:
; 754  : 			return D3DFMT_UNKNOWN;

	xor	eax, eax
$LN36@fromPixelF:

; 755  : 		}
; 756  : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
	npad	2
$LN38@fromPixelF:
	DD	$LN33@fromPixelF
	DD	$LN32@fromPixelF
	DD	$LN31@fromPixelF
	DD	$LN30@fromPixelF
	DD	$LN29@fromPixelF
	DD	$LN28@fromPixelF
	DD	$LN1@fromPixelF
	DD	$LN26@fromPixelF
	DD	$LN25@fromPixelF
	DD	$LN24@fromPixelF
	DD	$LN1@fromPixelF
	DD	$LN23@fromPixelF
	DD	$LN22@fromPixelF
	DD	$LN1@fromPixelF
	DD	$LN18@fromPixelF
	DD	$LN19@fromPixelF
	DD	$LN9@fromPixelF
	DD	$LN8@fromPixelF
	DD	$LN7@fromPixelF
	DD	$LN6@fromPixelF
	DD	$LN5@fromPixelF
	DD	$LN1@fromPixelF
	DD	$LN15@fromPixelF
	DD	$LN1@fromPixelF
	DD	$LN12@fromPixelF
	DD	$LN21@fromPixelF
	DD	$LN20@fromPixelF
	DD	$LN1@fromPixelF
	DD	$LN4@fromPixelF
	DD	$LN11@fromPixelF
	DD	$LN27@fromPixelF
	DD	$LN17@fromPixelF
	DD	$LN14@fromPixelF
	DD	$LN10@fromPixelF
	DD	$LN16@fromPixelF
	DD	$LN13@fromPixelF
	DD	$LN1@fromPixelF
	DD	$LN3@fromPixelF
	DD	$LN2@fromPixelF
?fromPixelFormat@D3D9RenderSystem@Ogre@@QAE?AW4_D3DFORMAT@@W4PixelFormat@2@@Z ENDP ; Ogre::D3D9RenderSystem::fromPixelFormat
_TEXT	ENDS
PUBLIC	?toPixelFormat@D3D9RenderSystem@Ogre@@QAE?AW4PixelFormat@2@W4_D3DFORMAT@@@Z ; Ogre::D3D9RenderSystem::toPixelFormat
; Function compile flags: /Odtp
_TEXT	SEGMENT
tv64 = -8						; size = 4
_this$ = -4						; size = 4
_d3dfmt$ = 8						; size = 4
?toPixelFormat@D3D9RenderSystem@Ogre@@QAE?AW4PixelFormat@2@W4_D3DFORMAT@@@Z PROC ; Ogre::D3D9RenderSystem::toPixelFormat
; _this$ = ecx

; 759  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 760  : 		switch(d3dfmt)

	mov	eax, DWORD PTR _d3dfmt$[ebp]
	mov	DWORD PTR tv64[ebp], eax
	cmp	DWORD PTR tv64[ebp], 827611204		; 31545844H
	jg	SHORT $LN38@toPixelFor
	cmp	DWORD PTR tv64[ebp], 827611204		; 31545844H
	je	$LN9@toPixelFor
	mov	ecx, DWORD PTR tv64[ebp]
	sub	ecx, 20					; 00000014H
	mov	DWORD PTR tv64[ebp], ecx
	cmp	DWORD PTR tv64[ebp], 96			; 00000060H
	ja	$LN1@toPixelFor
	mov	edx, DWORD PTR tv64[ebp]
	movzx	eax, BYTE PTR $LN40@toPixelFor[edx]
	jmp	DWORD PTR $LN41@toPixelFor[eax*4]
$LN38@toPixelFor:
	cmp	DWORD PTR tv64[ebp], 877942852		; 34545844H
	jg	SHORT $LN39@toPixelFor
	cmp	DWORD PTR tv64[ebp], 877942852		; 34545844H
	je	$LN6@toPixelFor
	cmp	DWORD PTR tv64[ebp], 844388420		; 32545844H
	je	$LN8@toPixelFor
	cmp	DWORD PTR tv64[ebp], 861165636		; 33545844H
	je	$LN7@toPixelFor
	jmp	$LN1@toPixelFor
$LN39@toPixelFor:
	cmp	DWORD PTR tv64[ebp], 894720068		; 35545844H
	je	$LN5@toPixelFor
	jmp	$LN1@toPixelFor
$LN33@toPixelFor:

; 761  : 		{
; 762  : 		case D3DFMT_L8:
; 763  : 			return PF_L8;

	mov	eax, 1
	jmp	$LN36@toPixelFor
$LN32@toPixelFor:

; 764  : 		case D3DFMT_L16:
; 765  : 			return PF_L16;

	mov	eax, 2
	jmp	$LN36@toPixelFor
$LN31@toPixelFor:

; 766  : 		case D3DFMT_A8:
; 767  : 			return PF_A8;

	mov	eax, 3
	jmp	$LN36@toPixelFor
$LN30@toPixelFor:

; 768  : 		case D3DFMT_A4L4:
; 769  : 			return PF_A4L4;

	mov	eax, 4
	jmp	$LN36@toPixelFor
$LN29@toPixelFor:

; 770  : 		case D3DFMT_A8L8:
; 771  : 			return PF_BYTE_LA; // Assume little endian here

	mov	eax, 5
	jmp	$LN36@toPixelFor
$LN28@toPixelFor:

; 772  : 		case D3DFMT_R3G3B2:
; 773  : 			return PF_R3G3B2;

	mov	eax, 31					; 0000001fH
	jmp	$LN36@toPixelFor
$LN27@toPixelFor:

; 774  : 		case D3DFMT_A1R5G5B5:
; 775  : 			return PF_A1R5G5B5;

	mov	eax, 9
	jmp	$LN36@toPixelFor
$LN26@toPixelFor:

; 776  : 		case D3DFMT_R5G6B5:
; 777  : 			return PF_R5G6B5;

	mov	eax, 6
	jmp	$LN36@toPixelFor
$LN25@toPixelFor:

; 778  : 		case D3DFMT_A4R4G4B4:
; 779  : 			return PF_A4R4G4B4;

	mov	eax, 8
	jmp	$LN36@toPixelFor
$LN24@toPixelFor:

; 780  : 		case D3DFMT_R8G8B8:
; 781  : 			return PF_R8G8B8;

	mov	eax, 10					; 0000000aH
	jmp	$LN36@toPixelFor
$LN23@toPixelFor:

; 782  : 		case D3DFMT_A8R8G8B8:
; 783  : 			return PF_A8R8G8B8;

	mov	eax, 12					; 0000000cH
	jmp	$LN36@toPixelFor
$LN22@toPixelFor:

; 784  : 		case D3DFMT_A8B8G8R8:
; 785  : 			return PF_A8B8G8R8;

	mov	eax, 13					; 0000000dH
	jmp	$LN36@toPixelFor
$LN21@toPixelFor:

; 786  : 		case D3DFMT_X8R8G8B8:
; 787  : 			return PF_X8R8G8B8;

	mov	eax, 26					; 0000001aH
	jmp	$LN36@toPixelFor
$LN20@toPixelFor:

; 788  : 		case D3DFMT_X8B8G8R8:
; 789  : 			return PF_X8B8G8R8;

	mov	eax, 27					; 0000001bH
	jmp	$LN36@toPixelFor
$LN19@toPixelFor:

; 790  : 		case D3DFMT_A2B10G10R10:
; 791  : 			return PF_A2B10G10R10;

	mov	eax, 16					; 00000010H
	jmp	SHORT $LN36@toPixelFor
$LN18@toPixelFor:

; 792  : 		case D3DFMT_A2R10G10B10:
; 793  : 			return PF_A2B10G10R10;

	mov	eax, 16					; 00000010H
	jmp	SHORT $LN36@toPixelFor
$LN17@toPixelFor:

; 794  : 		case D3DFMT_R16F:
; 795  : 			return PF_FLOAT16_R;

	mov	eax, 32					; 00000020H
	jmp	SHORT $LN36@toPixelFor
$LN16@toPixelFor:

; 796  : 		case D3DFMT_G16R16F:
; 797  : 			return PF_FLOAT16_GR;

	mov	eax, 35					; 00000023H
	jmp	SHORT $LN36@toPixelFor
$LN15@toPixelFor:

; 798  : 		case D3DFMT_A16B16G16R16F:
; 799  : 			return PF_FLOAT16_RGBA;

	mov	eax, 23					; 00000017H
	jmp	SHORT $LN36@toPixelFor
$LN14@toPixelFor:

; 800  : 		case D3DFMT_R32F:
; 801  : 			return PF_FLOAT32_R;

	mov	eax, 33					; 00000021H
	jmp	SHORT $LN36@toPixelFor
$LN13@toPixelFor:

; 802  : 		case D3DFMT_G32R32F:
; 803  : 			return PF_FLOAT32_GR;

	mov	eax, 36					; 00000024H
	jmp	SHORT $LN36@toPixelFor
$LN12@toPixelFor:

; 804  : 		case D3DFMT_A32B32G32R32F:
; 805  : 			return PF_FLOAT32_RGBA;

	mov	eax, 25					; 00000019H
	jmp	SHORT $LN36@toPixelFor
$LN11@toPixelFor:

; 806  : 		case D3DFMT_A16B16G16R16:
; 807  : 			return PF_SHORT_RGBA;

	mov	eax, 30					; 0000001eH
	jmp	SHORT $LN36@toPixelFor
$LN10@toPixelFor:

; 808  : 		case D3DFMT_G16R16:
; 809  : 			return PF_SHORT_GR;

	mov	eax, 34					; 00000022H
	jmp	SHORT $LN36@toPixelFor
$LN9@toPixelFor:

; 810  : 		case D3DFMT_DXT1:
; 811  : 			return PF_DXT1;

	mov	eax, 17					; 00000011H
	jmp	SHORT $LN36@toPixelFor
$LN8@toPixelFor:

; 812  : 		case D3DFMT_DXT2:
; 813  : 			return PF_DXT2;

	mov	eax, 18					; 00000012H
	jmp	SHORT $LN36@toPixelFor
$LN7@toPixelFor:

; 814  : 		case D3DFMT_DXT3:
; 815  : 			return PF_DXT3;

	mov	eax, 19					; 00000013H
	jmp	SHORT $LN36@toPixelFor
$LN6@toPixelFor:

; 816  : 		case D3DFMT_DXT4:
; 817  : 			return PF_DXT4;

	mov	eax, 20					; 00000014H
	jmp	SHORT $LN36@toPixelFor
$LN5@toPixelFor:

; 818  : 		case D3DFMT_DXT5:
; 819  : 			return PF_DXT5;

	mov	eax, 21					; 00000015H
	jmp	SHORT $LN36@toPixelFor
$LN4@toPixelFor:

; 820  : 		case D3DFMT_D24X8:
; 821  : 			return PF_D24X8;

	mov	eax, 29					; 0000001dH
	jmp	SHORT $LN36@toPixelFor
$LN3@toPixelFor:

; 822  : 		case D3DFMT_D24S8:
; 823  : 			return PF_D24S8;

	mov	eax, 38					; 00000026H
	jmp	SHORT $LN36@toPixelFor
$LN2@toPixelFor:

; 824  : 		case D3DFMT_D16:
; 825  : 			return PF_D16;

	mov	eax, 39					; 00000027H
	jmp	SHORT $LN36@toPixelFor
$LN1@toPixelFor:

; 826  : 		case D3DFMT_UNKNOWN:
; 827  : 		default:
; 828  : 			return PF_UNKNOWN;

	xor	eax, eax
$LN36@toPixelFor:

; 829  : 		}
; 830  : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
	npad	2
$LN41@toPixelFor:
	DD	$LN24@toPixelFor
	DD	$LN23@toPixelFor
	DD	$LN21@toPixelFor
	DD	$LN26@toPixelFor
	DD	$LN27@toPixelFor
	DD	$LN25@toPixelFor
	DD	$LN28@toPixelFor
	DD	$LN31@toPixelFor
	DD	$LN19@toPixelFor
	DD	$LN22@toPixelFor
	DD	$LN20@toPixelFor
	DD	$LN10@toPixelFor
	DD	$LN18@toPixelFor
	DD	$LN11@toPixelFor
	DD	$LN33@toPixelFor
	DD	$LN29@toPixelFor
	DD	$LN30@toPixelFor
	DD	$LN3@toPixelFor
	DD	$LN4@toPixelFor
	DD	$LN2@toPixelFor
	DD	$LN32@toPixelFor
	DD	$LN17@toPixelFor
	DD	$LN16@toPixelFor
	DD	$LN15@toPixelFor
	DD	$LN14@toPixelFor
	DD	$LN13@toPixelFor
	DD	$LN12@toPixelFor
	DD	$LN1@toPixelFor
$LN40@toPixelFor:
	DB	0
	DB	1
	DB	2
	DB	3
	DB	27					; 0000001bH
	DB	4
	DB	5
	DB	6
	DB	7
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	8
	DB	9
	DB	10					; 0000000aH
	DB	11					; 0000000bH
	DB	12					; 0000000cH
	DB	13					; 0000000dH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	14					; 0000000eH
	DB	15					; 0000000fH
	DB	16					; 00000010H
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	17					; 00000011H
	DB	27					; 0000001bH
	DB	18					; 00000012H
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	19					; 00000013H
	DB	20					; 00000014H
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	27					; 0000001bH
	DB	21					; 00000015H
	DB	22					; 00000016H
	DB	23					; 00000017H
	DB	24					; 00000018H
	DB	25					; 00000019H
	DB	26					; 0000001aH
?toPixelFormat@D3D9RenderSystem@Ogre@@QAE?AW4PixelFormat@2@W4_D3DFORMAT@@@Z ENDP ; Ogre::D3D9RenderSystem::toPixelFormat
_TEXT	ENDS
PUBLIC	?GetSettings@D3DEnumeration@Ogre@@QAEABUD3DSETTING_T@2@XZ ; Ogre::D3DEnumeration::GetSettings
PUBLIC	?isFormatSupported@D3D9RenderSystem@Ogre@@QAE_NW4_D3DFORMAT@@KW4_D3DRESOURCETYPE@@@Z ; Ogre::D3D9RenderSystem::isFormatSupported
; Function compile flags: /Odtp
_TEXT	SEGMENT
_this$ = -12						; size = 4
_setting$ = -8						; size = 4
_hr$ = -4						; size = 4
_format$ = 8						; size = 4
_usage$ = 12						; size = 4
_restype$ = 16						; size = 4
?isFormatSupported@D3D9RenderSystem@Ogre@@QAE_NW4_D3DFORMAT@@KW4_D3DRESOURCETYPE@@@Z PROC ; Ogre::D3D9RenderSystem::isFormatSupported
; _this$ = ecx

; 833  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 834  : 		const D3DSETTING_T &setting = m_pD3DEnum->GetSettings();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+420]
	call	?GetSettings@D3DEnumeration@Ogre@@QAEABUD3DSETTING_T@2@XZ ; Ogre::D3DEnumeration::GetSettings
	mov	DWORD PTR _setting$[ebp], eax

; 835  : 		HRESULT hr = m_pD3D->CheckDeviceFormat(setting.pdevcombo->iadapter, setting.pdevcombo->devtype,
; 836  : 			setting.pdevcombo->backbuffmt, usage, restype, format);

	mov	ecx, DWORD PTR _format$[ebp]
	push	ecx
	mov	edx, DWORD PTR _restype$[ebp]
	push	edx
	mov	eax, DWORD PTR _usage$[ebp]
	push	eax
	mov	ecx, DWORD PTR _setting$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _setting$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _setting$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+100]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+100]
	mov	edx, DWORD PTR [edx]
	push	ecx
	mov	eax, DWORD PTR [edx+40]
	call	eax
	mov	DWORD PTR _hr$[ebp], eax

; 837  : 
; 838  : 		return SUCCEEDED(hr);

	xor	eax, eax
	cmp	DWORD PTR _hr$[ebp], 0
	setge	al

; 839  : 	}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?isFormatSupported@D3D9RenderSystem@Ogre@@QAE_NW4_D3DFORMAT@@KW4_D3DRESOURCETYPE@@@Z ENDP ; Ogre::D3D9RenderSystem::isFormatSupported
; Function compile flags: /Odtp
; File i:\svnroot\client\plugins\rendersystem_d3d9\ogred3ddriverenum.h
_TEXT	ENDS
;	COMDAT ?GetSettings@D3DEnumeration@Ogre@@QAEABUD3DSETTING_T@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetSettings@D3DEnumeration@Ogre@@QAEABUD3DSETTING_T@2@XZ PROC ; Ogre::D3DEnumeration::GetSettings, COMDAT
; _this$ = ecx

; 88   : 		const D3DSETTING_T &GetSettings(){ return m_Settings; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 96					; 00000060H
	mov	esp, ebp
	pop	ebp
	ret	0
?GetSettings@D3DEnumeration@Ogre@@QAEABUD3DSETTING_T@2@XZ ENDP ; Ogre::D3DEnumeration::GetSettings
_TEXT	ENDS
PUBLIC	?isTargetFormatSupported@D3D9RenderSystem@Ogre@@QAE_NW4_D3DFORMAT@@0@Z ; Ogre::D3D9RenderSystem::isTargetFormatSupported
; Function compile flags: /Odtp
; File i:\svnroot\client\plugins\rendersystem_d3d9\ogred3d9rendersystem.cpp
_TEXT	SEGMENT
_this$ = -12						; size = 4
_setting$ = -8						; size = 4
_hr$ = -4						; size = 4
_colorformat$ = 8					; size = 4
_dsfmt$ = 12						; size = 4
?isTargetFormatSupported@D3D9RenderSystem@Ogre@@QAE_NW4_D3DFORMAT@@0@Z PROC ; Ogre::D3D9RenderSystem::isTargetFormatSupported
; _this$ = ecx

; 842  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 843  : 		const D3DSETTING_T &setting = m_pD3DEnum->GetSettings();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+420]
	call	?GetSettings@D3DEnumeration@Ogre@@QAEABUD3DSETTING_T@2@XZ ; Ogre::D3DEnumeration::GetSettings
	mov	DWORD PTR _setting$[ebp], eax

; 844  : 		HRESULT hr = m_pD3D->CheckDepthStencilMatch(setting.pdevcombo->iadapter, setting.pdevcombo->devtype,
; 845  : 			setting.pdevcombo->adapterfmt, colorformat, dsfmt);

	mov	ecx, DWORD PTR _dsfmt$[ebp]
	push	ecx
	mov	edx, DWORD PTR _colorformat$[ebp]
	push	edx
	mov	eax, DWORD PTR _setting$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	mov	eax, DWORD PTR _setting$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR _setting$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+100]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+100]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	mov	edx, DWORD PTR [ecx+48]
	call	edx
	mov	DWORD PTR _hr$[ebp], eax

; 846  : 
; 847  : 		return SUCCEEDED(hr);

	xor	eax, eax
	cmp	DWORD PTR _hr$[ebp], 0
	setge	al

; 848  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?isTargetFormatSupported@D3D9RenderSystem@Ogre@@QAE_NW4_D3DFORMAT@@0@Z ENDP ; Ogre::D3D9RenderSystem::isTargetFormatSupported
_TEXT	ENDS
PUBLIC	?isTargetMultiSampleSupported@D3D9RenderSystem@Ogre@@QAE_NW4_D3DFORMAT@@0W4_D3DMULTISAMPLE_TYPE@@@Z ; Ogre::D3D9RenderSystem::isTargetMultiSampleSupported
; Function compile flags: /Odtp
_TEXT	SEGMENT
_this$ = -12						; size = 4
_setting$ = -8						; size = 4
_hr$ = -4						; size = 4
_colorformat$ = 8					; size = 4
_dsfmt$ = 12						; size = 4
_mstype$ = 16						; size = 4
?isTargetMultiSampleSupported@D3D9RenderSystem@Ogre@@QAE_NW4_D3DFORMAT@@0W4_D3DMULTISAMPLE_TYPE@@@Z PROC ; Ogre::D3D9RenderSystem::isTargetMultiSampleSupported
; _this$ = ecx

; 851  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 852  : 		if(mstype == D3DMULTISAMPLE_NONE) return true;

	cmp	DWORD PTR _mstype$[ebp], 0
	jne	SHORT $LN3@isTargetMu
	mov	al, 1
	jmp	$LN4@isTargetMu
$LN3@isTargetMu:

; 853  : 
; 854  : 		const D3DSETTING_T &setting = m_pD3DEnum->GetSettings();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+420]
	call	?GetSettings@D3DEnumeration@Ogre@@QAEABUD3DSETTING_T@2@XZ ; Ogre::D3DEnumeration::GetSettings
	mov	DWORD PTR _setting$[ebp], eax

; 855  : 		HRESULT hr = m_pD3D->CheckDeviceMultiSampleType(setting.pdevcombo->iadapter, setting.pdevcombo->devtype,
; 856  : 			colorformat, setting.pdevcombo->iswindowed, mstype, NULL);

	push	0
	mov	ecx, DWORD PTR _mstype$[ebp]
	push	ecx
	mov	edx, DWORD PTR _setting$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR _colorformat$[ebp]
	push	edx
	mov	eax, DWORD PTR _setting$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR _setting$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+100]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+100]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	mov	edx, DWORD PTR [ecx+44]
	call	edx
	mov	DWORD PTR _hr$[ebp], eax

; 857  : 
; 858  : 		if(SUCCEEDED(hr))

	cmp	DWORD PTR _hr$[ebp], 0
	jl	SHORT $LN2@isTargetMu

; 859  : 		{
; 860  : 			hr = m_pD3D->CheckDeviceMultiSampleType(setting.pdevcombo->iadapter, setting.pdevcombo->devtype,
; 861  : 				dsfmt, setting.pdevcombo->iswindowed, mstype, NULL);

	push	0
	mov	eax, DWORD PTR _mstype$[ebp]
	push	eax
	mov	ecx, DWORD PTR _setting$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR _dsfmt$[ebp]
	push	ecx
	mov	edx, DWORD PTR _setting$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _setting$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+100]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+100]
	mov	eax, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR [eax+44]
	call	ecx
	mov	DWORD PTR _hr$[ebp], eax

; 862  : 			return SUCCEEDED(hr);

	xor	eax, eax
	cmp	DWORD PTR _hr$[ebp], 0
	setge	al
	jmp	SHORT $LN4@isTargetMu
	jmp	SHORT $LN4@isTargetMu
$LN2@isTargetMu:

; 863  : 		}
; 864  : 		else return false;

	xor	al, al
$LN4@isTargetMu:

; 865  : 	}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?isTargetMultiSampleSupported@D3D9RenderSystem@Ogre@@QAE_NW4_D3DFORMAT@@0W4_D3DMULTISAMPLE_TYPE@@@Z ENDP ; Ogre::D3D9RenderSystem::isTargetMultiSampleSupported
_TEXT	ENDS
PUBLIC	?getProperTargetDepthFormat@D3D9RenderSystem@Ogre@@QAE_NAAW4_D3DFORMAT@@W4_D3DMULTISAMPLE_TYPE@@W43@H@Z ; Ogre::D3D9RenderSystem::getProperTargetDepthFormat
; Function compile flags: /Odtp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_dsfmt$ = 8						; size = 4
_mstype$ = 12						; size = 4
_colorfmt$ = 16						; size = 4
_depthbits$ = 20					; size = 4
?getProperTargetDepthFormat@D3D9RenderSystem@Ogre@@QAE_NAAW4_D3DFORMAT@@W4_D3DMULTISAMPLE_TYPE@@W43@H@Z PROC ; Ogre::D3D9RenderSystem::getProperTargetDepthFormat
; _this$ = ecx

; 868  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 869  : 		dsfmt = D3DFMT_UNKNOWN;

	mov	eax, DWORD PTR _dsfmt$[ebp]
	mov	DWORD PTR [eax], 0
$LN14@getProperT:

; 870  : 		while(dsfmt == D3DFMT_UNKNOWN)

	mov	ecx, DWORD PTR _dsfmt$[ebp]
	cmp	DWORD PTR [ecx], 0
	jne	$LN13@getProperT

; 871  : 		{
; 872  : 			if(depthbits == 32)

	cmp	DWORD PTR _depthbits$[ebp], 32		; 00000020H
	jne	SHORT $LN12@getProperT

; 873  : 			{
; 874  : 				if(isTargetFormatSupported(colorfmt, D3DFMT_D32) && isTargetMultiSampleSupported(colorfmt, D3DFMT_D32, mstype)) dsfmt = D3DFMT_D32;

	push	71					; 00000047H
	mov	edx, DWORD PTR _colorfmt$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?isTargetFormatSupported@D3D9RenderSystem@Ogre@@QAE_NW4_D3DFORMAT@@0@Z ; Ogre::D3D9RenderSystem::isTargetFormatSupported
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN11@getProperT
	mov	ecx, DWORD PTR _mstype$[ebp]
	push	ecx
	push	71					; 00000047H
	mov	edx, DWORD PTR _colorfmt$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?isTargetMultiSampleSupported@D3D9RenderSystem@Ogre@@QAE_NW4_D3DFORMAT@@0W4_D3DMULTISAMPLE_TYPE@@@Z ; Ogre::D3D9RenderSystem::isTargetMultiSampleSupported
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN11@getProperT
	mov	ecx, DWORD PTR _dsfmt$[ebp]
	mov	DWORD PTR [ecx], 71			; 00000047H
	jmp	SHORT $LN10@getProperT
$LN11@getProperT:

; 875  : 				else depthbits = 24;

	mov	DWORD PTR _depthbits$[ebp], 24		; 00000018H
$LN10@getProperT:
	jmp	$LN9@getProperT
$LN12@getProperT:

; 876  : 			}
; 877  : 			else if(depthbits == 24)

	cmp	DWORD PTR _depthbits$[ebp], 24		; 00000018H
	jne	SHORT $LN8@getProperT

; 878  : 			{
; 879  : 				//if(isTargetFormatSupported(colorfmt, D3DFMT_D24X8) && isTargetMultiSampleSupported(colorfmt, D3DFMT_D24X8, mstype)) dsfmt = D3DFMT_D24X8;
; 880  : 				if(isTargetFormatSupported(colorfmt, D3DFMT_D24S8) && isTargetMultiSampleSupported(colorfmt, D3DFMT_D24S8, mstype)) dsfmt = D3DFMT_D24S8;

	push	75					; 0000004bH
	mov	edx, DWORD PTR _colorfmt$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?isTargetFormatSupported@D3D9RenderSystem@Ogre@@QAE_NW4_D3DFORMAT@@0@Z ; Ogre::D3D9RenderSystem::isTargetFormatSupported
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN7@getProperT
	mov	ecx, DWORD PTR _mstype$[ebp]
	push	ecx
	push	75					; 0000004bH
	mov	edx, DWORD PTR _colorfmt$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?isTargetMultiSampleSupported@D3D9RenderSystem@Ogre@@QAE_NW4_D3DFORMAT@@0W4_D3DMULTISAMPLE_TYPE@@@Z ; Ogre::D3D9RenderSystem::isTargetMultiSampleSupported
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN7@getProperT
	mov	ecx, DWORD PTR _dsfmt$[ebp]
	mov	DWORD PTR [ecx], 75			; 0000004bH
	jmp	SHORT $LN6@getProperT
$LN7@getProperT:

; 881  : 				else depthbits = 16;

	mov	DWORD PTR _depthbits$[ebp], 16		; 00000010H
$LN6@getProperT:
	jmp	SHORT $LN9@getProperT
$LN8@getProperT:

; 882  : 			}
; 883  : 			else if(depthbits == 16)

	cmp	DWORD PTR _depthbits$[ebp], 16		; 00000010H
	jne	SHORT $LN4@getProperT

; 884  : 			{
; 885  : 				if(isTargetFormatSupported(colorfmt, D3DFMT_D16) && isTargetMultiSampleSupported(colorfmt, D3DFMT_D16, mstype)) dsfmt = D3DFMT_D16;

	push	80					; 00000050H
	mov	edx, DWORD PTR _colorfmt$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?isTargetFormatSupported@D3D9RenderSystem@Ogre@@QAE_NW4_D3DFORMAT@@0@Z ; Ogre::D3D9RenderSystem::isTargetFormatSupported
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@getProperT
	mov	ecx, DWORD PTR _mstype$[ebp]
	push	ecx
	push	80					; 00000050H
	mov	edx, DWORD PTR _colorfmt$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?isTargetMultiSampleSupported@D3D9RenderSystem@Ogre@@QAE_NW4_D3DFORMAT@@0W4_D3DMULTISAMPLE_TYPE@@@Z ; Ogre::D3D9RenderSystem::isTargetMultiSampleSupported
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN3@getProperT
	mov	ecx, DWORD PTR _dsfmt$[ebp]
	mov	DWORD PTR [ecx], 80			; 00000050H
	jmp	SHORT $LN2@getProperT
$LN3@getProperT:

; 886  : 				else return false;

	xor	al, al
	jmp	SHORT $LN15@getProperT
$LN2@getProperT:
	jmp	SHORT $LN9@getProperT
$LN4@getProperT:

; 887  : 			}
; 888  : 			else return false;

	xor	al, al
	jmp	SHORT $LN15@getProperT
$LN9@getProperT:

; 889  : 		}

	jmp	$LN14@getProperT
$LN13@getProperT:

; 890  : 
; 891  : 		return true;

	mov	al, 1
$LN15@getProperT:

; 892  : 	}

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?getProperTargetDepthFormat@D3D9RenderSystem@Ogre@@QAE_NAAW4_D3DFORMAT@@W4_D3DMULTISAMPLE_TYPE@@W43@H@Z ENDP ; Ogre::D3D9RenderSystem::getProperTargetDepthFormat
_TEXT	ENDS
PUBLIC	?getProperTargetColorFormat@D3D9RenderSystem@Ogre@@QAE_NAAW4_D3DFORMAT@@W4_D3DMULTISAMPLE_TYPE@@W43@@Z ; Ogre::D3D9RenderSystem::getProperTargetColorFormat
; Function compile flags: /Odtp
_TEXT	SEGMENT
_this$ = -28						; size = 4
_i$152395 = -24						; size = 4
_fmts$ = -20						; size = 20
_colorfmt$ = 8						; size = 4
_mstype$ = 12						; size = 4
_dsfmt$ = 16						; size = 4
?getProperTargetColorFormat@D3D9RenderSystem@Ogre@@QAE_NAAW4_D3DFORMAT@@W4_D3DMULTISAMPLE_TYPE@@W43@@Z PROC ; Ogre::D3D9RenderSystem::getProperTargetColorFormat
; _this$ = ecx

; 895  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR _this$[ebp], ecx

; 896  : 		D3DFORMAT fmts[] = {D3DFMT_R5G6B5, D3DFMT_A8R8G8B8, D3DFMT_X8R8G8B8, D3DFMT_A8B8G8R8, D3DFMT_X8B8G8R8};

	mov	DWORD PTR _fmts$[ebp], 23		; 00000017H
	mov	DWORD PTR _fmts$[ebp+4], 21		; 00000015H
	mov	DWORD PTR _fmts$[ebp+8], 22		; 00000016H
	mov	DWORD PTR _fmts$[ebp+12], 32		; 00000020H
	mov	DWORD PTR _fmts$[ebp+16], 33		; 00000021H

; 897  : 		for(size_t i=0; i<ARRAY_ELEMENTS(fmts); i++)

	mov	DWORD PTR _i$152395[ebp], 0
	jmp	SHORT $LN4@getProperT@2
$LN3@getProperT@2:
	mov	eax, DWORD PTR _i$152395[ebp]
	add	eax, 1
	mov	DWORD PTR _i$152395[ebp], eax
$LN4@getProperT@2:
	cmp	DWORD PTR _i$152395[ebp], 5
	jae	SHORT $LN2@getProperT@2

; 898  : 		{
; 899  : 			if(isTargetFormatSupported(fmts[i], dsfmt) && isTargetMultiSampleSupported(fmts[i], dsfmt, mstype))

	mov	ecx, DWORD PTR _dsfmt$[ebp]
	push	ecx
	mov	edx, DWORD PTR _i$152395[ebp]
	mov	eax, DWORD PTR _fmts$[ebp+edx*4]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?isTargetFormatSupported@D3D9RenderSystem@Ogre@@QAE_NW4_D3DFORMAT@@0@Z ; Ogre::D3D9RenderSystem::isTargetFormatSupported
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@getProperT@2
	mov	edx, DWORD PTR _mstype$[ebp]
	push	edx
	mov	eax, DWORD PTR _dsfmt$[ebp]
	push	eax
	mov	ecx, DWORD PTR _i$152395[ebp]
	mov	edx, DWORD PTR _fmts$[ebp+ecx*4]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?isTargetMultiSampleSupported@D3D9RenderSystem@Ogre@@QAE_NW4_D3DFORMAT@@0W4_D3DMULTISAMPLE_TYPE@@@Z ; Ogre::D3D9RenderSystem::isTargetMultiSampleSupported
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@getProperT@2

; 900  : 			{
; 901  : 				colorfmt = fmts[i];

	mov	ecx, DWORD PTR _colorfmt$[ebp]
	mov	edx, DWORD PTR _i$152395[ebp]
	mov	eax, DWORD PTR _fmts$[ebp+edx*4]
	mov	DWORD PTR [ecx], eax

; 902  : 				return true;

	mov	al, 1
	jmp	SHORT $LN5@getProperT@2
$LN1@getProperT@2:

; 903  : 			}
; 904  : 		}

	jmp	SHORT $LN3@getProperT@2
$LN2@getProperT@2:

; 905  : 		return false;

	xor	al, al
$LN5@getProperT@2:

; 906  : 	}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?getProperTargetColorFormat@D3D9RenderSystem@Ogre@@QAE_NAAW4_D3DFORMAT@@W4_D3DMULTISAMPLE_TYPE@@W43@@Z ENDP ; Ogre::D3D9RenderSystem::getProperTargetColorFormat
_TEXT	ENDS
PUBLIC	?hbu2PoolUsage@D3D9RenderSystem@Ogre@@QAEXAAKAAW4_D3DPOOL@@W4HardwareBufferUsage@2@@Z ; Ogre::D3D9RenderSystem::hbu2PoolUsage
; Function compile flags: /Odtp
_TEXT	SEGMENT
tv64 = -8						; size = 4
_this$ = -4						; size = 4
_d3dusage$ = 8						; size = 4
_d3dpool$ = 12						; size = 4
_usage$ = 16						; size = 4
?hbu2PoolUsage@D3D9RenderSystem@Ogre@@QAEXAAKAAW4_D3DPOOL@@W4HardwareBufferUsage@2@@Z PROC ; Ogre::D3D9RenderSystem::hbu2PoolUsage
; _this$ = ecx

; 909  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 910  : 		switch(usage)

	mov	eax, DWORD PTR _usage$[ebp]
	mov	DWORD PTR tv64[ebp], eax
	cmp	DWORD PTR tv64[ebp], 5
	ja	SHORT $LN9@hbu2PoolUs
	mov	ecx, DWORD PTR tv64[ebp]
	jmp	DWORD PTR $LN11@hbu2PoolUs[ecx*4]
$LN6@hbu2PoolUs:

; 911  : 		{
; 912  : 		case HBU_STATIC:
; 913  : 		case HBU_OCCASION:
; 914  : 			d3dusage = 0;

	mov	edx, DWORD PTR _d3dusage$[ebp]
	mov	DWORD PTR [edx], 0

; 915  : 			d3dpool = D3DPOOL_MANAGED;

	mov	eax, DWORD PTR _d3dpool$[ebp]
	mov	DWORD PTR [eax], 1

; 916  : 			break;

	jmp	SHORT $LN9@hbu2PoolUs
$LN5@hbu2PoolUs:

; 917  : 
; 918  : 		case HBU_DYNAMIC:
; 919  : 			d3dusage = D3DUSAGE_DYNAMIC;

	mov	ecx, DWORD PTR _d3dusage$[ebp]
	mov	DWORD PTR [ecx], 512			; 00000200H

; 920  : 			d3dpool = D3DPOOL_DEFAULT;

	mov	edx, DWORD PTR _d3dpool$[ebp]
	mov	DWORD PTR [edx], 0

; 921  : 			break;

	jmp	SHORT $LN9@hbu2PoolUs
$LN4@hbu2PoolUs:

; 922  : 
; 923  : 		case HBU_RENDERTARGET:
; 924  : 			d3dusage = D3DUSAGE_RENDERTARGET;

	mov	eax, DWORD PTR _d3dusage$[ebp]
	mov	DWORD PTR [eax], 1

; 925  : 			d3dpool = D3DPOOL_DEFAULT;

	mov	ecx, DWORD PTR _d3dpool$[ebp]
	mov	DWORD PTR [ecx], 0

; 926  : 			break;

	jmp	SHORT $LN9@hbu2PoolUs
$LN3@hbu2PoolUs:

; 927  : 
; 928  : 		case HBU_DEPTHSTENCIL:
; 929  : 			d3dusage = D3DUSAGE_DEPTHSTENCIL;

	mov	edx, DWORD PTR _d3dusage$[ebp]
	mov	DWORD PTR [edx], 2

; 930  : 			d3dpool = D3DPOOL_DEFAULT;

	mov	eax, DWORD PTR _d3dpool$[ebp]
	mov	DWORD PTR [eax], 0

; 931  : 			break;

	jmp	SHORT $LN9@hbu2PoolUs
$LN2@hbu2PoolUs:

; 932  : 
; 933  : 		case HBU_ONLYCPU:
; 934  : 			d3dusage = 0;

	mov	ecx, DWORD PTR _d3dusage$[ebp]
	mov	DWORD PTR [ecx], 0

; 935  : 			d3dpool = D3DPOOL_SCRATCH;

	mov	edx, DWORD PTR _d3dpool$[ebp]
	mov	DWORD PTR [edx], 3
$LN9@hbu2PoolUs:

; 936  : 			break;
; 937  : 
; 938  : 		default:
; 939  : 			assert(0);
; 940  : 			break;
; 941  : 		}
; 942  : 	}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
	npad	1
$LN11@hbu2PoolUs:
	DD	$LN6@hbu2PoolUs
	DD	$LN6@hbu2PoolUs
	DD	$LN5@hbu2PoolUs
	DD	$LN3@hbu2PoolUs
	DD	$LN4@hbu2PoolUs
	DD	$LN2@hbu2PoolUs
?hbu2PoolUsage@D3D9RenderSystem@Ogre@@QAEXAAKAAW4_D3DPOOL@@W4HardwareBufferUsage@2@@Z ENDP ; Ogre::D3D9RenderSystem::hbu2PoolUsage
_TEXT	ENDS
PUBLIC	?createTexture@D3D9RenderSystem@Ogre@@QAEPAUIDirect3DBaseTexture9@@W4_D3DRESOURCETYPE@@W4_D3DFORMAT@@KW4_D3DPOOL@@IIII@Z ; Ogre::D3D9RenderSystem::createTexture
; Function compile flags: /Odtp
_TEXT	SEGMENT
tv64 = -20						; size = 4
_this$ = -16						; size = 4
_ptexture$152441 = -12					; size = 4
_ptexture$152437 = -8					; size = 4
_ptexture$152433 = -4					; size = 4
_restype$ = 8						; size = 4
_format$ = 12						; size = 4
_usage$ = 16						; size = 4
_pool$ = 20						; size = 4
_width$ = 24						; size = 4
_height$ = 28						; size = 4
_depth$ = 32						; size = 4
_miplevels$ = 36					; size = 4
?createTexture@D3D9RenderSystem@Ogre@@QAEPAUIDirect3DBaseTexture9@@W4_D3DRESOURCETYPE@@W4_D3DFORMAT@@KW4_D3DPOOL@@IIII@Z PROC ; Ogre::D3D9RenderSystem::createTexture
; _this$ = ecx

; 945  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 946  : 		switch(restype)

	mov	eax, DWORD PTR _restype$[ebp]
	mov	DWORD PTR tv64[ebp], eax
	cmp	DWORD PTR tv64[ebp], 3
	je	SHORT $LN7@createText
	cmp	DWORD PTR tv64[ebp], 4
	je	$LN3@createText
	cmp	DWORD PTR tv64[ebp], 5
	je	SHORT $LN5@createText
	jmp	$LN8@createText
$LN7@createText:

; 947  : 		{
; 948  : 		case D3DRTYPE_TEXTURE:
; 949  : 			{
; 950  : 				IDirect3DTexture9 *ptexture = NULL;

	mov	DWORD PTR _ptexture$152433[ebp], 0

; 951  : 				if(SUCCEEDED(m_pd3dDevice->CreateTexture(width, height, miplevels, usage, format, pool, &ptexture, NULL)))

	push	0
	lea	ecx, DWORD PTR _ptexture$152433[ebp]
	push	ecx
	mov	edx, DWORD PTR _pool$[ebp]
	push	edx
	mov	eax, DWORD PTR _format$[ebp]
	push	eax
	mov	ecx, DWORD PTR _usage$[ebp]
	push	ecx
	mov	edx, DWORD PTR _miplevels$[ebp]
	push	edx
	mov	eax, DWORD PTR _height$[ebp]
	push	eax
	mov	ecx, DWORD PTR _width$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+104]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+104]
	mov	eax, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR [eax+92]
	call	ecx
	test	eax, eax
	jl	SHORT $LN6@createText

; 952  : 				{
; 953  : 					return ptexture;

	mov	eax, DWORD PTR _ptexture$152433[ebp]
	jmp	$LN10@createText
$LN6@createText:

; 954  : 				}
; 955  : 			}
; 956  : 			break;

	jmp	$LN8@createText
$LN5@createText:

; 957  : 
; 958  : 		case D3DRTYPE_CUBETEXTURE:
; 959  : 			{
; 960  : 				IDirect3DCubeTexture9 *ptexture = NULL;

	mov	DWORD PTR _ptexture$152437[ebp], 0

; 961  : 				if(SUCCEEDED(m_pd3dDevice->CreateCubeTexture(width, miplevels, usage, format, pool, &ptexture, NULL )))

	push	0
	lea	edx, DWORD PTR _ptexture$152437[ebp]
	push	edx
	mov	eax, DWORD PTR _pool$[ebp]
	push	eax
	mov	ecx, DWORD PTR _format$[ebp]
	push	ecx
	mov	edx, DWORD PTR _usage$[ebp]
	push	edx
	mov	eax, DWORD PTR _miplevels$[ebp]
	push	eax
	mov	ecx, DWORD PTR _width$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+104]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+104]
	mov	eax, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR [eax+100]
	call	ecx
	test	eax, eax
	jl	SHORT $LN4@createText

; 962  : 				{
; 963  : 					return ptexture;

	mov	eax, DWORD PTR _ptexture$152437[ebp]
	jmp	SHORT $LN10@createText
$LN4@createText:

; 964  : 				}
; 965  : 			}
; 966  : 			break;

	jmp	SHORT $LN8@createText
$LN3@createText:

; 967  : 
; 968  : 		case D3DRTYPE_VOLUMETEXTURE:
; 969  : 			{
; 970  : 				IDirect3DVolumeTexture9 *ptexture = NULL;

	mov	DWORD PTR _ptexture$152441[ebp], 0

; 971  : 				if(SUCCEEDED(m_pd3dDevice->CreateVolumeTexture(width, height, depth, miplevels, usage, format, pool, &ptexture, NULL)))

	push	0
	lea	edx, DWORD PTR _ptexture$152441[ebp]
	push	edx
	mov	eax, DWORD PTR _pool$[ebp]
	push	eax
	mov	ecx, DWORD PTR _format$[ebp]
	push	ecx
	mov	edx, DWORD PTR _usage$[ebp]
	push	edx
	mov	eax, DWORD PTR _miplevels$[ebp]
	push	eax
	mov	ecx, DWORD PTR _depth$[ebp]
	push	ecx
	mov	edx, DWORD PTR _height$[ebp]
	push	edx
	mov	eax, DWORD PTR _width$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+104]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+104]
	mov	edx, DWORD PTR [edx]
	push	ecx
	mov	eax, DWORD PTR [edx+96]
	call	eax
	test	eax, eax
	jl	SHORT $LN8@createText

; 972  : 				{
; 973  : 					return ptexture;

	mov	eax, DWORD PTR _ptexture$152441[ebp]
	jmp	SHORT $LN10@createText
$LN8@createText:

; 974  : 				}
; 975  : 			}
; 976  : 			break;
; 977  : 
; 978  : 		default:
; 979  : 			assert(0);
; 980  : 			break;
; 981  : 		}
; 982  : 
; 983  : 		return NULL;

	xor	eax, eax
$LN10@createText:

; 984  : 	}

	mov	esp, ebp
	pop	ebp
	ret	32					; 00000020H
?createTexture@D3D9RenderSystem@Ogre@@QAEPAUIDirect3DBaseTexture9@@W4_D3DRESOURCETYPE@@W4_D3DFORMAT@@KW4_D3DPOOL@@IIII@Z ENDP ; Ogre::D3D9RenderSystem::createTexture
_TEXT	ENDS
PUBLIC	?lockOpt2D3DFlags@D3D9RenderSystem@Ogre@@QAEKW4HardwareBufferLockOpt@2@K@Z ; Ogre::D3D9RenderSystem::lockOpt2D3DFlags
; Function compile flags: /Odtp
_TEXT	SEGMENT
tv64 = -12						; size = 4
_this$ = -8						; size = 4
_flags$ = -4						; size = 4
_lockopt$ = 8						; size = 4
_d3dusage$ = 12						; size = 4
?lockOpt2D3DFlags@D3D9RenderSystem@Ogre@@QAEKW4HardwareBufferLockOpt@2@K@Z PROC ; Ogre::D3D9RenderSystem::lockOpt2D3DFlags
; _this$ = ecx

; 987  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 988  : 		DWORD flags = 0;

	mov	DWORD PTR _flags$[ebp], 0

; 989  : 		switch(lockopt)

	mov	eax, DWORD PTR _lockopt$[ebp]
	mov	DWORD PTR tv64[ebp], eax
	cmp	DWORD PTR tv64[ebp], 1
	je	SHORT $LN6@lockOpt2D3
	cmp	DWORD PTR tv64[ebp], 2
	je	SHORT $LN4@lockOpt2D3
	cmp	DWORD PTR tv64[ebp], 3
	je	SHORT $LN3@lockOpt2D3
	jmp	SHORT $LN8@lockOpt2D3

; 990  : 		{
; 991  : 		case HBL_NORMAL:
; 992  : 			break;

	jmp	SHORT $LN8@lockOpt2D3
$LN6@lockOpt2D3:

; 993  : 
; 994  : 		case HBL_DISCARD:
; 995  : 			if(d3dusage & D3DUSAGE_DYNAMIC) flags |= D3DLOCK_DISCARD;

	mov	ecx, DWORD PTR _d3dusage$[ebp]
	and	ecx, 512				; 00000200H
	je	SHORT $LN5@lockOpt2D3
	mov	edx, DWORD PTR _flags$[ebp]
	or	edx, 8192				; 00002000H
	mov	DWORD PTR _flags$[ebp], edx
$LN5@lockOpt2D3:

; 996  : 			break;

	jmp	SHORT $LN8@lockOpt2D3
$LN4@lockOpt2D3:

; 997  : 
; 998  : 		case HBL_READ_ONLY:
; 999  : 			flags |= D3DLOCK_READONLY;

	mov	eax, DWORD PTR _flags$[ebp]
	or	eax, 16					; 00000010H
	mov	DWORD PTR _flags$[ebp], eax

; 1000 : 			break;

	jmp	SHORT $LN8@lockOpt2D3
$LN3@lockOpt2D3:

; 1001 : 
; 1002 : 		case HBL_NO_OVERWRITE:
; 1003 : 			if(d3dusage & D3DUSAGE_DYNAMIC) flags |= D3DLOCK_NOOVERWRITE;

	mov	ecx, DWORD PTR _d3dusage$[ebp]
	and	ecx, 512				; 00000200H
	je	SHORT $LN8@lockOpt2D3
	mov	edx, DWORD PTR _flags$[ebp]
	or	edx, 4096				; 00001000H
	mov	DWORD PTR _flags$[ebp], edx
$LN8@lockOpt2D3:

; 1004 : 			break;
; 1005 : 
; 1006 : 		default:
; 1007 : 			assert(0);
; 1008 : 			break;
; 1009 : 		}
; 1010 : 		return flags;

	mov	eax, DWORD PTR _flags$[ebp]

; 1011 : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?lockOpt2D3DFlags@D3D9RenderSystem@Ogre@@QAEKW4HardwareBufferLockOpt@2@K@Z ENDP ; Ogre::D3D9RenderSystem::lockOpt2D3DFlags
_TEXT	ENDS
PUBLIC	??$_snprintf_s@$0BAA@@@YAHAAY0BAA@DIPBDZZ	; _snprintf_s<256>
PUBLIC	__$ArrayPad$
PUBLIC	?Open@MyShaderInclude@Ogre@@UAGJW4_D3DXINCLUDE_TYPE@@PBDPBXPAPBXPAI@Z ; Ogre::MyShaderInclude::Open
EXTRN	__imp__malloc:PROC
EXTRN	__imp_?openFileStream@ResourceManager@Ogre@@QAEPAVDataStream@2@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z:PROC
EXTRN	__imp_?getSingleton@?$Singleton@VResourceManager@Ogre@@@Ogre@@SAAAVResourceManager@2@XZ:PROC
xdata$x	SEGMENT
__unwindtable$?Open@MyShaderInclude@Ogre@@UAGJW4_D3DXINCLUDE_TYPE@@PBDPBXPAPBXPAI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Open@MyShaderInclude@Ogre@@UAGJW4_D3DXINCLUDE_TYPE@@PBDPBXPAPBXPAI@Z$0
__ehfuncinfo$?Open@MyShaderInclude@Ogre@@UAGJW4_D3DXINCLUDE_TYPE@@PBDPBXPAPBXPAI@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?Open@MyShaderInclude@Ogre@@UAGJW4_D3DXINCLUDE_TYPE@@PBDPBXPAPBXPAI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
_TEXT	SEGMENT
$T159812 = -312						; size = 28
_flen$152501 = -284					; size = 4
_pdata$152502 = -280					; size = 4
_fullpath$ = -276					; size = 256
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
_IncludeType$ = 12					; size = 4
_pFileName$ = 16					; size = 4
_pParentData$ = 20					; size = 4
_ppData$ = 24						; size = 4
_pBytes$ = 28						; size = 4
?Open@MyShaderInclude@Ogre@@UAGJW4_D3DXINCLUDE_TYPE@@PBDPBXPAPBXPAI@Z PROC ; Ogre::MyShaderInclude::Open

; 1024 : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?Open@MyShaderInclude@Ogre@@UAGJW4_D3DXINCLUDE_TYPE@@PBDPBXPAPBXPAI@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 300				; 0000012cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1025 : 		char fullpath[256];
; 1026 : 		_snprintf_s(fullpath,sizeof(fullpath), "%s%s", OGRE_SHADER_PATH, pFileName);

	mov	eax, DWORD PTR _pFileName$[ebp]
	push	eax
	push	OFFSET $SG152497
	push	OFFSET $SG152498
	push	256					; 00000100H
	lea	ecx, DWORD PTR _fullpath$[ebp]
	push	ecx
	call	??$_snprintf_s@$0BAA@@@YAHAAY0BAA@DIPBDZZ ; _snprintf_s<256>
	add	esp, 20					; 00000014H

; 1027 : 		m_FP = ResourceManager::getSingleton().openFileStream(fullpath, true);

	lea	edx, DWORD PTR _fullpath$[ebp]
	push	edx
	lea	ecx, DWORD PTR $T159812[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	push	1
	lea	eax, DWORD PTR $T159812[ebp]
	push	eax
	call	DWORD PTR __imp_?getSingleton@?$Singleton@VResourceManager@Ogre@@@Ogre@@SAAAVResourceManager@2@XZ
	mov	ecx, eax
	call	DWORD PTR __imp_?openFileStream@ResourceManager@Ogre@@QAEPAVDataStream@2@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T159812[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1028 : 		if(m_FP)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+4], 0
	je	$LN2@Open

; 1029 : 		{
; 1030 : 			size_t flen = m_FP->size();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, eax
	mov	eax, DWORD PTR [edx+44]
	call	eax
	mov	DWORD PTR _flen$152501[ebp], eax

; 1031 : 			void *pdata = malloc(flen);

	mov	ecx, DWORD PTR _flen$152501[ebp]
	push	ecx
	call	DWORD PTR __imp__malloc
	add	esp, 4
	mov	DWORD PTR _pdata$152502[ebp], eax

; 1032 : 			m_FP->read(pdata, flen);

	mov	edx, DWORD PTR _flen$152501[ebp]
	push	edx
	mov	eax, DWORD PTR _pdata$152502[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [edx]
	mov	eax, DWORD PTR [edx+4]
	call	eax

; 1033 : 
; 1034 : 			*pBytes = (UINT)m_FP->size();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [edx]
	mov	eax, DWORD PTR [edx+44]
	call	eax
	mov	ecx, DWORD PTR _pBytes$[ebp]
	mov	DWORD PTR [ecx], eax

; 1035 : 			*ppData = m_FP->getMemoryImage();

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [edx+52]
	call	eax
	mov	ecx, DWORD PTR _ppData$[ebp]
	mov	DWORD PTR [ecx], eax

; 1036 : 		}
; 1037 : 		else

	jmp	SHORT $LN1@Open
$LN2@Open:

; 1038 : 		{
; 1039 : 			*pBytes = 0;

	mov	edx, DWORD PTR _pBytes$[ebp]
	mov	DWORD PTR [edx], 0

; 1040 : 			*ppData = NULL;

	mov	eax, DWORD PTR _ppData$[ebp]
	mov	DWORD PTR [eax], 0
$LN1@Open:

; 1041 : 		}
; 1042 : 
; 1043 : 		return S_OK;

	xor	eax, eax

; 1044 : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?Open@MyShaderInclude@Ogre@@UAGJW4_D3DXINCLUDE_TYPE@@PBDPBXPAPBXPAI@Z$0:
	lea	ecx, DWORD PTR $T159812[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?Open@MyShaderInclude@Ogre@@UAGJW4_D3DXINCLUDE_TYPE@@PBDPBXPAPBXPAI@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-304]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?Open@MyShaderInclude@Ogre@@UAGJW4_D3DXINCLUDE_TYPE@@PBDPBXPAPBXPAI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?Open@MyShaderInclude@Ogre@@UAGJW4_D3DXINCLUDE_TYPE@@PBDPBXPAPBXPAI@Z ENDP ; Ogre::MyShaderInclude::Open
PUBLIC	?Close@MyShaderInclude@Ogre@@UAGJPBX@Z		; Ogre::MyShaderInclude::Close
; Function compile flags: /Odtp
_TEXT	SEGMENT
tv71 = -12						; size = 4
$T159820 = -8						; size = 4
$T159819 = -4						; size = 4
_this$ = 8						; size = 4
_pData$ = 12						; size = 4
?Close@MyShaderInclude@Ogre@@UAGJPBX@Z PROC		; Ogre::MyShaderInclude::Close

; 1047 : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 1048 : 		delete m_FP;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T159820[ebp], ecx
	mov	edx, DWORD PTR $T159820[ebp]
	mov	DWORD PTR $T159819[ebp], edx
	cmp	DWORD PTR $T159819[ebp], 0
	je	SHORT $LN3@Close
	push	1
	mov	eax, DWORD PTR $T159819[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR $T159819[ebp]
	mov	eax, DWORD PTR [edx]
	call	eax
	mov	DWORD PTR tv71[ebp], eax
	jmp	SHORT $LN4@Close
$LN3@Close:
	mov	DWORD PTR tv71[ebp], 0
$LN4@Close:

; 1049 : 
; 1050 : 		return S_OK;

	xor	eax, eax

; 1051 : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?Close@MyShaderInclude@Ogre@@UAGJPBX@Z ENDP		; Ogre::MyShaderInclude::Close
_TEXT	ENDS
PUBLIC	??0MyShaderInclude@Ogre@@QAE@XZ			; Ogre::MyShaderInclude::MyShaderInclude
PUBLIC	__$ArrayPad$
PUBLIC	?compileCode@D3D9RenderSystem@Ogre@@QAEPAUID3DXBuffer@@PBDIPBU_D3DXMACRO@@00PAPAUID3DXConstantTable@@@Z ; Ogre::D3D9RenderSystem::compileCode
EXTRN	__imp__GetCurrentDirectoryA@8:PROC
EXTRN	__imp__fclose:PROC
EXTRN	__imp__fwrite:PROC
EXTRN	__imp__fopen_s:PROC
EXTRN	_D3DXCompileShader@40:PROC
EXTRN	_D3DXCreateEffectCompiler@28:PROC
xdata$x	SEGMENT
__unwindtable$?compileCode@D3D9RenderSystem@Ogre@@QAEPAUID3DXBuffer@@PBDIPBU_D3DXMACRO@@00PAPAUID3DXConstantTable@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?compileCode@D3D9RenderSystem@Ogre@@QAEPAUID3DXBuffer@@PBDIPBU_D3DXMACRO@@00PAPAUID3DXConstantTable@@@Z$0
__ehfuncinfo$?compileCode@D3D9RenderSystem@Ogre@@QAEPAUID3DXBuffer@@PBDIPBU_D3DXMACRO@@00PAPAUID3DXConstantTable@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?compileCode@D3D9RenderSystem@Ogre@@QAEPAUID3DXBuffer@@PBDIPBU_D3DXMACRO@@00PAPAUID3DXConstantTable@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
_TEXT	SEGMENT
tv170 = -356						; size = 4
_this$ = -352						; size = 4
$T159827 = -348						; size = 4
$T159826 = -344						; size = 4
$T159825 = -340						; size = 28
_err$152554 = -312					; size = 4
_curdir$152564 = -308					; size = 256
__$ArrayPad$ = -52					; size = 4
_fp$152553 = -48					; size = 4
_fp$152531 = -44					; size = 4
_myincl$ = -40						; size = 8
_hr$ = -32						; size = 4
_perrorbuf$ = -28					; size = 4
_pcompiler$ = -24					; size = 4
_flags$ = -20						; size = 4
_pcompiledbuf$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_pbuffer$ = 8						; size = 4
_buflen$ = 12						; size = 4
_pmacros$ = 16						; size = 4
_funcname$ = 20						; size = 4
_profile$ = 24						; size = 4
_ppconst$ = 28						; size = 4
?compileCode@D3D9RenderSystem@Ogre@@QAEPAUID3DXBuffer@@PBDIPBU_D3DXMACRO@@00PAPAUID3DXConstantTable@@@Z PROC ; Ogre::D3D9RenderSystem::compileCode
; _this$ = ecx

; 1054 : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?compileCode@D3D9RenderSystem@Ogre@@QAEPAUID3DXBuffer@@PBDIPBU_D3DXMACRO@@00PAPAUID3DXConstantTable@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 344				; 00000158H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1055 : 		DWORD flags = 0;

	mov	DWORD PTR _flags$[ebp], 0

; 1056 : 
; 1057 : 		if(m_bDebugVS || m_bDebugPS)

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+516]
	test	ecx, ecx
	jne	SHORT $LN15@compileCod
	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+517]
	test	eax, eax
	je	SHORT $LN16@compileCod
$LN15@compileCod:

; 1058 : 		{
; 1059 : 			flags |= D3DXSHADER_DEBUG|D3DXSHADER_SKIPOPTIMIZATION;

	mov	ecx, DWORD PTR _flags$[ebp]
	or	ecx, 5
	mov	DWORD PTR _flags$[ebp], ecx
$LN16@compileCod:

; 1060 : 			//if(m_pRS->m_bDebugVS) flags |= D3DXSHADER_FORCE_VS_SOFTWARE_NOOPT;
; 1061 : 			//if(m_pRS->m_bDebugPS) flags |= D3DXSHADER_FORCE_PS_SOFTWARE_NOOPT;
; 1062 : 		}
; 1063 : 
; 1064 : 		ID3DXBuffer *pcompiledbuf = NULL;

	mov	DWORD PTR _pcompiledbuf$[ebp], 0

; 1065 : 		ID3DXBuffer *perrorbuf = NULL;

	mov	DWORD PTR _perrorbuf$[ebp], 0

; 1066 : 		HRESULT hr;
; 1067 : 		ID3DXEffectCompiler *pcompiler = NULL;

	mov	DWORD PTR _pcompiler$[ebp], 0

; 1068 : 		MyShaderInclude myincl;

	lea	ecx, DWORD PTR _myincl$[ebp]
	call	??0MyShaderInclude@Ogre@@QAE@XZ

; 1069 : 
; 1070 : 		if(buflen == 0)

	cmp	DWORD PTR _buflen$[ebp], 0
	jne	$LN14@compileCod

; 1071 : 		{
; 1072 : #ifdef LOAD_DEBUG_SHADER
; 1073 : 			if(funcname == NULL) hr = D3DXCreateEffectCompilerFromFile(pbuffer, pmacros, NULL, flags, &pcompiler, &perrorbuf);
; 1074 : 			else hr =D3DXCompileShaderFromFile(pbuffer, pmacros, NULL, funcname, profile, flags, &pcompiledbuf, &perrorbuf, ppconst);
; 1075 : 
; 1076 : #else
; 1077 : 			DataStream *fp = ResourceManager::getSingleton().openFileStream(pbuffer, true);

	mov	edx, DWORD PTR _pbuffer$[ebp]
	push	edx
	lea	ecx, DWORD PTR $T159825[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	push	1
	lea	eax, DWORD PTR $T159825[ebp]
	push	eax
	call	DWORD PTR __imp_?getSingleton@?$Singleton@VResourceManager@Ogre@@@Ogre@@SAAAVResourceManager@2@XZ
	mov	ecx, eax
	call	DWORD PTR __imp_?openFileStream@ResourceManager@Ogre@@QAEPAVDataStream@2@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z
	mov	DWORD PTR _fp$152531[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T159825[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 1078 : 			if(fp == NULL)

	cmp	DWORD PTR _fp$152531[ebp], 0
	jne	SHORT $LN13@compileCod

; 1079 : 			{
; 1080 : 				LOG_SEVERE("Open shader file failed: %s", pbuffer);

	push	8
	push	1080					; 00000438H
	push	OFFSET $SG152534
	call	DWORD PTR __imp_?LogSetCurParam@Ogre@@YAXPBDHI@Z
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR _pbuffer$[ebp]
	push	ecx
	push	OFFSET $SG152535
	call	DWORD PTR __imp_?LogMessage@Ogre@@YAXPBDZZ
	add	esp, 8

; 1081 : 				return false;

	xor	eax, eax
	jmp	$LN17@compileCod
$LN13@compileCod:

; 1082 : 			}
; 1083 : 
; 1084 : 			if(funcname == NULL) hr = D3DXCreateEffectCompiler((LPCSTR)fp->getMemoryImage(), (UINT)fp->size(), pmacros, &myincl, flags, &pcompiler, &perrorbuf);

	cmp	DWORD PTR _funcname$[ebp], 0
	jne	SHORT $LN12@compileCod
	lea	edx, DWORD PTR _perrorbuf$[ebp]
	push	edx
	lea	eax, DWORD PTR _pcompiler$[ebp]
	push	eax
	mov	ecx, DWORD PTR _flags$[ebp]
	push	ecx
	lea	edx, DWORD PTR _myincl$[ebp]
	push	edx
	mov	eax, DWORD PTR _pmacros$[ebp]
	push	eax
	mov	ecx, DWORD PTR _fp$152531[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _fp$152531[ebp]
	mov	eax, DWORD PTR [edx+44]
	call	eax
	push	eax
	mov	ecx, DWORD PTR _fp$152531[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _fp$152531[ebp]
	mov	eax, DWORD PTR [edx+52]
	call	eax
	push	eax
	call	_D3DXCreateEffectCompiler@28
	mov	DWORD PTR _hr$[ebp], eax
	jmp	SHORT $LN11@compileCod
$LN12@compileCod:

; 1085 : 			else hr = D3DXCompileShader((LPCSTR)fp->getMemoryImage(), (UINT)fp->size(), pmacros, &myincl, funcname, profile, flags, &pcompiledbuf, &perrorbuf, ppconst);

	mov	ecx, DWORD PTR _ppconst$[ebp]
	push	ecx
	lea	edx, DWORD PTR _perrorbuf$[ebp]
	push	edx
	lea	eax, DWORD PTR _pcompiledbuf$[ebp]
	push	eax
	mov	ecx, DWORD PTR _flags$[ebp]
	push	ecx
	mov	edx, DWORD PTR _profile$[ebp]
	push	edx
	mov	eax, DWORD PTR _funcname$[ebp]
	push	eax
	lea	ecx, DWORD PTR _myincl$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pmacros$[ebp]
	push	edx
	mov	eax, DWORD PTR _fp$152531[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _fp$152531[ebp]
	mov	eax, DWORD PTR [edx+44]
	call	eax
	push	eax
	mov	ecx, DWORD PTR _fp$152531[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _fp$152531[ebp]
	mov	eax, DWORD PTR [edx+52]
	call	eax
	push	eax
	call	_D3DXCompileShader@40
	mov	DWORD PTR _hr$[ebp], eax
$LN11@compileCod:

; 1086 : 
; 1087 : 			delete fp;

	mov	ecx, DWORD PTR _fp$152531[ebp]
	mov	DWORD PTR $T159827[ebp], ecx
	mov	edx, DWORD PTR $T159827[ebp]
	mov	DWORD PTR $T159826[ebp], edx
	cmp	DWORD PTR $T159826[ebp], 0
	je	SHORT $LN19@compileCod
	push	1
	mov	eax, DWORD PTR $T159826[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR $T159826[ebp]
	mov	eax, DWORD PTR [edx]
	call	eax
	mov	DWORD PTR tv170[ebp], eax
	jmp	SHORT $LN20@compileCod
$LN19@compileCod:
	mov	DWORD PTR tv170[ebp], 0
$LN20@compileCod:

; 1088 : #endif
; 1089 : 		}
; 1090 : 		else

	jmp	SHORT $LN10@compileCod
$LN14@compileCod:

; 1091 : 		{
; 1092 : 			if(funcname == NULL) hr = D3DXCreateEffectCompiler(pbuffer, (UINT)buflen, pmacros, &myincl, flags, &pcompiler, &perrorbuf);

	cmp	DWORD PTR _funcname$[ebp], 0
	jne	SHORT $LN9@compileCod
	lea	ecx, DWORD PTR _perrorbuf$[ebp]
	push	ecx
	lea	edx, DWORD PTR _pcompiler$[ebp]
	push	edx
	mov	eax, DWORD PTR _flags$[ebp]
	push	eax
	lea	ecx, DWORD PTR _myincl$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pmacros$[ebp]
	push	edx
	mov	eax, DWORD PTR _buflen$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pbuffer$[ebp]
	push	ecx
	call	_D3DXCreateEffectCompiler@28
	mov	DWORD PTR _hr$[ebp], eax
	jmp	SHORT $LN10@compileCod
$LN9@compileCod:

; 1093 : 			else hr = D3DXCompileShader(pbuffer, (UINT)buflen, pmacros, &myincl, funcname, profile, flags, &pcompiledbuf, &perrorbuf, ppconst);

	mov	edx, DWORD PTR _ppconst$[ebp]
	push	edx
	lea	eax, DWORD PTR _perrorbuf$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pcompiledbuf$[ebp]
	push	ecx
	mov	edx, DWORD PTR _flags$[ebp]
	push	edx
	mov	eax, DWORD PTR _profile$[ebp]
	push	eax
	mov	ecx, DWORD PTR _funcname$[ebp]
	push	ecx
	lea	edx, DWORD PTR _myincl$[ebp]
	push	edx
	mov	eax, DWORD PTR _pmacros$[ebp]
	push	eax
	mov	ecx, DWORD PTR _buflen$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pbuffer$[ebp]
	push	edx
	call	_D3DXCompileShader@40
	mov	DWORD PTR _hr$[ebp], eax
$LN10@compileCod:

; 1094 : 		}
; 1095 : 
; 1096 : 		if(funcname==NULL && SUCCEEDED(hr))

	cmp	DWORD PTR _funcname$[ebp], 0
	jne	SHORT $LN7@compileCod
	cmp	DWORD PTR _hr$[ebp], 0
	jl	SHORT $LN7@compileCod

; 1097 : 		{
; 1098 : 			hr = pcompiler->CompileEffect(flags, &pcompiledbuf, &perrorbuf);

	lea	eax, DWORD PTR _perrorbuf$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pcompiledbuf$[ebp]
	push	ecx
	mov	edx, DWORD PTR _flags$[ebp]
	push	edx
	mov	eax, DWORD PTR _pcompiler$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _pcompiler$[ebp]
	push	edx
	mov	eax, DWORD PTR [ecx+236]
	call	eax
	mov	DWORD PTR _hr$[ebp], eax

; 1099 : 			pcompiler->Release();

	mov	ecx, DWORD PTR _pcompiler$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _pcompiler$[ebp]
	push	eax
	mov	ecx, DWORD PTR [edx+8]
	call	ecx
$LN7@compileCod:

; 1100 : 		}
; 1101 : 
; 1102 : 		if(FAILED(hr))

	cmp	DWORD PTR _hr$[ebp], 0
	jge	$LN6@compileCod

; 1103 : 		{
; 1104 : #ifdef _LOG_FX_COMPILE_ERROR
; 1105 : 			FILE *fp;
; 1106 : 			errno_t err;
; 1107 : 			if(buflen != 0)

	cmp	DWORD PTR _buflen$[ebp], 0
	je	SHORT $LN5@compileCod

; 1108 : 			{
; 1109 : 				err = fopen_s(&fp,"log/error.fx", "wb");

	push	OFFSET $SG152556
	push	OFFSET $SG152557
	lea	edx, DWORD PTR _fp$152553[ebp]
	push	edx
	call	DWORD PTR __imp__fopen_s
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _err$152554[ebp], eax

; 1110 : 				if( !err && fp )

	cmp	DWORD PTR _err$152554[ebp], 0
	jne	SHORT $LN5@compileCod
	cmp	DWORD PTR _fp$152553[ebp], 0
	je	SHORT $LN5@compileCod

; 1111 : 				{
; 1112 : 					fwrite(pbuffer, buflen, 1, fp);

	mov	eax, DWORD PTR _fp$152553[ebp]
	push	eax
	push	1
	mov	ecx, DWORD PTR _buflen$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pbuffer$[ebp]
	push	edx
	call	DWORD PTR __imp__fwrite
	add	esp, 16					; 00000010H

; 1113 : 					fclose(fp);

	mov	eax, DWORD PTR _fp$152553[ebp]
	push	eax
	call	DWORD PTR __imp__fclose
	add	esp, 4
$LN5@compileCod:

; 1114 : 				}
; 1115 : 			}
; 1116 : 
; 1117 : 			if(perrorbuf)

	cmp	DWORD PTR _perrorbuf$[ebp], 0
	je	SHORT $LN3@compileCod

; 1118 : 			{
; 1119 : 				err = fopen_s(&fp,"log/fx_error.txt", "wb");

	push	OFFSET $SG152560
	push	OFFSET $SG152561
	lea	ecx, DWORD PTR _fp$152553[ebp]
	push	ecx
	call	DWORD PTR __imp__fopen_s
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _err$152554[ebp], eax

; 1120 : 				if( !err && fp )

	cmp	DWORD PTR _err$152554[ebp], 0
	jne	SHORT $LN3@compileCod
	cmp	DWORD PTR _fp$152553[ebp], 0
	je	SHORT $LN3@compileCod

; 1121 : 				{
; 1122 : 					fwrite(perrorbuf->GetBufferPointer(), perrorbuf->GetBufferSize(), 1, fp);

	mov	edx, DWORD PTR _fp$152553[ebp]
	push	edx
	push	1
	mov	eax, DWORD PTR _perrorbuf$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _perrorbuf$[ebp]
	push	edx
	mov	eax, DWORD PTR [ecx+16]
	call	eax
	push	eax
	mov	ecx, DWORD PTR _perrorbuf$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _perrorbuf$[ebp]
	push	eax
	mov	ecx, DWORD PTR [edx+12]
	call	ecx
	push	eax
	call	DWORD PTR __imp__fwrite
	add	esp, 16					; 00000010H

; 1123 : 					fwrite("\n", 1, 1, fp);

	mov	edx, DWORD PTR _fp$152553[ebp]
	push	edx
	push	1
	push	1
	push	OFFSET $SG152563
	call	DWORD PTR __imp__fwrite
	add	esp, 16					; 00000010H

; 1124 : 					fclose(fp);

	mov	eax, DWORD PTR _fp$152553[ebp]
	push	eax
	call	DWORD PTR __imp__fclose
	add	esp, 4
$LN3@compileCod:

; 1125 : 				}
; 1126 : 			}
; 1127 : #endif 
; 1128 : 			char curdir[256];
; 1129 : 			::GetCurrentDirectory(255, curdir);

	lea	ecx, DWORD PTR _curdir$152564[ebp]
	push	ecx
	push	255					; 000000ffH
	call	DWORD PTR __imp__GetCurrentDirectoryA@8

; 1130 : 			assert(0);
; 1131 : 			return NULL;

	xor	eax, eax
	jmp	SHORT $LN17@compileCod
$LN6@compileCod:

; 1132 : 		}
; 1133 : 
; 1134 : 		SAFE_RELEASE(perrorbuf);

	cmp	DWORD PTR _perrorbuf$[ebp], 0
	je	SHORT $LN1@compileCod
	mov	edx, DWORD PTR _perrorbuf$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _perrorbuf$[ebp]
	push	ecx
	mov	edx, DWORD PTR [eax+8]
	call	edx
	mov	DWORD PTR _perrorbuf$[ebp], 0
$LN1@compileCod:

; 1135 : 		return pcompiledbuf;

	mov	eax, DWORD PTR _pcompiledbuf$[ebp]
$LN17@compileCod:

; 1136 : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?compileCode@D3D9RenderSystem@Ogre@@QAEPAUID3DXBuffer@@PBDIPBU_D3DXMACRO@@00PAPAUID3DXConstantTable@@@Z$0:
	lea	ecx, DWORD PTR $T159825[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?compileCode@D3D9RenderSystem@Ogre@@QAEPAUID3DXBuffer@@PBDIPBU_D3DXMACRO@@00PAPAUID3DXConstantTable@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-348]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-40]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?compileCode@D3D9RenderSystem@Ogre@@QAEPAUID3DXBuffer@@PBDIPBU_D3DXMACRO@@00PAPAUID3DXConstantTable@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?compileCode@D3D9RenderSystem@Ogre@@QAEPAUID3DXBuffer@@PBDIPBU_D3DXMACRO@@00PAPAUID3DXConstantTable@@@Z ENDP ; Ogre::D3D9RenderSystem::compileCode
PUBLIC	??_7MyShaderInclude@Ogre@@6B@			; Ogre::MyShaderInclude::`vftable'
PUBLIC	??0ID3DXInclude@@QAE@XZ				; ID3DXInclude::ID3DXInclude
PUBLIC	??_R4MyShaderInclude@Ogre@@6B@			; Ogre::MyShaderInclude::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVMyShaderInclude@Ogre@@@8		; Ogre::MyShaderInclude `RTTI Type Descriptor'
PUBLIC	??_R3MyShaderInclude@Ogre@@8			; Ogre::MyShaderInclude::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2MyShaderInclude@Ogre@@8			; Ogre::MyShaderInclude::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@MyShaderInclude@Ogre@@8		; Ogre::MyShaderInclude::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@ID3DXInclude@@8			; ID3DXInclude::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AUID3DXInclude@@@8			; ID3DXInclude `RTTI Type Descriptor'
PUBLIC	??_R3ID3DXInclude@@8				; ID3DXInclude::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2ID3DXInclude@@8				; ID3DXInclude::`RTTI Base Class Array'
;	COMDAT ??_R2ID3DXInclude@@8
rdata$r	SEGMENT
??_R2ID3DXInclude@@8 DD FLAT:??_R1A@?0A@EA@ID3DXInclude@@8 ; ID3DXInclude::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3ID3DXInclude@@8
rdata$r	SEGMENT
??_R3ID3DXInclude@@8 DD 00H				; ID3DXInclude::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2ID3DXInclude@@8
rdata$r	ENDS
;	COMDAT ??_R0?AUID3DXInclude@@@8
_DATA	SEGMENT
??_R0?AUID3DXInclude@@@8 DD FLAT:??_7type_info@@6B@	; ID3DXInclude `RTTI Type Descriptor'
	DD	00H
	DB	'.?AUID3DXInclude@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@ID3DXInclude@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@ID3DXInclude@@8 DD FLAT:??_R0?AUID3DXInclude@@@8 ; ID3DXInclude::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3ID3DXInclude@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@MyShaderInclude@Ogre@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@MyShaderInclude@Ogre@@8 DD FLAT:??_R0?AVMyShaderInclude@Ogre@@@8 ; Ogre::MyShaderInclude::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3MyShaderInclude@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R2MyShaderInclude@Ogre@@8
rdata$r	SEGMENT
??_R2MyShaderInclude@Ogre@@8 DD FLAT:??_R1A@?0A@EA@MyShaderInclude@Ogre@@8 ; Ogre::MyShaderInclude::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@ID3DXInclude@@8
rdata$r	ENDS
;	COMDAT ??_R3MyShaderInclude@Ogre@@8
rdata$r	SEGMENT
??_R3MyShaderInclude@Ogre@@8 DD 00H			; Ogre::MyShaderInclude::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2MyShaderInclude@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVMyShaderInclude@Ogre@@@8
_DATA	SEGMENT
??_R0?AVMyShaderInclude@Ogre@@@8 DD FLAT:??_7type_info@@6B@ ; Ogre::MyShaderInclude `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVMyShaderInclude@Ogre@@', 00H
_DATA	ENDS
;	COMDAT ??_R4MyShaderInclude@Ogre@@6B@
rdata$r	SEGMENT
??_R4MyShaderInclude@Ogre@@6B@ DD 00H			; Ogre::MyShaderInclude::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVMyShaderInclude@Ogre@@@8
	DD	FLAT:??_R3MyShaderInclude@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_7MyShaderInclude@Ogre@@6B@
CONST	SEGMENT
??_7MyShaderInclude@Ogre@@6B@ DD FLAT:??_R4MyShaderInclude@Ogre@@6B@ ; Ogre::MyShaderInclude::`vftable'
	DD	FLAT:?Open@MyShaderInclude@Ogre@@UAGJW4_D3DXINCLUDE_TYPE@@PBDPBXPAPBXPAI@Z
	DD	FLAT:?Close@MyShaderInclude@Ogre@@UAGJPBX@Z
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ??0MyShaderInclude@Ogre@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0MyShaderInclude@Ogre@@QAE@XZ PROC			; Ogre::MyShaderInclude::MyShaderInclude, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0ID3DXInclude@@QAE@XZ
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7MyShaderInclude@Ogre@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0MyShaderInclude@Ogre@@QAE@XZ ENDP			; Ogre::MyShaderInclude::MyShaderInclude
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0ID3DXInclude@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0ID3DXInclude@@QAE@XZ PROC				; ID3DXInclude::ID3DXInclude, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0ID3DXInclude@@QAE@XZ ENDP				; ID3DXInclude::ID3DXInclude
_TEXT	ENDS
PUBLIC	?createD3DXEffect@D3D9RenderSystem@Ogre@@QAEPAUID3DXEffect@@PAUID3DXBuffer@@@Z ; Ogre::D3D9RenderSystem::createD3DXEffect
EXTRN	_D3DXCreateEffect@36:PROC
; Function compile flags: /Odtp
_TEXT	SEGMENT
_this$ = -12						; size = 4
_hr$ = -8						; size = 4
_peffect$ = -4						; size = 4
_pcompiledbuf$ = 8					; size = 4
?createD3DXEffect@D3D9RenderSystem@Ogre@@QAEPAUID3DXEffect@@PAUID3DXBuffer@@@Z PROC ; Ogre::D3D9RenderSystem::createD3DXEffect
; _this$ = ecx

; 1139 : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 1140 : 		ID3DXEffect *peffect = NULL;

	mov	DWORD PTR _peffect$[ebp], 0

; 1141 : 		HRESULT hr = D3DXCreateEffect(m_pd3dDevice, pcompiledbuf->GetBufferPointer(), pcompiledbuf->GetBufferSize(), NULL, NULL, 0, NULL, &peffect, NULL);

	push	0
	lea	eax, DWORD PTR _peffect$[ebp]
	push	eax
	push	0
	push	0
	push	0
	push	0
	mov	ecx, DWORD PTR _pcompiledbuf$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _pcompiledbuf$[ebp]
	push	eax
	mov	ecx, DWORD PTR [edx+16]
	call	ecx
	push	eax
	mov	edx, DWORD PTR _pcompiledbuf$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _pcompiledbuf$[ebp]
	push	ecx
	mov	edx, DWORD PTR [eax+12]
	call	edx
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+104]
	push	ecx
	call	_D3DXCreateEffect@36
	mov	DWORD PTR _hr$[ebp], eax

; 1142 : 		if(SUCCEEDED(hr)) return peffect;

	cmp	DWORD PTR _hr$[ebp], 0
	jl	SHORT $LN2@createD3DX
	mov	eax, DWORD PTR _peffect$[ebp]
	jmp	SHORT $LN3@createD3DX
	jmp	SHORT $LN3@createD3DX
$LN2@createD3DX:

; 1143 : 		else return NULL;

	xor	eax, eax
$LN3@createD3DX:

; 1144 : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
?createD3DXEffect@D3D9RenderSystem@Ogre@@QAEPAUID3DXEffect@@PAUID3DXBuffer@@@Z ENDP ; Ogre::D3D9RenderSystem::createD3DXEffect
_TEXT	ENDS
PUBLIC	?createVertexShader@D3D9RenderSystem@Ogre@@QAEPAUIDirect3DVertexShader9@@PAUID3DXBuffer@@@Z ; Ogre::D3D9RenderSystem::createVertexShader
; Function compile flags: /Odtp
_TEXT	SEGMENT
_this$ = -12						; size = 4
_hr$ = -8						; size = 4
_pvs$ = -4						; size = 4
_pcompiledbuf$ = 8					; size = 4
?createVertexShader@D3D9RenderSystem@Ogre@@QAEPAUIDirect3DVertexShader9@@PAUID3DXBuffer@@@Z PROC ; Ogre::D3D9RenderSystem::createVertexShader
; _this$ = ecx

; 1147 : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 1148 : 		IDirect3DVertexShader9 *pvs = NULL;

	mov	DWORD PTR _pvs$[ebp], 0

; 1149 : 		HRESULT hr = m_pd3dDevice->CreateVertexShader((const DWORD *)pcompiledbuf->GetBufferPointer(), &pvs);

	lea	eax, DWORD PTR _pvs$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pcompiledbuf$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _pcompiledbuf$[ebp]
	push	eax
	mov	ecx, DWORD PTR [edx+12]
	call	ecx
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+104]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+104]
	mov	eax, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR [eax+364]
	call	ecx
	mov	DWORD PTR _hr$[ebp], eax

; 1150 : 		if(SUCCEEDED(hr)) return pvs;

	cmp	DWORD PTR _hr$[ebp], 0
	jl	SHORT $LN2@createVert
	mov	eax, DWORD PTR _pvs$[ebp]
	jmp	SHORT $LN3@createVert
	jmp	SHORT $LN3@createVert
$LN2@createVert:

; 1151 : 		else return NULL;

	xor	eax, eax
$LN3@createVert:

; 1152 : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
?createVertexShader@D3D9RenderSystem@Ogre@@QAEPAUIDirect3DVertexShader9@@PAUID3DXBuffer@@@Z ENDP ; Ogre::D3D9RenderSystem::createVertexShader
_TEXT	ENDS
PUBLIC	?createPixelShader@D3D9RenderSystem@Ogre@@QAEPAUIDirect3DPixelShader9@@PAUID3DXBuffer@@@Z ; Ogre::D3D9RenderSystem::createPixelShader
; Function compile flags: /Odtp
_TEXT	SEGMENT
_this$ = -12						; size = 4
_hr$ = -8						; size = 4
_pps$ = -4						; size = 4
_pcompiledbuf$ = 8					; size = 4
?createPixelShader@D3D9RenderSystem@Ogre@@QAEPAUIDirect3DPixelShader9@@PAUID3DXBuffer@@@Z PROC ; Ogre::D3D9RenderSystem::createPixelShader
; _this$ = ecx

; 1155 : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 1156 : 		IDirect3DPixelShader9 *pps = NULL;

	mov	DWORD PTR _pps$[ebp], 0

; 1157 : 		HRESULT hr = m_pd3dDevice->CreatePixelShader((const DWORD *)pcompiledbuf->GetBufferPointer(), &pps);

	lea	eax, DWORD PTR _pps$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pcompiledbuf$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _pcompiledbuf$[ebp]
	push	eax
	mov	ecx, DWORD PTR [edx+12]
	call	ecx
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+104]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+104]
	mov	eax, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR [eax+424]
	call	ecx
	mov	DWORD PTR _hr$[ebp], eax

; 1158 : 		if(SUCCEEDED(hr)) return pps;

	cmp	DWORD PTR _hr$[ebp], 0
	jl	SHORT $LN2@createPixe
	mov	eax, DWORD PTR _pps$[ebp]
	jmp	SHORT $LN3@createPixe
	jmp	SHORT $LN3@createPixe
$LN2@createPixe:

; 1159 : 		else return NULL;

	xor	eax, eax
$LN3@createPixe:

; 1160 : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
?createPixelShader@D3D9RenderSystem@Ogre@@QAEPAUIDirect3DPixelShader9@@PAUID3DXBuffer@@@Z ENDP ; Ogre::D3D9RenderSystem::createPixelShader
_TEXT	ENDS
PUBLIC	?createD3DXEffect@D3D9RenderSystem@Ogre@@QAEPAUID3DXEffect@@PAXI@Z ; Ogre::D3D9RenderSystem::createD3DXEffect
; Function compile flags: /Odtp
_TEXT	SEGMENT
_this$ = -12						; size = 4
_hr$ = -8						; size = 4
_peffect$ = -4						; size = 4
_pcompiledbuf$ = 8					; size = 4
_bufferSize$ = 12					; size = 4
?createD3DXEffect@D3D9RenderSystem@Ogre@@QAEPAUID3DXEffect@@PAXI@Z PROC ; Ogre::D3D9RenderSystem::createD3DXEffect
; _this$ = ecx

; 1163 : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 1164 : 		ID3DXEffect *peffect = NULL;

	mov	DWORD PTR _peffect$[ebp], 0

; 1165 : 		HRESULT hr = D3DXCreateEffect(m_pd3dDevice, pcompiledbuf, bufferSize, NULL, NULL, 0, NULL, &peffect, NULL);

	push	0
	lea	eax, DWORD PTR _peffect$[ebp]
	push	eax
	push	0
	push	0
	push	0
	push	0
	mov	ecx, DWORD PTR _bufferSize$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pcompiledbuf$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+104]
	push	ecx
	call	_D3DXCreateEffect@36
	mov	DWORD PTR _hr$[ebp], eax

; 1166 : 		if(SUCCEEDED(hr)) return peffect;

	cmp	DWORD PTR _hr$[ebp], 0
	jl	SHORT $LN2@createD3DX@2
	mov	eax, DWORD PTR _peffect$[ebp]
	jmp	SHORT $LN3@createD3DX@2
	jmp	SHORT $LN3@createD3DX@2
$LN2@createD3DX@2:

; 1167 : 		else return NULL;

	xor	eax, eax
$LN3@createD3DX@2:

; 1168 : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?createD3DXEffect@D3D9RenderSystem@Ogre@@QAEPAUID3DXEffect@@PAXI@Z ENDP ; Ogre::D3D9RenderSystem::createD3DXEffect
_TEXT	ENDS
PUBLIC	?createVertexShader@D3D9RenderSystem@Ogre@@QAEPAUIDirect3DVertexShader9@@PAXI@Z ; Ogre::D3D9RenderSystem::createVertexShader
; Function compile flags: /Odtp
_TEXT	SEGMENT
_this$ = -12						; size = 4
_hr$ = -8						; size = 4
_pvs$ = -4						; size = 4
_pcompiledbuf$ = 8					; size = 4
_bufferSize$ = 12					; size = 4
?createVertexShader@D3D9RenderSystem@Ogre@@QAEPAUIDirect3DVertexShader9@@PAXI@Z PROC ; Ogre::D3D9RenderSystem::createVertexShader
; _this$ = ecx

; 1171 : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 1172 : 		IDirect3DVertexShader9 *pvs = NULL;

	mov	DWORD PTR _pvs$[ebp], 0

; 1173 : 		HRESULT hr = m_pd3dDevice->CreateVertexShader((const DWORD *)pcompiledbuf, &pvs);

	lea	eax, DWORD PTR _pvs$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pcompiledbuf$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+104]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+104]
	mov	eax, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR [eax+364]
	call	ecx
	mov	DWORD PTR _hr$[ebp], eax

; 1174 : 		if(SUCCEEDED(hr)) return pvs;

	cmp	DWORD PTR _hr$[ebp], 0
	jl	SHORT $LN2@createVert@2
	mov	eax, DWORD PTR _pvs$[ebp]
	jmp	SHORT $LN3@createVert@2
	jmp	SHORT $LN3@createVert@2
$LN2@createVert@2:

; 1175 : 		else return NULL;

	xor	eax, eax
$LN3@createVert@2:

; 1176 : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?createVertexShader@D3D9RenderSystem@Ogre@@QAEPAUIDirect3DVertexShader9@@PAXI@Z ENDP ; Ogre::D3D9RenderSystem::createVertexShader
_TEXT	ENDS
PUBLIC	?createPixelShader@D3D9RenderSystem@Ogre@@QAEPAUIDirect3DPixelShader9@@PAXI@Z ; Ogre::D3D9RenderSystem::createPixelShader
; Function compile flags: /Odtp
_TEXT	SEGMENT
_this$ = -12						; size = 4
_hr$ = -8						; size = 4
_pps$ = -4						; size = 4
_pcompiledbuf$ = 8					; size = 4
_bufferSize$ = 12					; size = 4
?createPixelShader@D3D9RenderSystem@Ogre@@QAEPAUIDirect3DPixelShader9@@PAXI@Z PROC ; Ogre::D3D9RenderSystem::createPixelShader
; _this$ = ecx

; 1179 : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 1180 : 		IDirect3DPixelShader9 *pps = NULL;

	mov	DWORD PTR _pps$[ebp], 0

; 1181 : 		HRESULT hr = m_pd3dDevice->CreatePixelShader((const DWORD *)pcompiledbuf, &pps);

	lea	eax, DWORD PTR _pps$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pcompiledbuf$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+104]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+104]
	mov	eax, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR [eax+424]
	call	ecx
	mov	DWORD PTR _hr$[ebp], eax

; 1182 : 		if(SUCCEEDED(hr)) return pps;

	cmp	DWORD PTR _hr$[ebp], 0
	jl	SHORT $LN2@createPixe@2
	mov	eax, DWORD PTR _pps$[ebp]
	jmp	SHORT $LN3@createPixe@2
	jmp	SHORT $LN3@createPixe@2
$LN2@createPixe@2:

; 1183 : 		else return NULL;

	xor	eax, eax
$LN3@createPixe@2:

; 1184 : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?createPixelShader@D3D9RenderSystem@Ogre@@QAEPAUIDirect3DPixelShader9@@PAXI@Z ENDP ; Ogre::D3D9RenderSystem::createPixelShader
_TEXT	ENDS
EXTRN	__imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z:PROC
; Function compile flags: /Odtp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_szSavePath$ = 8					; size = 4
?snapShotAll@D3D9RenderSystem@Ogre@@UAEXPBD@Z PROC	; Ogre::D3D9RenderSystem::snapShotAll
; _this$ = ecx

; 1187 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1188 : 		m_strSnapShotPath = szSavePath;

	mov	eax, DWORD PTR _szSavePath$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 64					; 00000040H
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 1189 : 		m_bSnapShot = true;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+44], 1

; 1190 : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
?snapShotAll@D3D9RenderSystem@Ogre@@UAEXPBD@Z ENDP	; Ogre::D3D9RenderSystem::snapShotAll
_TEXT	ENDS
EXTRN	_D3DXSaveSurfaceToFileA@20:PROC
; Function compile flags: /Odtp
_TEXT	SEGMENT
_this$ = -12						; size = 4
_pBackSurface$152640 = -8				; size = 4
_isFail$152646 = -1					; size = 1
?snapShot@D3D9RenderSystem@Ogre@@UAEXXZ PROC		; Ogre::D3D9RenderSystem::snapShot
; _this$ = ecx

; 1193 : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 1194 : 		if( m_bSnapShot )

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+44]
	test	ecx, ecx
	je	$LN5@snapShot

; 1195 : 		{
; 1196 : 			IDirect3DSurface9*	pBackSurface = NULL;

	mov	DWORD PTR _pBackSurface$152640[ebp], 0

; 1197 : 			if( FAILED( m_pd3dDevice->GetRenderTarget( 0, &pBackSurface ) ) )

	lea	edx, DWORD PTR _pBackSurface$152640[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+104]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+104]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	mov	edx, DWORD PTR [ecx+152]
	call	edx
	test	eax, eax
	jge	SHORT $LN3@snapShot

; 1198 : 			{
; 1199 : 				if ( pBackSurface != NULL )

	cmp	DWORD PTR _pBackSurface$152640[ebp], 0
	je	SHORT $LN2@snapShot

; 1200 : 				{
; 1201 : 					LOG_PRIVATE( "D3D9RenderSystem::setViewport--GetRenderTarget--获取了RenderTarget，但是没释放--1200" );

	push	64					; 00000040H
	push	1201					; 000004b1H
	push	OFFSET $SG152644
	call	DWORD PTR __imp_?LogSetCurParam@Ogre@@YAXPBDHI@Z
	add	esp, 12					; 0000000cH
	push	OFFSET $SG152645
	call	DWORD PTR __imp_?LogMessage@Ogre@@YAXPBDZZ
	add	esp, 4
$LN2@snapShot:

; 1202 : 				}
; 1203 : 				m_bSnapShot = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+44], 0

; 1204 : 				return;

	jmp	SHORT $LN5@snapShot
$LN3@snapShot:

; 1205 : 			}
; 1206 : 
; 1207 : 			bool isFail = FAILED( D3DXSaveSurfaceToFile( m_strSnapShotPath.c_str(), D3DXIFF_JPG, pBackSurface, NULL, NULL ) );

	push	0
	push	0
	mov	ecx, DWORD PTR _pBackSurface$152640[ebp]
	push	ecx
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 64					; 00000040H
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	call	_D3DXSaveSurfaceToFileA@20
	xor	edx, edx
	test	eax, eax
	setl	dl
	mov	BYTE PTR _isFail$152646[ebp], dl

; 1208 : 			m_bSnapShot = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+44], 0

; 1209 : 			SAFE_RELEASE( pBackSurface );

	cmp	DWORD PTR _pBackSurface$152640[ebp], 0
	je	SHORT $LN5@snapShot
	mov	ecx, DWORD PTR _pBackSurface$152640[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _pBackSurface$152640[ebp]
	push	eax
	mov	ecx, DWORD PTR [edx+8]
	call	ecx
	mov	DWORD PTR _pBackSurface$152640[ebp], 0
$LN5@snapShot:

; 1210 : 		}
; 1211 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?snapShot@D3D9RenderSystem@Ogre@@UAEXXZ ENDP		; Ogre::D3D9RenderSystem::snapShot
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@QAE@XZ ; std::_Vector_val<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >::~_Vector_val<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >
PUBLIC	?_Buy@?$vector@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@IAE_NI@Z ; std::vector<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >::_Buy
PUBLIC	??0?$_Vector_val@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@IAE@V?$allocator@PAVD3DRenderWindow@Ogre@@@1@@Z ; std::_Vector_val<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >::_Vector_val<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >
PUBLIC	??0?$allocator@PAVD3DRenderWindow@Ogre@@@std@@QAE@XZ ; std::allocator<Ogre::D3DRenderWindow *>::allocator<Ogre::D3DRenderWindow *>
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	SEGMENT
__unwindtable$??0?$vector@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??0?$vector@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$vector@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$vector@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T159848 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0?$vector@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@QAE@XZ PROC ; std::vector<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >::vector<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$vector@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T159848[ebp], esp
	call	??0?$allocator@PAVD3DRenderWindow@Ogre@@@std@@QAE@XZ ; std::allocator<Ogre::D3DRenderWindow *>::allocator<Ogre::D3DRenderWindow *>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_val@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@IAE@V?$allocator@PAVD3DRenderWindow@Ogre@@@1@@Z ; std::_Vector_val<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >::_Vector_val<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 471  : 		_Buy(0);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@IAE_NI@Z ; std::vector<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >::_Buy

; 472  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@QAE@XZ
__ehhandler$??0?$vector@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@QAE@XZ ENDP ; std::vector<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >::vector<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >
PUBLIC	?_Tidy@?$vector@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@IAEXXZ ; std::vector<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >::_Tidy
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$vector@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$vector@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$vector@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$vector@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$vector@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$vector@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@QAE@XZ PROC ; std::vector<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >::~vector<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$vector@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 559  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@IAEXXZ ; std::vector<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >::_Tidy

; 560  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Vector_val@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$vector@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@QAE@XZ
__ehhandler$??1?$vector@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$vector@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$vector@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@QAE@XZ ENDP ; std::vector<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >::~vector<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >
PUBLIC	??0?$_Vector_iterator@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@QAE@PAPAVD3DRenderWindow@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >::_Vector_iterator<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >
; Function compile flags: /Odtp
;	COMDAT ?begin@?$vector@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@2@XZ PROC ; std::vector<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >::begin, COMDAT
; _this$ = ecx

; 640  : 		{	// return iterator for beginning of mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 641  : 		return (iterator(_Myfirst, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@QAE@PAPAVD3DRenderWindow@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >::_Vector_iterator<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 642  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?begin@?$vector@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@2@XZ ENDP ; std::vector<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >::begin
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?end@?$vector@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@2@XZ PROC ; std::vector<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >::end, COMDAT
; _this$ = ecx

; 650  : 		{	// return iterator for end of mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 651  : 		return (iterator(_Mylast, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@QAE@PAPAVD3DRenderWindow@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >::_Vector_iterator<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 652  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?end@?$vector@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@2@XZ ENDP ; std::vector<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >::end
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?size@?$vector@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$vector@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@QBEIXZ PROC ; std::vector<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >::size, COMDAT
; _this$ = ecx

; 725  : 		{	// return length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+16]
	sub	eax, DWORD PTR [ecx+12]
	sar	eax, 2

; 727  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?size@?$vector@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@QBEIXZ ENDP ; std::vector<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >::size
_TEXT	ENDS
EXTRN	__imp___invalid_parameter_noinfo:PROC
; Function compile flags: /Odtp
;	COMDAT ??A?$vector@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@QAEAAPAVD3DRenderWindow@Ogre@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pos$ = 8						; size = 4
??A?$vector@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@QAEAAPAVD3DRenderWindow@Ogre@@I@Z PROC ; std::vector<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >::operator[], COMDAT
; _this$ = ecx

; 774  : 		{	// subscript mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)
; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");
; 780  : 			_SCL_SECURE_OUT_OF_RANGE;
; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >::size
	cmp	DWORD PTR __Pos$[ebp], eax
	jb	SHORT $LN1@operator
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN1@operator:

; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR __Pos$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]

; 786  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??A?$vector@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@QAEAAPAVD3DRenderWindow@Ogre@@I@Z ENDP ; std::vector<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >::operator[]
_TEXT	ENDS
PUBLIC	?insert@?$vector@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@2@ABQAVD3DRenderWindow@Ogre@@@Z ; std::vector<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >::insert
PUBLIC	?_Ufill@?$vector@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@IAEPAPAVD3DRenderWindow@Ogre@@PAPAV34@IABQAV34@@Z ; std::vector<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >::_Ufill
PUBLIC	?capacity@?$vector@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >::capacity
; Function compile flags: /Odtp
;	COMDAT ?push_back@?$vector@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@QAEXABQAVD3DRenderWindow@Ogre@@@Z
_TEXT	SEGMENT
_this$ = -28						; size = 4
$T159877 = -24						; size = 8
$T159876 = -16						; size = 8
$T159875 = -8						; size = 8
__Val$ = 8						; size = 4
?push_back@?$vector@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@QAEXABQAVD3DRenderWindow@Ogre@@@Z PROC ; std::vector<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >::push_back, COMDAT
; _this$ = ecx

; 809  : 		{	// insert element at end

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 810  : 		if (size() < capacity())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >::size
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?capacity@?$vector@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >::capacity
	cmp	esi, eax
	jae	SHORT $LN2@push_back

; 811  : 
; 812  :  #if _HAS_ITERATOR_DEBUGGING
; 813  : 			{ // room at end, construct it there
; 814  : 			_Orphan_range(_Mylast, _Mylast);
; 815  : 			_Mylast = _Ufill(_Mylast, 1, _Val);
; 816  : 			}
; 817  : 
; 818  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 819  : 			_Mylast = _Ufill(_Mylast, 1, _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Ufill@?$vector@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@IAEPAPAVD3DRenderWindow@Ogre@@PAPAV34@IABQAV34@@Z ; std::vector<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >::_Ufill
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 820  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 821  : 
; 822  : 		else

	jmp	SHORT $LN3@push_back
$LN2@push_back:

; 823  : 			insert(end(), _Val);

	lea	edx, DWORD PTR $T159876[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$vector@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@2@XZ ; std::vector<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >::end
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T159875[ebp], ecx
	mov	DWORD PTR $T159875[ebp+4], edx
	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T159875[ebp+4]
	push	ecx
	mov	edx, DWORD PTR $T159875[ebp]
	push	edx
	lea	eax, DWORD PTR $T159877[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?insert@?$vector@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@2@ABQAVD3DRenderWindow@Ogre@@@Z ; std::vector<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >::insert
$LN3@push_back:

; 824  : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?push_back@?$vector@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@QAEXABQAVD3DRenderWindow@Ogre@@@Z ENDP ; std::vector<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >::push_back
_TEXT	ENDS
PUBLIC	?_Make_iter@?$vector@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@2@@Z ; std::vector<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >::_Make_iter
PUBLIC	?_Destroy@?$vector@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@IAEXPAPAVD3DRenderWindow@Ogre@@0@Z ; std::vector<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >::_Destroy
PUBLIC	??$unchecked_copy@PAPAVD3DRenderWindow@Ogre@@PAPAV12@@stdext@@YAPAPAVD3DRenderWindow@Ogre@@PAPAV12@00@Z ; stdext::unchecked_copy<Ogre::D3DRenderWindow * *,Ogre::D3DRenderWindow * *>
; Function compile flags: /Odtp
;	COMDAT ?erase@?$vector@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 8
?erase@?$vector@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@2@@Z PROC ; std::vector<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >::erase, COMDAT
; _this$ = ecx

; 1017 : 		{	// erase element at where

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1018 : 		_STDEXT unchecked_copy(_VEC_ITER_BASE(_Where) + 1, _Mylast,
; 1019 : 			_VEC_ITER_BASE(_Where));

	mov	eax, DWORD PTR __Where$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR __Where$[ebp+4]
	add	eax, 4
	push	eax
	call	??$unchecked_copy@PAPAVD3DRenderWindow@Ogre@@PAPAV12@@stdext@@YAPAPAVD3DRenderWindow@Ogre@@PAPAV12@00@Z ; stdext::unchecked_copy<Ogre::D3DRenderWindow * *,Ogre::D3DRenderWindow * *>
	add	esp, 12					; 0000000cH

; 1020 : 		_Destroy(_Mylast - 1, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	sub	ecx, 4
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@IAEXPAPAVD3DRenderWindow@Ogre@@0@Z ; std::vector<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >::_Destroy

; 1021 : 		--_Mylast;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	sub	eax, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 1022 : 		return (_Make_iter(_Where));

	mov	edx, DWORD PTR __Where$[ebp+4]
	push	edx
	mov	eax, DWORD PTR __Where$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Make_iter@?$vector@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@2@@Z ; std::vector<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >::_Make_iter
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1023 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?erase@?$vector@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@2@@Z ENDP ; std::vector<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >::erase
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@QAE@XZ ; std::_Vector_val<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >::~_Vector_val<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >
PUBLIC	?_Buy@?$vector@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@IAE_NI@Z ; std::vector<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >::_Buy
PUBLIC	??0?$_Vector_val@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@IAE@V?$allocator@PAVD3D9VertexDecl@Ogre@@@1@@Z ; std::_Vector_val<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >::_Vector_val<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >
PUBLIC	??0?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@QAE@XZ ; std::allocator<Ogre::D3D9VertexDecl *>::allocator<Ogre::D3D9VertexDecl *>
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$vector@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??0?$vector@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$vector@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$vector@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T159882 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0?$vector@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@QAE@XZ PROC ; std::vector<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >::vector<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$vector@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T159882[ebp], esp
	call	??0?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@QAE@XZ ; std::allocator<Ogre::D3D9VertexDecl *>::allocator<Ogre::D3D9VertexDecl *>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_val@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@IAE@V?$allocator@PAVD3D9VertexDecl@Ogre@@@1@@Z ; std::_Vector_val<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >::_Vector_val<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 471  : 		_Buy(0);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@IAE_NI@Z ; std::vector<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >::_Buy

; 472  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@QAE@XZ
__ehhandler$??0?$vector@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@QAE@XZ ENDP ; std::vector<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >::vector<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >
PUBLIC	?_Tidy@?$vector@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@IAEXXZ ; std::vector<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >::_Tidy
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$vector@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$vector@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$vector@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$vector@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$vector@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$vector@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@QAE@XZ PROC ; std::vector<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >::~vector<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$vector@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 559  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@IAEXXZ ; std::vector<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >::_Tidy

; 560  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Vector_val@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$vector@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@QAE@XZ
__ehhandler$??1?$vector@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$vector@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$vector@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@QAE@XZ ENDP ; std::vector<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >::~vector<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >
PUBLIC	??0?$_Vector_iterator@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@QAE@PAPAVD3D9VertexDecl@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >::_Vector_iterator<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >
; Function compile flags: /Odtp
;	COMDAT ?begin@?$vector@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@2@XZ PROC ; std::vector<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >::begin, COMDAT
; _this$ = ecx

; 640  : 		{	// return iterator for beginning of mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 641  : 		return (iterator(_Myfirst, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@QAE@PAPAVD3D9VertexDecl@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >::_Vector_iterator<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 642  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?begin@?$vector@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@2@XZ ENDP ; std::vector<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >::begin
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?end@?$vector@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@2@XZ PROC ; std::vector<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >::end, COMDAT
; _this$ = ecx

; 650  : 		{	// return iterator for end of mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 651  : 		return (iterator(_Mylast, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@QAE@PAPAVD3D9VertexDecl@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >::_Vector_iterator<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 652  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?end@?$vector@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@2@XZ ENDP ; std::vector<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >::end
_TEXT	ENDS
PUBLIC	?insert@?$vector@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@2@ABQAVD3D9VertexDecl@Ogre@@@Z ; std::vector<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >::insert
PUBLIC	?_Ufill@?$vector@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@IAEPAPAVD3D9VertexDecl@Ogre@@PAPAV34@IABQAV34@@Z ; std::vector<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >::_Ufill
PUBLIC	?capacity@?$vector@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >::capacity
PUBLIC	?size@?$vector@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >::size
; Function compile flags: /Odtp
;	COMDAT ?push_back@?$vector@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@QAEXABQAVD3D9VertexDecl@Ogre@@@Z
_TEXT	SEGMENT
_this$ = -28						; size = 4
$T159907 = -24						; size = 8
$T159906 = -16						; size = 8
$T159905 = -8						; size = 8
__Val$ = 8						; size = 4
?push_back@?$vector@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@QAEXABQAVD3D9VertexDecl@Ogre@@@Z PROC ; std::vector<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >::push_back, COMDAT
; _this$ = ecx

; 809  : 		{	// insert element at end

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 810  : 		if (size() < capacity())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >::size
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?capacity@?$vector@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >::capacity
	cmp	esi, eax
	jae	SHORT $LN2@push_back@2

; 811  : 
; 812  :  #if _HAS_ITERATOR_DEBUGGING
; 813  : 			{ // room at end, construct it there
; 814  : 			_Orphan_range(_Mylast, _Mylast);
; 815  : 			_Mylast = _Ufill(_Mylast, 1, _Val);
; 816  : 			}
; 817  : 
; 818  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 819  : 			_Mylast = _Ufill(_Mylast, 1, _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Ufill@?$vector@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@IAEPAPAVD3D9VertexDecl@Ogre@@PAPAV34@IABQAV34@@Z ; std::vector<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >::_Ufill
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 820  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 821  : 
; 822  : 		else

	jmp	SHORT $LN3@push_back@2
$LN2@push_back@2:

; 823  : 			insert(end(), _Val);

	lea	edx, DWORD PTR $T159906[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$vector@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@2@XZ ; std::vector<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >::end
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T159905[ebp], ecx
	mov	DWORD PTR $T159905[ebp+4], edx
	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T159905[ebp+4]
	push	ecx
	mov	edx, DWORD PTR $T159905[ebp]
	push	edx
	lea	eax, DWORD PTR $T159907[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?insert@?$vector@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@2@ABQAVD3D9VertexDecl@Ogre@@@Z ; std::vector<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >::insert
$LN3@push_back@2:

; 824  : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?push_back@?$vector@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@QAEXABQAVD3D9VertexDecl@Ogre@@@Z ENDP ; std::vector<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >::push_back
_TEXT	ENDS
PUBLIC	??D?$_Vector_const_iterator@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@QBEABQAVD3DRenderWindow@Ogre@@XZ ; std::_Vector_const_iterator<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >::operator*
; Function compile flags: /Odtp
;	COMDAT ??D?$_Vector_iterator@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@QBEAAPAVD3DRenderWindow@Ogre@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??D?$_Vector_iterator@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@QBEAAPAVD3DRenderWindow@Ogre@@XZ PROC ; std::_Vector_iterator<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >::operator*, COMDAT
; _this$ = ecx

; 338  : 		{	// return designated object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 339  : 		return ((reference)**(_Mybase *)this);

	mov	ecx, DWORD PTR _this$[ebp]
	call	??D?$_Vector_const_iterator@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@QBEABQAVD3DRenderWindow@Ogre@@XZ ; std::_Vector_const_iterator<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >::operator*

; 340  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??D?$_Vector_iterator@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@QBEAAPAVD3DRenderWindow@Ogre@@XZ ENDP ; std::_Vector_iterator<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_iterator@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >::operator++
; Function compile flags: /Odtp
;	COMDAT ??E?$_Vector_iterator@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@QAE?AV01@H@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
__Tmp$ = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??E?$_Vector_iterator@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@QAE?AV01@H@Z PROC ; std::_Vector_iterator<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >::operator++, COMDAT
; _this$ = ecx

; 354  : 		{	// postincrement

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 355  : 		_Myt _Tmp = *this;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR __Tmp$[ebp], ecx
	mov	DWORD PTR __Tmp$[ebp+4], edx

; 356  : 		++*this;

	mov	ecx, DWORD PTR _this$[ebp]
	call	??E?$_Vector_iterator@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >::operator++

; 357  : 		return (_Tmp);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR __Tmp$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR __Tmp$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 358  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
??E?$_Vector_iterator@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@QAE?AV01@H@Z ENDP ; std::_Vector_iterator<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >::operator++
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >::operator==
; Function compile flags: /Odtp
;	COMDAT ??9?$_Vector_const_iterator@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >::operator!=, COMDAT
; _this$ = ecx

; 215  : 		{	// test for iterator inequality

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??8?$_Vector_const_iterator@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >::operator==
	movzx	eax, al
	neg	eax
	sbb	eax, eax
	add	eax, 1

; 217  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??9?$_Vector_const_iterator@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >::operator!=
_TEXT	ENDS
PUBLIC	??D?$_Vector_const_iterator@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@QBEABQAVD3D9VertexDecl@Ogre@@XZ ; std::_Vector_const_iterator<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >::operator*
; Function compile flags: /Odtp
;	COMDAT ??D?$_Vector_iterator@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@QBEAAPAVD3D9VertexDecl@Ogre@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??D?$_Vector_iterator@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@QBEAAPAVD3D9VertexDecl@Ogre@@XZ PROC ; std::_Vector_iterator<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >::operator*, COMDAT
; _this$ = ecx

; 338  : 		{	// return designated object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 339  : 		return ((reference)**(_Mybase *)this);

	mov	ecx, DWORD PTR _this$[ebp]
	call	??D?$_Vector_const_iterator@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@QBEABQAVD3D9VertexDecl@Ogre@@XZ ; std::_Vector_const_iterator<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >::operator*

; 340  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??D?$_Vector_iterator@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@QBEAAPAVD3D9VertexDecl@Ogre@@XZ ENDP ; std::_Vector_iterator<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_iterator@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >::operator++
; Function compile flags: /Odtp
;	COMDAT ??E?$_Vector_iterator@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@QAE?AV01@H@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
__Tmp$ = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??E?$_Vector_iterator@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@QAE?AV01@H@Z PROC ; std::_Vector_iterator<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >::operator++, COMDAT
; _this$ = ecx

; 354  : 		{	// postincrement

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 355  : 		_Myt _Tmp = *this;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR __Tmp$[ebp], ecx
	mov	DWORD PTR __Tmp$[ebp+4], edx

; 356  : 		++*this;

	mov	ecx, DWORD PTR _this$[ebp]
	call	??E?$_Vector_iterator@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >::operator++

; 357  : 		return (_Tmp);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR __Tmp$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR __Tmp$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 358  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
??E?$_Vector_iterator@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@QAE?AV01@H@Z ENDP ; std::_Vector_iterator<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >::operator++
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >::operator==
; Function compile flags: /Odtp
;	COMDAT ??9?$_Vector_const_iterator@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >::operator!=, COMDAT
; _this$ = ecx

; 215  : 		{	// test for iterator inequality

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??8?$_Vector_const_iterator@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >::operator==
	movzx	eax, al
	neg	eax
	sbb	eax, eax
	add	eax, 1

; 217  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??9?$_Vector_const_iterator@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >::operator!=
_TEXT	ENDS
PUBLIC	??1?$_Container_base_aux_alloc_real@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::D3DRenderWindow *> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::D3DRenderWindow *> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$_Vector_val@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Vector_val@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$_Vector_val@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Vector_val@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$_Vector_val@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Vector_val@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >::~_Vector_val<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Vector_val@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Container_base_aux_alloc_real@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::D3DRenderWindow *> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::D3DRenderWindow *> >
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Vector_val@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Container_base_aux_alloc_real@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::D3DRenderWindow *> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::D3DRenderWindow *> >
__ehhandler$??1?$_Vector_val@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Vector_val@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Vector_val@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >::~_Vector_val<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >
PUBLIC	??1?$_Container_base_aux_alloc_real@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::D3D9VertexDecl *> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::D3D9VertexDecl *> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$_Vector_val@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Vector_val@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$_Vector_val@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Vector_val@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$_Vector_val@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Vector_val@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >::~_Vector_val<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Vector_val@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Container_base_aux_alloc_real@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::D3D9VertexDecl *> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::D3D9VertexDecl *> >
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Vector_val@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Container_base_aux_alloc_real@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::D3D9VertexDecl *> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::D3D9VertexDecl *> >
__ehhandler$??1?$_Vector_val@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Vector_val@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Vector_val@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >::~_Vector_val<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >
; Function compile flags: /Odtp
;	COMDAT ?capacity@?$vector@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
tv70 = -8						; size = 4
_this$ = -4						; size = 4
?capacity@?$vector@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@QBEIXZ PROC ; std::vector<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >::capacity, COMDAT
; _this$ = ecx

; 634  : 		{	// return current length of allocated storage

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	jne	SHORT $LN3@capacity
	mov	DWORD PTR tv70[ebp], 0
	jmp	SHORT $LN4@capacity
$LN3@capacity:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+20]
	sub	eax, DWORD PTR [edx+12]
	sar	eax, 2
	mov	DWORD PTR tv70[ebp], eax
$LN4@capacity:
	mov	eax, DWORD PTR tv70[ebp]

; 636  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?capacity@?$vector@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@QBEIXZ ENDP ; std::vector<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >::capacity
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Make_iter@?$vector@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 8
?_Make_iter@?$vector@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@2@@Z PROC ; std::vector<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >::_Make_iter, COMDAT
; _this$ = ecx

; 660  : 		{	// make iterator from const_iterator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 661  : 		return (iterator(_Where._Myptr, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp+4]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@QAE@PAPAVD3DRenderWindow@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >::_Vector_iterator<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 662  : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?_Make_iter@?$vector@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@2@@Z ENDP ; std::vector<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >::_Make_iter
_TEXT	ENDS
PUBLIC	??H?$_Vector_iterator@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >::operator+
PUBLIC	?_Insert_n@?$vector@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@2@IABQAVD3DRenderWindow@Ogre@@@Z ; std::vector<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >::_Insert_n
PUBLIC	??G?$_Vector_const_iterator@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@QBEHABV01@@Z ; std::_Vector_const_iterator<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >::operator-
; Function compile flags: /Odtp
;	COMDAT ?insert@?$vector@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@2@ABQAVD3DRenderWindow@Ogre@@@Z
_TEXT	SEGMENT
tv77 = -28						; size = 4
_this$ = -24						; size = 4
$T159949 = -20						; size = 8
$T159946 = -12						; size = 8
__Off$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 8
__Val$ = 20						; size = 4
?insert@?$vector@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@2@ABQAVD3DRenderWindow@Ogre@@@Z PROC ; std::vector<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >::insert, COMDAT
; _this$ = ecx

; 875  : 		{	// insert _Val at _Where

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR _this$[ebp], ecx

; 876  : 		size_type _Off = size() == 0 ? 0 : _Where - begin();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >::size
	test	eax, eax
	jne	SHORT $LN3@insert
	mov	DWORD PTR tv77[ebp], 0
	jmp	SHORT $LN4@insert
$LN3@insert:
	lea	eax, DWORD PTR $T159946[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$vector@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@2@XZ ; std::vector<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >::begin
	push	eax
	lea	ecx, DWORD PTR __Where$[ebp]
	call	??G?$_Vector_const_iterator@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@QBEHABV01@@Z ; std::_Vector_const_iterator<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >::operator-
	mov	DWORD PTR tv77[ebp], eax
$LN4@insert:
	mov	ecx, DWORD PTR tv77[ebp]
	mov	DWORD PTR __Off$[ebp], ecx

; 877  : 		_Insert_n(_Where, (size_type)1, _Val);

	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	push	1
	mov	eax, DWORD PTR __Where$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert_n@?$vector@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@2@IABQAVD3DRenderWindow@Ogre@@@Z ; std::vector<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >::_Insert_n

; 878  : 		return (begin() + _Off);

	mov	edx, DWORD PTR __Off$[ebp]
	push	edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T159949[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$vector@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@2@XZ ; std::vector<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >::begin
	mov	ecx, eax
	call	??H?$_Vector_iterator@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >::operator+
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 879  : 		}

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?insert@?$vector@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@2@ABQAVD3DRenderWindow@Ogre@@@Z ENDP ; std::vector<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >::insert
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@PAVD3DRenderWindow@Ogre@@@std@@QAEPAPAVD3DRenderWindow@Ogre@@I@Z ; std::allocator<Ogre::D3DRenderWindow *>::allocate
PUBLIC	?_Xlen@?$vector@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@KAXXZ ; std::vector<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >::_Xlen
PUBLIC	?max_size@?$vector@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >::max_size
; Function compile flags: /Odtp
;	COMDAT ?_Buy@?$vector@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Capacity$ = 8						; size = 4
?_Buy@?$vector@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@IAE_NI@Z PROC ; std::vector<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+20], 0

; 1104 : 		if (_Capacity == 0)

	cmp	DWORD PTR __Capacity$[ebp], 0
	jne	SHORT $LN4@Buy

; 1105 : 			return (false);

	xor	al, al
	jmp	SHORT $LN5@Buy
	jmp	SHORT $LN3@Buy
$LN4@Buy:

; 1106 : 		else if (max_size() < _Capacity)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >::max_size
	cmp	eax, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN2@Buy

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@KAXXZ ; std::vector<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >::_Xlen

; 1108 : 		else

	jmp	SHORT $LN3@Buy
$LN2@Buy:

; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	mov	eax, DWORD PTR __Capacity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?allocate@?$allocator@PAVD3DRenderWindow@Ogre@@@std@@QAEPAPAVD3DRenderWindow@Ogre@@I@Z ; std::allocator<Ogre::D3DRenderWindow *>::allocate
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [edx+16], ecx

; 1112 : 			_Myend = _Myfirst + _Capacity;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR __Capacity$[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], edx
$LN3@Buy:

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
$LN5@Buy:

; 1115 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Buy@?$vector@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >::_Buy
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@YAXPAPAVD3DRenderWindow@Ogre@@0AAV?$allocator@PAVD3DRenderWindow@Ogre@@@0@@Z ; std::_Destroy_range<std::allocator<Ogre::D3DRenderWindow *> >
; Function compile flags: /Odtp
;	COMDAT ?_Destroy@?$vector@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@IAEXPAPAVD3DRenderWindow@Ogre@@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@IAEXPAPAVD3DRenderWindow@Ogre@@0@Z PROC ; std::vector<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >::_Destroy, COMDAT
; _this$ = ecx

; 1118 : 		{	// destroy [_First, _Last) using allocator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Destroy_range@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@YAXPAPAVD3DRenderWindow@Ogre@@0AAV?$allocator@PAVD3DRenderWindow@Ogre@@@0@@Z ; std::_Destroy_range<std::allocator<Ogre::D3DRenderWindow *> >
	add	esp, 12					; 0000000cH

; 1120 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?_Destroy@?$vector@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@IAEXPAPAVD3DRenderWindow@Ogre@@0@Z ENDP ; std::vector<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >::_Destroy
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@PAVD3DRenderWindow@Ogre@@@std@@QAEXPAPAVD3DRenderWindow@Ogre@@I@Z ; std::allocator<Ogre::D3DRenderWindow *>::deallocate
; Function compile flags: /Odtp
;	COMDAT ?_Tidy@?$vector@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Tidy@?$vector@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@IAEXXZ PROC ; std::vector<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	je	SHORT $LN1@Tidy

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@IAEXPAPAVD3DRenderWindow@Ogre@@0@Z ; std::vector<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >::_Destroy

; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+20]
	sub	ecx, DWORD PTR [eax+12]
	sar	ecx, 2
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?deallocate@?$allocator@PAVD3DRenderWindow@Ogre@@@std@@QAEXPAPAVD3DRenderWindow@Ogre@@I@Z ; std::allocator<Ogre::D3DRenderWindow *>::deallocate
$LN1@Tidy:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+16], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], 0

; 1135 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$vector@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@IAEXXZ ENDP ; std::vector<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >::_Tidy
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_fill_n@PAPAVD3DRenderWindow@Ogre@@IPAV12@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@stdext@@YAXPAPAVD3DRenderWindow@Ogre@@IABQAV12@AAV?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@Z ; stdext::unchecked_uninitialized_fill_n<Ogre::D3DRenderWindow * *,unsigned int,Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >
; Function compile flags: /Odtp
;	COMDAT ?_Ufill@?$vector@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@IAEPAPAVD3DRenderWindow@Ogre@@PAPAV34@IABQAV34@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Ufill@?$vector@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@IAEPAPAVD3DRenderWindow@Ogre@@PAPAV34@IABQAV34@@Z PROC ; std::vector<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >::_Ufill, COMDAT
; _this$ = ecx

; 1253 : 		{	// copy initializing _Count * _Val, using allocator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1254 : 		_STDEXT unchecked_uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??$unchecked_uninitialized_fill_n@PAPAVD3DRenderWindow@Ogre@@IPAV12@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@stdext@@YAXPAPAVD3DRenderWindow@Ogre@@IABQAV12@AAV?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@Z ; stdext::unchecked_uninitialized_fill_n<Ogre::D3DRenderWindow * *,unsigned int,Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >
	add	esp, 16					; 00000010H

; 1255 : 		return (_Ptr + _Count);

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Ptr$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]

; 1256 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?_Ufill@?$vector@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@IAEPAPAVD3DRenderWindow@Ogre@@PAPAV34@IABQAV34@@Z ENDP ; std::vector<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >::_Ufill
_TEXT	ENDS
PUBLIC	??0?$_Container_base_aux_alloc_real@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@IAE@V?$allocator@PAVD3DRenderWindow@Ogre@@@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::D3DRenderWindow *> >::_Container_base_aux_alloc_real<std::allocator<Ogre::D3DRenderWindow *> >
PUBLIC	??0?$allocator@PAVD3DRenderWindow@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::D3DRenderWindow *>::allocator<Ogre::D3DRenderWindow *>
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$_Vector_val@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@IAE@V?$allocator@PAVD3DRenderWindow@Ogre@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Vector_val@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@IAE@V?$allocator@PAVD3DRenderWindow@Ogre@@@1@@Z$0
__ehfuncinfo$??0?$_Vector_val@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@IAE@V?$allocator@PAVD3DRenderWindow@Ogre@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Vector_val@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@IAE@V?$allocator@PAVD3DRenderWindow@Ogre@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Vector_val@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@IAE@V?$allocator@PAVD3DRenderWindow@Ogre@@@1@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T159960 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 1
??0?$_Vector_val@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@IAE@V?$allocator@PAVD3DRenderWindow@Ogre@@@1@@Z PROC ; std::_Vector_val<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >::_Vector_val<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Vector_val@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@IAE@V?$allocator@PAVD3DRenderWindow@Ogre@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T159960[ebp], esp
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	call	??0?$allocator@PAVD3DRenderWindow@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::D3DRenderWindow *>::allocator<Ogre::D3DRenderWindow *>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Container_base_aux_alloc_real@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@IAE@V?$allocator@PAVD3DRenderWindow@Ogre@@@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::D3DRenderWindow *> >::_Container_base_aux_alloc_real<std::allocator<Ogre::D3DRenderWindow *> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??0?$allocator@PAVD3DRenderWindow@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::D3DRenderWindow *>::allocator<Ogre::D3DRenderWindow *>

; 426  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Vector_val@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@IAE@V?$allocator@PAVD3DRenderWindow@Ogre@@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Container_base_aux_alloc_real@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::D3DRenderWindow *> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::D3DRenderWindow *> >
__ehhandler$??0?$_Vector_val@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@IAE@V?$allocator@PAVD3DRenderWindow@Ogre@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Vector_val@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@IAE@V?$allocator@PAVD3DRenderWindow@Ogre@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Vector_val@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@IAE@V?$allocator@PAVD3DRenderWindow@Ogre@@@1@@Z ENDP ; std::_Vector_val<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >::_Vector_val<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >
PUBLIC	??1_Container_base_aux@std@@QAE@XZ		; std::_Container_base_aux::~_Container_base_aux
PUBLIC	?deallocate@?$allocator@V_Aux_cont@std@@@std@@QAEXPAV_Aux_cont@2@I@Z ; std::allocator<std::_Aux_cont>::deallocate
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??1?$_Container_base_aux_alloc_real@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@IAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Container_base_aux_alloc_real@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@IAE@XZ$0
__ehfuncinfo$??1?$_Container_base_aux_alloc_real@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@IAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Container_base_aux_alloc_real@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@IAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$_Container_base_aux_alloc_real@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Container_base_aux_alloc_real@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::D3DRenderWindow *> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::D3DRenderWindow *> >, COMDAT
; _this$ = ecx

; 436  : 		{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Container_base_aux_alloc_real@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@IAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 437  : 		_Myownedaux->~_Aux_cont();
; 438  : 
; 439  : 		_Alaux.deallocate(_Myownedaux, 1);

	push	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?deallocate@?$allocator@V_Aux_cont@std@@@std@@QAEXPAV_Aux_cont@2@I@Z ; std::allocator<std::_Aux_cont>::deallocate

; 440  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Container_base_aux_alloc_real@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@IAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
__ehhandler$??1?$_Container_base_aux_alloc_real@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@IAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Container_base_aux_alloc_real@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@IAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Container_base_aux_alloc_real@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::D3DRenderWindow *> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::D3DRenderWindow *> >
; Function compile flags: /Odtp
;	COMDAT ??1_Container_base_aux@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_Container_base_aux@std@@QAE@XZ PROC			; std::_Container_base_aux::~_Container_base_aux, COMDAT
; _this$ = ecx

; 402  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 403  : 		// Do nothing: ~_Container_base_aux_alloc_real() previously destroyed the aux object.
; 404  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??1_Container_base_aux@std@@QAE@XZ ENDP			; std::_Container_base_aux::~_Container_base_aux
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@PAVD3DRenderWindow@Ogre@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@PAVD3DRenderWindow@Ogre@@@std@@QAE@XZ PROC ; std::allocator<Ogre::D3DRenderWindow *>::allocator<Ogre::D3DRenderWindow *>, COMDAT
; _this$ = ecx

; 119  : 	allocator() _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$allocator@PAVD3DRenderWindow@Ogre@@@std@@QAE@XZ ENDP ; std::allocator<Ogre::D3DRenderWindow *>::allocator<Ogre::D3DRenderWindow *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?capacity@?$vector@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
tv70 = -8						; size = 4
_this$ = -4						; size = 4
?capacity@?$vector@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@QBEIXZ PROC ; std::vector<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >::capacity, COMDAT
; _this$ = ecx

; 634  : 		{	// return current length of allocated storage

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	jne	SHORT $LN3@capacity@2
	mov	DWORD PTR tv70[ebp], 0
	jmp	SHORT $LN4@capacity@2
$LN3@capacity@2:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+20]
	sub	eax, DWORD PTR [edx+12]
	sar	eax, 2
	mov	DWORD PTR tv70[ebp], eax
$LN4@capacity@2:
	mov	eax, DWORD PTR tv70[ebp]

; 636  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?capacity@?$vector@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@QBEIXZ ENDP ; std::vector<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >::capacity
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?size@?$vector@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$vector@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@QBEIXZ PROC ; std::vector<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >::size, COMDAT
; _this$ = ecx

; 725  : 		{	// return length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+16]
	sub	eax, DWORD PTR [ecx+12]
	sar	eax, 2

; 727  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?size@?$vector@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@QBEIXZ ENDP ; std::vector<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >::size
_TEXT	ENDS
PUBLIC	??H?$_Vector_iterator@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >::operator+
PUBLIC	?_Insert_n@?$vector@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@2@IABQAVD3D9VertexDecl@Ogre@@@Z ; std::vector<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >::_Insert_n
PUBLIC	??G?$_Vector_const_iterator@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@QBEHABV01@@Z ; std::_Vector_const_iterator<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >::operator-
; Function compile flags: /Odtp
;	COMDAT ?insert@?$vector@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@2@ABQAVD3D9VertexDecl@Ogre@@@Z
_TEXT	SEGMENT
tv77 = -28						; size = 4
_this$ = -24						; size = 4
$T159992 = -20						; size = 8
$T159989 = -12						; size = 8
__Off$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 8
__Val$ = 20						; size = 4
?insert@?$vector@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@2@ABQAVD3D9VertexDecl@Ogre@@@Z PROC ; std::vector<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >::insert, COMDAT
; _this$ = ecx

; 875  : 		{	// insert _Val at _Where

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR _this$[ebp], ecx

; 876  : 		size_type _Off = size() == 0 ? 0 : _Where - begin();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >::size
	test	eax, eax
	jne	SHORT $LN3@insert@2
	mov	DWORD PTR tv77[ebp], 0
	jmp	SHORT $LN4@insert@2
$LN3@insert@2:
	lea	eax, DWORD PTR $T159989[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$vector@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@2@XZ ; std::vector<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >::begin
	push	eax
	lea	ecx, DWORD PTR __Where$[ebp]
	call	??G?$_Vector_const_iterator@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@QBEHABV01@@Z ; std::_Vector_const_iterator<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >::operator-
	mov	DWORD PTR tv77[ebp], eax
$LN4@insert@2:
	mov	ecx, DWORD PTR tv77[ebp]
	mov	DWORD PTR __Off$[ebp], ecx

; 877  : 		_Insert_n(_Where, (size_type)1, _Val);

	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	push	1
	mov	eax, DWORD PTR __Where$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert_n@?$vector@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@2@IABQAVD3D9VertexDecl@Ogre@@@Z ; std::vector<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >::_Insert_n

; 878  : 		return (begin() + _Off);

	mov	edx, DWORD PTR __Off$[ebp]
	push	edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T159992[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$vector@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@2@XZ ; std::vector<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >::begin
	mov	ecx, eax
	call	??H?$_Vector_iterator@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >::operator+
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 879  : 		}

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?insert@?$vector@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@2@ABQAVD3D9VertexDecl@Ogre@@@Z ENDP ; std::vector<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >::insert
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@QAEPAPAVD3D9VertexDecl@Ogre@@I@Z ; std::allocator<Ogre::D3D9VertexDecl *>::allocate
PUBLIC	?_Xlen@?$vector@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@KAXXZ ; std::vector<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >::_Xlen
PUBLIC	?max_size@?$vector@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >::max_size
; Function compile flags: /Odtp
;	COMDAT ?_Buy@?$vector@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Capacity$ = 8						; size = 4
?_Buy@?$vector@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@IAE_NI@Z PROC ; std::vector<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+20], 0

; 1104 : 		if (_Capacity == 0)

	cmp	DWORD PTR __Capacity$[ebp], 0
	jne	SHORT $LN4@Buy@2

; 1105 : 			return (false);

	xor	al, al
	jmp	SHORT $LN5@Buy@2
	jmp	SHORT $LN3@Buy@2
$LN4@Buy@2:

; 1106 : 		else if (max_size() < _Capacity)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >::max_size
	cmp	eax, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN2@Buy@2

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@KAXXZ ; std::vector<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >::_Xlen

; 1108 : 		else

	jmp	SHORT $LN3@Buy@2
$LN2@Buy@2:

; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	mov	eax, DWORD PTR __Capacity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?allocate@?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@QAEPAPAVD3D9VertexDecl@Ogre@@I@Z ; std::allocator<Ogre::D3D9VertexDecl *>::allocate
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [edx+16], ecx

; 1112 : 			_Myend = _Myfirst + _Capacity;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR __Capacity$[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], edx
$LN3@Buy@2:

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
$LN5@Buy@2:

; 1115 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Buy@?$vector@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >::_Buy
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@QAEXPAPAVD3D9VertexDecl@Ogre@@I@Z ; std::allocator<Ogre::D3D9VertexDecl *>::deallocate
PUBLIC	?_Destroy@?$vector@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@IAEXPAPAVD3D9VertexDecl@Ogre@@0@Z ; std::vector<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >::_Destroy
; Function compile flags: /Odtp
;	COMDAT ?_Tidy@?$vector@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Tidy@?$vector@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@IAEXXZ PROC ; std::vector<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	je	SHORT $LN1@Tidy@2

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@IAEXPAPAVD3D9VertexDecl@Ogre@@0@Z ; std::vector<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >::_Destroy

; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+20]
	sub	ecx, DWORD PTR [eax+12]
	sar	ecx, 2
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?deallocate@?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@QAEXPAPAVD3D9VertexDecl@Ogre@@I@Z ; std::allocator<Ogre::D3D9VertexDecl *>::deallocate
$LN1@Tidy@2:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+16], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], 0

; 1135 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$vector@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@IAEXXZ ENDP ; std::vector<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >::_Tidy
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_fill_n@PAPAVD3D9VertexDecl@Ogre@@IPAV12@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@stdext@@YAXPAPAVD3D9VertexDecl@Ogre@@IABQAV12@AAV?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@Z ; stdext::unchecked_uninitialized_fill_n<Ogre::D3D9VertexDecl * *,unsigned int,Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >
; Function compile flags: /Odtp
;	COMDAT ?_Ufill@?$vector@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@IAEPAPAVD3D9VertexDecl@Ogre@@PAPAV34@IABQAV34@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Ufill@?$vector@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@IAEPAPAVD3D9VertexDecl@Ogre@@PAPAV34@IABQAV34@@Z PROC ; std::vector<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >::_Ufill, COMDAT
; _this$ = ecx

; 1253 : 		{	// copy initializing _Count * _Val, using allocator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1254 : 		_STDEXT unchecked_uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??$unchecked_uninitialized_fill_n@PAPAVD3D9VertexDecl@Ogre@@IPAV12@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@stdext@@YAXPAPAVD3D9VertexDecl@Ogre@@IABQAV12@AAV?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@Z ; stdext::unchecked_uninitialized_fill_n<Ogre::D3D9VertexDecl * *,unsigned int,Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >
	add	esp, 16					; 00000010H

; 1255 : 		return (_Ptr + _Count);

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Ptr$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]

; 1256 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?_Ufill@?$vector@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@IAEPAPAVD3D9VertexDecl@Ogre@@PAPAV34@IABQAV34@@Z ENDP ; std::vector<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >::_Ufill
_TEXT	ENDS
PUBLIC	??0?$_Container_base_aux_alloc_real@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@IAE@V?$allocator@PAVD3D9VertexDecl@Ogre@@@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::D3D9VertexDecl *> >::_Container_base_aux_alloc_real<std::allocator<Ogre::D3D9VertexDecl *> >
PUBLIC	??0?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::D3D9VertexDecl *>::allocator<Ogre::D3D9VertexDecl *>
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$_Vector_val@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@IAE@V?$allocator@PAVD3D9VertexDecl@Ogre@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Vector_val@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@IAE@V?$allocator@PAVD3D9VertexDecl@Ogre@@@1@@Z$0
__ehfuncinfo$??0?$_Vector_val@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@IAE@V?$allocator@PAVD3D9VertexDecl@Ogre@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Vector_val@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@IAE@V?$allocator@PAVD3D9VertexDecl@Ogre@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Vector_val@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@IAE@V?$allocator@PAVD3D9VertexDecl@Ogre@@@1@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T160001 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 1
??0?$_Vector_val@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@IAE@V?$allocator@PAVD3D9VertexDecl@Ogre@@@1@@Z PROC ; std::_Vector_val<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >::_Vector_val<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Vector_val@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@IAE@V?$allocator@PAVD3D9VertexDecl@Ogre@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T160001[ebp], esp
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	call	??0?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::D3D9VertexDecl *>::allocator<Ogre::D3D9VertexDecl *>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Container_base_aux_alloc_real@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@IAE@V?$allocator@PAVD3D9VertexDecl@Ogre@@@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::D3D9VertexDecl *> >::_Container_base_aux_alloc_real<std::allocator<Ogre::D3D9VertexDecl *> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??0?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::D3D9VertexDecl *>::allocator<Ogre::D3D9VertexDecl *>

; 426  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Vector_val@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@IAE@V?$allocator@PAVD3D9VertexDecl@Ogre@@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Container_base_aux_alloc_real@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::D3D9VertexDecl *> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::D3D9VertexDecl *> >
__ehhandler$??0?$_Vector_val@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@IAE@V?$allocator@PAVD3D9VertexDecl@Ogre@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Vector_val@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@IAE@V?$allocator@PAVD3D9VertexDecl@Ogre@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Vector_val@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@IAE@V?$allocator@PAVD3D9VertexDecl@Ogre@@@1@@Z ENDP ; std::_Vector_val<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >::_Vector_val<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??1?$_Container_base_aux_alloc_real@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@IAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Container_base_aux_alloc_real@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@IAE@XZ$0
__ehfuncinfo$??1?$_Container_base_aux_alloc_real@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@IAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Container_base_aux_alloc_real@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@IAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$_Container_base_aux_alloc_real@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Container_base_aux_alloc_real@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::D3D9VertexDecl *> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::D3D9VertexDecl *> >, COMDAT
; _this$ = ecx

; 436  : 		{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Container_base_aux_alloc_real@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@IAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 437  : 		_Myownedaux->~_Aux_cont();
; 438  : 
; 439  : 		_Alaux.deallocate(_Myownedaux, 1);

	push	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?deallocate@?$allocator@V_Aux_cont@std@@@std@@QAEXPAV_Aux_cont@2@I@Z ; std::allocator<std::_Aux_cont>::deallocate

; 440  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Container_base_aux_alloc_real@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@IAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
__ehhandler$??1?$_Container_base_aux_alloc_real@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@IAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Container_base_aux_alloc_real@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@IAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Container_base_aux_alloc_real@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::D3D9VertexDecl *> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::D3D9VertexDecl *> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@QAE@XZ PROC ; std::allocator<Ogre::D3D9VertexDecl *>::allocator<Ogre::D3D9VertexDecl *>, COMDAT
; _this$ = ecx

; 119  : 	allocator() _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@QAE@XZ ENDP ; std::allocator<Ogre::D3D9VertexDecl *>::allocator<Ogre::D3D9VertexDecl *>
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@QAE@PAPAVD3DRenderWindow@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >::_Vector_const_iterator<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$_Vector_iterator@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@QAE@PAPAVD3DRenderWindow@Ogre@@PBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@QAE@PAPAVD3DRenderWindow@Ogre@@PBV_Container_base_aux@1@@Z PROC ; std::_Vector_iterator<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >::_Vector_iterator<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >, COMDAT
; _this$ = ecx

; 327  : 		{	// construct with pointer _Ptr

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Pvector$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_const_iterator@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@QAE@PAPAVD3DRenderWindow@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >::_Vector_const_iterator<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >

; 328  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Vector_iterator@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@QAE@PAPAVD3DRenderWindow@Ogre@@PBV_Container_base_aux@1@@Z ENDP ; std::_Vector_iterator<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >::_Vector_iterator<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >
_TEXT	ENDS
PUBLIC	??E?$_Vector_const_iterator@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >::operator++
; Function compile flags: /Odtp
;	COMDAT ??E?$_Vector_iterator@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??E?$_Vector_iterator@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_iterator<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >::operator++, COMDAT
; _this$ = ecx

; 348  : 		{	// preincrement

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 349  : 		++(*(_Mybase *)this);

	mov	ecx, DWORD PTR _this$[ebp]
	call	??E?$_Vector_const_iterator@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >::operator++

; 350  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 351  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??E?$_Vector_iterator@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_iterator<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >::operator++
_TEXT	ENDS
PUBLIC	?_Getmycont@_Iterator_base_aux@std@@QBEPBV_Container_base_aux@2@XZ ; std::_Iterator_base_aux::_Getmycont
PUBLIC	?_Has_container@_Iterator_base_aux@std@@QBE_NXZ	; std::_Iterator_base_aux::_Has_container
; Function compile flags: /Odtp
;	COMDAT ??D?$_Vector_const_iterator@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@QBEABQAVD3DRenderWindow@Ogre@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??D?$_Vector_const_iterator@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@QBEABQAVD3DRenderWindow@Ogre@@XZ PROC ; std::_Vector_const_iterator<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >::operator*, COMDAT
; _this$ = ecx

; 91   : 		{	// return designated object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 92   : 
; 93   :  #if _HAS_ITERATOR_DEBUGGING
; 94   : 		if (this->_Mycont == 0
; 95   : 			|| _Myptr < ((_Myvec *)this->_Mycont)->_Myfirst
; 96   : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 97   : 			{
; 98   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 99   : 			_SCL_SECURE_OUT_OF_RANGE;
; 100  : 			}
; 101  :  #else
; 102  :  		_SCL_SECURE_VALIDATE(this->_Has_container());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Has_container@_Iterator_base_aux@std@@QBE_NXZ ; std::_Iterator_base_aux::_Has_container
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN2@operator@2
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@operator@2:

; 103  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getmycont@_Iterator_base_aux@std@@QBEPBV_Container_base_aux@2@XZ ; std::_Iterator_base_aux::_Getmycont
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, DWORD PTR [eax+16]
	jb	SHORT $LN1@operator@2
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN1@operator@2:

; 104  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 105  : 
; 106  : 		return (*_Myptr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 107  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??D?$_Vector_const_iterator@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@QBEABQAVD3DRenderWindow@Ogre@@XZ ENDP ; std::_Vector_const_iterator<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >::operator*
_TEXT	ENDS
PUBLIC	?_Getcont@_Aux_cont@std@@QBEPBV_Container_base_aux@2@XZ ; std::_Aux_cont::_Getcont
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ?_Getmycont@_Iterator_base_aux@std@@QBEPBV_Container_base_aux@2@XZ
_TEXT	SEGMENT
tv67 = -8						; size = 4
_this$ = -4						; size = 4
?_Getmycont@_Iterator_base_aux@std@@QBEPBV_Container_base_aux@2@XZ PROC ; std::_Iterator_base_aux::_Getmycont, COMDAT
; _this$ = ecx

; 457  : 		{	// Go through the aux object to get the container

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 458  : 		return _Myaux ? _Myaux->_Getcont() : 0;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN3@Getmycont
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?_Getcont@_Aux_cont@std@@QBEPBV_Container_base_aux@2@XZ ; std::_Aux_cont::_Getcont
	mov	DWORD PTR tv67[ebp], eax
	jmp	SHORT $LN4@Getmycont
$LN3@Getmycont:
	mov	DWORD PTR tv67[ebp], 0
$LN4@Getmycont:
	mov	eax, DWORD PTR tv67[ebp]

; 459  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Getmycont@_Iterator_base_aux@std@@QBEPBV_Container_base_aux@2@XZ ENDP ; std::_Iterator_base_aux::_Getmycont
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Getcont@_Aux_cont@std@@QBEPBV_Container_base_aux@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Getcont@_Aux_cont@std@@QBEPBV_Container_base_aux@2@XZ PROC ; std::_Aux_cont::_Getcont, COMDAT
; _this$ = ecx

; 368  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 369  : 		return _Mycontainer;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 370  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Getcont@_Aux_cont@std@@QBEPBV_Container_base_aux@2@XZ ENDP ; std::_Aux_cont::_Getcont
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Has_container@_Iterator_base_aux@std@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Has_container@_Iterator_base_aux@std@@QBE_NXZ PROC	; std::_Iterator_base_aux::_Has_container, COMDAT
; _this$ = ecx

; 467  : 		{	// Accelerate the comparison by not going through the aux object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 468  : 		return _Myaux != 0;

	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	cmp	DWORD PTR [eax], 0
	setne	cl
	mov	al, cl

; 469  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Has_container@_Iterator_base_aux@std@@QBE_NXZ ENDP	; std::_Iterator_base_aux::_Has_container
_TEXT	ENDS
PUBLIC	?_Same_container@_Iterator_base_aux@std@@QBE_NABV12@@Z ; std::_Iterator_base_aux::_Same_container
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??8?$_Vector_const_iterator@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >::operator==, COMDAT
; _this$ = ecx

; 203  : 		{	// test for iterator equality

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Has_container@_Iterator_base_aux@std@@QBE_NXZ ; std::_Iterator_base_aux::_Has_container
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@operator@3
	mov	ecx, DWORD PTR __Right$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Same_container@_Iterator_base_aux@std@@QBE_NABV12@@Z ; std::_Iterator_base_aux::_Same_container
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN2@operator@3
$LN1@operator@3:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@operator@3:

; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [eax+4]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+4]
	sete	al

; 212  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??8?$_Vector_const_iterator@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >::operator==
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ?_Same_container@_Iterator_base_aux@std@@QBE_NABV12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Other$ = 8						; size = 4
?_Same_container@_Iterator_base_aux@std@@QBE_NABV12@@Z PROC ; std::_Iterator_base_aux::_Same_container, COMDAT
; _this$ = ecx

; 462  : 		{	// Accelerate the comparison by not going through the aux object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 463  : 		return _Myaux == _Other._Myaux;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Other$[ebp]
	mov	edx, DWORD PTR [eax]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx]
	sete	al

; 464  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Same_container@_Iterator_base_aux@std@@QBE_NABV12@@Z ENDP ; std::_Iterator_base_aux::_Same_container
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@QAE@PAPAVD3D9VertexDecl@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >::_Vector_const_iterator<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$_Vector_iterator@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@QAE@PAPAVD3D9VertexDecl@Ogre@@PBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@QAE@PAPAVD3D9VertexDecl@Ogre@@PBV_Container_base_aux@1@@Z PROC ; std::_Vector_iterator<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >::_Vector_iterator<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >, COMDAT
; _this$ = ecx

; 327  : 		{	// construct with pointer _Ptr

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Pvector$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_const_iterator@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@QAE@PAPAVD3D9VertexDecl@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >::_Vector_const_iterator<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >

; 328  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Vector_iterator@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@QAE@PAPAVD3D9VertexDecl@Ogre@@PBV_Container_base_aux@1@@Z ENDP ; std::_Vector_iterator<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >::_Vector_iterator<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >
_TEXT	ENDS
PUBLIC	??E?$_Vector_const_iterator@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >::operator++
; Function compile flags: /Odtp
;	COMDAT ??E?$_Vector_iterator@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??E?$_Vector_iterator@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_iterator<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >::operator++, COMDAT
; _this$ = ecx

; 348  : 		{	// preincrement

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 349  : 		++(*(_Mybase *)this);

	mov	ecx, DWORD PTR _this$[ebp]
	call	??E?$_Vector_const_iterator@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >::operator++

; 350  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 351  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??E?$_Vector_iterator@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_iterator<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >::operator++
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??D?$_Vector_const_iterator@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@QBEABQAVD3D9VertexDecl@Ogre@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??D?$_Vector_const_iterator@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@QBEABQAVD3D9VertexDecl@Ogre@@XZ PROC ; std::_Vector_const_iterator<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >::operator*, COMDAT
; _this$ = ecx

; 91   : 		{	// return designated object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 92   : 
; 93   :  #if _HAS_ITERATOR_DEBUGGING
; 94   : 		if (this->_Mycont == 0
; 95   : 			|| _Myptr < ((_Myvec *)this->_Mycont)->_Myfirst
; 96   : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 97   : 			{
; 98   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 99   : 			_SCL_SECURE_OUT_OF_RANGE;
; 100  : 			}
; 101  :  #else
; 102  :  		_SCL_SECURE_VALIDATE(this->_Has_container());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Has_container@_Iterator_base_aux@std@@QBE_NXZ ; std::_Iterator_base_aux::_Has_container
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN2@operator@4
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@operator@4:

; 103  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getmycont@_Iterator_base_aux@std@@QBEPBV_Container_base_aux@2@XZ ; std::_Iterator_base_aux::_Getmycont
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, DWORD PTR [eax+16]
	jb	SHORT $LN1@operator@4
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN1@operator@4:

; 104  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 105  : 
; 106  : 		return (*_Myptr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 107  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??D?$_Vector_const_iterator@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@QBEABQAVD3D9VertexDecl@Ogre@@XZ ENDP ; std::_Vector_const_iterator<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >::operator*
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??8?$_Vector_const_iterator@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >::operator==, COMDAT
; _this$ = ecx

; 203  : 		{	// test for iterator equality

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Has_container@_Iterator_base_aux@std@@QBE_NXZ ; std::_Iterator_base_aux::_Has_container
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@operator@5
	mov	ecx, DWORD PTR __Right$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Same_container@_Iterator_base_aux@std@@QBE_NABV12@@Z ; std::_Iterator_base_aux::_Same_container
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN2@operator@5
$LN1@operator@5:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@operator@5:

; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [eax+4]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+4]
	sete	al

; 212  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??8?$_Vector_const_iterator@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >::operator==
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@V_Aux_cont@std@@@std@@QAEXPAV_Aux_cont@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@V_Aux_cont@std@@@std@@QAEXPAV_Aux_cont@2@I@Z PROC ; std::allocator<std::_Aux_cont>::deallocate, COMDAT
; _this$ = ecx

; 139  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 141  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@V_Aux_cont@std@@@std@@QAEXPAV_Aux_cont@2@I@Z ENDP ; std::allocator<std::_Aux_cont>::deallocate
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@PAVD3DRenderWindow@Ogre@@@std@@QBEIXZ ; std::allocator<Ogre::D3DRenderWindow *>::max_size
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?max_size@?$vector@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$vector@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@QBEIXZ PROC ; std::vector<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >::max_size, COMDAT
; _this$ = ecx

; 730  : 		{	// return maximum possible length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 731  : 		return (this->_Alval.max_size());

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?max_size@?$allocator@PAVD3DRenderWindow@Ogre@@@std@@QBEIXZ ; std::allocator<Ogre::D3DRenderWindow *>::max_size

; 732  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$vector@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@QBEIXZ ENDP ; std::vector<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >::max_size
_TEXT	ENDS
PUBLIC	??$_Unchecked_move_backward@PAPAVD3DRenderWindow@Ogre@@PAPAV12@@stdext@@YAPAPAVD3DRenderWindow@Ogre@@PAPAV12@00@Z ; stdext::_Unchecked_move_backward<Ogre::D3DRenderWindow * *,Ogre::D3DRenderWindow * *>
PUBLIC	??$fill@PAPAVD3DRenderWindow@Ogre@@PAV12@@std@@YAXPAPAVD3DRenderWindow@Ogre@@0ABQAV12@@Z ; std::fill<Ogre::D3DRenderWindow * *,Ogre::D3DRenderWindow *>
PUBLIC	??$_Umove@PAPAVD3DRenderWindow@Ogre@@@?$vector@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@IAEPAPAVD3DRenderWindow@Ogre@@PAPAV23@00@Z ; std::vector<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >::_Umove<Ogre::D3DRenderWindow * *>
EXTRN	__CxxThrowException@8:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Insert_n@?$vector@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@2@IABQAVD3DRenderWindow@Ogre@@@Z$5 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@2@IABQAVD3DRenderWindow@Ogre@@@Z$2
__catchsym$?_Insert_n@?$vector@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@2@IABQAVD3DRenderWindow@Ogre@@@Z$4 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@2@IABQAVD3DRenderWindow@Ogre@@@Z$0
__unwindtable$?_Insert_n@?$vector@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@2@IABQAVD3DRenderWindow@Ogre@@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$?_Insert_n@?$vector@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@2@IABQAVD3DRenderWindow@Ogre@@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Insert_n@?$vector@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@2@IABQAVD3DRenderWindow@Ogre@@@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Insert_n@?$vector@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@2@IABQAVD3DRenderWindow@Ogre@@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__tryblocktable$?_Insert_n@?$vector@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@2@IABQAVD3DRenderWindow@Ogre@@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@2@IABQAVD3DRenderWindow@Ogre@@@Z$4
	DD	02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@2@IABQAVD3DRenderWindow@Ogre@@@Z$5
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?_Insert_n@?$vector@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@2@IABQAVD3DRenderWindow@Ogre@@@Z
_TEXT	SEGMENT
tv84 = -52						; size = 4
_this$ = -48						; size = 4
__Tmp$155480 = -44					; size = 4
__Oldend$155481 = -40					; size = 4
__Tmp$155470 = -36					; size = 4
__Ncopied$155457 = -32					; size = 4
__Newvec$155455 = -28					; size = 4
__Whereoff$155456 = -24					; size = 4
__Capacity$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Where$ = 8						; size = 8
__Count$ = 16						; size = 4
__Val$ = 20						; size = 4
?_Insert_n@?$vector@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@2@IABQAVD3DRenderWindow@Ogre@@@Z PROC ; std::vector<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >::_Insert_n, COMDAT
; _this$ = ecx

; 1153 : 		{	// insert _Count * _Val at _Where

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Insert_n@?$vector@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@2@IABQAVD3DRenderWindow@Ogre@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 36					; 00000024H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1154 : 
; 1155 :  #if _HAS_ITERATOR_DEBUGGING
; 1156 : 		if (_Where._Mycont != this
; 1157 : 			|| _Where._Myptr < _Myfirst || _Mylast < _Where._Myptr)
; 1158 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1159 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1160 : 
; 1161 : 		size_type _Capacity = capacity();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?capacity@?$vector@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >::capacity
	mov	DWORD PTR __Capacity$[ebp], eax

; 1162 : 
; 1163 : 		if (_Count == 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN14@Insert_n
	jmp	$LN16@Insert_n
$LN14@Insert_n:

; 1164 : 			;
; 1165 : 		else if (max_size() - size() < _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >::max_size
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >::size
	sub	esi, eax
	cmp	esi, DWORD PTR __Count$[ebp]
	jae	SHORT $LN12@Insert_n

; 1166 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@KAXXZ ; std::vector<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >::_Xlen
	jmp	$LN16@Insert_n
$LN12@Insert_n:

; 1167 : 		else if (_Capacity < size() + _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >::size
	add	eax, DWORD PTR __Count$[ebp]
	cmp	DWORD PTR __Capacity$[ebp], eax
	jae	$LN10@Insert_n

; 1168 : 			{	// not enough room, reallocate
; 1169 : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1170 : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >::max_size
	mov	ecx, DWORD PTR __Capacity$[ebp]
	shr	ecx, 1
	sub	eax, ecx
	cmp	eax, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN17@Insert_n
	mov	DWORD PTR tv84[ebp], 0
	jmp	SHORT $LN18@Insert_n
$LN17@Insert_n:
	mov	edx, DWORD PTR __Capacity$[ebp]
	shr	edx, 1
	add	edx, DWORD PTR __Capacity$[ebp]
	mov	DWORD PTR tv84[ebp], edx
$LN18@Insert_n:
	mov	eax, DWORD PTR tv84[ebp]
	mov	DWORD PTR __Capacity$[ebp], eax

; 1171 : 			if (_Capacity < size() + _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >::size
	add	eax, DWORD PTR __Count$[ebp]
	cmp	DWORD PTR __Capacity$[ebp], eax
	jae	SHORT $LN9@Insert_n

; 1172 : 				_Capacity = size() + _Count;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >::size
	add	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Capacity$[ebp], eax
$LN9@Insert_n:

; 1173 : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

	mov	ecx, DWORD PTR __Capacity$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?allocate@?$allocator@PAVD3DRenderWindow@Ogre@@@std@@QAEPAPAVD3DRenderWindow@Ogre@@I@Z ; std::allocator<Ogre::D3DRenderWindow *>::allocate
	mov	DWORD PTR __Newvec$155455[ebp], eax

; 1174 : 			size_type _Whereoff = _VEC_ITER_BASE(_Where) - _Myfirst;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Where$[ebp+4]
	sub	eax, DWORD PTR [edx+12]
	sar	eax, 2
	mov	DWORD PTR __Whereoff$155456[ebp], eax

; 1175 : 			int _Ncopied = 0;

	mov	DWORD PTR __Ncopied$155457[ebp], 0

; 1176 : 
; 1177 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1178 : 			_Ufill(_Newvec + _Whereoff, _Count, _Val);	// add new stuff

	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __Whereoff$155456[ebp]
	mov	ecx, DWORD PTR __Newvec$155455[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Ufill@?$vector@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@IAEPAPAVD3DRenderWindow@Ogre@@PAPAV34@IABQAV34@@Z ; std::vector<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >::_Ufill

; 1179 : 			++_Ncopied;

	mov	eax, DWORD PTR __Ncopied$155457[ebp]
	add	eax, 1
	mov	DWORD PTR __Ncopied$155457[ebp], eax

; 1180 : 			_Umove(this->_Myfirst, _VEC_ITER_BASE(_Where),
; 1181 : 				_Newvec);	// move prefix

	mov	ecx, DWORD PTR __Newvec$155455[ebp]
	push	ecx
	mov	edx, DWORD PTR __Where$[ebp+4]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Umove@PAPAVD3DRenderWindow@Ogre@@@?$vector@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@IAEPAPAVD3DRenderWindow@Ogre@@PAPAV23@00@Z ; std::vector<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >::_Umove<Ogre::D3DRenderWindow * *>

; 1182 : 			++_Ncopied;

	mov	edx, DWORD PTR __Ncopied$155457[ebp]
	add	edx, 1
	mov	DWORD PTR __Ncopied$155457[ebp], edx

; 1183 : 			_Umove(_VEC_ITER_BASE(_Where), this->_Mylast,
; 1184 : 				_Newvec + (_Whereoff + _Count));	// move suffix

	mov	eax, DWORD PTR __Whereoff$155456[ebp]
	add	eax, DWORD PTR __Count$[ebp]
	mov	ecx, DWORD PTR __Newvec$155455[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Where$[ebp+4]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Umove@PAPAVD3DRenderWindow@Ogre@@@?$vector@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@IAEPAPAVD3DRenderWindow@Ogre@@PAPAV23@00@Z ; std::vector<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >::_Umove<Ogre::D3DRenderWindow * *>
	jmp	SHORT $LN19@Insert_n
__catch$?_Insert_n@?$vector@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@2@IABQAVD3DRenderWindow@Ogre@@@Z$0:

; 1185 : 			_CATCH_ALL
; 1186 : 			if (1 < _Ncopied)

	cmp	DWORD PTR __Ncopied$155457[ebp], 1
	jle	SHORT $LN7@Insert_n

; 1187 : 				_Destroy(_Newvec, _Newvec + _Whereoff);

	mov	eax, DWORD PTR __Whereoff$155456[ebp]
	mov	ecx, DWORD PTR __Newvec$155455[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	push	edx
	mov	eax, DWORD PTR __Newvec$155455[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@IAEXPAPAVD3DRenderWindow@Ogre@@0@Z ; std::vector<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >::_Destroy
$LN7@Insert_n:

; 1188 : 			if (0 < _Ncopied)

	cmp	DWORD PTR __Ncopied$155457[ebp], 0
	jle	SHORT $LN6@Insert_n

; 1189 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);

	mov	ecx, DWORD PTR __Whereoff$155456[ebp]
	mov	edx, DWORD PTR __Newvec$155455[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR __Count$[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]
	push	edx
	mov	eax, DWORD PTR __Whereoff$155456[ebp]
	mov	ecx, DWORD PTR __Newvec$155455[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@IAEXPAPAVD3DRenderWindow@Ogre@@0@Z ; std::vector<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >::_Destroy
$LN6@Insert_n:

; 1190 : 			this->_Alval.deallocate(_Newvec, _Capacity);

	mov	eax, DWORD PTR __Capacity$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Newvec$155455[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?deallocate@?$allocator@PAVD3DRenderWindow@Ogre@@@std@@QAEXPAPAVD3DRenderWindow@Ogre@@I@Z ; std::allocator<Ogre::D3DRenderWindow *>::deallocate

; 1191 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1192 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$?_Insert_n@?$vector@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@2@IABQAVD3DRenderWindow@Ogre@@@Z$1
	ret	0
$LN19@Insert_n:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Insert_n@?$vector@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@2@IABQAVD3DRenderWindow@Ogre@@@Z$1:

; 1193 : 
; 1194 : 			_Count += size();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >::size
	add	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Count$[ebp], eax

; 1195 : 			if (_Myfirst != 0)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+12], 0
	je	SHORT $LN5@Insert_n

; 1196 : 				{	// destroy and deallocate old array
; 1197 : 				_Destroy(_Myfirst, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@IAEXPAPAVD3DRenderWindow@Ogre@@0@Z ; std::vector<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >::_Destroy

; 1198 : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+20]
	sub	eax, DWORD PTR [edx+12]
	sar	eax, 2
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?deallocate@?$allocator@PAVD3DRenderWindow@Ogre@@@std@@QAEXPAPAVD3DRenderWindow@Ogre@@I@Z ; std::allocator<Ogre::D3DRenderWindow *>::deallocate
$LN5@Insert_n:

; 1199 : 				}
; 1200 : 
; 1201 :  #if _HAS_ITERATOR_DEBUGGING
; 1202 : 			this->_Orphan_all();
; 1203 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1204 : 
; 1205 : 			_Myend = _Newvec + _Capacity;

	mov	eax, DWORD PTR __Capacity$[ebp]
	mov	ecx, DWORD PTR __Newvec$155455[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], edx

; 1206 : 			_Mylast = _Newvec + _Count;

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Newvec$155455[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 1207 : 			_Myfirst = _Newvec;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Newvec$155455[ebp]
	mov	DWORD PTR [edx+12], eax
	jmp	$LN16@Insert_n
$LN10@Insert_n:

; 1208 : 			}
; 1209 : 		else if ((size_type)(_Mylast - _VEC_ITER_BASE(_Where)) < _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	sub	edx, DWORD PTR __Where$[ebp+4]
	sar	edx, 2
	cmp	edx, DWORD PTR __Count$[ebp]
	jae	$LN3@Insert_n

; 1210 : 			{	// new stuff spills off end
; 1211 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Tmp$155470[ebp], ecx

; 1212 : 
; 1213 : 			_Umove(_VEC_ITER_BASE(_Where), _Mylast,
; 1214 : 				_VEC_ITER_BASE(_Where) + _Count);	// copy suffix

	mov	edx, DWORD PTR __Count$[ebp]
	mov	eax, DWORD PTR __Where$[ebp+4]
	lea	ecx, DWORD PTR [eax+edx*4]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp+4]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Umove@PAPAVD3DRenderWindow@Ogre@@@?$vector@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@IAEPAPAVD3DRenderWindow@Ogre@@PAPAV23@00@Z ; std::vector<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >::_Umove<Ogre::D3DRenderWindow * *>

; 1215 : 
; 1216 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 2

; 1217 : 			_Ufill(_Mylast, _Count - (_Mylast - _VEC_ITER_BASE(_Where)),
; 1218 : 				_Tmp);	// insert new stuff off end

	lea	edx, DWORD PTR __Tmp$155470[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	sub	ecx, DWORD PTR __Where$[ebp+4]
	sar	ecx, 2
	mov	edx, DWORD PTR __Count$[ebp]
	sub	edx, ecx
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Ufill@?$vector@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@IAEPAPAVD3DRenderWindow@Ogre@@PAPAV34@IABQAV34@@Z ; std::vector<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >::_Ufill
	jmp	SHORT $LN21@Insert_n
__catch$?_Insert_n@?$vector@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@2@IABQAVD3DRenderWindow@Ogre@@@Z$2:

; 1219 : 			_CATCH_ALL
; 1220 : 			_Destroy(_VEC_ITER_BASE(_Where) + _Count, _Mylast + _Count);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR __Count$[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	mov	ecx, DWORD PTR __Where$[ebp+4]
	lea	edx, DWORD PTR [ecx+eax*4]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@IAEXPAPAVD3DRenderWindow@Ogre@@0@Z ; std::vector<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >::_Destroy

; 1221 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1222 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$?_Insert_n@?$vector@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@2@IABQAVD3DRenderWindow@Ogre@@@Z$3
	ret	0
$LN21@Insert_n:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Insert_n@?$vector@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@2@IABQAVD3DRenderWindow@Ogre@@@Z$3:

; 1223 : 
; 1224 : 			_Mylast += _Count;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR __Count$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 1225 : 
; 1226 :  #if _HAS_ITERATOR_DEBUGGING
; 1227 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1228 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1229 : 
; 1230 : 			std::fill(_VEC_ITER_BASE(_Where), _Mylast - _Count,
; 1231 : 				_Tmp);	// insert up to old end

	lea	edx, DWORD PTR __Tmp$155470[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 2
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	sub	edx, eax
	push	edx
	mov	eax, DWORD PTR __Where$[ebp+4]
	push	eax
	call	??$fill@PAPAVD3DRenderWindow@Ogre@@PAV12@@std@@YAXPAPAVD3DRenderWindow@Ogre@@0ABQAV12@@Z ; std::fill<Ogre::D3DRenderWindow * *,Ogre::D3DRenderWindow *>
	add	esp, 12					; 0000000cH

; 1232 : 			}
; 1233 : 		else

	jmp	SHORT $LN16@Insert_n
$LN3@Insert_n:

; 1234 : 			{	// new stuff can all be assigned
; 1235 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	ecx, DWORD PTR __Val$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR __Tmp$155480[ebp], edx

; 1236 : 
; 1237 : 			pointer _Oldend = _Mylast;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR __Oldend$155481[ebp], ecx

; 1238 : 			_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1239 : 				_Mylast);	// copy suffix

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR __Oldend$155481[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count$[ebp]
	shl	edx, 2
	mov	eax, DWORD PTR __Oldend$155481[ebp]
	sub	eax, edx
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Umove@PAPAVD3DRenderWindow@Ogre@@@?$vector@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@IAEPAPAVD3DRenderWindow@Ogre@@PAPAV23@00@Z ; std::vector<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >::_Umove<Ogre::D3DRenderWindow * *>
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 1240 : 
; 1241 :  #if _HAS_ITERATOR_DEBUGGING
; 1242 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1243 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1244 : 
; 1245 : 			_STDEXT _Unchecked_move_backward(_VEC_ITER_BASE(_Where), _Oldend - _Count,
; 1246 : 				_Oldend);	// copy hole

	mov	edx, DWORD PTR __Oldend$155481[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 2
	mov	ecx, DWORD PTR __Oldend$155481[ebp]
	sub	ecx, eax
	push	ecx
	mov	edx, DWORD PTR __Where$[ebp+4]
	push	edx
	call	??$_Unchecked_move_backward@PAPAVD3DRenderWindow@Ogre@@PAPAV12@@stdext@@YAPAPAVD3DRenderWindow@Ogre@@PAPAV12@00@Z ; stdext::_Unchecked_move_backward<Ogre::D3DRenderWindow * *,Ogre::D3DRenderWindow * *>
	add	esp, 12					; 0000000cH

; 1247 : 			std::fill(_VEC_ITER_BASE(_Where), _VEC_ITER_BASE(_Where) + _Count,
; 1248 : 				_Tmp);	// insert into hole

	lea	eax, DWORD PTR __Tmp$155480[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Where$[ebp+4]
	lea	eax, DWORD PTR [edx+ecx*4]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp+4]
	push	ecx
	call	??$fill@PAPAVD3DRenderWindow@Ogre@@PAV12@@std@@YAXPAPAVD3DRenderWindow@Ogre@@0ABQAV12@@Z ; std::fill<Ogre::D3DRenderWindow * *,Ogre::D3DRenderWindow *>
	add	esp, 12					; 0000000cH
$LN16@Insert_n:

; 1249 : 			}
; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Insert_n@?$vector@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@2@IABQAVD3DRenderWindow@Ogre@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-56]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Insert_n@?$vector@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@2@IABQAVD3DRenderWindow@Ogre@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Insert_n@?$vector@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@2@IABQAVD3DRenderWindow@Ogre@@@Z ENDP ; std::vector<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >::_Insert_n
PUBLIC	__TI3?AVlength_error@std@@
PUBLIC	??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::length_error::length_error
PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	??1length_error@std@@UAE@XZ			; std::length_error::~length_error
PUBLIC	__CTA3?AVlength_error@std@@
PUBLIC	__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
PUBLIC	??_R0?AVlength_error@std@@@8			; std::length_error `RTTI Type Descriptor'
PUBLIC	??0length_error@std@@QAE@ABV01@@Z		; std::length_error::length_error
PUBLIC	__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
PUBLIC	??_R0?AVlogic_error@std@@@8			; std::logic_error `RTTI Type Descriptor'
PUBLIC	??0logic_error@std@@QAE@ABV01@@Z		; std::logic_error::logic_error
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
EXTRN	??0exception@std@@QAE@ABV01@@Z:PROC		; std::exception::exception
;	COMDAT ??_R0?AVexception@std@@@8
_DATA	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVlogic_error@std@@@8
_DATA	SEGMENT
??_R0?AVlogic_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::logic_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlogic_error@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0logic_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVlength_error@std@@@8
_DATA	SEGMENT
??_R0?AVlength_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::length_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlength_error@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlength_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0length_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA3?AVlength_error@std@@
xdata$x	SEGMENT
__CTA3?AVlength_error@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVlength_error@std@@
xdata$x	SEGMENT
__TI3?AVlength_error@std@@ DD 00H
	DD	FLAT:??1length_error@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVlength_error@std@@
xdata$x	ENDS
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ DB 'vector<T> too long'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@KAXXZ$0
__ehfuncinfo$?_Xlen@?$vector@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@KAXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T160077 = -80						; size = 28
$T160076 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@KAXXZ PROC ; std::vector<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Xlen@?$vector@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T160077[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR $T160077[ebp]
	push	eax
	lea	ecx, DWORD PTR $T160076[ebp]
	call	??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::length_error::length_error
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T160076[ebp]
	push	ecx
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T160077[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN2@Xlen:

; 1261 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T160077[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?_Xlen@?$vector@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@KAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@KAXXZ ENDP ; std::vector<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >::_Xlen
PUBLIC	??1logic_error@std@@UAE@XZ			; std::logic_error::~logic_error
PUBLIC	??_7length_error@std@@6B@			; std::length_error::`vftable'
PUBLIC	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
PUBLIC	??_R4length_error@std@@6B@			; std::length_error::`RTTI Complete Object Locator'
PUBLIC	??_R3length_error@std@@8			; std::length_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2length_error@std@@8			; std::length_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@length_error@std@@8		; std::length_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@logic_error@std@@8		; std::logic_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3logic_error@std@@8				; std::logic_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2logic_error@std@@8				; std::logic_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
PUBLIC	?what@logic_error@std@@UBEPBDXZ			; std::logic_error::what
EXTRN	??_Elength_error@std@@UAEPAXI@Z:PROC		; std::length_error::`vector deleting destructor'
;	COMDAT ??_R2exception@std@@8
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R2logic_error@std@@8
rdata$r	SEGMENT
??_R2logic_error@std@@8 DD FLAT:??_R1A@?0A@EA@logic_error@std@@8 ; std::logic_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3logic_error@std@@8
rdata$r	SEGMENT
??_R3logic_error@std@@8 DD 00H				; std::logic_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@logic_error@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@logic_error@std@@8 DD FLAT:??_R0?AVlogic_error@std@@@8 ; std::logic_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@length_error@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@length_error@std@@8 DD FLAT:??_R0?AVlength_error@std@@@8 ; std::length_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2length_error@std@@8
rdata$r	SEGMENT
??_R2length_error@std@@8 DD FLAT:??_R1A@?0A@EA@length_error@std@@8 ; std::length_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@logic_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3length_error@std@@8
rdata$r	SEGMENT
??_R3length_error@std@@8 DD 00H				; std::length_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R4length_error@std@@6B@
rdata$r	SEGMENT
??_R4length_error@std@@6B@ DD 00H			; std::length_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVlength_error@std@@@8
	DD	FLAT:??_R3length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_7length_error@std@@6B@
CONST	SEGMENT
??_7length_error@std@@6B@ DD FLAT:??_R4length_error@std@@6B@ ; std::length_error::`vftable'
	DD	FLAT:??_Elength_error@std@@UAEPAXI@Z
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0
__ehfuncinfo$??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Message$ = 8						; size = 4
??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::length_error::length_error, COMDAT
; _this$ = ecx

; 105  : 		{	// construct from message string

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Message$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7length_error@std@@6B@

; 106  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1logic_error@std@@UAE@XZ		; std::logic_error::~logic_error
__ehhandler$??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::length_error::length_error
PUBLIC	??_7logic_error@std@@6B@			; std::logic_error::`vftable'
PUBLIC	??_R4logic_error@std@@6B@			; std::logic_error::`RTTI Complete Object Locator'
EXTRN	__imp_??1exception@std@@UAE@XZ:PROC
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z:PROC
EXTRN	__imp_??0exception@std@@QAE@XZ:PROC
EXTRN	??_Elogic_error@std@@UAEPAXI@Z:PROC		; std::logic_error::`vector deleting destructor'
;	COMDAT ??_R4logic_error@std@@6B@
rdata$r	SEGMENT
??_R4logic_error@std@@6B@ DD 00H			; std::logic_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	FLAT:??_R3logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_7logic_error@std@@6B@
CONST	SEGMENT
??_7logic_error@std@@6B@ DD FLAT:??_R4logic_error@std@@6B@ ; std::logic_error::`vftable'
	DD	FLAT:??_Elogic_error@std@@UAEPAXI@Z
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$1
__ehfuncinfo$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Message$ = 8						; size = 4
??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::logic_error::logic_error, COMDAT
; _this$ = ecx

; 26   : 		{	// construct from message string

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7logic_error@std@@6B@
	mov	ecx, DWORD PTR __Message$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 27   : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__unwindfunclet$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::logic_error::logic_error
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1logic_error@std@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1logic_error@std@@UAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1logic_error@std@@UAE@XZ$1
__ehfuncinfo$??1logic_error@std@@UAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??1logic_error@std@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1logic_error@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1logic_error@std@@UAE@XZ PROC				; std::logic_error::~logic_error, COMDAT
; _this$ = ecx

; 30   : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1logic_error@std@@UAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7logic_error@std@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 31   : 		}

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1logic_error@std@@UAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__unwindfunclet$??1logic_error@std@@UAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$??1logic_error@std@@UAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1logic_error@std@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1logic_error@std@@UAE@XZ ENDP				; std::logic_error::~logic_error
; Function compile flags: /Odtp
;	COMDAT ?what@logic_error@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?what@logic_error@std@@UBEPBDXZ PROC			; std::logic_error::what, COMDAT
; _this$ = ecx

; 34   : 		{	// return pointer to message string

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 35   : 		return (_Str.c_str());

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ

; 36   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?what@logic_error@std@@UBEPBDXZ ENDP			; std::logic_error::what
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_Glogic_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Glogic_error@std@@UAEPAXI@Z PROC			; std::logic_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1logic_error@std@@UAE@XZ		; std::logic_error::~logic_error
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@4
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@4:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Glogic_error@std@@UAEPAXI@Z ENDP			; std::logic_error::`scalar deleting destructor'
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1length_error@std@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1length_error@std@@UAE@XZ$0
__ehfuncinfo$??1length_error@std@@UAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1length_error@std@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1length_error@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1length_error@std@@UAE@XZ PROC			; std::length_error::~length_error, COMDAT
; _this$ = ecx

; 109  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1length_error@std@@UAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7length_error@std@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 110  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1logic_error@std@@UAE@XZ		; std::logic_error::~logic_error
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1length_error@std@@UAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1logic_error@std@@UAE@XZ		; std::logic_error::~logic_error
__ehhandler$??1length_error@std@@UAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1length_error@std@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1length_error@std@@UAE@XZ ENDP			; std::length_error::~length_error
; Function compile flags: /Odtp
;	COMDAT ??_Glength_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Glength_error@std@@UAEPAXI@Z PROC			; std::length_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1length_error@std@@UAE@XZ		; std::length_error::~length_error
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@5
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@5:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Glength_error@std@@UAEPAXI@Z ENDP			; std::length_error::`scalar deleting destructor'
_TEXT	ENDS
EXTRN	__imp_??0exception@std@@QAE@ABV01@@Z:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0logic_error@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$1
__ehfuncinfo$??0logic_error@std@@QAE@ABV01@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0logic_error@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0logic_error@std@@QAE@ABV01@@Z PROC			; std::logic_error::logic_error, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0logic_error@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7logic_error@std@@6B@
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 12					; 0000000cH
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$??0logic_error@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0logic_error@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0logic_error@std@@QAE@ABV01@@Z ENDP			; std::logic_error::logic_error
PUBLIC	??3@YAXPAX0@Z					; operator delete
PUBLIC	??0_Aux_cont@std@@QAE@QBV_Container_base_aux@1@@Z ; std::_Aux_cont::_Aux_cont
PUBLIC	??2@YAPAXIPAX@Z					; operator new
PUBLIC	?allocate@?$allocator@V_Aux_cont@std@@@std@@QAEPAV_Aux_cont@2@I@Z ; std::allocator<std::_Aux_cont>::allocate
PUBLIC	??$?0PAVD3DRenderWindow@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@PAVD3DRenderWindow@Ogre@@@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::D3DRenderWindow *>
PUBLIC	??0_Container_base_aux@std@@QAE@XZ		; std::_Container_base_aux::_Container_base_aux
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@IAE@V?$allocator@PAVD3DRenderWindow@Ogre@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@IAE@V?$allocator@PAVD3DRenderWindow@Ogre@@@1@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@IAE@V?$allocator@PAVD3DRenderWindow@Ogre@@@1@@Z$1
__ehfuncinfo$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@IAE@V?$allocator@PAVD3DRenderWindow@Ogre@@@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@IAE@V?$allocator@PAVD3DRenderWindow@Ogre@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Container_base_aux_alloc_real@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@IAE@V?$allocator@PAVD3DRenderWindow@Ogre@@@1@@Z
_TEXT	SEGMENT
tv133 = -32						; size = 4
_this$ = -28						; size = 4
$T160143 = -24						; size = 4
$T160142 = -20						; size = 4
$T160141 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 1
??0?$_Container_base_aux_alloc_real@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@IAE@V?$allocator@PAVD3DRenderWindow@Ogre@@@1@@Z PROC ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::D3DRenderWindow *> >::_Container_base_aux_alloc_real<std::allocator<Ogre::D3DRenderWindow *> >, COMDAT
; _this$ = ecx

; 419  : 		{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@IAE@V?$allocator@PAVD3DRenderWindow@Ogre@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 20					; 00000014H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::_Container_base_aux
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??$?0PAVD3DRenderWindow@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@PAVD3DRenderWindow@Ogre@@@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::D3DRenderWindow *>

; 420  : 		_Myownedaux = new (_Alaux.allocate(1)) _Aux_cont(this);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?allocate@?$allocator@V_Aux_cont@std@@@std@@QAEPAV_Aux_cont@2@I@Z ; std::allocator<std::_Aux_cont>::allocate
	mov	DWORD PTR $T160143[ebp], eax
	mov	ecx, DWORD PTR $T160143[ebp]
	push	ecx
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T160142[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	cmp	DWORD PTR $T160142[ebp], 0
	je	SHORT $LN3@Container_
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T160142[ebp]
	call	??0_Aux_cont@std@@QAE@QBV_Container_base_aux@1@@Z ; std::_Aux_cont::_Aux_cont
	mov	DWORD PTR tv133[ebp], eax
	jmp	SHORT $LN4@Container_
$LN3@Container_:
	mov	DWORD PTR tv133[ebp], 0
$LN4@Container_:
	mov	eax, DWORD PTR tv133[ebp]
	mov	DWORD PTR $T160141[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T160141[ebp]
	mov	DWORD PTR [ecx], edx

; 421  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@IAE@V?$allocator@PAVD3DRenderWindow@Ogre@@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@IAE@V?$allocator@PAVD3DRenderWindow@Ogre@@@1@@Z$1:
	mov	eax, DWORD PTR $T160143[ebp]
	push	eax
	mov	ecx, DWORD PTR $T160142[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@IAE@V?$allocator@PAVD3DRenderWindow@Ogre@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@IAE@V?$allocator@PAVD3DRenderWindow@Ogre@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Container_base_aux_alloc_real@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@IAE@V?$allocator@PAVD3DRenderWindow@Ogre@@@1@@Z ENDP ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::D3DRenderWindow *> >::_Container_base_aux_alloc_real<std::allocator<Ogre::D3DRenderWindow *> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\new
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 58   : 	{	// construct array with placement at _Where

	push	ebp
	mov	ebp, esp

; 59   : 	return (_Where);

	mov	eax, DWORD PTR __Where$[ebp]

; 60   : 	}

	pop	ebp
	ret	0
??2@YAPAXIPAX@Z ENDP					; operator new
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??3@YAXPAX0@Z PROC					; operator delete, COMDAT

; 63   : 	{	// delete if placement new fails

	push	ebp
	mov	ebp, esp

; 64   : 	}

	pop	ebp
	ret	0
??3@YAXPAX0@Z ENDP					; operator delete
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??0_Aux_cont@std@@QAE@QBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pcont$ = 8						; size = 4
??0_Aux_cont@std@@QAE@QBV_Container_base_aux@1@@Z PROC	; std::_Aux_cont::_Aux_cont, COMDAT
; _this$ = ecx

; 364  : 	explicit _Aux_cont(const _Container_base_aux * const _Pcont)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Pcont$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0_Aux_cont@std@@QAE@QBV_Container_base_aux@1@@Z ENDP	; std::_Aux_cont::_Aux_cont
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0_Container_base_aux@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_Container_base_aux@std@@QAE@XZ PROC			; std::_Container_base_aux::_Container_base_aux, COMDAT
; _this$ = ecx

; 379  : 	_Container_base_aux()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 380  : 		{
; 381  : 		// Do nothing: _Container_base_aux_alloc_real() will construct the aux object.
; 382  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0_Container_base_aux@std@@QAE@XZ ENDP			; std::_Container_base_aux::_Container_base_aux
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@PAVD3DRenderWindow@Ogre@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$allocator@PAVD3DRenderWindow@Ogre@@@std@@QAE@ABV01@@Z PROC ; std::allocator<Ogre::D3DRenderWindow *>::allocator<Ogre::D3DRenderWindow *>, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$allocator@PAVD3DRenderWindow@Ogre@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<Ogre::D3DRenderWindow *>::allocator<Ogre::D3DRenderWindow *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@PAVD3DRenderWindow@Ogre@@@std@@QAEXPAPAVD3DRenderWindow@Ogre@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@PAVD3DRenderWindow@Ogre@@@std@@QAEXPAPAVD3DRenderWindow@Ogre@@I@Z PROC ; std::allocator<Ogre::D3DRenderWindow *>::deallocate, COMDAT
; _this$ = ecx

; 139  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 141  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@PAVD3DRenderWindow@Ogre@@@std@@QAEXPAPAVD3DRenderWindow@Ogre@@I@Z ENDP ; std::allocator<Ogre::D3DRenderWindow *>::deallocate
_TEXT	ENDS
PUBLIC	??$_Allocate@PAVD3DRenderWindow@Ogre@@@std@@YAPAPAVD3DRenderWindow@Ogre@@IPAPAV12@@Z ; std::_Allocate<Ogre::D3DRenderWindow *>
; Function compile flags: /Odtp
;	COMDAT ?allocate@?$allocator@PAVD3DRenderWindow@Ogre@@@std@@QAEPAPAVD3DRenderWindow@Ogre@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@PAVD3DRenderWindow@Ogre@@@std@@QAEPAPAVD3DRenderWindow@Ogre@@I@Z PROC ; std::allocator<Ogre::D3DRenderWindow *>::allocate, COMDAT
; _this$ = ecx

; 144  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@PAVD3DRenderWindow@Ogre@@@std@@YAPAPAVD3DRenderWindow@Ogre@@IPAPAV12@@Z ; std::_Allocate<Ogre::D3DRenderWindow *>
	add	esp, 8

; 146  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@PAVD3DRenderWindow@Ogre@@@std@@QAEPAPAVD3DRenderWindow@Ogre@@I@Z ENDP ; std::allocator<Ogre::D3DRenderWindow *>::allocate
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@QBEIXZ ; std::allocator<Ogre::D3D9VertexDecl *>::max_size
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?max_size@?$vector@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$vector@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@QBEIXZ PROC ; std::vector<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >::max_size, COMDAT
; _this$ = ecx

; 730  : 		{	// return maximum possible length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 731  : 		return (this->_Alval.max_size());

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?max_size@?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@QBEIXZ ; std::allocator<Ogre::D3D9VertexDecl *>::max_size

; 732  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$vector@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@QBEIXZ ENDP ; std::vector<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >::max_size
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@YAXPAPAVD3D9VertexDecl@Ogre@@0AAV?$allocator@PAVD3D9VertexDecl@Ogre@@@0@@Z ; std::_Destroy_range<std::allocator<Ogre::D3D9VertexDecl *> >
; Function compile flags: /Odtp
;	COMDAT ?_Destroy@?$vector@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@IAEXPAPAVD3D9VertexDecl@Ogre@@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@IAEXPAPAVD3D9VertexDecl@Ogre@@0@Z PROC ; std::vector<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >::_Destroy, COMDAT
; _this$ = ecx

; 1118 : 		{	// destroy [_First, _Last) using allocator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Destroy_range@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@YAXPAPAVD3D9VertexDecl@Ogre@@0AAV?$allocator@PAVD3D9VertexDecl@Ogre@@@0@@Z ; std::_Destroy_range<std::allocator<Ogre::D3D9VertexDecl *> >
	add	esp, 12					; 0000000cH

; 1120 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?_Destroy@?$vector@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@IAEXPAPAVD3D9VertexDecl@Ogre@@0@Z ENDP ; std::vector<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >::_Destroy
_TEXT	ENDS
PUBLIC	??$_Unchecked_move_backward@PAPAVD3D9VertexDecl@Ogre@@PAPAV12@@stdext@@YAPAPAVD3D9VertexDecl@Ogre@@PAPAV12@00@Z ; stdext::_Unchecked_move_backward<Ogre::D3D9VertexDecl * *,Ogre::D3D9VertexDecl * *>
PUBLIC	??$fill@PAPAVD3D9VertexDecl@Ogre@@PAV12@@std@@YAXPAPAVD3D9VertexDecl@Ogre@@0ABQAV12@@Z ; std::fill<Ogre::D3D9VertexDecl * *,Ogre::D3D9VertexDecl *>
PUBLIC	??$_Umove@PAPAVD3D9VertexDecl@Ogre@@@?$vector@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@IAEPAPAVD3D9VertexDecl@Ogre@@PAPAV23@00@Z ; std::vector<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >::_Umove<Ogre::D3D9VertexDecl * *>
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Insert_n@?$vector@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@2@IABQAVD3D9VertexDecl@Ogre@@@Z$5 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@2@IABQAVD3D9VertexDecl@Ogre@@@Z$2
__catchsym$?_Insert_n@?$vector@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@2@IABQAVD3D9VertexDecl@Ogre@@@Z$4 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@2@IABQAVD3D9VertexDecl@Ogre@@@Z$0
__unwindtable$?_Insert_n@?$vector@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@2@IABQAVD3D9VertexDecl@Ogre@@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$?_Insert_n@?$vector@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@2@IABQAVD3D9VertexDecl@Ogre@@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Insert_n@?$vector@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@2@IABQAVD3D9VertexDecl@Ogre@@@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Insert_n@?$vector@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@2@IABQAVD3D9VertexDecl@Ogre@@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__tryblocktable$?_Insert_n@?$vector@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@2@IABQAVD3D9VertexDecl@Ogre@@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@2@IABQAVD3D9VertexDecl@Ogre@@@Z$4
	DD	02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@2@IABQAVD3D9VertexDecl@Ogre@@@Z$5
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?_Insert_n@?$vector@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@2@IABQAVD3D9VertexDecl@Ogre@@@Z
_TEXT	SEGMENT
tv84 = -52						; size = 4
_this$ = -48						; size = 4
__Tmp$155567 = -44					; size = 4
__Oldend$155568 = -40					; size = 4
__Tmp$155557 = -36					; size = 4
__Ncopied$155544 = -32					; size = 4
__Newvec$155542 = -28					; size = 4
__Whereoff$155543 = -24					; size = 4
__Capacity$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Where$ = 8						; size = 8
__Count$ = 16						; size = 4
__Val$ = 20						; size = 4
?_Insert_n@?$vector@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@2@IABQAVD3D9VertexDecl@Ogre@@@Z PROC ; std::vector<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >::_Insert_n, COMDAT
; _this$ = ecx

; 1153 : 		{	// insert _Count * _Val at _Where

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Insert_n@?$vector@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@2@IABQAVD3D9VertexDecl@Ogre@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 36					; 00000024H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1154 : 
; 1155 :  #if _HAS_ITERATOR_DEBUGGING
; 1156 : 		if (_Where._Mycont != this
; 1157 : 			|| _Where._Myptr < _Myfirst || _Mylast < _Where._Myptr)
; 1158 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1159 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1160 : 
; 1161 : 		size_type _Capacity = capacity();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?capacity@?$vector@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >::capacity
	mov	DWORD PTR __Capacity$[ebp], eax

; 1162 : 
; 1163 : 		if (_Count == 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN14@Insert_n@2
	jmp	$LN16@Insert_n@2
$LN14@Insert_n@2:

; 1164 : 			;
; 1165 : 		else if (max_size() - size() < _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >::max_size
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >::size
	sub	esi, eax
	cmp	esi, DWORD PTR __Count$[ebp]
	jae	SHORT $LN12@Insert_n@2

; 1166 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@KAXXZ ; std::vector<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >::_Xlen
	jmp	$LN16@Insert_n@2
$LN12@Insert_n@2:

; 1167 : 		else if (_Capacity < size() + _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >::size
	add	eax, DWORD PTR __Count$[ebp]
	cmp	DWORD PTR __Capacity$[ebp], eax
	jae	$LN10@Insert_n@2

; 1168 : 			{	// not enough room, reallocate
; 1169 : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1170 : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >::max_size
	mov	ecx, DWORD PTR __Capacity$[ebp]
	shr	ecx, 1
	sub	eax, ecx
	cmp	eax, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN17@Insert_n@2
	mov	DWORD PTR tv84[ebp], 0
	jmp	SHORT $LN18@Insert_n@2
$LN17@Insert_n@2:
	mov	edx, DWORD PTR __Capacity$[ebp]
	shr	edx, 1
	add	edx, DWORD PTR __Capacity$[ebp]
	mov	DWORD PTR tv84[ebp], edx
$LN18@Insert_n@2:
	mov	eax, DWORD PTR tv84[ebp]
	mov	DWORD PTR __Capacity$[ebp], eax

; 1171 : 			if (_Capacity < size() + _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >::size
	add	eax, DWORD PTR __Count$[ebp]
	cmp	DWORD PTR __Capacity$[ebp], eax
	jae	SHORT $LN9@Insert_n@2

; 1172 : 				_Capacity = size() + _Count;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >::size
	add	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Capacity$[ebp], eax
$LN9@Insert_n@2:

; 1173 : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

	mov	ecx, DWORD PTR __Capacity$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?allocate@?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@QAEPAPAVD3D9VertexDecl@Ogre@@I@Z ; std::allocator<Ogre::D3D9VertexDecl *>::allocate
	mov	DWORD PTR __Newvec$155542[ebp], eax

; 1174 : 			size_type _Whereoff = _VEC_ITER_BASE(_Where) - _Myfirst;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Where$[ebp+4]
	sub	eax, DWORD PTR [edx+12]
	sar	eax, 2
	mov	DWORD PTR __Whereoff$155543[ebp], eax

; 1175 : 			int _Ncopied = 0;

	mov	DWORD PTR __Ncopied$155544[ebp], 0

; 1176 : 
; 1177 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1178 : 			_Ufill(_Newvec + _Whereoff, _Count, _Val);	// add new stuff

	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __Whereoff$155543[ebp]
	mov	ecx, DWORD PTR __Newvec$155542[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Ufill@?$vector@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@IAEPAPAVD3D9VertexDecl@Ogre@@PAPAV34@IABQAV34@@Z ; std::vector<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >::_Ufill

; 1179 : 			++_Ncopied;

	mov	eax, DWORD PTR __Ncopied$155544[ebp]
	add	eax, 1
	mov	DWORD PTR __Ncopied$155544[ebp], eax

; 1180 : 			_Umove(this->_Myfirst, _VEC_ITER_BASE(_Where),
; 1181 : 				_Newvec);	// move prefix

	mov	ecx, DWORD PTR __Newvec$155542[ebp]
	push	ecx
	mov	edx, DWORD PTR __Where$[ebp+4]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Umove@PAPAVD3D9VertexDecl@Ogre@@@?$vector@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@IAEPAPAVD3D9VertexDecl@Ogre@@PAPAV23@00@Z ; std::vector<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >::_Umove<Ogre::D3D9VertexDecl * *>

; 1182 : 			++_Ncopied;

	mov	edx, DWORD PTR __Ncopied$155544[ebp]
	add	edx, 1
	mov	DWORD PTR __Ncopied$155544[ebp], edx

; 1183 : 			_Umove(_VEC_ITER_BASE(_Where), this->_Mylast,
; 1184 : 				_Newvec + (_Whereoff + _Count));	// move suffix

	mov	eax, DWORD PTR __Whereoff$155543[ebp]
	add	eax, DWORD PTR __Count$[ebp]
	mov	ecx, DWORD PTR __Newvec$155542[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Where$[ebp+4]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Umove@PAPAVD3D9VertexDecl@Ogre@@@?$vector@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@IAEPAPAVD3D9VertexDecl@Ogre@@PAPAV23@00@Z ; std::vector<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >::_Umove<Ogre::D3D9VertexDecl * *>
	jmp	SHORT $LN19@Insert_n@2
__catch$?_Insert_n@?$vector@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@2@IABQAVD3D9VertexDecl@Ogre@@@Z$0:

; 1185 : 			_CATCH_ALL
; 1186 : 			if (1 < _Ncopied)

	cmp	DWORD PTR __Ncopied$155544[ebp], 1
	jle	SHORT $LN7@Insert_n@2

; 1187 : 				_Destroy(_Newvec, _Newvec + _Whereoff);

	mov	eax, DWORD PTR __Whereoff$155543[ebp]
	mov	ecx, DWORD PTR __Newvec$155542[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	push	edx
	mov	eax, DWORD PTR __Newvec$155542[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@IAEXPAPAVD3D9VertexDecl@Ogre@@0@Z ; std::vector<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >::_Destroy
$LN7@Insert_n@2:

; 1188 : 			if (0 < _Ncopied)

	cmp	DWORD PTR __Ncopied$155544[ebp], 0
	jle	SHORT $LN6@Insert_n@2

; 1189 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);

	mov	ecx, DWORD PTR __Whereoff$155543[ebp]
	mov	edx, DWORD PTR __Newvec$155542[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR __Count$[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]
	push	edx
	mov	eax, DWORD PTR __Whereoff$155543[ebp]
	mov	ecx, DWORD PTR __Newvec$155542[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@IAEXPAPAVD3D9VertexDecl@Ogre@@0@Z ; std::vector<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >::_Destroy
$LN6@Insert_n@2:

; 1190 : 			this->_Alval.deallocate(_Newvec, _Capacity);

	mov	eax, DWORD PTR __Capacity$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Newvec$155542[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?deallocate@?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@QAEXPAPAVD3D9VertexDecl@Ogre@@I@Z ; std::allocator<Ogre::D3D9VertexDecl *>::deallocate

; 1191 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1192 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$?_Insert_n@?$vector@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@2@IABQAVD3D9VertexDecl@Ogre@@@Z$1
	ret	0
$LN19@Insert_n@2:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Insert_n@?$vector@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@2@IABQAVD3D9VertexDecl@Ogre@@@Z$1:

; 1193 : 
; 1194 : 			_Count += size();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >::size
	add	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Count$[ebp], eax

; 1195 : 			if (_Myfirst != 0)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+12], 0
	je	SHORT $LN5@Insert_n@2

; 1196 : 				{	// destroy and deallocate old array
; 1197 : 				_Destroy(_Myfirst, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@IAEXPAPAVD3D9VertexDecl@Ogre@@0@Z ; std::vector<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >::_Destroy

; 1198 : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+20]
	sub	eax, DWORD PTR [edx+12]
	sar	eax, 2
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?deallocate@?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@QAEXPAPAVD3D9VertexDecl@Ogre@@I@Z ; std::allocator<Ogre::D3D9VertexDecl *>::deallocate
$LN5@Insert_n@2:

; 1199 : 				}
; 1200 : 
; 1201 :  #if _HAS_ITERATOR_DEBUGGING
; 1202 : 			this->_Orphan_all();
; 1203 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1204 : 
; 1205 : 			_Myend = _Newvec + _Capacity;

	mov	eax, DWORD PTR __Capacity$[ebp]
	mov	ecx, DWORD PTR __Newvec$155542[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], edx

; 1206 : 			_Mylast = _Newvec + _Count;

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Newvec$155542[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 1207 : 			_Myfirst = _Newvec;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Newvec$155542[ebp]
	mov	DWORD PTR [edx+12], eax
	jmp	$LN16@Insert_n@2
$LN10@Insert_n@2:

; 1208 : 			}
; 1209 : 		else if ((size_type)(_Mylast - _VEC_ITER_BASE(_Where)) < _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	sub	edx, DWORD PTR __Where$[ebp+4]
	sar	edx, 2
	cmp	edx, DWORD PTR __Count$[ebp]
	jae	$LN3@Insert_n@2

; 1210 : 			{	// new stuff spills off end
; 1211 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Tmp$155557[ebp], ecx

; 1212 : 
; 1213 : 			_Umove(_VEC_ITER_BASE(_Where), _Mylast,
; 1214 : 				_VEC_ITER_BASE(_Where) + _Count);	// copy suffix

	mov	edx, DWORD PTR __Count$[ebp]
	mov	eax, DWORD PTR __Where$[ebp+4]
	lea	ecx, DWORD PTR [eax+edx*4]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp+4]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Umove@PAPAVD3D9VertexDecl@Ogre@@@?$vector@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@IAEPAPAVD3D9VertexDecl@Ogre@@PAPAV23@00@Z ; std::vector<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >::_Umove<Ogre::D3D9VertexDecl * *>

; 1215 : 
; 1216 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 2

; 1217 : 			_Ufill(_Mylast, _Count - (_Mylast - _VEC_ITER_BASE(_Where)),
; 1218 : 				_Tmp);	// insert new stuff off end

	lea	edx, DWORD PTR __Tmp$155557[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	sub	ecx, DWORD PTR __Where$[ebp+4]
	sar	ecx, 2
	mov	edx, DWORD PTR __Count$[ebp]
	sub	edx, ecx
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Ufill@?$vector@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@IAEPAPAVD3D9VertexDecl@Ogre@@PAPAV34@IABQAV34@@Z ; std::vector<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >::_Ufill
	jmp	SHORT $LN21@Insert_n@2
__catch$?_Insert_n@?$vector@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@2@IABQAVD3D9VertexDecl@Ogre@@@Z$2:

; 1219 : 			_CATCH_ALL
; 1220 : 			_Destroy(_VEC_ITER_BASE(_Where) + _Count, _Mylast + _Count);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR __Count$[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	mov	ecx, DWORD PTR __Where$[ebp+4]
	lea	edx, DWORD PTR [ecx+eax*4]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@IAEXPAPAVD3D9VertexDecl@Ogre@@0@Z ; std::vector<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >::_Destroy

; 1221 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1222 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$?_Insert_n@?$vector@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@2@IABQAVD3D9VertexDecl@Ogre@@@Z$3
	ret	0
$LN21@Insert_n@2:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Insert_n@?$vector@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@2@IABQAVD3D9VertexDecl@Ogre@@@Z$3:

; 1223 : 
; 1224 : 			_Mylast += _Count;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR __Count$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 1225 : 
; 1226 :  #if _HAS_ITERATOR_DEBUGGING
; 1227 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1228 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1229 : 
; 1230 : 			std::fill(_VEC_ITER_BASE(_Where), _Mylast - _Count,
; 1231 : 				_Tmp);	// insert up to old end

	lea	edx, DWORD PTR __Tmp$155557[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 2
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	sub	edx, eax
	push	edx
	mov	eax, DWORD PTR __Where$[ebp+4]
	push	eax
	call	??$fill@PAPAVD3D9VertexDecl@Ogre@@PAV12@@std@@YAXPAPAVD3D9VertexDecl@Ogre@@0ABQAV12@@Z ; std::fill<Ogre::D3D9VertexDecl * *,Ogre::D3D9VertexDecl *>
	add	esp, 12					; 0000000cH

; 1232 : 			}
; 1233 : 		else

	jmp	SHORT $LN16@Insert_n@2
$LN3@Insert_n@2:

; 1234 : 			{	// new stuff can all be assigned
; 1235 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	ecx, DWORD PTR __Val$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR __Tmp$155567[ebp], edx

; 1236 : 
; 1237 : 			pointer _Oldend = _Mylast;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR __Oldend$155568[ebp], ecx

; 1238 : 			_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1239 : 				_Mylast);	// copy suffix

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR __Oldend$155568[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count$[ebp]
	shl	edx, 2
	mov	eax, DWORD PTR __Oldend$155568[ebp]
	sub	eax, edx
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Umove@PAPAVD3D9VertexDecl@Ogre@@@?$vector@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@IAEPAPAVD3D9VertexDecl@Ogre@@PAPAV23@00@Z ; std::vector<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >::_Umove<Ogre::D3D9VertexDecl * *>
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 1240 : 
; 1241 :  #if _HAS_ITERATOR_DEBUGGING
; 1242 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1243 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1244 : 
; 1245 : 			_STDEXT _Unchecked_move_backward(_VEC_ITER_BASE(_Where), _Oldend - _Count,
; 1246 : 				_Oldend);	// copy hole

	mov	edx, DWORD PTR __Oldend$155568[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 2
	mov	ecx, DWORD PTR __Oldend$155568[ebp]
	sub	ecx, eax
	push	ecx
	mov	edx, DWORD PTR __Where$[ebp+4]
	push	edx
	call	??$_Unchecked_move_backward@PAPAVD3D9VertexDecl@Ogre@@PAPAV12@@stdext@@YAPAPAVD3D9VertexDecl@Ogre@@PAPAV12@00@Z ; stdext::_Unchecked_move_backward<Ogre::D3D9VertexDecl * *,Ogre::D3D9VertexDecl * *>
	add	esp, 12					; 0000000cH

; 1247 : 			std::fill(_VEC_ITER_BASE(_Where), _VEC_ITER_BASE(_Where) + _Count,
; 1248 : 				_Tmp);	// insert into hole

	lea	eax, DWORD PTR __Tmp$155567[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Where$[ebp+4]
	lea	eax, DWORD PTR [edx+ecx*4]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp+4]
	push	ecx
	call	??$fill@PAPAVD3D9VertexDecl@Ogre@@PAV12@@std@@YAXPAPAVD3D9VertexDecl@Ogre@@0ABQAV12@@Z ; std::fill<Ogre::D3D9VertexDecl * *,Ogre::D3D9VertexDecl *>
	add	esp, 12					; 0000000cH
$LN16@Insert_n@2:

; 1249 : 			}
; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Insert_n@?$vector@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@2@IABQAVD3D9VertexDecl@Ogre@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-56]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Insert_n@?$vector@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@2@IABQAVD3D9VertexDecl@Ogre@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Insert_n@?$vector@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@2@IABQAVD3D9VertexDecl@Ogre@@@Z ENDP ; std::vector<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >::_Insert_n
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@KAXXZ$0
__ehfuncinfo$?_Xlen@?$vector@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@KAXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T160198 = -80						; size = 28
$T160197 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@KAXXZ PROC ; std::vector<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Xlen@?$vector@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T160198[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR $T160198[ebp]
	push	eax
	lea	ecx, DWORD PTR $T160197[ebp]
	call	??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::length_error::length_error
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T160197[ebp]
	push	ecx
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T160198[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN2@Xlen@2:

; 1261 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T160198[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?_Xlen@?$vector@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@KAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@KAXXZ ENDP ; std::vector<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >::_Xlen
PUBLIC	??$?0PAVD3D9VertexDecl@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@PAVD3D9VertexDecl@Ogre@@@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::D3D9VertexDecl *>
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@IAE@V?$allocator@PAVD3D9VertexDecl@Ogre@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@IAE@V?$allocator@PAVD3D9VertexDecl@Ogre@@@1@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@IAE@V?$allocator@PAVD3D9VertexDecl@Ogre@@@1@@Z$1
__ehfuncinfo$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@IAE@V?$allocator@PAVD3D9VertexDecl@Ogre@@@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@IAE@V?$allocator@PAVD3D9VertexDecl@Ogre@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Container_base_aux_alloc_real@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@IAE@V?$allocator@PAVD3D9VertexDecl@Ogre@@@1@@Z
_TEXT	SEGMENT
tv133 = -32						; size = 4
_this$ = -28						; size = 4
$T160210 = -24						; size = 4
$T160209 = -20						; size = 4
$T160208 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 1
??0?$_Container_base_aux_alloc_real@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@IAE@V?$allocator@PAVD3D9VertexDecl@Ogre@@@1@@Z PROC ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::D3D9VertexDecl *> >::_Container_base_aux_alloc_real<std::allocator<Ogre::D3D9VertexDecl *> >, COMDAT
; _this$ = ecx

; 419  : 		{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@IAE@V?$allocator@PAVD3D9VertexDecl@Ogre@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 20					; 00000014H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::_Container_base_aux
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??$?0PAVD3D9VertexDecl@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@PAVD3D9VertexDecl@Ogre@@@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::D3D9VertexDecl *>

; 420  : 		_Myownedaux = new (_Alaux.allocate(1)) _Aux_cont(this);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?allocate@?$allocator@V_Aux_cont@std@@@std@@QAEPAV_Aux_cont@2@I@Z ; std::allocator<std::_Aux_cont>::allocate
	mov	DWORD PTR $T160210[ebp], eax
	mov	ecx, DWORD PTR $T160210[ebp]
	push	ecx
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T160209[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	cmp	DWORD PTR $T160209[ebp], 0
	je	SHORT $LN3@Container_@2
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T160209[ebp]
	call	??0_Aux_cont@std@@QAE@QBV_Container_base_aux@1@@Z ; std::_Aux_cont::_Aux_cont
	mov	DWORD PTR tv133[ebp], eax
	jmp	SHORT $LN4@Container_@2
$LN3@Container_@2:
	mov	DWORD PTR tv133[ebp], 0
$LN4@Container_@2:
	mov	eax, DWORD PTR tv133[ebp]
	mov	DWORD PTR $T160208[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T160208[ebp]
	mov	DWORD PTR [ecx], edx

; 421  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@IAE@V?$allocator@PAVD3D9VertexDecl@Ogre@@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@IAE@V?$allocator@PAVD3D9VertexDecl@Ogre@@@1@@Z$1:
	mov	eax, DWORD PTR $T160210[ebp]
	push	eax
	mov	ecx, DWORD PTR $T160209[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@IAE@V?$allocator@PAVD3D9VertexDecl@Ogre@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@IAE@V?$allocator@PAVD3D9VertexDecl@Ogre@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Container_base_aux_alloc_real@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@IAE@V?$allocator@PAVD3D9VertexDecl@Ogre@@@1@@Z ENDP ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::D3D9VertexDecl *> >::_Container_base_aux_alloc_real<std::allocator<Ogre::D3D9VertexDecl *> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@QAE@ABV01@@Z PROC ; std::allocator<Ogre::D3D9VertexDecl *>::allocator<Ogre::D3D9VertexDecl *>, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<Ogre::D3D9VertexDecl *>::allocator<Ogre::D3D9VertexDecl *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@QAEXPAPAVD3D9VertexDecl@Ogre@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@QAEXPAPAVD3D9VertexDecl@Ogre@@I@Z PROC ; std::allocator<Ogre::D3D9VertexDecl *>::deallocate, COMDAT
; _this$ = ecx

; 139  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 141  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@QAEXPAPAVD3D9VertexDecl@Ogre@@I@Z ENDP ; std::allocator<Ogre::D3D9VertexDecl *>::deallocate
_TEXT	ENDS
PUBLIC	??$_Allocate@PAVD3D9VertexDecl@Ogre@@@std@@YAPAPAVD3D9VertexDecl@Ogre@@IPAPAV12@@Z ; std::_Allocate<Ogre::D3D9VertexDecl *>
; Function compile flags: /Odtp
;	COMDAT ?allocate@?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@QAEPAPAVD3D9VertexDecl@Ogre@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@QAEPAPAVD3D9VertexDecl@Ogre@@I@Z PROC ; std::allocator<Ogre::D3D9VertexDecl *>::allocate, COMDAT
; _this$ = ecx

; 144  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@PAVD3D9VertexDecl@Ogre@@@std@@YAPAPAVD3D9VertexDecl@Ogre@@IPAPAV12@@Z ; std::_Allocate<Ogre::D3D9VertexDecl *>
	add	esp, 8

; 146  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@QAEPAPAVD3D9VertexDecl@Ogre@@I@Z ENDP ; std::allocator<Ogre::D3D9VertexDecl *>::allocate
_TEXT	ENDS
PUBLIC	??Y?$_Vector_iterator@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >::operator+=
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??H?$_Vector_iterator@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
__Tmp$ = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Vector_iterator@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >::operator+, COMDAT
; _this$ = ecx

; 380  : 		{	// return this + integer

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 381  : 		_Myt _Tmp = *this;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR __Tmp$[ebp], ecx
	mov	DWORD PTR __Tmp$[ebp+4], edx

; 382  : 		return (_Tmp += _Off);

	mov	eax, DWORD PTR __Off$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Tmp$[ebp]
	call	??Y?$_Vector_iterator@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >::operator+=
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 383  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
??H?$_Vector_iterator@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >::operator+
_TEXT	ENDS
PUBLIC	?_Set_container@_Iterator_base_aux@std@@QAEXQBV_Container_base_aux@2@@Z ; std::_Iterator_base_aux::_Set_container
PUBLIC	??0?$_Ranit@PAVD3DRenderWindow@Ogre@@HPBQAV12@ABQAV12@@std@@QAE@XZ ; std::_Ranit<Ogre::D3DRenderWindow *,int,Ogre::D3DRenderWindow * const *,Ogre::D3DRenderWindow * const &>::_Ranit<Ogre::D3DRenderWindow *,int,Ogre::D3DRenderWindow * const *,Ogre::D3DRenderWindow * const &>
; Function compile flags: /Odtp
;	COMDAT ??0?$_Vector_const_iterator@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@QAE@PAPAVD3DRenderWindow@Ogre@@PBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@QAE@PAPAVD3DRenderWindow@Ogre@@PBV_Container_base_aux@1@@Z PROC ; std::_Vector_const_iterator<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >::_Vector_const_iterator<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >, COMDAT
; _this$ = ecx

; 76   : 	_Vector_const_iterator(_Tptr _Ptr, const _Container_base *_Pvector)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Ranit@PAVD3DRenderWindow@Ogre@@HPBQAV12@ABQAV12@@std@@QAE@XZ

; 77   : 		{	// construct with pointer _Ptr
; 78   : 		_SCL_SECURE_VALIDATE(_Pvector != NULL && ((_Myvec *)_Pvector)->_Myfirst <= _Ptr && _Ptr <= ((_Myvec *)_Pvector)->_Mylast);

	cmp	DWORD PTR __Pvector$[ebp], 0
	je	SHORT $LN1@Vector_con
	mov	eax, DWORD PTR __Pvector$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	cmp	ecx, DWORD PTR __Ptr$[ebp]
	ja	SHORT $LN1@Vector_con
	mov	edx, DWORD PTR __Pvector$[ebp]
	mov	eax, DWORD PTR __Ptr$[ebp]
	cmp	eax, DWORD PTR [edx+16]
	jbe	SHORT $LN2@Vector_con
$LN1@Vector_con:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@Vector_con:

; 79   : 		this->_Set_container(_Pvector);

	mov	ecx, DWORD PTR __Pvector$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Set_container@_Iterator_base_aux@std@@QAEXQBV_Container_base_aux@2@@Z ; std::_Iterator_base_aux::_Set_container

; 80   : 		_Myptr = _Ptr;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR [edx+4], eax

; 81   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Vector_const_iterator@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@QAE@PAPAVD3DRenderWindow@Ogre@@PBV_Container_base_aux@1@@Z ENDP ; std::_Vector_const_iterator<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >::_Vector_const_iterator<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ?_Set_container@_Iterator_base_aux@std@@QAEXQBV_Container_base_aux@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pcont$ = 8						; size = 4
?_Set_container@_Iterator_base_aux@std@@QAEXQBV_Container_base_aux@2@@Z PROC ; std::_Iterator_base_aux::_Set_container, COMDAT
; _this$ = ecx

; 452  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 453  : 		_Myaux = _Pcont->_Myownedaux;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Pcont$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 454  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Set_container@_Iterator_base_aux@std@@QAEXQBV_Container_base_aux@2@@Z ENDP ; std::_Iterator_base_aux::_Set_container
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ??E?$_Vector_const_iterator@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??E?$_Vector_const_iterator@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >::operator++, COMDAT
; _this$ = ecx

; 115  : 		{	// preincrement

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 116  : 		_SCL_SECURE_VALIDATE(this->_Has_container());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Has_container@_Iterator_base_aux@std@@QBE_NXZ ; std::_Iterator_base_aux::_Has_container
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN2@operator@6
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@operator@6:

; 117  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getmycont@_Iterator_base_aux@std@@QBEPBV_Container_base_aux@2@XZ ; std::_Iterator_base_aux::_Getmycont
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, DWORD PTR [eax+16]
	jb	SHORT $LN1@operator@6
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN1@operator@6:

; 118  : 
; 119  :  #if _HAS_ITERATOR_DEBUGGING
; 120  : 		if (this->_Mycont == 0
; 121  : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 122  : 			_DEBUG_ERROR("vector iterator not incrementable");
; 123  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 124  : 
; 125  : 		++_Myptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 126  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 127  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??E?$_Vector_const_iterator@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >::operator++
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??G?$_Vector_const_iterator@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@QBEHABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??G?$_Vector_const_iterator@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@QBEHABV01@@Z PROC ; std::_Vector_const_iterator<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >::operator-, COMDAT
; _this$ = ecx

; 186  : 		{	// return difference of iterators

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 187  : 
; 188  :  #if _HAS_ITERATOR_DEBUGGING
; 189  : 		_Compat(_Right);
; 190  :  #else
; 191  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Has_container@_Iterator_base_aux@std@@QBE_NXZ ; std::_Iterator_base_aux::_Has_container
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@operator@7
	mov	ecx, DWORD PTR __Right$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Same_container@_Iterator_base_aux@std@@QBE_NABV12@@Z ; std::_Iterator_base_aux::_Same_container
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN2@operator@7
$LN1@operator@7:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@operator@7:

; 192  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 193  : 
; 194  : 		return (_Myptr - _Right._Myptr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [eax+4]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 195  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??G?$_Vector_const_iterator@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@QBEHABV01@@Z ENDP ; std::_Vector_const_iterator<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >::operator-
_TEXT	ENDS
PUBLIC	??Y?$_Vector_iterator@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >::operator+=
; Function compile flags: /Odtp
;	COMDAT ??H?$_Vector_iterator@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
__Tmp$ = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Vector_iterator@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >::operator+, COMDAT
; _this$ = ecx

; 380  : 		{	// return this + integer

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 381  : 		_Myt _Tmp = *this;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR __Tmp$[ebp], ecx
	mov	DWORD PTR __Tmp$[ebp+4], edx

; 382  : 		return (_Tmp += _Off);

	mov	eax, DWORD PTR __Off$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Tmp$[ebp]
	call	??Y?$_Vector_iterator@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >::operator+=
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 383  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
??H?$_Vector_iterator@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >::operator+
_TEXT	ENDS
PUBLIC	??0?$_Ranit@PAVD3D9VertexDecl@Ogre@@HPBQAV12@ABQAV12@@std@@QAE@XZ ; std::_Ranit<Ogre::D3D9VertexDecl *,int,Ogre::D3D9VertexDecl * const *,Ogre::D3D9VertexDecl * const &>::_Ranit<Ogre::D3D9VertexDecl *,int,Ogre::D3D9VertexDecl * const *,Ogre::D3D9VertexDecl * const &>
; Function compile flags: /Odtp
;	COMDAT ??0?$_Vector_const_iterator@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@QAE@PAPAVD3D9VertexDecl@Ogre@@PBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@QAE@PAPAVD3D9VertexDecl@Ogre@@PBV_Container_base_aux@1@@Z PROC ; std::_Vector_const_iterator<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >::_Vector_const_iterator<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >, COMDAT
; _this$ = ecx

; 76   : 	_Vector_const_iterator(_Tptr _Ptr, const _Container_base *_Pvector)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Ranit@PAVD3D9VertexDecl@Ogre@@HPBQAV12@ABQAV12@@std@@QAE@XZ

; 77   : 		{	// construct with pointer _Ptr
; 78   : 		_SCL_SECURE_VALIDATE(_Pvector != NULL && ((_Myvec *)_Pvector)->_Myfirst <= _Ptr && _Ptr <= ((_Myvec *)_Pvector)->_Mylast);

	cmp	DWORD PTR __Pvector$[ebp], 0
	je	SHORT $LN1@Vector_con@2
	mov	eax, DWORD PTR __Pvector$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	cmp	ecx, DWORD PTR __Ptr$[ebp]
	ja	SHORT $LN1@Vector_con@2
	mov	edx, DWORD PTR __Pvector$[ebp]
	mov	eax, DWORD PTR __Ptr$[ebp]
	cmp	eax, DWORD PTR [edx+16]
	jbe	SHORT $LN2@Vector_con@2
$LN1@Vector_con@2:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@Vector_con@2:

; 79   : 		this->_Set_container(_Pvector);

	mov	ecx, DWORD PTR __Pvector$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Set_container@_Iterator_base_aux@std@@QAEXQBV_Container_base_aux@2@@Z ; std::_Iterator_base_aux::_Set_container

; 80   : 		_Myptr = _Ptr;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR [edx+4], eax

; 81   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Vector_const_iterator@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@QAE@PAPAVD3D9VertexDecl@Ogre@@PBV_Container_base_aux@1@@Z ENDP ; std::_Vector_const_iterator<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >::_Vector_const_iterator<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??E?$_Vector_const_iterator@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??E?$_Vector_const_iterator@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >::operator++, COMDAT
; _this$ = ecx

; 115  : 		{	// preincrement

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 116  : 		_SCL_SECURE_VALIDATE(this->_Has_container());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Has_container@_Iterator_base_aux@std@@QBE_NXZ ; std::_Iterator_base_aux::_Has_container
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN2@operator@8
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@operator@8:

; 117  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getmycont@_Iterator_base_aux@std@@QBEPBV_Container_base_aux@2@XZ ; std::_Iterator_base_aux::_Getmycont
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, DWORD PTR [eax+16]
	jb	SHORT $LN1@operator@8
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN1@operator@8:

; 118  : 
; 119  :  #if _HAS_ITERATOR_DEBUGGING
; 120  : 		if (this->_Mycont == 0
; 121  : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 122  : 			_DEBUG_ERROR("vector iterator not incrementable");
; 123  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 124  : 
; 125  : 		++_Myptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 126  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 127  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??E?$_Vector_const_iterator@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >::operator++
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??G?$_Vector_const_iterator@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@QBEHABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??G?$_Vector_const_iterator@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@QBEHABV01@@Z PROC ; std::_Vector_const_iterator<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >::operator-, COMDAT
; _this$ = ecx

; 186  : 		{	// return difference of iterators

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 187  : 
; 188  :  #if _HAS_ITERATOR_DEBUGGING
; 189  : 		_Compat(_Right);
; 190  :  #else
; 191  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Has_container@_Iterator_base_aux@std@@QBE_NXZ ; std::_Iterator_base_aux::_Has_container
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@operator@9
	mov	ecx, DWORD PTR __Right$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Same_container@_Iterator_base_aux@std@@QBE_NABV12@@Z ; std::_Iterator_base_aux::_Same_container
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN2@operator@9
$LN1@operator@9:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@operator@9:

; 192  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 193  : 
; 194  : 		return (_Myptr - _Right._Myptr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [eax+4]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 195  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??G?$_Vector_const_iterator@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@QBEHABV01@@Z ENDP ; std::_Vector_const_iterator<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >::operator-
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0length_error@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0length_error@std@@QAE@ABV01@@Z$0
__ehfuncinfo$??0length_error@std@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0length_error@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0length_error@std@@QAE@ABV01@@Z PROC			; std::length_error::length_error, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0length_error@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0logic_error@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7length_error@std@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0length_error@std@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1logic_error@std@@UAE@XZ		; std::logic_error::~logic_error
__ehhandler$??0length_error@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0length_error@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0length_error@std@@QAE@ABV01@@Z ENDP			; std::length_error::length_error
PUBLIC	??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@PAVD3DRenderWindow@Ogre@@HPBQAV34@ABQAV34@V_Iterator_base_aux@2@@std@@QAE@XZ ; std::_Iterator_with_base<std::random_access_iterator_tag,Ogre::D3DRenderWindow *,int,Ogre::D3DRenderWindow * const *,Ogre::D3DRenderWindow * const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,Ogre::D3DRenderWindow *,int,Ogre::D3DRenderWindow * const *,Ogre::D3DRenderWindow * const &,std::_Iterator_base_aux>
; Function compile flags: /Odtp
;	COMDAT ??0?$_Ranit@PAVD3DRenderWindow@Ogre@@HPBQAV12@ABQAV12@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Ranit@PAVD3DRenderWindow@Ogre@@HPBQAV12@ABQAV12@@std@@QAE@XZ PROC ; std::_Ranit<Ogre::D3DRenderWindow *,int,Ogre::D3DRenderWindow * const *,Ogre::D3DRenderWindow * const &>::_Ranit<Ogre::D3DRenderWindow *,int,Ogre::D3DRenderWindow * const *,Ogre::D3DRenderWindow * const &>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@PAVD3DRenderWindow@Ogre@@HPBQAV34@ABQAV34@V_Iterator_base_aux@2@@std@@QAE@XZ
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Ranit@PAVD3DRenderWindow@Ogre@@HPBQAV12@ABQAV12@@std@@QAE@XZ ENDP ; std::_Ranit<Ogre::D3DRenderWindow *,int,Ogre::D3DRenderWindow * const *,Ogre::D3DRenderWindow * const &>::_Ranit<Ogre::D3DRenderWindow *,int,Ogre::D3DRenderWindow * const *,Ogre::D3DRenderWindow * const &>
_TEXT	ENDS
PUBLIC	??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@PAVD3D9VertexDecl@Ogre@@HPBQAV34@ABQAV34@V_Iterator_base_aux@2@@std@@QAE@XZ ; std::_Iterator_with_base<std::random_access_iterator_tag,Ogre::D3D9VertexDecl *,int,Ogre::D3D9VertexDecl * const *,Ogre::D3D9VertexDecl * const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,Ogre::D3D9VertexDecl *,int,Ogre::D3D9VertexDecl * const *,Ogre::D3D9VertexDecl * const &,std::_Iterator_base_aux>
; Function compile flags: /Odtp
;	COMDAT ??0?$_Ranit@PAVD3D9VertexDecl@Ogre@@HPBQAV12@ABQAV12@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Ranit@PAVD3D9VertexDecl@Ogre@@HPBQAV12@ABQAV12@@std@@QAE@XZ PROC ; std::_Ranit<Ogre::D3D9VertexDecl *,int,Ogre::D3D9VertexDecl * const *,Ogre::D3D9VertexDecl * const &>::_Ranit<Ogre::D3D9VertexDecl *,int,Ogre::D3D9VertexDecl * const *,Ogre::D3D9VertexDecl * const &>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@PAVD3D9VertexDecl@Ogre@@HPBQAV34@ABQAV34@V_Iterator_base_aux@2@@std@@QAE@XZ
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Ranit@PAVD3D9VertexDecl@Ogre@@HPBQAV12@ABQAV12@@std@@QAE@XZ ENDP ; std::_Ranit<Ogre::D3D9VertexDecl *,int,Ogre::D3D9VertexDecl * const *,Ogre::D3D9VertexDecl * const &>::_Ranit<Ogre::D3D9VertexDecl *,int,Ogre::D3D9VertexDecl * const *,Ogre::D3D9VertexDecl * const &>
_TEXT	ENDS
PUBLIC	??0_Iterator_base_aux@std@@QAE@XZ		; std::_Iterator_base_aux::_Iterator_base_aux
; Function compile flags: /Odtp
;	COMDAT ??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@PAVD3DRenderWindow@Ogre@@HPBQAV34@ABQAV34@V_Iterator_base_aux@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@PAVD3DRenderWindow@Ogre@@HPBQAV34@ABQAV34@V_Iterator_base_aux@2@@std@@QAE@XZ PROC ; std::_Iterator_with_base<std::random_access_iterator_tag,Ogre::D3DRenderWindow *,int,Ogre::D3DRenderWindow * const *,Ogre::D3DRenderWindow * const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,Ogre::D3DRenderWindow *,int,Ogre::D3DRenderWindow * const *,Ogre::D3DRenderWindow * const &,std::_Iterator_base_aux>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Iterator_base_aux@std@@QAE@XZ	; std::_Iterator_base_aux::_Iterator_base_aux
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@PAVD3DRenderWindow@Ogre@@HPBQAV34@ABQAV34@V_Iterator_base_aux@2@@std@@QAE@XZ ENDP ; std::_Iterator_with_base<std::random_access_iterator_tag,Ogre::D3DRenderWindow *,int,Ogre::D3DRenderWindow * const *,Ogre::D3DRenderWindow * const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,Ogre::D3DRenderWindow *,int,Ogre::D3DRenderWindow * const *,Ogre::D3DRenderWindow * const &,std::_Iterator_base_aux>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??0_Iterator_base_aux@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_Iterator_base_aux@std@@QAE@XZ PROC			; std::_Iterator_base_aux::_Iterator_base_aux, COMDAT
; _this$ = ecx

; 448  : 	_Iterator_base_aux()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0_Iterator_base_aux@std@@QAE@XZ ENDP			; std::_Iterator_base_aux::_Iterator_base_aux
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@PAVD3D9VertexDecl@Ogre@@HPBQAV34@ABQAV34@V_Iterator_base_aux@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@PAVD3D9VertexDecl@Ogre@@HPBQAV34@ABQAV34@V_Iterator_base_aux@2@@std@@QAE@XZ PROC ; std::_Iterator_with_base<std::random_access_iterator_tag,Ogre::D3D9VertexDecl *,int,Ogre::D3D9VertexDecl * const *,Ogre::D3D9VertexDecl * const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,Ogre::D3D9VertexDecl *,int,Ogre::D3D9VertexDecl * const *,Ogre::D3D9VertexDecl * const &,std::_Iterator_base_aux>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Iterator_base_aux@std@@QAE@XZ	; std::_Iterator_base_aux::_Iterator_base_aux
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@PAVD3D9VertexDecl@Ogre@@HPBQAV34@ABQAV34@V_Iterator_base_aux@2@@std@@QAE@XZ ENDP ; std::_Iterator_with_base<std::random_access_iterator_tag,Ogre::D3D9VertexDecl *,int,Ogre::D3D9VertexDecl * const *,Ogre::D3D9VertexDecl * const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,Ogre::D3D9VertexDecl *,int,Ogre::D3D9VertexDecl * const *,Ogre::D3D9VertexDecl * const &,std::_Iterator_base_aux>
_TEXT	ENDS
PUBLIC	??$_Allocate@V_Aux_cont@std@@@std@@YAPAV_Aux_cont@0@IPAV10@@Z ; std::_Allocate<std::_Aux_cont>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@V_Aux_cont@std@@@std@@QAEPAV_Aux_cont@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@V_Aux_cont@std@@@std@@QAEPAV_Aux_cont@2@I@Z PROC ; std::allocator<std::_Aux_cont>::allocate, COMDAT
; _this$ = ecx

; 144  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@V_Aux_cont@std@@@std@@YAPAV_Aux_cont@0@IPAV10@@Z ; std::_Allocate<std::_Aux_cont>
	add	esp, 8

; 146  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@V_Aux_cont@std@@@std@@QAEPAV_Aux_cont@2@I@Z ENDP ; std::allocator<std::_Aux_cont>::allocate
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@PAVD3DRenderWindow@Ogre@@@std@@QBEIXZ
_TEXT	SEGMENT
tv65 = -12						; size = 4
_this$ = -8						; size = 4
__Count$ = -4						; size = 4
?max_size@?$allocator@PAVD3DRenderWindow@Ogre@@@std@@QBEIXZ PROC ; std::allocator<Ogre::D3DRenderWindow *>::max_size, COMDAT
; _this$ = ecx

; 164  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);

	mov	DWORD PTR __Count$[ebp], 1073741823	; 3fffffffH

; 166  : 		return (0 < _Count ? _Count : 1);

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN3@max_size
	mov	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR tv65[ebp], eax
	jmp	SHORT $LN4@max_size
$LN3@max_size:
	mov	DWORD PTR tv65[ebp], 1
$LN4@max_size:
	mov	eax, DWORD PTR tv65[ebp]

; 167  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$allocator@PAVD3DRenderWindow@Ogre@@@std@@QBEIXZ ENDP ; std::allocator<Ogre::D3DRenderWindow *>::max_size
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@QBEIXZ
_TEXT	SEGMENT
tv65 = -12						; size = 4
_this$ = -8						; size = 4
__Count$ = -4						; size = 4
?max_size@?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@QBEIXZ PROC ; std::allocator<Ogre::D3D9VertexDecl *>::max_size, COMDAT
; _this$ = ecx

; 164  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);

	mov	DWORD PTR __Count$[ebp], 1073741823	; 3fffffffH

; 166  : 		return (0 < _Count ? _Count : 1);

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN3@max_size@2
	mov	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR tv65[ebp], eax
	jmp	SHORT $LN4@max_size@2
$LN3@max_size@2:
	mov	DWORD PTR tv65[ebp], 1
$LN4@max_size@2:
	mov	eax, DWORD PTR tv65[ebp]

; 167  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@QBEIXZ ENDP ; std::allocator<Ogre::D3D9VertexDecl *>::max_size
_TEXT	ENDS
PUBLIC	??Y?$_Vector_const_iterator@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >::operator+=
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??Y?$_Vector_iterator@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
??Y?$_Vector_iterator@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >::operator+=, COMDAT
; _this$ = ecx

; 374  : 		{	// increment by integer

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 375  : 		(*(_Mybase *)this) += _Off;

	mov	eax, DWORD PTR __Off$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??Y?$_Vector_const_iterator@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >::operator+=

; 376  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 377  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??Y?$_Vector_iterator@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >::operator+=
_TEXT	ENDS
PUBLIC	??Y?$_Vector_const_iterator@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >::operator+=
; Function compile flags: /Odtp
;	COMDAT ??Y?$_Vector_iterator@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
??Y?$_Vector_iterator@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >::operator+=, COMDAT
; _this$ = ecx

; 374  : 		{	// increment by integer

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 375  : 		(*(_Mybase *)this) += _Off;

	mov	eax, DWORD PTR __Off$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??Y?$_Vector_const_iterator@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >::operator+=

; 376  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 377  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??Y?$_Vector_iterator@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >::operator+=
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??Y?$_Vector_const_iterator@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
??Y?$_Vector_const_iterator@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >::operator+=, COMDAT
; _this$ = ecx

; 159  : 		{	// increment by integer

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 160  : 		_SCL_SECURE_VALIDATE(this->_Has_container());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Has_container@_Iterator_base_aux@std@@QBE_NXZ ; std::_Iterator_base_aux::_Has_container
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN3@operator@10
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN3@operator@10:

; 161  : 		_SCL_SECURE_VALIDATE_RANGE(

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR __Off$[ebp]
	lea	esi, DWORD PTR [edx+eax*4]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getmycont@_Iterator_base_aux@std@@QBEPBV_Container_base_aux@2@XZ ; std::_Iterator_base_aux::_Getmycont
	cmp	esi, DWORD PTR [eax+16]
	ja	SHORT $LN1@operator@10
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR __Off$[ebp]
	lea	esi, DWORD PTR [edx+eax*4]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getmycont@_Iterator_base_aux@std@@QBEPBV_Container_base_aux@2@XZ ; std::_Iterator_base_aux::_Getmycont
	cmp	esi, DWORD PTR [eax+12]
	jae	SHORT $LN2@operator@10
$LN1@operator@10:

; 162  : 			_Myptr + _Off <= ((_Myvec *)(this->_Getmycont()))->_Mylast &&
; 163  : 			_Myptr + _Off >= ((_Myvec *)(this->_Getmycont()))->_Myfirst);

	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@operator@10:

; 164  : 		_Myptr += _Off;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR __Off$[ebp]
	lea	ecx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 165  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 166  : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
??Y?$_Vector_const_iterator@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >::operator+=
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??Y?$_Vector_const_iterator@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
??Y?$_Vector_const_iterator@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >::operator+=, COMDAT
; _this$ = ecx

; 159  : 		{	// increment by integer

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 160  : 		_SCL_SECURE_VALIDATE(this->_Has_container());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Has_container@_Iterator_base_aux@std@@QBE_NXZ ; std::_Iterator_base_aux::_Has_container
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN3@operator@11
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN3@operator@11:

; 161  : 		_SCL_SECURE_VALIDATE_RANGE(

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR __Off$[ebp]
	lea	esi, DWORD PTR [edx+eax*4]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getmycont@_Iterator_base_aux@std@@QBEPBV_Container_base_aux@2@XZ ; std::_Iterator_base_aux::_Getmycont
	cmp	esi, DWORD PTR [eax+16]
	ja	SHORT $LN1@operator@11
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR __Off$[ebp]
	lea	esi, DWORD PTR [edx+eax*4]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getmycont@_Iterator_base_aux@std@@QBEPBV_Container_base_aux@2@XZ ; std::_Iterator_base_aux::_Getmycont
	cmp	esi, DWORD PTR [eax+12]
	jae	SHORT $LN2@operator@11
$LN1@operator@11:

; 162  : 			_Myptr + _Off <= ((_Myvec *)(this->_Getmycont()))->_Mylast &&
; 163  : 			_Myptr + _Off >= ((_Myvec *)(this->_Getmycont()))->_Myfirst);

	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@operator@11:

; 164  : 		_Myptr += _Off;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR __Off$[ebp]
	lea	ecx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 165  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 166  : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
??Y?$_Vector_const_iterator@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >::operator+=
_TEXT	ENDS
PUBLIC	?clear@?$vector@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@QAEXXZ ; std::vector<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >::clear
PUBLIC	??A?$vector@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@QAEAAPAVD3D9VertexDecl@Ogre@@I@Z ; std::vector<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >::operator[]
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogreprerequisites.h
;	COMDAT ??$DeletePointerArray@VD3D9VertexDecl@Ogre@@@Ogre@@YAXAAV?$vector@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@@Z
_TEXT	SEGMENT
tv75 = -16						; size = 4
$T160285 = -12						; size = 4
$T160284 = -8						; size = 4
_i$156120 = -4						; size = 4
_array$ = 8						; size = 4
??$DeletePointerArray@VD3D9VertexDecl@Ogre@@@Ogre@@YAXAAV?$vector@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@@Z PROC ; Ogre::DeletePointerArray<Ogre::D3D9VertexDecl>, COMDAT

; 271  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 272  : 		for(size_t i=0; i<array.size(); i++)

	mov	DWORD PTR _i$156120[ebp], 0
	jmp	SHORT $LN3@DeletePoin
$LN2@DeletePoin:
	mov	eax, DWORD PTR _i$156120[ebp]
	add	eax, 1
	mov	DWORD PTR _i$156120[ebp], eax
$LN3@DeletePoin:
	mov	ecx, DWORD PTR _array$[ebp]
	call	?size@?$vector@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >::size
	cmp	DWORD PTR _i$156120[ebp], eax
	jae	SHORT $LN1@DeletePoin

; 273  : 		{
; 274  : 			delete array[i];

	mov	ecx, DWORD PTR _i$156120[ebp]
	push	ecx
	mov	ecx, DWORD PTR _array$[ebp]
	call	??A?$vector@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@QAEAAPAVD3D9VertexDecl@Ogre@@I@Z ; std::vector<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >::operator[]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR $T160285[ebp], edx
	mov	eax, DWORD PTR $T160285[ebp]
	mov	DWORD PTR $T160284[ebp], eax
	cmp	DWORD PTR $T160284[ebp], 0
	je	SHORT $LN6@DeletePoin
	push	1
	mov	ecx, DWORD PTR $T160284[ebp]
	call	??_GD3D9VertexDecl@Ogre@@QAEPAXI@Z
	mov	DWORD PTR tv75[ebp], eax
	jmp	SHORT $LN7@DeletePoin
$LN6@DeletePoin:
	mov	DWORD PTR tv75[ebp], 0
$LN7@DeletePoin:

; 275  : 		}

	jmp	SHORT $LN2@DeletePoin
$LN1@DeletePoin:

; 276  : 		array.clear();

	mov	ecx, DWORD PTR _array$[ebp]
	call	?clear@?$vector@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@QAEXXZ ; std::vector<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >::clear

; 277  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$DeletePointerArray@VD3D9VertexDecl@Ogre@@@Ogre@@YAXAAV?$vector@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@@Z ENDP ; Ogre::DeletePointerArray<Ogre::D3D9VertexDecl>
_TEXT	ENDS
EXTRN	__imp___vsnprintf_s:PROC
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\stdio.h
;	COMDAT ??$_snprintf_s@$0BAA@@@YAHAAY0BAA@DIPBDZZ
_TEXT	SEGMENT
__ArgList$ = -4						; size = 4
__Dest$ = 8						; size = 4
__MaxCount$ = 12					; size = 4
__Format$ = 16						; size = 4
??$_snprintf_s@$0BAA@@@YAHAAY0BAA@DIPBDZZ PROC		; _snprintf_s<256>, COMDAT

; 318  : __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_2_ARGLIST(int, _snprintf_s, _vsnprintf_s, char, _Dest, _In_ size_t, _MaxCount, _In_z_ _Printf_format_string_ const char *,_Format)

	push	ebp
	mov	ebp, esp
	push	ecx
	lea	eax, DWORD PTR __Format$[ebp+4]
	mov	DWORD PTR __ArgList$[ebp], eax
	mov	ecx, DWORD PTR __ArgList$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Format$[ebp]
	push	edx
	mov	eax, DWORD PTR __MaxCount$[ebp]
	push	eax
	push	256					; 00000100H
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	DWORD PTR __imp___vsnprintf_s
	add	esp, 20					; 00000014H
	mov	esp, ebp
	pop	ebp
	ret	0
??$_snprintf_s@$0BAA@@@YAHAAY0BAA@DIPBDZZ ENDP		; _snprintf_s<256>
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAPAVD3DRenderWindow@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@@std@@YAPAPAVD3DRenderWindow@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<Ogre::D3DRenderWindow * *,Ogre::D3DRenderWindow * *,std::random_access_iterator_tag>
PUBLIC	??$_Checked_base@PAPAVD3DRenderWindow@Ogre@@@std@@YAPAPAVD3DRenderWindow@Ogre@@AAPAPAV12@@Z ; std::_Checked_base<Ogre::D3DRenderWindow * *>
PUBLIC	??$_Iter_random@PAPAVD3DRenderWindow@Ogre@@PAPAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVD3DRenderWindow@Ogre@@0@Z ; std::_Iter_random<Ogre::D3DRenderWindow * *,Ogre::D3DRenderWindow * *>
PUBLIC	??$_Ptr_cat@PAPAVD3DRenderWindow@Ogre@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVD3DRenderWindow@Ogre@@0@Z ; std::_Ptr_cat<Ogre::D3DRenderWindow * *,Ogre::D3DRenderWindow * *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$unchecked_copy@PAPAVD3DRenderWindow@Ogre@@PAPAV12@@stdext@@YAPAPAVD3DRenderWindow@Ogre@@PAPAV12@00@Z
_TEXT	SEGMENT
$T160294 = -3						; size = 1
$T160293 = -2						; size = 1
$T160292 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAPAVD3DRenderWindow@Ogre@@PAPAV12@@stdext@@YAPAPAVD3DRenderWindow@Ogre@@PAPAV12@00@Z PROC ; stdext::unchecked_copy<Ogre::D3DRenderWindow * *,Ogre::D3DRenderWindow * *>, COMDAT

; 3604 : 	{	// copy [_First, _Last) to [_Dest, ...)

	push	ebp
	mov	ebp, esp
	push	ecx

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T160292[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAPAVD3DRenderWindow@Ogre@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVD3DRenderWindow@Ogre@@0@Z ; std::_Ptr_cat<Ogre::D3DRenderWindow * *,Ogre::D3DRenderWindow * *>
	add	esp, 8
	mov	BYTE PTR $T160293[ebp], al
	movzx	eax, BYTE PTR $T160292[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T160293[ebp]
	push	ecx
	lea	edx, DWORD PTR __Dest$[ebp]
	push	edx
	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T160294[ebp]
	push	ecx
	call	??$_Iter_random@PAPAVD3DRenderWindow@Ogre@@PAPAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVD3DRenderWindow@Ogre@@0@Z ; std::_Iter_random<Ogre::D3DRenderWindow * *,Ogre::D3DRenderWindow * *>
	add	esp, 12					; 0000000cH
	movzx	edx, BYTE PTR [eax]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@PAPAVD3DRenderWindow@Ogre@@@std@@YAPAPAVD3DRenderWindow@Ogre@@AAPAPAV12@@Z ; std::_Checked_base<Ogre::D3DRenderWindow * *>
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@PAPAVD3DRenderWindow@Ogre@@@std@@YAPAPAVD3DRenderWindow@Ogre@@AAPAPAV12@@Z ; std::_Checked_base<Ogre::D3DRenderWindow * *>
	add	esp, 4
	push	eax
	call	??$_Copy_opt@PAPAVD3DRenderWindow@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@@std@@YAPAPAVD3DRenderWindow@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<Ogre::D3DRenderWindow * *,Ogre::D3DRenderWindow * *,std::random_access_iterator_tag>
	add	esp, 24					; 00000018H

; 3607 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_copy@PAPAVD3DRenderWindow@Ogre@@PAPAV12@@stdext@@YAPAPAVD3DRenderWindow@Ogre@@PAPAV12@00@Z ENDP ; stdext::unchecked_copy<Ogre::D3DRenderWindow * *,Ogre::D3DRenderWindow * *>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@YAXPAPAVD3DRenderWindow@Ogre@@0AAV?$allocator@PAVD3DRenderWindow@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<Ogre::D3DRenderWindow *> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@YAXPAPAVD3DRenderWindow@Ogre@@0AAV?$allocator@PAVD3DRenderWindow@Ogre@@@0@@Z
_TEXT	SEGMENT
$T160297 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@YAXPAPAVD3DRenderWindow@Ogre@@0AAV?$allocator@PAVD3DRenderWindow@Ogre@@@0@@Z PROC ; std::_Destroy_range<std::allocator<Ogre::D3DRenderWindow *> >, COMDAT

; 224  : 	{	// destroy [_First, _Last)

	push	ebp
	mov	ebp, esp
	push	ecx

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Ptr_cat@PAPAVD3DRenderWindow@Ogre@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVD3DRenderWindow@Ogre@@0@Z ; std::_Ptr_cat<Ogre::D3DRenderWindow * *,Ogre::D3DRenderWindow * *>
	add	esp, 8
	mov	BYTE PTR $T160297[ebp], al
	movzx	edx, BYTE PTR $T160297[ebp]
	push	edx
	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Destroy_range@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@YAXPAPAVD3DRenderWindow@Ogre@@0AAV?$allocator@PAVD3DRenderWindow@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<Ogre::D3DRenderWindow *> >
	add	esp, 16					; 00000010H

; 226  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Destroy_range@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@YAXPAPAVD3DRenderWindow@Ogre@@0AAV?$allocator@PAVD3DRenderWindow@Ogre@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<Ogre::D3DRenderWindow *> >
_TEXT	ENDS
PUBLIC	??$_Uninit_fill_n@PAPAVD3DRenderWindow@Ogre@@IPAV12@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@YAXPAPAVD3DRenderWindow@Ogre@@IABQAV12@AAV?$allocator@PAVD3DRenderWindow@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<Ogre::D3DRenderWindow * *,unsigned int,Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_fill_n@PAPAVD3DRenderWindow@Ogre@@IPAV12@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@stdext@@YAXPAPAVD3DRenderWindow@Ogre@@IABQAV12@AAV?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@Z
_TEXT	SEGMENT
$T160301 = -2						; size = 1
$T160300 = -1						; size = 1
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_fill_n@PAPAVD3DRenderWindow@Ogre@@IPAV12@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@stdext@@YAXPAPAVD3DRenderWindow@Ogre@@IABQAV12@AAV?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@Z PROC ; stdext::unchecked_uninitialized_fill_n<Ogre::D3DRenderWindow * *,unsigned int,Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >, COMDAT

; 940  : 	{	// copy _Count *_Val to raw _First, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 941  : 	_STD _Uninit_fill_n(_First, _Count, _Val, _Al,
; 942  : 		_STD _Ptr_cat(_First, _First), _STD _Range_checked_iterator_tag());

	xor	eax, eax
	mov	BYTE PTR $T160300[ebp], al
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAPAVD3DRenderWindow@Ogre@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVD3DRenderWindow@Ogre@@0@Z ; std::_Ptr_cat<Ogre::D3DRenderWindow * *,Ogre::D3DRenderWindow * *>
	add	esp, 8
	mov	BYTE PTR $T160301[ebp], al
	movzx	eax, BYTE PTR $T160300[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T160301[ebp]
	push	ecx
	mov	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Uninit_fill_n@PAPAVD3DRenderWindow@Ogre@@IPAV12@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@YAXPAPAVD3DRenderWindow@Ogre@@IABQAV12@AAV?$allocator@PAVD3DRenderWindow@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<Ogre::D3DRenderWindow * *,unsigned int,Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >
	add	esp, 24					; 00000018H

; 943  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_fill_n@PAPAVD3DRenderWindow@Ogre@@IPAV12@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@stdext@@YAXPAPAVD3DRenderWindow@Ogre@@IABQAV12@AAV?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_fill_n<Ogre::D3DRenderWindow * *,unsigned int,Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >
_TEXT	ENDS
PUBLIC	??$_Uninit_fill_n@PAPAVD3D9VertexDecl@Ogre@@IPAV12@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@YAXPAPAVD3D9VertexDecl@Ogre@@IABQAV12@AAV?$allocator@PAVD3D9VertexDecl@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<Ogre::D3D9VertexDecl * *,unsigned int,Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >
PUBLIC	??$_Ptr_cat@PAPAVD3D9VertexDecl@Ogre@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVD3D9VertexDecl@Ogre@@0@Z ; std::_Ptr_cat<Ogre::D3D9VertexDecl * *,Ogre::D3D9VertexDecl * *>
; Function compile flags: /Odtp
;	COMDAT ??$unchecked_uninitialized_fill_n@PAPAVD3D9VertexDecl@Ogre@@IPAV12@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@stdext@@YAXPAPAVD3D9VertexDecl@Ogre@@IABQAV12@AAV?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@Z
_TEXT	SEGMENT
$T160305 = -2						; size = 1
$T160304 = -1						; size = 1
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_fill_n@PAPAVD3D9VertexDecl@Ogre@@IPAV12@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@stdext@@YAXPAPAVD3D9VertexDecl@Ogre@@IABQAV12@AAV?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@Z PROC ; stdext::unchecked_uninitialized_fill_n<Ogre::D3D9VertexDecl * *,unsigned int,Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >, COMDAT

; 940  : 	{	// copy _Count *_Val to raw _First, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 941  : 	_STD _Uninit_fill_n(_First, _Count, _Val, _Al,
; 942  : 		_STD _Ptr_cat(_First, _First), _STD _Range_checked_iterator_tag());

	xor	eax, eax
	mov	BYTE PTR $T160304[ebp], al
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAPAVD3D9VertexDecl@Ogre@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVD3D9VertexDecl@Ogre@@0@Z ; std::_Ptr_cat<Ogre::D3D9VertexDecl * *,Ogre::D3D9VertexDecl * *>
	add	esp, 8
	mov	BYTE PTR $T160305[ebp], al
	movzx	eax, BYTE PTR $T160304[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T160305[ebp]
	push	ecx
	mov	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Uninit_fill_n@PAPAVD3D9VertexDecl@Ogre@@IPAV12@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@YAXPAPAVD3D9VertexDecl@Ogre@@IABQAV12@AAV?$allocator@PAVD3D9VertexDecl@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<Ogre::D3D9VertexDecl * *,unsigned int,Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >
	add	esp, 24					; 00000018H

; 943  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_fill_n@PAPAVD3D9VertexDecl@Ogre@@IPAV12@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@stdext@@YAXPAPAVD3D9VertexDecl@Ogre@@IABQAV12@AAV?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_fill_n<Ogre::D3D9VertexDecl * *,unsigned int,Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >
_TEXT	ENDS
PUBLIC	??$_Unchecked_uninitialized_move@PAPAVD3DRenderWindow@Ogre@@PAPAV12@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@stdext@@YAPAPAVD3DRenderWindow@Ogre@@PAPAV12@00AAV?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@Z ; stdext::_Unchecked_uninitialized_move<Ogre::D3DRenderWindow * *,Ogre::D3DRenderWindow * *,std::allocator<Ogre::D3DRenderWindow *> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??$_Umove@PAPAVD3DRenderWindow@Ogre@@@?$vector@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@IAEPAPAVD3DRenderWindow@Ogre@@PAPAV23@00@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Umove@PAPAVD3DRenderWindow@Ogre@@@?$vector@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@IAEPAPAVD3DRenderWindow@Ogre@@PAPAV23@00@Z PROC ; std::vector<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >::_Umove<Ogre::D3DRenderWindow * *>, COMDAT
; _this$ = ecx

; 1145 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1146 : 		{	// move initializing [_First, _Last), using allocator
; 1147 : 		return (_STDEXT _Unchecked_uninitialized_move(_First, _Last,
; 1148 : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Unchecked_uninitialized_move@PAPAVD3DRenderWindow@Ogre@@PAPAV12@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@stdext@@YAPAPAVD3DRenderWindow@Ogre@@PAPAV12@00AAV?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@Z ; stdext::_Unchecked_uninitialized_move<Ogre::D3DRenderWindow * *,Ogre::D3DRenderWindow * *,std::allocator<Ogre::D3DRenderWindow *> >
	add	esp, 16					; 00000010H

; 1149 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??$_Umove@PAPAVD3DRenderWindow@Ogre@@@?$vector@PAVD3DRenderWindow@Ogre@@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@IAEPAPAVD3DRenderWindow@Ogre@@PAPAV23@00@Z ENDP ; std::vector<Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >::_Umove<Ogre::D3DRenderWindow * *>
_TEXT	ENDS
PUBLIC	??$_Fill@PAPAVD3DRenderWindow@Ogre@@PAV12@@std@@YAXPAPAVD3DRenderWindow@Ogre@@0ABQAV12@@Z ; std::_Fill<Ogre::D3DRenderWindow * *,Ogre::D3DRenderWindow *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$fill@PAPAVD3DRenderWindow@Ogre@@PAV12@@std@@YAXPAPAVD3DRenderWindow@Ogre@@0ABQAV12@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$fill@PAPAVD3DRenderWindow@Ogre@@PAV12@@std@@YAXPAPAVD3DRenderWindow@Ogre@@0ABQAV12@@Z PROC ; std::fill<Ogre::D3DRenderWindow * *,Ogre::D3DRenderWindow *>, COMDAT

; 3186 : 	{	// copy _Val through [_First, _Last)

	push	ebp
	mov	ebp, esp

; 3187 : 	_Fill(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@PAPAVD3DRenderWindow@Ogre@@@std@@YAPAPAVD3DRenderWindow@Ogre@@AAPAPAV12@@Z ; std::_Checked_base<Ogre::D3DRenderWindow * *>
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@PAPAVD3DRenderWindow@Ogre@@@std@@YAPAPAVD3DRenderWindow@Ogre@@AAPAPAV12@@Z ; std::_Checked_base<Ogre::D3DRenderWindow * *>
	add	esp, 4
	push	eax
	call	??$_Fill@PAPAVD3DRenderWindow@Ogre@@PAV12@@std@@YAXPAPAVD3DRenderWindow@Ogre@@0ABQAV12@@Z ; std::_Fill<Ogre::D3DRenderWindow * *,Ogre::D3DRenderWindow *>
	add	esp, 12					; 0000000cH

; 3188 : 	}

	pop	ebp
	ret	0
??$fill@PAPAVD3DRenderWindow@Ogre@@PAV12@@std@@YAXPAPAVD3DRenderWindow@Ogre@@0ABQAV12@@Z ENDP ; std::fill<Ogre::D3DRenderWindow * *,Ogre::D3DRenderWindow *>
_TEXT	ENDS
PUBLIC	??$_Move_backward_opt@PAPAVD3DRenderWindow@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@4@@std@@YAPAPAVD3DRenderWindow@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Move_backward_opt<Ogre::D3DRenderWindow * *,Ogre::D3DRenderWindow * *,std::random_access_iterator_tag,std::_Undefined_move_tag>
PUBLIC	??$_Move_cat@PAPAVD3DRenderWindow@Ogre@@@std@@YA?AU_Undefined_move_tag@0@ABQAPAVD3DRenderWindow@Ogre@@@Z ; std::_Move_cat<Ogre::D3DRenderWindow * *>
; Function compile flags: /Odtp
;	COMDAT ??$_Unchecked_move_backward@PAPAVD3DRenderWindow@Ogre@@PAPAV12@@stdext@@YAPAPAVD3DRenderWindow@Ogre@@PAPAV12@00@Z
_TEXT	SEGMENT
$T160314 = -3						; size = 1
$T160313 = -2						; size = 1
$T160312 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Unchecked_move_backward@PAPAVD3DRenderWindow@Ogre@@PAPAV12@@stdext@@YAPAPAVD3DRenderWindow@Ogre@@PAPAV12@00@Z PROC ; stdext::_Unchecked_move_backward<Ogre::D3DRenderWindow * *,Ogre::D3DRenderWindow * *>, COMDAT

; 3694 : 	{	// move [_First, _Last) backwards to [..., _Dest)

	push	ebp
	mov	ebp, esp
	push	ecx

; 3695 : 		return (_STD _Move_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3696 : 			_STD _Iter_random(_First, _Dest), _STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T160312[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	??$_Move_cat@PAPAVD3DRenderWindow@Ogre@@@std@@YA?AU_Undefined_move_tag@0@ABQAPAVD3DRenderWindow@Ogre@@@Z ; std::_Move_cat<Ogre::D3DRenderWindow * *>
	add	esp, 4
	mov	BYTE PTR $T160313[ebp], al
	movzx	edx, BYTE PTR $T160312[ebp]
	push	edx
	movzx	eax, BYTE PTR $T160313[ebp]
	push	eax
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	lea	eax, DWORD PTR $T160314[ebp]
	push	eax
	call	??$_Iter_random@PAPAVD3DRenderWindow@Ogre@@PAPAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVD3DRenderWindow@Ogre@@0@Z ; std::_Iter_random<Ogre::D3DRenderWindow * *,Ogre::D3DRenderWindow * *>
	add	esp, 12					; 0000000cH
	movzx	ecx, BYTE PTR [eax]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	call	??$_Checked_base@PAPAVD3DRenderWindow@Ogre@@@std@@YAPAPAVD3DRenderWindow@Ogre@@AAPAPAV12@@Z ; std::_Checked_base<Ogre::D3DRenderWindow * *>
	add	esp, 4
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Checked_base@PAPAVD3DRenderWindow@Ogre@@@std@@YAPAPAVD3DRenderWindow@Ogre@@AAPAPAV12@@Z ; std::_Checked_base<Ogre::D3DRenderWindow * *>
	add	esp, 4
	push	eax
	call	??$_Move_backward_opt@PAPAVD3DRenderWindow@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@4@@std@@YAPAPAVD3DRenderWindow@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Move_backward_opt<Ogre::D3DRenderWindow * *,Ogre::D3DRenderWindow * *,std::random_access_iterator_tag,std::_Undefined_move_tag>
	add	esp, 24					; 00000018H

; 3697 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Unchecked_move_backward@PAPAVD3DRenderWindow@Ogre@@PAPAV12@@stdext@@YAPAPAVD3DRenderWindow@Ogre@@PAPAV12@00@Z ENDP ; stdext::_Unchecked_move_backward<Ogre::D3DRenderWindow * *,Ogre::D3DRenderWindow * *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$?0PAVD3DRenderWindow@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@PAVD3DRenderWindow@Ogre@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??$?0PAVD3DRenderWindow@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@PAVD3DRenderWindow@Ogre@@@1@@Z PROC ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::D3DRenderWindow *>, COMDAT
; _this$ = ecx

; 128  : 		allocator(const allocator<_Other>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0PAVD3DRenderWindow@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@PAVD3DRenderWindow@Ogre@@@1@@Z ENDP ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::D3DRenderWindow *>
_TEXT	ENDS
PUBLIC	__TI2?AVbad_alloc@std@@
PUBLIC	??0bad_alloc@std@@QAE@PBD@Z			; std::bad_alloc::bad_alloc
PUBLIC	??1bad_alloc@std@@UAE@XZ			; std::bad_alloc::~bad_alloc
PUBLIC	__CTA2?AVbad_alloc@std@@
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
;	COMDAT ??_R0?AVbad_alloc@std@@@8
_DATA	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_alloc@std@@
xdata$x	SEGMENT
__CTA2?AVbad_alloc@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI2?AVbad_alloc@std@@
xdata$x	SEGMENT
__TI2?AVbad_alloc@std@@ DD 00H
	DD	FLAT:??1bad_alloc@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVbad_alloc@std@@
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??$_Allocate@PAVD3DRenderWindow@Ogre@@@std@@YAPAPAVD3DRenderWindow@Ogre@@IPAPAV12@@Z
_TEXT	SEGMENT
$T160319 = -12						; size = 12
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@PAVD3DRenderWindow@Ogre@@@std@@YAPAPAVD3DRenderWindow@Ogre@@IPAPAV12@@Z PROC ; std::_Allocate<Ogre::D3DRenderWindow *>, COMDAT

; 36   : 	{	// check for integer overflow

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 37   : 	if (_Count <= 0)

	cmp	DWORD PTR __Count$[ebp], 0
	ja	SHORT $LN3@Allocate

; 38   : 		_Count = 0;

	mov	DWORD PTR __Count$[ebp], 0
	jmp	SHORT $LN2@Allocate
$LN3@Allocate:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Count$[ebp]
	cmp	eax, 4
	jae	SHORT $LN2@Allocate

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	push	0
	lea	ecx, DWORD PTR $T160319[ebp]
	call	??0bad_alloc@std@@QAE@PBD@Z		; std::bad_alloc::bad_alloc
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	eax, DWORD PTR $T160319[ebp]
	push	eax
	call	__CxxThrowException@8
$LN2@Allocate:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 2
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
$LN5@Allocate:

; 44   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@PAVD3DRenderWindow@Ogre@@@std@@YAPAPAVD3DRenderWindow@Ogre@@IPAPAV12@@Z ENDP ; std::_Allocate<Ogre::D3DRenderWindow *>
_TEXT	ENDS
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	__imp_??0exception@std@@QAE@ABQBD@Z:PROC
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	?what@exception@std@@UBEPBDXZ:PROC		; std::exception::what
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0bad_alloc@std@@QAE@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0bad_alloc@std@@QAE@PBD@Z$0
__ehfuncinfo$??0bad_alloc@std@@QAE@PBD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0bad_alloc@std@@QAE@PBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@PBD@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Message$ = 8						; size = 4
??0bad_alloc@std@@QAE@PBD@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx

; 371  : 		{	// construct from message string

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0bad_alloc@std@@QAE@PBD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	lea	eax, DWORD PTR __Message$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7bad_alloc@std@@6B@

; 372  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0bad_alloc@std@@QAE@PBD@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??0bad_alloc@std@@QAE@PBD@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0bad_alloc@std@@QAE@PBD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0bad_alloc@std@@QAE@PBD@Z ENDP			; std::bad_alloc::bad_alloc
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1bad_alloc@std@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1bad_alloc@std@@UAE@XZ$0
__ehfuncinfo$??1bad_alloc@std@@UAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1bad_alloc@std@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1bad_alloc@std@@UAE@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
; _this$ = ecx

; 380  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1bad_alloc@std@@UAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 381  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1bad_alloc@std@@UAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??1bad_alloc@std@@UAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1bad_alloc@std@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1bad_alloc@std@@UAE@XZ ENDP				; std::bad_alloc::~bad_alloc
; Function compile flags: /Odtp
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1bad_alloc@std@@UAE@XZ		; std::bad_alloc::~bad_alloc
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@6
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@6:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@YAXPAPAVD3D9VertexDecl@Ogre@@0AAV?$allocator@PAVD3D9VertexDecl@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<Ogre::D3D9VertexDecl *> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@YAXPAPAVD3D9VertexDecl@Ogre@@0AAV?$allocator@PAVD3D9VertexDecl@Ogre@@@0@@Z
_TEXT	SEGMENT
$T160342 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@YAXPAPAVD3D9VertexDecl@Ogre@@0AAV?$allocator@PAVD3D9VertexDecl@Ogre@@@0@@Z PROC ; std::_Destroy_range<std::allocator<Ogre::D3D9VertexDecl *> >, COMDAT

; 224  : 	{	// destroy [_First, _Last)

	push	ebp
	mov	ebp, esp
	push	ecx

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Ptr_cat@PAPAVD3D9VertexDecl@Ogre@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVD3D9VertexDecl@Ogre@@0@Z ; std::_Ptr_cat<Ogre::D3D9VertexDecl * *,Ogre::D3D9VertexDecl * *>
	add	esp, 8
	mov	BYTE PTR $T160342[ebp], al
	movzx	edx, BYTE PTR $T160342[ebp]
	push	edx
	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Destroy_range@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@YAXPAPAVD3D9VertexDecl@Ogre@@0AAV?$allocator@PAVD3D9VertexDecl@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<Ogre::D3D9VertexDecl *> >
	add	esp, 16					; 00000010H

; 226  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Destroy_range@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@YAXPAPAVD3D9VertexDecl@Ogre@@0AAV?$allocator@PAVD3D9VertexDecl@Ogre@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<Ogre::D3D9VertexDecl *> >
_TEXT	ENDS
PUBLIC	??$_Unchecked_uninitialized_move@PAPAVD3D9VertexDecl@Ogre@@PAPAV12@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@stdext@@YAPAPAVD3D9VertexDecl@Ogre@@PAPAV12@00AAV?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@Z ; stdext::_Unchecked_uninitialized_move<Ogre::D3D9VertexDecl * *,Ogre::D3D9VertexDecl * *,std::allocator<Ogre::D3D9VertexDecl *> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??$_Umove@PAPAVD3D9VertexDecl@Ogre@@@?$vector@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@IAEPAPAVD3D9VertexDecl@Ogre@@PAPAV23@00@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Umove@PAPAVD3D9VertexDecl@Ogre@@@?$vector@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@IAEPAPAVD3D9VertexDecl@Ogre@@PAPAV23@00@Z PROC ; std::vector<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >::_Umove<Ogre::D3D9VertexDecl * *>, COMDAT
; _this$ = ecx

; 1145 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1146 : 		{	// move initializing [_First, _Last), using allocator
; 1147 : 		return (_STDEXT _Unchecked_uninitialized_move(_First, _Last,
; 1148 : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Unchecked_uninitialized_move@PAPAVD3D9VertexDecl@Ogre@@PAPAV12@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@stdext@@YAPAPAVD3D9VertexDecl@Ogre@@PAPAV12@00AAV?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@Z ; stdext::_Unchecked_uninitialized_move<Ogre::D3D9VertexDecl * *,Ogre::D3D9VertexDecl * *,std::allocator<Ogre::D3D9VertexDecl *> >
	add	esp, 16					; 00000010H

; 1149 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??$_Umove@PAPAVD3D9VertexDecl@Ogre@@@?$vector@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@IAEPAPAVD3D9VertexDecl@Ogre@@PAPAV23@00@Z ENDP ; std::vector<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >::_Umove<Ogre::D3D9VertexDecl * *>
_TEXT	ENDS
PUBLIC	??$_Fill@PAPAVD3D9VertexDecl@Ogre@@PAV12@@std@@YAXPAPAVD3D9VertexDecl@Ogre@@0ABQAV12@@Z ; std::_Fill<Ogre::D3D9VertexDecl * *,Ogre::D3D9VertexDecl *>
PUBLIC	??$_Checked_base@PAPAVD3D9VertexDecl@Ogre@@@std@@YAPAPAVD3D9VertexDecl@Ogre@@AAPAPAV12@@Z ; std::_Checked_base<Ogre::D3D9VertexDecl * *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$fill@PAPAVD3D9VertexDecl@Ogre@@PAV12@@std@@YAXPAPAVD3D9VertexDecl@Ogre@@0ABQAV12@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$fill@PAPAVD3D9VertexDecl@Ogre@@PAV12@@std@@YAXPAPAVD3D9VertexDecl@Ogre@@0ABQAV12@@Z PROC ; std::fill<Ogre::D3D9VertexDecl * *,Ogre::D3D9VertexDecl *>, COMDAT

; 3186 : 	{	// copy _Val through [_First, _Last)

	push	ebp
	mov	ebp, esp

; 3187 : 	_Fill(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@PAPAVD3D9VertexDecl@Ogre@@@std@@YAPAPAVD3D9VertexDecl@Ogre@@AAPAPAV12@@Z ; std::_Checked_base<Ogre::D3D9VertexDecl * *>
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@PAPAVD3D9VertexDecl@Ogre@@@std@@YAPAPAVD3D9VertexDecl@Ogre@@AAPAPAV12@@Z ; std::_Checked_base<Ogre::D3D9VertexDecl * *>
	add	esp, 4
	push	eax
	call	??$_Fill@PAPAVD3D9VertexDecl@Ogre@@PAV12@@std@@YAXPAPAVD3D9VertexDecl@Ogre@@0ABQAV12@@Z ; std::_Fill<Ogre::D3D9VertexDecl * *,Ogre::D3D9VertexDecl *>
	add	esp, 12					; 0000000cH

; 3188 : 	}

	pop	ebp
	ret	0
??$fill@PAPAVD3D9VertexDecl@Ogre@@PAV12@@std@@YAXPAPAVD3D9VertexDecl@Ogre@@0ABQAV12@@Z ENDP ; std::fill<Ogre::D3D9VertexDecl * *,Ogre::D3D9VertexDecl *>
_TEXT	ENDS
PUBLIC	??$_Move_backward_opt@PAPAVD3D9VertexDecl@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@4@@std@@YAPAPAVD3D9VertexDecl@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Move_backward_opt<Ogre::D3D9VertexDecl * *,Ogre::D3D9VertexDecl * *,std::random_access_iterator_tag,std::_Undefined_move_tag>
PUBLIC	??$_Iter_random@PAPAVD3D9VertexDecl@Ogre@@PAPAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVD3D9VertexDecl@Ogre@@0@Z ; std::_Iter_random<Ogre::D3D9VertexDecl * *,Ogre::D3D9VertexDecl * *>
PUBLIC	??$_Move_cat@PAPAVD3D9VertexDecl@Ogre@@@std@@YA?AU_Undefined_move_tag@0@ABQAPAVD3D9VertexDecl@Ogre@@@Z ; std::_Move_cat<Ogre::D3D9VertexDecl * *>
; Function compile flags: /Odtp
;	COMDAT ??$_Unchecked_move_backward@PAPAVD3D9VertexDecl@Ogre@@PAPAV12@@stdext@@YAPAPAVD3D9VertexDecl@Ogre@@PAPAV12@00@Z
_TEXT	SEGMENT
$T160351 = -3						; size = 1
$T160350 = -2						; size = 1
$T160349 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Unchecked_move_backward@PAPAVD3D9VertexDecl@Ogre@@PAPAV12@@stdext@@YAPAPAVD3D9VertexDecl@Ogre@@PAPAV12@00@Z PROC ; stdext::_Unchecked_move_backward<Ogre::D3D9VertexDecl * *,Ogre::D3D9VertexDecl * *>, COMDAT

; 3694 : 	{	// move [_First, _Last) backwards to [..., _Dest)

	push	ebp
	mov	ebp, esp
	push	ecx

; 3695 : 		return (_STD _Move_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3696 : 			_STD _Iter_random(_First, _Dest), _STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T160349[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	??$_Move_cat@PAPAVD3D9VertexDecl@Ogre@@@std@@YA?AU_Undefined_move_tag@0@ABQAPAVD3D9VertexDecl@Ogre@@@Z ; std::_Move_cat<Ogre::D3D9VertexDecl * *>
	add	esp, 4
	mov	BYTE PTR $T160350[ebp], al
	movzx	edx, BYTE PTR $T160349[ebp]
	push	edx
	movzx	eax, BYTE PTR $T160350[ebp]
	push	eax
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	lea	eax, DWORD PTR $T160351[ebp]
	push	eax
	call	??$_Iter_random@PAPAVD3D9VertexDecl@Ogre@@PAPAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVD3D9VertexDecl@Ogre@@0@Z ; std::_Iter_random<Ogre::D3D9VertexDecl * *,Ogre::D3D9VertexDecl * *>
	add	esp, 12					; 0000000cH
	movzx	ecx, BYTE PTR [eax]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	call	??$_Checked_base@PAPAVD3D9VertexDecl@Ogre@@@std@@YAPAPAVD3D9VertexDecl@Ogre@@AAPAPAV12@@Z ; std::_Checked_base<Ogre::D3D9VertexDecl * *>
	add	esp, 4
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Checked_base@PAPAVD3D9VertexDecl@Ogre@@@std@@YAPAPAVD3D9VertexDecl@Ogre@@AAPAPAV12@@Z ; std::_Checked_base<Ogre::D3D9VertexDecl * *>
	add	esp, 4
	push	eax
	call	??$_Move_backward_opt@PAPAVD3D9VertexDecl@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@4@@std@@YAPAPAVD3D9VertexDecl@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Move_backward_opt<Ogre::D3D9VertexDecl * *,Ogre::D3D9VertexDecl * *,std::random_access_iterator_tag,std::_Undefined_move_tag>
	add	esp, 24					; 00000018H

; 3697 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Unchecked_move_backward@PAPAVD3D9VertexDecl@Ogre@@PAPAV12@@stdext@@YAPAPAVD3D9VertexDecl@Ogre@@PAPAV12@00@Z ENDP ; stdext::_Unchecked_move_backward<Ogre::D3D9VertexDecl * *,Ogre::D3D9VertexDecl * *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$?0PAVD3D9VertexDecl@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@PAVD3D9VertexDecl@Ogre@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??$?0PAVD3D9VertexDecl@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@PAVD3D9VertexDecl@Ogre@@@1@@Z PROC ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::D3D9VertexDecl *>, COMDAT
; _this$ = ecx

; 128  : 		allocator(const allocator<_Other>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0PAVD3D9VertexDecl@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@PAVD3D9VertexDecl@Ogre@@@1@@Z ENDP ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::D3D9VertexDecl *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Allocate@PAVD3D9VertexDecl@Ogre@@@std@@YAPAPAVD3D9VertexDecl@Ogre@@IPAPAV12@@Z
_TEXT	SEGMENT
$T160356 = -12						; size = 12
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@PAVD3D9VertexDecl@Ogre@@@std@@YAPAPAVD3D9VertexDecl@Ogre@@IPAPAV12@@Z PROC ; std::_Allocate<Ogre::D3D9VertexDecl *>, COMDAT

; 36   : 	{	// check for integer overflow

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 37   : 	if (_Count <= 0)

	cmp	DWORD PTR __Count$[ebp], 0
	ja	SHORT $LN3@Allocate@2

; 38   : 		_Count = 0;

	mov	DWORD PTR __Count$[ebp], 0
	jmp	SHORT $LN2@Allocate@2
$LN3@Allocate@2:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Count$[ebp]
	cmp	eax, 4
	jae	SHORT $LN2@Allocate@2

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	push	0
	lea	ecx, DWORD PTR $T160356[ebp]
	call	??0bad_alloc@std@@QAE@PBD@Z		; std::bad_alloc::bad_alloc
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	eax, DWORD PTR $T160356[ebp]
	push	eax
	call	__CxxThrowException@8
$LN2@Allocate@2:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 2
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
$LN5@Allocate@2:

; 44   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@PAVD3D9VertexDecl@Ogre@@@std@@YAPAPAVD3D9VertexDecl@Ogre@@IPAPAV12@@Z ENDP ; std::_Allocate<Ogre::D3D9VertexDecl *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Allocate@V_Aux_cont@std@@@std@@YAPAV_Aux_cont@0@IPAV10@@Z
_TEXT	SEGMENT
$T160359 = -12						; size = 12
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@V_Aux_cont@std@@@std@@YAPAV_Aux_cont@0@IPAV10@@Z PROC ; std::_Allocate<std::_Aux_cont>, COMDAT

; 36   : 	{	// check for integer overflow

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 37   : 	if (_Count <= 0)

	cmp	DWORD PTR __Count$[ebp], 0
	ja	SHORT $LN3@Allocate@3

; 38   : 		_Count = 0;

	mov	DWORD PTR __Count$[ebp], 0
	jmp	SHORT $LN2@Allocate@3
$LN3@Allocate@3:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Count$[ebp]
	cmp	eax, 4
	jae	SHORT $LN2@Allocate@3

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	push	0
	lea	ecx, DWORD PTR $T160359[ebp]
	call	??0bad_alloc@std@@QAE@PBD@Z		; std::bad_alloc::bad_alloc
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	eax, DWORD PTR $T160359[ebp]
	push	eax
	call	__CxxThrowException@8
$LN2@Allocate@3:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 2
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
$LN5@Allocate@3:

; 44   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@V_Aux_cont@std@@@std@@YAPAV_Aux_cont@0@IPAV10@@Z ENDP ; std::_Allocate<std::_Aux_cont>
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0bad_alloc@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0bad_alloc@std@@QAE@ABV01@@Z$0
__ehfuncinfo$??0bad_alloc@std@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0bad_alloc@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0bad_alloc@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7bad_alloc@std@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0bad_alloc@std@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??0bad_alloc@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0bad_alloc@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??A?$vector@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@QAEAAPAVD3D9VertexDecl@Ogre@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pos$ = 8						; size = 4
??A?$vector@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@QAEAAPAVD3D9VertexDecl@Ogre@@I@Z PROC ; std::vector<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >::operator[], COMDAT
; _this$ = ecx

; 774  : 		{	// subscript mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)
; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");
; 780  : 			_SCL_SECURE_OUT_OF_RANGE;
; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >::size
	cmp	DWORD PTR __Pos$[ebp], eax
	jb	SHORT $LN1@operator@12
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN1@operator@12:

; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR __Pos$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]

; 786  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??A?$vector@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@QAEAAPAVD3D9VertexDecl@Ogre@@I@Z ENDP ; std::vector<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >::operator[]
_TEXT	ENDS
PUBLIC	?erase@?$vector@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@2@0@Z ; std::vector<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >::erase
; Function compile flags: /Odtp
;	COMDAT ?clear@?$vector@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -44						; size = 4
$T160377 = -40						; size = 8
$T160376 = -32						; size = 8
$T160375 = -24						; size = 8
$T160374 = -16						; size = 8
$T160373 = -8						; size = 8
?clear@?$vector@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@QAEXXZ PROC ; std::vector<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >::clear, COMDAT
; _this$ = ecx

; 1059 : 		{	// erase all

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	mov	DWORD PTR _this$[ebp], ecx

; 1060 : 		erase(begin(), end());

	lea	eax, DWORD PTR $T160374[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$vector@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@2@XZ ; std::vector<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >::end
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T160373[ebp], ecx
	mov	DWORD PTR $T160373[ebp+4], edx
	lea	eax, DWORD PTR $T160376[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$vector@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@2@XZ ; std::vector<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >::begin
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T160375[ebp], ecx
	mov	DWORD PTR $T160375[ebp+4], edx
	mov	eax, DWORD PTR $T160373[ebp+4]
	push	eax
	mov	ecx, DWORD PTR $T160373[ebp]
	push	ecx
	mov	edx, DWORD PTR $T160375[ebp+4]
	push	edx
	mov	eax, DWORD PTR $T160375[ebp]
	push	eax
	lea	ecx, DWORD PTR $T160377[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$vector@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@2@0@Z ; std::vector<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >::erase

; 1061 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?clear@?$vector@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@QAEXXZ ENDP ; std::vector<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >::clear
_TEXT	ENDS
PUBLIC	??$unchecked_copy@PAPAVD3D9VertexDecl@Ogre@@PAPAV12@@stdext@@YAPAPAVD3D9VertexDecl@Ogre@@PAPAV12@00@Z ; stdext::unchecked_copy<Ogre::D3D9VertexDecl * *,Ogre::D3D9VertexDecl * *>
PUBLIC	?_Make_iter@?$vector@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@2@@Z ; std::vector<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >::_Make_iter
; Function compile flags: /Odtp
;	COMDAT ?erase@?$vector@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@2@0@Z
_TEXT	SEGMENT
_this$ = -24						; size = 4
__Ptr$157152 = -20					; size = 4
__Last$ = -16						; size = 8
__First$ = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 8
__Last_arg$ = 20					; size = 8
?erase@?$vector@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@2@0@Z PROC ; std::vector<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >::erase, COMDAT
; _this$ = ecx

; 1028 : 		{	// erase [_First, _Last)

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	eax, DWORD PTR __First_arg$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __First_arg$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Make_iter@?$vector@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@2@@Z ; std::vector<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >::_Make_iter

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);

	mov	eax, DWORD PTR __Last_arg$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __Last_arg$[ebp]
	push	ecx
	lea	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Make_iter@?$vector@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@2@@Z ; std::vector<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >::_Make_iter

; 1031 : 
; 1032 : 		if (_First != _Last)

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	call	??9?$_Vector_const_iterator@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >::operator!=
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@erase

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	edx, DWORD PTR __First$[ebp+4]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp+4]
	push	edx
	call	??$unchecked_copy@PAPAVD3D9VertexDecl@Ogre@@PAPAV12@@stdext@@YAPAPAVD3D9VertexDecl@Ogre@@PAPAV12@00@Z ; stdext::unchecked_copy<Ogre::D3D9VertexDecl * *,Ogre::D3D9VertexDecl * *>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR __Ptr$157152[ebp], eax

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Ptr$157152[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@IAEXPAPAVD3D9VertexDecl@Ogre@@0@Z ; std::vector<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >::_Destroy

; 1049 : 			_Mylast = _Ptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Ptr$157152[ebp]
	mov	DWORD PTR [eax+16], ecx
$LN1@erase:

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);

	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR __First$[ebp+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1055 : #endif
; 1056 : 		}

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?erase@?$vector@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@2@0@Z ENDP ; std::vector<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >::erase
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Make_iter@?$vector@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 8
?_Make_iter@?$vector@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@2@@Z PROC ; std::vector<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >::_Make_iter, COMDAT
; _this$ = ecx

; 660  : 		{	// make iterator from const_iterator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 661  : 		return (iterator(_Where._Myptr, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp+4]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@QAE@PAPAVD3D9VertexDecl@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >::_Vector_iterator<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 662  : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?_Make_iter@?$vector@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVD3D9VertexDecl@Ogre@@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@2@@Z ENDP ; std::vector<Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >::_Make_iter
_TEXT	ENDS
PUBLIC	??$_Checked_base@PAPAVD3DRenderWindow@Ogre@@@std@@YAPAPAVD3DRenderWindow@Ogre@@AAPAPAV12@U_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<Ogre::D3DRenderWindow * *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Checked_base@PAPAVD3DRenderWindow@Ogre@@@std@@YAPAPAVD3DRenderWindow@Ogre@@AAPAPAV12@@Z
_TEXT	SEGMENT
__Base_tag$ = -1					; size = 1
__It$ = 8						; size = 4
??$_Checked_base@PAPAVD3DRenderWindow@Ogre@@@std@@YAPAPAVD3DRenderWindow@Ogre@@AAPAPAV12@@Z PROC ; std::_Checked_base<Ogre::D3DRenderWindow * *>, COMDAT

; 1163 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1164 : 		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
; 1165 : 		return _Checked_base(_It, _Base_tag);

	movzx	eax, BYTE PTR __Base_tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR __It$[ebp]
	push	ecx
	call	??$_Checked_base@PAPAVD3DRenderWindow@Ogre@@@std@@YAPAPAVD3DRenderWindow@Ogre@@AAPAPAV12@U_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<Ogre::D3DRenderWindow * *>
	add	esp, 8

; 1166 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Checked_base@PAPAVD3DRenderWindow@Ogre@@@std@@YAPAPAVD3DRenderWindow@Ogre@@AAPAPAV12@@Z ENDP ; std::_Checked_base<Ogre::D3DRenderWindow * *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Iter_random@PAPAVD3DRenderWindow@Ogre@@PAPAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVD3DRenderWindow@Ogre@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAPAVD3DRenderWindow@Ogre@@PAPAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVD3DRenderWindow@Ogre@@0@Z PROC ; std::_Iter_random<Ogre::D3DRenderWindow * *,Ogre::D3DRenderWindow * *>, COMDAT

; 993  : 	{	// return category from iterator argument

	push	ebp
	mov	ebp, esp
	push	ecx

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 998  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Iter_random@PAPAVD3DRenderWindow@Ogre@@PAPAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVD3DRenderWindow@Ogre@@0@Z ENDP ; std::_Iter_random<Ogre::D3DRenderWindow * *,Ogre::D3DRenderWindow * *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAPAVD3DRenderWindow@Ogre@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVD3DRenderWindow@Ogre@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAPAVD3DRenderWindow@Ogre@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVD3DRenderWindow@Ogre@@0@Z PROC ; std::_Ptr_cat<Ogre::D3DRenderWindow * *,Ogre::D3DRenderWindow * *>, COMDAT

; 1509 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 1512 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Ptr_cat@PAPAVD3DRenderWindow@Ogre@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVD3DRenderWindow@Ogre@@0@Z ENDP ; std::_Ptr_cat<Ogre::D3DRenderWindow * *,Ogre::D3DRenderWindow * *>
_TEXT	ENDS
EXTRN	__imp__memmove_s:PROC
; Function compile flags: /Odtp
;	COMDAT ??$_Copy_opt@PAPAVD3DRenderWindow@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@@std@@YAPAPAVD3DRenderWindow@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Off$ = -8						; size = 4
__Result$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAPAVD3DRenderWindow@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@@std@@YAPAPAVD3DRenderWindow@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<Ogre::D3DRenderWindow * *,Ogre::D3DRenderWindow * *,std::random_access_iterator_tag>, COMDAT

; 2494 : 	{	// copy [_First, _Last) to [_Dest, ...), pointers to scalars

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 2495 : 
; 2496 :  #if _HAS_ITERATOR_DEBUGGING
; 2497 : 	_DEBUG_RANGE(_First, _Last);
; 2498 : 	if (_First != _Last)
; 2499 : 		_DEBUG_POINTER(_Dest);
; 2500 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2501 : 
; 2502 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 2
	mov	DWORD PTR __Off$[ebp], eax

; 2503 : 	// if _OutIt is range checked, this will make sure there is enough space for the memmove
; 2504 : 	_OutIt _Result = _Dest + _Off;

	mov	ecx, DWORD PTR __Off$[ebp]
	mov	edx, DWORD PTR __Dest$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR __Result$[ebp], eax

; 2505 : 	if (_Off > 0)

	cmp	DWORD PTR __Off$[ebp], 0
	jle	SHORT $LN1@Copy_opt

; 2506 : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Off * sizeof (*_First), &*_First, _Off * sizeof (*_First));

	mov	ecx, DWORD PTR __Off$[ebp]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	eax, DWORD PTR __Off$[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN1@Copy_opt:

; 2507 : 	return _Result;

	mov	eax, DWORD PTR __Result$[ebp]

; 2508 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Copy_opt@PAPAVD3DRenderWindow@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@@std@@YAPAPAVD3DRenderWindow@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<Ogre::D3DRenderWindow * *,Ogre::D3DRenderWindow * *,std::random_access_iterator_tag>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@YAXPAPAVD3DRenderWindow@Ogre@@0AAV?$allocator@PAVD3DRenderWindow@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@YAXPAPAVD3DRenderWindow@Ogre@@0AAV?$allocator@PAVD3DRenderWindow@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<Ogre::D3DRenderWindow *> >, COMDAT

; 241  : 	{	// destroy [_First, _Last), scalar type (do nothing)

	push	ebp
	mov	ebp, esp

; 242  : 	}

	pop	ebp
	ret	0
??$_Destroy_range@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@YAXPAPAVD3DRenderWindow@Ogre@@0AAV?$allocator@PAVD3DRenderWindow@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<Ogre::D3DRenderWindow *> >
_TEXT	ENDS
PUBLIC	??$unchecked_fill_n@PAPAVD3DRenderWindow@Ogre@@IPAV12@@stdext@@YAXPAPAVD3DRenderWindow@Ogre@@IABQAV12@@Z ; stdext::unchecked_fill_n<Ogre::D3DRenderWindow * *,unsigned int,Ogre::D3DRenderWindow *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Uninit_fill_n@PAPAVD3DRenderWindow@Ogre@@IPAV12@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@YAXPAPAVD3DRenderWindow@Ogre@@IABQAV12@AAV?$allocator@PAVD3DRenderWindow@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_fill_n@PAPAVD3DRenderWindow@Ogre@@IPAV12@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@YAXPAPAVD3DRenderWindow@Ogre@@IABQAV12@AAV?$allocator@PAVD3DRenderWindow@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<Ogre::D3DRenderWindow * *,unsigned int,Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >, COMDAT

; 418  : 	{	// copy _Count *_Val to raw _First, using _Al, scalar type

	push	ebp
	mov	ebp, esp

; 419  : 		_STDEXT unchecked_fill_n(_First, _Count, _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$unchecked_fill_n@PAPAVD3DRenderWindow@Ogre@@IPAV12@@stdext@@YAXPAPAVD3DRenderWindow@Ogre@@IABQAV12@@Z ; stdext::unchecked_fill_n<Ogre::D3DRenderWindow * *,unsigned int,Ogre::D3DRenderWindow *>
	add	esp, 12					; 0000000cH

; 420  : 	}

	pop	ebp
	ret	0
??$_Uninit_fill_n@PAPAVD3DRenderWindow@Ogre@@IPAV12@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@YAXPAPAVD3DRenderWindow@Ogre@@IABQAV12@AAV?$allocator@PAVD3DRenderWindow@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<Ogre::D3DRenderWindow * *,unsigned int,Ogre::D3DRenderWindow *,std::allocator<Ogre::D3DRenderWindow *> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAPAVD3D9VertexDecl@Ogre@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVD3D9VertexDecl@Ogre@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAPAVD3D9VertexDecl@Ogre@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVD3D9VertexDecl@Ogre@@0@Z PROC ; std::_Ptr_cat<Ogre::D3D9VertexDecl * *,Ogre::D3D9VertexDecl * *>, COMDAT

; 1509 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 1512 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Ptr_cat@PAPAVD3D9VertexDecl@Ogre@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVD3D9VertexDecl@Ogre@@0@Z ENDP ; std::_Ptr_cat<Ogre::D3D9VertexDecl * *,Ogre::D3D9VertexDecl * *>
_TEXT	ENDS
PUBLIC	??$unchecked_fill_n@PAPAVD3D9VertexDecl@Ogre@@IPAV12@@stdext@@YAXPAPAVD3D9VertexDecl@Ogre@@IABQAV12@@Z ; stdext::unchecked_fill_n<Ogre::D3D9VertexDecl * *,unsigned int,Ogre::D3D9VertexDecl *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Uninit_fill_n@PAPAVD3D9VertexDecl@Ogre@@IPAV12@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@YAXPAPAVD3D9VertexDecl@Ogre@@IABQAV12@AAV?$allocator@PAVD3D9VertexDecl@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_fill_n@PAPAVD3D9VertexDecl@Ogre@@IPAV12@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@YAXPAPAVD3D9VertexDecl@Ogre@@IABQAV12@AAV?$allocator@PAVD3D9VertexDecl@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<Ogre::D3D9VertexDecl * *,unsigned int,Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >, COMDAT

; 418  : 	{	// copy _Count *_Val to raw _First, using _Al, scalar type

	push	ebp
	mov	ebp, esp

; 419  : 		_STDEXT unchecked_fill_n(_First, _Count, _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$unchecked_fill_n@PAPAVD3D9VertexDecl@Ogre@@IPAV12@@stdext@@YAXPAPAVD3D9VertexDecl@Ogre@@IABQAV12@@Z ; stdext::unchecked_fill_n<Ogre::D3D9VertexDecl * *,unsigned int,Ogre::D3D9VertexDecl *>
	add	esp, 12					; 0000000cH

; 420  : 	}

	pop	ebp
	ret	0
??$_Uninit_fill_n@PAPAVD3D9VertexDecl@Ogre@@IPAV12@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@YAXPAPAVD3D9VertexDecl@Ogre@@IABQAV12@AAV?$allocator@PAVD3D9VertexDecl@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<Ogre::D3D9VertexDecl * *,unsigned int,Ogre::D3D9VertexDecl *,std::allocator<Ogre::D3D9VertexDecl *> >
_TEXT	ENDS
PUBLIC	??$_Uninit_move@PAPAVD3DRenderWindow@Ogre@@PAPAV12@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@U_Undefined_move_tag@4@@std@@YAPAPAVD3DRenderWindow@Ogre@@PAPAV12@00AAV?$allocator@PAVD3DRenderWindow@Ogre@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<Ogre::D3DRenderWindow * *,Ogre::D3DRenderWindow * *,std::allocator<Ogre::D3DRenderWindow *>,std::_Undefined_move_tag>
; Function compile flags: /Odtp
;	COMDAT ??$_Unchecked_uninitialized_move@PAPAVD3DRenderWindow@Ogre@@PAPAV12@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@stdext@@YAPAPAVD3DRenderWindow@Ogre@@PAPAV12@00AAV?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@Z
_TEXT	SEGMENT
$T160401 = -2						; size = 1
$T160400 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Unchecked_uninitialized_move@PAPAVD3DRenderWindow@Ogre@@PAPAV12@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@stdext@@YAPAPAVD3DRenderWindow@Ogre@@PAPAV12@00AAV?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@Z PROC ; stdext::_Unchecked_uninitialized_move<Ogre::D3DRenderWindow * *,Ogre::D3DRenderWindow * *,std::allocator<Ogre::D3DRenderWindow *> >, COMDAT

; 861  : 	{	// move [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 862  : 	return (_STD _Uninit_move(_CHECKED_BASE(_First),
; 863  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 864  : 		_STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T160400[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	??$_Move_cat@PAPAVD3DRenderWindow@Ogre@@@std@@YA?AU_Undefined_move_tag@0@ABQAPAVD3DRenderWindow@Ogre@@@Z ; std::_Move_cat<Ogre::D3DRenderWindow * *>
	add	esp, 4
	mov	BYTE PTR $T160401[ebp], al
	movzx	edx, BYTE PTR $T160400[ebp]
	push	edx
	movzx	eax, BYTE PTR $T160401[ebp]
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	call	??$_Checked_base@PAPAVD3DRenderWindow@Ogre@@@std@@YAPAPAVD3DRenderWindow@Ogre@@AAPAPAV12@@Z ; std::_Checked_base<Ogre::D3DRenderWindow * *>
	add	esp, 4
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Checked_base@PAPAVD3DRenderWindow@Ogre@@@std@@YAPAPAVD3DRenderWindow@Ogre@@AAPAPAV12@@Z ; std::_Checked_base<Ogre::D3DRenderWindow * *>
	add	esp, 4
	push	eax
	call	??$_Uninit_move@PAPAVD3DRenderWindow@Ogre@@PAPAV12@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@U_Undefined_move_tag@4@@std@@YAPAPAVD3DRenderWindow@Ogre@@PAPAV12@00AAV?$allocator@PAVD3DRenderWindow@Ogre@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<Ogre::D3DRenderWindow * *,Ogre::D3DRenderWindow * *,std::allocator<Ogre::D3DRenderWindow *>,std::_Undefined_move_tag>
	add	esp, 24					; 00000018H

; 865  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Unchecked_uninitialized_move@PAPAVD3DRenderWindow@Ogre@@PAPAV12@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@stdext@@YAPAPAVD3DRenderWindow@Ogre@@PAPAV12@00AAV?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@Z ENDP ; stdext::_Unchecked_uninitialized_move<Ogre::D3DRenderWindow * *,Ogre::D3DRenderWindow * *,std::allocator<Ogre::D3DRenderWindow *> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Fill@PAPAVD3DRenderWindow@Ogre@@PAV12@@std@@YAXPAPAVD3DRenderWindow@Ogre@@0ABQAV12@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$_Fill@PAPAVD3DRenderWindow@Ogre@@PAV12@@std@@YAXPAPAVD3DRenderWindow@Ogre@@0ABQAV12@@Z PROC ; std::_Fill<Ogre::D3DRenderWindow * *,Ogre::D3DRenderWindow *>, COMDAT

; 3156 : 	{	// copy _Val through [_First, _Last)

	push	ebp
	mov	ebp, esp

; 3157 : 	_DEBUG_RANGE(_First, _Last);
; 3158 : 	for (; _First != _Last; ++_First)

	jmp	SHORT $LN3@Fill
$LN2@Fill:
	mov	eax, DWORD PTR __First$[ebp]
	add	eax, 4
	mov	DWORD PTR __First$[ebp], eax
$LN3@Fill:
	mov	ecx, DWORD PTR __First$[ebp]
	cmp	ecx, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Fill

; 3159 : 		*_First = _Val;

	mov	edx, DWORD PTR __First$[ebp]
	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	jmp	SHORT $LN2@Fill
$LN4@Fill:

; 3160 : 	}

	pop	ebp
	ret	0
??$_Fill@PAPAVD3DRenderWindow@Ogre@@PAV12@@std@@YAXPAPAVD3DRenderWindow@Ogre@@0ABQAV12@@Z ENDP ; std::_Fill<Ogre::D3DRenderWindow * *,Ogre::D3DRenderWindow *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Move_cat@PAPAVD3DRenderWindow@Ogre@@@std@@YA?AU_Undefined_move_tag@0@ABQAPAVD3DRenderWindow@Ogre@@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
??$_Move_cat@PAPAVD3DRenderWindow@Ogre@@@std@@YA?AU_Undefined_move_tag@0@ABQAPAVD3DRenderWindow@Ogre@@@Z PROC ; std::_Move_cat<Ogre::D3DRenderWindow * *>, COMDAT

; 1200 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1201 : 		typename _Move_operation_category<typename iterator_traits<_Iter>::value_type>::_Move_cat _Cat;
; 1202 : 		return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 1203 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Move_cat@PAPAVD3DRenderWindow@Ogre@@@std@@YA?AU_Undefined_move_tag@0@ABQAPAVD3DRenderWindow@Ogre@@@Z ENDP ; std::_Move_cat<Ogre::D3DRenderWindow * *>
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@PAPAVD3DRenderWindow@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@@std@@YAPAPAVD3DRenderWindow@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<Ogre::D3DRenderWindow * *,Ogre::D3DRenderWindow * *,std::random_access_iterator_tag>
; Function compile flags: /Odtp
;	COMDAT ??$_Move_backward_opt@PAPAVD3DRenderWindow@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@4@@std@@YAPAPAVD3DRenderWindow@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T160409 = -2						; size = 1
$T160408 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__First_dest_cat$ = 20					; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Move_backward_opt@PAPAVD3DRenderWindow@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@4@@std@@YAPAPAVD3DRenderWindow@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Move_backward_opt<Ogre::D3DRenderWindow * *,Ogre::D3DRenderWindow * *,std::random_access_iterator_tag,std::_Undefined_move_tag>, COMDAT

; 2752 : 	{	// move defaults to copy if there is not a more effecient way

	push	ebp
	mov	ebp, esp
	push	ecx

; 2753 : 	return _Copy_backward_opt(_First, _Last, _Dest,
; 2754 : 		_First_dest_cat, _Ptr_cat(_First, _Dest), _Range_checked_iterator_tag());

	xor	eax, eax
	mov	BYTE PTR $T160408[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAPAVD3DRenderWindow@Ogre@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVD3DRenderWindow@Ogre@@0@Z ; std::_Ptr_cat<Ogre::D3DRenderWindow * *,Ogre::D3DRenderWindow * *>
	add	esp, 8
	mov	BYTE PTR $T160409[ebp], al
	movzx	eax, BYTE PTR $T160408[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T160409[ebp]
	push	ecx
	movzx	edx, BYTE PTR __First_dest_cat$[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Copy_backward_opt@PAPAVD3DRenderWindow@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@@std@@YAPAPAVD3DRenderWindow@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<Ogre::D3DRenderWindow * *,Ogre::D3DRenderWindow * *,std::random_access_iterator_tag>
	add	esp, 24					; 00000018H

; 2755 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Move_backward_opt@PAPAVD3DRenderWindow@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@4@@std@@YAPAPAVD3DRenderWindow@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Move_backward_opt<Ogre::D3DRenderWindow * *,Ogre::D3DRenderWindow * *,std::random_access_iterator_tag,std::_Undefined_move_tag>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@YAXPAPAVD3D9VertexDecl@Ogre@@0AAV?$allocator@PAVD3D9VertexDecl@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@YAXPAPAVD3D9VertexDecl@Ogre@@0AAV?$allocator@PAVD3D9VertexDecl@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<Ogre::D3D9VertexDecl *> >, COMDAT

; 241  : 	{	// destroy [_First, _Last), scalar type (do nothing)

	push	ebp
	mov	ebp, esp

; 242  : 	}

	pop	ebp
	ret	0
??$_Destroy_range@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@YAXPAPAVD3D9VertexDecl@Ogre@@0AAV?$allocator@PAVD3D9VertexDecl@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<Ogre::D3D9VertexDecl *> >
_TEXT	ENDS
PUBLIC	??$_Uninit_move@PAPAVD3D9VertexDecl@Ogre@@PAPAV12@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@U_Undefined_move_tag@4@@std@@YAPAPAVD3D9VertexDecl@Ogre@@PAPAV12@00AAV?$allocator@PAVD3D9VertexDecl@Ogre@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<Ogre::D3D9VertexDecl * *,Ogre::D3D9VertexDecl * *,std::allocator<Ogre::D3D9VertexDecl *>,std::_Undefined_move_tag>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Unchecked_uninitialized_move@PAPAVD3D9VertexDecl@Ogre@@PAPAV12@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@stdext@@YAPAPAVD3D9VertexDecl@Ogre@@PAPAV12@00AAV?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@Z
_TEXT	SEGMENT
$T160415 = -2						; size = 1
$T160414 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Unchecked_uninitialized_move@PAPAVD3D9VertexDecl@Ogre@@PAPAV12@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@stdext@@YAPAPAVD3D9VertexDecl@Ogre@@PAPAV12@00AAV?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@Z PROC ; stdext::_Unchecked_uninitialized_move<Ogre::D3D9VertexDecl * *,Ogre::D3D9VertexDecl * *,std::allocator<Ogre::D3D9VertexDecl *> >, COMDAT

; 861  : 	{	// move [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 862  : 	return (_STD _Uninit_move(_CHECKED_BASE(_First),
; 863  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 864  : 		_STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T160414[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	??$_Move_cat@PAPAVD3D9VertexDecl@Ogre@@@std@@YA?AU_Undefined_move_tag@0@ABQAPAVD3D9VertexDecl@Ogre@@@Z ; std::_Move_cat<Ogre::D3D9VertexDecl * *>
	add	esp, 4
	mov	BYTE PTR $T160415[ebp], al
	movzx	edx, BYTE PTR $T160414[ebp]
	push	edx
	movzx	eax, BYTE PTR $T160415[ebp]
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	call	??$_Checked_base@PAPAVD3D9VertexDecl@Ogre@@@std@@YAPAPAVD3D9VertexDecl@Ogre@@AAPAPAV12@@Z ; std::_Checked_base<Ogre::D3D9VertexDecl * *>
	add	esp, 4
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Checked_base@PAPAVD3D9VertexDecl@Ogre@@@std@@YAPAPAVD3D9VertexDecl@Ogre@@AAPAPAV12@@Z ; std::_Checked_base<Ogre::D3D9VertexDecl * *>
	add	esp, 4
	push	eax
	call	??$_Uninit_move@PAPAVD3D9VertexDecl@Ogre@@PAPAV12@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@U_Undefined_move_tag@4@@std@@YAPAPAVD3D9VertexDecl@Ogre@@PAPAV12@00AAV?$allocator@PAVD3D9VertexDecl@Ogre@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<Ogre::D3D9VertexDecl * *,Ogre::D3D9VertexDecl * *,std::allocator<Ogre::D3D9VertexDecl *>,std::_Undefined_move_tag>
	add	esp, 24					; 00000018H

; 865  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Unchecked_uninitialized_move@PAPAVD3D9VertexDecl@Ogre@@PAPAV12@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@stdext@@YAPAPAVD3D9VertexDecl@Ogre@@PAPAV12@00AAV?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@Z ENDP ; stdext::_Unchecked_uninitialized_move<Ogre::D3D9VertexDecl * *,Ogre::D3D9VertexDecl * *,std::allocator<Ogre::D3D9VertexDecl *> >
_TEXT	ENDS
PUBLIC	??$_Checked_base@PAPAVD3D9VertexDecl@Ogre@@@std@@YAPAPAVD3D9VertexDecl@Ogre@@AAPAPAV12@U_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<Ogre::D3D9VertexDecl * *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Checked_base@PAPAVD3D9VertexDecl@Ogre@@@std@@YAPAPAVD3D9VertexDecl@Ogre@@AAPAPAV12@@Z
_TEXT	SEGMENT
__Base_tag$ = -1					; size = 1
__It$ = 8						; size = 4
??$_Checked_base@PAPAVD3D9VertexDecl@Ogre@@@std@@YAPAPAVD3D9VertexDecl@Ogre@@AAPAPAV12@@Z PROC ; std::_Checked_base<Ogre::D3D9VertexDecl * *>, COMDAT

; 1163 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1164 : 		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
; 1165 : 		return _Checked_base(_It, _Base_tag);

	movzx	eax, BYTE PTR __Base_tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR __It$[ebp]
	push	ecx
	call	??$_Checked_base@PAPAVD3D9VertexDecl@Ogre@@@std@@YAPAPAVD3D9VertexDecl@Ogre@@AAPAPAV12@U_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<Ogre::D3D9VertexDecl * *>
	add	esp, 8

; 1166 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Checked_base@PAPAVD3D9VertexDecl@Ogre@@@std@@YAPAPAVD3D9VertexDecl@Ogre@@AAPAPAV12@@Z ENDP ; std::_Checked_base<Ogre::D3D9VertexDecl * *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Fill@PAPAVD3D9VertexDecl@Ogre@@PAV12@@std@@YAXPAPAVD3D9VertexDecl@Ogre@@0ABQAV12@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$_Fill@PAPAVD3D9VertexDecl@Ogre@@PAV12@@std@@YAXPAPAVD3D9VertexDecl@Ogre@@0ABQAV12@@Z PROC ; std::_Fill<Ogre::D3D9VertexDecl * *,Ogre::D3D9VertexDecl *>, COMDAT

; 3156 : 	{	// copy _Val through [_First, _Last)

	push	ebp
	mov	ebp, esp

; 3157 : 	_DEBUG_RANGE(_First, _Last);
; 3158 : 	for (; _First != _Last; ++_First)

	jmp	SHORT $LN3@Fill@2
$LN2@Fill@2:
	mov	eax, DWORD PTR __First$[ebp]
	add	eax, 4
	mov	DWORD PTR __First$[ebp], eax
$LN3@Fill@2:
	mov	ecx, DWORD PTR __First$[ebp]
	cmp	ecx, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Fill@2

; 3159 : 		*_First = _Val;

	mov	edx, DWORD PTR __First$[ebp]
	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	jmp	SHORT $LN2@Fill@2
$LN4@Fill@2:

; 3160 : 	}

	pop	ebp
	ret	0
??$_Fill@PAPAVD3D9VertexDecl@Ogre@@PAV12@@std@@YAXPAPAVD3D9VertexDecl@Ogre@@0ABQAV12@@Z ENDP ; std::_Fill<Ogre::D3D9VertexDecl * *,Ogre::D3D9VertexDecl *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Iter_random@PAPAVD3D9VertexDecl@Ogre@@PAPAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVD3D9VertexDecl@Ogre@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAPAVD3D9VertexDecl@Ogre@@PAPAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVD3D9VertexDecl@Ogre@@0@Z PROC ; std::_Iter_random<Ogre::D3D9VertexDecl * *,Ogre::D3D9VertexDecl * *>, COMDAT

; 993  : 	{	// return category from iterator argument

	push	ebp
	mov	ebp, esp
	push	ecx

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 998  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Iter_random@PAPAVD3D9VertexDecl@Ogre@@PAPAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVD3D9VertexDecl@Ogre@@0@Z ENDP ; std::_Iter_random<Ogre::D3D9VertexDecl * *,Ogre::D3D9VertexDecl * *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Move_cat@PAPAVD3D9VertexDecl@Ogre@@@std@@YA?AU_Undefined_move_tag@0@ABQAPAVD3D9VertexDecl@Ogre@@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
??$_Move_cat@PAPAVD3D9VertexDecl@Ogre@@@std@@YA?AU_Undefined_move_tag@0@ABQAPAVD3D9VertexDecl@Ogre@@@Z PROC ; std::_Move_cat<Ogre::D3D9VertexDecl * *>, COMDAT

; 1200 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1201 : 		typename _Move_operation_category<typename iterator_traits<_Iter>::value_type>::_Move_cat _Cat;
; 1202 : 		return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 1203 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Move_cat@PAPAVD3D9VertexDecl@Ogre@@@std@@YA?AU_Undefined_move_tag@0@ABQAPAVD3D9VertexDecl@Ogre@@@Z ENDP ; std::_Move_cat<Ogre::D3D9VertexDecl * *>
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@PAPAVD3D9VertexDecl@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@@std@@YAPAPAVD3D9VertexDecl@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<Ogre::D3D9VertexDecl * *,Ogre::D3D9VertexDecl * *,std::random_access_iterator_tag>
; Function compile flags: /Odtp
;	COMDAT ??$_Move_backward_opt@PAPAVD3D9VertexDecl@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@4@@std@@YAPAPAVD3D9VertexDecl@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T160427 = -2						; size = 1
$T160426 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__First_dest_cat$ = 20					; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Move_backward_opt@PAPAVD3D9VertexDecl@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@4@@std@@YAPAPAVD3D9VertexDecl@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Move_backward_opt<Ogre::D3D9VertexDecl * *,Ogre::D3D9VertexDecl * *,std::random_access_iterator_tag,std::_Undefined_move_tag>, COMDAT

; 2752 : 	{	// move defaults to copy if there is not a more effecient way

	push	ebp
	mov	ebp, esp
	push	ecx

; 2753 : 	return _Copy_backward_opt(_First, _Last, _Dest,
; 2754 : 		_First_dest_cat, _Ptr_cat(_First, _Dest), _Range_checked_iterator_tag());

	xor	eax, eax
	mov	BYTE PTR $T160426[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAPAVD3D9VertexDecl@Ogre@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVD3D9VertexDecl@Ogre@@0@Z ; std::_Ptr_cat<Ogre::D3D9VertexDecl * *,Ogre::D3D9VertexDecl * *>
	add	esp, 8
	mov	BYTE PTR $T160427[ebp], al
	movzx	eax, BYTE PTR $T160426[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T160427[ebp]
	push	ecx
	movzx	edx, BYTE PTR __First_dest_cat$[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Copy_backward_opt@PAPAVD3D9VertexDecl@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@@std@@YAPAPAVD3D9VertexDecl@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<Ogre::D3D9VertexDecl * *,Ogre::D3D9VertexDecl * *,std::random_access_iterator_tag>
	add	esp, 24					; 00000018H

; 2755 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Move_backward_opt@PAPAVD3D9VertexDecl@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@4@@std@@YAPAPAVD3D9VertexDecl@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Move_backward_opt<Ogre::D3D9VertexDecl * *,Ogre::D3D9VertexDecl * *,std::random_access_iterator_tag,std::_Undefined_move_tag>
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAPAVD3D9VertexDecl@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@@std@@YAPAPAVD3D9VertexDecl@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<Ogre::D3D9VertexDecl * *,Ogre::D3D9VertexDecl * *,std::random_access_iterator_tag>
; Function compile flags: /Odtp
;	COMDAT ??$unchecked_copy@PAPAVD3D9VertexDecl@Ogre@@PAPAV12@@stdext@@YAPAPAVD3D9VertexDecl@Ogre@@PAPAV12@00@Z
_TEXT	SEGMENT
$T160432 = -3						; size = 1
$T160431 = -2						; size = 1
$T160430 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAPAVD3D9VertexDecl@Ogre@@PAPAV12@@stdext@@YAPAPAVD3D9VertexDecl@Ogre@@PAPAV12@00@Z PROC ; stdext::unchecked_copy<Ogre::D3D9VertexDecl * *,Ogre::D3D9VertexDecl * *>, COMDAT

; 3604 : 	{	// copy [_First, _Last) to [_Dest, ...)

	push	ebp
	mov	ebp, esp
	push	ecx

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T160430[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAPAVD3D9VertexDecl@Ogre@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVD3D9VertexDecl@Ogre@@0@Z ; std::_Ptr_cat<Ogre::D3D9VertexDecl * *,Ogre::D3D9VertexDecl * *>
	add	esp, 8
	mov	BYTE PTR $T160431[ebp], al
	movzx	eax, BYTE PTR $T160430[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T160431[ebp]
	push	ecx
	lea	edx, DWORD PTR __Dest$[ebp]
	push	edx
	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T160432[ebp]
	push	ecx
	call	??$_Iter_random@PAPAVD3D9VertexDecl@Ogre@@PAPAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVD3D9VertexDecl@Ogre@@0@Z ; std::_Iter_random<Ogre::D3D9VertexDecl * *,Ogre::D3D9VertexDecl * *>
	add	esp, 12					; 0000000cH
	movzx	edx, BYTE PTR [eax]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@PAPAVD3D9VertexDecl@Ogre@@@std@@YAPAPAVD3D9VertexDecl@Ogre@@AAPAPAV12@@Z ; std::_Checked_base<Ogre::D3D9VertexDecl * *>
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@PAPAVD3D9VertexDecl@Ogre@@@std@@YAPAPAVD3D9VertexDecl@Ogre@@AAPAPAV12@@Z ; std::_Checked_base<Ogre::D3D9VertexDecl * *>
	add	esp, 4
	push	eax
	call	??$_Copy_opt@PAPAVD3D9VertexDecl@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@@std@@YAPAPAVD3D9VertexDecl@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<Ogre::D3D9VertexDecl * *,Ogre::D3D9VertexDecl * *,std::random_access_iterator_tag>
	add	esp, 24					; 00000018H

; 3607 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_copy@PAPAVD3D9VertexDecl@Ogre@@PAPAV12@@stdext@@YAPAPAVD3D9VertexDecl@Ogre@@PAPAV12@00@Z ENDP ; stdext::unchecked_copy<Ogre::D3D9VertexDecl * *,Ogre::D3D9VertexDecl * *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Checked_base@PAPAVD3DRenderWindow@Ogre@@@std@@YAPAPAVD3DRenderWindow@Ogre@@AAPAPAV12@U_Unchanged_checked_iterator_base_type_tag@0@@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Checked_base@PAPAVD3DRenderWindow@Ogre@@@std@@YAPAPAVD3DRenderWindow@Ogre@@AAPAPAV12@U_Unchanged_checked_iterator_base_type_tag@0@@Z PROC ; std::_Checked_base<Ogre::D3DRenderWindow * *>, COMDAT

; 1146 : 	{

	push	ebp
	mov	ebp, esp

; 1147 : 		return _It;

	mov	eax, DWORD PTR __It$[ebp]
	mov	eax, DWORD PTR [eax]

; 1148 : 	}

	pop	ebp
	ret	0
??$_Checked_base@PAPAVD3DRenderWindow@Ogre@@@std@@YAPAPAVD3DRenderWindow@Ogre@@AAPAPAV12@U_Unchanged_checked_iterator_base_type_tag@0@@Z ENDP ; std::_Checked_base<Ogre::D3DRenderWindow * *>
_TEXT	ENDS
PUBLIC	??$_Fill_n@PAPAVD3DRenderWindow@Ogre@@IPAV12@@std@@YAXPAPAVD3DRenderWindow@Ogre@@IABQAV12@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Fill_n<Ogre::D3DRenderWindow * *,unsigned int,Ogre::D3DRenderWindow *>
PUBLIC	??$_Iter_cat@PAPAVD3DRenderWindow@Ogre@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVD3DRenderWindow@Ogre@@@Z ; std::_Iter_cat<Ogre::D3DRenderWindow * *>
; Function compile flags: /Odtp
;	COMDAT ??$unchecked_fill_n@PAPAVD3DRenderWindow@Ogre@@IPAV12@@stdext@@YAXPAPAVD3DRenderWindow@Ogre@@IABQAV12@@Z
_TEXT	SEGMENT
$T160438 = -2						; size = 1
$T160437 = -1						; size = 1
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
??$unchecked_fill_n@PAPAVD3DRenderWindow@Ogre@@IPAV12@@stdext@@YAXPAPAVD3DRenderWindow@Ogre@@IABQAV12@@Z PROC ; stdext::unchecked_fill_n<Ogre::D3DRenderWindow * *,unsigned int,Ogre::D3DRenderWindow *>, COMDAT

; 3720 : 	{	// copy _Val _Count times through [_First, ...)

	push	ebp
	mov	ebp, esp
	push	ecx

; 3721 : 		_STD _Fill_n(_First, _Count, _Val, _STD _Iter_cat(_First), _STD _Range_checked_iterator_tag());

	xor	eax, eax
	mov	BYTE PTR $T160437[ebp], al
	movzx	ecx, BYTE PTR $T160437[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	lea	eax, DWORD PTR $T160438[ebp]
	push	eax
	call	??$_Iter_cat@PAPAVD3DRenderWindow@Ogre@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVD3DRenderWindow@Ogre@@@Z ; std::_Iter_cat<Ogre::D3DRenderWindow * *>
	add	esp, 8
	movzx	ecx, BYTE PTR [eax]
	push	ecx
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Fill_n@PAPAVD3DRenderWindow@Ogre@@IPAV12@@std@@YAXPAPAVD3DRenderWindow@Ogre@@IABQAV12@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Fill_n<Ogre::D3DRenderWindow * *,unsigned int,Ogre::D3DRenderWindow *>
	add	esp, 20					; 00000014H

; 3722 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_fill_n@PAPAVD3DRenderWindow@Ogre@@IPAV12@@stdext@@YAXPAPAVD3DRenderWindow@Ogre@@IABQAV12@@Z ENDP ; stdext::unchecked_fill_n<Ogre::D3DRenderWindow * *,unsigned int,Ogre::D3DRenderWindow *>
_TEXT	ENDS
PUBLIC	??$_Fill_n@PAPAVD3D9VertexDecl@Ogre@@IPAV12@@std@@YAXPAPAVD3D9VertexDecl@Ogre@@IABQAV12@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Fill_n<Ogre::D3D9VertexDecl * *,unsigned int,Ogre::D3D9VertexDecl *>
PUBLIC	??$_Iter_cat@PAPAVD3D9VertexDecl@Ogre@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVD3D9VertexDecl@Ogre@@@Z ; std::_Iter_cat<Ogre::D3D9VertexDecl * *>
; Function compile flags: /Odtp
;	COMDAT ??$unchecked_fill_n@PAPAVD3D9VertexDecl@Ogre@@IPAV12@@stdext@@YAXPAPAVD3D9VertexDecl@Ogre@@IABQAV12@@Z
_TEXT	SEGMENT
$T160442 = -2						; size = 1
$T160441 = -1						; size = 1
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
??$unchecked_fill_n@PAPAVD3D9VertexDecl@Ogre@@IPAV12@@stdext@@YAXPAPAVD3D9VertexDecl@Ogre@@IABQAV12@@Z PROC ; stdext::unchecked_fill_n<Ogre::D3D9VertexDecl * *,unsigned int,Ogre::D3D9VertexDecl *>, COMDAT

; 3720 : 	{	// copy _Val _Count times through [_First, ...)

	push	ebp
	mov	ebp, esp
	push	ecx

; 3721 : 		_STD _Fill_n(_First, _Count, _Val, _STD _Iter_cat(_First), _STD _Range_checked_iterator_tag());

	xor	eax, eax
	mov	BYTE PTR $T160441[ebp], al
	movzx	ecx, BYTE PTR $T160441[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	lea	eax, DWORD PTR $T160442[ebp]
	push	eax
	call	??$_Iter_cat@PAPAVD3D9VertexDecl@Ogre@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVD3D9VertexDecl@Ogre@@@Z ; std::_Iter_cat<Ogre::D3D9VertexDecl * *>
	add	esp, 8
	movzx	ecx, BYTE PTR [eax]
	push	ecx
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Fill_n@PAPAVD3D9VertexDecl@Ogre@@IPAV12@@std@@YAXPAPAVD3D9VertexDecl@Ogre@@IABQAV12@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Fill_n<Ogre::D3D9VertexDecl * *,unsigned int,Ogre::D3D9VertexDecl *>
	add	esp, 20					; 00000014H

; 3722 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_fill_n@PAPAVD3D9VertexDecl@Ogre@@IPAV12@@stdext@@YAXPAPAVD3D9VertexDecl@Ogre@@IABQAV12@@Z ENDP ; stdext::unchecked_fill_n<Ogre::D3D9VertexDecl * *,unsigned int,Ogre::D3D9VertexDecl *>
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@PAPAVD3DRenderWindow@Ogre@@PAPAV12@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@stdext@@YAPAPAVD3DRenderWindow@Ogre@@PAPAV12@00AAV?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@Z ; stdext::unchecked_uninitialized_copy<Ogre::D3DRenderWindow * *,Ogre::D3DRenderWindow * *,std::allocator<Ogre::D3DRenderWindow *> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Uninit_move@PAPAVD3DRenderWindow@Ogre@@PAPAV12@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@U_Undefined_move_tag@4@@std@@YAPAPAVD3DRenderWindow@Ogre@@PAPAV12@00AAV?$allocator@PAVD3DRenderWindow@Ogre@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_move@PAPAVD3DRenderWindow@Ogre@@PAPAV12@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@U_Undefined_move_tag@4@@std@@YAPAPAVD3DRenderWindow@Ogre@@PAPAV12@00AAV?$allocator@PAVD3DRenderWindow@Ogre@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_move<Ogre::D3DRenderWindow * *,Ogre::D3DRenderWindow * *,std::allocator<Ogre::D3DRenderWindow *>,std::_Undefined_move_tag>, COMDAT

; 206  : 	{	// move defaults to copy if there is not a more effecient way

	push	ebp
	mov	ebp, esp

; 207  : 	return (_STDEXT unchecked_uninitialized_copy(_First, _Last, _Dest, _Al));

	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$unchecked_uninitialized_copy@PAPAVD3DRenderWindow@Ogre@@PAPAV12@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@stdext@@YAPAPAVD3DRenderWindow@Ogre@@PAPAV12@00AAV?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@Z ; stdext::unchecked_uninitialized_copy<Ogre::D3DRenderWindow * *,Ogre::D3DRenderWindow * *,std::allocator<Ogre::D3DRenderWindow *> >
	add	esp, 16					; 00000010H

; 208  : 	}

	pop	ebp
	ret	0
??$_Uninit_move@PAPAVD3DRenderWindow@Ogre@@PAPAV12@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@U_Undefined_move_tag@4@@std@@YAPAPAVD3DRenderWindow@Ogre@@PAPAV12@00AAV?$allocator@PAVD3DRenderWindow@Ogre@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_move<Ogre::D3DRenderWindow * *,Ogre::D3DRenderWindow * *,std::allocator<Ogre::D3DRenderWindow *>,std::_Undefined_move_tag>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Copy_backward_opt@PAPAVD3DRenderWindow@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@@std@@YAPAPAVD3DRenderWindow@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Off$ = -8						; size = 4
__Result$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_backward_opt@PAPAVD3DRenderWindow@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@@std@@YAPAPAVD3DRenderWindow@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<Ogre::D3DRenderWindow * *,Ogre::D3DRenderWindow * *,std::random_access_iterator_tag>, COMDAT

; 2698 : 	{	// copy [_First, _Last) backwards to [..., _Dest), pointers to scalars

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 2699 : 
; 2700 :  #if _HAS_ITERATOR_DEBUGGING
; 2701 : 	_DEBUG_RANGE(_First, _Last);
; 2702 : 	if (_First != _Last)
; 2703 : 		_DEBUG_POINTER(_Dest);
; 2704 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2705 : 
; 2706 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 2
	mov	DWORD PTR __Off$[ebp], eax

; 2707 : 	/* if _OutIt is range checked, this will make sure there is enough space for 
; 2708 : 	 * the memmove
; 2709 : 	 */
; 2710 : 	_OutIt _Result = _Dest - _Off;

	mov	ecx, DWORD PTR __Off$[ebp]
	shl	ecx, 2
	mov	edx, DWORD PTR __Dest$[ebp]
	sub	edx, ecx
	mov	DWORD PTR __Result$[ebp], edx

; 2711 : 	if (_Off > 0)

	cmp	DWORD PTR __Off$[ebp], 0
	jle	SHORT $LN1@Copy_backw

; 2712 : 		_CRT_SECURE_MEMMOVE(&*_Result, _Off * sizeof (*_First), &*_First, _Off * sizeof (*_First));

	mov	eax, DWORD PTR __Off$[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Off$[ebp]
	shl	edx, 2
	push	edx
	mov	eax, DWORD PTR __Result$[ebp]
	push	eax
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN1@Copy_backw:

; 2713 : 	return _Result;

	mov	eax, DWORD PTR __Result$[ebp]

; 2714 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Copy_backward_opt@PAPAVD3DRenderWindow@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@@std@@YAPAPAVD3DRenderWindow@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<Ogre::D3DRenderWindow * *,Ogre::D3DRenderWindow * *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@PAPAVD3D9VertexDecl@Ogre@@PAPAV12@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@stdext@@YAPAPAVD3D9VertexDecl@Ogre@@PAPAV12@00AAV?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@Z ; stdext::unchecked_uninitialized_copy<Ogre::D3D9VertexDecl * *,Ogre::D3D9VertexDecl * *,std::allocator<Ogre::D3D9VertexDecl *> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Uninit_move@PAPAVD3D9VertexDecl@Ogre@@PAPAV12@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@U_Undefined_move_tag@4@@std@@YAPAPAVD3D9VertexDecl@Ogre@@PAPAV12@00AAV?$allocator@PAVD3D9VertexDecl@Ogre@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_move@PAPAVD3D9VertexDecl@Ogre@@PAPAV12@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@U_Undefined_move_tag@4@@std@@YAPAPAVD3D9VertexDecl@Ogre@@PAPAV12@00AAV?$allocator@PAVD3D9VertexDecl@Ogre@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_move<Ogre::D3D9VertexDecl * *,Ogre::D3D9VertexDecl * *,std::allocator<Ogre::D3D9VertexDecl *>,std::_Undefined_move_tag>, COMDAT

; 206  : 	{	// move defaults to copy if there is not a more effecient way

	push	ebp
	mov	ebp, esp

; 207  : 	return (_STDEXT unchecked_uninitialized_copy(_First, _Last, _Dest, _Al));

	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$unchecked_uninitialized_copy@PAPAVD3D9VertexDecl@Ogre@@PAPAV12@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@stdext@@YAPAPAVD3D9VertexDecl@Ogre@@PAPAV12@00AAV?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@Z ; stdext::unchecked_uninitialized_copy<Ogre::D3D9VertexDecl * *,Ogre::D3D9VertexDecl * *,std::allocator<Ogre::D3D9VertexDecl *> >
	add	esp, 16					; 00000010H

; 208  : 	}

	pop	ebp
	ret	0
??$_Uninit_move@PAPAVD3D9VertexDecl@Ogre@@PAPAV12@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@U_Undefined_move_tag@4@@std@@YAPAPAVD3D9VertexDecl@Ogre@@PAPAV12@00AAV?$allocator@PAVD3D9VertexDecl@Ogre@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_move<Ogre::D3D9VertexDecl * *,Ogre::D3D9VertexDecl * *,std::allocator<Ogre::D3D9VertexDecl *>,std::_Undefined_move_tag>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Checked_base@PAPAVD3D9VertexDecl@Ogre@@@std@@YAPAPAVD3D9VertexDecl@Ogre@@AAPAPAV12@U_Unchanged_checked_iterator_base_type_tag@0@@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Checked_base@PAPAVD3D9VertexDecl@Ogre@@@std@@YAPAPAVD3D9VertexDecl@Ogre@@AAPAPAV12@U_Unchanged_checked_iterator_base_type_tag@0@@Z PROC ; std::_Checked_base<Ogre::D3D9VertexDecl * *>, COMDAT

; 1146 : 	{

	push	ebp
	mov	ebp, esp

; 1147 : 		return _It;

	mov	eax, DWORD PTR __It$[ebp]
	mov	eax, DWORD PTR [eax]

; 1148 : 	}

	pop	ebp
	ret	0
??$_Checked_base@PAPAVD3D9VertexDecl@Ogre@@@std@@YAPAPAVD3D9VertexDecl@Ogre@@AAPAPAV12@U_Unchanged_checked_iterator_base_type_tag@0@@Z ENDP ; std::_Checked_base<Ogre::D3D9VertexDecl * *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Copy_backward_opt@PAPAVD3D9VertexDecl@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@@std@@YAPAPAVD3D9VertexDecl@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Off$ = -8						; size = 4
__Result$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_backward_opt@PAPAVD3D9VertexDecl@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@@std@@YAPAPAVD3D9VertexDecl@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<Ogre::D3D9VertexDecl * *,Ogre::D3D9VertexDecl * *,std::random_access_iterator_tag>, COMDAT

; 2698 : 	{	// copy [_First, _Last) backwards to [..., _Dest), pointers to scalars

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 2699 : 
; 2700 :  #if _HAS_ITERATOR_DEBUGGING
; 2701 : 	_DEBUG_RANGE(_First, _Last);
; 2702 : 	if (_First != _Last)
; 2703 : 		_DEBUG_POINTER(_Dest);
; 2704 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2705 : 
; 2706 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 2
	mov	DWORD PTR __Off$[ebp], eax

; 2707 : 	/* if _OutIt is range checked, this will make sure there is enough space for 
; 2708 : 	 * the memmove
; 2709 : 	 */
; 2710 : 	_OutIt _Result = _Dest - _Off;

	mov	ecx, DWORD PTR __Off$[ebp]
	shl	ecx, 2
	mov	edx, DWORD PTR __Dest$[ebp]
	sub	edx, ecx
	mov	DWORD PTR __Result$[ebp], edx

; 2711 : 	if (_Off > 0)

	cmp	DWORD PTR __Off$[ebp], 0
	jle	SHORT $LN1@Copy_backw@2

; 2712 : 		_CRT_SECURE_MEMMOVE(&*_Result, _Off * sizeof (*_First), &*_First, _Off * sizeof (*_First));

	mov	eax, DWORD PTR __Off$[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Off$[ebp]
	shl	edx, 2
	push	edx
	mov	eax, DWORD PTR __Result$[ebp]
	push	eax
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN1@Copy_backw@2:

; 2713 : 	return _Result;

	mov	eax, DWORD PTR __Result$[ebp]

; 2714 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Copy_backward_opt@PAPAVD3D9VertexDecl@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@@std@@YAPAPAVD3D9VertexDecl@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<Ogre::D3D9VertexDecl * *,Ogre::D3D9VertexDecl * *,std::random_access_iterator_tag>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Copy_opt@PAPAVD3D9VertexDecl@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@@std@@YAPAPAVD3D9VertexDecl@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Off$ = -8						; size = 4
__Result$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAPAVD3D9VertexDecl@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@@std@@YAPAPAVD3D9VertexDecl@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<Ogre::D3D9VertexDecl * *,Ogre::D3D9VertexDecl * *,std::random_access_iterator_tag>, COMDAT

; 2494 : 	{	// copy [_First, _Last) to [_Dest, ...), pointers to scalars

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 2495 : 
; 2496 :  #if _HAS_ITERATOR_DEBUGGING
; 2497 : 	_DEBUG_RANGE(_First, _Last);
; 2498 : 	if (_First != _Last)
; 2499 : 		_DEBUG_POINTER(_Dest);
; 2500 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2501 : 
; 2502 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 2
	mov	DWORD PTR __Off$[ebp], eax

; 2503 : 	// if _OutIt is range checked, this will make sure there is enough space for the memmove
; 2504 : 	_OutIt _Result = _Dest + _Off;

	mov	ecx, DWORD PTR __Off$[ebp]
	mov	edx, DWORD PTR __Dest$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR __Result$[ebp], eax

; 2505 : 	if (_Off > 0)

	cmp	DWORD PTR __Off$[ebp], 0
	jle	SHORT $LN1@Copy_opt@2

; 2506 : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Off * sizeof (*_First), &*_First, _Off * sizeof (*_First));

	mov	ecx, DWORD PTR __Off$[ebp]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	eax, DWORD PTR __Off$[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN1@Copy_opt@2:

; 2507 : 	return _Result;

	mov	eax, DWORD PTR __Result$[ebp]

; 2508 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Copy_opt@PAPAVD3D9VertexDecl@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@@std@@YAPAPAVD3D9VertexDecl@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<Ogre::D3D9VertexDecl * *,Ogre::D3D9VertexDecl * *,std::random_access_iterator_tag>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Iter_cat@PAPAVD3DRenderWindow@Ogre@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVD3DRenderWindow@Ogre@@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??$_Iter_cat@PAPAVD3DRenderWindow@Ogre@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVD3DRenderWindow@Ogre@@@Z PROC ; std::_Iter_cat<Ogre::D3DRenderWindow * *>, COMDAT

; 952  : 	{	// return category from iterator argument

	push	ebp
	mov	ebp, esp
	push	ecx

; 953  : 	typename iterator_traits<_Iter>::iterator_category _Cat;
; 954  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 955  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Iter_cat@PAPAVD3DRenderWindow@Ogre@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVD3DRenderWindow@Ogre@@@Z ENDP ; std::_Iter_cat<Ogre::D3DRenderWindow * *>
_TEXT	ENDS
PUBLIC	??$_Fill_n@PAPAVD3DRenderWindow@Ogre@@IPAV12@@std@@YAXPAPAVD3DRenderWindow@Ogre@@IABQAV12@U_Range_checked_iterator_tag@0@@Z ; std::_Fill_n<Ogre::D3DRenderWindow * *,unsigned int,Ogre::D3DRenderWindow *>
; Function compile flags: /Odtp
;	COMDAT ??$_Fill_n@PAPAVD3DRenderWindow@Ogre@@IPAV12@@std@@YAXPAPAVD3DRenderWindow@Ogre@@IABQAV12@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T160459 = -5						; size = 1
__Last$ = -4						; size = 4
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
??$_Fill_n@PAPAVD3DRenderWindow@Ogre@@IPAV12@@std@@YAXPAPAVD3DRenderWindow@Ogre@@IABQAV12@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Fill_n<Ogre::D3DRenderWindow * *,unsigned int,Ogre::D3DRenderWindow *>, COMDAT

; 3250 : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 3251 : 		// if _OutIt is checked, this will ensure we have enough space
; 3252 : 		_OutIt _Last = _First + _Count; (_Last);

	mov	eax, DWORD PTR __Count$[ebp]
	mov	ecx, DWORD PTR __First$[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR __Last$[ebp], edx

; 3253 : 		_Fill_n(_CHECKED_BASE(_First), _Count, _Val,
; 3254 : 			_Range_checked_iterator_tag());

	xor	eax, eax
	mov	BYTE PTR $T160459[ebp], al
	movzx	ecx, BYTE PTR $T160459[ebp]
	push	ecx
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Checked_base@PAPAVD3DRenderWindow@Ogre@@@std@@YAPAPAVD3DRenderWindow@Ogre@@AAPAPAV12@@Z ; std::_Checked_base<Ogre::D3DRenderWindow * *>
	add	esp, 4
	push	eax
	call	??$_Fill_n@PAPAVD3DRenderWindow@Ogre@@IPAV12@@std@@YAXPAPAVD3DRenderWindow@Ogre@@IABQAV12@U_Range_checked_iterator_tag@0@@Z ; std::_Fill_n<Ogre::D3DRenderWindow * *,unsigned int,Ogre::D3DRenderWindow *>
	add	esp, 16					; 00000010H

; 3255 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Fill_n@PAPAVD3DRenderWindow@Ogre@@IPAV12@@std@@YAXPAPAVD3DRenderWindow@Ogre@@IABQAV12@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Fill_n<Ogre::D3DRenderWindow * *,unsigned int,Ogre::D3DRenderWindow *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Iter_cat@PAPAVD3D9VertexDecl@Ogre@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVD3D9VertexDecl@Ogre@@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??$_Iter_cat@PAPAVD3D9VertexDecl@Ogre@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVD3D9VertexDecl@Ogre@@@Z PROC ; std::_Iter_cat<Ogre::D3D9VertexDecl * *>, COMDAT

; 952  : 	{	// return category from iterator argument

	push	ebp
	mov	ebp, esp
	push	ecx

; 953  : 	typename iterator_traits<_Iter>::iterator_category _Cat;
; 954  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 955  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Iter_cat@PAPAVD3D9VertexDecl@Ogre@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVD3D9VertexDecl@Ogre@@@Z ENDP ; std::_Iter_cat<Ogre::D3D9VertexDecl * *>
_TEXT	ENDS
PUBLIC	??$_Fill_n@PAPAVD3D9VertexDecl@Ogre@@IPAV12@@std@@YAXPAPAVD3D9VertexDecl@Ogre@@IABQAV12@U_Range_checked_iterator_tag@0@@Z ; std::_Fill_n<Ogre::D3D9VertexDecl * *,unsigned int,Ogre::D3D9VertexDecl *>
; Function compile flags: /Odtp
;	COMDAT ??$_Fill_n@PAPAVD3D9VertexDecl@Ogre@@IPAV12@@std@@YAXPAPAVD3D9VertexDecl@Ogre@@IABQAV12@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T160464 = -5						; size = 1
__Last$ = -4						; size = 4
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
??$_Fill_n@PAPAVD3D9VertexDecl@Ogre@@IPAV12@@std@@YAXPAPAVD3D9VertexDecl@Ogre@@IABQAV12@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Fill_n<Ogre::D3D9VertexDecl * *,unsigned int,Ogre::D3D9VertexDecl *>, COMDAT

; 3250 : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 3251 : 		// if _OutIt is checked, this will ensure we have enough space
; 3252 : 		_OutIt _Last = _First + _Count; (_Last);

	mov	eax, DWORD PTR __Count$[ebp]
	mov	ecx, DWORD PTR __First$[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR __Last$[ebp], edx

; 3253 : 		_Fill_n(_CHECKED_BASE(_First), _Count, _Val,
; 3254 : 			_Range_checked_iterator_tag());

	xor	eax, eax
	mov	BYTE PTR $T160464[ebp], al
	movzx	ecx, BYTE PTR $T160464[ebp]
	push	ecx
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Checked_base@PAPAVD3D9VertexDecl@Ogre@@@std@@YAPAPAVD3D9VertexDecl@Ogre@@AAPAPAV12@@Z ; std::_Checked_base<Ogre::D3D9VertexDecl * *>
	add	esp, 4
	push	eax
	call	??$_Fill_n@PAPAVD3D9VertexDecl@Ogre@@IPAV12@@std@@YAXPAPAVD3D9VertexDecl@Ogre@@IABQAV12@U_Range_checked_iterator_tag@0@@Z ; std::_Fill_n<Ogre::D3D9VertexDecl * *,unsigned int,Ogre::D3D9VertexDecl *>
	add	esp, 16					; 00000010H

; 3255 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Fill_n@PAPAVD3D9VertexDecl@Ogre@@IPAV12@@std@@YAXPAPAVD3D9VertexDecl@Ogre@@IABQAV12@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Fill_n<Ogre::D3D9VertexDecl * *,unsigned int,Ogre::D3D9VertexDecl *>
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PAPAVD3DRenderWindow@Ogre@@PAPAV12@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@YAPAPAVD3DRenderWindow@Ogre@@PAPAV12@00AAV?$allocator@PAVD3DRenderWindow@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Ogre::D3DRenderWindow * *,Ogre::D3DRenderWindow * *,std::allocator<Ogre::D3DRenderWindow *> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_copy@PAPAVD3DRenderWindow@Ogre@@PAPAV12@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@stdext@@YAPAPAVD3DRenderWindow@Ogre@@PAPAV12@00AAV?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@Z
_TEXT	SEGMENT
$T160468 = -2						; size = 1
$T160467 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@PAPAVD3DRenderWindow@Ogre@@PAPAV12@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@stdext@@YAPAPAVD3DRenderWindow@Ogre@@PAPAV12@00AAV?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<Ogre::D3DRenderWindow * *,Ogre::D3DRenderWindow * *,std::allocator<Ogre::D3DRenderWindow *> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T160467[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAPAVD3DRenderWindow@Ogre@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVD3DRenderWindow@Ogre@@0@Z ; std::_Ptr_cat<Ogre::D3DRenderWindow * *,Ogre::D3DRenderWindow * *>
	add	esp, 8
	mov	BYTE PTR $T160468[ebp], al
	movzx	eax, BYTE PTR $T160467[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T160468[ebp]
	push	ecx
	mov	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@PAPAVD3DRenderWindow@Ogre@@@std@@YAPAPAVD3DRenderWindow@Ogre@@AAPAPAV12@@Z ; std::_Checked_base<Ogre::D3DRenderWindow * *>
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@PAPAVD3DRenderWindow@Ogre@@@std@@YAPAPAVD3DRenderWindow@Ogre@@AAPAPAV12@@Z ; std::_Checked_base<Ogre::D3DRenderWindow * *>
	add	esp, 4
	push	eax
	call	??$_Uninit_copy@PAPAVD3DRenderWindow@Ogre@@PAPAV12@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@YAPAPAVD3DRenderWindow@Ogre@@PAPAV12@00AAV?$allocator@PAVD3DRenderWindow@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Ogre::D3DRenderWindow * *,Ogre::D3DRenderWindow * *,std::allocator<Ogre::D3DRenderWindow *> >
	add	esp, 24					; 00000018H

; 823  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_copy@PAPAVD3DRenderWindow@Ogre@@PAPAV12@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@stdext@@YAPAPAVD3DRenderWindow@Ogre@@PAPAV12@00AAV?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<Ogre::D3DRenderWindow * *,Ogre::D3DRenderWindow * *,std::allocator<Ogre::D3DRenderWindow *> >
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PAPAVD3D9VertexDecl@Ogre@@PAPAV12@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@YAPAPAVD3D9VertexDecl@Ogre@@PAPAV12@00AAV?$allocator@PAVD3D9VertexDecl@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Ogre::D3D9VertexDecl * *,Ogre::D3D9VertexDecl * *,std::allocator<Ogre::D3D9VertexDecl *> >
; Function compile flags: /Odtp
;	COMDAT ??$unchecked_uninitialized_copy@PAPAVD3D9VertexDecl@Ogre@@PAPAV12@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@stdext@@YAPAPAVD3D9VertexDecl@Ogre@@PAPAV12@00AAV?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@Z
_TEXT	SEGMENT
$T160472 = -2						; size = 1
$T160471 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@PAPAVD3D9VertexDecl@Ogre@@PAPAV12@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@stdext@@YAPAPAVD3D9VertexDecl@Ogre@@PAPAV12@00AAV?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<Ogre::D3D9VertexDecl * *,Ogre::D3D9VertexDecl * *,std::allocator<Ogre::D3D9VertexDecl *> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T160471[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAPAVD3D9VertexDecl@Ogre@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVD3D9VertexDecl@Ogre@@0@Z ; std::_Ptr_cat<Ogre::D3D9VertexDecl * *,Ogre::D3D9VertexDecl * *>
	add	esp, 8
	mov	BYTE PTR $T160472[ebp], al
	movzx	eax, BYTE PTR $T160471[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T160472[ebp]
	push	ecx
	mov	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@PAPAVD3D9VertexDecl@Ogre@@@std@@YAPAPAVD3D9VertexDecl@Ogre@@AAPAPAV12@@Z ; std::_Checked_base<Ogre::D3D9VertexDecl * *>
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@PAPAVD3D9VertexDecl@Ogre@@@std@@YAPAPAVD3D9VertexDecl@Ogre@@AAPAPAV12@@Z ; std::_Checked_base<Ogre::D3D9VertexDecl * *>
	add	esp, 4
	push	eax
	call	??$_Uninit_copy@PAPAVD3D9VertexDecl@Ogre@@PAPAV12@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@YAPAPAVD3D9VertexDecl@Ogre@@PAPAV12@00AAV?$allocator@PAVD3D9VertexDecl@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Ogre::D3D9VertexDecl * *,Ogre::D3D9VertexDecl * *,std::allocator<Ogre::D3D9VertexDecl *> >
	add	esp, 24					; 00000018H

; 823  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_copy@PAPAVD3D9VertexDecl@Ogre@@PAPAV12@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@stdext@@YAPAPAVD3D9VertexDecl@Ogre@@PAPAV12@00AAV?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<Ogre::D3D9VertexDecl * *,Ogre::D3D9VertexDecl * *,std::allocator<Ogre::D3D9VertexDecl *> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Fill_n@PAPAVD3DRenderWindow@Ogre@@IPAV12@@std@@YAXPAPAVD3DRenderWindow@Ogre@@IABQAV12@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Fill_n@PAPAVD3DRenderWindow@Ogre@@IPAV12@@std@@YAXPAPAVD3DRenderWindow@Ogre@@IABQAV12@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Fill_n<Ogre::D3DRenderWindow * *,unsigned int,Ogre::D3DRenderWindow *>, COMDAT

; 3196 : 	{	// copy _Val _Count times through [_First, ...)

	push	ebp
	mov	ebp, esp

; 3197 : 	for (; 0 < _Count; --_Count, ++_First)

	jmp	SHORT $LN3@Fill_n
$LN2@Fill_n:
	mov	eax, DWORD PTR __Count$[ebp]
	sub	eax, 1
	mov	DWORD PTR __Count$[ebp], eax
	mov	ecx, DWORD PTR __First$[ebp]
	add	ecx, 4
	mov	DWORD PTR __First$[ebp], ecx
$LN3@Fill_n:
	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN4@Fill_n

; 3198 : 		*_First = _Val;

	mov	edx, DWORD PTR __First$[ebp]
	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	jmp	SHORT $LN2@Fill_n
$LN4@Fill_n:

; 3199 : 	}

	pop	ebp
	ret	0
??$_Fill_n@PAPAVD3DRenderWindow@Ogre@@IPAV12@@std@@YAXPAPAVD3DRenderWindow@Ogre@@IABQAV12@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Fill_n<Ogre::D3DRenderWindow * *,unsigned int,Ogre::D3DRenderWindow *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Fill_n@PAPAVD3D9VertexDecl@Ogre@@IPAV12@@std@@YAXPAPAVD3D9VertexDecl@Ogre@@IABQAV12@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Fill_n@PAPAVD3D9VertexDecl@Ogre@@IPAV12@@std@@YAXPAPAVD3D9VertexDecl@Ogre@@IABQAV12@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Fill_n<Ogre::D3D9VertexDecl * *,unsigned int,Ogre::D3D9VertexDecl *>, COMDAT

; 3196 : 	{	// copy _Val _Count times through [_First, ...)

	push	ebp
	mov	ebp, esp

; 3197 : 	for (; 0 < _Count; --_Count, ++_First)

	jmp	SHORT $LN3@Fill_n@2
$LN2@Fill_n@2:
	mov	eax, DWORD PTR __Count$[ebp]
	sub	eax, 1
	mov	DWORD PTR __Count$[ebp], eax
	mov	ecx, DWORD PTR __First$[ebp]
	add	ecx, 4
	mov	DWORD PTR __First$[ebp], ecx
$LN3@Fill_n@2:
	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN4@Fill_n@2

; 3198 : 		*_First = _Val;

	mov	edx, DWORD PTR __First$[ebp]
	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	jmp	SHORT $LN2@Fill_n@2
$LN4@Fill_n@2:

; 3199 : 	}

	pop	ebp
	ret	0
??$_Fill_n@PAPAVD3D9VertexDecl@Ogre@@IPAV12@@std@@YAXPAPAVD3D9VertexDecl@Ogre@@IABQAV12@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Fill_n<Ogre::D3D9VertexDecl * *,unsigned int,Ogre::D3D9VertexDecl *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@PAPAVD3DRenderWindow@Ogre@@PAPAV12@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@YAPAPAVD3DRenderWindow@Ogre@@PAPAV12@00AAV?$allocator@PAVD3DRenderWindow@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Result$ = -8						; size = 4
__Count$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PAPAVD3DRenderWindow@Ogre@@PAPAV12@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@YAPAPAVD3DRenderWindow@Ogre@@PAPAV12@00AAV?$allocator@PAVD3DRenderWindow@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<Ogre::D3DRenderWindow * *,Ogre::D3DRenderWindow * *,std::allocator<Ogre::D3DRenderWindow *> >, COMDAT

; 145  : 	{	// copy [_First, _Last) to raw _Dest, scalar type

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 146  : 	_DEBUG_RANGE(_First, _Last);
; 147  : 	_DEBUG_POINTER(_Dest);
; 148  : 	size_t _Count = (size_t)(_Last - _First);

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 2
	mov	DWORD PTR __Count$[ebp], eax

; 149  : 	_FwdIt _Result = _Dest + _Count;

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Dest$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR __Result$[ebp], eax

; 150  : 	if (_Count > 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN1@Uninit_cop

; 151  : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Count * sizeof (*_First), &*_First, _Count * sizeof (*_First));	// NB: non-overlapping move

	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN1@Uninit_cop:

; 152  : 	return (_Result);

	mov	eax, DWORD PTR __Result$[ebp]

; 153  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Uninit_copy@PAPAVD3DRenderWindow@Ogre@@PAPAV12@V?$allocator@PAVD3DRenderWindow@Ogre@@@std@@@std@@YAPAPAVD3DRenderWindow@Ogre@@PAPAV12@00AAV?$allocator@PAVD3DRenderWindow@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<Ogre::D3DRenderWindow * *,Ogre::D3DRenderWindow * *,std::allocator<Ogre::D3DRenderWindow *> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@PAPAVD3D9VertexDecl@Ogre@@PAPAV12@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@YAPAPAVD3D9VertexDecl@Ogre@@PAPAV12@00AAV?$allocator@PAVD3D9VertexDecl@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Result$ = -8						; size = 4
__Count$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PAPAVD3D9VertexDecl@Ogre@@PAPAV12@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@YAPAPAVD3D9VertexDecl@Ogre@@PAPAV12@00AAV?$allocator@PAVD3D9VertexDecl@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<Ogre::D3D9VertexDecl * *,Ogre::D3D9VertexDecl * *,std::allocator<Ogre::D3D9VertexDecl *> >, COMDAT

; 145  : 	{	// copy [_First, _Last) to raw _Dest, scalar type

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 146  : 	_DEBUG_RANGE(_First, _Last);
; 147  : 	_DEBUG_POINTER(_Dest);
; 148  : 	size_t _Count = (size_t)(_Last - _First);

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 2
	mov	DWORD PTR __Count$[ebp], eax

; 149  : 	_FwdIt _Result = _Dest + _Count;

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Dest$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR __Result$[ebp], eax

; 150  : 	if (_Count > 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN1@Uninit_cop@2

; 151  : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Count * sizeof (*_First), &*_First, _Count * sizeof (*_First));	// NB: non-overlapping move

	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN1@Uninit_cop@2:

; 152  : 	return (_Result);

	mov	eax, DWORD PTR __Result$[ebp]

; 153  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Uninit_copy@PAPAVD3D9VertexDecl@Ogre@@PAPAV12@V?$allocator@PAVD3D9VertexDecl@Ogre@@@std@@@std@@YAPAPAVD3D9VertexDecl@Ogre@@PAPAV12@00AAV?$allocator@PAVD3D9VertexDecl@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<Ogre::D3D9VertexDecl * *,Ogre::D3D9VertexDecl * *,std::allocator<Ogre::D3D9VertexDecl *> >
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogremath.h
_TEXT	ENDS
;	COMDAT ??__ETWO_PI@Ogre@@YAXXZ
text$yc	SEGMENT
??__ETWO_PI@Ogre@@YAXXZ PROC				; Ogre::`dynamic initializer for 'TWO_PI'', COMDAT

; 10   : 	const float TWO_PI = ONE_PI*2;

	push	ebp
	mov	ebp, esp
	fld	DWORD PTR _ONE_PI
	fadd	ST(0), ST(0)
	fstp	DWORD PTR _TWO_PI
	pop	ebp
	ret	0
??__ETWO_PI@Ogre@@YAXXZ ENDP				; Ogre::`dynamic initializer for 'TWO_PI''
text$yc	ENDS
PUBLIC	__real@3fe0000000000000
;	COMDAT __real@3fe0000000000000
CONST	SEGMENT
__real@3fe0000000000000 DQ 03fe0000000000000r	; 0.5
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ??__EHALF_PI@Ogre@@YAXXZ
text$yc	SEGMENT
??__EHALF_PI@Ogre@@YAXXZ PROC				; Ogre::`dynamic initializer for 'HALF_PI'', COMDAT

; 11   : 	const float	HALF_PI = ONE_PI*0.5f;

	push	ebp
	mov	ebp, esp
	fld	DWORD PTR _ONE_PI
	fmul	QWORD PTR __real@3fe0000000000000
	fstp	DWORD PTR _HALF_PI
	pop	ebp
	ret	0
??__EHALF_PI@Ogre@@YAXXZ ENDP				; Ogre::`dynamic initializer for 'HALF_PI''
text$yc	ENDS
_BSS	SEGMENT
_TWO_PI	DD	01H DUP (?)
_HALF_PI DD	01H DUP (?)
_BSS	ENDS
CRT$XCU	SEGMENT
_TWO_PI$initializer$ DD FLAT:??__ETWO_PI@Ogre@@YAXXZ
_HALF_PI$initializer$ DD FLAT:??__EHALF_PI@Ogre@@YAXXZ
CRT$XCU	ENDS
END

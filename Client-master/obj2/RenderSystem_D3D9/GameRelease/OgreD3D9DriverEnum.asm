; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	i:\svnroot\client\Plugins\RenderSystem_D3D9\OgreD3D9DriverEnum.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	?_Value@?$_Is_swap_move@U_Swap_move_tag@std@@@std@@2_NB ; std::_Is_swap_move<std::_Swap_move_tag>::_Value
PUBLIC	?collate@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::collate
PUBLIC	?ctype@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::ctype
PUBLIC	?monetary@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::monetary
PUBLIC	?numeric@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::numeric
PUBLIC	?time@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::time
PUBLIC	?messages@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::messages
PUBLIC	?all@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::all
PUBLIC	?none@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::none
PUBLIC	?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::skipws
PUBLIC	?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::unitbuf
PUBLIC	?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::uppercase
PUBLIC	?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showbase
PUBLIC	?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpoint
PUBLIC	?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpos
PUBLIC	?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::left
PUBLIC	?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::right
PUBLIC	?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::internal
PUBLIC	?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::dec
PUBLIC	?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::oct
PUBLIC	?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::hex
PUBLIC	?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::scientific
PUBLIC	?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::fixed
PUBLIC	?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::hexfloat
PUBLIC	?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::boolalpha
PUBLIC	?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::_Stdio
PUBLIC	?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::adjustfield
PUBLIC	?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::basefield
PUBLIC	?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::floatfield
PUBLIC	?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::goodbit
PUBLIC	?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::eofbit
PUBLIC	?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::failbit
PUBLIC	?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::badbit
PUBLIC	?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::_Hardfail
PUBLIC	?in@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::in
PUBLIC	?out@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::out
PUBLIC	?ate@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::ate
PUBLIC	?app@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::app
PUBLIC	?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::trunc
PUBLIC	?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Nocreate
PUBLIC	?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Noreplace
PUBLIC	?binary@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::binary
PUBLIC	?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::beg
PUBLIC	?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::cur
PUBLIC	?end@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::end
PUBLIC	?value@?$integral_constant@_N$0A@@tr1@std@@2_NB	; std::tr1::integral_constant<bool,0>::value
PUBLIC	?value@?$integral_constant@_N$00@tr1@std@@2_NB	; std::tr1::integral_constant<bool,1>::value
;	COMDAT ?value@?$integral_constant@_N$00@tr1@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$00@tr1@std@@2_NB DB 01H	; std::tr1::integral_constant<bool,1>::value
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$0A@@tr1@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$0A@@tr1@std@@2_NB DB 00H	; std::tr1::integral_constant<bool,0>::value
CONST	ENDS
;	COMDAT ?end@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?end@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 02H		; std::_Iosb<int>::end
CONST	ENDS
;	COMDAT ?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 01H		; std::_Iosb<int>::cur
CONST	ENDS
;	COMDAT ?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 00H		; std::_Iosb<int>::beg
CONST	ENDS
;	COMDAT ?binary@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?binary@?$_Iosb@H@std@@2W4_Openmode@12@B DD 020H	; std::_Iosb<int>::binary
CONST	ENDS
;	COMDAT ?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B DD 080H	; std::_Iosb<int>::_Noreplace
CONST	ENDS
;	COMDAT ?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 040H	; std::_Iosb<int>::_Nocreate
CONST	ENDS
;	COMDAT ?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B DD 010H		; std::_Iosb<int>::trunc
CONST	ENDS
;	COMDAT ?app@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?app@?$_Iosb@H@std@@2W4_Openmode@12@B DD 08H		; std::_Iosb<int>::app
CONST	ENDS
;	COMDAT ?ate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?ate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 04H		; std::_Iosb<int>::ate
CONST	ENDS
;	COMDAT ?out@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?out@?$_Iosb@H@std@@2W4_Openmode@12@B DD 02H		; std::_Iosb<int>::out
CONST	ENDS
;	COMDAT ?in@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?in@?$_Iosb@H@std@@2W4_Openmode@12@B DD 01H		; std::_Iosb<int>::in
CONST	ENDS
;	COMDAT ?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B DD 010H	; std::_Iosb<int>::_Hardfail
CONST	ENDS
;	COMDAT ?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 04H		; std::_Iosb<int>::badbit
CONST	ENDS
;	COMDAT ?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 02H		; std::_Iosb<int>::failbit
CONST	ENDS
;	COMDAT ?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 01H		; std::_Iosb<int>::eofbit
CONST	ENDS
;	COMDAT ?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 00H		; std::_Iosb<int>::goodbit
CONST	ENDS
;	COMDAT ?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 03000H	; std::_Iosb<int>::floatfield
CONST	ENDS
;	COMDAT ?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0e00H	; std::_Iosb<int>::basefield
CONST	ENDS
;	COMDAT ?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01c0H	; std::_Iosb<int>::adjustfield
CONST	ENDS
;	COMDAT ?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08000H	; std::_Iosb<int>::_Stdio
CONST	ENDS
;	COMDAT ?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04000H	; std::_Iosb<int>::boolalpha
CONST	ENDS
;	COMDAT ?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 03000H	; std::_Iosb<int>::hexfloat
CONST	ENDS
;	COMDAT ?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02000H	; std::_Iosb<int>::fixed
CONST	ENDS
;	COMDAT ?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01000H	; std::_Iosb<int>::scientific
CONST	ENDS
;	COMDAT ?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0800H		; std::_Iosb<int>::hex
CONST	ENDS
;	COMDAT ?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0400H		; std::_Iosb<int>::oct
CONST	ENDS
;	COMDAT ?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0200H		; std::_Iosb<int>::dec
CONST	ENDS
;	COMDAT ?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0100H	; std::_Iosb<int>::internal
CONST	ENDS
;	COMDAT ?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 080H		; std::_Iosb<int>::right
CONST	ENDS
;	COMDAT ?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 040H		; std::_Iosb<int>::left
CONST	ENDS
;	COMDAT ?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 020H	; std::_Iosb<int>::showpos
CONST	ENDS
;	COMDAT ?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 010H	; std::_Iosb<int>::showpoint
CONST	ENDS
;	COMDAT ?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08H	; std::_Iosb<int>::showbase
CONST	ENDS
;	COMDAT ?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04H	; std::_Iosb<int>::uppercase
CONST	ENDS
;	COMDAT ?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02H	; std::_Iosb<int>::unitbuf
CONST	ENDS
;	COMDAT ?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01H		; std::_Iosb<int>::skipws
CONST	ENDS
;	COMDAT ?none@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?none@?$_Locbase@H@std@@2HB DD 00H			; std::_Locbase<int>::none
CONST	ENDS
;	COMDAT ?all@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?all@?$_Locbase@H@std@@2HB DD 03fH			; std::_Locbase<int>::all
CONST	ENDS
;	COMDAT ?messages@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?messages@?$_Locbase@H@std@@2HB DD 020H			; std::_Locbase<int>::messages
CONST	ENDS
;	COMDAT ?time@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?time@?$_Locbase@H@std@@2HB DD 010H			; std::_Locbase<int>::time
CONST	ENDS
;	COMDAT ?numeric@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?numeric@?$_Locbase@H@std@@2HB DD 08H			; std::_Locbase<int>::numeric
CONST	ENDS
;	COMDAT ?monetary@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?monetary@?$_Locbase@H@std@@2HB DD 04H			; std::_Locbase<int>::monetary
CONST	ENDS
;	COMDAT ?ctype@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?ctype@?$_Locbase@H@std@@2HB DD 02H			; std::_Locbase<int>::ctype
CONST	ENDS
;	COMDAT ?collate@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?collate@?$_Locbase@H@std@@2HB DD 01H			; std::_Locbase<int>::collate
CONST	ENDS
;	COMDAT ?_Value@?$_Is_swap_move@U_Swap_move_tag@std@@@std@@2_NB
CONST	SEGMENT
?_Value@?$_Is_swap_move@U_Swap_move_tag@std@@@std@@2_NB DB 01H ; std::_Is_swap_move<std::_Swap_move_tag>::_Value
CONST	ENDS
_DATA	SEGMENT
__bad_alloc_Message DD FLAT:$SG5714
_DATA	ENDS
CONST	SEGMENT
$SG5714	DB	'bad allocation', 00H
	ORG $+1
$SG129038 DB	0d2H, 0fdH, 0c7H, 0e6H, 0b3H, 0f5H, 0caH, 0bcH, 0bbH, 0afH
	DB	0b4H, 0edH, 0ceH, 0f3H, 00H
	ORG $+1
$SG129039 DB	0d5H, 0d2H, 0b2H, 0bbH, 0b5H, 0bdH, '3D', 0d3H, 0b2H, 0bcH
	DB	0feH, 0bcH, 0d3H, 0cbH, 0d9H, 0c9H, 0e8H, 0b1H, 0b8H, 0a3H, 0acH
	DB	0d3H, 0d0H, 0bfH, 0c9H, 0c4H, 0dcH, 0caH, 0c7H, 0c3H, 0bbH, 0d3H
	DB	0d0H, 0b0H, 0b2H, 0d7H, 0b0H, 0cfH, 0d4H, 0bfH, 0a8H, 0c7H, 0fdH
	DB	0b6H, 0afH, 0b3H, 0ccH, 0d0H, 0f2H, 0bbH, 0f2H, 0d5H, 0dfH, 'D'
	DB	'irectX9.0c', 00H
	ORG $+2
$SG129057 DB	'.\OgreD3D9DriverEnum.cpp', 00H
	ORG $+3
$SG129058 DB	'Choose D3DSettings: dispmode=(%d,%d,%d), dsformat=%d, in'
	DB	'terval=%d, msquality=%d, mstype=%d, vptype=%d', 00H
CONST	ENDS
PUBLIC	??1?$vector@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::D3DDEVCOMBO_T *,std::allocator<Ogre::D3DDEVCOMBO_T *> >::~vector<Ogre::D3DDEVCOMBO_T *,std::allocator<Ogre::D3DDEVCOMBO_T *> >
PUBLIC	??_GD3DDEVCOMBO_T@Ogre@@QAEPAXI@Z		; Ogre::D3DDEVCOMBO_T::`scalar deleting destructor'
PUBLIC	??A?$vector@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@QAEAAPAUD3DDEVCOMBO_T@Ogre@@I@Z ; std::vector<Ogre::D3DDEVCOMBO_T *,std::allocator<Ogre::D3DDEVCOMBO_T *> >::operator[]
PUBLIC	?size@?$vector@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::D3DDEVCOMBO_T *,std::allocator<Ogre::D3DDEVCOMBO_T *> >::size
PUBLIC	??1D3DDEVICEINFO_T@Ogre@@QAE@XZ			; Ogre::D3DDEVICEINFO_T::~D3DDEVICEINFO_T
EXTRN	___security_cookie:DWORD
EXTRN	___CxxFrameHandler3:PROC
EXTRN	@__security_check_cookie@4:PROC
xdata$x	SEGMENT
__unwindtable$??1D3DDEVICEINFO_T@Ogre@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1D3DDEVICEINFO_T@Ogre@@QAE@XZ$0
__ehfuncinfo$??1D3DDEVICEINFO_T@Ogre@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1D3DDEVICEINFO_T@Ogre@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
; File i:\svnroot\client\plugins\rendersystem_d3d9\ogred3d9driverenum.cpp
xdata$x	ENDS
_TEXT	SEGMENT
tv79 = -32						; size = 4
_this$ = -28						; size = 4
$T141400 = -24						; size = 4
$T141399 = -20						; size = 4
_i$128705 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1D3DDEVICEINFO_T@Ogre@@QAE@XZ PROC			; Ogre::D3DDEVICEINFO_T::~D3DDEVICEINFO_T
; _this$ = ecx

; 126  : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1D3DDEVICEINFO_T@Ogre@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 20					; 00000014H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 127  : 		for( SIZE_T i=0; i<devcombo.size(); i++ )

	mov	DWORD PTR _i$128705[ebp], 0
	jmp	SHORT $LN3@D3DDEVICEI
$LN2@D3DDEVICEI:
	mov	eax, DWORD PTR _i$128705[ebp]
	add	eax, 1
	mov	DWORD PTR _i$128705[ebp], eax
$LN3@D3DDEVICEI:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 312				; 00000138H
	call	?size@?$vector@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::D3DDEVCOMBO_T *,std::allocator<Ogre::D3DDEVCOMBO_T *> >::size
	cmp	DWORD PTR _i$128705[ebp], eax
	jae	SHORT $LN4@D3DDEVICEI

; 128  : 		{
; 129  : 			delete(devcombo[i]);

	mov	ecx, DWORD PTR _i$128705[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 312				; 00000138H
	call	??A?$vector@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@QAEAAPAUD3DDEVCOMBO_T@Ogre@@I@Z ; std::vector<Ogre::D3DDEVCOMBO_T *,std::allocator<Ogre::D3DDEVCOMBO_T *> >::operator[]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR $T141400[ebp], edx
	mov	eax, DWORD PTR $T141400[ebp]
	mov	DWORD PTR $T141399[ebp], eax
	cmp	DWORD PTR $T141399[ebp], 0
	je	SHORT $LN6@D3DDEVICEI
	push	1
	mov	ecx, DWORD PTR $T141399[ebp]
	call	??_GD3DDEVCOMBO_T@Ogre@@QAEPAXI@Z
	mov	DWORD PTR tv79[ebp], eax
	jmp	SHORT $LN7@D3DDEVICEI
$LN6@D3DDEVICEI:
	mov	DWORD PTR tv79[ebp], 0
$LN7@D3DDEVICEI:

; 130  : 		}

	jmp	SHORT $LN2@D3DDEVICEI
$LN4@D3DDEVICEI:

; 131  : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 312				; 00000138H
	call	??1?$vector@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::D3DDEVCOMBO_T *,std::allocator<Ogre::D3DDEVCOMBO_T *> >::~vector<Ogre::D3DDEVCOMBO_T *,std::allocator<Ogre::D3DDEVCOMBO_T *> >
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$??1D3DDEVICEINFO_T@Ogre@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 312				; 00000138H
	jmp	??1?$vector@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::D3DDEVCOMBO_T *,std::allocator<Ogre::D3DDEVCOMBO_T *> >::~vector<Ogre::D3DDEVCOMBO_T *,std::allocator<Ogre::D3DDEVCOMBO_T *> >
__ehhandler$??1D3DDEVICEINFO_T@Ogre@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1D3DDEVICEINFO_T@Ogre@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1D3DDEVICEINFO_T@Ogre@@QAE@XZ ENDP			; Ogre::D3DDEVICEINFO_T::~D3DDEVICEINFO_T
PUBLIC	??1D3DDEVCOMBO_T@Ogre@@QAE@XZ			; Ogre::D3DDEVCOMBO_T::~D3DDEVCOMBO_T
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
; Function compile flags: /Odtp
;	COMDAT ??_GD3DDEVCOMBO_T@Ogre@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GD3DDEVCOMBO_T@Ogre@@QAEPAXI@Z PROC			; Ogre::D3DDEVCOMBO_T::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1D3DDEVCOMBO_T@Ogre@@QAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GD3DDEVCOMBO_T@Ogre@@QAEPAXI@Z ENDP			; Ogre::D3DDEVCOMBO_T::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??1?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@QAE@XZ ; std::vector<enum _D3DFORMAT,std::allocator<enum _D3DFORMAT> >::~vector<enum _D3DFORMAT,std::allocator<enum _D3DFORMAT> >
PUBLIC	??1?$vector@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@QAE@XZ ; std::vector<enum _D3DMULTISAMPLE_TYPE,std::allocator<enum _D3DMULTISAMPLE_TYPE> >::~vector<enum _D3DMULTISAMPLE_TYPE,std::allocator<enum _D3DMULTISAMPLE_TYPE> >
PUBLIC	??1?$vector@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::D3DSMSCONFLICT_T,std::allocator<Ogre::D3DSMSCONFLICT_T> >::~vector<Ogre::D3DSMSCONFLICT_T,std::allocator<Ogre::D3DSMSCONFLICT_T> >
PUBLIC	??1?$vector@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@QAE@XZ ; std::vector<enum Ogre::VERTPROCESS_T,std::allocator<enum Ogre::VERTPROCESS_T> >::~vector<enum Ogre::VERTPROCESS_T,std::allocator<enum Ogre::VERTPROCESS_T> >
PUBLIC	??1?$vector@IV?$allocator@I@std@@@std@@QAE@XZ	; std::vector<unsigned int,std::allocator<unsigned int> >::~vector<unsigned int,std::allocator<unsigned int> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1D3DDEVCOMBO_T@Ogre@@QAE@XZ DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$??1D3DDEVCOMBO_T@Ogre@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__unwindtable$??1D3DDEVCOMBO_T@Ogre@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1D3DDEVCOMBO_T@Ogre@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1D3DDEVCOMBO_T@Ogre@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??1D3DDEVCOMBO_T@Ogre@@QAE@XZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$??1D3DDEVCOMBO_T@Ogre@@QAE@XZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$??1D3DDEVCOMBO_T@Ogre@@QAE@XZ$4
	DD	04H
	DD	FLAT:__unwindfunclet$??1D3DDEVCOMBO_T@Ogre@@QAE@XZ$5
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1D3DDEVCOMBO_T@Ogre@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1D3DDEVCOMBO_T@Ogre@@QAE@XZ PROC			; Ogre::D3DDEVCOMBO_T::~D3DDEVCOMBO_T, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1D3DDEVCOMBO_T@Ogre@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 5
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 140				; 0000008cH
	call	??1?$vector@IV?$allocator@I@std@@@std@@QAE@XZ ; std::vector<unsigned int,std::allocator<unsigned int> >::~vector<unsigned int,std::allocator<unsigned int> >
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 116				; 00000074H
	call	??1?$vector@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@QAE@XZ ; std::vector<enum Ogre::VERTPROCESS_T,std::allocator<enum Ogre::VERTPROCESS_T> >::~vector<enum Ogre::VERTPROCESS_T,std::allocator<enum Ogre::VERTPROCESS_T> >
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 92					; 0000005cH
	call	??1?$vector@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::D3DSMSCONFLICT_T,std::allocator<Ogre::D3DSMSCONFLICT_T> >::~vector<Ogre::D3DSMSCONFLICT_T,std::allocator<Ogre::D3DSMSCONFLICT_T> >
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 68					; 00000044H
	call	??1?$vector@IV?$allocator@I@std@@@std@@QAE@XZ ; std::vector<unsigned int,std::allocator<unsigned int> >::~vector<unsigned int,std::allocator<unsigned int> >
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 44					; 0000002cH
	call	??1?$vector@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@QAE@XZ ; std::vector<enum _D3DMULTISAMPLE_TYPE,std::allocator<enum _D3DMULTISAMPLE_TYPE> >::~vector<enum _D3DMULTISAMPLE_TYPE,std::allocator<enum _D3DMULTISAMPLE_TYPE> >
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 20					; 00000014H
	call	??1?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@QAE@XZ ; std::vector<enum _D3DFORMAT,std::allocator<enum _D3DFORMAT> >::~vector<enum _D3DFORMAT,std::allocator<enum _D3DFORMAT> >
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1D3DDEVCOMBO_T@Ogre@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 20					; 00000014H
	jmp	??1?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@QAE@XZ ; std::vector<enum _D3DFORMAT,std::allocator<enum _D3DFORMAT> >::~vector<enum _D3DFORMAT,std::allocator<enum _D3DFORMAT> >
__unwindfunclet$??1D3DDEVCOMBO_T@Ogre@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 44					; 0000002cH
	jmp	??1?$vector@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@QAE@XZ ; std::vector<enum _D3DMULTISAMPLE_TYPE,std::allocator<enum _D3DMULTISAMPLE_TYPE> >::~vector<enum _D3DMULTISAMPLE_TYPE,std::allocator<enum _D3DMULTISAMPLE_TYPE> >
__unwindfunclet$??1D3DDEVCOMBO_T@Ogre@@QAE@XZ$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 68					; 00000044H
	jmp	??1?$vector@IV?$allocator@I@std@@@std@@QAE@XZ ; std::vector<unsigned int,std::allocator<unsigned int> >::~vector<unsigned int,std::allocator<unsigned int> >
__unwindfunclet$??1D3DDEVCOMBO_T@Ogre@@QAE@XZ$3:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 92					; 0000005cH
	jmp	??1?$vector@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::D3DSMSCONFLICT_T,std::allocator<Ogre::D3DSMSCONFLICT_T> >::~vector<Ogre::D3DSMSCONFLICT_T,std::allocator<Ogre::D3DSMSCONFLICT_T> >
__unwindfunclet$??1D3DDEVCOMBO_T@Ogre@@QAE@XZ$4:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 116				; 00000074H
	jmp	??1?$vector@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@QAE@XZ ; std::vector<enum Ogre::VERTPROCESS_T,std::allocator<enum Ogre::VERTPROCESS_T> >::~vector<enum Ogre::VERTPROCESS_T,std::allocator<enum Ogre::VERTPROCESS_T> >
__unwindfunclet$??1D3DDEVCOMBO_T@Ogre@@QAE@XZ$5:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 140				; 0000008cH
	jmp	??1?$vector@IV?$allocator@I@std@@@std@@QAE@XZ ; std::vector<unsigned int,std::allocator<unsigned int> >::~vector<unsigned int,std::allocator<unsigned int> >
__ehhandler$??1D3DDEVCOMBO_T@Ogre@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1D3DDEVCOMBO_T@Ogre@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1D3DDEVCOMBO_T@Ogre@@QAE@XZ ENDP			; Ogre::D3DDEVCOMBO_T::~D3DDEVCOMBO_T
PUBLIC	??1?$vector@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@QAE@XZ ; std::vector<_D3DDISPLAYMODE,std::allocator<_D3DDISPLAYMODE> >::~vector<_D3DDISPLAYMODE,std::allocator<_D3DDISPLAYMODE> >
PUBLIC	??1?$vector@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::D3DDEVICEINFO_T *,std::allocator<Ogre::D3DDEVICEINFO_T *> >::~vector<Ogre::D3DDEVICEINFO_T *,std::allocator<Ogre::D3DDEVICEINFO_T *> >
PUBLIC	??_GD3DDEVICEINFO_T@Ogre@@QAEPAXI@Z		; Ogre::D3DDEVICEINFO_T::`scalar deleting destructor'
PUBLIC	??A?$vector@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@QAEAAPAUD3DDEVICEINFO_T@Ogre@@I@Z ; std::vector<Ogre::D3DDEVICEINFO_T *,std::allocator<Ogre::D3DDEVICEINFO_T *> >::operator[]
PUBLIC	?size@?$vector@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::D3DDEVICEINFO_T *,std::allocator<Ogre::D3DDEVICEINFO_T *> >::size
PUBLIC	??1D3DADAPTER_T@Ogre@@QAE@XZ			; Ogre::D3DADAPTER_T::~D3DADAPTER_T
xdata$x	SEGMENT
__unwindtable$??1D3DADAPTER_T@Ogre@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1D3DADAPTER_T@Ogre@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1D3DADAPTER_T@Ogre@@QAE@XZ$1
__ehfuncinfo$??1D3DADAPTER_T@Ogre@@QAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??1D3DADAPTER_T@Ogre@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
_TEXT	SEGMENT
tv81 = -32						; size = 4
_this$ = -28						; size = 4
$T141431 = -24						; size = 4
$T141430 = -20						; size = 4
_i$128720 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1D3DADAPTER_T@Ogre@@QAE@XZ PROC			; Ogre::D3DADAPTER_T::~D3DADAPTER_T
; _this$ = ecx

; 134  : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1D3DADAPTER_T@Ogre@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 20					; 00000014H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 135  : 		for( SIZE_T i=0; i<devinfo.size(); i++ )

	mov	DWORD PTR _i$128720[ebp], 0
	jmp	SHORT $LN3@D3DADAPTER
$LN2@D3DADAPTER:
	mov	eax, DWORD PTR _i$128720[ebp]
	add	eax, 1
	mov	DWORD PTR _i$128720[ebp], eax
$LN3@D3DADAPTER:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1128				; 00000468H
	call	?size@?$vector@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::D3DDEVICEINFO_T *,std::allocator<Ogre::D3DDEVICEINFO_T *> >::size
	cmp	DWORD PTR _i$128720[ebp], eax
	jae	SHORT $LN4@D3DADAPTER

; 136  : 		{
; 137  : 			delete(devinfo[i]);

	mov	ecx, DWORD PTR _i$128720[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1128				; 00000468H
	call	??A?$vector@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@QAEAAPAUD3DDEVICEINFO_T@Ogre@@I@Z ; std::vector<Ogre::D3DDEVICEINFO_T *,std::allocator<Ogre::D3DDEVICEINFO_T *> >::operator[]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR $T141431[ebp], edx
	mov	eax, DWORD PTR $T141431[ebp]
	mov	DWORD PTR $T141430[ebp], eax
	cmp	DWORD PTR $T141430[ebp], 0
	je	SHORT $LN6@D3DADAPTER
	push	1
	mov	ecx, DWORD PTR $T141430[ebp]
	call	??_GD3DDEVICEINFO_T@Ogre@@QAEPAXI@Z
	mov	DWORD PTR tv81[ebp], eax
	jmp	SHORT $LN7@D3DADAPTER
$LN6@D3DADAPTER:
	mov	DWORD PTR tv81[ebp], 0
$LN7@D3DADAPTER:

; 138  : 		}

	jmp	SHORT $LN2@D3DADAPTER
$LN4@D3DADAPTER:

; 139  : 	}

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1128				; 00000468H
	call	??1?$vector@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::D3DDEVICEINFO_T *,std::allocator<Ogre::D3DDEVICEINFO_T *> >::~vector<Ogre::D3DDEVICEINFO_T *,std::allocator<Ogre::D3DDEVICEINFO_T *> >
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1104				; 00000450H
	call	??1?$vector@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@QAE@XZ ; std::vector<_D3DDISPLAYMODE,std::allocator<_D3DDISPLAYMODE> >::~vector<_D3DDISPLAYMODE,std::allocator<_D3DDISPLAYMODE> >
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$??1D3DADAPTER_T@Ogre@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1104				; 00000450H
	jmp	??1?$vector@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@QAE@XZ ; std::vector<_D3DDISPLAYMODE,std::allocator<_D3DDISPLAYMODE> >::~vector<_D3DDISPLAYMODE,std::allocator<_D3DDISPLAYMODE> >
__unwindfunclet$??1D3DADAPTER_T@Ogre@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1128				; 00000468H
	jmp	??1?$vector@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::D3DDEVICEINFO_T *,std::allocator<Ogre::D3DDEVICEINFO_T *> >::~vector<Ogre::D3DDEVICEINFO_T *,std::allocator<Ogre::D3DDEVICEINFO_T *> >
__ehhandler$??1D3DADAPTER_T@Ogre@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1D3DADAPTER_T@Ogre@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1D3DADAPTER_T@Ogre@@QAE@XZ ENDP			; Ogre::D3DADAPTER_T::~D3DADAPTER_T
; Function compile flags: /Odtp
;	COMDAT ??_GD3DDEVICEINFO_T@Ogre@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GD3DDEVICEINFO_T@Ogre@@QAEPAXI@Z PROC		; Ogre::D3DDEVICEINFO_T::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1D3DDEVICEINFO_T@Ogre@@QAE@XZ		; Ogre::D3DDEVICEINFO_T::~D3DDEVICEINFO_T
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@2
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@2:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GD3DDEVICEINFO_T@Ogre@@QAEPAXI@Z ENDP		; Ogre::D3DDEVICEINFO_T::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??1?$vector@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::D3DADAPTER_T *,std::allocator<Ogre::D3DADAPTER_T *> >::~vector<Ogre::D3DADAPTER_T *,std::allocator<Ogre::D3DADAPTER_T *> >
PUBLIC	?push_back@?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@QAEXABW4_D3DFORMAT@@@Z ; std::vector<enum _D3DFORMAT,std::allocator<enum _D3DFORMAT> >::push_back
PUBLIC	??0?$vector@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::D3DADAPTER_T *,std::allocator<Ogre::D3DADAPTER_T *> >::vector<Ogre::D3DADAPTER_T *,std::allocator<Ogre::D3DADAPTER_T *> >
PUBLIC	??0?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@QAE@XZ ; std::vector<enum _D3DFORMAT,std::allocator<enum _D3DFORMAT> >::vector<enum _D3DFORMAT,std::allocator<enum _D3DFORMAT> >
PUBLIC	??0D3DEnumeration@Ogre@@QAE@XZ			; Ogre::D3DEnumeration::D3DEnumeration
EXTRN	_memset:PROC
xdata$x	SEGMENT
__unwindtable$??0D3DEnumeration@Ogre@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0D3DEnumeration@Ogre@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0D3DEnumeration@Ogre@@QAE@XZ$1
__ehfuncinfo$??0D3DEnumeration@Ogre@@QAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0D3DEnumeration@Ogre@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
_TEXT	SEGMENT
_this$ = -32						; size = 4
$T141446 = -28						; size = 4
$T141445 = -24						; size = 4
$T141444 = -20						; size = 4
$T141443 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0D3DEnumeration@Ogre@@QAE@XZ PROC			; Ogre::D3DEnumeration::D3DEnumeration
; _this$ = ecx

; 142  : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0D3DEnumeration@Ogre@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 20					; 00000014H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@QAE@XZ ; std::vector<enum _D3DFORMAT,std::allocator<enum _D3DFORMAT> >::vector<enum _D3DFORMAT,std::allocator<enum _D3DFORMAT> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	??0?$vector@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::D3DADAPTER_T *,std::allocator<Ogre::D3DADAPTER_T *> >::vector<Ogre::D3DADAPTER_T *,std::allocator<Ogre::D3DADAPTER_T *> >
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 143  : 		memset( &m_Settings, 0, sizeof(m_Settings) );

	push	48					; 00000030H
	push	0
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 96					; 00000060H
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 144  : 
; 145  : 		m_ConfirmDeviceCallback = NULL;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+48], 0

; 146  : 		m_MinFullScreenWidth = 640;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+52], 640			; 00000280H

; 147  : 		m_MinFullScreenHeight = 480;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+56], 480			; 000001e0H

; 148  : 		m_MinColorChannelBits = 4;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+60], 4

; 149  : 		m_MinAlphaChannelBits = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+64], 0

; 150  : 		m_MinDepthBits = 16;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+68], 16			; 00000010H

; 151  : 		m_MinStencilBits = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+72], 0

; 152  : 
; 153  : 		m_UseDepthBuf = TRUE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+76], 1

; 154  : 		m_UseMixedVP = FALSE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+80], 0

; 155  : 		m_RequireWindowed = FALSE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+84], 0

; 156  : 		m_RequireFullscreen = FALSE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+88], 0

; 157  : 
; 158  : 		m_pD3D = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+92], 0

; 159  : 		m_AllowedFmt.push_back( D3DFMT_X8R8G8B8 );

	mov	DWORD PTR $T141443[ebp], 22		; 00000016H
	lea	ecx, DWORD PTR $T141443[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?push_back@?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@QAEXABW4_D3DFORMAT@@@Z ; std::vector<enum _D3DFORMAT,std::allocator<enum _D3DFORMAT> >::push_back

; 160  : 		m_AllowedFmt.push_back( D3DFMT_X1R5G5B5 );

	mov	DWORD PTR $T141444[ebp], 24		; 00000018H
	lea	edx, DWORD PTR $T141444[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?push_back@?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@QAEXABW4_D3DFORMAT@@@Z ; std::vector<enum _D3DFORMAT,std::allocator<enum _D3DFORMAT> >::push_back

; 161  : 		m_AllowedFmt.push_back( D3DFMT_R5G6B5 );

	mov	DWORD PTR $T141445[ebp], 23		; 00000017H
	lea	eax, DWORD PTR $T141445[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?push_back@?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@QAEXABW4_D3DFORMAT@@@Z ; std::vector<enum _D3DFORMAT,std::allocator<enum _D3DFORMAT> >::push_back

; 162  : 		m_AllowedFmt.push_back( D3DFMT_A2R10G10B10 );

	mov	DWORD PTR $T141446[ebp], 35		; 00000023H
	lea	ecx, DWORD PTR $T141446[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?push_back@?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@QAEXABW4_D3DFORMAT@@@Z ; std::vector<enum _D3DFORMAT,std::allocator<enum _D3DFORMAT> >::push_back

; 163  : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$??0D3DEnumeration@Ogre@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@QAE@XZ ; std::vector<enum _D3DFORMAT,std::allocator<enum _D3DFORMAT> >::~vector<enum _D3DFORMAT,std::allocator<enum _D3DFORMAT> >
__unwindfunclet$??0D3DEnumeration@Ogre@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	jmp	??1?$vector@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::D3DADAPTER_T *,std::allocator<Ogre::D3DADAPTER_T *> >::~vector<Ogre::D3DADAPTER_T *,std::allocator<Ogre::D3DADAPTER_T *> >
__ehhandler$??0D3DEnumeration@Ogre@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0D3DEnumeration@Ogre@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0D3DEnumeration@Ogre@@QAE@XZ ENDP			; Ogre::D3DEnumeration::D3DEnumeration
PUBLIC	??_GD3DADAPTER_T@Ogre@@QAEPAXI@Z		; Ogre::D3DADAPTER_T::`scalar deleting destructor'
PUBLIC	??A?$vector@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@QAEAAPAUD3DADAPTER_T@Ogre@@I@Z ; std::vector<Ogre::D3DADAPTER_T *,std::allocator<Ogre::D3DADAPTER_T *> >::operator[]
PUBLIC	?size@?$vector@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::D3DADAPTER_T *,std::allocator<Ogre::D3DADAPTER_T *> >::size
PUBLIC	??1D3DEnumeration@Ogre@@QAE@XZ			; Ogre::D3DEnumeration::~D3DEnumeration
xdata$x	SEGMENT
__unwindtable$??1D3DEnumeration@Ogre@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1D3DEnumeration@Ogre@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1D3DEnumeration@Ogre@@QAE@XZ$1
__ehfuncinfo$??1D3DEnumeration@Ogre@@QAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??1D3DEnumeration@Ogre@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
_TEXT	SEGMENT
tv80 = -32						; size = 4
_this$ = -28						; size = 4
$T141455 = -24						; size = 4
$T141454 = -20						; size = 4
_i$128740 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1D3DEnumeration@Ogre@@QAE@XZ PROC			; Ogre::D3DEnumeration::~D3DEnumeration
; _this$ = ecx

; 166  : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1D3DEnumeration@Ogre@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 20					; 00000014H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 167  : 		for( SIZE_T i=0; i<m_Adapters.size(); i++ ) delete(m_Adapters[i]);

	mov	DWORD PTR _i$128740[ebp], 0
	jmp	SHORT $LN3@D3DEnumera
$LN2@D3DEnumera:
	mov	eax, DWORD PTR _i$128740[ebp]
	add	eax, 1
	mov	DWORD PTR _i$128740[ebp], eax
$LN3@D3DEnumera:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	?size@?$vector@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::D3DADAPTER_T *,std::allocator<Ogre::D3DADAPTER_T *> >::size
	cmp	DWORD PTR _i$128740[ebp], eax
	jae	SHORT $LN4@D3DEnumera
	mov	ecx, DWORD PTR _i$128740[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	??A?$vector@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@QAEAAPAUD3DADAPTER_T@Ogre@@I@Z ; std::vector<Ogre::D3DADAPTER_T *,std::allocator<Ogre::D3DADAPTER_T *> >::operator[]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR $T141455[ebp], edx
	mov	eax, DWORD PTR $T141455[ebp]
	mov	DWORD PTR $T141454[ebp], eax
	cmp	DWORD PTR $T141454[ebp], 0
	je	SHORT $LN6@D3DEnumera
	push	1
	mov	ecx, DWORD PTR $T141454[ebp]
	call	??_GD3DADAPTER_T@Ogre@@QAEPAXI@Z
	mov	DWORD PTR tv80[ebp], eax
	jmp	SHORT $LN7@D3DEnumera
$LN6@D3DEnumera:
	mov	DWORD PTR tv80[ebp], 0
$LN7@D3DEnumera:
	jmp	SHORT $LN2@D3DEnumera
$LN4@D3DEnumera:

; 168  : 	}

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	??1?$vector@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::D3DADAPTER_T *,std::allocator<Ogre::D3DADAPTER_T *> >::~vector<Ogre::D3DADAPTER_T *,std::allocator<Ogre::D3DADAPTER_T *> >
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@QAE@XZ ; std::vector<enum _D3DFORMAT,std::allocator<enum _D3DFORMAT> >::~vector<enum _D3DFORMAT,std::allocator<enum _D3DFORMAT> >
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$??1D3DEnumeration@Ogre@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@QAE@XZ ; std::vector<enum _D3DFORMAT,std::allocator<enum _D3DFORMAT> >::~vector<enum _D3DFORMAT,std::allocator<enum _D3DFORMAT> >
__unwindfunclet$??1D3DEnumeration@Ogre@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	jmp	??1?$vector@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::D3DADAPTER_T *,std::allocator<Ogre::D3DADAPTER_T *> >::~vector<Ogre::D3DADAPTER_T *,std::allocator<Ogre::D3DADAPTER_T *> >
__ehhandler$??1D3DEnumeration@Ogre@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1D3DEnumeration@Ogre@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1D3DEnumeration@Ogre@@QAE@XZ ENDP			; Ogre::D3DEnumeration::~D3DEnumeration
; Function compile flags: /Odtp
;	COMDAT ??_GD3DADAPTER_T@Ogre@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GD3DADAPTER_T@Ogre@@QAEPAXI@Z PROC			; Ogre::D3DADAPTER_T::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1D3DADAPTER_T@Ogre@@QAE@XZ		; Ogre::D3DADAPTER_T::~D3DADAPTER_T
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@3
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@3:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GD3DADAPTER_T@Ogre@@QAEPAXI@Z ENDP			; Ogre::D3DADAPTER_T::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?push_back@?$vector@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@QAEXABQAUD3DADAPTER_T@Ogre@@@Z ; std::vector<Ogre::D3DADAPTER_T *,std::allocator<Ogre::D3DADAPTER_T *> >::push_back
PUBLIC	?EnumerateDevices@D3DEnumeration@Ogre@@AAEXPAUD3DADAPTER_T@2@AAV?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@@Z ; Ogre::D3DEnumeration::EnumerateDevices
PUBLIC	??A?$vector@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@QAEAAU_D3DDISPLAYMODE@@I@Z ; std::vector<_D3DDISPLAYMODE,std::allocator<_D3DDISPLAYMODE> >::operator[]
PUBLIC	?size@?$vector@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@QBEIXZ ; std::vector<_D3DDISPLAYMODE,std::allocator<_D3DDISPLAYMODE> >::size
PUBLIC	??$IsVectorContain@W4_D3DFORMAT@@@Ogre@@YAHAAV?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@ABW4_D3DFORMAT@@@Z ; Ogre::IsVectorContain<enum _D3DFORMAT>
PUBLIC	?push_back@?$vector@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@QAEXABU_D3DDISPLAYMODE@@@Z ; std::vector<_D3DDISPLAYMODE,std::allocator<_D3DDISPLAYMODE> >::push_back
PUBLIC	??A?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@QAEAAW4_D3DFORMAT@@I@Z ; std::vector<enum _D3DFORMAT,std::allocator<enum _D3DFORMAT> >::operator[]
PUBLIC	?size@?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@QBEIXZ ; std::vector<enum _D3DFORMAT,std::allocator<enum _D3DFORMAT> >::size
PUBLIC	??0D3DADAPTER_T@Ogre@@QAE@XZ			; Ogre::D3DADAPTER_T::D3DADAPTER_T
PUBLIC	?Enumerate@D3DEnumeration@Ogre@@QAEHPAUIDirect3D9@@P6AHPAU_D3DCAPS9@@W4VERTPROCESS_T@2@W4_D3DFORMAT@@3@Z@Z ; Ogre::D3DEnumeration::Enumerate
EXTRN	__imp__qsort:PROC
EXTRN	??2@YAPAXI@Z:PROC				; operator new
xdata$x	SEGMENT
__unwindtable$?Enumerate@D3DEnumeration@Ogre@@QAEHPAUIDirect3D9@@P6AHPAU_D3DCAPS9@@W4VERTPROCESS_T@2@W4_D3DFORMAT@@3@Z@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Enumerate@D3DEnumeration@Ogre@@QAEHPAUIDirect3D9@@P6AHPAU_D3DCAPS9@@W4VERTPROCESS_T@2@W4_D3DFORMAT@@3@Z@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?Enumerate@D3DEnumeration@Ogre@@QAEHPAUIDirect3D9@@P6AHPAU_D3DCAPS9@@W4VERTPROCESS_T@2@W4_D3DFORMAT@@3@Z@Z$1
__ehfuncinfo$?Enumerate@D3DEnumeration@Ogre@@QAEHPAUIDirect3D9@@P6AHPAU_D3DCAPS9@@W4VERTPROCESS_T@2@W4_D3DFORMAT@@3@Z@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?Enumerate@D3DEnumeration@Ogre@@QAEHPAUIDirect3D9@@P6AHPAU_D3DCAPS9@@W4VERTPROCESS_T@2@W4_D3DFORMAT@@3@Z@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
_TEXT	SEGMENT
tv201 = -104						; size = 4
tv83 = -100						; size = 4
_this$ = -96						; size = 4
$T141472 = -92						; size = 4
$T141471 = -88						; size = 4
$T141468 = -84						; size = 4
$T141467 = -80						; size = 4
_tmpmode$128807 = -76					; size = 16
_imode$128803 = -60					; size = 4
_nadaptermode$128802 = -56				; size = 4
_iallow$128798 = -52					; size = 4
_padapter$128788 = -48					; size = 4
_allformats$128797 = -44				; size = 24
_iadapter$128784 = -20					; size = 4
_nadapter$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_pd3d$ = 8						; size = 4
_mycallback$ = 12					; size = 4
?Enumerate@D3DEnumeration@Ogre@@QAEHPAUIDirect3D9@@P6AHPAU_D3DCAPS9@@W4VERTPROCESS_T@2@W4_D3DFORMAT@@3@Z@Z PROC ; Ogre::D3DEnumeration::Enumerate
; _this$ = ecx

; 201  : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?Enumerate@D3DEnumeration@Ogre@@QAEHPAUIDirect3D9@@P6AHPAU_D3DCAPS9@@W4VERTPROCESS_T@2@W4_D3DFORMAT@@3@Z@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 92					; 0000005cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 202  : 		m_pD3D = pd3d;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pd3d$[ebp]
	mov	DWORD PTR [eax+92], ecx

; 203  : 		m_ConfirmDeviceCallback = mycallback;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _mycallback$[ebp]
	mov	DWORD PTR [edx+48], eax

; 204  : 
; 205  : 		UINT32 nadapter = m_pD3D->GetAdapterCount();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+92]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+92]
	mov	edx, DWORD PTR [edx]
	push	ecx
	mov	eax, DWORD PTR [edx+16]
	call	eax
	mov	DWORD PTR _nadapter$[ebp], eax

; 206  : 		for( UINT32 iadapter=0; iadapter<nadapter; iadapter++ )

	mov	DWORD PTR _iadapter$128784[ebp], 0
	jmp	SHORT $LN14@Enumerate
$LN13@Enumerate:
	mov	ecx, DWORD PTR _iadapter$128784[ebp]
	add	ecx, 1
	mov	DWORD PTR _iadapter$128784[ebp], ecx
$LN14@Enumerate:
	mov	edx, DWORD PTR _iadapter$128784[ebp]
	cmp	edx, DWORD PTR _nadapter$[ebp]
	jae	$LN12@Enumerate

; 207  : 		{
; 208  : 			D3DADAPTER_T *padapter = new D3DADAPTER_T;

	push	1152					; 00000480H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T141468[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T141468[ebp], 0
	je	SHORT $LN17@Enumerate
	mov	ecx, DWORD PTR $T141468[ebp]
	call	??0D3DADAPTER_T@Ogre@@QAE@XZ
	mov	DWORD PTR tv83[ebp], eax
	jmp	SHORT $LN18@Enumerate
$LN17@Enumerate:
	mov	DWORD PTR tv83[ebp], 0
$LN18@Enumerate:
	mov	eax, DWORD PTR tv83[ebp]
	mov	DWORD PTR $T141467[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR $T141467[ebp]
	mov	DWORD PTR _padapter$128788[ebp], ecx

; 209  : 			std::vector<D3DFORMAT> allformats;

	lea	ecx, DWORD PTR _allformats$128797[ebp]
	call	??0?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@QAE@XZ ; std::vector<enum _D3DFORMAT,std::allocator<enum _D3DFORMAT> >::vector<enum _D3DFORMAT,std::allocator<enum _D3DFORMAT> >
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 210  : 
; 211  : 			padapter->iadapter = iadapter;

	mov	edx, DWORD PTR _padapter$128788[ebp]
	mov	eax, DWORD PTR _iadapter$128784[ebp]
	mov	DWORD PTR [edx], eax

; 212  : 			m_pD3D->GetAdapterIdentifier( iadapter, 0, &padapter->id );

	mov	ecx, DWORD PTR _padapter$128788[ebp]
	add	ecx, 4
	push	ecx
	push	0
	mov	edx, DWORD PTR _iadapter$128784[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+92]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+92]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	mov	edx, DWORD PTR [ecx+20]
	call	edx

; 213  : 
; 214  : 			for( UINT32 iallow=0; iallow<m_AllowedFmt.size(); iallow++ )

	mov	DWORD PTR _iallow$128798[ebp], 0
	jmp	SHORT $LN11@Enumerate
$LN10@Enumerate:
	mov	eax, DWORD PTR _iallow$128798[ebp]
	add	eax, 1
	mov	DWORD PTR _iallow$128798[ebp], eax
$LN11@Enumerate:
	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@QBEIXZ ; std::vector<enum _D3DFORMAT,std::allocator<enum _D3DFORMAT> >::size
	cmp	DWORD PTR _iallow$128798[ebp], eax
	jae	$LN9@Enumerate

; 215  : 			{
; 216  : 				UINT32 nadaptermode = m_pD3D->GetAdapterModeCount( iadapter, m_AllowedFmt[iallow] );

	mov	ecx, DWORD PTR _iallow$128798[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@QAEAAW4_D3DFORMAT@@I@Z ; std::vector<enum _D3DFORMAT,std::allocator<enum _D3DFORMAT> >::operator[]
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	eax, DWORD PTR _iadapter$128784[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+92]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+92]
	mov	edx, DWORD PTR [edx]
	push	ecx
	mov	eax, DWORD PTR [edx+24]
	call	eax
	mov	DWORD PTR _nadaptermode$128802[ebp], eax

; 217  : 				for( UINT32 imode=0; imode<nadaptermode; imode++ )

	mov	DWORD PTR _imode$128803[ebp], 0
	jmp	SHORT $LN8@Enumerate
$LN7@Enumerate:
	mov	ecx, DWORD PTR _imode$128803[ebp]
	add	ecx, 1
	mov	DWORD PTR _imode$128803[ebp], ecx
$LN8@Enumerate:
	mov	edx, DWORD PTR _imode$128803[ebp]
	cmp	edx, DWORD PTR _nadaptermode$128802[ebp]
	jae	$LN6@Enumerate

; 218  : 				{
; 219  : 					D3DDISPLAYMODE tmpmode;
; 220  : 					m_pD3D->EnumAdapterModes( iadapter, m_AllowedFmt[iallow], imode, &tmpmode );

	lea	eax, DWORD PTR _tmpmode$128807[ebp]
	push	eax
	mov	ecx, DWORD PTR _imode$128803[ebp]
	push	ecx
	mov	edx, DWORD PTR _iallow$128798[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@QAEAAW4_D3DFORMAT@@I@Z ; std::vector<enum _D3DFORMAT,std::allocator<enum _D3DFORMAT> >::operator[]
	mov	eax, DWORD PTR [eax]
	push	eax
	mov	ecx, DWORD PTR _iadapter$128784[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+92]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+92]
	mov	eax, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR [eax+28]
	call	ecx

; 221  : 
; 222  : 					if( tmpmode.Width<m_MinFullScreenWidth || tmpmode.Height<m_MinFullScreenHeight 
; 223  : 						|| ColorChannelBits(tmpmode.Format)<m_MinColorChannelBits ) continue;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _tmpmode$128807[ebp]
	cmp	eax, DWORD PTR [edx+52]
	jb	SHORT $LN4@Enumerate
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _tmpmode$128807[ebp+4]
	cmp	edx, DWORD PTR [ecx+56]
	jb	SHORT $LN4@Enumerate
	mov	eax, DWORD PTR _tmpmode$128807[ebp+12]
	push	eax
	call	?ColorChannelBits@Ogre@@YAIW4_D3DFORMAT@@@Z ; Ogre::ColorChannelBits
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR [ecx+60]
	jae	SHORT $LN5@Enumerate
$LN4@Enumerate:
	jmp	SHORT $LN7@Enumerate
$LN5@Enumerate:

; 224  : 
; 225  : 					padapter->modes.push_back( tmpmode );

	lea	edx, DWORD PTR _tmpmode$128807[ebp]
	push	edx
	mov	ecx, DWORD PTR _padapter$128788[ebp]
	add	ecx, 1104				; 00000450H
	call	?push_back@?$vector@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@QAEXABU_D3DDISPLAYMODE@@@Z ; std::vector<_D3DDISPLAYMODE,std::allocator<_D3DDISPLAYMODE> >::push_back

; 226  : 					if( !IsVectorContain(allformats, tmpmode.Format) ) allformats.push_back( tmpmode.Format );

	lea	eax, DWORD PTR _tmpmode$128807[ebp+12]
	push	eax
	lea	ecx, DWORD PTR _allformats$128797[ebp]
	push	ecx
	call	??$IsVectorContain@W4_D3DFORMAT@@@Ogre@@YAHAAV?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@ABW4_D3DFORMAT@@@Z ; Ogre::IsVectorContain<enum _D3DFORMAT>
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN3@Enumerate
	lea	edx, DWORD PTR _tmpmode$128807[ebp+12]
	push	edx
	lea	ecx, DWORD PTR _allformats$128797[ebp]
	call	?push_back@?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@QAEXABW4_D3DFORMAT@@@Z ; std::vector<enum _D3DFORMAT,std::allocator<enum _D3DFORMAT> >::push_back
$LN3@Enumerate:

; 227  : 				}

	jmp	$LN7@Enumerate
$LN6@Enumerate:

; 228  : 			}

	jmp	$LN10@Enumerate
$LN9@Enumerate:

; 229  : 
; 230  : 			//for all the modes, find devices
; 231  : 			qsort( &padapter->modes[0], padapter->modes.size(), sizeof(D3DDISPLAYMODE), SortModeCallback );

	push	OFFSET ?SortModeCallback@Ogre@@YAHPBX0@Z ; Ogre::SortModeCallback
	push	16					; 00000010H
	mov	ecx, DWORD PTR _padapter$128788[ebp]
	add	ecx, 1104				; 00000450H
	call	?size@?$vector@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@QBEIXZ ; std::vector<_D3DDISPLAYMODE,std::allocator<_D3DDISPLAYMODE> >::size
	push	eax
	push	0
	mov	ecx, DWORD PTR _padapter$128788[ebp]
	add	ecx, 1104				; 00000450H
	call	??A?$vector@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@QAEAAU_D3DDISPLAYMODE@@I@Z ; std::vector<_D3DDISPLAYMODE,std::allocator<_D3DDISPLAYMODE> >::operator[]
	push	eax
	call	DWORD PTR __imp__qsort
	add	esp, 16					; 00000010H

; 232  : 
; 233  : 			EnumerateDevices( padapter, allformats );

	lea	eax, DWORD PTR _allformats$128797[ebp]
	push	eax
	mov	ecx, DWORD PTR _padapter$128788[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?EnumerateDevices@D3DEnumeration@Ogre@@AAEXPAUD3DADAPTER_T@2@AAV?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@@Z ; Ogre::D3DEnumeration::EnumerateDevices

; 234  : 
; 235  : 			if( padapter->devinfo.size() == 0 ) delete(padapter);

	mov	ecx, DWORD PTR _padapter$128788[ebp]
	add	ecx, 1128				; 00000468H
	call	?size@?$vector@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::D3DDEVICEINFO_T *,std::allocator<Ogre::D3DDEVICEINFO_T *> >::size
	test	eax, eax
	jne	SHORT $LN2@Enumerate
	mov	edx, DWORD PTR _padapter$128788[ebp]
	mov	DWORD PTR $T141472[ebp], edx
	mov	eax, DWORD PTR $T141472[ebp]
	mov	DWORD PTR $T141471[ebp], eax
	cmp	DWORD PTR $T141471[ebp], 0
	je	SHORT $LN19@Enumerate
	push	1
	mov	ecx, DWORD PTR $T141471[ebp]
	call	??_GD3DADAPTER_T@Ogre@@QAEPAXI@Z
	mov	DWORD PTR tv201[ebp], eax
	jmp	SHORT $LN20@Enumerate
$LN19@Enumerate:
	mov	DWORD PTR tv201[ebp], 0
$LN20@Enumerate:

; 236  : 			else m_Adapters.push_back( padapter );

	jmp	SHORT $LN1@Enumerate
$LN2@Enumerate:
	lea	ecx, DWORD PTR _padapter$128788[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	?push_back@?$vector@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@QAEXABQAUD3DADAPTER_T@Ogre@@@Z ; std::vector<Ogre::D3DADAPTER_T *,std::allocator<Ogre::D3DADAPTER_T *> >::push_back
$LN1@Enumerate:

; 237  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _allformats$128797[ebp]
	call	??1?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@QAE@XZ ; std::vector<enum _D3DFORMAT,std::allocator<enum _D3DFORMAT> >::~vector<enum _D3DFORMAT,std::allocator<enum _D3DFORMAT> >
	jmp	$LN13@Enumerate
$LN12@Enumerate:

; 238  : 
; 239  : 		return TRUE;

	mov	eax, 1

; 240  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?Enumerate@D3DEnumeration@Ogre@@QAEHPAUIDirect3D9@@P6AHPAU_D3DCAPS9@@W4VERTPROCESS_T@2@W4_D3DFORMAT@@3@Z@Z$0:
	mov	eax, DWORD PTR $T141468[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?Enumerate@D3DEnumeration@Ogre@@QAEHPAUIDirect3D9@@P6AHPAU_D3DCAPS9@@W4VERTPROCESS_T@2@W4_D3DFORMAT@@3@Z@Z$1:
	lea	ecx, DWORD PTR _allformats$128797[ebp]
	jmp	??1?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@QAE@XZ ; std::vector<enum _D3DFORMAT,std::allocator<enum _D3DFORMAT> >::~vector<enum _D3DFORMAT,std::allocator<enum _D3DFORMAT> >
__ehhandler$?Enumerate@D3DEnumeration@Ogre@@QAEHPAUIDirect3D9@@P6AHPAU_D3DCAPS9@@W4VERTPROCESS_T@2@W4_D3DFORMAT@@3@Z@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-96]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?Enumerate@D3DEnumeration@Ogre@@QAEHPAUIDirect3D9@@P6AHPAU_D3DCAPS9@@W4VERTPROCESS_T@2@W4_D3DFORMAT@@3@Z@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?Enumerate@D3DEnumeration@Ogre@@QAEHPAUIDirect3D9@@P6AHPAU_D3DCAPS9@@W4VERTPROCESS_T@2@W4_D3DFORMAT@@3@Z@Z ENDP ; Ogre::D3DEnumeration::Enumerate
; Function compile flags: /Odtp
_TEXT	SEGMENT
tv64 = -4						; size = 4
_fmt$ = 8						; size = 4
?ColorChannelBits@Ogre@@YAIW4_D3DFORMAT@@@Z PROC	; Ogre::ColorChannelBits

; 11   : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 12   : 		switch( fmt )

	mov	eax, DWORD PTR _fmt$[ebp]
	mov	DWORD PTR tv64[ebp], eax
	mov	ecx, DWORD PTR tv64[ebp]
	sub	ecx, 20					; 00000014H
	mov	DWORD PTR tv64[ebp], ecx
	cmp	DWORD PTR tv64[ebp], 15			; 0000000fH
	ja	SHORT $LN1@ColorChann
	mov	edx, DWORD PTR tv64[ebp]
	jmp	DWORD PTR $LN18@ColorChann[edx*4]
$LN13@ColorChann:

; 13   : 		{
; 14   : 		case D3DFMT_R8G8B8:
; 15   : 			return 8;

	mov	eax, 8
	jmp	SHORT $LN16@ColorChann
$LN12@ColorChann:

; 16   : 		case D3DFMT_A8R8G8B8:
; 17   : 			return 8;

	mov	eax, 8
	jmp	SHORT $LN16@ColorChann
$LN11@ColorChann:

; 18   : 		case D3DFMT_X8R8G8B8:
; 19   : 			return 8;

	mov	eax, 8
	jmp	SHORT $LN16@ColorChann
$LN10@ColorChann:

; 20   : 		case D3DFMT_R5G6B5:
; 21   : 			return 5;

	mov	eax, 5
	jmp	SHORT $LN16@ColorChann
$LN9@ColorChann:

; 22   : 		case D3DFMT_X1R5G5B5:
; 23   : 			return 5;

	mov	eax, 5
	jmp	SHORT $LN16@ColorChann
$LN8@ColorChann:

; 24   : 		case D3DFMT_A1R5G5B5:
; 25   : 			return 5;

	mov	eax, 5
	jmp	SHORT $LN16@ColorChann
$LN7@ColorChann:

; 26   : 		case D3DFMT_A4R4G4B4:
; 27   : 			return 4;

	mov	eax, 4
	jmp	SHORT $LN16@ColorChann
$LN6@ColorChann:

; 28   : 		case D3DFMT_R3G3B2:
; 29   : 			return 2;

	mov	eax, 2
	jmp	SHORT $LN16@ColorChann
$LN5@ColorChann:

; 30   : 		case D3DFMT_A8R3G3B2:
; 31   : 			return 2;

	mov	eax, 2
	jmp	SHORT $LN16@ColorChann
$LN4@ColorChann:

; 32   : 		case D3DFMT_X4R4G4B4:
; 33   : 			return 4;

	mov	eax, 4
	jmp	SHORT $LN16@ColorChann
$LN3@ColorChann:

; 34   : 		case D3DFMT_A2B10G10R10:
; 35   : 			return 10;

	mov	eax, 10					; 0000000aH
	jmp	SHORT $LN16@ColorChann
$LN2@ColorChann:

; 36   : 		case D3DFMT_A2R10G10B10:
; 37   : 			return 10;

	mov	eax, 10					; 0000000aH
	jmp	SHORT $LN16@ColorChann
$LN1@ColorChann:

; 38   : 		default:
; 39   : 			return 0;

	xor	eax, eax
$LN16@ColorChann:

; 40   : 		}
; 41   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN18@ColorChann:
	DD	$LN13@ColorChann
	DD	$LN12@ColorChann
	DD	$LN11@ColorChann
	DD	$LN10@ColorChann
	DD	$LN9@ColorChann
	DD	$LN8@ColorChann
	DD	$LN7@ColorChann
	DD	$LN6@ColorChann
	DD	$LN1@ColorChann
	DD	$LN5@ColorChann
	DD	$LN4@ColorChann
	DD	$LN3@ColorChann
	DD	$LN1@ColorChann
	DD	$LN1@ColorChann
	DD	$LN1@ColorChann
	DD	$LN2@ColorChann
?ColorChannelBits@Ogre@@YAIW4_D3DFORMAT@@@Z ENDP	; Ogre::ColorChannelBits
; Function compile flags: /Odtp
_pmode2$ = -8						; size = 4
_pmode1$ = -4						; size = 4
_p1$ = 8						; size = 4
_p2$ = 12						; size = 4
?SortModeCallback@Ogre@@YAHPBX0@Z PROC			; Ogre::SortModeCallback

; 181  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 182  : 		D3DDISPLAYMODE *pmode1 = (D3DDISPLAYMODE *)p1;

	mov	eax, DWORD PTR _p1$[ebp]
	mov	DWORD PTR _pmode1$[ebp], eax

; 183  : 		D3DDISPLAYMODE *pmode2 = (D3DDISPLAYMODE *)p2;

	mov	ecx, DWORD PTR _p2$[ebp]
	mov	DWORD PTR _pmode2$[ebp], ecx

; 184  : 
; 185  : 		if( pmode1->Width > pmode2->Width ) return 1;

	mov	edx, DWORD PTR _pmode1$[ebp]
	mov	eax, DWORD PTR _pmode2$[ebp]
	mov	ecx, DWORD PTR [edx]
	cmp	ecx, DWORD PTR [eax]
	jbe	SHORT $LN12@SortModeCa
	mov	eax, 1
	jmp	$LN13@SortModeCa
	jmp	SHORT $LN11@SortModeCa
$LN12@SortModeCa:

; 186  : 		else if( pmode1->Width < pmode2->Width ) return -1;

	mov	edx, DWORD PTR _pmode1$[ebp]
	mov	eax, DWORD PTR _pmode2$[ebp]
	mov	ecx, DWORD PTR [edx]
	cmp	ecx, DWORD PTR [eax]
	jae	SHORT $LN11@SortModeCa
	or	eax, -1
	jmp	$LN13@SortModeCa
$LN11@SortModeCa:

; 187  : 
; 188  : 		if( pmode1->Height > pmode2->Height ) return 1;

	mov	edx, DWORD PTR _pmode1$[ebp]
	mov	eax, DWORD PTR _pmode2$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	cmp	ecx, DWORD PTR [eax+4]
	jbe	SHORT $LN9@SortModeCa
	mov	eax, 1
	jmp	SHORT $LN13@SortModeCa
	jmp	SHORT $LN8@SortModeCa
$LN9@SortModeCa:

; 189  : 		else if( pmode1->Height < pmode2->Height ) return -1;

	mov	edx, DWORD PTR _pmode1$[ebp]
	mov	eax, DWORD PTR _pmode2$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	cmp	ecx, DWORD PTR [eax+4]
	jae	SHORT $LN8@SortModeCa
	or	eax, -1
	jmp	SHORT $LN13@SortModeCa
$LN8@SortModeCa:

; 190  : 
; 191  : 		if( pmode1->Format > pmode2->Format ) return 1;

	mov	edx, DWORD PTR _pmode1$[ebp]
	mov	eax, DWORD PTR _pmode2$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	cmp	ecx, DWORD PTR [eax+12]
	jle	SHORT $LN6@SortModeCa
	mov	eax, 1
	jmp	SHORT $LN13@SortModeCa
	jmp	SHORT $LN5@SortModeCa
$LN6@SortModeCa:

; 192  : 		else if( pmode1->Format < pmode2->Format ) return -1;

	mov	edx, DWORD PTR _pmode1$[ebp]
	mov	eax, DWORD PTR _pmode2$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	cmp	ecx, DWORD PTR [eax+12]
	jge	SHORT $LN5@SortModeCa
	or	eax, -1
	jmp	SHORT $LN13@SortModeCa
$LN5@SortModeCa:

; 193  : 
; 194  : 		if( pmode1->RefreshRate > pmode2->RefreshRate ) return 1;

	mov	edx, DWORD PTR _pmode1$[ebp]
	mov	eax, DWORD PTR _pmode2$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	cmp	ecx, DWORD PTR [eax+8]
	jbe	SHORT $LN3@SortModeCa
	mov	eax, 1
	jmp	SHORT $LN13@SortModeCa
	jmp	SHORT $LN2@SortModeCa
$LN3@SortModeCa:

; 195  : 		else if( pmode1->RefreshRate < pmode2->RefreshRate ) return -1;

	mov	edx, DWORD PTR _pmode1$[ebp]
	mov	eax, DWORD PTR _pmode2$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	cmp	ecx, DWORD PTR [eax+8]
	jae	SHORT $LN2@SortModeCa
	or	eax, -1
	jmp	SHORT $LN13@SortModeCa
$LN2@SortModeCa:

; 196  : 
; 197  : 		return 0;

	xor	eax, eax
$LN13@SortModeCa:

; 198  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?SortModeCallback@Ogre@@YAHPBX0@Z ENDP			; Ogre::SortModeCallback
_TEXT	ENDS
PUBLIC	??0?$vector@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::D3DDEVICEINFO_T *,std::allocator<Ogre::D3DDEVICEINFO_T *> >::vector<Ogre::D3DDEVICEINFO_T *,std::allocator<Ogre::D3DDEVICEINFO_T *> >
PUBLIC	??0?$vector@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@QAE@XZ ; std::vector<_D3DDISPLAYMODE,std::allocator<_D3DDISPLAYMODE> >::vector<_D3DDISPLAYMODE,std::allocator<_D3DDISPLAYMODE> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0D3DADAPTER_T@Ogre@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0D3DADAPTER_T@Ogre@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0D3DADAPTER_T@Ogre@@QAE@XZ$1
__ehfuncinfo$??0D3DADAPTER_T@Ogre@@QAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0D3DADAPTER_T@Ogre@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0D3DADAPTER_T@Ogre@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0D3DADAPTER_T@Ogre@@QAE@XZ PROC			; Ogre::D3DADAPTER_T::D3DADAPTER_T, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0D3DADAPTER_T@Ogre@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1104				; 00000450H
	call	??0?$vector@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@QAE@XZ ; std::vector<_D3DDISPLAYMODE,std::allocator<_D3DDISPLAYMODE> >::vector<_D3DDISPLAYMODE,std::allocator<_D3DDISPLAYMODE> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1128				; 00000468H
	call	??0?$vector@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::D3DDEVICEINFO_T *,std::allocator<Ogre::D3DDEVICEINFO_T *> >::vector<Ogre::D3DDEVICEINFO_T *,std::allocator<Ogre::D3DDEVICEINFO_T *> >
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0D3DADAPTER_T@Ogre@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1104				; 00000450H
	jmp	??1?$vector@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@QAE@XZ ; std::vector<_D3DDISPLAYMODE,std::allocator<_D3DDISPLAYMODE> >::~vector<_D3DDISPLAYMODE,std::allocator<_D3DDISPLAYMODE> >
__unwindfunclet$??0D3DADAPTER_T@Ogre@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1128				; 00000468H
	jmp	??1?$vector@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::D3DDEVICEINFO_T *,std::allocator<Ogre::D3DDEVICEINFO_T *> >::~vector<Ogre::D3DDEVICEINFO_T *,std::allocator<Ogre::D3DDEVICEINFO_T *> >
__ehhandler$??0D3DADAPTER_T@Ogre@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0D3DADAPTER_T@Ogre@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0D3DADAPTER_T@Ogre@@QAE@XZ ENDP			; Ogre::D3DADAPTER_T::D3DADAPTER_T
PUBLIC	?push_back@?$vector@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@QAEXABQAUD3DDEVICEINFO_T@Ogre@@@Z ; std::vector<Ogre::D3DDEVICEINFO_T *,std::allocator<Ogre::D3DDEVICEINFO_T *> >::push_back
PUBLIC	?empty@?$vector@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@QBE_NXZ ; std::vector<Ogre::D3DDEVCOMBO_T *,std::allocator<Ogre::D3DDEVCOMBO_T *> >::empty
PUBLIC	?EnumerateDeviceCombo@D3DEnumeration@Ogre@@AAEXPAUD3DDEVICEINFO_T@2@AAV?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@@Z ; Ogre::D3DEnumeration::EnumerateDeviceCombo
PUBLIC	??0D3DDEVICEINFO_T@Ogre@@QAE@XZ			; Ogre::D3DDEVICEINFO_T::D3DDEVICEINFO_T
xdata$x	SEGMENT
__unwindtable$?EnumerateDevices@D3DEnumeration@Ogre@@AAEXPAUD3DADAPTER_T@2@AAV?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?EnumerateDevices@D3DEnumeration@Ogre@@AAEXPAUD3DADAPTER_T@2@AAV?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@@Z$0
__ehfuncinfo$?EnumerateDevices@D3DEnumeration@Ogre@@AAEXPAUD3DADAPTER_T@2@AAV?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?EnumerateDevices@D3DEnumeration@Ogre@@AAEXPAUD3DADAPTER_T@2@AAV?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
_TEXT	SEGMENT
tv139 = -68						; size = 4
tv94 = -64						; size = 4
tv73 = -60						; size = 4
_this$ = -56						; size = 4
$T141504 = -52						; size = 4
$T141503 = -48						; size = 4
$T141500 = -44						; size = 4
$T141499 = -40						; size = 4
$T141496 = -36						; size = 4
$T141495 = -32						; size = 4
_pdevinfo$128841 = -28					; size = 4
_idt$128837 = -24					; size = 4
_devtypes$ = -20					; size = 8
__$EHRec$ = -12						; size = 12
_padapter$ = 8						; size = 4
_formatarray$ = 12					; size = 4
?EnumerateDevices@D3DEnumeration@Ogre@@AAEXPAUD3DADAPTER_T@2@AAV?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@@Z PROC ; Ogre::D3DEnumeration::EnumerateDevices
; _this$ = ecx

; 243  : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?EnumerateDevices@D3DEnumeration@Ogre@@AAEXPAUD3DADAPTER_T@2@AAV?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 56					; 00000038H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 244  : 		const D3DDEVTYPE devtypes[] = { D3DDEVTYPE_HAL, D3DDEVTYPE_REF };

	mov	DWORD PTR _devtypes$[ebp], 1
	mov	DWORD PTR _devtypes$[ebp+4], 2

; 245  : 
; 246  : 		for( UINT32 idt=0; idt<ARRAY_ELEMENTS(devtypes); idt++ )

	mov	DWORD PTR _idt$128837[ebp], 0
	jmp	SHORT $LN6@EnumerateD
$LN5@EnumerateD:
	mov	eax, DWORD PTR _idt$128837[ebp]
	add	eax, 1
	mov	DWORD PTR _idt$128837[ebp], eax
$LN6@EnumerateD:
	cmp	DWORD PTR _idt$128837[ebp], 2
	jae	$LN7@EnumerateD

; 247  : 		{
; 248  : 			D3DDEVICEINFO_T *pdevinfo = new D3DDEVICEINFO_T;

	push	336					; 00000150H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T141496[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T141496[ebp], 0
	je	SHORT $LN9@EnumerateD
	mov	ecx, DWORD PTR $T141496[ebp]
	call	??0D3DDEVICEINFO_T@Ogre@@QAE@XZ
	mov	DWORD PTR tv73[ebp], eax
	jmp	SHORT $LN10@EnumerateD
$LN9@EnumerateD:
	mov	DWORD PTR tv73[ebp], 0
$LN10@EnumerateD:
	mov	ecx, DWORD PTR tv73[ebp]
	mov	DWORD PTR $T141495[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	edx, DWORD PTR $T141495[ebp]
	mov	DWORD PTR _pdevinfo$128841[ebp], edx

; 249  : 
; 250  : 			pdevinfo->iadapter = padapter->iadapter;

	mov	eax, DWORD PTR _pdevinfo$128841[ebp]
	mov	ecx, DWORD PTR _padapter$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 251  : 			pdevinfo->type = devtypes[idt];

	mov	eax, DWORD PTR _pdevinfo$128841[ebp]
	mov	ecx, DWORD PTR _idt$128837[ebp]
	mov	edx, DWORD PTR _devtypes$[ebp+ecx*4]
	mov	DWORD PTR [eax+4], edx

; 252  : 
; 253  : 			if( FAILED( m_pD3D->GetDeviceCaps(pdevinfo->iadapter, pdevinfo->type, &pdevinfo->caps) ) )

	mov	eax, DWORD PTR _pdevinfo$128841[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR _pdevinfo$128841[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR _pdevinfo$128841[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+92]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+92]
	mov	eax, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR [eax+56]
	call	ecx
	test	eax, eax
	jge	SHORT $LN3@EnumerateD

; 254  : 			{
; 255  : 				delete(pdevinfo);

	mov	edx, DWORD PTR _pdevinfo$128841[ebp]
	mov	DWORD PTR $T141500[ebp], edx
	mov	eax, DWORD PTR $T141500[ebp]
	mov	DWORD PTR $T141499[ebp], eax
	cmp	DWORD PTR $T141499[ebp], 0
	je	SHORT $LN11@EnumerateD
	push	1
	mov	ecx, DWORD PTR $T141499[ebp]
	call	??_GD3DDEVICEINFO_T@Ogre@@QAEPAXI@Z
	mov	DWORD PTR tv94[ebp], eax
	jmp	SHORT $LN12@EnumerateD
$LN11@EnumerateD:
	mov	DWORD PTR tv94[ebp], 0
$LN12@EnumerateD:

; 256  : 				continue;

	jmp	$LN5@EnumerateD
$LN3@EnumerateD:

; 257  : 			}
; 258  : 
; 259  : 			// Get info for each devicecombo on this device
; 260  : 			EnumerateDeviceCombo( pdevinfo, formatarray );

	mov	ecx, DWORD PTR _formatarray$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pdevinfo$128841[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?EnumerateDeviceCombo@D3DEnumeration@Ogre@@AAEXPAUD3DDEVICEINFO_T@2@AAV?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@@Z ; Ogre::D3DEnumeration::EnumerateDeviceCombo

; 261  : 
; 262  : 			if( pdevinfo->devcombo.empty() ) delete(pdevinfo);

	mov	ecx, DWORD PTR _pdevinfo$128841[ebp]
	add	ecx, 312				; 00000138H
	call	?empty@?$vector@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@QBE_NXZ ; std::vector<Ogre::D3DDEVCOMBO_T *,std::allocator<Ogre::D3DDEVCOMBO_T *> >::empty
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@EnumerateD
	mov	ecx, DWORD PTR _pdevinfo$128841[ebp]
	mov	DWORD PTR $T141504[ebp], ecx
	mov	edx, DWORD PTR $T141504[ebp]
	mov	DWORD PTR $T141503[ebp], edx
	cmp	DWORD PTR $T141503[ebp], 0
	je	SHORT $LN13@EnumerateD
	push	1
	mov	ecx, DWORD PTR $T141503[ebp]
	call	??_GD3DDEVICEINFO_T@Ogre@@QAEPAXI@Z
	mov	DWORD PTR tv139[ebp], eax
	jmp	SHORT $LN14@EnumerateD
$LN13@EnumerateD:
	mov	DWORD PTR tv139[ebp], 0
$LN14@EnumerateD:

; 263  : 			else padapter->devinfo.push_back( pdevinfo );

	jmp	SHORT $LN1@EnumerateD
$LN2@EnumerateD:
	lea	eax, DWORD PTR _pdevinfo$128841[ebp]
	push	eax
	mov	ecx, DWORD PTR _padapter$[ebp]
	add	ecx, 1128				; 00000468H
	call	?push_back@?$vector@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@QAEXABQAUD3DDEVICEINFO_T@Ogre@@@Z ; std::vector<Ogre::D3DDEVICEINFO_T *,std::allocator<Ogre::D3DDEVICEINFO_T *> >::push_back
$LN1@EnumerateD:
	jmp	$LN5@EnumerateD
$LN7@EnumerateD:

; 264  : 		}
; 265  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?EnumerateDevices@D3DEnumeration@Ogre@@AAEXPAUD3DADAPTER_T@2@AAV?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@@Z$0:
	mov	eax, DWORD PTR $T141496[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?EnumerateDevices@D3DEnumeration@Ogre@@AAEXPAUD3DADAPTER_T@2@AAV?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-60]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?EnumerateDevices@D3DEnumeration@Ogre@@AAEXPAUD3DADAPTER_T@2@AAV?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?EnumerateDevices@D3DEnumeration@Ogre@@AAEXPAUD3DADAPTER_T@2@AAV?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@@Z ENDP ; Ogre::D3DEnumeration::EnumerateDevices
PUBLIC	??0?$vector@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::D3DDEVCOMBO_T *,std::allocator<Ogre::D3DDEVCOMBO_T *> >::vector<Ogre::D3DDEVCOMBO_T *,std::allocator<Ogre::D3DDEVCOMBO_T *> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0D3DDEVICEINFO_T@Ogre@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0D3DDEVICEINFO_T@Ogre@@QAE@XZ$0
__ehfuncinfo$??0D3DDEVICEINFO_T@Ogre@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0D3DDEVICEINFO_T@Ogre@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0D3DDEVICEINFO_T@Ogre@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0D3DDEVICEINFO_T@Ogre@@QAE@XZ PROC			; Ogre::D3DDEVICEINFO_T::D3DDEVICEINFO_T, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0D3DDEVICEINFO_T@Ogre@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 312				; 00000138H
	call	??0?$vector@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::D3DDEVCOMBO_T *,std::allocator<Ogre::D3DDEVCOMBO_T *> >::vector<Ogre::D3DDEVCOMBO_T *,std::allocator<Ogre::D3DDEVCOMBO_T *> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0D3DDEVICEINFO_T@Ogre@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 312				; 00000138H
	jmp	??1?$vector@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::D3DDEVCOMBO_T *,std::allocator<Ogre::D3DDEVCOMBO_T *> >::~vector<Ogre::D3DDEVCOMBO_T *,std::allocator<Ogre::D3DDEVCOMBO_T *> >
__ehhandler$??0D3DDEVICEINFO_T@Ogre@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0D3DDEVICEINFO_T@Ogre@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0D3DDEVICEINFO_T@Ogre@@QAE@XZ ENDP			; Ogre::D3DDEVICEINFO_T::D3DDEVICEINFO_T
PUBLIC	?push_back@?$vector@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@QAEXABQAUD3DDEVCOMBO_T@Ogre@@@Z ; std::vector<Ogre::D3DDEVCOMBO_T *,std::allocator<Ogre::D3DDEVCOMBO_T *> >::push_back
PUBLIC	?ComputeDeviceCombo@D3DEnumeration@Ogre@@AAEPAUD3DDEVCOMBO_T@2@PAUD3DDEVICEINFO_T@2@W4_D3DFORMAT@@1H@Z ; Ogre::D3DEnumeration::ComputeDeviceCombo
; Function compile flags: /Odtp
_TEXT	SEGMENT
_this$ = -60						; size = 4
_pcombo$128882 = -56					; size = 4
_iwin$128878 = -52					; size = 4
_bkfmt$128876 = -48					; size = 4
_ibk$128872 = -44					; size = 4
_dispformat$128871 = -40				; size = 4
_idisp$128867 = -36					; size = 4
_bkbuffmt$ = -32					; size = 24
_iswindow$ = -8						; size = 8
_pdevice$ = 8						; size = 4
_formatarray$ = 12					; size = 4
?EnumerateDeviceCombo@D3DEnumeration@Ogre@@AAEXPAUD3DDEVICEINFO_T@2@AAV?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@@Z PROC ; Ogre::D3DEnumeration::EnumerateDeviceCombo
; _this$ = ecx

; 268  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 60					; 0000003cH
	mov	DWORD PTR _this$[ebp], ecx

; 269  : 		const D3DFORMAT bkbuffmt[] = { D3DFMT_A8R8G8B8, D3DFMT_X8R8G8B8, D3DFMT_A2R10G10B10, 

	mov	DWORD PTR _bkbuffmt$[ebp], 21		; 00000015H
	mov	DWORD PTR _bkbuffmt$[ebp+4], 22		; 00000016H
	mov	DWORD PTR _bkbuffmt$[ebp+8], 35		; 00000023H

; 270  : 			D3DFMT_R5G6B5, D3DFMT_A1R5G5B5, D3DFMT_X1R5G5B5 };

	mov	DWORD PTR _bkbuffmt$[ebp+12], 23	; 00000017H
	mov	DWORD PTR _bkbuffmt$[ebp+16], 25	; 00000019H
	mov	DWORD PTR _bkbuffmt$[ebp+20], 24	; 00000018H

; 271  : 		BOOL  iswindow[] = { FALSE, TRUE };

	mov	DWORD PTR _iswindow$[ebp], 0
	mov	DWORD PTR _iswindow$[ebp+4], 1

; 272  : 
; 273  : 		for( UINT32 idisp=0; idisp<formatarray.size(); idisp++)

	mov	DWORD PTR _idisp$128867[ebp], 0
	jmp	SHORT $LN11@EnumerateD@2
$LN10@EnumerateD@2:
	mov	eax, DWORD PTR _idisp$128867[ebp]
	add	eax, 1
	mov	DWORD PTR _idisp$128867[ebp], eax
$LN11@EnumerateD@2:
	mov	ecx, DWORD PTR _formatarray$[ebp]
	call	?size@?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@QBEIXZ ; std::vector<enum _D3DFORMAT,std::allocator<enum _D3DFORMAT> >::size
	cmp	DWORD PTR _idisp$128867[ebp], eax
	jae	$LN12@EnumerateD@2

; 274  : 		{
; 275  : 			D3DFORMAT dispformat = formatarray[idisp];

	mov	ecx, DWORD PTR _idisp$128867[ebp]
	push	ecx
	mov	ecx, DWORD PTR _formatarray$[ebp]
	call	??A?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@QAEAAW4_D3DFORMAT@@I@Z ; std::vector<enum _D3DFORMAT,std::allocator<enum _D3DFORMAT> >::operator[]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR _dispformat$128871[ebp], edx

; 276  : 
; 277  : 			for( UINT32 ibk=0; ibk<ARRAY_ELEMENTS(bkbuffmt); ibk++ )

	mov	DWORD PTR _ibk$128872[ebp], 0
	jmp	SHORT $LN8@EnumerateD@2
$LN7@EnumerateD@2:
	mov	eax, DWORD PTR _ibk$128872[ebp]
	add	eax, 1
	mov	DWORD PTR _ibk$128872[ebp], eax
$LN8@EnumerateD@2:
	cmp	DWORD PTR _ibk$128872[ebp], 6
	jae	SHORT $LN6@EnumerateD@2

; 278  : 			{
; 279  : 				D3DFORMAT bkfmt = bkbuffmt[ibk];

	mov	ecx, DWORD PTR _ibk$128872[ebp]
	mov	edx, DWORD PTR _bkbuffmt$[ebp+ecx*4]
	mov	DWORD PTR _bkfmt$128876[ebp], edx

; 280  : 				if( AlphaChannelBits(bkfmt) < m_MinAlphaChannelBits ) continue;

	mov	eax, DWORD PTR _bkfmt$128876[ebp]
	push	eax
	call	?AlphaChannelBits@Ogre@@YAIW4_D3DFORMAT@@@Z ; Ogre::AlphaChannelBits
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR [ecx+64]
	jae	SHORT $LN5@EnumerateD@2
	jmp	SHORT $LN7@EnumerateD@2
$LN5@EnumerateD@2:

; 281  : 
; 282  : 				for( UINT32 iwin=0; iwin<ARRAY_ELEMENTS(iswindow); iwin++ )

	mov	DWORD PTR _iwin$128878[ebp], 0
	jmp	SHORT $LN4@EnumerateD@2
$LN3@EnumerateD@2:
	mov	edx, DWORD PTR _iwin$128878[ebp]
	add	edx, 1
	mov	DWORD PTR _iwin$128878[ebp], edx
$LN4@EnumerateD@2:
	cmp	DWORD PTR _iwin$128878[ebp], 2
	jae	SHORT $LN2@EnumerateD@2

; 283  : 				{
; 284  : 					D3DDEVCOMBO_T *pcombo = ComputeDeviceCombo( pdevice, dispformat, bkfmt, iswindow[iwin] );

	mov	eax, DWORD PTR _iwin$128878[ebp]
	mov	ecx, DWORD PTR _iswindow$[ebp+eax*4]
	push	ecx
	mov	edx, DWORD PTR _bkfmt$128876[ebp]
	push	edx
	mov	eax, DWORD PTR _dispformat$128871[ebp]
	push	eax
	mov	ecx, DWORD PTR _pdevice$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ComputeDeviceCombo@D3DEnumeration@Ogre@@AAEPAUD3DDEVCOMBO_T@2@PAUD3DDEVICEINFO_T@2@W4_D3DFORMAT@@1H@Z ; Ogre::D3DEnumeration::ComputeDeviceCombo
	mov	DWORD PTR _pcombo$128882[ebp], eax

; 285  : 					if( pcombo ) pdevice->devcombo.push_back( pcombo );

	cmp	DWORD PTR _pcombo$128882[ebp], 0
	je	SHORT $LN1@EnumerateD@2
	lea	edx, DWORD PTR _pcombo$128882[ebp]
	push	edx
	mov	ecx, DWORD PTR _pdevice$[ebp]
	add	ecx, 312				; 00000138H
	call	?push_back@?$vector@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@QAEXABQAUD3DDEVCOMBO_T@Ogre@@@Z ; std::vector<Ogre::D3DDEVCOMBO_T *,std::allocator<Ogre::D3DDEVCOMBO_T *> >::push_back
$LN1@EnumerateD@2:

; 286  : 				}

	jmp	SHORT $LN3@EnumerateD@2
$LN2@EnumerateD@2:

; 287  : 			}

	jmp	$LN7@EnumerateD@2
$LN6@EnumerateD@2:

; 288  : 		}

	jmp	$LN10@EnumerateD@2
$LN12@EnumerateD@2:

; 289  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?EnumerateDeviceCombo@D3DEnumeration@Ogre@@AAEXPAUD3DDEVICEINFO_T@2@AAV?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@@Z ENDP ; Ogre::D3DEnumeration::EnumerateDeviceCombo
; Function compile flags: /Odtp
tv64 = -4						; size = 4
_fmt$ = 8						; size = 4
?AlphaChannelBits@Ogre@@YAIW4_D3DFORMAT@@@Z PROC	; Ogre::AlphaChannelBits

; 44   : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 45   : 		switch( fmt )

	mov	eax, DWORD PTR _fmt$[ebp]
	mov	DWORD PTR tv64[ebp], eax
	mov	ecx, DWORD PTR tv64[ebp]
	sub	ecx, 20					; 00000014H
	mov	DWORD PTR tv64[ebp], ecx
	cmp	DWORD PTR tv64[ebp], 15			; 0000000fH
	ja	SHORT $LN1@AlphaChann
	mov	edx, DWORD PTR tv64[ebp]
	jmp	DWORD PTR $LN18@AlphaChann[edx*4]
$LN13@AlphaChann:

; 46   : 		{
; 47   : 		case D3DFMT_R8G8B8:
; 48   : 			return 0;

	xor	eax, eax
	jmp	SHORT $LN16@AlphaChann
$LN12@AlphaChann:

; 49   : 		case D3DFMT_A8R8G8B8:
; 50   : 			return 8;

	mov	eax, 8
	jmp	SHORT $LN16@AlphaChann
$LN11@AlphaChann:

; 51   : 		case D3DFMT_X8R8G8B8:
; 52   : 			return 0;

	xor	eax, eax
	jmp	SHORT $LN16@AlphaChann
$LN10@AlphaChann:

; 53   : 		case D3DFMT_R5G6B5:
; 54   : 			return 0;

	xor	eax, eax
	jmp	SHORT $LN16@AlphaChann
$LN9@AlphaChann:

; 55   : 		case D3DFMT_X1R5G5B5:
; 56   : 			return 0;

	xor	eax, eax
	jmp	SHORT $LN16@AlphaChann
$LN8@AlphaChann:

; 57   : 		case D3DFMT_A1R5G5B5:
; 58   : 			return 1;

	mov	eax, 1
	jmp	SHORT $LN16@AlphaChann
$LN7@AlphaChann:

; 59   : 		case D3DFMT_A4R4G4B4:
; 60   : 			return 4;

	mov	eax, 4
	jmp	SHORT $LN16@AlphaChann
$LN6@AlphaChann:

; 61   : 		case D3DFMT_R3G3B2:
; 62   : 			return 0;

	xor	eax, eax
	jmp	SHORT $LN16@AlphaChann
$LN5@AlphaChann:

; 63   : 		case D3DFMT_A8R3G3B2:
; 64   : 			return 8;

	mov	eax, 8
	jmp	SHORT $LN16@AlphaChann
$LN4@AlphaChann:

; 65   : 		case D3DFMT_X4R4G4B4:
; 66   : 			return 0;

	xor	eax, eax
	jmp	SHORT $LN16@AlphaChann
$LN3@AlphaChann:

; 67   : 		case D3DFMT_A2B10G10R10:
; 68   : 			return 2;

	mov	eax, 2
	jmp	SHORT $LN16@AlphaChann
$LN2@AlphaChann:

; 69   : 		case D3DFMT_A2R10G10B10:
; 70   : 			return 2;

	mov	eax, 2
	jmp	SHORT $LN16@AlphaChann
$LN1@AlphaChann:

; 71   : 		default:
; 72   : 			return 0;

	xor	eax, eax
$LN16@AlphaChann:

; 73   : 		}
; 74   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN18@AlphaChann:
	DD	$LN13@AlphaChann
	DD	$LN12@AlphaChann
	DD	$LN11@AlphaChann
	DD	$LN10@AlphaChann
	DD	$LN9@AlphaChann
	DD	$LN8@AlphaChann
	DD	$LN7@AlphaChann
	DD	$LN6@AlphaChann
	DD	$LN1@AlphaChann
	DD	$LN5@AlphaChann
	DD	$LN4@AlphaChann
	DD	$LN3@AlphaChann
	DD	$LN1@AlphaChann
	DD	$LN1@AlphaChann
	DD	$LN1@AlphaChann
	DD	$LN2@AlphaChann
?AlphaChannelBits@Ogre@@YAIW4_D3DFORMAT@@@Z ENDP	; Ogre::AlphaChannelBits
_TEXT	ENDS
PUBLIC	?Dismiss@ScopeGuardImplBase@Ogre@@QBEXXZ	; Ogre::ScopeGuardImplBase::Dismiss
PUBLIC	?BuildPresentIntervalList@D3DEnumeration@Ogre@@AAEXPAUD3DDEVICEINFO_T@2@PAUD3DDEVCOMBO_T@2@@Z ; Ogre::D3DEnumeration::BuildPresentIntervalList
PUBLIC	?empty@?$vector@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@QBE_NXZ ; std::vector<enum Ogre::VERTPROCESS_T,std::allocator<enum Ogre::VERTPROCESS_T> >::empty
PUBLIC	?BuildVertexProcessingTypeList@D3DEnumeration@Ogre@@AAEXPAUD3DDEVICEINFO_T@2@PAUD3DDEVCOMBO_T@2@@Z ; Ogre::D3DEnumeration::BuildVertexProcessingTypeList
PUBLIC	?BuildDSMSConflictList@D3DEnumeration@Ogre@@AAEXPAUD3DDEVCOMBO_T@2@@Z ; Ogre::D3DEnumeration::BuildDSMSConflictList
PUBLIC	?empty@?$vector@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@QBE_NXZ ; std::vector<enum _D3DMULTISAMPLE_TYPE,std::allocator<enum _D3DMULTISAMPLE_TYPE> >::empty
PUBLIC	?BuildMultiSampleTypeList@D3DEnumeration@Ogre@@AAEXPAUD3DDEVCOMBO_T@2@@Z ; Ogre::D3DEnumeration::BuildMultiSampleTypeList
PUBLIC	??1?$PtrScopeGuardImpl@UD3DDEVCOMBO_T@Ogre@@@Ogre@@QAE@XZ ; Ogre::PtrScopeGuardImpl<Ogre::D3DDEVCOMBO_T>::~PtrScopeGuardImpl<Ogre::D3DDEVCOMBO_T>
PUBLIC	?empty@?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@QBE_NXZ ; std::vector<enum _D3DFORMAT,std::allocator<enum _D3DFORMAT> >::empty
PUBLIC	?BuildDepthStencilFormatList@D3DEnumeration@Ogre@@AAEXPAUD3DDEVCOMBO_T@2@@Z ; Ogre::D3DEnumeration::BuildDepthStencilFormatList
PUBLIC	??$MakePtrGuard@UD3DDEVCOMBO_T@Ogre@@@Ogre@@YA?AV?$PtrScopeGuardImpl@UD3DDEVCOMBO_T@Ogre@@@0@PAUD3DDEVCOMBO_T@0@@Z ; Ogre::MakePtrGuard<Ogre::D3DDEVCOMBO_T>
PUBLIC	??0D3DDEVCOMBO_T@Ogre@@QAE@XZ			; Ogre::D3DDEVCOMBO_T::D3DDEVCOMBO_T
xdata$x	SEGMENT
__unwindtable$?ComputeDeviceCombo@D3DEnumeration@Ogre@@AAEPAUD3DDEVCOMBO_T@2@PAUD3DDEVICEINFO_T@2@W4_D3DFORMAT@@1H@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ComputeDeviceCombo@D3DEnumeration@Ogre@@AAEPAUD3DDEVCOMBO_T@2@PAUD3DDEVICEINFO_T@2@W4_D3DFORMAT@@1H@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?ComputeDeviceCombo@D3DEnumeration@Ogre@@AAEPAUD3DDEVCOMBO_T@2@PAUD3DDEVICEINFO_T@2@W4_D3DFORMAT@@1H@Z$1
__ehfuncinfo$?ComputeDeviceCombo@D3DEnumeration@Ogre@@AAEPAUD3DDEVCOMBO_T@2@PAUD3DDEVICEINFO_T@2@W4_D3DFORMAT@@1H@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?ComputeDeviceCombo@D3DEnumeration@Ogre@@AAEPAUD3DDEVCOMBO_T@2@PAUD3DDEVICEINFO_T@2@W4_D3DFORMAT@@1H@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
_TEXT	SEGMENT
tv92 = -60						; size = 4
_this$ = -56						; size = 4
$T141532 = -52						; size = 4
$T141531 = -48						; size = 4
$T141530 = -44						; size = 4
$T141529 = -40						; size = 4
$T141526 = -36						; size = 4
$T141525 = -32						; size = 4
_comboguard$ = -28					; size = 4
_$S1$ = -24						; size = 8
_pcombo$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_pdevice$ = 8						; size = 4
_dispformat$ = 12					; size = 4
_bkbufformat$ = 16					; size = 4
_iswindow$ = 20						; size = 4
?ComputeDeviceCombo@D3DEnumeration@Ogre@@AAEPAUD3DDEVCOMBO_T@2@PAUD3DDEVICEINFO_T@2@W4_D3DFORMAT@@1H@Z PROC ; Ogre::D3DEnumeration::ComputeDeviceCombo
; _this$ = ecx

; 292  : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?ComputeDeviceCombo@D3DEnumeration@Ogre@@AAEPAUD3DDEVCOMBO_T@2@PAUD3DDEVICEINFO_T@2@W4_D3DFORMAT@@1H@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 48					; 00000030H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 293  : 		if( iswindow && m_RequireFullscreen ) return NULL;

	cmp	DWORD PTR _iswindow$[ebp], 0
	je	SHORT $LN7@ComputeDev
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+88], 0
	je	SHORT $LN7@ComputeDev
	xor	eax, eax
	jmp	$LN8@ComputeDev
$LN7@ComputeDev:

; 294  : 		if( !iswindow && m_RequireWindowed ) return NULL;

	cmp	DWORD PTR _iswindow$[ebp], 0
	jne	SHORT $LN6@ComputeDev
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+84], 0
	je	SHORT $LN6@ComputeDev
	xor	eax, eax
	jmp	$LN8@ComputeDev
$LN6@ComputeDev:

; 295  : 
; 296  : 		if( FAILED(m_pD3D->CheckDeviceType(pdevice->iadapter, pdevice->type, dispformat, bkbufformat, iswindow)) )

	mov	edx, DWORD PTR _iswindow$[ebp]
	push	edx
	mov	eax, DWORD PTR _bkbufformat$[ebp]
	push	eax
	mov	ecx, DWORD PTR _dispformat$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pdevice$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _pdevice$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+92]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+92]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	mov	edx, DWORD PTR [ecx+36]
	call	edx
	test	eax, eax
	jge	SHORT $LN5@ComputeDev

; 297  : 		{
; 298  : 			return NULL;

	xor	eax, eax
	jmp	$LN8@ComputeDev
$LN5@ComputeDev:

; 299  : 		}
; 300  : 
; 301  : 		D3DDEVCOMBO_T *pcombo = new D3DDEVCOMBO_T;

	push	164					; 000000a4H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T141526[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T141526[ebp], 0
	je	SHORT $LN10@ComputeDev
	mov	ecx, DWORD PTR $T141526[ebp]
	call	??0D3DDEVCOMBO_T@Ogre@@QAE@XZ
	mov	DWORD PTR tv92[ebp], eax
	jmp	SHORT $LN11@ComputeDev
$LN10@ComputeDev:
	mov	DWORD PTR tv92[ebp], 0
$LN11@ComputeDev:
	mov	eax, DWORD PTR tv92[ebp]
	mov	DWORD PTR $T141525[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR $T141525[ebp]
	mov	DWORD PTR _pcombo$[ebp], ecx

; 302  : 		ScopeGuard comboguard = MakePtrGuard( pcombo );

	mov	edx, DWORD PTR _pcombo$[ebp]
	push	edx
	lea	eax, DWORD PTR _$S1$[ebp]
	push	eax
	call	??$MakePtrGuard@UD3DDEVCOMBO_T@Ogre@@@Ogre@@YA?AV?$PtrScopeGuardImpl@UD3DDEVCOMBO_T@Ogre@@@0@PAUD3DDEVCOMBO_T@0@@Z ; Ogre::MakePtrGuard<Ogre::D3DDEVCOMBO_T>
	add	esp, 8
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _$S1$[ebp]
	mov	DWORD PTR _comboguard$[ebp], ecx

; 303  : 
; 304  : 		pcombo->iadapter = pdevice->iadapter;

	mov	edx, DWORD PTR _pcombo$[ebp]
	mov	eax, DWORD PTR _pdevice$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx

; 305  : 		pcombo->devtype = pdevice->type;

	mov	edx, DWORD PTR _pcombo$[ebp]
	mov	eax, DWORD PTR _pdevice$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx

; 306  : 		pcombo->adapterfmt = dispformat;

	mov	edx, DWORD PTR _pcombo$[ebp]
	mov	eax, DWORD PTR _dispformat$[ebp]
	mov	DWORD PTR [edx+8], eax

; 307  : 		pcombo->backbuffmt = bkbufformat;

	mov	ecx, DWORD PTR _pcombo$[ebp]
	mov	edx, DWORD PTR _bkbufformat$[ebp]
	mov	DWORD PTR [ecx+12], edx

; 308  : 		pcombo->iswindowed = iswindow;

	mov	eax, DWORD PTR _pcombo$[ebp]
	mov	ecx, DWORD PTR _iswindow$[ebp]
	mov	DWORD PTR [eax+16], ecx

; 309  : 
; 310  : 		if( m_UseDepthBuf )

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+76], 0
	je	SHORT $LN4@ComputeDev

; 311  : 		{
; 312  : 			BuildDepthStencilFormatList( pcombo );

	mov	eax, DWORD PTR _pcombo$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?BuildDepthStencilFormatList@D3DEnumeration@Ogre@@AAEXPAUD3DDEVCOMBO_T@2@@Z ; Ogre::D3DEnumeration::BuildDepthStencilFormatList

; 313  : 			if( pcombo->dsfmts.empty() )return NULL;

	mov	ecx, DWORD PTR _pcombo$[ebp]
	add	ecx, 20					; 00000014H
	call	?empty@?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@QBE_NXZ ; std::vector<enum _D3DFORMAT,std::allocator<enum _D3DFORMAT> >::empty
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN4@ComputeDev
	mov	DWORD PTR $T141529[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _$S1$[ebp]
	call	??1?$PtrScopeGuardImpl@UD3DDEVCOMBO_T@Ogre@@@Ogre@@QAE@XZ ; Ogre::PtrScopeGuardImpl<Ogre::D3DDEVCOMBO_T>::~PtrScopeGuardImpl<Ogre::D3DDEVCOMBO_T>
	mov	eax, DWORD PTR $T141529[ebp]
	jmp	$LN8@ComputeDev
$LN4@ComputeDev:

; 314  : 		}
; 315  : 
; 316  : 		BuildMultiSampleTypeList( pcombo );

	mov	edx, DWORD PTR _pcombo$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?BuildMultiSampleTypeList@D3DEnumeration@Ogre@@AAEXPAUD3DDEVCOMBO_T@2@@Z ; Ogre::D3DEnumeration::BuildMultiSampleTypeList

; 317  : 		if( pcombo->mstypes.empty() )return NULL;

	mov	ecx, DWORD PTR _pcombo$[ebp]
	add	ecx, 44					; 0000002cH
	call	?empty@?$vector@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@QBE_NXZ ; std::vector<enum _D3DMULTISAMPLE_TYPE,std::allocator<enum _D3DMULTISAMPLE_TYPE> >::empty
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@ComputeDev
	mov	DWORD PTR $T141530[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _$S1$[ebp]
	call	??1?$PtrScopeGuardImpl@UD3DDEVCOMBO_T@Ogre@@@Ogre@@QAE@XZ ; Ogre::PtrScopeGuardImpl<Ogre::D3DDEVCOMBO_T>::~PtrScopeGuardImpl<Ogre::D3DDEVCOMBO_T>
	mov	eax, DWORD PTR $T141530[ebp]
	jmp	SHORT $LN8@ComputeDev
$LN2@ComputeDev:

; 318  : 
; 319  : 		BuildDSMSConflictList( pcombo );

	mov	ecx, DWORD PTR _pcombo$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?BuildDSMSConflictList@D3DEnumeration@Ogre@@AAEXPAUD3DDEVCOMBO_T@2@@Z ; Ogre::D3DEnumeration::BuildDSMSConflictList

; 320  : 		BuildVertexProcessingTypeList( pdevice, pcombo );

	mov	edx, DWORD PTR _pcombo$[ebp]
	push	edx
	mov	eax, DWORD PTR _pdevice$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?BuildVertexProcessingTypeList@D3DEnumeration@Ogre@@AAEXPAUD3DDEVICEINFO_T@2@PAUD3DDEVCOMBO_T@2@@Z ; Ogre::D3DEnumeration::BuildVertexProcessingTypeList

; 321  : 		if( pcombo->vptypes.empty() ) return NULL;

	mov	ecx, DWORD PTR _pcombo$[ebp]
	add	ecx, 116				; 00000074H
	call	?empty@?$vector@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@QBE_NXZ ; std::vector<enum Ogre::VERTPROCESS_T,std::allocator<enum Ogre::VERTPROCESS_T> >::empty
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@ComputeDev
	mov	DWORD PTR $T141531[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _$S1$[ebp]
	call	??1?$PtrScopeGuardImpl@UD3DDEVCOMBO_T@Ogre@@@Ogre@@QAE@XZ ; Ogre::PtrScopeGuardImpl<Ogre::D3DDEVCOMBO_T>::~PtrScopeGuardImpl<Ogre::D3DDEVCOMBO_T>
	mov	eax, DWORD PTR $T141531[ebp]
	jmp	SHORT $LN8@ComputeDev
$LN1@ComputeDev:

; 322  : 
; 323  : 		BuildPresentIntervalList( pdevice, pcombo );

	mov	edx, DWORD PTR _pcombo$[ebp]
	push	edx
	mov	eax, DWORD PTR _pdevice$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?BuildPresentIntervalList@D3DEnumeration@Ogre@@AAEXPAUD3DDEVICEINFO_T@2@PAUD3DDEVCOMBO_T@2@@Z ; Ogre::D3DEnumeration::BuildPresentIntervalList

; 324  : 
; 325  : 		comboguard.Dismiss();

	mov	ecx, DWORD PTR _comboguard$[ebp]
	call	?Dismiss@ScopeGuardImplBase@Ogre@@QBEXXZ ; Ogre::ScopeGuardImplBase::Dismiss

; 326  : 		return pcombo;

	mov	ecx, DWORD PTR _pcombo$[ebp]
	mov	DWORD PTR $T141532[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _$S1$[ebp]
	call	??1?$PtrScopeGuardImpl@UD3DDEVCOMBO_T@Ogre@@@Ogre@@QAE@XZ ; Ogre::PtrScopeGuardImpl<Ogre::D3DDEVCOMBO_T>::~PtrScopeGuardImpl<Ogre::D3DDEVCOMBO_T>
	mov	eax, DWORD PTR $T141532[ebp]
$LN8@ComputeDev:

; 327  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?ComputeDeviceCombo@D3DEnumeration@Ogre@@AAEPAUD3DDEVCOMBO_T@2@PAUD3DDEVICEINFO_T@2@W4_D3DFORMAT@@1H@Z$0:
	mov	eax, DWORD PTR $T141526[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?ComputeDeviceCombo@D3DEnumeration@Ogre@@AAEPAUD3DDEVCOMBO_T@2@PAUD3DDEVICEINFO_T@2@W4_D3DFORMAT@@1H@Z$1:
	lea	ecx, DWORD PTR _$S1$[ebp]
	jmp	??1?$PtrScopeGuardImpl@UD3DDEVCOMBO_T@Ogre@@@Ogre@@QAE@XZ ; Ogre::PtrScopeGuardImpl<Ogre::D3DDEVCOMBO_T>::~PtrScopeGuardImpl<Ogre::D3DDEVCOMBO_T>
__ehhandler$?ComputeDeviceCombo@D3DEnumeration@Ogre@@AAEPAUD3DDEVCOMBO_T@2@PAUD3DDEVICEINFO_T@2@W4_D3DFORMAT@@1H@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-52]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?ComputeDeviceCombo@D3DEnumeration@Ogre@@AAEPAUD3DDEVCOMBO_T@2@PAUD3DDEVICEINFO_T@2@W4_D3DFORMAT@@1H@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?ComputeDeviceCombo@D3DEnumeration@Ogre@@AAEPAUD3DDEVCOMBO_T@2@PAUD3DDEVICEINFO_T@2@W4_D3DFORMAT@@1H@Z ENDP ; Ogre::D3DEnumeration::ComputeDeviceCombo
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogrescopeguard.h
;	COMDAT ?Dismiss@ScopeGuardImplBase@Ogre@@QBEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Dismiss@ScopeGuardImplBase@Ogre@@QBEXXZ PROC		; Ogre::ScopeGuardImplBase::Dismiss, COMDAT
; _this$ = ecx

; 59   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 60   : 			dismissed_ = true;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax], 1

; 61   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?Dismiss@ScopeGuardImplBase@Ogre@@QBEXXZ ENDP		; Ogre::ScopeGuardImplBase::Dismiss
_TEXT	ENDS
PUBLIC	??0?$vector@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@QAE@XZ ; std::vector<enum Ogre::VERTPROCESS_T,std::allocator<enum Ogre::VERTPROCESS_T> >::vector<enum Ogre::VERTPROCESS_T,std::allocator<enum Ogre::VERTPROCESS_T> >
PUBLIC	??0?$vector@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::D3DSMSCONFLICT_T,std::allocator<Ogre::D3DSMSCONFLICT_T> >::vector<Ogre::D3DSMSCONFLICT_T,std::allocator<Ogre::D3DSMSCONFLICT_T> >
PUBLIC	??0?$vector@IV?$allocator@I@std@@@std@@QAE@XZ	; std::vector<unsigned int,std::allocator<unsigned int> >::vector<unsigned int,std::allocator<unsigned int> >
PUBLIC	??0?$vector@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@QAE@XZ ; std::vector<enum _D3DMULTISAMPLE_TYPE,std::allocator<enum _D3DMULTISAMPLE_TYPE> >::vector<enum _D3DMULTISAMPLE_TYPE,std::allocator<enum _D3DMULTISAMPLE_TYPE> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0D3DDEVCOMBO_T@Ogre@@QAE@XZ DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$??0D3DDEVCOMBO_T@Ogre@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__unwindtable$??0D3DDEVCOMBO_T@Ogre@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0D3DDEVCOMBO_T@Ogre@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0D3DDEVCOMBO_T@Ogre@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0D3DDEVCOMBO_T@Ogre@@QAE@XZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$??0D3DDEVCOMBO_T@Ogre@@QAE@XZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$??0D3DDEVCOMBO_T@Ogre@@QAE@XZ$4
	DD	04H
	DD	FLAT:__unwindfunclet$??0D3DDEVCOMBO_T@Ogre@@QAE@XZ$5
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0D3DDEVCOMBO_T@Ogre@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0D3DDEVCOMBO_T@Ogre@@QAE@XZ PROC			; Ogre::D3DDEVCOMBO_T::D3DDEVCOMBO_T, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0D3DDEVCOMBO_T@Ogre@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 20					; 00000014H
	call	??0?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@QAE@XZ ; std::vector<enum _D3DFORMAT,std::allocator<enum _D3DFORMAT> >::vector<enum _D3DFORMAT,std::allocator<enum _D3DFORMAT> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 44					; 0000002cH
	call	??0?$vector@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@QAE@XZ ; std::vector<enum _D3DMULTISAMPLE_TYPE,std::allocator<enum _D3DMULTISAMPLE_TYPE> >::vector<enum _D3DMULTISAMPLE_TYPE,std::allocator<enum _D3DMULTISAMPLE_TYPE> >
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 68					; 00000044H
	call	??0?$vector@IV?$allocator@I@std@@@std@@QAE@XZ ; std::vector<unsigned int,std::allocator<unsigned int> >::vector<unsigned int,std::allocator<unsigned int> >
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 92					; 0000005cH
	call	??0?$vector@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::D3DSMSCONFLICT_T,std::allocator<Ogre::D3DSMSCONFLICT_T> >::vector<Ogre::D3DSMSCONFLICT_T,std::allocator<Ogre::D3DSMSCONFLICT_T> >
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 116				; 00000074H
	call	??0?$vector@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@QAE@XZ ; std::vector<enum Ogre::VERTPROCESS_T,std::allocator<enum Ogre::VERTPROCESS_T> >::vector<enum Ogre::VERTPROCESS_T,std::allocator<enum Ogre::VERTPROCESS_T> >
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 140				; 0000008cH
	call	??0?$vector@IV?$allocator@I@std@@@std@@QAE@XZ ; std::vector<unsigned int,std::allocator<unsigned int> >::vector<unsigned int,std::allocator<unsigned int> >
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0D3DDEVCOMBO_T@Ogre@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 20					; 00000014H
	jmp	??1?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@QAE@XZ ; std::vector<enum _D3DFORMAT,std::allocator<enum _D3DFORMAT> >::~vector<enum _D3DFORMAT,std::allocator<enum _D3DFORMAT> >
__unwindfunclet$??0D3DDEVCOMBO_T@Ogre@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 44					; 0000002cH
	jmp	??1?$vector@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@QAE@XZ ; std::vector<enum _D3DMULTISAMPLE_TYPE,std::allocator<enum _D3DMULTISAMPLE_TYPE> >::~vector<enum _D3DMULTISAMPLE_TYPE,std::allocator<enum _D3DMULTISAMPLE_TYPE> >
__unwindfunclet$??0D3DDEVCOMBO_T@Ogre@@QAE@XZ$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 68					; 00000044H
	jmp	??1?$vector@IV?$allocator@I@std@@@std@@QAE@XZ ; std::vector<unsigned int,std::allocator<unsigned int> >::~vector<unsigned int,std::allocator<unsigned int> >
__unwindfunclet$??0D3DDEVCOMBO_T@Ogre@@QAE@XZ$3:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 92					; 0000005cH
	jmp	??1?$vector@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::D3DSMSCONFLICT_T,std::allocator<Ogre::D3DSMSCONFLICT_T> >::~vector<Ogre::D3DSMSCONFLICT_T,std::allocator<Ogre::D3DSMSCONFLICT_T> >
__unwindfunclet$??0D3DDEVCOMBO_T@Ogre@@QAE@XZ$4:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 116				; 00000074H
	jmp	??1?$vector@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@QAE@XZ ; std::vector<enum Ogre::VERTPROCESS_T,std::allocator<enum Ogre::VERTPROCESS_T> >::~vector<enum Ogre::VERTPROCESS_T,std::allocator<enum Ogre::VERTPROCESS_T> >
__unwindfunclet$??0D3DDEVCOMBO_T@Ogre@@QAE@XZ$5:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 140				; 0000008cH
	jmp	??1?$vector@IV?$allocator@I@std@@@std@@QAE@XZ ; std::vector<unsigned int,std::allocator<unsigned int> >::~vector<unsigned int,std::allocator<unsigned int> >
__ehhandler$??0D3DDEVCOMBO_T@Ogre@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0D3DDEVCOMBO_T@Ogre@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0D3DDEVCOMBO_T@Ogre@@QAE@XZ ENDP			; Ogre::D3DDEVCOMBO_T::D3DDEVCOMBO_T
; Function compile flags: /Odtp
; File i:\svnroot\client\plugins\rendersystem_d3d9\ogred3d9driverenum.cpp
_TEXT	SEGMENT
_this$ = -36						; size = 4
_dsf$128945 = -32					; size = 4
_idsf$128941 = -28					; size = 4
_dsfarray$ = -24					; size = 24
_pcombo$ = 8						; size = 4
?BuildDepthStencilFormatList@D3DEnumeration@Ogre@@AAEXPAUD3DDEVCOMBO_T@2@@Z PROC ; Ogre::D3DEnumeration::BuildDepthStencilFormatList
; _this$ = ecx

; 330  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	mov	DWORD PTR _this$[ebp], ecx

; 331  : 		const D3DFORMAT dsfarray[] = 
; 332  : 		{
; 333  : 			D3DFMT_D16,

	mov	DWORD PTR _dsfarray$[ebp], 80		; 00000050H

; 334  : 				D3DFMT_D15S1,

	mov	DWORD PTR _dsfarray$[ebp+4], 73		; 00000049H

; 335  : 				D3DFMT_D24X8,

	mov	DWORD PTR _dsfarray$[ebp+8], 77		; 0000004dH

; 336  : 				D3DFMT_D24S8,

	mov	DWORD PTR _dsfarray$[ebp+12], 75	; 0000004bH

; 337  : 				D3DFMT_D24X4S4,

	mov	DWORD PTR _dsfarray$[ebp+16], 79	; 0000004fH

; 338  : 				D3DFMT_D32,

	mov	DWORD PTR _dsfarray$[ebp+20], 71	; 00000047H

; 339  : 		};
; 340  : 
; 341  : 		for( UINT idsf=0; idsf<ARRAY_ELEMENTS(dsfarray); idsf++ )

	mov	DWORD PTR _idsf$128941[ebp], 0
	jmp	SHORT $LN7@BuildDepth
$LN6@BuildDepth:
	mov	eax, DWORD PTR _idsf$128941[ebp]
	add	eax, 1
	mov	DWORD PTR _idsf$128941[ebp], eax
$LN7@BuildDepth:
	cmp	DWORD PTR _idsf$128941[ebp], 6
	jae	$LN8@BuildDepth

; 342  : 		{
; 343  : 			D3DFORMAT dsf = dsfarray[idsf];

	mov	ecx, DWORD PTR _idsf$128941[ebp]
	mov	edx, DWORD PTR _dsfarray$[ebp+ecx*4]
	mov	DWORD PTR _dsf$128945[ebp], edx

; 344  : 			if( DepthBits(dsf) < this->m_MinDepthBits ) continue;

	mov	eax, DWORD PTR _dsf$128945[ebp]
	push	eax
	call	?DepthBits@Ogre@@YAIW4_D3DFORMAT@@@Z	; Ogre::DepthBits
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR [ecx+68]
	jae	SHORT $LN4@BuildDepth
	jmp	SHORT $LN6@BuildDepth
$LN4@BuildDepth:

; 345  : 			if( StencilBits(dsf) < this->m_MinStencilBits ) continue;

	mov	edx, DWORD PTR _dsf$128945[ebp]
	push	edx
	call	?StencilBits@Ogre@@YAIW4_D3DFORMAT@@@Z	; Ogre::StencilBits
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR [ecx+72]
	jae	SHORT $LN3@BuildDepth
	jmp	SHORT $LN6@BuildDepth
$LN3@BuildDepth:

; 346  : 
; 347  : 			if( SUCCEEDED(m_pD3D->CheckDeviceFormat(pcombo->iadapter, pcombo->devtype, pcombo->adapterfmt, 
; 348  : 				D3DUSAGE_DEPTHSTENCIL, D3DRTYPE_SURFACE, dsf)) )

	mov	edx, DWORD PTR _dsf$128945[ebp]
	push	edx
	push	1
	push	2
	mov	eax, DWORD PTR _pcombo$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _pcombo$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _pcombo$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+92]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+92]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	mov	edx, DWORD PTR [ecx+40]
	call	edx
	test	eax, eax
	jl	SHORT $LN2@BuildDepth

; 349  : 			{
; 350  : 				if( SUCCEEDED(m_pD3D->CheckDepthStencilMatch(pcombo->iadapter, pcombo->devtype, pcombo->adapterfmt, 
; 351  : 					pcombo->backbuffmt, dsf)) )

	mov	eax, DWORD PTR _dsf$128945[ebp]
	push	eax
	mov	ecx, DWORD PTR _pcombo$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR _pcombo$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _pcombo$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _pcombo$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+92]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+92]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	mov	edx, DWORD PTR [ecx+48]
	call	edx
	test	eax, eax
	jl	SHORT $LN2@BuildDepth

; 352  : 				{
; 353  : 					pcombo->dsfmts.push_back( dsf );

	lea	eax, DWORD PTR _dsf$128945[ebp]
	push	eax
	mov	ecx, DWORD PTR _pcombo$[ebp]
	add	ecx, 20					; 00000014H
	call	?push_back@?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@QAEXABW4_D3DFORMAT@@@Z ; std::vector<enum _D3DFORMAT,std::allocator<enum _D3DFORMAT> >::push_back
$LN2@BuildDepth:

; 354  : 				}
; 355  : 			}

	jmp	$LN6@BuildDepth
$LN8@BuildDepth:

; 356  : 		}
; 357  : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
?BuildDepthStencilFormatList@D3DEnumeration@Ogre@@AAEXPAUD3DDEVCOMBO_T@2@@Z ENDP ; Ogre::D3DEnumeration::BuildDepthStencilFormatList
; Function compile flags: /Odtp
tv64 = -4						; size = 4
_fmt$ = 8						; size = 4
?DepthBits@Ogre@@YAIW4_D3DFORMAT@@@Z PROC		; Ogre::DepthBits

; 77   : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 78   : 		switch( fmt )

	mov	eax, DWORD PTR _fmt$[ebp]
	mov	DWORD PTR tv64[ebp], eax
	mov	ecx, DWORD PTR tv64[ebp]
	sub	ecx, 71					; 00000047H
	mov	DWORD PTR tv64[ebp], ecx
	cmp	DWORD PTR tv64[ebp], 9
	ja	SHORT $LN1@DepthBits
	mov	edx, DWORD PTR tv64[ebp]
	jmp	DWORD PTR $LN12@DepthBits[edx*4]
$LN7@DepthBits:

; 79   : 		{
; 80   : 		case D3DFMT_D16:
; 81   : 			return 16;

	mov	eax, 16					; 00000010H
	jmp	SHORT $LN10@DepthBits
$LN6@DepthBits:

; 82   : 		case D3DFMT_D15S1:
; 83   : 			return 15;

	mov	eax, 15					; 0000000fH
	jmp	SHORT $LN10@DepthBits
$LN5@DepthBits:

; 84   : 		case D3DFMT_D24X8:
; 85   : 			return 24;

	mov	eax, 24					; 00000018H
	jmp	SHORT $LN10@DepthBits
$LN4@DepthBits:

; 86   : 		case D3DFMT_D24S8:
; 87   : 			return 24;

	mov	eax, 24					; 00000018H
	jmp	SHORT $LN10@DepthBits
$LN3@DepthBits:

; 88   : 		case D3DFMT_D24X4S4:
; 89   : 			return 24;

	mov	eax, 24					; 00000018H
	jmp	SHORT $LN10@DepthBits
$LN2@DepthBits:

; 90   : 		case D3DFMT_D32:
; 91   : 			return 32;

	mov	eax, 32					; 00000020H
	jmp	SHORT $LN10@DepthBits
$LN1@DepthBits:

; 92   : 		default:
; 93   : 			return 0;

	xor	eax, eax
$LN10@DepthBits:

; 94   : 		}
; 95   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN12@DepthBits:
	DD	$LN2@DepthBits
	DD	$LN1@DepthBits
	DD	$LN6@DepthBits
	DD	$LN1@DepthBits
	DD	$LN4@DepthBits
	DD	$LN1@DepthBits
	DD	$LN5@DepthBits
	DD	$LN1@DepthBits
	DD	$LN3@DepthBits
	DD	$LN7@DepthBits
?DepthBits@Ogre@@YAIW4_D3DFORMAT@@@Z ENDP		; Ogre::DepthBits
; Function compile flags: /Odtp
tv64 = -4						; size = 4
_fmt$ = 8						; size = 4
?StencilBits@Ogre@@YAIW4_D3DFORMAT@@@Z PROC		; Ogre::StencilBits

; 105  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 106  : 		switch( fmt )

	mov	eax, DWORD PTR _fmt$[ebp]
	mov	DWORD PTR tv64[ebp], eax
	mov	ecx, DWORD PTR tv64[ebp]
	sub	ecx, 71					; 00000047H
	mov	DWORD PTR tv64[ebp], ecx
	cmp	DWORD PTR tv64[ebp], 9
	ja	SHORT $LN1@StencilBit
	mov	edx, DWORD PTR tv64[ebp]
	jmp	DWORD PTR $LN12@StencilBit[edx*4]
$LN7@StencilBit:

; 107  : 		{
; 108  : 		case D3DFMT_D16:
; 109  : 			return 0;

	xor	eax, eax
	jmp	SHORT $LN10@StencilBit
$LN6@StencilBit:

; 110  : 		case D3DFMT_D15S1:
; 111  : 			return 1;

	mov	eax, 1
	jmp	SHORT $LN10@StencilBit
$LN5@StencilBit:

; 112  : 		case D3DFMT_D24X8:
; 113  : 			return 0;

	xor	eax, eax
	jmp	SHORT $LN10@StencilBit
$LN4@StencilBit:

; 114  : 		case D3DFMT_D24S8:
; 115  : 			return 8;

	mov	eax, 8
	jmp	SHORT $LN10@StencilBit
$LN3@StencilBit:

; 116  : 		case D3DFMT_D24X4S4:
; 117  : 			return 4;

	mov	eax, 4
	jmp	SHORT $LN10@StencilBit
$LN2@StencilBit:

; 118  : 		case D3DFMT_D32:
; 119  : 			return 0;

	xor	eax, eax
	jmp	SHORT $LN10@StencilBit
$LN1@StencilBit:

; 120  : 		default:
; 121  : 			return 0;

	xor	eax, eax
$LN10@StencilBit:

; 122  : 		}
; 123  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN12@StencilBit:
	DD	$LN2@StencilBit
	DD	$LN1@StencilBit
	DD	$LN6@StencilBit
	DD	$LN1@StencilBit
	DD	$LN4@StencilBit
	DD	$LN1@StencilBit
	DD	$LN5@StencilBit
	DD	$LN1@StencilBit
	DD	$LN3@StencilBit
	DD	$LN7@StencilBit
?StencilBits@Ogre@@YAIW4_D3DFORMAT@@@Z ENDP		; Ogre::StencilBits
_TEXT	ENDS
PUBLIC	?push_back@?$vector@IV?$allocator@I@std@@@std@@QAEXABI@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::push_back
PUBLIC	?push_back@?$vector@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@QAEXABW4_D3DMULTISAMPLE_TYPE@@@Z ; std::vector<enum _D3DMULTISAMPLE_TYPE,std::allocator<enum _D3DMULTISAMPLE_TYPE> >::push_back
; Function compile flags: /Odtp
_TEXT	SEGMENT
_this$ = -92						; size = 4
$T141561 = -88						; size = 4
_imst$128959 = -84					; size = 4
_msType$ = -80						; size = 4
_msQuality$ = -76					; size = 4
_msTypeArray$ = -72					; size = 68
_pcombo$ = 8						; size = 4
?BuildMultiSampleTypeList@D3DEnumeration@Ogre@@AAEXPAUD3DDEVCOMBO_T@2@@Z PROC ; Ogre::D3DEnumeration::BuildMultiSampleTypeList
; _this$ = ecx

; 360  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH
	mov	DWORD PTR _this$[ebp], ecx

; 361  : 		const D3DMULTISAMPLE_TYPE msTypeArray[] = { 
; 362  : 			D3DMULTISAMPLE_NONE,

	mov	DWORD PTR _msTypeArray$[ebp], 0

; 363  : 				D3DMULTISAMPLE_NONMASKABLE,

	mov	DWORD PTR _msTypeArray$[ebp+4], 1

; 364  : 				D3DMULTISAMPLE_2_SAMPLES,

	mov	DWORD PTR _msTypeArray$[ebp+8], 2

; 365  : 				D3DMULTISAMPLE_3_SAMPLES,

	mov	DWORD PTR _msTypeArray$[ebp+12], 3

; 366  : 				D3DMULTISAMPLE_4_SAMPLES,

	mov	DWORD PTR _msTypeArray$[ebp+16], 4

; 367  : 				D3DMULTISAMPLE_5_SAMPLES,

	mov	DWORD PTR _msTypeArray$[ebp+20], 5

; 368  : 				D3DMULTISAMPLE_6_SAMPLES,

	mov	DWORD PTR _msTypeArray$[ebp+24], 6

; 369  : 				D3DMULTISAMPLE_7_SAMPLES,

	mov	DWORD PTR _msTypeArray$[ebp+28], 7

; 370  : 				D3DMULTISAMPLE_8_SAMPLES,

	mov	DWORD PTR _msTypeArray$[ebp+32], 8

; 371  : 				D3DMULTISAMPLE_9_SAMPLES,

	mov	DWORD PTR _msTypeArray$[ebp+36], 9

; 372  : 				D3DMULTISAMPLE_10_SAMPLES,

	mov	DWORD PTR _msTypeArray$[ebp+40], 10	; 0000000aH

; 373  : 				D3DMULTISAMPLE_11_SAMPLES,

	mov	DWORD PTR _msTypeArray$[ebp+44], 11	; 0000000bH

; 374  : 				D3DMULTISAMPLE_12_SAMPLES,

	mov	DWORD PTR _msTypeArray$[ebp+48], 12	; 0000000cH

; 375  : 				D3DMULTISAMPLE_13_SAMPLES,

	mov	DWORD PTR _msTypeArray$[ebp+52], 13	; 0000000dH

; 376  : 				D3DMULTISAMPLE_14_SAMPLES,

	mov	DWORD PTR _msTypeArray$[ebp+56], 14	; 0000000eH

; 377  : 				D3DMULTISAMPLE_15_SAMPLES,

	mov	DWORD PTR _msTypeArray$[ebp+60], 15	; 0000000fH

; 378  : 				D3DMULTISAMPLE_16_SAMPLES,

	mov	DWORD PTR _msTypeArray$[ebp+64], 16	; 00000010H

; 379  : 		};
; 380  : 
; 381  : 		D3DMULTISAMPLE_TYPE msType;
; 382  : 		DWORD msQuality;
; 383  : 		for( UINT imst = 0; imst < ARRAY_ELEMENTS(msTypeArray); imst++ )

	mov	DWORD PTR _imst$128959[ebp], 0
	jmp	SHORT $LN4@BuildMulti
$LN3@BuildMulti:
	mov	eax, DWORD PTR _imst$128959[ebp]
	add	eax, 1
	mov	DWORD PTR _imst$128959[ebp], eax
$LN4@BuildMulti:
	cmp	DWORD PTR _imst$128959[ebp], 17		; 00000011H
	jae	SHORT $LN5@BuildMulti

; 384  : 		{
; 385  : 			msType = msTypeArray[imst];

	mov	ecx, DWORD PTR _imst$128959[ebp]
	mov	edx, DWORD PTR _msTypeArray$[ebp+ecx*4]
	mov	DWORD PTR _msType$[ebp], edx

; 386  : 			if (SUCCEEDED(m_pD3D->CheckDeviceMultiSampleType(pcombo->iadapter, pcombo->devtype, 
; 387  : 				pcombo->backbuffmt, pcombo->iswindowed, msType, &msQuality)))

	lea	eax, DWORD PTR _msQuality$[ebp]
	push	eax
	mov	ecx, DWORD PTR _msType$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pcombo$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR _pcombo$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR _pcombo$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR _pcombo$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+92]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+92]
	mov	edx, DWORD PTR [edx]
	push	ecx
	mov	eax, DWORD PTR [edx+44]
	call	eax
	test	eax, eax
	jl	SHORT $LN1@BuildMulti

; 388  : 			{
; 389  : 				pcombo->mstypes.push_back( msType );

	lea	ecx, DWORD PTR _msType$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pcombo$[ebp]
	add	ecx, 44					; 0000002cH
	call	?push_back@?$vector@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@QAEXABW4_D3DMULTISAMPLE_TYPE@@@Z ; std::vector<enum _D3DMULTISAMPLE_TYPE,std::allocator<enum _D3DMULTISAMPLE_TYPE> >::push_back

; 390  : 				pcombo->msqualitys.push_back( msQuality );

	mov	edx, DWORD PTR _msQuality$[ebp]
	mov	DWORD PTR $T141561[ebp], edx
	lea	eax, DWORD PTR $T141561[ebp]
	push	eax
	mov	ecx, DWORD PTR _pcombo$[ebp]
	add	ecx, 68					; 00000044H
	call	?push_back@?$vector@IV?$allocator@I@std@@@std@@QAEXABI@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::push_back
$LN1@BuildMulti:

; 391  : 			}

	jmp	SHORT $LN3@BuildMulti
$LN5@BuildMulti:

; 392  : 		}
; 393  : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
?BuildMultiSampleTypeList@D3DEnumeration@Ogre@@AAEXPAUD3DDEVCOMBO_T@2@@Z ENDP ; Ogre::D3DEnumeration::BuildMultiSampleTypeList
_TEXT	ENDS
PUBLIC	?push_back@?$vector@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@QAEXABUD3DSMSCONFLICT_T@Ogre@@@Z ; std::vector<Ogre::D3DSMSCONFLICT_T,std::allocator<Ogre::D3DSMSCONFLICT_T> >::push_back
PUBLIC	??A?$vector@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@QAEAAW4_D3DMULTISAMPLE_TYPE@@I@Z ; std::vector<enum _D3DMULTISAMPLE_TYPE,std::allocator<enum _D3DMULTISAMPLE_TYPE> >::operator[]
PUBLIC	?size@?$vector@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@QBEIXZ ; std::vector<enum _D3DMULTISAMPLE_TYPE,std::allocator<enum _D3DMULTISAMPLE_TYPE> >::size
; Function compile flags: /Odtp
_TEXT	SEGMENT
_this$ = -28						; size = 4
_msType$128980 = -24					; size = 4
_ims$128976 = -20					; size = 4
_dsFmt$128975 = -16					; size = 4
_ids$128971 = -12					; size = 4
_conflict$ = -8						; size = 8
_pcombo$ = 8						; size = 4
?BuildDSMSConflictList@D3DEnumeration@Ogre@@AAEXPAUD3DDEVCOMBO_T@2@@Z PROC ; Ogre::D3DEnumeration::BuildDSMSConflictList
; _this$ = ecx

; 397  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR _this$[ebp], ecx

; 398  : 		D3DSMSCONFLICT_T conflict;
; 399  : 
; 400  : 		for( SIZE_T ids = 0; ids < pcombo->dsfmts.size(); ids++ )

	mov	DWORD PTR _ids$128971[ebp], 0
	jmp	SHORT $LN7@BuildDSMSC
$LN6@BuildDSMSC:
	mov	eax, DWORD PTR _ids$128971[ebp]
	add	eax, 1
	mov	DWORD PTR _ids$128971[ebp], eax
$LN7@BuildDSMSC:
	mov	ecx, DWORD PTR _pcombo$[ebp]
	add	ecx, 20					; 00000014H
	call	?size@?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@QBEIXZ ; std::vector<enum _D3DFORMAT,std::allocator<enum _D3DFORMAT> >::size
	cmp	DWORD PTR _ids$128971[ebp], eax
	jae	$LN8@BuildDSMSC

; 401  : 		{
; 402  : 			D3DFORMAT dsFmt = pcombo->dsfmts[ids];

	mov	ecx, DWORD PTR _ids$128971[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pcombo$[ebp]
	add	ecx, 20					; 00000014H
	call	??A?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@QAEAAW4_D3DFORMAT@@I@Z ; std::vector<enum _D3DFORMAT,std::allocator<enum _D3DFORMAT> >::operator[]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR _dsFmt$128975[ebp], edx

; 403  : 			for( SIZE_T ims = 0; ims < pcombo->mstypes.size(); ims++ )

	mov	DWORD PTR _ims$128976[ebp], 0
	jmp	SHORT $LN4@BuildDSMSC
$LN3@BuildDSMSC:
	mov	eax, DWORD PTR _ims$128976[ebp]
	add	eax, 1
	mov	DWORD PTR _ims$128976[ebp], eax
$LN4@BuildDSMSC:
	mov	ecx, DWORD PTR _pcombo$[ebp]
	add	ecx, 44					; 0000002cH
	call	?size@?$vector@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@QBEIXZ ; std::vector<enum _D3DMULTISAMPLE_TYPE,std::allocator<enum _D3DMULTISAMPLE_TYPE> >::size
	cmp	DWORD PTR _ims$128976[ebp], eax
	jae	SHORT $LN2@BuildDSMSC

; 404  : 			{
; 405  : 				D3DMULTISAMPLE_TYPE msType = pcombo->mstypes[ims];

	mov	ecx, DWORD PTR _ims$128976[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pcombo$[ebp]
	add	ecx, 44					; 0000002cH
	call	??A?$vector@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@QAEAAW4_D3DMULTISAMPLE_TYPE@@I@Z ; std::vector<enum _D3DMULTISAMPLE_TYPE,std::allocator<enum _D3DMULTISAMPLE_TYPE> >::operator[]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR _msType$128980[ebp], edx

; 406  : 				if( FAILED( m_pD3D->CheckDeviceMultiSampleType( pcombo->iadapter, pcombo->devtype,
; 407  : 					dsFmt, pcombo->iswindowed, msType, NULL ) ) )

	push	0
	mov	eax, DWORD PTR _msType$128980[ebp]
	push	eax
	mov	ecx, DWORD PTR _pcombo$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR _dsFmt$128975[ebp]
	push	eax
	mov	ecx, DWORD PTR _pcombo$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR _pcombo$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+92]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+92]
	mov	eax, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR [eax+44]
	call	ecx
	test	eax, eax
	jge	SHORT $LN1@BuildDSMSC

; 408  : 				{
; 409  : 					conflict.dsfmt = dsFmt;

	mov	edx, DWORD PTR _dsFmt$128975[ebp]
	mov	DWORD PTR _conflict$[ebp], edx

; 410  : 					conflict.mstype = msType;

	mov	eax, DWORD PTR _msType$128980[ebp]
	mov	DWORD PTR _conflict$[ebp+4], eax

; 411  : 					pcombo->conflicts.push_back( conflict );

	lea	ecx, DWORD PTR _conflict$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pcombo$[ebp]
	add	ecx, 92					; 0000005cH
	call	?push_back@?$vector@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@QAEXABUD3DSMSCONFLICT_T@Ogre@@@Z ; std::vector<Ogre::D3DSMSCONFLICT_T,std::allocator<Ogre::D3DSMSCONFLICT_T> >::push_back
$LN1@BuildDSMSC:

; 412  : 				}
; 413  : 			}

	jmp	SHORT $LN3@BuildDSMSC
$LN2@BuildDSMSC:

; 414  : 		}

	jmp	$LN6@BuildDSMSC
$LN8@BuildDSMSC:

; 415  : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
?BuildDSMSConflictList@D3DEnumeration@Ogre@@AAEXPAUD3DDEVCOMBO_T@2@@Z ENDP ; Ogre::D3DEnumeration::BuildDSMSConflictList
_TEXT	ENDS
PUBLIC	?push_back@?$vector@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@QAEXABW4VERTPROCESS_T@Ogre@@@Z ; std::vector<enum Ogre::VERTPROCESS_T,std::allocator<enum Ogre::VERTPROCESS_T> >::push_back
PUBLIC	?ConfirmDevice@D3DEnumeration@Ogre@@AAEXPAUD3DDEVICEINFO_T@2@PAUD3DDEVCOMBO_T@2@W4VERTPROCESS_T@2@@Z ; Ogre::D3DEnumeration::ConfirmDevice
; Function compile flags: /Odtp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pdevice$ = 8						; size = 4
_pcombo$ = 12						; size = 4
_vpt$ = 16						; size = 4
?ConfirmDevice@D3DEnumeration@Ogre@@AAEXPAUD3DDEVICEINFO_T@2@PAUD3DDEVCOMBO_T@2@W4VERTPROCESS_T@2@@Z PROC ; Ogre::D3DEnumeration::ConfirmDevice
; _this$ = ecx

; 418  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 419  : 		if( m_ConfirmDeviceCallback && 
; 420  : 			m_ConfirmDeviceCallback(&pdevice->caps, vpt, pcombo->adapterfmt, pcombo->backbuffmt) )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+48], 0
	je	SHORT $LN2@ConfirmDev
	mov	ecx, DWORD PTR _pcombo$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR _pcombo$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _vpt$[ebp]
	push	edx
	mov	eax, DWORD PTR _pdevice$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+48]
	call	edx
	add	esp, 16					; 00000010H
	test	eax, eax
	je	SHORT $LN2@ConfirmDev

; 421  : 		{
; 422  : 			pcombo->vptypes.push_back( vpt );

	lea	eax, DWORD PTR _vpt$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pcombo$[ebp]
	add	ecx, 116				; 00000074H
	call	?push_back@?$vector@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@QAEXABW4VERTPROCESS_T@Ogre@@@Z ; std::vector<enum Ogre::VERTPROCESS_T,std::allocator<enum Ogre::VERTPROCESS_T> >::push_back
$LN2@ConfirmDev:

; 423  : 		}
; 424  : 	}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?ConfirmDevice@D3DEnumeration@Ogre@@AAEXPAUD3DDEVICEINFO_T@2@PAUD3DDEVCOMBO_T@2@W4VERTPROCESS_T@2@@Z ENDP ; Ogre::D3DEnumeration::ConfirmDevice
; Function compile flags: /Odtp
_this$ = -4						; size = 4
_pdevice$ = 8						; size = 4
_pcombo$ = 12						; size = 4
?BuildVertexProcessingTypeList@D3DEnumeration@Ogre@@AAEXPAUD3DDEVICEINFO_T@2@PAUD3DDEVCOMBO_T@2@@Z PROC ; Ogre::D3DEnumeration::BuildVertexProcessingTypeList
; _this$ = ecx

; 427  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 428  : 		if( (pdevice->caps.DevCaps & D3DDEVCAPS_HWTRANSFORMANDLIGHT) != 0 )

	mov	eax, DWORD PTR _pdevice$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	and	ecx, 65536				; 00010000H
	je	SHORT $LN3@BuildVerte

; 429  : 		{
; 430  : 			if( (pdevice->caps.DevCaps&D3DDEVCAPS_PUREDEVICE) != 0 ) ConfirmDevice( pdevice, pcombo, PURE_HARDWARE_VP );

	mov	edx, DWORD PTR _pdevice$[ebp]
	mov	eax, DWORD PTR [edx+36]
	and	eax, 1048576				; 00100000H
	je	SHORT $LN2@BuildVerte
	push	3
	mov	ecx, DWORD PTR _pcombo$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pdevice$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ConfirmDevice@D3DEnumeration@Ogre@@AAEXPAUD3DDEVICEINFO_T@2@PAUD3DDEVCOMBO_T@2@W4VERTPROCESS_T@2@@Z ; Ogre::D3DEnumeration::ConfirmDevice
$LN2@BuildVerte:

; 431  : 			ConfirmDevice( pdevice, pcombo, HARDWARE_VP );

	push	2
	mov	eax, DWORD PTR _pcombo$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pdevice$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ConfirmDevice@D3DEnumeration@Ogre@@AAEXPAUD3DDEVICEINFO_T@2@PAUD3DDEVCOMBO_T@2@W4VERTPROCESS_T@2@@Z ; Ogre::D3DEnumeration::ConfirmDevice

; 432  : 			if( m_UseMixedVP ) ConfirmDevice( pdevice, pcombo, MIXED_VP );

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+80], 0
	je	SHORT $LN3@BuildVerte
	push	1
	mov	eax, DWORD PTR _pcombo$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pdevice$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ConfirmDevice@D3DEnumeration@Ogre@@AAEXPAUD3DDEVICEINFO_T@2@PAUD3DDEVCOMBO_T@2@W4VERTPROCESS_T@2@@Z ; Ogre::D3DEnumeration::ConfirmDevice
$LN3@BuildVerte:

; 433  : 		}
; 434  : 		ConfirmDevice( pdevice, pcombo, SOFTWARE_VP );

	push	0
	mov	edx, DWORD PTR _pcombo$[ebp]
	push	edx
	mov	eax, DWORD PTR _pdevice$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?ConfirmDevice@D3DEnumeration@Ogre@@AAEXPAUD3DDEVICEINFO_T@2@PAUD3DDEVCOMBO_T@2@W4VERTPROCESS_T@2@@Z ; Ogre::D3DEnumeration::ConfirmDevice

; 435  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?BuildVertexProcessingTypeList@D3DEnumeration@Ogre@@AAEXPAUD3DDEVICEINFO_T@2@PAUD3DDEVCOMBO_T@2@@Z ENDP ; Ogre::D3DEnumeration::BuildVertexProcessingTypeList
; Function compile flags: /Odtp
_this$ = -36						; size = 4
_pi$129008 = -32					; size = 4
_ipi$129004 = -28					; size = 4
_piArray$ = -24						; size = 24
_pdevice$ = 8						; size = 4
_pcombo$ = 12						; size = 4
?BuildPresentIntervalList@D3DEnumeration@Ogre@@AAEXPAUD3DDEVICEINFO_T@2@PAUD3DDEVCOMBO_T@2@@Z PROC ; Ogre::D3DEnumeration::BuildPresentIntervalList
; _this$ = ecx

; 438  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	mov	DWORD PTR _this$[ebp], ecx

; 439  : 		const UINT piArray[] = { 
; 440  : 			D3DPRESENT_INTERVAL_IMMEDIATE,

	mov	DWORD PTR _piArray$[ebp], -2147483648	; 80000000H

; 441  : 				D3DPRESENT_INTERVAL_DEFAULT,

	mov	DWORD PTR _piArray$[ebp+4], 0

; 442  : 				D3DPRESENT_INTERVAL_ONE,

	mov	DWORD PTR _piArray$[ebp+8], 1

; 443  : 				D3DPRESENT_INTERVAL_TWO,

	mov	DWORD PTR _piArray$[ebp+12], 2

; 444  : 				D3DPRESENT_INTERVAL_THREE,

	mov	DWORD PTR _piArray$[ebp+16], 4

; 445  : 				D3DPRESENT_INTERVAL_FOUR,

	mov	DWORD PTR _piArray$[ebp+20], 8

; 446  : 		};
; 447  : 
; 448  : 		for( UINT ipi = 0; ipi < ARRAY_ELEMENTS(piArray); ipi++ )

	mov	DWORD PTR _ipi$129004[ebp], 0
	jmp	SHORT $LN8@BuildPrese
$LN7@BuildPrese:
	mov	eax, DWORD PTR _ipi$129004[ebp]
	add	eax, 1
	mov	DWORD PTR _ipi$129004[ebp], eax
$LN8@BuildPrese:
	cmp	DWORD PTR _ipi$129004[ebp], 6
	jae	SHORT $LN9@BuildPrese

; 449  : 		{
; 450  : 			UINT pi = piArray[ipi];

	mov	ecx, DWORD PTR _ipi$129004[ebp]
	mov	edx, DWORD PTR _piArray$[ebp+ecx*4]
	mov	DWORD PTR _pi$129008[ebp], edx

; 451  : 			if( pcombo->iswindowed )

	mov	eax, DWORD PTR _pcombo$[ebp]
	cmp	DWORD PTR [eax+16], 0
	je	SHORT $LN5@BuildPrese

; 452  : 			{
; 453  : 				if( pi == D3DPRESENT_INTERVAL_TWO ||
; 454  : 					pi == D3DPRESENT_INTERVAL_THREE ||
; 455  : 					pi == D3DPRESENT_INTERVAL_FOUR )

	cmp	DWORD PTR _pi$129008[ebp], 2
	je	SHORT $LN3@BuildPrese
	cmp	DWORD PTR _pi$129008[ebp], 4
	je	SHORT $LN3@BuildPrese
	cmp	DWORD PTR _pi$129008[ebp], 8
	jne	SHORT $LN5@BuildPrese
$LN3@BuildPrese:

; 456  : 				{
; 457  : 					// These intervals are not supported in windowed mode.
; 458  : 					continue;

	jmp	SHORT $LN7@BuildPrese
$LN5@BuildPrese:

; 459  : 				}
; 460  : 			}
; 461  : 			// Note that D3DPRESENT_INTERVAL_DEFAULT is zero, so you
; 462  : 			// can't do a caps check for it -- it is always available.
; 463  : 			if( pi == D3DPRESENT_INTERVAL_DEFAULT || (pdevice->caps.PresentationIntervals & pi) )

	cmp	DWORD PTR _pi$129008[ebp], 0
	je	SHORT $LN1@BuildPrese
	mov	ecx, DWORD PTR _pdevice$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	and	edx, DWORD PTR _pi$129008[ebp]
	je	SHORT $LN2@BuildPrese
$LN1@BuildPrese:

; 464  : 			{
; 465  : 				pcombo->intervals.push_back( pi );

	lea	eax, DWORD PTR _pi$129008[ebp]
	push	eax
	mov	ecx, DWORD PTR _pcombo$[ebp]
	add	ecx, 140				; 0000008cH
	call	?push_back@?$vector@IV?$allocator@I@std@@@std@@QAEXABI@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::push_back
$LN2@BuildPrese:

; 466  : 			}

	jmp	SHORT $LN7@BuildPrese
$LN9@BuildPrese:

; 467  : 		}
; 468  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?BuildPresentIntervalList@D3DEnumeration@Ogre@@AAEXPAUD3DDEVICEINFO_T@2@PAUD3DDEVCOMBO_T@2@@Z ENDP ; Ogre::D3DEnumeration::BuildPresentIntervalList
_TEXT	ENDS
PUBLIC	??$IsValueInArray@W4VERTPROCESS_T@Ogre@@@Ogre@@YA_NW4VERTPROCESS_T@0@AAV?$vector@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@@Z ; Ogre::IsValueInArray<enum Ogre::VERTPROCESS_T>
PUBLIC	?FindBestWindowMode@D3DEnumeration@Ogre@@AAEXABUInitDesc@RenderSystem@2@@Z ; Ogre::D3DEnumeration::FindBestWindowMode
PUBLIC	?FindBestFullscreenMode@D3DEnumeration@Ogre@@AAEXABUInitDesc@RenderSystem@2@@Z ; Ogre::D3DEnumeration::FindBestFullscreenMode
PUBLIC	?ChooseD3DSettings@D3DEnumeration@Ogre@@QAEABUD3DSETTING_T@2@ABUInitDesc@RenderSystem@2@@Z ; Ogre::D3DEnumeration::ChooseD3DSettings
EXTRN	__imp_?LogMessage@Ogre@@YAXPBDZZ:PROC
EXTRN	__imp_?LogSetCurParam@Ogre@@YAXPBDHI@Z:PROC
EXTRN	__imp__exit:PROC
EXTRN	__imp__MessageBoxA@16:PROC
; Function compile flags: /Odtp
_TEXT	SEGMENT
_this$ = -16						; size = 4
_pdevice$129032 = -12					; size = 4
_idev$129028 = -8					; size = 4
_brefrast$ = -1						; size = 1
_desc$ = 8						; size = 4
?ChooseD3DSettings@D3DEnumeration@Ogre@@QAEABUD3DSETTING_T@2@ABUInitDesc@RenderSystem@2@@Z PROC ; Ogre::D3DEnumeration::ChooseD3DSettings
; _this$ = ecx

; 481  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 482  : 		assert( desc.adapter < int(m_Adapters.size()) );
; 483  : 		m_Settings.padapter = m_Adapters[desc.adapter];

	mov	eax, DWORD PTR _desc$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	??A?$vector@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@QAEAAPAUD3DADAPTER_T@Ogre@@I@Z ; std::vector<Ogre::D3DADAPTER_T *,std::allocator<Ogre::D3DADAPTER_T *> >::operator[]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx+96], eax

; 484  : 
; 485  : 		bool brefrast = desc.brefrast;

	mov	ecx, DWORD PTR _desc$[ebp]
	mov	dl, BYTE PTR [ecx+4]
	mov	BYTE PTR _brefrast$[ebp], dl

; 486  : 		if(desc.debug_ps) brefrast = true;

	mov	eax, DWORD PTR _desc$[ebp]
	movzx	ecx, BYTE PTR [eax+8]
	test	ecx, ecx
	je	SHORT $LN16@ChooseD3DS
	mov	BYTE PTR _brefrast$[ebp], 1
$LN16@ChooseD3DS:

; 487  : 
; 488  : 		for( SIZE_T idev=0; idev<m_Settings.padapter->devinfo.size(); idev++ )

	mov	DWORD PTR _idev$129028[ebp], 0
	jmp	SHORT $LN15@ChooseD3DS
$LN14@ChooseD3DS:
	mov	edx, DWORD PTR _idev$129028[ebp]
	add	edx, 1
	mov	DWORD PTR _idev$129028[ebp], edx
$LN15@ChooseD3DS:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+96]
	add	ecx, 1128				; 00000468H
	call	?size@?$vector@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::D3DDEVICEINFO_T *,std::allocator<Ogre::D3DDEVICEINFO_T *> >::size
	cmp	DWORD PTR _idev$129028[ebp], eax
	jae	SHORT $LN13@ChooseD3DS

; 489  : 		{
; 490  : 			D3DDEVICEINFO_T *pdevice = m_Settings.padapter->devinfo[idev];

	mov	ecx, DWORD PTR _idev$129028[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+96]
	add	ecx, 1128				; 00000468H
	call	??A?$vector@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@QAEAAPAUD3DDEVICEINFO_T@Ogre@@I@Z ; std::vector<Ogre::D3DDEVICEINFO_T *,std::allocator<Ogre::D3DDEVICEINFO_T *> >::operator[]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR _pdevice$129032[ebp], eax

; 491  : 			if( brefrast && pdevice->type==D3DDEVTYPE_REF ||
; 492  : 				!brefrast && pdevice->type==D3DDEVTYPE_HAL )

	movzx	ecx, BYTE PTR _brefrast$[ebp]
	test	ecx, ecx
	je	SHORT $LN10@ChooseD3DS
	mov	edx, DWORD PTR _pdevice$129032[ebp]
	cmp	DWORD PTR [edx+4], 2
	je	SHORT $LN11@ChooseD3DS
$LN10@ChooseD3DS:
	movzx	eax, BYTE PTR _brefrast$[ebp]
	test	eax, eax
	jne	SHORT $LN12@ChooseD3DS
	mov	ecx, DWORD PTR _pdevice$129032[ebp]
	cmp	DWORD PTR [ecx+4], 1
	jne	SHORT $LN12@ChooseD3DS
$LN11@ChooseD3DS:

; 493  : 			{
; 494  : 				m_Settings.pdevice = pdevice;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _pdevice$129032[ebp]
	mov	DWORD PTR [edx+100], eax

; 495  : 				break;

	jmp	SHORT $LN13@ChooseD3DS
$LN12@ChooseD3DS:

; 496  : 			}
; 497  : 		}

	jmp	SHORT $LN14@ChooseD3DS
$LN13@ChooseD3DS:

; 498  : 
; 499  : 		if(m_Settings.pdevice == NULL)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+100], 0
	jne	SHORT $LN9@ChooseD3DS

; 500  : 		{
; 501  : 			MessageBox((HWND)desc.hwnd, "3DDirectX9.0c", "", MB_OK);

	push	0
	push	OFFSET $SG129038
	push	OFFSET $SG129039
	mov	edx, DWORD PTR _desc$[ebp]
	mov	eax, DWORD PTR [edx+40]
	push	eax
	call	DWORD PTR __imp__MessageBoxA@16

; 502  : 			exit(3);

	push	3
	call	DWORD PTR __imp__exit
$LN9@ChooseD3DS:

; 503  : 		}
; 504  : 
; 505  : 		if( desc.bfullscreen ) 

	mov	ecx, DWORD PTR _desc$[ebp]
	movzx	edx, BYTE PTR [ecx+5]
	test	edx, edx
	je	SHORT $LN8@ChooseD3DS

; 506  : 			FindBestFullscreenMode( desc );

	mov	eax, DWORD PTR _desc$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FindBestFullscreenMode@D3DEnumeration@Ogre@@AAEXABUInitDesc@RenderSystem@2@@Z ; Ogre::D3DEnumeration::FindBestFullscreenMode

; 507  : 		else 

	jmp	SHORT $LN7@ChooseD3DS
$LN8@ChooseD3DS:

; 508  : 			FindBestWindowMode( desc );

	mov	ecx, DWORD PTR _desc$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?FindBestWindowMode@D3DEnumeration@Ogre@@AAEXABUInitDesc@RenderSystem@2@@Z ; Ogre::D3DEnumeration::FindBestWindowMode
$LN7@ChooseD3DS:

; 509  : 
; 510  : 		if(desc.debug_vs) m_Settings.vptype = SOFTWARE_VP;

	mov	edx, DWORD PTR _desc$[ebp]
	movzx	eax, BYTE PTR [edx+7]
	test	eax, eax
	je	SHORT $LN6@ChooseD3DS
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+120], 0

; 511  : 		else

	jmp	SHORT $LN5@ChooseD3DS
$LN6@ChooseD3DS:

; 512  : 		{
; 513  : 			if(IsValueInArray(PURE_HARDWARE_VP, m_Settings.pdevcombo->vptypes)) m_Settings.vptype = PURE_HARDWARE_VP;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+104]
	add	eax, 116				; 00000074H
	push	eax
	push	3
	call	??$IsValueInArray@W4VERTPROCESS_T@Ogre@@@Ogre@@YA_NW4VERTPROCESS_T@0@AAV?$vector@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@@Z ; Ogre::IsValueInArray<enum Ogre::VERTPROCESS_T>
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN4@ChooseD3DS
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+120], 3
	jmp	SHORT $LN5@ChooseD3DS
$LN4@ChooseD3DS:

; 514  : 			else if(IsValueInArray(HARDWARE_VP, m_Settings.pdevcombo->vptypes)) m_Settings.vptype = HARDWARE_VP;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+104]
	add	ecx, 116				; 00000074H
	push	ecx
	push	2
	call	??$IsValueInArray@W4VERTPROCESS_T@Ogre@@@Ogre@@YA_NW4VERTPROCESS_T@0@AAV?$vector@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@@Z ; Ogre::IsValueInArray<enum Ogre::VERTPROCESS_T>
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN2@ChooseD3DS
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+120], 2
	jmp	SHORT $LN5@ChooseD3DS
$LN2@ChooseD3DS:

; 515  : 			else m_Settings.vptype = SOFTWARE_VP;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+120], 0
$LN5@ChooseD3DS:

; 516  : 		}
; 517  : 
; 518  : 		LOG_INFO("Choose D3DSettings: dispmode=(%d,%d,%d), dsformat=%d, interval=%d, msquality=%d, mstype=%d, vptype=%d", m_Settings.dispmode.Format, m_Settings.dispmode.Width, m_Settings.dispmode.Height, 
; 519  : 			m_Settings.dsformat, m_Settings.interval, m_Settings.msquality, m_Settings.mstype, m_Settings.vptype);

	push	2
	push	518					; 00000206H
	push	OFFSET $SG129057
	call	DWORD PTR __imp_?LogSetCurParam@Ogre@@YAXPBDHI@Z
	add	esp, 12					; 0000000cH
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+120]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+112]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+116]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+124]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+108]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+132]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+128]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+140]
	push	edx
	push	OFFSET $SG129058
	call	DWORD PTR __imp_?LogMessage@Ogre@@YAXPBDZZ
	add	esp, 36					; 00000024H

; 520  : 		return m_Settings;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 96					; 00000060H
$LN18@ChooseD3DS:

; 521  : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
?ChooseD3DSettings@D3DEnumeration@Ogre@@QAEABUD3DSETTING_T@2@ABUInitDesc@RenderSystem@2@@Z ENDP ; Ogre::D3DEnumeration::ChooseD3DSettings
_TEXT	ENDS
PUBLIC	?MultiSampleConvert@Ogre@@YA?AW4_D3DMULTISAMPLE_TYPE@@H@Z ; Ogre::MultiSampleConvert
; Function compile flags: /Odtp
_TEXT	SEGMENT
_mstype$ = -4						; size = 4
_multisample$ = 8					; size = 4
?MultiSampleConvert@Ogre@@YA?AW4_D3DMULTISAMPLE_TYPE@@H@Z PROC ; Ogre::MultiSampleConvert

; 589  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 590  : 		D3DMULTISAMPLE_TYPE mstype;
; 591  : 
; 592  : 		if(multisample == 1) mstype = D3DMULTISAMPLE_2_SAMPLES;

	cmp	DWORD PTR _multisample$[ebp], 1
	jne	SHORT $LN8@MultiSampl
	mov	DWORD PTR _mstype$[ebp], 2
	jmp	SHORT $LN7@MultiSampl
$LN8@MultiSampl:

; 593  : 		else if(multisample == 2) mstype = D3DMULTISAMPLE_4_SAMPLES;

	cmp	DWORD PTR _multisample$[ebp], 2
	jne	SHORT $LN6@MultiSampl
	mov	DWORD PTR _mstype$[ebp], 4
	jmp	SHORT $LN7@MultiSampl
$LN6@MultiSampl:

; 594  : 		else if(multisample == 3) mstype = D3DMULTISAMPLE_8_SAMPLES;

	cmp	DWORD PTR _multisample$[ebp], 3
	jne	SHORT $LN4@MultiSampl
	mov	DWORD PTR _mstype$[ebp], 8
	jmp	SHORT $LN7@MultiSampl
$LN4@MultiSampl:

; 595  : 		else if(multisample == 4) mstype = D3DMULTISAMPLE_16_SAMPLES;

	cmp	DWORD PTR _multisample$[ebp], 4
	jne	SHORT $LN2@MultiSampl
	mov	DWORD PTR _mstype$[ebp], 16		; 00000010H
	jmp	SHORT $LN7@MultiSampl
$LN2@MultiSampl:

; 596  : 		else mstype = D3DMULTISAMPLE_NONE;

	mov	DWORD PTR _mstype$[ebp], 0
$LN7@MultiSampl:

; 597  : 
; 598  : 		return mstype;

	mov	eax, DWORD PTR _mstype$[ebp]

; 599  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?MultiSampleConvert@Ogre@@YA?AW4_D3DMULTISAMPLE_TYPE@@H@Z ENDP ; Ogre::MultiSampleConvert
_TEXT	ENDS
PUBLIC	?GetRenderTargetFormat@D3DEnumeration@Ogre@@QAE_NAAW4_D3DFORMAT@@AAW4_D3DMULTISAMPLE_TYPE@@W43@HHH@Z ; Ogre::D3DEnumeration::GetRenderTargetFormat
; Function compile flags: /Odtp
_TEXT	SEGMENT
_this$ = -16						; size = 4
_pcombo$129163 = -12					; size = 4
_icombo$129159 = -8					; size = 4
_pbestcombo$ = -4					; size = 4
_dsfmt$ = 8						; size = 4
_mstype$ = 12						; size = 4
_colorfmt$ = 16						; size = 4
_depthbits$ = 20					; size = 4
_stencilbits$ = 24					; size = 4
_multisample$ = 28					; size = 4
?GetRenderTargetFormat@D3DEnumeration@Ogre@@QAE_NAAW4_D3DFORMAT@@AAW4_D3DMULTISAMPLE_TYPE@@W43@HHH@Z PROC ; Ogre::D3DEnumeration::GetRenderTargetFormat
; _this$ = ecx

; 632  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 633  : 		D3DDEVCOMBO_T *pbestcombo = NULL;

	mov	DWORD PTR _pbestcombo$[ebp], 0

; 634  : 		for( SIZE_T icombo=0; icombo<m_Settings.pdevice->devcombo.size(); icombo++ )

	mov	DWORD PTR _icombo$129159[ebp], 0
	jmp	SHORT $LN9@GetRenderT
$LN8@GetRenderT:
	mov	eax, DWORD PTR _icombo$129159[ebp]
	add	eax, 1
	mov	DWORD PTR _icombo$129159[ebp], eax
$LN9@GetRenderT:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+100]
	add	ecx, 312				; 00000138H
	call	?size@?$vector@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::D3DDEVCOMBO_T *,std::allocator<Ogre::D3DDEVCOMBO_T *> >::size
	cmp	DWORD PTR _icombo$129159[ebp], eax
	jae	SHORT $LN7@GetRenderT

; 635  : 		{
; 636  : 			D3DDEVCOMBO_T *pcombo = m_Settings.pdevice->devcombo[icombo];

	mov	edx, DWORD PTR _icombo$129159[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+100]
	add	ecx, 312				; 00000138H
	call	??A?$vector@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@QAEAAPAUD3DDEVCOMBO_T@Ogre@@I@Z ; std::vector<Ogre::D3DDEVCOMBO_T *,std::allocator<Ogre::D3DDEVCOMBO_T *> >::operator[]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _pcombo$129163[ebp], ecx

; 637  : 			if( !pcombo->iswindowed ) continue;

	mov	edx, DWORD PTR _pcombo$129163[ebp]
	cmp	DWORD PTR [edx+16], 0
	jne	SHORT $LN6@GetRenderT
	jmp	SHORT $LN8@GetRenderT
$LN6@GetRenderT:

; 638  : 			if(pcombo->adapterfmt != colorfmt) continue;

	mov	eax, DWORD PTR _pcombo$129163[ebp]
	mov	ecx, DWORD PTR [eax+8]
	cmp	ecx, DWORD PTR _colorfmt$[ebp]
	je	SHORT $LN5@GetRenderT
	jmp	SHORT $LN8@GetRenderT
$LN5@GetRenderT:

; 639  : 
; 640  : 			if( pbestcombo == NULL ) pbestcombo = pcombo;

	cmp	DWORD PTR _pbestcombo$[ebp], 0
	jne	SHORT $LN4@GetRenderT
	mov	edx, DWORD PTR _pcombo$129163[ebp]
	mov	DWORD PTR _pbestcombo$[ebp], edx
	jmp	SHORT $LN3@GetRenderT
$LN4@GetRenderT:

; 641  : 			else if( pcombo->adapterfmt == pcombo->backbuffmt )

	mov	eax, DWORD PTR _pcombo$129163[ebp]
	mov	ecx, DWORD PTR _pcombo$129163[ebp]
	mov	edx, DWORD PTR [eax+8]
	cmp	edx, DWORD PTR [ecx+12]
	jne	SHORT $LN3@GetRenderT

; 642  : 			{
; 643  : 				pbestcombo = pcombo;

	mov	eax, DWORD PTR _pcombo$129163[ebp]
	mov	DWORD PTR _pbestcombo$[ebp], eax

; 644  : 				break;

	jmp	SHORT $LN7@GetRenderT
$LN3@GetRenderT:

; 645  : 			}
; 646  : 		}

	jmp	SHORT $LN8@GetRenderT
$LN7@GetRenderT:

; 647  : 
; 648  : 		if(pbestcombo == NULL) return false;

	cmp	DWORD PTR _pbestcombo$[ebp], 0
	jne	SHORT $LN1@GetRenderT
	xor	al, al
	jmp	SHORT $LN10@GetRenderT
$LN1@GetRenderT:

; 649  : 
; 650  : 		GetBestDSFmtAndMSType(dsfmt, mstype, pbestcombo, depthbits, stencilbits, multisample);

	mov	ecx, DWORD PTR _multisample$[ebp]
	push	ecx
	mov	edx, DWORD PTR _stencilbits$[ebp]
	push	edx
	mov	eax, DWORD PTR _depthbits$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pbestcombo$[ebp]
	push	ecx
	mov	edx, DWORD PTR _mstype$[ebp]
	push	edx
	mov	eax, DWORD PTR _dsfmt$[ebp]
	push	eax
	call	?GetBestDSFmtAndMSType@Ogre@@YAXAAW4_D3DFORMAT@@AAW4_D3DMULTISAMPLE_TYPE@@PAUD3DDEVCOMBO_T@1@HHH@Z ; Ogre::GetBestDSFmtAndMSType
	add	esp, 24					; 00000018H

; 651  : 		return true;

	mov	al, 1
$LN10@GetRenderT:

; 652  : 	}

	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
?GetRenderTargetFormat@D3DEnumeration@Ogre@@QAE_NAAW4_D3DFORMAT@@AAW4_D3DMULTISAMPLE_TYPE@@W43@HHH@Z ENDP ; Ogre::D3DEnumeration::GetRenderTargetFormat
_TEXT	ENDS
PUBLIC	??$IsValueInArray@W4_D3DMULTISAMPLE_TYPE@@@Ogre@@YA_NW4_D3DMULTISAMPLE_TYPE@@AAV?$vector@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@@Z ; Ogre::IsValueInArray<enum _D3DMULTISAMPLE_TYPE>
; Function compile flags: /Odtp
_TEXT	SEGMENT
_dsfmt$ = 8						; size = 4
_mstype$ = 12						; size = 4
_pcombo$ = 16						; size = 4
_depthbits$ = 20					; size = 4
_stencilbits$ = 24					; size = 4
_multisample$ = 28					; size = 4
?GetBestDSFmtAndMSType@Ogre@@YAXAAW4_D3DFORMAT@@AAW4_D3DMULTISAMPLE_TYPE@@PAUD3DDEVCOMBO_T@1@HHH@Z PROC ; Ogre::GetBestDSFmtAndMSType

; 602  : 	{

	push	ebp
	mov	ebp, esp
$LN13@GetBestDSF:

; 603  : 		while(multisample > 0)

	cmp	DWORD PTR _multisample$[ebp], 0
	jle	SHORT $LN10@GetBestDSF

; 604  : 		{
; 605  : 			mstype = MultiSampleConvert(multisample);

	mov	eax, DWORD PTR _multisample$[ebp]
	push	eax
	call	?MultiSampleConvert@Ogre@@YA?AW4_D3DMULTISAMPLE_TYPE@@H@Z ; Ogre::MultiSampleConvert
	add	esp, 4
	mov	ecx, DWORD PTR _mstype$[ebp]
	mov	DWORD PTR [ecx], eax

; 606  : 			if(IsValueInArray(mstype, pcombo->mstypes)) break;

	mov	edx, DWORD PTR _pcombo$[ebp]
	add	edx, 44					; 0000002cH
	push	edx
	mov	eax, DWORD PTR _mstype$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	??$IsValueInArray@W4_D3DMULTISAMPLE_TYPE@@@Ogre@@YA_NW4_D3DMULTISAMPLE_TYPE@@AAV?$vector@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@@Z ; Ogre::IsValueInArray<enum _D3DMULTISAMPLE_TYPE>
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN11@GetBestDSF
	jmp	SHORT $LN10@GetBestDSF
$LN11@GetBestDSF:

; 607  : 			multisample--;

	mov	eax, DWORD PTR _multisample$[ebp]
	sub	eax, 1
	mov	DWORD PTR _multisample$[ebp], eax

; 608  : 		}

	jmp	SHORT $LN13@GetBestDSF
$LN10@GetBestDSF:

; 609  : 
; 610  : 		for(;;)
; 611  : 		{
; 612  : 			dsfmt = GetProperDSFmt(mstype, pcombo, depthbits, stencilbits);

	mov	ecx, DWORD PTR _stencilbits$[ebp]
	push	ecx
	mov	edx, DWORD PTR _depthbits$[ebp]
	push	edx
	mov	eax, DWORD PTR _pcombo$[ebp]
	push	eax
	mov	ecx, DWORD PTR _mstype$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	?GetProperDSFmt@Ogre@@YA?AW4_D3DFORMAT@@W4_D3DMULTISAMPLE_TYPE@@PAUD3DDEVCOMBO_T@1@HH@Z ; Ogre::GetProperDSFmt
	add	esp, 16					; 00000010H
	mov	ecx, DWORD PTR _dsfmt$[ebp]
	mov	DWORD PTR [ecx], eax

; 613  : 			if(dsfmt == D3DFMT_UNKNOWN)

	mov	edx, DWORD PTR _dsfmt$[ebp]
	cmp	DWORD PTR [edx], 0
	jne	SHORT $LN8@GetBestDSF

; 614  : 			{
; 615  : 				if(depthbits == 32) 

	cmp	DWORD PTR _depthbits$[ebp], 32		; 00000020H
	jne	SHORT $LN7@GetBestDSF

; 616  : 					depthbits = 24;

	mov	DWORD PTR _depthbits$[ebp], 24		; 00000018H
	jmp	SHORT $LN6@GetBestDSF
$LN7@GetBestDSF:

; 617  : 				else if(depthbits == 24) 

	cmp	DWORD PTR _depthbits$[ebp], 24		; 00000018H
	jne	SHORT $LN5@GetBestDSF

; 618  : 					depthbits = 16;

	mov	DWORD PTR _depthbits$[ebp], 16		; 00000010H
	jmp	SHORT $LN6@GetBestDSF
$LN5@GetBestDSF:

; 619  : 				else if(mstype != D3DMULTISAMPLE_NONE)

	mov	eax, DWORD PTR _mstype$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN3@GetBestDSF

; 620  : 					mstype = D3DMULTISAMPLE_NONE;

	mov	ecx, DWORD PTR _mstype$[ebp]
	mov	DWORD PTR [ecx], 0

; 621  : 				else

	jmp	SHORT $LN6@GetBestDSF
$LN3@GetBestDSF:

; 622  : 				{
; 623  : 					dsfmt = D3DFMT_D16;

	mov	edx, DWORD PTR _dsfmt$[ebp]
	mov	DWORD PTR [edx], 80			; 00000050H

; 624  : 					break;

	jmp	SHORT $LN14@GetBestDSF
$LN6@GetBestDSF:

; 625  : 				}

	jmp	SHORT $LN1@GetBestDSF
$LN8@GetBestDSF:

; 626  : 			}
; 627  : 			else break;

	jmp	SHORT $LN14@GetBestDSF
$LN1@GetBestDSF:
	jmp	SHORT $LN10@GetBestDSF
$LN14@GetBestDSF:

; 628  : 		}
; 629  : 	}

	pop	ebp
	ret	0
?GetBestDSFmtAndMSType@Ogre@@YAXAAW4_D3DFORMAT@@AAW4_D3DMULTISAMPLE_TYPE@@PAUD3DDEVCOMBO_T@1@HHH@Z ENDP ; Ogre::GetBestDSFmtAndMSType
; Function compile flags: /Odtp
_fmt$129082 = -16					; size = 4
_i$129078 = -12						; size = 4
_bestfmt$ = -8						; size = 4
_okfmt$ = -4						; size = 4
_mstype$ = 8						; size = 4
_pcombo$ = 12						; size = 4
_depthbits$ = 16					; size = 4
_stencilbits$ = 20					; size = 4
?GetProperDSFmt@Ogre@@YA?AW4_D3DFORMAT@@W4_D3DMULTISAMPLE_TYPE@@PAUD3DDEVCOMBO_T@1@HH@Z PROC ; Ogre::GetProperDSFmt

; 533  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 534  : 		D3DFORMAT bestfmt = D3DFMT_UNKNOWN;

	mov	DWORD PTR _bestfmt$[ebp], 0

; 535  : 		D3DFORMAT okfmt = D3DFMT_UNKNOWN;

	mov	DWORD PTR _okfmt$[ebp], 0

; 536  : 
; 537  : 		for(size_t i=0; i<pcombo->dsfmts.size(); i++)

	mov	DWORD PTR _i$129078[ebp], 0
	jmp	SHORT $LN25@GetProperD
$LN24@GetProperD:
	mov	eax, DWORD PTR _i$129078[ebp]
	add	eax, 1
	mov	DWORD PTR _i$129078[ebp], eax
$LN25@GetProperD:
	mov	ecx, DWORD PTR _pcombo$[ebp]
	add	ecx, 20					; 00000014H
	call	?size@?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@QBEIXZ ; std::vector<enum _D3DFORMAT,std::allocator<enum _D3DFORMAT> >::size
	cmp	DWORD PTR _i$129078[ebp], eax
	jae	$LN23@GetProperD

; 538  : 		{
; 539  : 			D3DFORMAT fmt = pcombo->dsfmts[i];

	mov	ecx, DWORD PTR _i$129078[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pcombo$[ebp]
	add	ecx, 20					; 00000014H
	call	??A?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@QAEAAW4_D3DFORMAT@@I@Z ; std::vector<enum _D3DFORMAT,std::allocator<enum _D3DFORMAT> >::operator[]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR _fmt$129082[ebp], edx

; 540  : 			if(IsConflicted(mstype, fmt, pcombo)) continue;

	mov	eax, DWORD PTR _pcombo$[ebp]
	push	eax
	mov	ecx, DWORD PTR _fmt$129082[ebp]
	push	ecx
	mov	edx, DWORD PTR _mstype$[ebp]
	push	edx
	call	?IsConflicted@Ogre@@YA_NW4_D3DMULTISAMPLE_TYPE@@W4_D3DFORMAT@@PAUD3DDEVCOMBO_T@1@@Z ; Ogre::IsConflicted
	add	esp, 12					; 0000000cH
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN22@GetProperD
	jmp	SHORT $LN24@GetProperD
$LN22@GetProperD:

; 541  : 
; 542  : 			if(fmt == D3DFMT_D16)

	cmp	DWORD PTR _fmt$129082[ebp], 80		; 00000050H
	jne	SHORT $LN21@GetProperD

; 543  : 			{
; 544  : 				if(stencilbits == 0)

	cmp	DWORD PTR _stencilbits$[ebp], 0
	jne	SHORT $LN20@GetProperD

; 545  : 				{
; 546  : 					if(depthbits == 16) bestfmt = fmt;

	cmp	DWORD PTR _depthbits$[ebp], 16		; 00000010H
	jne	SHORT $LN19@GetProperD
	mov	ecx, DWORD PTR _fmt$129082[ebp]
	mov	DWORD PTR _bestfmt$[ebp], ecx
$LN19@GetProperD:

; 547  : 					okfmt = fmt;

	mov	edx, DWORD PTR _fmt$129082[ebp]
	mov	DWORD PTR _okfmt$[ebp], edx
$LN20@GetProperD:

; 548  : 				}
; 549  : 			}

	jmp	SHORT $LN18@GetProperD
$LN21@GetProperD:

; 550  : 			else if(fmt == D3DFMT_D32)

	cmp	DWORD PTR _fmt$129082[ebp], 71		; 00000047H
	jne	SHORT $LN17@GetProperD

; 551  : 			{
; 552  : 				if(stencilbits==0)

	cmp	DWORD PTR _stencilbits$[ebp], 0
	jne	SHORT $LN16@GetProperD

; 553  : 				{
; 554  : 					if(depthbits == 32) bestfmt = fmt;

	cmp	DWORD PTR _depthbits$[ebp], 32		; 00000020H
	jne	SHORT $LN15@GetProperD
	mov	eax, DWORD PTR _fmt$129082[ebp]
	mov	DWORD PTR _bestfmt$[ebp], eax
$LN15@GetProperD:

; 555  : 					okfmt = fmt;

	mov	ecx, DWORD PTR _fmt$129082[ebp]
	mov	DWORD PTR _okfmt$[ebp], ecx
$LN16@GetProperD:

; 556  : 				}
; 557  : 			}

	jmp	SHORT $LN18@GetProperD
$LN17@GetProperD:

; 558  : 			else if(fmt == D3DFMT_D15S1)

	cmp	DWORD PTR _fmt$129082[ebp], 73		; 00000049H
	jne	SHORT $LN13@GetProperD

; 559  : 			{
; 560  : 				if(stencilbits == 1)

	cmp	DWORD PTR _stencilbits$[ebp], 1
	jne	SHORT $LN12@GetProperD

; 561  : 				{
; 562  : 					if(depthbits == 16) bestfmt = fmt;

	cmp	DWORD PTR _depthbits$[ebp], 16		; 00000010H
	jne	SHORT $LN11@GetProperD
	mov	edx, DWORD PTR _fmt$129082[ebp]
	mov	DWORD PTR _bestfmt$[ebp], edx
$LN11@GetProperD:

; 563  : 					okfmt = fmt;

	mov	eax, DWORD PTR _fmt$129082[ebp]
	mov	DWORD PTR _okfmt$[ebp], eax
$LN12@GetProperD:

; 564  : 				}
; 565  : 			}

	jmp	SHORT $LN18@GetProperD
$LN13@GetProperD:

; 566  : 			else if(fmt == D3DFMT_D24S8)

	cmp	DWORD PTR _fmt$129082[ebp], 75		; 0000004bH
	jne	SHORT $LN9@GetProperD

; 567  : 			{
; 568  : 				if(stencilbits == 8)

	cmp	DWORD PTR _stencilbits$[ebp], 8
	jne	SHORT $LN8@GetProperD

; 569  : 				{
; 570  : 					if(depthbits == 24) bestfmt = fmt;

	cmp	DWORD PTR _depthbits$[ebp], 24		; 00000018H
	jne	SHORT $LN7@GetProperD
	mov	ecx, DWORD PTR _fmt$129082[ebp]
	mov	DWORD PTR _bestfmt$[ebp], ecx
$LN7@GetProperD:

; 571  : 					okfmt = fmt;

	mov	edx, DWORD PTR _fmt$129082[ebp]
	mov	DWORD PTR _okfmt$[ebp], edx
$LN8@GetProperD:

; 572  : 				}
; 573  : 			}

	jmp	SHORT $LN18@GetProperD
$LN9@GetProperD:

; 574  : 			else if(fmt == D3DFMT_D24X8)

	cmp	DWORD PTR _fmt$129082[ebp], 77		; 0000004dH
	jne	SHORT $LN18@GetProperD

; 575  : 			{
; 576  : 				if(stencilbits == 0)

	cmp	DWORD PTR _stencilbits$[ebp], 0
	jne	SHORT $LN18@GetProperD

; 577  : 				{
; 578  : 					if(depthbits == 24) bestfmt = fmt;

	cmp	DWORD PTR _depthbits$[ebp], 24		; 00000018H
	jne	SHORT $LN3@GetProperD
	mov	eax, DWORD PTR _fmt$129082[ebp]
	mov	DWORD PTR _bestfmt$[ebp], eax
$LN3@GetProperD:

; 579  : 					okfmt = fmt;

	mov	ecx, DWORD PTR _fmt$129082[ebp]
	mov	DWORD PTR _okfmt$[ebp], ecx
$LN18@GetProperD:

; 580  : 				}
; 581  : 			}
; 582  : 		}

	jmp	$LN24@GetProperD
$LN23@GetProperD:

; 583  : 
; 584  : 		if(bestfmt != D3DFMT_UNKNOWN) return bestfmt;

	cmp	DWORD PTR _bestfmt$[ebp], 0
	je	SHORT $LN2@GetProperD
	mov	eax, DWORD PTR _bestfmt$[ebp]
	jmp	SHORT $LN26@GetProperD
	jmp	SHORT $LN26@GetProperD
$LN2@GetProperD:

; 585  : 		else return okfmt;

	mov	eax, DWORD PTR _okfmt$[ebp]
$LN26@GetProperD:

; 586  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?GetProperDSFmt@Ogre@@YA?AW4_D3DFORMAT@@W4_D3DMULTISAMPLE_TYPE@@PAUD3DDEVCOMBO_T@1@HH@Z ENDP ; Ogre::GetProperDSFmt
_TEXT	ENDS
PUBLIC	??A?$vector@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@QAEAAUD3DSMSCONFLICT_T@Ogre@@I@Z ; std::vector<Ogre::D3DSMSCONFLICT_T,std::allocator<Ogre::D3DSMSCONFLICT_T> >::operator[]
PUBLIC	?size@?$vector@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::D3DSMSCONFLICT_T,std::allocator<Ogre::D3DSMSCONFLICT_T> >::size
; Function compile flags: /Odtp
_TEXT	SEGMENT
_obj$129068 = -8					; size = 4
_i$129064 = -4						; size = 4
_mstype$ = 8						; size = 4
_dsfmt$ = 12						; size = 4
_pcombo$ = 16						; size = 4
?IsConflicted@Ogre@@YA_NW4_D3DMULTISAMPLE_TYPE@@W4_D3DFORMAT@@PAUD3DDEVCOMBO_T@1@@Z PROC ; Ogre::IsConflicted

; 524  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 525  : 		for(size_t i=0; i<pcombo->conflicts.size(); i++)

	mov	DWORD PTR _i$129064[ebp], 0
	jmp	SHORT $LN4@IsConflict
$LN3@IsConflict:
	mov	eax, DWORD PTR _i$129064[ebp]
	add	eax, 1
	mov	DWORD PTR _i$129064[ebp], eax
$LN4@IsConflict:
	mov	ecx, DWORD PTR _pcombo$[ebp]
	add	ecx, 92					; 0000005cH
	call	?size@?$vector@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::D3DSMSCONFLICT_T,std::allocator<Ogre::D3DSMSCONFLICT_T> >::size
	cmp	DWORD PTR _i$129064[ebp], eax
	jae	SHORT $LN2@IsConflict

; 526  : 		{
; 527  : 			D3DSMSCONFLICT_T &obj = pcombo->conflicts[i];

	mov	ecx, DWORD PTR _i$129064[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pcombo$[ebp]
	add	ecx, 92					; 0000005cH
	call	??A?$vector@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@QAEAAUD3DSMSCONFLICT_T@Ogre@@I@Z ; std::vector<Ogre::D3DSMSCONFLICT_T,std::allocator<Ogre::D3DSMSCONFLICT_T> >::operator[]
	mov	DWORD PTR _obj$129068[ebp], eax

; 528  : 			if(mstype==obj.mstype && dsfmt==obj.dsfmt) return true;

	mov	edx, DWORD PTR _obj$129068[ebp]
	mov	eax, DWORD PTR _mstype$[ebp]
	cmp	eax, DWORD PTR [edx+4]
	jne	SHORT $LN1@IsConflict
	mov	ecx, DWORD PTR _obj$129068[ebp]
	mov	edx, DWORD PTR _dsfmt$[ebp]
	cmp	edx, DWORD PTR [ecx]
	jne	SHORT $LN1@IsConflict
	mov	al, 1
	jmp	SHORT $LN5@IsConflict
$LN1@IsConflict:

; 529  : 		}

	jmp	SHORT $LN3@IsConflict
$LN2@IsConflict:

; 530  : 		return false;

	xor	al, al
$LN5@IsConflict:

; 531  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?IsConflicted@Ogre@@YA_NW4_D3DMULTISAMPLE_TYPE@@W4_D3DFORMAT@@PAUD3DDEVCOMBO_T@1@@Z ENDP ; Ogre::IsConflicted
; Function compile flags: /Odtp
_this$ = -32						; size = 4
_pcombo$129180 = -28					; size = 4
_icombo$129176 = -24					; size = 4
_pbestcombo$ = -20					; size = 4
_desktopmode$ = -16					; size = 16
_desc$ = 8						; size = 4
?FindBestWindowMode@D3DEnumeration@Ogre@@AAEXABUInitDesc@RenderSystem@2@@Z PROC ; Ogre::D3DEnumeration::FindBestWindowMode
; _this$ = ecx

; 655  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	DWORD PTR _this$[ebp], ecx

; 656  : 		D3DDISPLAYMODE desktopmode;
; 657  : 		m_pD3D->GetAdapterDisplayMode( 0, &desktopmode );

	lea	eax, DWORD PTR _desktopmode$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+92]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+92]
	mov	edx, DWORD PTR [edx]
	push	ecx
	mov	eax, DWORD PTR [edx+32]
	call	eax

; 658  : 
; 659  : 		D3DDEVCOMBO_T *pbestcombo = NULL;

	mov	DWORD PTR _pbestcombo$[ebp], 0

; 660  : 		for( SIZE_T icombo=0; icombo<m_Settings.pdevice->devcombo.size(); icombo++ )

	mov	DWORD PTR _icombo$129176[ebp], 0
	jmp	SHORT $LN10@FindBestWi
$LN9@FindBestWi:
	mov	ecx, DWORD PTR _icombo$129176[ebp]
	add	ecx, 1
	mov	DWORD PTR _icombo$129176[ebp], ecx
$LN10@FindBestWi:
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+100]
	add	ecx, 312				; 00000138H
	call	?size@?$vector@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::D3DDEVCOMBO_T *,std::allocator<Ogre::D3DDEVCOMBO_T *> >::size
	cmp	DWORD PTR _icombo$129176[ebp], eax
	jae	SHORT $LN8@FindBestWi

; 661  : 		{
; 662  : 			D3DDEVCOMBO_T *pcombo = m_Settings.pdevice->devcombo[icombo];

	mov	eax, DWORD PTR _icombo$129176[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+100]
	add	ecx, 312				; 00000138H
	call	??A?$vector@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@QAEAAPAUD3DDEVCOMBO_T@Ogre@@I@Z ; std::vector<Ogre::D3DDEVCOMBO_T *,std::allocator<Ogre::D3DDEVCOMBO_T *> >::operator[]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR _pcombo$129180[ebp], edx

; 663  : 			if( !pcombo->iswindowed ) continue;

	mov	eax, DWORD PTR _pcombo$129180[ebp]
	cmp	DWORD PTR [eax+16], 0
	jne	SHORT $LN7@FindBestWi
	jmp	SHORT $LN9@FindBestWi
$LN7@FindBestWi:

; 664  : 			if( pcombo->adapterfmt != desktopmode.Format ) continue;

	mov	ecx, DWORD PTR _pcombo$129180[ebp]
	mov	edx, DWORD PTR [ecx+8]
	cmp	edx, DWORD PTR _desktopmode$[ebp+12]
	je	SHORT $LN6@FindBestWi
	jmp	SHORT $LN9@FindBestWi
$LN6@FindBestWi:

; 665  : 
; 666  : 			if( pbestcombo == NULL ) pbestcombo = pcombo;

	cmp	DWORD PTR _pbestcombo$[ebp], 0
	jne	SHORT $LN5@FindBestWi
	mov	eax, DWORD PTR _pcombo$129180[ebp]
	mov	DWORD PTR _pbestcombo$[ebp], eax
	jmp	SHORT $LN4@FindBestWi
$LN5@FindBestWi:

; 667  : 			else if( pcombo->adapterfmt == pcombo->backbuffmt )

	mov	ecx, DWORD PTR _pcombo$129180[ebp]
	mov	edx, DWORD PTR _pcombo$129180[ebp]
	mov	eax, DWORD PTR [ecx+8]
	cmp	eax, DWORD PTR [edx+12]
	jne	SHORT $LN4@FindBestWi

; 668  : 			{
; 669  : 				pbestcombo = pcombo;

	mov	ecx, DWORD PTR _pcombo$129180[ebp]
	mov	DWORD PTR _pbestcombo$[ebp], ecx

; 670  : 				break;

	jmp	SHORT $LN8@FindBestWi
$LN4@FindBestWi:

; 671  : 			}
; 672  : 		}

	jmp	SHORT $LN9@FindBestWi
$LN8@FindBestWi:

; 673  : 
; 674  : 		m_Settings.pdevcombo = pbestcombo;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _pbestcombo$[ebp]
	mov	DWORD PTR [edx+104], eax

; 675  : 		m_Settings.dispmode = desktopmode;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 128				; 00000080H
	mov	edx, DWORD PTR _desktopmode$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR _desktopmode$[ebp+4]
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR _desktopmode$[ebp+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR _desktopmode$[ebp+12]
	mov	DWORD PTR [ecx+12], eax

; 676  : 
; 677  : 		GetBestDSFmtAndMSType(m_Settings.dsformat, m_Settings.mstype, m_Settings.pdevcombo, desc.depthbits, desc.stencilbits, desc.multisample);

	mov	ecx, DWORD PTR _desc$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	push	edx
	mov	eax, DWORD PTR _desc$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	push	ecx
	mov	edx, DWORD PTR _desc$[ebp]
	mov	eax, DWORD PTR [edx+28]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+104]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 112				; 00000070H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 108				; 0000006cH
	push	ecx
	call	?GetBestDSFmtAndMSType@Ogre@@YAXAAW4_D3DFORMAT@@AAW4_D3DMULTISAMPLE_TYPE@@PAUD3DDEVCOMBO_T@1@HHH@Z ; Ogre::GetBestDSFmtAndMSType
	add	esp, 24					; 00000018H

; 678  : 	
; 679  : 		if(desc.sync_refresh) 

	mov	edx, DWORD PTR _desc$[ebp]
	movzx	eax, BYTE PTR [edx+11]
	test	eax, eax
	je	SHORT $LN2@FindBestWi

; 680  : 			m_Settings.interval = D3DPRESENT_INTERVAL_ONE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+124], 1

; 681  : 		else 

	jmp	SHORT $LN1@FindBestWi
$LN2@FindBestWi:

; 682  : 			m_Settings.interval = D3DPRESENT_INTERVAL_IMMEDIATE;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+124], -2147483648	; 80000000H
$LN1@FindBestWi:

; 683  : 
; 684  : 		m_Settings.msquality = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+116], 0

; 685  : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
?FindBestWindowMode@D3DEnumeration@Ogre@@AAEXABUInitDesc@RenderSystem@2@@Z ENDP ; Ogre::D3DEnumeration::FindBestWindowMode
; Function compile flags: /Odtp
tv130 = -56						; size = 4
_this$ = -52						; size = 4
_tmpmode$129216 = -48					; size = 4
_imode$129212 = -44					; size = 4
_bmatch_format$129200 = -40				; size = 4
_bmatch_bb$129201 = -36					; size = 4
_pcombo$129198 = -32					; size = 4
_icombo$129194 = -28					; size = 4
_pbestcombo$ = -24					; size = 4
_pbestmode$ = -20					; size = 4
_desktopmode$ = -16					; size = 16
_desc$ = 8						; size = 4
?FindBestFullscreenMode@D3DEnumeration@Ogre@@AAEXABUInitDesc@RenderSystem@2@@Z PROC ; Ogre::D3DEnumeration::FindBestFullscreenMode
; _this$ = ecx

; 688  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 56					; 00000038H
	mov	DWORD PTR _this$[ebp], ecx

; 689  : 		D3DDISPLAYMODE desktopmode;
; 690  : 		m_pD3D->GetAdapterDisplayMode( desc.adapter, &desktopmode );

	lea	eax, DWORD PTR _desktopmode$[ebp]
	push	eax
	mov	ecx, DWORD PTR _desc$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+92]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+92]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	mov	edx, DWORD PTR [ecx+32]
	call	edx

; 691  : 
; 692  : 		D3DDEVCOMBO_T *pbestcombo = NULL;

	mov	DWORD PTR _pbestcombo$[ebp], 0

; 693  : 		for( SIZE_T icombo=0; icombo<m_Settings.pdevice->devcombo.size(); icombo++ )

	mov	DWORD PTR _icombo$129194[ebp], 0
	jmp	SHORT $LN26@FindBestFu
$LN25@FindBestFu:
	mov	eax, DWORD PTR _icombo$129194[ebp]
	add	eax, 1
	mov	DWORD PTR _icombo$129194[ebp], eax
$LN26@FindBestFu:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+100]
	add	ecx, 312				; 00000138H
	call	?size@?$vector@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::D3DDEVCOMBO_T *,std::allocator<Ogre::D3DDEVCOMBO_T *> >::size
	cmp	DWORD PTR _icombo$129194[ebp], eax
	jae	$LN24@FindBestFu

; 694  : 		{
; 695  : 			D3DDEVCOMBO_T *pcombo = m_Settings.pdevice->devcombo[icombo];

	mov	edx, DWORD PTR _icombo$129194[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+100]
	add	ecx, 312				; 00000138H
	call	??A?$vector@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@QAEAAPAUD3DDEVCOMBO_T@Ogre@@I@Z ; std::vector<Ogre::D3DDEVCOMBO_T *,std::allocator<Ogre::D3DDEVCOMBO_T *> >::operator[]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _pcombo$129198[ebp], ecx

; 696  : 			if( pcombo->iswindowed ) continue;

	mov	edx, DWORD PTR _pcombo$129198[ebp]
	cmp	DWORD PTR [edx+16], 0
	je	SHORT $LN23@FindBestFu
	jmp	SHORT $LN25@FindBestFu
$LN23@FindBestFu:

; 697  : 
; 698  : 			BOOL bmatch_format = (ColorChannelBits(pcombo->backbuffmt)==desc.colorbits && AlphaChannelBits(pcombo->backbuffmt)==desc.alphabits);

	mov	eax, DWORD PTR _pcombo$129198[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	call	?ColorChannelBits@Ogre@@YAIW4_D3DFORMAT@@@Z ; Ogre::ColorChannelBits
	add	esp, 4
	mov	edx, DWORD PTR _desc$[ebp]
	cmp	eax, DWORD PTR [edx+20]
	jne	SHORT $LN29@FindBestFu
	mov	eax, DWORD PTR _pcombo$129198[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	call	?AlphaChannelBits@Ogre@@YAIW4_D3DFORMAT@@@Z ; Ogre::AlphaChannelBits
	add	esp, 4
	mov	edx, DWORD PTR _desc$[ebp]
	cmp	eax, DWORD PTR [edx+24]
	jne	SHORT $LN29@FindBestFu
	mov	DWORD PTR tv130[ebp], 1
	jmp	SHORT $LN30@FindBestFu
$LN29@FindBestFu:
	mov	DWORD PTR tv130[ebp], 0
$LN30@FindBestFu:
	mov	eax, DWORD PTR tv130[ebp]
	mov	DWORD PTR _bmatch_format$129200[ebp], eax

; 699  : 			BOOL bmatch_bb = (pcombo->backbuffmt==pcombo->adapterfmt);

	mov	ecx, DWORD PTR _pcombo$129198[ebp]
	mov	edx, DWORD PTR _pcombo$129198[ebp]
	mov	eax, DWORD PTR [ecx+12]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx+8]
	sete	cl
	mov	DWORD PTR _bmatch_bb$129201[ebp], ecx

; 700  : 
; 701  : 			if( pbestcombo == NULL ) pbestcombo = pcombo;

	cmp	DWORD PTR _pbestcombo$[ebp], 0
	jne	SHORT $LN22@FindBestFu
	mov	edx, DWORD PTR _pcombo$129198[ebp]
	mov	DWORD PTR _pbestcombo$[ebp], edx

; 702  : 			else 

	jmp	SHORT $LN21@FindBestFu
$LN22@FindBestFu:

; 703  : 			{
; 704  : 				if( ColorChannelBits(pbestcombo->backbuffmt)!=desc.colorbits || AlphaChannelBits(pbestcombo->backbuffmt)!=desc.alphabits )

	mov	eax, DWORD PTR _pbestcombo$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	call	?ColorChannelBits@Ogre@@YAIW4_D3DFORMAT@@@Z ; Ogre::ColorChannelBits
	add	esp, 4
	mov	edx, DWORD PTR _desc$[ebp]
	cmp	eax, DWORD PTR [edx+20]
	jne	SHORT $LN19@FindBestFu
	mov	eax, DWORD PTR _pbestcombo$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	call	?AlphaChannelBits@Ogre@@YAIW4_D3DFORMAT@@@Z ; Ogre::AlphaChannelBits
	add	esp, 4
	mov	edx, DWORD PTR _desc$[ebp]
	cmp	eax, DWORD PTR [edx+24]
	je	SHORT $LN20@FindBestFu
$LN19@FindBestFu:

; 705  : 				{
; 706  : 					if( bmatch_format ) pbestcombo = pcombo;

	cmp	DWORD PTR _bmatch_format$129200[ebp], 0
	je	SHORT $LN18@FindBestFu
	mov	eax, DWORD PTR _pcombo$129198[ebp]
	mov	DWORD PTR _pbestcombo$[ebp], eax
$LN18@FindBestFu:

; 707  : 				}

	jmp	SHORT $LN21@FindBestFu
$LN20@FindBestFu:

; 708  : 				else if( pbestcombo->backbuffmt != pbestcombo->adapterfmt )

	mov	ecx, DWORD PTR _pbestcombo$[ebp]
	mov	edx, DWORD PTR _pbestcombo$[ebp]
	mov	eax, DWORD PTR [ecx+12]
	cmp	eax, DWORD PTR [edx+8]
	je	SHORT $LN21@FindBestFu

; 709  : 				{
; 710  : 					if( bmatch_bb ) pbestcombo = pcombo;

	cmp	DWORD PTR _bmatch_bb$129201[ebp], 0
	je	SHORT $LN21@FindBestFu
	mov	ecx, DWORD PTR _pcombo$129198[ebp]
	mov	DWORD PTR _pbestcombo$[ebp], ecx
$LN21@FindBestFu:

; 711  : 				}
; 712  : 			}
; 713  : 		}

	jmp	$LN25@FindBestFu
$LN24@FindBestFu:

; 714  : 		m_Settings.pdevcombo = pbestcombo;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _pbestcombo$[ebp]
	mov	DWORD PTR [edx+104], eax

; 715  : 		if( pbestcombo == NULL ) return;

	cmp	DWORD PTR _pbestcombo$[ebp], 0
	jne	SHORT $LN14@FindBestFu
	jmp	$LN27@FindBestFu
$LN14@FindBestFu:

; 716  : 
; 717  : 		//find a best display mode
; 718  : 		D3DDISPLAYMODE *pbestmode = NULL;

	mov	DWORD PTR _pbestmode$[ebp], 0

; 719  : 		for( SIZE_T imode=0; imode<m_Settings.padapter->modes.size(); imode++ )

	mov	DWORD PTR _imode$129212[ebp], 0
	jmp	SHORT $LN13@FindBestFu
$LN12@FindBestFu:
	mov	ecx, DWORD PTR _imode$129212[ebp]
	add	ecx, 1
	mov	DWORD PTR _imode$129212[ebp], ecx
$LN13@FindBestFu:
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+96]
	add	ecx, 1104				; 00000450H
	call	?size@?$vector@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@QBEIXZ ; std::vector<_D3DDISPLAYMODE,std::allocator<_D3DDISPLAYMODE> >::size
	cmp	DWORD PTR _imode$129212[ebp], eax
	jae	$LN11@FindBestFu

; 720  : 		{
; 721  : 			D3DDISPLAYMODE &tmpmode = m_Settings.padapter->modes[imode];

	mov	eax, DWORD PTR _imode$129212[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+96]
	add	ecx, 1104				; 00000450H
	call	??A?$vector@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@QAEAAU_D3DDISPLAYMODE@@I@Z ; std::vector<_D3DDISPLAYMODE,std::allocator<_D3DDISPLAYMODE> >::operator[]
	mov	DWORD PTR _tmpmode$129216[ebp], eax

; 722  : 			if( pbestmode == NULL ) pbestmode = &tmpmode;

	cmp	DWORD PTR _pbestmode$[ebp], 0
	jne	SHORT $LN10@FindBestFu
	mov	edx, DWORD PTR _tmpmode$129216[ebp]
	mov	DWORD PTR _pbestmode$[ebp], edx
	jmp	SHORT $LN9@FindBestFu
$LN10@FindBestFu:

; 723  : 			else if( pbestmode->Width!=desc.width || pbestmode->Height!=desc.height || pbestmode->RefreshRate!=desktopmode.RefreshRate )

	mov	eax, DWORD PTR _pbestmode$[ebp]
	mov	ecx, DWORD PTR _desc$[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx+12]
	jne	SHORT $LN7@FindBestFu
	mov	eax, DWORD PTR _pbestmode$[ebp]
	mov	ecx, DWORD PTR _desc$[ebp]
	mov	edx, DWORD PTR [eax+4]
	cmp	edx, DWORD PTR [ecx+16]
	jne	SHORT $LN7@FindBestFu
	mov	eax, DWORD PTR _pbestmode$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	cmp	ecx, DWORD PTR _desktopmode$[ebp+8]
	je	SHORT $LN8@FindBestFu
$LN7@FindBestFu:

; 724  : 			{
; 725  : 				if( tmpmode.Width==desc.width&&tmpmode.Height==desc.height&&tmpmode.RefreshRate==desktopmode.RefreshRate )

	mov	edx, DWORD PTR _tmpmode$129216[ebp]
	mov	eax, DWORD PTR _desc$[ebp]
	mov	ecx, DWORD PTR [edx]
	cmp	ecx, DWORD PTR [eax+12]
	jne	SHORT $LN6@FindBestFu
	mov	edx, DWORD PTR _tmpmode$129216[ebp]
	mov	eax, DWORD PTR _desc$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	cmp	ecx, DWORD PTR [eax+16]
	jne	SHORT $LN6@FindBestFu
	mov	edx, DWORD PTR _tmpmode$129216[ebp]
	mov	eax, DWORD PTR [edx+8]
	cmp	eax, DWORD PTR _desktopmode$[ebp+8]
	jne	SHORT $LN6@FindBestFu

; 726  : 					pbestmode = &tmpmode;

	mov	ecx, DWORD PTR _tmpmode$129216[ebp]
	mov	DWORD PTR _pbestmode$[ebp], ecx
$LN6@FindBestFu:

; 727  : 			}

	jmp	SHORT $LN9@FindBestFu
$LN8@FindBestFu:

; 728  : 			else if( pbestmode->Format != pbestcombo->adapterfmt )

	mov	edx, DWORD PTR _pbestmode$[ebp]
	mov	eax, DWORD PTR _pbestcombo$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	cmp	ecx, DWORD PTR [eax+8]
	je	SHORT $LN9@FindBestFu

; 729  : 			{
; 730  : 				if( tmpmode.Format == pbestcombo->adapterfmt ) pbestmode = &tmpmode;

	mov	edx, DWORD PTR _tmpmode$129216[ebp]
	mov	eax, DWORD PTR _pbestcombo$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	cmp	ecx, DWORD PTR [eax+8]
	jne	SHORT $LN9@FindBestFu
	mov	edx, DWORD PTR _tmpmode$129216[ebp]
	mov	DWORD PTR _pbestmode$[ebp], edx
$LN9@FindBestFu:

; 731  : 			}
; 732  : 		}

	jmp	$LN12@FindBestFu
$LN11@FindBestFu:

; 733  : 
; 734  : 		m_Settings.dispmode = *pbestmode;

	mov	eax, DWORD PTR _pbestmode$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 128				; 00000080H
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], eax

; 735  : 
; 736  : 		if(desc.sync_refresh) 

	mov	ecx, DWORD PTR _desc$[ebp]
	movzx	edx, BYTE PTR [ecx+11]
	test	edx, edx
	je	SHORT $LN2@FindBestFu

; 737  : 			m_Settings.interval = D3DPRESENT_INTERVAL_ONE;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+124], 1

; 738  : 		else 

	jmp	SHORT $LN1@FindBestFu
$LN2@FindBestFu:

; 739  : 			m_Settings.interval = D3DPRESENT_INTERVAL_IMMEDIATE;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+124], -2147483648	; 80000000H
$LN1@FindBestFu:

; 740  : 
; 741  : 		m_Settings.msquality = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+116], 0
$LN27@FindBestFu:

; 742  : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
?FindBestFullscreenMode@D3DEnumeration@Ogre@@AAEXABUInitDesc@RenderSystem@2@@Z ENDP ; Ogre::D3DEnumeration::FindBestFullscreenMode
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@QAE@XZ ; std::_Vector_val<enum _D3DFORMAT,std::allocator<enum _D3DFORMAT> >::~_Vector_val<enum _D3DFORMAT,std::allocator<enum _D3DFORMAT> >
PUBLIC	?_Buy@?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@IAE_NI@Z ; std::vector<enum _D3DFORMAT,std::allocator<enum _D3DFORMAT> >::_Buy
PUBLIC	??0?$_Vector_val@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@IAE@V?$allocator@W4_D3DFORMAT@@@1@@Z ; std::_Vector_val<enum _D3DFORMAT,std::allocator<enum _D3DFORMAT> >::_Vector_val<enum _D3DFORMAT,std::allocator<enum _D3DFORMAT> >
PUBLIC	??0?$allocator@W4_D3DFORMAT@@@std@@QAE@XZ	; std::allocator<enum _D3DFORMAT>::allocator<enum _D3DFORMAT>
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	SEGMENT
__unwindtable$??0?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??0?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T141577 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@QAE@XZ PROC ; std::vector<enum _D3DFORMAT,std::allocator<enum _D3DFORMAT> >::vector<enum _D3DFORMAT,std::allocator<enum _D3DFORMAT> >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T141577[ebp], esp
	call	??0?$allocator@W4_D3DFORMAT@@@std@@QAE@XZ ; std::allocator<enum _D3DFORMAT>::allocator<enum _D3DFORMAT>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_val@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@IAE@V?$allocator@W4_D3DFORMAT@@@1@@Z ; std::_Vector_val<enum _D3DFORMAT,std::allocator<enum _D3DFORMAT> >::_Vector_val<enum _D3DFORMAT,std::allocator<enum _D3DFORMAT> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 471  : 		_Buy(0);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@IAE_NI@Z ; std::vector<enum _D3DFORMAT,std::allocator<enum _D3DFORMAT> >::_Buy

; 472  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@QAE@XZ
__ehhandler$??0?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@QAE@XZ ENDP ; std::vector<enum _D3DFORMAT,std::allocator<enum _D3DFORMAT> >::vector<enum _D3DFORMAT,std::allocator<enum _D3DFORMAT> >
PUBLIC	?_Tidy@?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@IAEXXZ ; std::vector<enum _D3DFORMAT,std::allocator<enum _D3DFORMAT> >::_Tidy
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@QAE@XZ PROC ; std::vector<enum _D3DFORMAT,std::allocator<enum _D3DFORMAT> >::~vector<enum _D3DFORMAT,std::allocator<enum _D3DFORMAT> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 559  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@IAEXXZ ; std::vector<enum _D3DFORMAT,std::allocator<enum _D3DFORMAT> >::_Tidy

; 560  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Vector_val@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@QAE@XZ
__ehhandler$??1?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@QAE@XZ ENDP ; std::vector<enum _D3DFORMAT,std::allocator<enum _D3DFORMAT> >::~vector<enum _D3DFORMAT,std::allocator<enum _D3DFORMAT> >
; Function compile flags: /Odtp
;	COMDAT ?size@?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@QBEIXZ PROC ; std::vector<enum _D3DFORMAT,std::allocator<enum _D3DFORMAT> >::size, COMDAT
; _this$ = ecx

; 725  : 		{	// return length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+16]
	sub	eax, DWORD PTR [ecx+12]
	sar	eax, 2

; 727  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?size@?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@QBEIXZ ENDP ; std::vector<enum _D3DFORMAT,std::allocator<enum _D3DFORMAT> >::size
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?empty@?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?empty@?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@QBE_NXZ PROC ; std::vector<enum _D3DFORMAT,std::allocator<enum _D3DFORMAT> >::empty, COMDAT
; _this$ = ecx

; 735  : 		{	// test if sequence is empty

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 736  : 		return (size() == 0);

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@QBEIXZ ; std::vector<enum _D3DFORMAT,std::allocator<enum _D3DFORMAT> >::size
	neg	eax
	sbb	eax, eax
	add	eax, 1

; 737  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?empty@?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@QBE_NXZ ENDP ; std::vector<enum _D3DFORMAT,std::allocator<enum _D3DFORMAT> >::empty
_TEXT	ENDS
EXTRN	__imp___invalid_parameter_noinfo:PROC
; Function compile flags: /Odtp
;	COMDAT ??A?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@QAEAAW4_D3DFORMAT@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pos$ = 8						; size = 4
??A?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@QAEAAW4_D3DFORMAT@@I@Z PROC ; std::vector<enum _D3DFORMAT,std::allocator<enum _D3DFORMAT> >::operator[], COMDAT
; _this$ = ecx

; 774  : 		{	// subscript mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)
; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");
; 780  : 			_SCL_SECURE_OUT_OF_RANGE;
; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@QBEIXZ ; std::vector<enum _D3DFORMAT,std::allocator<enum _D3DFORMAT> >::size
	cmp	DWORD PTR __Pos$[ebp], eax
	jb	SHORT $LN1@operator
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN1@operator:

; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR __Pos$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]

; 786  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??A?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@QAEAAW4_D3DFORMAT@@I@Z ENDP ; std::vector<enum _D3DFORMAT,std::allocator<enum _D3DFORMAT> >::operator[]
_TEXT	ENDS
PUBLIC	?insert@?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@QAE?AV?$_Vector_iterator@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@2@V?$_Vector_const_iterator@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@2@ABW4_D3DFORMAT@@@Z ; std::vector<enum _D3DFORMAT,std::allocator<enum _D3DFORMAT> >::insert
PUBLIC	?end@?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@QAE?AV?$_Vector_iterator@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@2@XZ ; std::vector<enum _D3DFORMAT,std::allocator<enum _D3DFORMAT> >::end
PUBLIC	?_Ufill@?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@IAEPAW4_D3DFORMAT@@PAW43@IABW43@@Z ; std::vector<enum _D3DFORMAT,std::allocator<enum _D3DFORMAT> >::_Ufill
PUBLIC	?capacity@?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@QBEIXZ ; std::vector<enum _D3DFORMAT,std::allocator<enum _D3DFORMAT> >::capacity
; Function compile flags: /Odtp
;	COMDAT ?push_back@?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@QAEXABW4_D3DFORMAT@@@Z
_TEXT	SEGMENT
_this$ = -28						; size = 4
$T141604 = -24						; size = 8
$T141603 = -16						; size = 8
$T141602 = -8						; size = 8
__Val$ = 8						; size = 4
?push_back@?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@QAEXABW4_D3DFORMAT@@@Z PROC ; std::vector<enum _D3DFORMAT,std::allocator<enum _D3DFORMAT> >::push_back, COMDAT
; _this$ = ecx

; 809  : 		{	// insert element at end

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 810  : 		if (size() < capacity())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@QBEIXZ ; std::vector<enum _D3DFORMAT,std::allocator<enum _D3DFORMAT> >::size
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?capacity@?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@QBEIXZ ; std::vector<enum _D3DFORMAT,std::allocator<enum _D3DFORMAT> >::capacity
	cmp	esi, eax
	jae	SHORT $LN2@push_back

; 811  : 
; 812  :  #if _HAS_ITERATOR_DEBUGGING
; 813  : 			{ // room at end, construct it there
; 814  : 			_Orphan_range(_Mylast, _Mylast);
; 815  : 			_Mylast = _Ufill(_Mylast, 1, _Val);
; 816  : 			}
; 817  : 
; 818  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 819  : 			_Mylast = _Ufill(_Mylast, 1, _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Ufill@?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@IAEPAW4_D3DFORMAT@@PAW43@IABW43@@Z ; std::vector<enum _D3DFORMAT,std::allocator<enum _D3DFORMAT> >::_Ufill
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 820  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 821  : 
; 822  : 		else

	jmp	SHORT $LN3@push_back
$LN2@push_back:

; 823  : 			insert(end(), _Val);

	lea	edx, DWORD PTR $T141603[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@QAE?AV?$_Vector_iterator@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@2@XZ ; std::vector<enum _D3DFORMAT,std::allocator<enum _D3DFORMAT> >::end
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T141602[ebp], ecx
	mov	DWORD PTR $T141602[ebp+4], edx
	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T141602[ebp+4]
	push	ecx
	mov	edx, DWORD PTR $T141602[ebp]
	push	edx
	lea	eax, DWORD PTR $T141604[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?insert@?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@QAE?AV?$_Vector_iterator@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@2@V?$_Vector_const_iterator@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@2@ABW4_D3DFORMAT@@@Z ; std::vector<enum _D3DFORMAT,std::allocator<enum _D3DFORMAT> >::insert
$LN3@push_back:

; 824  : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?push_back@?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@QAEXABW4_D3DFORMAT@@@Z ENDP ; std::vector<enum _D3DFORMAT,std::allocator<enum _D3DFORMAT> >::push_back
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@QAE@XZ ; std::_Vector_val<enum _D3DMULTISAMPLE_TYPE,std::allocator<enum _D3DMULTISAMPLE_TYPE> >::~_Vector_val<enum _D3DMULTISAMPLE_TYPE,std::allocator<enum _D3DMULTISAMPLE_TYPE> >
PUBLIC	?_Buy@?$vector@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@IAE_NI@Z ; std::vector<enum _D3DMULTISAMPLE_TYPE,std::allocator<enum _D3DMULTISAMPLE_TYPE> >::_Buy
PUBLIC	??0?$_Vector_val@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@IAE@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@1@@Z ; std::_Vector_val<enum _D3DMULTISAMPLE_TYPE,std::allocator<enum _D3DMULTISAMPLE_TYPE> >::_Vector_val<enum _D3DMULTISAMPLE_TYPE,std::allocator<enum _D3DMULTISAMPLE_TYPE> >
PUBLIC	??0?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@QAE@XZ ; std::allocator<enum _D3DMULTISAMPLE_TYPE>::allocator<enum _D3DMULTISAMPLE_TYPE>
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$vector@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??0?$vector@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$vector@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$vector@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T141607 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0?$vector@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@QAE@XZ PROC ; std::vector<enum _D3DMULTISAMPLE_TYPE,std::allocator<enum _D3DMULTISAMPLE_TYPE> >::vector<enum _D3DMULTISAMPLE_TYPE,std::allocator<enum _D3DMULTISAMPLE_TYPE> >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$vector@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T141607[ebp], esp
	call	??0?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@QAE@XZ ; std::allocator<enum _D3DMULTISAMPLE_TYPE>::allocator<enum _D3DMULTISAMPLE_TYPE>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_val@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@IAE@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@1@@Z ; std::_Vector_val<enum _D3DMULTISAMPLE_TYPE,std::allocator<enum _D3DMULTISAMPLE_TYPE> >::_Vector_val<enum _D3DMULTISAMPLE_TYPE,std::allocator<enum _D3DMULTISAMPLE_TYPE> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 471  : 		_Buy(0);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@IAE_NI@Z ; std::vector<enum _D3DMULTISAMPLE_TYPE,std::allocator<enum _D3DMULTISAMPLE_TYPE> >::_Buy

; 472  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@QAE@XZ
__ehhandler$??0?$vector@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@QAE@XZ ENDP ; std::vector<enum _D3DMULTISAMPLE_TYPE,std::allocator<enum _D3DMULTISAMPLE_TYPE> >::vector<enum _D3DMULTISAMPLE_TYPE,std::allocator<enum _D3DMULTISAMPLE_TYPE> >
PUBLIC	?_Tidy@?$vector@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@IAEXXZ ; std::vector<enum _D3DMULTISAMPLE_TYPE,std::allocator<enum _D3DMULTISAMPLE_TYPE> >::_Tidy
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$vector@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$vector@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$vector@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$vector@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$vector@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$vector@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@QAE@XZ PROC ; std::vector<enum _D3DMULTISAMPLE_TYPE,std::allocator<enum _D3DMULTISAMPLE_TYPE> >::~vector<enum _D3DMULTISAMPLE_TYPE,std::allocator<enum _D3DMULTISAMPLE_TYPE> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$vector@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 559  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@IAEXXZ ; std::vector<enum _D3DMULTISAMPLE_TYPE,std::allocator<enum _D3DMULTISAMPLE_TYPE> >::_Tidy

; 560  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Vector_val@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$vector@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@QAE@XZ
__ehhandler$??1?$vector@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$vector@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$vector@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@QAE@XZ ENDP ; std::vector<enum _D3DMULTISAMPLE_TYPE,std::allocator<enum _D3DMULTISAMPLE_TYPE> >::~vector<enum _D3DMULTISAMPLE_TYPE,std::allocator<enum _D3DMULTISAMPLE_TYPE> >
; Function compile flags: /Odtp
;	COMDAT ?size@?$vector@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$vector@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@QBEIXZ PROC ; std::vector<enum _D3DMULTISAMPLE_TYPE,std::allocator<enum _D3DMULTISAMPLE_TYPE> >::size, COMDAT
; _this$ = ecx

; 725  : 		{	// return length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+16]
	sub	eax, DWORD PTR [ecx+12]
	sar	eax, 2

; 727  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?size@?$vector@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@QBEIXZ ENDP ; std::vector<enum _D3DMULTISAMPLE_TYPE,std::allocator<enum _D3DMULTISAMPLE_TYPE> >::size
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?empty@?$vector@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?empty@?$vector@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@QBE_NXZ PROC ; std::vector<enum _D3DMULTISAMPLE_TYPE,std::allocator<enum _D3DMULTISAMPLE_TYPE> >::empty, COMDAT
; _this$ = ecx

; 735  : 		{	// test if sequence is empty

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 736  : 		return (size() == 0);

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@QBEIXZ ; std::vector<enum _D3DMULTISAMPLE_TYPE,std::allocator<enum _D3DMULTISAMPLE_TYPE> >::size
	neg	eax
	sbb	eax, eax
	add	eax, 1

; 737  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?empty@?$vector@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@QBE_NXZ ENDP ; std::vector<enum _D3DMULTISAMPLE_TYPE,std::allocator<enum _D3DMULTISAMPLE_TYPE> >::empty
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??A?$vector@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@QAEAAW4_D3DMULTISAMPLE_TYPE@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pos$ = 8						; size = 4
??A?$vector@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@QAEAAW4_D3DMULTISAMPLE_TYPE@@I@Z PROC ; std::vector<enum _D3DMULTISAMPLE_TYPE,std::allocator<enum _D3DMULTISAMPLE_TYPE> >::operator[], COMDAT
; _this$ = ecx

; 774  : 		{	// subscript mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)
; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");
; 780  : 			_SCL_SECURE_OUT_OF_RANGE;
; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@QBEIXZ ; std::vector<enum _D3DMULTISAMPLE_TYPE,std::allocator<enum _D3DMULTISAMPLE_TYPE> >::size
	cmp	DWORD PTR __Pos$[ebp], eax
	jb	SHORT $LN1@operator@2
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN1@operator@2:

; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR __Pos$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]

; 786  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??A?$vector@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@QAEAAW4_D3DMULTISAMPLE_TYPE@@I@Z ENDP ; std::vector<enum _D3DMULTISAMPLE_TYPE,std::allocator<enum _D3DMULTISAMPLE_TYPE> >::operator[]
_TEXT	ENDS
PUBLIC	?insert@?$vector@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@QAE?AV?$_Vector_iterator@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@2@V?$_Vector_const_iterator@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@2@ABW4_D3DMULTISAMPLE_TYPE@@@Z ; std::vector<enum _D3DMULTISAMPLE_TYPE,std::allocator<enum _D3DMULTISAMPLE_TYPE> >::insert
PUBLIC	?end@?$vector@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@QAE?AV?$_Vector_iterator@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@2@XZ ; std::vector<enum _D3DMULTISAMPLE_TYPE,std::allocator<enum _D3DMULTISAMPLE_TYPE> >::end
PUBLIC	?_Ufill@?$vector@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@IAEPAW4_D3DMULTISAMPLE_TYPE@@PAW43@IABW43@@Z ; std::vector<enum _D3DMULTISAMPLE_TYPE,std::allocator<enum _D3DMULTISAMPLE_TYPE> >::_Ufill
PUBLIC	?capacity@?$vector@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@QBEIXZ ; std::vector<enum _D3DMULTISAMPLE_TYPE,std::allocator<enum _D3DMULTISAMPLE_TYPE> >::capacity
; Function compile flags: /Odtp
;	COMDAT ?push_back@?$vector@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@QAEXABW4_D3DMULTISAMPLE_TYPE@@@Z
_TEXT	SEGMENT
_this$ = -28						; size = 4
$T141634 = -24						; size = 8
$T141633 = -16						; size = 8
$T141632 = -8						; size = 8
__Val$ = 8						; size = 4
?push_back@?$vector@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@QAEXABW4_D3DMULTISAMPLE_TYPE@@@Z PROC ; std::vector<enum _D3DMULTISAMPLE_TYPE,std::allocator<enum _D3DMULTISAMPLE_TYPE> >::push_back, COMDAT
; _this$ = ecx

; 809  : 		{	// insert element at end

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 810  : 		if (size() < capacity())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@QBEIXZ ; std::vector<enum _D3DMULTISAMPLE_TYPE,std::allocator<enum _D3DMULTISAMPLE_TYPE> >::size
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?capacity@?$vector@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@QBEIXZ ; std::vector<enum _D3DMULTISAMPLE_TYPE,std::allocator<enum _D3DMULTISAMPLE_TYPE> >::capacity
	cmp	esi, eax
	jae	SHORT $LN2@push_back@2

; 811  : 
; 812  :  #if _HAS_ITERATOR_DEBUGGING
; 813  : 			{ // room at end, construct it there
; 814  : 			_Orphan_range(_Mylast, _Mylast);
; 815  : 			_Mylast = _Ufill(_Mylast, 1, _Val);
; 816  : 			}
; 817  : 
; 818  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 819  : 			_Mylast = _Ufill(_Mylast, 1, _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Ufill@?$vector@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@IAEPAW4_D3DMULTISAMPLE_TYPE@@PAW43@IABW43@@Z ; std::vector<enum _D3DMULTISAMPLE_TYPE,std::allocator<enum _D3DMULTISAMPLE_TYPE> >::_Ufill
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 820  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 821  : 
; 822  : 		else

	jmp	SHORT $LN3@push_back@2
$LN2@push_back@2:

; 823  : 			insert(end(), _Val);

	lea	edx, DWORD PTR $T141633[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$vector@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@QAE?AV?$_Vector_iterator@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@2@XZ ; std::vector<enum _D3DMULTISAMPLE_TYPE,std::allocator<enum _D3DMULTISAMPLE_TYPE> >::end
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T141632[ebp], ecx
	mov	DWORD PTR $T141632[ebp+4], edx
	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T141632[ebp+4]
	push	ecx
	mov	edx, DWORD PTR $T141632[ebp]
	push	edx
	lea	eax, DWORD PTR $T141634[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?insert@?$vector@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@QAE?AV?$_Vector_iterator@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@2@V?$_Vector_const_iterator@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@2@ABW4_D3DMULTISAMPLE_TYPE@@@Z ; std::vector<enum _D3DMULTISAMPLE_TYPE,std::allocator<enum _D3DMULTISAMPLE_TYPE> >::insert
$LN3@push_back@2:

; 824  : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?push_back@?$vector@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@QAEXABW4_D3DMULTISAMPLE_TYPE@@@Z ENDP ; std::vector<enum _D3DMULTISAMPLE_TYPE,std::allocator<enum _D3DMULTISAMPLE_TYPE> >::push_back
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@IV?$allocator@I@std@@@std@@QAE@XZ ; std::_Vector_val<unsigned int,std::allocator<unsigned int> >::~_Vector_val<unsigned int,std::allocator<unsigned int> >
PUBLIC	?_Buy@?$vector@IV?$allocator@I@std@@@std@@IAE_NI@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Buy
PUBLIC	??0?$_Vector_val@IV?$allocator@I@std@@@std@@IAE@V?$allocator@I@1@@Z ; std::_Vector_val<unsigned int,std::allocator<unsigned int> >::_Vector_val<unsigned int,std::allocator<unsigned int> >
PUBLIC	??0?$allocator@I@std@@QAE@XZ			; std::allocator<unsigned int>::allocator<unsigned int>
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$vector@IV?$allocator@I@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@IV?$allocator@I@std@@@std@@QAE@XZ$0
__ehfuncinfo$??0?$vector@IV?$allocator@I@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$vector@IV?$allocator@I@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$vector@IV?$allocator@I@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T141637 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0?$vector@IV?$allocator@I@std@@@std@@QAE@XZ PROC	; std::vector<unsigned int,std::allocator<unsigned int> >::vector<unsigned int,std::allocator<unsigned int> >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$vector@IV?$allocator@I@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T141637[ebp], esp
	call	??0?$allocator@I@std@@QAE@XZ		; std::allocator<unsigned int>::allocator<unsigned int>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_val@IV?$allocator@I@std@@@std@@IAE@V?$allocator@I@1@@Z ; std::_Vector_val<unsigned int,std::allocator<unsigned int> >::_Vector_val<unsigned int,std::allocator<unsigned int> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 471  : 		_Buy(0);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@IV?$allocator@I@std@@@std@@IAE_NI@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Buy

; 472  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@IV?$allocator@I@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@IV?$allocator@I@std@@@std@@QAE@XZ
__ehhandler$??0?$vector@IV?$allocator@I@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@IV?$allocator@I@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@IV?$allocator@I@std@@@std@@QAE@XZ ENDP	; std::vector<unsigned int,std::allocator<unsigned int> >::vector<unsigned int,std::allocator<unsigned int> >
PUBLIC	?_Tidy@?$vector@IV?$allocator@I@std@@@std@@IAEXXZ ; std::vector<unsigned int,std::allocator<unsigned int> >::_Tidy
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$vector@IV?$allocator@I@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$vector@IV?$allocator@I@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$vector@IV?$allocator@I@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$vector@IV?$allocator@I@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$vector@IV?$allocator@I@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$vector@IV?$allocator@I@std@@@std@@QAE@XZ PROC	; std::vector<unsigned int,std::allocator<unsigned int> >::~vector<unsigned int,std::allocator<unsigned int> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$vector@IV?$allocator@I@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 559  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@IV?$allocator@I@std@@@std@@IAEXXZ ; std::vector<unsigned int,std::allocator<unsigned int> >::_Tidy

; 560  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Vector_val@IV?$allocator@I@std@@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$vector@IV?$allocator@I@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@IV?$allocator@I@std@@@std@@QAE@XZ
__ehhandler$??1?$vector@IV?$allocator@I@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$vector@IV?$allocator@I@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$vector@IV?$allocator@I@std@@@std@@QAE@XZ ENDP	; std::vector<unsigned int,std::allocator<unsigned int> >::~vector<unsigned int,std::allocator<unsigned int> >
PUBLIC	?insert@?$vector@IV?$allocator@I@std@@@std@@QAE?AV?$_Vector_iterator@IV?$allocator@I@std@@@2@V?$_Vector_const_iterator@IV?$allocator@I@std@@@2@ABI@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::insert
PUBLIC	?end@?$vector@IV?$allocator@I@std@@@std@@QAE?AV?$_Vector_iterator@IV?$allocator@I@std@@@2@XZ ; std::vector<unsigned int,std::allocator<unsigned int> >::end
PUBLIC	?_Ufill@?$vector@IV?$allocator@I@std@@@std@@IAEPAIPAIIABI@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Ufill
PUBLIC	?capacity@?$vector@IV?$allocator@I@std@@@std@@QBEIXZ ; std::vector<unsigned int,std::allocator<unsigned int> >::capacity
PUBLIC	?size@?$vector@IV?$allocator@I@std@@@std@@QBEIXZ ; std::vector<unsigned int,std::allocator<unsigned int> >::size
; Function compile flags: /Odtp
;	COMDAT ?push_back@?$vector@IV?$allocator@I@std@@@std@@QAEXABI@Z
_TEXT	SEGMENT
_this$ = -28						; size = 4
$T141658 = -24						; size = 8
$T141657 = -16						; size = 8
$T141656 = -8						; size = 8
__Val$ = 8						; size = 4
?push_back@?$vector@IV?$allocator@I@std@@@std@@QAEXABI@Z PROC ; std::vector<unsigned int,std::allocator<unsigned int> >::push_back, COMDAT
; _this$ = ecx

; 809  : 		{	// insert element at end

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 810  : 		if (size() < capacity())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@IV?$allocator@I@std@@@std@@QBEIXZ ; std::vector<unsigned int,std::allocator<unsigned int> >::size
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?capacity@?$vector@IV?$allocator@I@std@@@std@@QBEIXZ ; std::vector<unsigned int,std::allocator<unsigned int> >::capacity
	cmp	esi, eax
	jae	SHORT $LN2@push_back@3

; 811  : 
; 812  :  #if _HAS_ITERATOR_DEBUGGING
; 813  : 			{ // room at end, construct it there
; 814  : 			_Orphan_range(_Mylast, _Mylast);
; 815  : 			_Mylast = _Ufill(_Mylast, 1, _Val);
; 816  : 			}
; 817  : 
; 818  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 819  : 			_Mylast = _Ufill(_Mylast, 1, _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Ufill@?$vector@IV?$allocator@I@std@@@std@@IAEPAIPAIIABI@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Ufill
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 820  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 821  : 
; 822  : 		else

	jmp	SHORT $LN3@push_back@3
$LN2@push_back@3:

; 823  : 			insert(end(), _Val);

	lea	edx, DWORD PTR $T141657[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$vector@IV?$allocator@I@std@@@std@@QAE?AV?$_Vector_iterator@IV?$allocator@I@std@@@2@XZ ; std::vector<unsigned int,std::allocator<unsigned int> >::end
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T141656[ebp], ecx
	mov	DWORD PTR $T141656[ebp+4], edx
	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T141656[ebp+4]
	push	ecx
	mov	edx, DWORD PTR $T141656[ebp]
	push	edx
	lea	eax, DWORD PTR $T141658[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?insert@?$vector@IV?$allocator@I@std@@@std@@QAE?AV?$_Vector_iterator@IV?$allocator@I@std@@@2@V?$_Vector_const_iterator@IV?$allocator@I@std@@@2@ABI@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::insert
$LN3@push_back@3:

; 824  : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?push_back@?$vector@IV?$allocator@I@std@@@std@@QAEXABI@Z ENDP ; std::vector<unsigned int,std::allocator<unsigned int> >::push_back
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@QAE@XZ ; std::_Vector_val<Ogre::D3DSMSCONFLICT_T,std::allocator<Ogre::D3DSMSCONFLICT_T> >::~_Vector_val<Ogre::D3DSMSCONFLICT_T,std::allocator<Ogre::D3DSMSCONFLICT_T> >
PUBLIC	?_Buy@?$vector@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@IAE_NI@Z ; std::vector<Ogre::D3DSMSCONFLICT_T,std::allocator<Ogre::D3DSMSCONFLICT_T> >::_Buy
PUBLIC	??0?$_Vector_val@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@IAE@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@1@@Z ; std::_Vector_val<Ogre::D3DSMSCONFLICT_T,std::allocator<Ogre::D3DSMSCONFLICT_T> >::_Vector_val<Ogre::D3DSMSCONFLICT_T,std::allocator<Ogre::D3DSMSCONFLICT_T> >
PUBLIC	??0?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@QAE@XZ ; std::allocator<Ogre::D3DSMSCONFLICT_T>::allocator<Ogre::D3DSMSCONFLICT_T>
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$vector@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??0?$vector@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$vector@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$vector@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T141661 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0?$vector@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@QAE@XZ PROC ; std::vector<Ogre::D3DSMSCONFLICT_T,std::allocator<Ogre::D3DSMSCONFLICT_T> >::vector<Ogre::D3DSMSCONFLICT_T,std::allocator<Ogre::D3DSMSCONFLICT_T> >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$vector@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T141661[ebp], esp
	call	??0?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@QAE@XZ ; std::allocator<Ogre::D3DSMSCONFLICT_T>::allocator<Ogre::D3DSMSCONFLICT_T>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_val@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@IAE@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@1@@Z ; std::_Vector_val<Ogre::D3DSMSCONFLICT_T,std::allocator<Ogre::D3DSMSCONFLICT_T> >::_Vector_val<Ogre::D3DSMSCONFLICT_T,std::allocator<Ogre::D3DSMSCONFLICT_T> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 471  : 		_Buy(0);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@IAE_NI@Z ; std::vector<Ogre::D3DSMSCONFLICT_T,std::allocator<Ogre::D3DSMSCONFLICT_T> >::_Buy

; 472  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@QAE@XZ
__ehhandler$??0?$vector@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@QAE@XZ ENDP ; std::vector<Ogre::D3DSMSCONFLICT_T,std::allocator<Ogre::D3DSMSCONFLICT_T> >::vector<Ogre::D3DSMSCONFLICT_T,std::allocator<Ogre::D3DSMSCONFLICT_T> >
PUBLIC	?_Tidy@?$vector@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@IAEXXZ ; std::vector<Ogre::D3DSMSCONFLICT_T,std::allocator<Ogre::D3DSMSCONFLICT_T> >::_Tidy
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$vector@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$vector@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$vector@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$vector@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$vector@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$vector@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@QAE@XZ PROC ; std::vector<Ogre::D3DSMSCONFLICT_T,std::allocator<Ogre::D3DSMSCONFLICT_T> >::~vector<Ogre::D3DSMSCONFLICT_T,std::allocator<Ogre::D3DSMSCONFLICT_T> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$vector@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 559  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@IAEXXZ ; std::vector<Ogre::D3DSMSCONFLICT_T,std::allocator<Ogre::D3DSMSCONFLICT_T> >::_Tidy

; 560  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Vector_val@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$vector@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@QAE@XZ
__ehhandler$??1?$vector@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$vector@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$vector@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@QAE@XZ ENDP ; std::vector<Ogre::D3DSMSCONFLICT_T,std::allocator<Ogre::D3DSMSCONFLICT_T> >::~vector<Ogre::D3DSMSCONFLICT_T,std::allocator<Ogre::D3DSMSCONFLICT_T> >
; Function compile flags: /Odtp
;	COMDAT ?size@?$vector@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$vector@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@QBEIXZ PROC ; std::vector<Ogre::D3DSMSCONFLICT_T,std::allocator<Ogre::D3DSMSCONFLICT_T> >::size, COMDAT
; _this$ = ecx

; 725  : 		{	// return length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+16]
	sub	eax, DWORD PTR [ecx+12]
	sar	eax, 3

; 727  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?size@?$vector@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@QBEIXZ ENDP ; std::vector<Ogre::D3DSMSCONFLICT_T,std::allocator<Ogre::D3DSMSCONFLICT_T> >::size
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??A?$vector@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@QAEAAUD3DSMSCONFLICT_T@Ogre@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pos$ = 8						; size = 4
??A?$vector@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@QAEAAUD3DSMSCONFLICT_T@Ogre@@I@Z PROC ; std::vector<Ogre::D3DSMSCONFLICT_T,std::allocator<Ogre::D3DSMSCONFLICT_T> >::operator[], COMDAT
; _this$ = ecx

; 774  : 		{	// subscript mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)
; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");
; 780  : 			_SCL_SECURE_OUT_OF_RANGE;
; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::D3DSMSCONFLICT_T,std::allocator<Ogre::D3DSMSCONFLICT_T> >::size
	cmp	DWORD PTR __Pos$[ebp], eax
	jb	SHORT $LN1@operator@3
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN1@operator@3:

; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR __Pos$[ebp]
	lea	eax, DWORD PTR [ecx+edx*8]

; 786  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??A?$vector@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@QAEAAUD3DSMSCONFLICT_T@Ogre@@I@Z ENDP ; std::vector<Ogre::D3DSMSCONFLICT_T,std::allocator<Ogre::D3DSMSCONFLICT_T> >::operator[]
_TEXT	ENDS
PUBLIC	?insert@?$vector@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@2@V?$_Vector_const_iterator@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@2@ABUD3DSMSCONFLICT_T@Ogre@@@Z ; std::vector<Ogre::D3DSMSCONFLICT_T,std::allocator<Ogre::D3DSMSCONFLICT_T> >::insert
PUBLIC	?end@?$vector@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@2@XZ ; std::vector<Ogre::D3DSMSCONFLICT_T,std::allocator<Ogre::D3DSMSCONFLICT_T> >::end
PUBLIC	?_Ufill@?$vector@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@IAEPAUD3DSMSCONFLICT_T@Ogre@@PAU34@IABU34@@Z ; std::vector<Ogre::D3DSMSCONFLICT_T,std::allocator<Ogre::D3DSMSCONFLICT_T> >::_Ufill
PUBLIC	?capacity@?$vector@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::D3DSMSCONFLICT_T,std::allocator<Ogre::D3DSMSCONFLICT_T> >::capacity
; Function compile flags: /Odtp
;	COMDAT ?push_back@?$vector@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@QAEXABUD3DSMSCONFLICT_T@Ogre@@@Z
_TEXT	SEGMENT
_this$ = -28						; size = 4
$T141686 = -24						; size = 8
$T141685 = -16						; size = 8
$T141684 = -8						; size = 8
__Val$ = 8						; size = 4
?push_back@?$vector@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@QAEXABUD3DSMSCONFLICT_T@Ogre@@@Z PROC ; std::vector<Ogre::D3DSMSCONFLICT_T,std::allocator<Ogre::D3DSMSCONFLICT_T> >::push_back, COMDAT
; _this$ = ecx

; 809  : 		{	// insert element at end

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 810  : 		if (size() < capacity())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::D3DSMSCONFLICT_T,std::allocator<Ogre::D3DSMSCONFLICT_T> >::size
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?capacity@?$vector@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::D3DSMSCONFLICT_T,std::allocator<Ogre::D3DSMSCONFLICT_T> >::capacity
	cmp	esi, eax
	jae	SHORT $LN2@push_back@4

; 811  : 
; 812  :  #if _HAS_ITERATOR_DEBUGGING
; 813  : 			{ // room at end, construct it there
; 814  : 			_Orphan_range(_Mylast, _Mylast);
; 815  : 			_Mylast = _Ufill(_Mylast, 1, _Val);
; 816  : 			}
; 817  : 
; 818  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 819  : 			_Mylast = _Ufill(_Mylast, 1, _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Ufill@?$vector@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@IAEPAUD3DSMSCONFLICT_T@Ogre@@PAU34@IABU34@@Z ; std::vector<Ogre::D3DSMSCONFLICT_T,std::allocator<Ogre::D3DSMSCONFLICT_T> >::_Ufill
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 820  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 821  : 
; 822  : 		else

	jmp	SHORT $LN3@push_back@4
$LN2@push_back@4:

; 823  : 			insert(end(), _Val);

	lea	edx, DWORD PTR $T141685[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$vector@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@2@XZ ; std::vector<Ogre::D3DSMSCONFLICT_T,std::allocator<Ogre::D3DSMSCONFLICT_T> >::end
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T141684[ebp], ecx
	mov	DWORD PTR $T141684[ebp+4], edx
	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T141684[ebp+4]
	push	ecx
	mov	edx, DWORD PTR $T141684[ebp]
	push	edx
	lea	eax, DWORD PTR $T141686[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?insert@?$vector@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@2@V?$_Vector_const_iterator@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@2@ABUD3DSMSCONFLICT_T@Ogre@@@Z ; std::vector<Ogre::D3DSMSCONFLICT_T,std::allocator<Ogre::D3DSMSCONFLICT_T> >::insert
$LN3@push_back@4:

; 824  : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?push_back@?$vector@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@QAEXABUD3DSMSCONFLICT_T@Ogre@@@Z ENDP ; std::vector<Ogre::D3DSMSCONFLICT_T,std::allocator<Ogre::D3DSMSCONFLICT_T> >::push_back
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@QAE@XZ ; std::_Vector_val<enum Ogre::VERTPROCESS_T,std::allocator<enum Ogre::VERTPROCESS_T> >::~_Vector_val<enum Ogre::VERTPROCESS_T,std::allocator<enum Ogre::VERTPROCESS_T> >
PUBLIC	?_Buy@?$vector@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@IAE_NI@Z ; std::vector<enum Ogre::VERTPROCESS_T,std::allocator<enum Ogre::VERTPROCESS_T> >::_Buy
PUBLIC	??0?$_Vector_val@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@IAE@V?$allocator@W4VERTPROCESS_T@Ogre@@@1@@Z ; std::_Vector_val<enum Ogre::VERTPROCESS_T,std::allocator<enum Ogre::VERTPROCESS_T> >::_Vector_val<enum Ogre::VERTPROCESS_T,std::allocator<enum Ogre::VERTPROCESS_T> >
PUBLIC	??0?$allocator@W4VERTPROCESS_T@Ogre@@@std@@QAE@XZ ; std::allocator<enum Ogre::VERTPROCESS_T>::allocator<enum Ogre::VERTPROCESS_T>
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$vector@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??0?$vector@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$vector@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$vector@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T141689 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0?$vector@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@QAE@XZ PROC ; std::vector<enum Ogre::VERTPROCESS_T,std::allocator<enum Ogre::VERTPROCESS_T> >::vector<enum Ogre::VERTPROCESS_T,std::allocator<enum Ogre::VERTPROCESS_T> >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$vector@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T141689[ebp], esp
	call	??0?$allocator@W4VERTPROCESS_T@Ogre@@@std@@QAE@XZ ; std::allocator<enum Ogre::VERTPROCESS_T>::allocator<enum Ogre::VERTPROCESS_T>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_val@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@IAE@V?$allocator@W4VERTPROCESS_T@Ogre@@@1@@Z ; std::_Vector_val<enum Ogre::VERTPROCESS_T,std::allocator<enum Ogre::VERTPROCESS_T> >::_Vector_val<enum Ogre::VERTPROCESS_T,std::allocator<enum Ogre::VERTPROCESS_T> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 471  : 		_Buy(0);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@IAE_NI@Z ; std::vector<enum Ogre::VERTPROCESS_T,std::allocator<enum Ogre::VERTPROCESS_T> >::_Buy

; 472  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@QAE@XZ
__ehhandler$??0?$vector@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@QAE@XZ ENDP ; std::vector<enum Ogre::VERTPROCESS_T,std::allocator<enum Ogre::VERTPROCESS_T> >::vector<enum Ogre::VERTPROCESS_T,std::allocator<enum Ogre::VERTPROCESS_T> >
PUBLIC	?_Tidy@?$vector@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@IAEXXZ ; std::vector<enum Ogre::VERTPROCESS_T,std::allocator<enum Ogre::VERTPROCESS_T> >::_Tidy
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$vector@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$vector@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$vector@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$vector@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$vector@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$vector@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@QAE@XZ PROC ; std::vector<enum Ogre::VERTPROCESS_T,std::allocator<enum Ogre::VERTPROCESS_T> >::~vector<enum Ogre::VERTPROCESS_T,std::allocator<enum Ogre::VERTPROCESS_T> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$vector@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 559  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@IAEXXZ ; std::vector<enum Ogre::VERTPROCESS_T,std::allocator<enum Ogre::VERTPROCESS_T> >::_Tidy

; 560  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Vector_val@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$vector@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@QAE@XZ
__ehhandler$??1?$vector@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$vector@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$vector@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@QAE@XZ ENDP ; std::vector<enum Ogre::VERTPROCESS_T,std::allocator<enum Ogre::VERTPROCESS_T> >::~vector<enum Ogre::VERTPROCESS_T,std::allocator<enum Ogre::VERTPROCESS_T> >
PUBLIC	?size@?$vector@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@QBEIXZ ; std::vector<enum Ogre::VERTPROCESS_T,std::allocator<enum Ogre::VERTPROCESS_T> >::size
; Function compile flags: /Odtp
;	COMDAT ?empty@?$vector@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?empty@?$vector@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@QBE_NXZ PROC ; std::vector<enum Ogre::VERTPROCESS_T,std::allocator<enum Ogre::VERTPROCESS_T> >::empty, COMDAT
; _this$ = ecx

; 735  : 		{	// test if sequence is empty

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 736  : 		return (size() == 0);

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@QBEIXZ ; std::vector<enum Ogre::VERTPROCESS_T,std::allocator<enum Ogre::VERTPROCESS_T> >::size
	neg	eax
	sbb	eax, eax
	add	eax, 1

; 737  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?empty@?$vector@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@QBE_NXZ ENDP ; std::vector<enum Ogre::VERTPROCESS_T,std::allocator<enum Ogre::VERTPROCESS_T> >::empty
_TEXT	ENDS
PUBLIC	?insert@?$vector@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@2@V?$_Vector_const_iterator@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@2@ABW4VERTPROCESS_T@Ogre@@@Z ; std::vector<enum Ogre::VERTPROCESS_T,std::allocator<enum Ogre::VERTPROCESS_T> >::insert
PUBLIC	?end@?$vector@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@2@XZ ; std::vector<enum Ogre::VERTPROCESS_T,std::allocator<enum Ogre::VERTPROCESS_T> >::end
PUBLIC	?_Ufill@?$vector@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@IAEPAW4VERTPROCESS_T@Ogre@@PAW434@IABW434@@Z ; std::vector<enum Ogre::VERTPROCESS_T,std::allocator<enum Ogre::VERTPROCESS_T> >::_Ufill
PUBLIC	?capacity@?$vector@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@QBEIXZ ; std::vector<enum Ogre::VERTPROCESS_T,std::allocator<enum Ogre::VERTPROCESS_T> >::capacity
; Function compile flags: /Odtp
;	COMDAT ?push_back@?$vector@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@QAEXABW4VERTPROCESS_T@Ogre@@@Z
_TEXT	SEGMENT
_this$ = -28						; size = 4
$T141712 = -24						; size = 8
$T141711 = -16						; size = 8
$T141710 = -8						; size = 8
__Val$ = 8						; size = 4
?push_back@?$vector@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@QAEXABW4VERTPROCESS_T@Ogre@@@Z PROC ; std::vector<enum Ogre::VERTPROCESS_T,std::allocator<enum Ogre::VERTPROCESS_T> >::push_back, COMDAT
; _this$ = ecx

; 809  : 		{	// insert element at end

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 810  : 		if (size() < capacity())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@QBEIXZ ; std::vector<enum Ogre::VERTPROCESS_T,std::allocator<enum Ogre::VERTPROCESS_T> >::size
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?capacity@?$vector@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@QBEIXZ ; std::vector<enum Ogre::VERTPROCESS_T,std::allocator<enum Ogre::VERTPROCESS_T> >::capacity
	cmp	esi, eax
	jae	SHORT $LN2@push_back@5

; 811  : 
; 812  :  #if _HAS_ITERATOR_DEBUGGING
; 813  : 			{ // room at end, construct it there
; 814  : 			_Orphan_range(_Mylast, _Mylast);
; 815  : 			_Mylast = _Ufill(_Mylast, 1, _Val);
; 816  : 			}
; 817  : 
; 818  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 819  : 			_Mylast = _Ufill(_Mylast, 1, _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Ufill@?$vector@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@IAEPAW4VERTPROCESS_T@Ogre@@PAW434@IABW434@@Z ; std::vector<enum Ogre::VERTPROCESS_T,std::allocator<enum Ogre::VERTPROCESS_T> >::_Ufill
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 820  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 821  : 
; 822  : 		else

	jmp	SHORT $LN3@push_back@5
$LN2@push_back@5:

; 823  : 			insert(end(), _Val);

	lea	edx, DWORD PTR $T141711[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$vector@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@2@XZ ; std::vector<enum Ogre::VERTPROCESS_T,std::allocator<enum Ogre::VERTPROCESS_T> >::end
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T141710[ebp], ecx
	mov	DWORD PTR $T141710[ebp+4], edx
	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T141710[ebp+4]
	push	ecx
	mov	edx, DWORD PTR $T141710[ebp]
	push	edx
	lea	eax, DWORD PTR $T141712[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?insert@?$vector@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@2@V?$_Vector_const_iterator@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@2@ABW4VERTPROCESS_T@Ogre@@@Z ; std::vector<enum Ogre::VERTPROCESS_T,std::allocator<enum Ogre::VERTPROCESS_T> >::insert
$LN3@push_back@5:

; 824  : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?push_back@?$vector@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@QAEXABW4VERTPROCESS_T@Ogre@@@Z ENDP ; std::vector<enum Ogre::VERTPROCESS_T,std::allocator<enum Ogre::VERTPROCESS_T> >::push_back
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@QAE@XZ ; std::_Vector_val<Ogre::D3DDEVCOMBO_T *,std::allocator<Ogre::D3DDEVCOMBO_T *> >::~_Vector_val<Ogre::D3DDEVCOMBO_T *,std::allocator<Ogre::D3DDEVCOMBO_T *> >
PUBLIC	?_Buy@?$vector@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@IAE_NI@Z ; std::vector<Ogre::D3DDEVCOMBO_T *,std::allocator<Ogre::D3DDEVCOMBO_T *> >::_Buy
PUBLIC	??0?$_Vector_val@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@IAE@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@1@@Z ; std::_Vector_val<Ogre::D3DDEVCOMBO_T *,std::allocator<Ogre::D3DDEVCOMBO_T *> >::_Vector_val<Ogre::D3DDEVCOMBO_T *,std::allocator<Ogre::D3DDEVCOMBO_T *> >
PUBLIC	??0?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@QAE@XZ ; std::allocator<Ogre::D3DDEVCOMBO_T *>::allocator<Ogre::D3DDEVCOMBO_T *>
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$vector@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??0?$vector@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$vector@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$vector@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T141715 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0?$vector@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@QAE@XZ PROC ; std::vector<Ogre::D3DDEVCOMBO_T *,std::allocator<Ogre::D3DDEVCOMBO_T *> >::vector<Ogre::D3DDEVCOMBO_T *,std::allocator<Ogre::D3DDEVCOMBO_T *> >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$vector@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T141715[ebp], esp
	call	??0?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@QAE@XZ ; std::allocator<Ogre::D3DDEVCOMBO_T *>::allocator<Ogre::D3DDEVCOMBO_T *>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_val@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@IAE@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@1@@Z ; std::_Vector_val<Ogre::D3DDEVCOMBO_T *,std::allocator<Ogre::D3DDEVCOMBO_T *> >::_Vector_val<Ogre::D3DDEVCOMBO_T *,std::allocator<Ogre::D3DDEVCOMBO_T *> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 471  : 		_Buy(0);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@IAE_NI@Z ; std::vector<Ogre::D3DDEVCOMBO_T *,std::allocator<Ogre::D3DDEVCOMBO_T *> >::_Buy

; 472  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@QAE@XZ
__ehhandler$??0?$vector@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@QAE@XZ ENDP ; std::vector<Ogre::D3DDEVCOMBO_T *,std::allocator<Ogre::D3DDEVCOMBO_T *> >::vector<Ogre::D3DDEVCOMBO_T *,std::allocator<Ogre::D3DDEVCOMBO_T *> >
PUBLIC	?_Tidy@?$vector@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@IAEXXZ ; std::vector<Ogre::D3DDEVCOMBO_T *,std::allocator<Ogre::D3DDEVCOMBO_T *> >::_Tidy
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$vector@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$vector@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$vector@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$vector@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$vector@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$vector@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@QAE@XZ PROC ; std::vector<Ogre::D3DDEVCOMBO_T *,std::allocator<Ogre::D3DDEVCOMBO_T *> >::~vector<Ogre::D3DDEVCOMBO_T *,std::allocator<Ogre::D3DDEVCOMBO_T *> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$vector@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 559  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@IAEXXZ ; std::vector<Ogre::D3DDEVCOMBO_T *,std::allocator<Ogre::D3DDEVCOMBO_T *> >::_Tidy

; 560  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Vector_val@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$vector@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@QAE@XZ
__ehhandler$??1?$vector@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$vector@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$vector@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@QAE@XZ ENDP ; std::vector<Ogre::D3DDEVCOMBO_T *,std::allocator<Ogre::D3DDEVCOMBO_T *> >::~vector<Ogre::D3DDEVCOMBO_T *,std::allocator<Ogre::D3DDEVCOMBO_T *> >
; Function compile flags: /Odtp
;	COMDAT ?size@?$vector@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$vector@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@QBEIXZ PROC ; std::vector<Ogre::D3DDEVCOMBO_T *,std::allocator<Ogre::D3DDEVCOMBO_T *> >::size, COMDAT
; _this$ = ecx

; 725  : 		{	// return length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+16]
	sub	eax, DWORD PTR [ecx+12]
	sar	eax, 2

; 727  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?size@?$vector@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@QBEIXZ ENDP ; std::vector<Ogre::D3DDEVCOMBO_T *,std::allocator<Ogre::D3DDEVCOMBO_T *> >::size
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?empty@?$vector@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?empty@?$vector@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@QBE_NXZ PROC ; std::vector<Ogre::D3DDEVCOMBO_T *,std::allocator<Ogre::D3DDEVCOMBO_T *> >::empty, COMDAT
; _this$ = ecx

; 735  : 		{	// test if sequence is empty

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 736  : 		return (size() == 0);

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::D3DDEVCOMBO_T *,std::allocator<Ogre::D3DDEVCOMBO_T *> >::size
	neg	eax
	sbb	eax, eax
	add	eax, 1

; 737  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?empty@?$vector@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@QBE_NXZ ENDP ; std::vector<Ogre::D3DDEVCOMBO_T *,std::allocator<Ogre::D3DDEVCOMBO_T *> >::empty
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??A?$vector@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@QAEAAPAUD3DDEVCOMBO_T@Ogre@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pos$ = 8						; size = 4
??A?$vector@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@QAEAAPAUD3DDEVCOMBO_T@Ogre@@I@Z PROC ; std::vector<Ogre::D3DDEVCOMBO_T *,std::allocator<Ogre::D3DDEVCOMBO_T *> >::operator[], COMDAT
; _this$ = ecx

; 774  : 		{	// subscript mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)
; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");
; 780  : 			_SCL_SECURE_OUT_OF_RANGE;
; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::D3DDEVCOMBO_T *,std::allocator<Ogre::D3DDEVCOMBO_T *> >::size
	cmp	DWORD PTR __Pos$[ebp], eax
	jb	SHORT $LN1@operator@4
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN1@operator@4:

; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR __Pos$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]

; 786  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??A?$vector@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@QAEAAPAUD3DDEVCOMBO_T@Ogre@@I@Z ENDP ; std::vector<Ogre::D3DDEVCOMBO_T *,std::allocator<Ogre::D3DDEVCOMBO_T *> >::operator[]
_TEXT	ENDS
PUBLIC	?insert@?$vector@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@2@ABQAUD3DDEVCOMBO_T@Ogre@@@Z ; std::vector<Ogre::D3DDEVCOMBO_T *,std::allocator<Ogre::D3DDEVCOMBO_T *> >::insert
PUBLIC	?end@?$vector@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@2@XZ ; std::vector<Ogre::D3DDEVCOMBO_T *,std::allocator<Ogre::D3DDEVCOMBO_T *> >::end
PUBLIC	?_Ufill@?$vector@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@IAEPAPAUD3DDEVCOMBO_T@Ogre@@PAPAU34@IABQAU34@@Z ; std::vector<Ogre::D3DDEVCOMBO_T *,std::allocator<Ogre::D3DDEVCOMBO_T *> >::_Ufill
PUBLIC	?capacity@?$vector@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::D3DDEVCOMBO_T *,std::allocator<Ogre::D3DDEVCOMBO_T *> >::capacity
; Function compile flags: /Odtp
;	COMDAT ?push_back@?$vector@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@QAEXABQAUD3DDEVCOMBO_T@Ogre@@@Z
_TEXT	SEGMENT
_this$ = -28						; size = 4
$T141742 = -24						; size = 8
$T141741 = -16						; size = 8
$T141740 = -8						; size = 8
__Val$ = 8						; size = 4
?push_back@?$vector@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@QAEXABQAUD3DDEVCOMBO_T@Ogre@@@Z PROC ; std::vector<Ogre::D3DDEVCOMBO_T *,std::allocator<Ogre::D3DDEVCOMBO_T *> >::push_back, COMDAT
; _this$ = ecx

; 809  : 		{	// insert element at end

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 810  : 		if (size() < capacity())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::D3DDEVCOMBO_T *,std::allocator<Ogre::D3DDEVCOMBO_T *> >::size
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?capacity@?$vector@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::D3DDEVCOMBO_T *,std::allocator<Ogre::D3DDEVCOMBO_T *> >::capacity
	cmp	esi, eax
	jae	SHORT $LN2@push_back@6

; 811  : 
; 812  :  #if _HAS_ITERATOR_DEBUGGING
; 813  : 			{ // room at end, construct it there
; 814  : 			_Orphan_range(_Mylast, _Mylast);
; 815  : 			_Mylast = _Ufill(_Mylast, 1, _Val);
; 816  : 			}
; 817  : 
; 818  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 819  : 			_Mylast = _Ufill(_Mylast, 1, _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Ufill@?$vector@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@IAEPAPAUD3DDEVCOMBO_T@Ogre@@PAPAU34@IABQAU34@@Z ; std::vector<Ogre::D3DDEVCOMBO_T *,std::allocator<Ogre::D3DDEVCOMBO_T *> >::_Ufill
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 820  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 821  : 
; 822  : 		else

	jmp	SHORT $LN3@push_back@6
$LN2@push_back@6:

; 823  : 			insert(end(), _Val);

	lea	edx, DWORD PTR $T141741[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$vector@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@2@XZ ; std::vector<Ogre::D3DDEVCOMBO_T *,std::allocator<Ogre::D3DDEVCOMBO_T *> >::end
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T141740[ebp], ecx
	mov	DWORD PTR $T141740[ebp+4], edx
	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T141740[ebp+4]
	push	ecx
	mov	edx, DWORD PTR $T141740[ebp]
	push	edx
	lea	eax, DWORD PTR $T141742[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?insert@?$vector@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@2@ABQAUD3DDEVCOMBO_T@Ogre@@@Z ; std::vector<Ogre::D3DDEVCOMBO_T *,std::allocator<Ogre::D3DDEVCOMBO_T *> >::insert
$LN3@push_back@6:

; 824  : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?push_back@?$vector@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@QAEXABQAUD3DDEVCOMBO_T@Ogre@@@Z ENDP ; std::vector<Ogre::D3DDEVCOMBO_T *,std::allocator<Ogre::D3DDEVCOMBO_T *> >::push_back
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@QAE@XZ ; std::_Vector_val<_D3DDISPLAYMODE,std::allocator<_D3DDISPLAYMODE> >::~_Vector_val<_D3DDISPLAYMODE,std::allocator<_D3DDISPLAYMODE> >
PUBLIC	?_Buy@?$vector@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@IAE_NI@Z ; std::vector<_D3DDISPLAYMODE,std::allocator<_D3DDISPLAYMODE> >::_Buy
PUBLIC	??0?$_Vector_val@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@IAE@V?$allocator@U_D3DDISPLAYMODE@@@1@@Z ; std::_Vector_val<_D3DDISPLAYMODE,std::allocator<_D3DDISPLAYMODE> >::_Vector_val<_D3DDISPLAYMODE,std::allocator<_D3DDISPLAYMODE> >
PUBLIC	??0?$allocator@U_D3DDISPLAYMODE@@@std@@QAE@XZ	; std::allocator<_D3DDISPLAYMODE>::allocator<_D3DDISPLAYMODE>
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$vector@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??0?$vector@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$vector@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$vector@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T141745 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0?$vector@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@QAE@XZ PROC ; std::vector<_D3DDISPLAYMODE,std::allocator<_D3DDISPLAYMODE> >::vector<_D3DDISPLAYMODE,std::allocator<_D3DDISPLAYMODE> >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$vector@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T141745[ebp], esp
	call	??0?$allocator@U_D3DDISPLAYMODE@@@std@@QAE@XZ ; std::allocator<_D3DDISPLAYMODE>::allocator<_D3DDISPLAYMODE>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_val@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@IAE@V?$allocator@U_D3DDISPLAYMODE@@@1@@Z ; std::_Vector_val<_D3DDISPLAYMODE,std::allocator<_D3DDISPLAYMODE> >::_Vector_val<_D3DDISPLAYMODE,std::allocator<_D3DDISPLAYMODE> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 471  : 		_Buy(0);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@IAE_NI@Z ; std::vector<_D3DDISPLAYMODE,std::allocator<_D3DDISPLAYMODE> >::_Buy

; 472  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@QAE@XZ
__ehhandler$??0?$vector@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@QAE@XZ ENDP ; std::vector<_D3DDISPLAYMODE,std::allocator<_D3DDISPLAYMODE> >::vector<_D3DDISPLAYMODE,std::allocator<_D3DDISPLAYMODE> >
PUBLIC	?_Tidy@?$vector@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@IAEXXZ ; std::vector<_D3DDISPLAYMODE,std::allocator<_D3DDISPLAYMODE> >::_Tidy
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$vector@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$vector@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$vector@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$vector@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$vector@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$vector@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@QAE@XZ PROC ; std::vector<_D3DDISPLAYMODE,std::allocator<_D3DDISPLAYMODE> >::~vector<_D3DDISPLAYMODE,std::allocator<_D3DDISPLAYMODE> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$vector@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 559  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@IAEXXZ ; std::vector<_D3DDISPLAYMODE,std::allocator<_D3DDISPLAYMODE> >::_Tidy

; 560  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Vector_val@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$vector@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@QAE@XZ
__ehhandler$??1?$vector@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$vector@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$vector@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@QAE@XZ ENDP ; std::vector<_D3DDISPLAYMODE,std::allocator<_D3DDISPLAYMODE> >::~vector<_D3DDISPLAYMODE,std::allocator<_D3DDISPLAYMODE> >
; Function compile flags: /Odtp
;	COMDAT ?size@?$vector@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$vector@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@QBEIXZ PROC ; std::vector<_D3DDISPLAYMODE,std::allocator<_D3DDISPLAYMODE> >::size, COMDAT
; _this$ = ecx

; 725  : 		{	// return length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+16]
	sub	eax, DWORD PTR [ecx+12]
	sar	eax, 4

; 727  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?size@?$vector@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@QBEIXZ ENDP ; std::vector<_D3DDISPLAYMODE,std::allocator<_D3DDISPLAYMODE> >::size
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??A?$vector@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@QAEAAU_D3DDISPLAYMODE@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pos$ = 8						; size = 4
??A?$vector@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@QAEAAU_D3DDISPLAYMODE@@I@Z PROC ; std::vector<_D3DDISPLAYMODE,std::allocator<_D3DDISPLAYMODE> >::operator[], COMDAT
; _this$ = ecx

; 774  : 		{	// subscript mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)
; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");
; 780  : 			_SCL_SECURE_OUT_OF_RANGE;
; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@QBEIXZ ; std::vector<_D3DDISPLAYMODE,std::allocator<_D3DDISPLAYMODE> >::size
	cmp	DWORD PTR __Pos$[ebp], eax
	jb	SHORT $LN1@operator@5
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN1@operator@5:

; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR __Pos$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+12]

; 786  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??A?$vector@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@QAEAAU_D3DDISPLAYMODE@@I@Z ENDP ; std::vector<_D3DDISPLAYMODE,std::allocator<_D3DDISPLAYMODE> >::operator[]
_TEXT	ENDS
PUBLIC	?insert@?$vector@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@QAE?AV?$_Vector_iterator@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@2@V?$_Vector_const_iterator@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@2@ABU_D3DDISPLAYMODE@@@Z ; std::vector<_D3DDISPLAYMODE,std::allocator<_D3DDISPLAYMODE> >::insert
PUBLIC	?end@?$vector@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@QAE?AV?$_Vector_iterator@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@2@XZ ; std::vector<_D3DDISPLAYMODE,std::allocator<_D3DDISPLAYMODE> >::end
PUBLIC	?_Ufill@?$vector@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@IAEPAU_D3DDISPLAYMODE@@PAU3@IABU3@@Z ; std::vector<_D3DDISPLAYMODE,std::allocator<_D3DDISPLAYMODE> >::_Ufill
PUBLIC	?capacity@?$vector@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@QBEIXZ ; std::vector<_D3DDISPLAYMODE,std::allocator<_D3DDISPLAYMODE> >::capacity
; Function compile flags: /Odtp
;	COMDAT ?push_back@?$vector@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@QAEXABU_D3DDISPLAYMODE@@@Z
_TEXT	SEGMENT
_this$ = -28						; size = 4
$T141770 = -24						; size = 8
$T141769 = -16						; size = 8
$T141768 = -8						; size = 8
__Val$ = 8						; size = 4
?push_back@?$vector@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@QAEXABU_D3DDISPLAYMODE@@@Z PROC ; std::vector<_D3DDISPLAYMODE,std::allocator<_D3DDISPLAYMODE> >::push_back, COMDAT
; _this$ = ecx

; 809  : 		{	// insert element at end

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 810  : 		if (size() < capacity())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@QBEIXZ ; std::vector<_D3DDISPLAYMODE,std::allocator<_D3DDISPLAYMODE> >::size
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?capacity@?$vector@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@QBEIXZ ; std::vector<_D3DDISPLAYMODE,std::allocator<_D3DDISPLAYMODE> >::capacity
	cmp	esi, eax
	jae	SHORT $LN2@push_back@7

; 811  : 
; 812  :  #if _HAS_ITERATOR_DEBUGGING
; 813  : 			{ // room at end, construct it there
; 814  : 			_Orphan_range(_Mylast, _Mylast);
; 815  : 			_Mylast = _Ufill(_Mylast, 1, _Val);
; 816  : 			}
; 817  : 
; 818  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 819  : 			_Mylast = _Ufill(_Mylast, 1, _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Ufill@?$vector@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@IAEPAU_D3DDISPLAYMODE@@PAU3@IABU3@@Z ; std::vector<_D3DDISPLAYMODE,std::allocator<_D3DDISPLAYMODE> >::_Ufill
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 820  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 821  : 
; 822  : 		else

	jmp	SHORT $LN3@push_back@7
$LN2@push_back@7:

; 823  : 			insert(end(), _Val);

	lea	edx, DWORD PTR $T141769[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$vector@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@QAE?AV?$_Vector_iterator@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@2@XZ ; std::vector<_D3DDISPLAYMODE,std::allocator<_D3DDISPLAYMODE> >::end
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T141768[ebp], ecx
	mov	DWORD PTR $T141768[ebp+4], edx
	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T141768[ebp+4]
	push	ecx
	mov	edx, DWORD PTR $T141768[ebp]
	push	edx
	lea	eax, DWORD PTR $T141770[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?insert@?$vector@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@QAE?AV?$_Vector_iterator@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@2@V?$_Vector_const_iterator@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@2@ABU_D3DDISPLAYMODE@@@Z ; std::vector<_D3DDISPLAYMODE,std::allocator<_D3DDISPLAYMODE> >::insert
$LN3@push_back@7:

; 824  : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?push_back@?$vector@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@QAEXABU_D3DDISPLAYMODE@@@Z ENDP ; std::vector<_D3DDISPLAYMODE,std::allocator<_D3DDISPLAYMODE> >::push_back
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@QAE@XZ ; std::_Vector_val<Ogre::D3DDEVICEINFO_T *,std::allocator<Ogre::D3DDEVICEINFO_T *> >::~_Vector_val<Ogre::D3DDEVICEINFO_T *,std::allocator<Ogre::D3DDEVICEINFO_T *> >
PUBLIC	?_Buy@?$vector@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@IAE_NI@Z ; std::vector<Ogre::D3DDEVICEINFO_T *,std::allocator<Ogre::D3DDEVICEINFO_T *> >::_Buy
PUBLIC	??0?$_Vector_val@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@IAE@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@1@@Z ; std::_Vector_val<Ogre::D3DDEVICEINFO_T *,std::allocator<Ogre::D3DDEVICEINFO_T *> >::_Vector_val<Ogre::D3DDEVICEINFO_T *,std::allocator<Ogre::D3DDEVICEINFO_T *> >
PUBLIC	??0?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@QAE@XZ ; std::allocator<Ogre::D3DDEVICEINFO_T *>::allocator<Ogre::D3DDEVICEINFO_T *>
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$vector@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??0?$vector@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$vector@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$vector@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T141773 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0?$vector@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@QAE@XZ PROC ; std::vector<Ogre::D3DDEVICEINFO_T *,std::allocator<Ogre::D3DDEVICEINFO_T *> >::vector<Ogre::D3DDEVICEINFO_T *,std::allocator<Ogre::D3DDEVICEINFO_T *> >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$vector@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T141773[ebp], esp
	call	??0?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@QAE@XZ ; std::allocator<Ogre::D3DDEVICEINFO_T *>::allocator<Ogre::D3DDEVICEINFO_T *>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_val@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@IAE@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@1@@Z ; std::_Vector_val<Ogre::D3DDEVICEINFO_T *,std::allocator<Ogre::D3DDEVICEINFO_T *> >::_Vector_val<Ogre::D3DDEVICEINFO_T *,std::allocator<Ogre::D3DDEVICEINFO_T *> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 471  : 		_Buy(0);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@IAE_NI@Z ; std::vector<Ogre::D3DDEVICEINFO_T *,std::allocator<Ogre::D3DDEVICEINFO_T *> >::_Buy

; 472  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@QAE@XZ
__ehhandler$??0?$vector@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@QAE@XZ ENDP ; std::vector<Ogre::D3DDEVICEINFO_T *,std::allocator<Ogre::D3DDEVICEINFO_T *> >::vector<Ogre::D3DDEVICEINFO_T *,std::allocator<Ogre::D3DDEVICEINFO_T *> >
PUBLIC	?_Tidy@?$vector@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@IAEXXZ ; std::vector<Ogre::D3DDEVICEINFO_T *,std::allocator<Ogre::D3DDEVICEINFO_T *> >::_Tidy
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$vector@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$vector@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$vector@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$vector@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$vector@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$vector@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@QAE@XZ PROC ; std::vector<Ogre::D3DDEVICEINFO_T *,std::allocator<Ogre::D3DDEVICEINFO_T *> >::~vector<Ogre::D3DDEVICEINFO_T *,std::allocator<Ogre::D3DDEVICEINFO_T *> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$vector@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 559  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@IAEXXZ ; std::vector<Ogre::D3DDEVICEINFO_T *,std::allocator<Ogre::D3DDEVICEINFO_T *> >::_Tidy

; 560  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Vector_val@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$vector@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@QAE@XZ
__ehhandler$??1?$vector@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$vector@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$vector@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@QAE@XZ ENDP ; std::vector<Ogre::D3DDEVICEINFO_T *,std::allocator<Ogre::D3DDEVICEINFO_T *> >::~vector<Ogre::D3DDEVICEINFO_T *,std::allocator<Ogre::D3DDEVICEINFO_T *> >
; Function compile flags: /Odtp
;	COMDAT ?size@?$vector@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$vector@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@QBEIXZ PROC ; std::vector<Ogre::D3DDEVICEINFO_T *,std::allocator<Ogre::D3DDEVICEINFO_T *> >::size, COMDAT
; _this$ = ecx

; 725  : 		{	// return length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+16]
	sub	eax, DWORD PTR [ecx+12]
	sar	eax, 2

; 727  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?size@?$vector@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@QBEIXZ ENDP ; std::vector<Ogre::D3DDEVICEINFO_T *,std::allocator<Ogre::D3DDEVICEINFO_T *> >::size
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??A?$vector@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@QAEAAPAUD3DDEVICEINFO_T@Ogre@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pos$ = 8						; size = 4
??A?$vector@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@QAEAAPAUD3DDEVICEINFO_T@Ogre@@I@Z PROC ; std::vector<Ogre::D3DDEVICEINFO_T *,std::allocator<Ogre::D3DDEVICEINFO_T *> >::operator[], COMDAT
; _this$ = ecx

; 774  : 		{	// subscript mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)
; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");
; 780  : 			_SCL_SECURE_OUT_OF_RANGE;
; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::D3DDEVICEINFO_T *,std::allocator<Ogre::D3DDEVICEINFO_T *> >::size
	cmp	DWORD PTR __Pos$[ebp], eax
	jb	SHORT $LN1@operator@6
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN1@operator@6:

; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR __Pos$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]

; 786  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??A?$vector@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@QAEAAPAUD3DDEVICEINFO_T@Ogre@@I@Z ENDP ; std::vector<Ogre::D3DDEVICEINFO_T *,std::allocator<Ogre::D3DDEVICEINFO_T *> >::operator[]
_TEXT	ENDS
PUBLIC	?insert@?$vector@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@2@ABQAUD3DDEVICEINFO_T@Ogre@@@Z ; std::vector<Ogre::D3DDEVICEINFO_T *,std::allocator<Ogre::D3DDEVICEINFO_T *> >::insert
PUBLIC	?end@?$vector@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@2@XZ ; std::vector<Ogre::D3DDEVICEINFO_T *,std::allocator<Ogre::D3DDEVICEINFO_T *> >::end
PUBLIC	?_Ufill@?$vector@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@IAEPAPAUD3DDEVICEINFO_T@Ogre@@PAPAU34@IABQAU34@@Z ; std::vector<Ogre::D3DDEVICEINFO_T *,std::allocator<Ogre::D3DDEVICEINFO_T *> >::_Ufill
PUBLIC	?capacity@?$vector@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::D3DDEVICEINFO_T *,std::allocator<Ogre::D3DDEVICEINFO_T *> >::capacity
; Function compile flags: /Odtp
;	COMDAT ?push_back@?$vector@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@QAEXABQAUD3DDEVICEINFO_T@Ogre@@@Z
_TEXT	SEGMENT
_this$ = -28						; size = 4
$T141798 = -24						; size = 8
$T141797 = -16						; size = 8
$T141796 = -8						; size = 8
__Val$ = 8						; size = 4
?push_back@?$vector@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@QAEXABQAUD3DDEVICEINFO_T@Ogre@@@Z PROC ; std::vector<Ogre::D3DDEVICEINFO_T *,std::allocator<Ogre::D3DDEVICEINFO_T *> >::push_back, COMDAT
; _this$ = ecx

; 809  : 		{	// insert element at end

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 810  : 		if (size() < capacity())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::D3DDEVICEINFO_T *,std::allocator<Ogre::D3DDEVICEINFO_T *> >::size
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?capacity@?$vector@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::D3DDEVICEINFO_T *,std::allocator<Ogre::D3DDEVICEINFO_T *> >::capacity
	cmp	esi, eax
	jae	SHORT $LN2@push_back@8

; 811  : 
; 812  :  #if _HAS_ITERATOR_DEBUGGING
; 813  : 			{ // room at end, construct it there
; 814  : 			_Orphan_range(_Mylast, _Mylast);
; 815  : 			_Mylast = _Ufill(_Mylast, 1, _Val);
; 816  : 			}
; 817  : 
; 818  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 819  : 			_Mylast = _Ufill(_Mylast, 1, _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Ufill@?$vector@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@IAEPAPAUD3DDEVICEINFO_T@Ogre@@PAPAU34@IABQAU34@@Z ; std::vector<Ogre::D3DDEVICEINFO_T *,std::allocator<Ogre::D3DDEVICEINFO_T *> >::_Ufill
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 820  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 821  : 
; 822  : 		else

	jmp	SHORT $LN3@push_back@8
$LN2@push_back@8:

; 823  : 			insert(end(), _Val);

	lea	edx, DWORD PTR $T141797[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$vector@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@2@XZ ; std::vector<Ogre::D3DDEVICEINFO_T *,std::allocator<Ogre::D3DDEVICEINFO_T *> >::end
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T141796[ebp], ecx
	mov	DWORD PTR $T141796[ebp+4], edx
	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T141796[ebp+4]
	push	ecx
	mov	edx, DWORD PTR $T141796[ebp]
	push	edx
	lea	eax, DWORD PTR $T141798[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?insert@?$vector@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@2@ABQAUD3DDEVICEINFO_T@Ogre@@@Z ; std::vector<Ogre::D3DDEVICEINFO_T *,std::allocator<Ogre::D3DDEVICEINFO_T *> >::insert
$LN3@push_back@8:

; 824  : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?push_back@?$vector@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@QAEXABQAUD3DDEVICEINFO_T@Ogre@@@Z ENDP ; std::vector<Ogre::D3DDEVICEINFO_T *,std::allocator<Ogre::D3DDEVICEINFO_T *> >::push_back
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@QAE@XZ ; std::_Vector_val<Ogre::D3DADAPTER_T *,std::allocator<Ogre::D3DADAPTER_T *> >::~_Vector_val<Ogre::D3DADAPTER_T *,std::allocator<Ogre::D3DADAPTER_T *> >
PUBLIC	?_Buy@?$vector@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@IAE_NI@Z ; std::vector<Ogre::D3DADAPTER_T *,std::allocator<Ogre::D3DADAPTER_T *> >::_Buy
PUBLIC	??0?$_Vector_val@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@IAE@V?$allocator@PAUD3DADAPTER_T@Ogre@@@1@@Z ; std::_Vector_val<Ogre::D3DADAPTER_T *,std::allocator<Ogre::D3DADAPTER_T *> >::_Vector_val<Ogre::D3DADAPTER_T *,std::allocator<Ogre::D3DADAPTER_T *> >
PUBLIC	??0?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@QAE@XZ ; std::allocator<Ogre::D3DADAPTER_T *>::allocator<Ogre::D3DADAPTER_T *>
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$vector@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??0?$vector@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$vector@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$vector@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T141801 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0?$vector@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@QAE@XZ PROC ; std::vector<Ogre::D3DADAPTER_T *,std::allocator<Ogre::D3DADAPTER_T *> >::vector<Ogre::D3DADAPTER_T *,std::allocator<Ogre::D3DADAPTER_T *> >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$vector@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T141801[ebp], esp
	call	??0?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@QAE@XZ ; std::allocator<Ogre::D3DADAPTER_T *>::allocator<Ogre::D3DADAPTER_T *>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_val@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@IAE@V?$allocator@PAUD3DADAPTER_T@Ogre@@@1@@Z ; std::_Vector_val<Ogre::D3DADAPTER_T *,std::allocator<Ogre::D3DADAPTER_T *> >::_Vector_val<Ogre::D3DADAPTER_T *,std::allocator<Ogre::D3DADAPTER_T *> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 471  : 		_Buy(0);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@IAE_NI@Z ; std::vector<Ogre::D3DADAPTER_T *,std::allocator<Ogre::D3DADAPTER_T *> >::_Buy

; 472  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@QAE@XZ
__ehhandler$??0?$vector@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@QAE@XZ ENDP ; std::vector<Ogre::D3DADAPTER_T *,std::allocator<Ogre::D3DADAPTER_T *> >::vector<Ogre::D3DADAPTER_T *,std::allocator<Ogre::D3DADAPTER_T *> >
PUBLIC	?_Tidy@?$vector@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@IAEXXZ ; std::vector<Ogre::D3DADAPTER_T *,std::allocator<Ogre::D3DADAPTER_T *> >::_Tidy
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$vector@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$vector@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$vector@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$vector@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$vector@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$vector@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@QAE@XZ PROC ; std::vector<Ogre::D3DADAPTER_T *,std::allocator<Ogre::D3DADAPTER_T *> >::~vector<Ogre::D3DADAPTER_T *,std::allocator<Ogre::D3DADAPTER_T *> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$vector@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 559  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@IAEXXZ ; std::vector<Ogre::D3DADAPTER_T *,std::allocator<Ogre::D3DADAPTER_T *> >::_Tidy

; 560  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Vector_val@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$vector@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@QAE@XZ
__ehhandler$??1?$vector@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$vector@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$vector@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@QAE@XZ ENDP ; std::vector<Ogre::D3DADAPTER_T *,std::allocator<Ogre::D3DADAPTER_T *> >::~vector<Ogre::D3DADAPTER_T *,std::allocator<Ogre::D3DADAPTER_T *> >
; Function compile flags: /Odtp
;	COMDAT ?size@?$vector@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$vector@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@QBEIXZ PROC ; std::vector<Ogre::D3DADAPTER_T *,std::allocator<Ogre::D3DADAPTER_T *> >::size, COMDAT
; _this$ = ecx

; 725  : 		{	// return length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+16]
	sub	eax, DWORD PTR [ecx+12]
	sar	eax, 2

; 727  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?size@?$vector@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@QBEIXZ ENDP ; std::vector<Ogre::D3DADAPTER_T *,std::allocator<Ogre::D3DADAPTER_T *> >::size
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??A?$vector@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@QAEAAPAUD3DADAPTER_T@Ogre@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pos$ = 8						; size = 4
??A?$vector@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@QAEAAPAUD3DADAPTER_T@Ogre@@I@Z PROC ; std::vector<Ogre::D3DADAPTER_T *,std::allocator<Ogre::D3DADAPTER_T *> >::operator[], COMDAT
; _this$ = ecx

; 774  : 		{	// subscript mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)
; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");
; 780  : 			_SCL_SECURE_OUT_OF_RANGE;
; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::D3DADAPTER_T *,std::allocator<Ogre::D3DADAPTER_T *> >::size
	cmp	DWORD PTR __Pos$[ebp], eax
	jb	SHORT $LN1@operator@7
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN1@operator@7:

; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR __Pos$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]

; 786  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??A?$vector@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@QAEAAPAUD3DADAPTER_T@Ogre@@I@Z ENDP ; std::vector<Ogre::D3DADAPTER_T *,std::allocator<Ogre::D3DADAPTER_T *> >::operator[]
_TEXT	ENDS
PUBLIC	?insert@?$vector@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@2@ABQAUD3DADAPTER_T@Ogre@@@Z ; std::vector<Ogre::D3DADAPTER_T *,std::allocator<Ogre::D3DADAPTER_T *> >::insert
PUBLIC	?end@?$vector@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@2@XZ ; std::vector<Ogre::D3DADAPTER_T *,std::allocator<Ogre::D3DADAPTER_T *> >::end
PUBLIC	?_Ufill@?$vector@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@IAEPAPAUD3DADAPTER_T@Ogre@@PAPAU34@IABQAU34@@Z ; std::vector<Ogre::D3DADAPTER_T *,std::allocator<Ogre::D3DADAPTER_T *> >::_Ufill
PUBLIC	?capacity@?$vector@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::D3DADAPTER_T *,std::allocator<Ogre::D3DADAPTER_T *> >::capacity
; Function compile flags: /Odtp
;	COMDAT ?push_back@?$vector@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@QAEXABQAUD3DADAPTER_T@Ogre@@@Z
_TEXT	SEGMENT
_this$ = -28						; size = 4
$T141826 = -24						; size = 8
$T141825 = -16						; size = 8
$T141824 = -8						; size = 8
__Val$ = 8						; size = 4
?push_back@?$vector@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@QAEXABQAUD3DADAPTER_T@Ogre@@@Z PROC ; std::vector<Ogre::D3DADAPTER_T *,std::allocator<Ogre::D3DADAPTER_T *> >::push_back, COMDAT
; _this$ = ecx

; 809  : 		{	// insert element at end

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 810  : 		if (size() < capacity())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::D3DADAPTER_T *,std::allocator<Ogre::D3DADAPTER_T *> >::size
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?capacity@?$vector@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::D3DADAPTER_T *,std::allocator<Ogre::D3DADAPTER_T *> >::capacity
	cmp	esi, eax
	jae	SHORT $LN2@push_back@9

; 811  : 
; 812  :  #if _HAS_ITERATOR_DEBUGGING
; 813  : 			{ // room at end, construct it there
; 814  : 			_Orphan_range(_Mylast, _Mylast);
; 815  : 			_Mylast = _Ufill(_Mylast, 1, _Val);
; 816  : 			}
; 817  : 
; 818  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 819  : 			_Mylast = _Ufill(_Mylast, 1, _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Ufill@?$vector@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@IAEPAPAUD3DADAPTER_T@Ogre@@PAPAU34@IABQAU34@@Z ; std::vector<Ogre::D3DADAPTER_T *,std::allocator<Ogre::D3DADAPTER_T *> >::_Ufill
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 820  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 821  : 
; 822  : 		else

	jmp	SHORT $LN3@push_back@9
$LN2@push_back@9:

; 823  : 			insert(end(), _Val);

	lea	edx, DWORD PTR $T141825[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$vector@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@2@XZ ; std::vector<Ogre::D3DADAPTER_T *,std::allocator<Ogre::D3DADAPTER_T *> >::end
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T141824[ebp], ecx
	mov	DWORD PTR $T141824[ebp+4], edx
	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T141824[ebp+4]
	push	ecx
	mov	edx, DWORD PTR $T141824[ebp]
	push	edx
	lea	eax, DWORD PTR $T141826[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?insert@?$vector@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@2@ABQAUD3DADAPTER_T@Ogre@@@Z ; std::vector<Ogre::D3DADAPTER_T *,std::allocator<Ogre::D3DADAPTER_T *> >::insert
$LN3@push_back@9:

; 824  : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?push_back@?$vector@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@QAEXABQAUD3DADAPTER_T@Ogre@@@Z ENDP ; std::vector<Ogre::D3DADAPTER_T *,std::allocator<Ogre::D3DADAPTER_T *> >::push_back
_TEXT	ENDS
PUBLIC	??1ScopeGuardImplBase@Ogre@@IAE@XZ		; Ogre::ScopeGuardImplBase::~ScopeGuardImplBase
PUBLIC	??$SafeExecute@V?$PtrScopeGuardImpl@UD3DDEVCOMBO_T@Ogre@@@Ogre@@@ScopeGuardImplBase@Ogre@@KAXAAV?$PtrScopeGuardImpl@UD3DDEVCOMBO_T@Ogre@@@1@@Z ; Ogre::ScopeGuardImplBase::SafeExecute<Ogre::PtrScopeGuardImpl<Ogre::D3DDEVCOMBO_T> >
;	COMDAT xdata$x
; File i:\svnroot\client\ogremain\ogrescopeguard.h
xdata$x	SEGMENT
__unwindtable$??1?$PtrScopeGuardImpl@UD3DDEVCOMBO_T@Ogre@@@Ogre@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$PtrScopeGuardImpl@UD3DDEVCOMBO_T@Ogre@@@Ogre@@QAE@XZ$0
__ehfuncinfo$??1?$PtrScopeGuardImpl@UD3DDEVCOMBO_T@Ogre@@@Ogre@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$PtrScopeGuardImpl@UD3DDEVCOMBO_T@Ogre@@@Ogre@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$PtrScopeGuardImpl@UD3DDEVCOMBO_T@Ogre@@@Ogre@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$PtrScopeGuardImpl@UD3DDEVCOMBO_T@Ogre@@@Ogre@@QAE@XZ PROC ; Ogre::PtrScopeGuardImpl<Ogre::D3DDEVCOMBO_T>::~PtrScopeGuardImpl<Ogre::D3DDEVCOMBO_T>, COMDAT
; _this$ = ecx

; 289  : 		{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$PtrScopeGuardImpl@UD3DDEVCOMBO_T@Ogre@@@Ogre@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 290  : 			SafeExecute(*this);

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??$SafeExecute@V?$PtrScopeGuardImpl@UD3DDEVCOMBO_T@Ogre@@@Ogre@@@ScopeGuardImplBase@Ogre@@KAXAAV?$PtrScopeGuardImpl@UD3DDEVCOMBO_T@Ogre@@@1@@Z ; Ogre::ScopeGuardImplBase::SafeExecute<Ogre::PtrScopeGuardImpl<Ogre::D3DDEVCOMBO_T> >
	add	esp, 4

; 291  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1ScopeGuardImplBase@Ogre@@IAE@XZ	; Ogre::ScopeGuardImplBase::~ScopeGuardImplBase
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$PtrScopeGuardImpl@UD3DDEVCOMBO_T@Ogre@@@Ogre@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1ScopeGuardImplBase@Ogre@@IAE@XZ	; Ogre::ScopeGuardImplBase::~ScopeGuardImplBase
__ehhandler$??1?$PtrScopeGuardImpl@UD3DDEVCOMBO_T@Ogre@@@Ogre@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$PtrScopeGuardImpl@UD3DDEVCOMBO_T@Ogre@@@Ogre@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$PtrScopeGuardImpl@UD3DDEVCOMBO_T@Ogre@@@Ogre@@QAE@XZ ENDP ; Ogre::PtrScopeGuardImpl<Ogre::D3DDEVCOMBO_T>::~PtrScopeGuardImpl<Ogre::D3DDEVCOMBO_T>
; Function compile flags: /Odtp
;	COMDAT ??1ScopeGuardImplBase@Ogre@@IAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1ScopeGuardImplBase@Ogre@@IAE@XZ PROC			; Ogre::ScopeGuardImplBase::~ScopeGuardImplBase, COMDAT
; _this$ = ecx

; 33   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 34   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??1ScopeGuardImplBase@Ogre@@IAE@XZ ENDP			; Ogre::ScopeGuardImplBase::~ScopeGuardImplBase
_TEXT	ENDS
PUBLIC	??1?$_Container_base_aux_alloc_real@V?$allocator@W4_D3DFORMAT@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<enum _D3DFORMAT> >::~_Container_base_aux_alloc_real<std::allocator<enum _D3DFORMAT> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$_Vector_val@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Vector_val@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$_Vector_val@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Vector_val@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$_Vector_val@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Vector_val@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<enum _D3DFORMAT,std::allocator<enum _D3DFORMAT> >::~_Vector_val<enum _D3DFORMAT,std::allocator<enum _D3DFORMAT> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Vector_val@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Container_base_aux_alloc_real@V?$allocator@W4_D3DFORMAT@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<enum _D3DFORMAT> >::~_Container_base_aux_alloc_real<std::allocator<enum _D3DFORMAT> >
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Vector_val@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Container_base_aux_alloc_real@V?$allocator@W4_D3DFORMAT@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<enum _D3DFORMAT> >::~_Container_base_aux_alloc_real<std::allocator<enum _D3DFORMAT> >
__ehhandler$??1?$_Vector_val@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Vector_val@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Vector_val@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<enum _D3DFORMAT,std::allocator<enum _D3DFORMAT> >::~_Vector_val<enum _D3DFORMAT,std::allocator<enum _D3DFORMAT> >
PUBLIC	??1?$_Container_base_aux_alloc_real@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<enum _D3DMULTISAMPLE_TYPE> >::~_Container_base_aux_alloc_real<std::allocator<enum _D3DMULTISAMPLE_TYPE> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$_Vector_val@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Vector_val@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$_Vector_val@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Vector_val@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$_Vector_val@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Vector_val@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<enum _D3DMULTISAMPLE_TYPE,std::allocator<enum _D3DMULTISAMPLE_TYPE> >::~_Vector_val<enum _D3DMULTISAMPLE_TYPE,std::allocator<enum _D3DMULTISAMPLE_TYPE> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Vector_val@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Container_base_aux_alloc_real@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<enum _D3DMULTISAMPLE_TYPE> >::~_Container_base_aux_alloc_real<std::allocator<enum _D3DMULTISAMPLE_TYPE> >
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Vector_val@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Container_base_aux_alloc_real@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<enum _D3DMULTISAMPLE_TYPE> >::~_Container_base_aux_alloc_real<std::allocator<enum _D3DMULTISAMPLE_TYPE> >
__ehhandler$??1?$_Vector_val@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Vector_val@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Vector_val@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<enum _D3DMULTISAMPLE_TYPE,std::allocator<enum _D3DMULTISAMPLE_TYPE> >::~_Vector_val<enum _D3DMULTISAMPLE_TYPE,std::allocator<enum _D3DMULTISAMPLE_TYPE> >
PUBLIC	??1?$_Container_base_aux_alloc_real@V?$allocator@I@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<unsigned int> >::~_Container_base_aux_alloc_real<std::allocator<unsigned int> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$_Vector_val@IV?$allocator@I@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Vector_val@IV?$allocator@I@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$_Vector_val@IV?$allocator@I@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Vector_val@IV?$allocator@I@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$_Vector_val@IV?$allocator@I@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Vector_val@IV?$allocator@I@std@@@std@@QAE@XZ PROC	; std::_Vector_val<unsigned int,std::allocator<unsigned int> >::~_Vector_val<unsigned int,std::allocator<unsigned int> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Vector_val@IV?$allocator@I@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Container_base_aux_alloc_real@V?$allocator@I@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<unsigned int> >::~_Container_base_aux_alloc_real<std::allocator<unsigned int> >
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Vector_val@IV?$allocator@I@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Container_base_aux_alloc_real@V?$allocator@I@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<unsigned int> >::~_Container_base_aux_alloc_real<std::allocator<unsigned int> >
__ehhandler$??1?$_Vector_val@IV?$allocator@I@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Vector_val@IV?$allocator@I@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Vector_val@IV?$allocator@I@std@@@std@@QAE@XZ ENDP	; std::_Vector_val<unsigned int,std::allocator<unsigned int> >::~_Vector_val<unsigned int,std::allocator<unsigned int> >
PUBLIC	??1?$_Container_base_aux_alloc_real@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::D3DSMSCONFLICT_T> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::D3DSMSCONFLICT_T> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$_Vector_val@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Vector_val@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$_Vector_val@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Vector_val@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$_Vector_val@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Vector_val@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<Ogre::D3DSMSCONFLICT_T,std::allocator<Ogre::D3DSMSCONFLICT_T> >::~_Vector_val<Ogre::D3DSMSCONFLICT_T,std::allocator<Ogre::D3DSMSCONFLICT_T> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Vector_val@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Container_base_aux_alloc_real@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::D3DSMSCONFLICT_T> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::D3DSMSCONFLICT_T> >
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Vector_val@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Container_base_aux_alloc_real@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::D3DSMSCONFLICT_T> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::D3DSMSCONFLICT_T> >
__ehhandler$??1?$_Vector_val@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Vector_val@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Vector_val@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<Ogre::D3DSMSCONFLICT_T,std::allocator<Ogre::D3DSMSCONFLICT_T> >::~_Vector_val<Ogre::D3DSMSCONFLICT_T,std::allocator<Ogre::D3DSMSCONFLICT_T> >
PUBLIC	??1?$_Container_base_aux_alloc_real@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<enum Ogre::VERTPROCESS_T> >::~_Container_base_aux_alloc_real<std::allocator<enum Ogre::VERTPROCESS_T> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$_Vector_val@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Vector_val@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$_Vector_val@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Vector_val@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$_Vector_val@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Vector_val@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<enum Ogre::VERTPROCESS_T,std::allocator<enum Ogre::VERTPROCESS_T> >::~_Vector_val<enum Ogre::VERTPROCESS_T,std::allocator<enum Ogre::VERTPROCESS_T> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Vector_val@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Container_base_aux_alloc_real@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<enum Ogre::VERTPROCESS_T> >::~_Container_base_aux_alloc_real<std::allocator<enum Ogre::VERTPROCESS_T> >
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Vector_val@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Container_base_aux_alloc_real@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<enum Ogre::VERTPROCESS_T> >::~_Container_base_aux_alloc_real<std::allocator<enum Ogre::VERTPROCESS_T> >
__ehhandler$??1?$_Vector_val@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Vector_val@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Vector_val@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<enum Ogre::VERTPROCESS_T,std::allocator<enum Ogre::VERTPROCESS_T> >::~_Vector_val<enum Ogre::VERTPROCESS_T,std::allocator<enum Ogre::VERTPROCESS_T> >
PUBLIC	??1?$_Container_base_aux_alloc_real@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::D3DDEVCOMBO_T *> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::D3DDEVCOMBO_T *> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$_Vector_val@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Vector_val@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$_Vector_val@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Vector_val@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$_Vector_val@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Vector_val@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<Ogre::D3DDEVCOMBO_T *,std::allocator<Ogre::D3DDEVCOMBO_T *> >::~_Vector_val<Ogre::D3DDEVCOMBO_T *,std::allocator<Ogre::D3DDEVCOMBO_T *> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Vector_val@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Container_base_aux_alloc_real@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::D3DDEVCOMBO_T *> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::D3DDEVCOMBO_T *> >
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Vector_val@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Container_base_aux_alloc_real@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::D3DDEVCOMBO_T *> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::D3DDEVCOMBO_T *> >
__ehhandler$??1?$_Vector_val@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Vector_val@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Vector_val@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<Ogre::D3DDEVCOMBO_T *,std::allocator<Ogre::D3DDEVCOMBO_T *> >::~_Vector_val<Ogre::D3DDEVCOMBO_T *,std::allocator<Ogre::D3DDEVCOMBO_T *> >
PUBLIC	??1?$_Container_base_aux_alloc_real@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<_D3DDISPLAYMODE> >::~_Container_base_aux_alloc_real<std::allocator<_D3DDISPLAYMODE> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$_Vector_val@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Vector_val@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$_Vector_val@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Vector_val@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$_Vector_val@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Vector_val@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<_D3DDISPLAYMODE,std::allocator<_D3DDISPLAYMODE> >::~_Vector_val<_D3DDISPLAYMODE,std::allocator<_D3DDISPLAYMODE> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Vector_val@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Container_base_aux_alloc_real@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<_D3DDISPLAYMODE> >::~_Container_base_aux_alloc_real<std::allocator<_D3DDISPLAYMODE> >
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Vector_val@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Container_base_aux_alloc_real@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<_D3DDISPLAYMODE> >::~_Container_base_aux_alloc_real<std::allocator<_D3DDISPLAYMODE> >
__ehhandler$??1?$_Vector_val@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Vector_val@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Vector_val@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<_D3DDISPLAYMODE,std::allocator<_D3DDISPLAYMODE> >::~_Vector_val<_D3DDISPLAYMODE,std::allocator<_D3DDISPLAYMODE> >
PUBLIC	??1?$_Container_base_aux_alloc_real@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::D3DDEVICEINFO_T *> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::D3DDEVICEINFO_T *> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$_Vector_val@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Vector_val@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$_Vector_val@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Vector_val@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$_Vector_val@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Vector_val@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<Ogre::D3DDEVICEINFO_T *,std::allocator<Ogre::D3DDEVICEINFO_T *> >::~_Vector_val<Ogre::D3DDEVICEINFO_T *,std::allocator<Ogre::D3DDEVICEINFO_T *> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Vector_val@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Container_base_aux_alloc_real@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::D3DDEVICEINFO_T *> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::D3DDEVICEINFO_T *> >
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Vector_val@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Container_base_aux_alloc_real@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::D3DDEVICEINFO_T *> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::D3DDEVICEINFO_T *> >
__ehhandler$??1?$_Vector_val@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Vector_val@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Vector_val@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<Ogre::D3DDEVICEINFO_T *,std::allocator<Ogre::D3DDEVICEINFO_T *> >::~_Vector_val<Ogre::D3DDEVICEINFO_T *,std::allocator<Ogre::D3DDEVICEINFO_T *> >
PUBLIC	??1?$_Container_base_aux_alloc_real@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::D3DADAPTER_T *> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::D3DADAPTER_T *> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$_Vector_val@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Vector_val@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$_Vector_val@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Vector_val@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$_Vector_val@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Vector_val@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<Ogre::D3DADAPTER_T *,std::allocator<Ogre::D3DADAPTER_T *> >::~_Vector_val<Ogre::D3DADAPTER_T *,std::allocator<Ogre::D3DADAPTER_T *> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Vector_val@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Container_base_aux_alloc_real@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::D3DADAPTER_T *> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::D3DADAPTER_T *> >
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Vector_val@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Container_base_aux_alloc_real@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::D3DADAPTER_T *> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::D3DADAPTER_T *> >
__ehhandler$??1?$_Vector_val@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Vector_val@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Vector_val@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<Ogre::D3DADAPTER_T *,std::allocator<Ogre::D3DADAPTER_T *> >::~_Vector_val<Ogre::D3DADAPTER_T *,std::allocator<Ogre::D3DADAPTER_T *> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?capacity@?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
tv70 = -8						; size = 4
_this$ = -4						; size = 4
?capacity@?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@QBEIXZ PROC ; std::vector<enum _D3DFORMAT,std::allocator<enum _D3DFORMAT> >::capacity, COMDAT
; _this$ = ecx

; 634  : 		{	// return current length of allocated storage

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	jne	SHORT $LN3@capacity
	mov	DWORD PTR tv70[ebp], 0
	jmp	SHORT $LN4@capacity
$LN3@capacity:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+20]
	sub	eax, DWORD PTR [edx+12]
	sar	eax, 2
	mov	DWORD PTR tv70[ebp], eax
$LN4@capacity:
	mov	eax, DWORD PTR tv70[ebp]

; 636  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?capacity@?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@QBEIXZ ENDP ; std::vector<enum _D3DFORMAT,std::allocator<enum _D3DFORMAT> >::capacity
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@QAE@PAW4_D3DFORMAT@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<enum _D3DFORMAT,std::allocator<enum _D3DFORMAT> >::_Vector_iterator<enum _D3DFORMAT,std::allocator<enum _D3DFORMAT> >
; Function compile flags: /Odtp
;	COMDAT ?end@?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@QAE?AV?$_Vector_iterator@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@QAE?AV?$_Vector_iterator@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@2@XZ PROC ; std::vector<enum _D3DFORMAT,std::allocator<enum _D3DFORMAT> >::end, COMDAT
; _this$ = ecx

; 650  : 		{	// return iterator for end of mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 651  : 		return (iterator(_Mylast, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@QAE@PAW4_D3DFORMAT@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<enum _D3DFORMAT,std::allocator<enum _D3DFORMAT> >::_Vector_iterator<enum _D3DFORMAT,std::allocator<enum _D3DFORMAT> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 652  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?end@?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@QAE?AV?$_Vector_iterator@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@2@XZ ENDP ; std::vector<enum _D3DFORMAT,std::allocator<enum _D3DFORMAT> >::end
_TEXT	ENDS
PUBLIC	??H?$_Vector_iterator@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<enum _D3DFORMAT,std::allocator<enum _D3DFORMAT> >::operator+
PUBLIC	?_Insert_n@?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@2@IABW4_D3DFORMAT@@@Z ; std::vector<enum _D3DFORMAT,std::allocator<enum _D3DFORMAT> >::_Insert_n
PUBLIC	??G?$_Vector_const_iterator@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@QBEHABV01@@Z ; std::_Vector_const_iterator<enum _D3DFORMAT,std::allocator<enum _D3DFORMAT> >::operator-
PUBLIC	?begin@?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@QAE?AV?$_Vector_iterator@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@2@XZ ; std::vector<enum _D3DFORMAT,std::allocator<enum _D3DFORMAT> >::begin
; Function compile flags: /Odtp
;	COMDAT ?insert@?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@QAE?AV?$_Vector_iterator@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@2@V?$_Vector_const_iterator@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@2@ABW4_D3DFORMAT@@@Z
_TEXT	SEGMENT
tv77 = -28						; size = 4
_this$ = -24						; size = 4
$T141930 = -20						; size = 8
$T141927 = -12						; size = 8
__Off$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 8
__Val$ = 20						; size = 4
?insert@?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@QAE?AV?$_Vector_iterator@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@2@V?$_Vector_const_iterator@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@2@ABW4_D3DFORMAT@@@Z PROC ; std::vector<enum _D3DFORMAT,std::allocator<enum _D3DFORMAT> >::insert, COMDAT
; _this$ = ecx

; 875  : 		{	// insert _Val at _Where

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR _this$[ebp], ecx

; 876  : 		size_type _Off = size() == 0 ? 0 : _Where - begin();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@QBEIXZ ; std::vector<enum _D3DFORMAT,std::allocator<enum _D3DFORMAT> >::size
	test	eax, eax
	jne	SHORT $LN3@insert
	mov	DWORD PTR tv77[ebp], 0
	jmp	SHORT $LN4@insert
$LN3@insert:
	lea	eax, DWORD PTR $T141927[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@QAE?AV?$_Vector_iterator@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@2@XZ ; std::vector<enum _D3DFORMAT,std::allocator<enum _D3DFORMAT> >::begin
	push	eax
	lea	ecx, DWORD PTR __Where$[ebp]
	call	??G?$_Vector_const_iterator@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@QBEHABV01@@Z ; std::_Vector_const_iterator<enum _D3DFORMAT,std::allocator<enum _D3DFORMAT> >::operator-
	mov	DWORD PTR tv77[ebp], eax
$LN4@insert:
	mov	ecx, DWORD PTR tv77[ebp]
	mov	DWORD PTR __Off$[ebp], ecx

; 877  : 		_Insert_n(_Where, (size_type)1, _Val);

	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	push	1
	mov	eax, DWORD PTR __Where$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert_n@?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@2@IABW4_D3DFORMAT@@@Z ; std::vector<enum _D3DFORMAT,std::allocator<enum _D3DFORMAT> >::_Insert_n

; 878  : 		return (begin() + _Off);

	mov	edx, DWORD PTR __Off$[ebp]
	push	edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T141930[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@QAE?AV?$_Vector_iterator@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@2@XZ ; std::vector<enum _D3DFORMAT,std::allocator<enum _D3DFORMAT> >::begin
	mov	ecx, eax
	call	??H?$_Vector_iterator@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<enum _D3DFORMAT,std::allocator<enum _D3DFORMAT> >::operator+
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 879  : 		}

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?insert@?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@QAE?AV?$_Vector_iterator@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@2@V?$_Vector_const_iterator@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@2@ABW4_D3DFORMAT@@@Z ENDP ; std::vector<enum _D3DFORMAT,std::allocator<enum _D3DFORMAT> >::insert
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@W4_D3DFORMAT@@@std@@QAEPAW4_D3DFORMAT@@I@Z ; std::allocator<enum _D3DFORMAT>::allocate
PUBLIC	?_Xlen@?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@KAXXZ ; std::vector<enum _D3DFORMAT,std::allocator<enum _D3DFORMAT> >::_Xlen
PUBLIC	?max_size@?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@QBEIXZ ; std::vector<enum _D3DFORMAT,std::allocator<enum _D3DFORMAT> >::max_size
; Function compile flags: /Odtp
;	COMDAT ?_Buy@?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Capacity$ = 8						; size = 4
?_Buy@?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@IAE_NI@Z PROC ; std::vector<enum _D3DFORMAT,std::allocator<enum _D3DFORMAT> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+20], 0

; 1104 : 		if (_Capacity == 0)

	cmp	DWORD PTR __Capacity$[ebp], 0
	jne	SHORT $LN4@Buy

; 1105 : 			return (false);

	xor	al, al
	jmp	SHORT $LN5@Buy
	jmp	SHORT $LN3@Buy
$LN4@Buy:

; 1106 : 		else if (max_size() < _Capacity)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@QBEIXZ ; std::vector<enum _D3DFORMAT,std::allocator<enum _D3DFORMAT> >::max_size
	cmp	eax, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN2@Buy

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@KAXXZ ; std::vector<enum _D3DFORMAT,std::allocator<enum _D3DFORMAT> >::_Xlen

; 1108 : 		else

	jmp	SHORT $LN3@Buy
$LN2@Buy:

; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	mov	eax, DWORD PTR __Capacity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?allocate@?$allocator@W4_D3DFORMAT@@@std@@QAEPAW4_D3DFORMAT@@I@Z ; std::allocator<enum _D3DFORMAT>::allocate
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [edx+16], ecx

; 1112 : 			_Myend = _Myfirst + _Capacity;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR __Capacity$[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], edx
$LN3@Buy:

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
$LN5@Buy:

; 1115 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Buy@?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<enum _D3DFORMAT,std::allocator<enum _D3DFORMAT> >::_Buy
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@W4_D3DFORMAT@@@std@@QAEXPAW4_D3DFORMAT@@I@Z ; std::allocator<enum _D3DFORMAT>::deallocate
PUBLIC	?_Destroy@?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@IAEXPAW4_D3DFORMAT@@0@Z ; std::vector<enum _D3DFORMAT,std::allocator<enum _D3DFORMAT> >::_Destroy
; Function compile flags: /Odtp
;	COMDAT ?_Tidy@?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Tidy@?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@IAEXXZ PROC ; std::vector<enum _D3DFORMAT,std::allocator<enum _D3DFORMAT> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	je	SHORT $LN1@Tidy

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@IAEXPAW4_D3DFORMAT@@0@Z ; std::vector<enum _D3DFORMAT,std::allocator<enum _D3DFORMAT> >::_Destroy

; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+20]
	sub	ecx, DWORD PTR [eax+12]
	sar	ecx, 2
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?deallocate@?$allocator@W4_D3DFORMAT@@@std@@QAEXPAW4_D3DFORMAT@@I@Z ; std::allocator<enum _D3DFORMAT>::deallocate
$LN1@Tidy:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+16], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], 0

; 1135 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@IAEXXZ ENDP ; std::vector<enum _D3DFORMAT,std::allocator<enum _D3DFORMAT> >::_Tidy
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_fill_n@PAW4_D3DFORMAT@@IW41@V?$allocator@W4_D3DFORMAT@@@std@@@stdext@@YAXPAW4_D3DFORMAT@@IABW41@AAV?$allocator@W4_D3DFORMAT@@@std@@@Z ; stdext::unchecked_uninitialized_fill_n<enum _D3DFORMAT *,unsigned int,enum _D3DFORMAT,std::allocator<enum _D3DFORMAT> >
; Function compile flags: /Odtp
;	COMDAT ?_Ufill@?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@IAEPAW4_D3DFORMAT@@PAW43@IABW43@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Ufill@?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@IAEPAW4_D3DFORMAT@@PAW43@IABW43@@Z PROC ; std::vector<enum _D3DFORMAT,std::allocator<enum _D3DFORMAT> >::_Ufill, COMDAT
; _this$ = ecx

; 1253 : 		{	// copy initializing _Count * _Val, using allocator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1254 : 		_STDEXT unchecked_uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??$unchecked_uninitialized_fill_n@PAW4_D3DFORMAT@@IW41@V?$allocator@W4_D3DFORMAT@@@std@@@stdext@@YAXPAW4_D3DFORMAT@@IABW41@AAV?$allocator@W4_D3DFORMAT@@@std@@@Z ; stdext::unchecked_uninitialized_fill_n<enum _D3DFORMAT *,unsigned int,enum _D3DFORMAT,std::allocator<enum _D3DFORMAT> >
	add	esp, 16					; 00000010H

; 1255 : 		return (_Ptr + _Count);

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Ptr$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]

; 1256 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?_Ufill@?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@IAEPAW4_D3DFORMAT@@PAW43@IABW43@@Z ENDP ; std::vector<enum _D3DFORMAT,std::allocator<enum _D3DFORMAT> >::_Ufill
_TEXT	ENDS
PUBLIC	??0?$_Container_base_aux_alloc_real@V?$allocator@W4_D3DFORMAT@@@std@@@std@@IAE@V?$allocator@W4_D3DFORMAT@@@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<enum _D3DFORMAT> >::_Container_base_aux_alloc_real<std::allocator<enum _D3DFORMAT> >
PUBLIC	??0?$allocator@W4_D3DFORMAT@@@std@@QAE@ABV01@@Z	; std::allocator<enum _D3DFORMAT>::allocator<enum _D3DFORMAT>
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$_Vector_val@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@IAE@V?$allocator@W4_D3DFORMAT@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Vector_val@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@IAE@V?$allocator@W4_D3DFORMAT@@@1@@Z$0
__ehfuncinfo$??0?$_Vector_val@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@IAE@V?$allocator@W4_D3DFORMAT@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Vector_val@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@IAE@V?$allocator@W4_D3DFORMAT@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Vector_val@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@IAE@V?$allocator@W4_D3DFORMAT@@@1@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T141939 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 1
??0?$_Vector_val@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@IAE@V?$allocator@W4_D3DFORMAT@@@1@@Z PROC ; std::_Vector_val<enum _D3DFORMAT,std::allocator<enum _D3DFORMAT> >::_Vector_val<enum _D3DFORMAT,std::allocator<enum _D3DFORMAT> >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Vector_val@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@IAE@V?$allocator@W4_D3DFORMAT@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T141939[ebp], esp
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	call	??0?$allocator@W4_D3DFORMAT@@@std@@QAE@ABV01@@Z ; std::allocator<enum _D3DFORMAT>::allocator<enum _D3DFORMAT>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Container_base_aux_alloc_real@V?$allocator@W4_D3DFORMAT@@@std@@@std@@IAE@V?$allocator@W4_D3DFORMAT@@@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<enum _D3DFORMAT> >::_Container_base_aux_alloc_real<std::allocator<enum _D3DFORMAT> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??0?$allocator@W4_D3DFORMAT@@@std@@QAE@ABV01@@Z ; std::allocator<enum _D3DFORMAT>::allocator<enum _D3DFORMAT>

; 426  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Vector_val@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@IAE@V?$allocator@W4_D3DFORMAT@@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Container_base_aux_alloc_real@V?$allocator@W4_D3DFORMAT@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<enum _D3DFORMAT> >::~_Container_base_aux_alloc_real<std::allocator<enum _D3DFORMAT> >
__ehhandler$??0?$_Vector_val@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@IAE@V?$allocator@W4_D3DFORMAT@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Vector_val@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@IAE@V?$allocator@W4_D3DFORMAT@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Vector_val@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@IAE@V?$allocator@W4_D3DFORMAT@@@1@@Z ENDP ; std::_Vector_val<enum _D3DFORMAT,std::allocator<enum _D3DFORMAT> >::_Vector_val<enum _D3DFORMAT,std::allocator<enum _D3DFORMAT> >
PUBLIC	??1_Container_base_aux@std@@QAE@XZ		; std::_Container_base_aux::~_Container_base_aux
PUBLIC	?deallocate@?$allocator@V_Aux_cont@std@@@std@@QAEXPAV_Aux_cont@2@I@Z ; std::allocator<std::_Aux_cont>::deallocate
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??1?$_Container_base_aux_alloc_real@V?$allocator@W4_D3DFORMAT@@@std@@@std@@IAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Container_base_aux_alloc_real@V?$allocator@W4_D3DFORMAT@@@std@@@std@@IAE@XZ$0
__ehfuncinfo$??1?$_Container_base_aux_alloc_real@V?$allocator@W4_D3DFORMAT@@@std@@@std@@IAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Container_base_aux_alloc_real@V?$allocator@W4_D3DFORMAT@@@std@@@std@@IAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$_Container_base_aux_alloc_real@V?$allocator@W4_D3DFORMAT@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Container_base_aux_alloc_real@V?$allocator@W4_D3DFORMAT@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_real<std::allocator<enum _D3DFORMAT> >::~_Container_base_aux_alloc_real<std::allocator<enum _D3DFORMAT> >, COMDAT
; _this$ = ecx

; 436  : 		{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Container_base_aux_alloc_real@V?$allocator@W4_D3DFORMAT@@@std@@@std@@IAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 437  : 		_Myownedaux->~_Aux_cont();
; 438  : 
; 439  : 		_Alaux.deallocate(_Myownedaux, 1);

	push	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?deallocate@?$allocator@V_Aux_cont@std@@@std@@QAEXPAV_Aux_cont@2@I@Z ; std::allocator<std::_Aux_cont>::deallocate

; 440  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Container_base_aux_alloc_real@V?$allocator@W4_D3DFORMAT@@@std@@@std@@IAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
__ehhandler$??1?$_Container_base_aux_alloc_real@V?$allocator@W4_D3DFORMAT@@@std@@@std@@IAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Container_base_aux_alloc_real@V?$allocator@W4_D3DFORMAT@@@std@@@std@@IAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Container_base_aux_alloc_real@V?$allocator@W4_D3DFORMAT@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_real<std::allocator<enum _D3DFORMAT> >::~_Container_base_aux_alloc_real<std::allocator<enum _D3DFORMAT> >
; Function compile flags: /Odtp
;	COMDAT ??1_Container_base_aux@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_Container_base_aux@std@@QAE@XZ PROC			; std::_Container_base_aux::~_Container_base_aux, COMDAT
; _this$ = ecx

; 402  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 403  : 		// Do nothing: ~_Container_base_aux_alloc_real() previously destroyed the aux object.
; 404  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??1_Container_base_aux@std@@QAE@XZ ENDP			; std::_Container_base_aux::~_Container_base_aux
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@W4_D3DFORMAT@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@W4_D3DFORMAT@@@std@@QAE@XZ PROC		; std::allocator<enum _D3DFORMAT>::allocator<enum _D3DFORMAT>, COMDAT
; _this$ = ecx

; 119  : 	allocator() _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$allocator@W4_D3DFORMAT@@@std@@QAE@XZ ENDP		; std::allocator<enum _D3DFORMAT>::allocator<enum _D3DFORMAT>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?capacity@?$vector@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
tv70 = -8						; size = 4
_this$ = -4						; size = 4
?capacity@?$vector@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@QBEIXZ PROC ; std::vector<enum _D3DMULTISAMPLE_TYPE,std::allocator<enum _D3DMULTISAMPLE_TYPE> >::capacity, COMDAT
; _this$ = ecx

; 634  : 		{	// return current length of allocated storage

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	jne	SHORT $LN3@capacity@2
	mov	DWORD PTR tv70[ebp], 0
	jmp	SHORT $LN4@capacity@2
$LN3@capacity@2:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+20]
	sub	eax, DWORD PTR [edx+12]
	sar	eax, 2
	mov	DWORD PTR tv70[ebp], eax
$LN4@capacity@2:
	mov	eax, DWORD PTR tv70[ebp]

; 636  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?capacity@?$vector@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@QBEIXZ ENDP ; std::vector<enum _D3DMULTISAMPLE_TYPE,std::allocator<enum _D3DMULTISAMPLE_TYPE> >::capacity
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@QAE@PAW4_D3DMULTISAMPLE_TYPE@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<enum _D3DMULTISAMPLE_TYPE,std::allocator<enum _D3DMULTISAMPLE_TYPE> >::_Vector_iterator<enum _D3DMULTISAMPLE_TYPE,std::allocator<enum _D3DMULTISAMPLE_TYPE> >
; Function compile flags: /Odtp
;	COMDAT ?end@?$vector@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@QAE?AV?$_Vector_iterator@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@QAE?AV?$_Vector_iterator@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@2@XZ PROC ; std::vector<enum _D3DMULTISAMPLE_TYPE,std::allocator<enum _D3DMULTISAMPLE_TYPE> >::end, COMDAT
; _this$ = ecx

; 650  : 		{	// return iterator for end of mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 651  : 		return (iterator(_Mylast, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@QAE@PAW4_D3DMULTISAMPLE_TYPE@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<enum _D3DMULTISAMPLE_TYPE,std::allocator<enum _D3DMULTISAMPLE_TYPE> >::_Vector_iterator<enum _D3DMULTISAMPLE_TYPE,std::allocator<enum _D3DMULTISAMPLE_TYPE> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 652  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?end@?$vector@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@QAE?AV?$_Vector_iterator@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@2@XZ ENDP ; std::vector<enum _D3DMULTISAMPLE_TYPE,std::allocator<enum _D3DMULTISAMPLE_TYPE> >::end
_TEXT	ENDS
PUBLIC	??H?$_Vector_iterator@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<enum _D3DMULTISAMPLE_TYPE,std::allocator<enum _D3DMULTISAMPLE_TYPE> >::operator+
PUBLIC	?_Insert_n@?$vector@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@2@IABW4_D3DMULTISAMPLE_TYPE@@@Z ; std::vector<enum _D3DMULTISAMPLE_TYPE,std::allocator<enum _D3DMULTISAMPLE_TYPE> >::_Insert_n
PUBLIC	??G?$_Vector_const_iterator@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@QBEHABV01@@Z ; std::_Vector_const_iterator<enum _D3DMULTISAMPLE_TYPE,std::allocator<enum _D3DMULTISAMPLE_TYPE> >::operator-
PUBLIC	?begin@?$vector@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@QAE?AV?$_Vector_iterator@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@2@XZ ; std::vector<enum _D3DMULTISAMPLE_TYPE,std::allocator<enum _D3DMULTISAMPLE_TYPE> >::begin
; Function compile flags: /Odtp
;	COMDAT ?insert@?$vector@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@QAE?AV?$_Vector_iterator@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@2@V?$_Vector_const_iterator@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@2@ABW4_D3DMULTISAMPLE_TYPE@@@Z
_TEXT	SEGMENT
tv77 = -28						; size = 4
_this$ = -24						; size = 4
$T141971 = -20						; size = 8
$T141968 = -12						; size = 8
__Off$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 8
__Val$ = 20						; size = 4
?insert@?$vector@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@QAE?AV?$_Vector_iterator@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@2@V?$_Vector_const_iterator@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@2@ABW4_D3DMULTISAMPLE_TYPE@@@Z PROC ; std::vector<enum _D3DMULTISAMPLE_TYPE,std::allocator<enum _D3DMULTISAMPLE_TYPE> >::insert, COMDAT
; _this$ = ecx

; 875  : 		{	// insert _Val at _Where

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR _this$[ebp], ecx

; 876  : 		size_type _Off = size() == 0 ? 0 : _Where - begin();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@QBEIXZ ; std::vector<enum _D3DMULTISAMPLE_TYPE,std::allocator<enum _D3DMULTISAMPLE_TYPE> >::size
	test	eax, eax
	jne	SHORT $LN3@insert@2
	mov	DWORD PTR tv77[ebp], 0
	jmp	SHORT $LN4@insert@2
$LN3@insert@2:
	lea	eax, DWORD PTR $T141968[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$vector@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@QAE?AV?$_Vector_iterator@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@2@XZ ; std::vector<enum _D3DMULTISAMPLE_TYPE,std::allocator<enum _D3DMULTISAMPLE_TYPE> >::begin
	push	eax
	lea	ecx, DWORD PTR __Where$[ebp]
	call	??G?$_Vector_const_iterator@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@QBEHABV01@@Z ; std::_Vector_const_iterator<enum _D3DMULTISAMPLE_TYPE,std::allocator<enum _D3DMULTISAMPLE_TYPE> >::operator-
	mov	DWORD PTR tv77[ebp], eax
$LN4@insert@2:
	mov	ecx, DWORD PTR tv77[ebp]
	mov	DWORD PTR __Off$[ebp], ecx

; 877  : 		_Insert_n(_Where, (size_type)1, _Val);

	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	push	1
	mov	eax, DWORD PTR __Where$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert_n@?$vector@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@2@IABW4_D3DMULTISAMPLE_TYPE@@@Z ; std::vector<enum _D3DMULTISAMPLE_TYPE,std::allocator<enum _D3DMULTISAMPLE_TYPE> >::_Insert_n

; 878  : 		return (begin() + _Off);

	mov	edx, DWORD PTR __Off$[ebp]
	push	edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T141971[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$vector@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@QAE?AV?$_Vector_iterator@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@2@XZ ; std::vector<enum _D3DMULTISAMPLE_TYPE,std::allocator<enum _D3DMULTISAMPLE_TYPE> >::begin
	mov	ecx, eax
	call	??H?$_Vector_iterator@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<enum _D3DMULTISAMPLE_TYPE,std::allocator<enum _D3DMULTISAMPLE_TYPE> >::operator+
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 879  : 		}

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?insert@?$vector@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@QAE?AV?$_Vector_iterator@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@2@V?$_Vector_const_iterator@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@2@ABW4_D3DMULTISAMPLE_TYPE@@@Z ENDP ; std::vector<enum _D3DMULTISAMPLE_TYPE,std::allocator<enum _D3DMULTISAMPLE_TYPE> >::insert
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@QAEPAW4_D3DMULTISAMPLE_TYPE@@I@Z ; std::allocator<enum _D3DMULTISAMPLE_TYPE>::allocate
PUBLIC	?_Xlen@?$vector@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@KAXXZ ; std::vector<enum _D3DMULTISAMPLE_TYPE,std::allocator<enum _D3DMULTISAMPLE_TYPE> >::_Xlen
PUBLIC	?max_size@?$vector@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@QBEIXZ ; std::vector<enum _D3DMULTISAMPLE_TYPE,std::allocator<enum _D3DMULTISAMPLE_TYPE> >::max_size
; Function compile flags: /Odtp
;	COMDAT ?_Buy@?$vector@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Capacity$ = 8						; size = 4
?_Buy@?$vector@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@IAE_NI@Z PROC ; std::vector<enum _D3DMULTISAMPLE_TYPE,std::allocator<enum _D3DMULTISAMPLE_TYPE> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+20], 0

; 1104 : 		if (_Capacity == 0)

	cmp	DWORD PTR __Capacity$[ebp], 0
	jne	SHORT $LN4@Buy@2

; 1105 : 			return (false);

	xor	al, al
	jmp	SHORT $LN5@Buy@2
	jmp	SHORT $LN3@Buy@2
$LN4@Buy@2:

; 1106 : 		else if (max_size() < _Capacity)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@QBEIXZ ; std::vector<enum _D3DMULTISAMPLE_TYPE,std::allocator<enum _D3DMULTISAMPLE_TYPE> >::max_size
	cmp	eax, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN2@Buy@2

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@KAXXZ ; std::vector<enum _D3DMULTISAMPLE_TYPE,std::allocator<enum _D3DMULTISAMPLE_TYPE> >::_Xlen

; 1108 : 		else

	jmp	SHORT $LN3@Buy@2
$LN2@Buy@2:

; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	mov	eax, DWORD PTR __Capacity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?allocate@?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@QAEPAW4_D3DMULTISAMPLE_TYPE@@I@Z ; std::allocator<enum _D3DMULTISAMPLE_TYPE>::allocate
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [edx+16], ecx

; 1112 : 			_Myend = _Myfirst + _Capacity;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR __Capacity$[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], edx
$LN3@Buy@2:

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
$LN5@Buy@2:

; 1115 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Buy@?$vector@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<enum _D3DMULTISAMPLE_TYPE,std::allocator<enum _D3DMULTISAMPLE_TYPE> >::_Buy
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@QAEXPAW4_D3DMULTISAMPLE_TYPE@@I@Z ; std::allocator<enum _D3DMULTISAMPLE_TYPE>::deallocate
PUBLIC	?_Destroy@?$vector@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@IAEXPAW4_D3DMULTISAMPLE_TYPE@@0@Z ; std::vector<enum _D3DMULTISAMPLE_TYPE,std::allocator<enum _D3DMULTISAMPLE_TYPE> >::_Destroy
; Function compile flags: /Odtp
;	COMDAT ?_Tidy@?$vector@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Tidy@?$vector@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@IAEXXZ PROC ; std::vector<enum _D3DMULTISAMPLE_TYPE,std::allocator<enum _D3DMULTISAMPLE_TYPE> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	je	SHORT $LN1@Tidy@2

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@IAEXPAW4_D3DMULTISAMPLE_TYPE@@0@Z ; std::vector<enum _D3DMULTISAMPLE_TYPE,std::allocator<enum _D3DMULTISAMPLE_TYPE> >::_Destroy

; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+20]
	sub	ecx, DWORD PTR [eax+12]
	sar	ecx, 2
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?deallocate@?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@QAEXPAW4_D3DMULTISAMPLE_TYPE@@I@Z ; std::allocator<enum _D3DMULTISAMPLE_TYPE>::deallocate
$LN1@Tidy@2:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+16], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], 0

; 1135 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$vector@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@IAEXXZ ENDP ; std::vector<enum _D3DMULTISAMPLE_TYPE,std::allocator<enum _D3DMULTISAMPLE_TYPE> >::_Tidy
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_fill_n@PAW4_D3DMULTISAMPLE_TYPE@@IW41@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@stdext@@YAXPAW4_D3DMULTISAMPLE_TYPE@@IABW41@AAV?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@Z ; stdext::unchecked_uninitialized_fill_n<enum _D3DMULTISAMPLE_TYPE *,unsigned int,enum _D3DMULTISAMPLE_TYPE,std::allocator<enum _D3DMULTISAMPLE_TYPE> >
; Function compile flags: /Odtp
;	COMDAT ?_Ufill@?$vector@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@IAEPAW4_D3DMULTISAMPLE_TYPE@@PAW43@IABW43@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Ufill@?$vector@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@IAEPAW4_D3DMULTISAMPLE_TYPE@@PAW43@IABW43@@Z PROC ; std::vector<enum _D3DMULTISAMPLE_TYPE,std::allocator<enum _D3DMULTISAMPLE_TYPE> >::_Ufill, COMDAT
; _this$ = ecx

; 1253 : 		{	// copy initializing _Count * _Val, using allocator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1254 : 		_STDEXT unchecked_uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??$unchecked_uninitialized_fill_n@PAW4_D3DMULTISAMPLE_TYPE@@IW41@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@stdext@@YAXPAW4_D3DMULTISAMPLE_TYPE@@IABW41@AAV?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@Z ; stdext::unchecked_uninitialized_fill_n<enum _D3DMULTISAMPLE_TYPE *,unsigned int,enum _D3DMULTISAMPLE_TYPE,std::allocator<enum _D3DMULTISAMPLE_TYPE> >
	add	esp, 16					; 00000010H

; 1255 : 		return (_Ptr + _Count);

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Ptr$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]

; 1256 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?_Ufill@?$vector@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@IAEPAW4_D3DMULTISAMPLE_TYPE@@PAW43@IABW43@@Z ENDP ; std::vector<enum _D3DMULTISAMPLE_TYPE,std::allocator<enum _D3DMULTISAMPLE_TYPE> >::_Ufill
_TEXT	ENDS
PUBLIC	??0?$_Container_base_aux_alloc_real@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@IAE@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<enum _D3DMULTISAMPLE_TYPE> >::_Container_base_aux_alloc_real<std::allocator<enum _D3DMULTISAMPLE_TYPE> >
PUBLIC	??0?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@QAE@ABV01@@Z ; std::allocator<enum _D3DMULTISAMPLE_TYPE>::allocator<enum _D3DMULTISAMPLE_TYPE>
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$_Vector_val@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@IAE@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Vector_val@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@IAE@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@1@@Z$0
__ehfuncinfo$??0?$_Vector_val@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@IAE@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Vector_val@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@IAE@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Vector_val@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@IAE@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@1@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T141980 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 1
??0?$_Vector_val@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@IAE@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@1@@Z PROC ; std::_Vector_val<enum _D3DMULTISAMPLE_TYPE,std::allocator<enum _D3DMULTISAMPLE_TYPE> >::_Vector_val<enum _D3DMULTISAMPLE_TYPE,std::allocator<enum _D3DMULTISAMPLE_TYPE> >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Vector_val@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@IAE@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T141980[ebp], esp
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	call	??0?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@QAE@ABV01@@Z ; std::allocator<enum _D3DMULTISAMPLE_TYPE>::allocator<enum _D3DMULTISAMPLE_TYPE>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Container_base_aux_alloc_real@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@IAE@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<enum _D3DMULTISAMPLE_TYPE> >::_Container_base_aux_alloc_real<std::allocator<enum _D3DMULTISAMPLE_TYPE> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??0?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@QAE@ABV01@@Z ; std::allocator<enum _D3DMULTISAMPLE_TYPE>::allocator<enum _D3DMULTISAMPLE_TYPE>

; 426  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Vector_val@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@IAE@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Container_base_aux_alloc_real@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<enum _D3DMULTISAMPLE_TYPE> >::~_Container_base_aux_alloc_real<std::allocator<enum _D3DMULTISAMPLE_TYPE> >
__ehhandler$??0?$_Vector_val@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@IAE@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Vector_val@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@IAE@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Vector_val@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@IAE@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@1@@Z ENDP ; std::_Vector_val<enum _D3DMULTISAMPLE_TYPE,std::allocator<enum _D3DMULTISAMPLE_TYPE> >::_Vector_val<enum _D3DMULTISAMPLE_TYPE,std::allocator<enum _D3DMULTISAMPLE_TYPE> >
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??1?$_Container_base_aux_alloc_real@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@IAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Container_base_aux_alloc_real@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@IAE@XZ$0
__ehfuncinfo$??1?$_Container_base_aux_alloc_real@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@IAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Container_base_aux_alloc_real@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@IAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$_Container_base_aux_alloc_real@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Container_base_aux_alloc_real@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_real<std::allocator<enum _D3DMULTISAMPLE_TYPE> >::~_Container_base_aux_alloc_real<std::allocator<enum _D3DMULTISAMPLE_TYPE> >, COMDAT
; _this$ = ecx

; 436  : 		{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Container_base_aux_alloc_real@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@IAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 437  : 		_Myownedaux->~_Aux_cont();
; 438  : 
; 439  : 		_Alaux.deallocate(_Myownedaux, 1);

	push	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?deallocate@?$allocator@V_Aux_cont@std@@@std@@QAEXPAV_Aux_cont@2@I@Z ; std::allocator<std::_Aux_cont>::deallocate

; 440  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Container_base_aux_alloc_real@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@IAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
__ehhandler$??1?$_Container_base_aux_alloc_real@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@IAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Container_base_aux_alloc_real@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@IAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Container_base_aux_alloc_real@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_real<std::allocator<enum _D3DMULTISAMPLE_TYPE> >::~_Container_base_aux_alloc_real<std::allocator<enum _D3DMULTISAMPLE_TYPE> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@QAE@XZ PROC ; std::allocator<enum _D3DMULTISAMPLE_TYPE>::allocator<enum _D3DMULTISAMPLE_TYPE>, COMDAT
; _this$ = ecx

; 119  : 	allocator() _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@QAE@XZ ENDP ; std::allocator<enum _D3DMULTISAMPLE_TYPE>::allocator<enum _D3DMULTISAMPLE_TYPE>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?capacity@?$vector@IV?$allocator@I@std@@@std@@QBEIXZ
_TEXT	SEGMENT
tv70 = -8						; size = 4
_this$ = -4						; size = 4
?capacity@?$vector@IV?$allocator@I@std@@@std@@QBEIXZ PROC ; std::vector<unsigned int,std::allocator<unsigned int> >::capacity, COMDAT
; _this$ = ecx

; 634  : 		{	// return current length of allocated storage

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	jne	SHORT $LN3@capacity@3
	mov	DWORD PTR tv70[ebp], 0
	jmp	SHORT $LN4@capacity@3
$LN3@capacity@3:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+20]
	sub	eax, DWORD PTR [edx+12]
	sar	eax, 2
	mov	DWORD PTR tv70[ebp], eax
$LN4@capacity@3:
	mov	eax, DWORD PTR tv70[ebp]

; 636  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?capacity@?$vector@IV?$allocator@I@std@@@std@@QBEIXZ ENDP ; std::vector<unsigned int,std::allocator<unsigned int> >::capacity
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@IV?$allocator@I@std@@@std@@QAE@PAIPBV_Container_base_aux@1@@Z ; std::_Vector_iterator<unsigned int,std::allocator<unsigned int> >::_Vector_iterator<unsigned int,std::allocator<unsigned int> >
; Function compile flags: /Odtp
;	COMDAT ?end@?$vector@IV?$allocator@I@std@@@std@@QAE?AV?$_Vector_iterator@IV?$allocator@I@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@IV?$allocator@I@std@@@std@@QAE?AV?$_Vector_iterator@IV?$allocator@I@std@@@2@XZ PROC ; std::vector<unsigned int,std::allocator<unsigned int> >::end, COMDAT
; _this$ = ecx

; 650  : 		{	// return iterator for end of mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 651  : 		return (iterator(_Mylast, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@IV?$allocator@I@std@@@std@@QAE@PAIPBV_Container_base_aux@1@@Z ; std::_Vector_iterator<unsigned int,std::allocator<unsigned int> >::_Vector_iterator<unsigned int,std::allocator<unsigned int> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 652  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?end@?$vector@IV?$allocator@I@std@@@std@@QAE?AV?$_Vector_iterator@IV?$allocator@I@std@@@2@XZ ENDP ; std::vector<unsigned int,std::allocator<unsigned int> >::end
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?size@?$vector@IV?$allocator@I@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$vector@IV?$allocator@I@std@@@std@@QBEIXZ PROC	; std::vector<unsigned int,std::allocator<unsigned int> >::size, COMDAT
; _this$ = ecx

; 725  : 		{	// return length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+16]
	sub	eax, DWORD PTR [ecx+12]
	sar	eax, 2

; 727  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?size@?$vector@IV?$allocator@I@std@@@std@@QBEIXZ ENDP	; std::vector<unsigned int,std::allocator<unsigned int> >::size
_TEXT	ENDS
PUBLIC	??H?$_Vector_iterator@IV?$allocator@I@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<unsigned int,std::allocator<unsigned int> >::operator+
PUBLIC	?_Insert_n@?$vector@IV?$allocator@I@std@@@std@@IAEXV?$_Vector_const_iterator@IV?$allocator@I@std@@@2@IABI@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Insert_n
PUBLIC	??G?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@QBEHABV01@@Z ; std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> >::operator-
PUBLIC	?begin@?$vector@IV?$allocator@I@std@@@std@@QAE?AV?$_Vector_iterator@IV?$allocator@I@std@@@2@XZ ; std::vector<unsigned int,std::allocator<unsigned int> >::begin
; Function compile flags: /Odtp
;	COMDAT ?insert@?$vector@IV?$allocator@I@std@@@std@@QAE?AV?$_Vector_iterator@IV?$allocator@I@std@@@2@V?$_Vector_const_iterator@IV?$allocator@I@std@@@2@ABI@Z
_TEXT	SEGMENT
tv77 = -28						; size = 4
_this$ = -24						; size = 4
$T142012 = -20						; size = 8
$T142009 = -12						; size = 8
__Off$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 8
__Val$ = 20						; size = 4
?insert@?$vector@IV?$allocator@I@std@@@std@@QAE?AV?$_Vector_iterator@IV?$allocator@I@std@@@2@V?$_Vector_const_iterator@IV?$allocator@I@std@@@2@ABI@Z PROC ; std::vector<unsigned int,std::allocator<unsigned int> >::insert, COMDAT
; _this$ = ecx

; 875  : 		{	// insert _Val at _Where

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR _this$[ebp], ecx

; 876  : 		size_type _Off = size() == 0 ? 0 : _Where - begin();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@IV?$allocator@I@std@@@std@@QBEIXZ ; std::vector<unsigned int,std::allocator<unsigned int> >::size
	test	eax, eax
	jne	SHORT $LN3@insert@3
	mov	DWORD PTR tv77[ebp], 0
	jmp	SHORT $LN4@insert@3
$LN3@insert@3:
	lea	eax, DWORD PTR $T142009[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$vector@IV?$allocator@I@std@@@std@@QAE?AV?$_Vector_iterator@IV?$allocator@I@std@@@2@XZ ; std::vector<unsigned int,std::allocator<unsigned int> >::begin
	push	eax
	lea	ecx, DWORD PTR __Where$[ebp]
	call	??G?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@QBEHABV01@@Z ; std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> >::operator-
	mov	DWORD PTR tv77[ebp], eax
$LN4@insert@3:
	mov	ecx, DWORD PTR tv77[ebp]
	mov	DWORD PTR __Off$[ebp], ecx

; 877  : 		_Insert_n(_Where, (size_type)1, _Val);

	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	push	1
	mov	eax, DWORD PTR __Where$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert_n@?$vector@IV?$allocator@I@std@@@std@@IAEXV?$_Vector_const_iterator@IV?$allocator@I@std@@@2@IABI@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Insert_n

; 878  : 		return (begin() + _Off);

	mov	edx, DWORD PTR __Off$[ebp]
	push	edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T142012[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$vector@IV?$allocator@I@std@@@std@@QAE?AV?$_Vector_iterator@IV?$allocator@I@std@@@2@XZ ; std::vector<unsigned int,std::allocator<unsigned int> >::begin
	mov	ecx, eax
	call	??H?$_Vector_iterator@IV?$allocator@I@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<unsigned int,std::allocator<unsigned int> >::operator+
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 879  : 		}

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?insert@?$vector@IV?$allocator@I@std@@@std@@QAE?AV?$_Vector_iterator@IV?$allocator@I@std@@@2@V?$_Vector_const_iterator@IV?$allocator@I@std@@@2@ABI@Z ENDP ; std::vector<unsigned int,std::allocator<unsigned int> >::insert
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@I@std@@QAEPAII@Z		; std::allocator<unsigned int>::allocate
PUBLIC	?_Xlen@?$vector@IV?$allocator@I@std@@@std@@KAXXZ ; std::vector<unsigned int,std::allocator<unsigned int> >::_Xlen
PUBLIC	?max_size@?$vector@IV?$allocator@I@std@@@std@@QBEIXZ ; std::vector<unsigned int,std::allocator<unsigned int> >::max_size
; Function compile flags: /Odtp
;	COMDAT ?_Buy@?$vector@IV?$allocator@I@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Capacity$ = 8						; size = 4
?_Buy@?$vector@IV?$allocator@I@std@@@std@@IAE_NI@Z PROC	; std::vector<unsigned int,std::allocator<unsigned int> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+20], 0

; 1104 : 		if (_Capacity == 0)

	cmp	DWORD PTR __Capacity$[ebp], 0
	jne	SHORT $LN4@Buy@3

; 1105 : 			return (false);

	xor	al, al
	jmp	SHORT $LN5@Buy@3
	jmp	SHORT $LN3@Buy@3
$LN4@Buy@3:

; 1106 : 		else if (max_size() < _Capacity)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@IV?$allocator@I@std@@@std@@QBEIXZ ; std::vector<unsigned int,std::allocator<unsigned int> >::max_size
	cmp	eax, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN2@Buy@3

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@IV?$allocator@I@std@@@std@@KAXXZ ; std::vector<unsigned int,std::allocator<unsigned int> >::_Xlen

; 1108 : 		else

	jmp	SHORT $LN3@Buy@3
$LN2@Buy@3:

; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	mov	eax, DWORD PTR __Capacity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?allocate@?$allocator@I@std@@QAEPAII@Z	; std::allocator<unsigned int>::allocate
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [edx+16], ecx

; 1112 : 			_Myend = _Myfirst + _Capacity;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR __Capacity$[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], edx
$LN3@Buy@3:

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
$LN5@Buy@3:

; 1115 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Buy@?$vector@IV?$allocator@I@std@@@std@@IAE_NI@Z ENDP	; std::vector<unsigned int,std::allocator<unsigned int> >::_Buy
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@I@std@@QAEXPAII@Z	; std::allocator<unsigned int>::deallocate
PUBLIC	?_Destroy@?$vector@IV?$allocator@I@std@@@std@@IAEXPAI0@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Destroy
; Function compile flags: /Odtp
;	COMDAT ?_Tidy@?$vector@IV?$allocator@I@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Tidy@?$vector@IV?$allocator@I@std@@@std@@IAEXXZ PROC	; std::vector<unsigned int,std::allocator<unsigned int> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	je	SHORT $LN1@Tidy@3

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@IV?$allocator@I@std@@@std@@IAEXPAI0@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Destroy

; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+20]
	sub	ecx, DWORD PTR [eax+12]
	sar	ecx, 2
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?deallocate@?$allocator@I@std@@QAEXPAII@Z ; std::allocator<unsigned int>::deallocate
$LN1@Tidy@3:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+16], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], 0

; 1135 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$vector@IV?$allocator@I@std@@@std@@IAEXXZ ENDP	; std::vector<unsigned int,std::allocator<unsigned int> >::_Tidy
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_fill_n@PAIIIV?$allocator@I@std@@@stdext@@YAXPAIIABIAAV?$allocator@I@std@@@Z ; stdext::unchecked_uninitialized_fill_n<unsigned int *,unsigned int,unsigned int,std::allocator<unsigned int> >
; Function compile flags: /Odtp
;	COMDAT ?_Ufill@?$vector@IV?$allocator@I@std@@@std@@IAEPAIPAIIABI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Ufill@?$vector@IV?$allocator@I@std@@@std@@IAEPAIPAIIABI@Z PROC ; std::vector<unsigned int,std::allocator<unsigned int> >::_Ufill, COMDAT
; _this$ = ecx

; 1253 : 		{	// copy initializing _Count * _Val, using allocator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1254 : 		_STDEXT unchecked_uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??$unchecked_uninitialized_fill_n@PAIIIV?$allocator@I@std@@@stdext@@YAXPAIIABIAAV?$allocator@I@std@@@Z ; stdext::unchecked_uninitialized_fill_n<unsigned int *,unsigned int,unsigned int,std::allocator<unsigned int> >
	add	esp, 16					; 00000010H

; 1255 : 		return (_Ptr + _Count);

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Ptr$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]

; 1256 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?_Ufill@?$vector@IV?$allocator@I@std@@@std@@IAEPAIPAIIABI@Z ENDP ; std::vector<unsigned int,std::allocator<unsigned int> >::_Ufill
_TEXT	ENDS
PUBLIC	??0?$_Container_base_aux_alloc_real@V?$allocator@I@std@@@std@@IAE@V?$allocator@I@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<unsigned int> >::_Container_base_aux_alloc_real<std::allocator<unsigned int> >
PUBLIC	??0?$allocator@I@std@@QAE@ABV01@@Z		; std::allocator<unsigned int>::allocator<unsigned int>
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$_Vector_val@IV?$allocator@I@std@@@std@@IAE@V?$allocator@I@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Vector_val@IV?$allocator@I@std@@@std@@IAE@V?$allocator@I@1@@Z$0
__ehfuncinfo$??0?$_Vector_val@IV?$allocator@I@std@@@std@@IAE@V?$allocator@I@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Vector_val@IV?$allocator@I@std@@@std@@IAE@V?$allocator@I@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Vector_val@IV?$allocator@I@std@@@std@@IAE@V?$allocator@I@1@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T142021 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 1
??0?$_Vector_val@IV?$allocator@I@std@@@std@@IAE@V?$allocator@I@1@@Z PROC ; std::_Vector_val<unsigned int,std::allocator<unsigned int> >::_Vector_val<unsigned int,std::allocator<unsigned int> >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Vector_val@IV?$allocator@I@std@@@std@@IAE@V?$allocator@I@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T142021[ebp], esp
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	call	??0?$allocator@I@std@@QAE@ABV01@@Z	; std::allocator<unsigned int>::allocator<unsigned int>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Container_base_aux_alloc_real@V?$allocator@I@std@@@std@@IAE@V?$allocator@I@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<unsigned int> >::_Container_base_aux_alloc_real<std::allocator<unsigned int> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??0?$allocator@I@std@@QAE@ABV01@@Z	; std::allocator<unsigned int>::allocator<unsigned int>

; 426  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Vector_val@IV?$allocator@I@std@@@std@@IAE@V?$allocator@I@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Container_base_aux_alloc_real@V?$allocator@I@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<unsigned int> >::~_Container_base_aux_alloc_real<std::allocator<unsigned int> >
__ehhandler$??0?$_Vector_val@IV?$allocator@I@std@@@std@@IAE@V?$allocator@I@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Vector_val@IV?$allocator@I@std@@@std@@IAE@V?$allocator@I@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Vector_val@IV?$allocator@I@std@@@std@@IAE@V?$allocator@I@1@@Z ENDP ; std::_Vector_val<unsigned int,std::allocator<unsigned int> >::_Vector_val<unsigned int,std::allocator<unsigned int> >
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??1?$_Container_base_aux_alloc_real@V?$allocator@I@std@@@std@@IAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Container_base_aux_alloc_real@V?$allocator@I@std@@@std@@IAE@XZ$0
__ehfuncinfo$??1?$_Container_base_aux_alloc_real@V?$allocator@I@std@@@std@@IAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Container_base_aux_alloc_real@V?$allocator@I@std@@@std@@IAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$_Container_base_aux_alloc_real@V?$allocator@I@std@@@std@@IAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Container_base_aux_alloc_real@V?$allocator@I@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_real<std::allocator<unsigned int> >::~_Container_base_aux_alloc_real<std::allocator<unsigned int> >, COMDAT
; _this$ = ecx

; 436  : 		{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Container_base_aux_alloc_real@V?$allocator@I@std@@@std@@IAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 437  : 		_Myownedaux->~_Aux_cont();
; 438  : 
; 439  : 		_Alaux.deallocate(_Myownedaux, 1);

	push	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?deallocate@?$allocator@V_Aux_cont@std@@@std@@QAEXPAV_Aux_cont@2@I@Z ; std::allocator<std::_Aux_cont>::deallocate

; 440  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Container_base_aux_alloc_real@V?$allocator@I@std@@@std@@IAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
__ehhandler$??1?$_Container_base_aux_alloc_real@V?$allocator@I@std@@@std@@IAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Container_base_aux_alloc_real@V?$allocator@I@std@@@std@@IAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Container_base_aux_alloc_real@V?$allocator@I@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_real<std::allocator<unsigned int> >::~_Container_base_aux_alloc_real<std::allocator<unsigned int> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@I@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@I@std@@QAE@XZ PROC			; std::allocator<unsigned int>::allocator<unsigned int>, COMDAT
; _this$ = ecx

; 119  : 	allocator() _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$allocator@I@std@@QAE@XZ ENDP			; std::allocator<unsigned int>::allocator<unsigned int>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?capacity@?$vector@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
tv70 = -8						; size = 4
_this$ = -4						; size = 4
?capacity@?$vector@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@QBEIXZ PROC ; std::vector<Ogre::D3DSMSCONFLICT_T,std::allocator<Ogre::D3DSMSCONFLICT_T> >::capacity, COMDAT
; _this$ = ecx

; 634  : 		{	// return current length of allocated storage

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	jne	SHORT $LN3@capacity@4
	mov	DWORD PTR tv70[ebp], 0
	jmp	SHORT $LN4@capacity@4
$LN3@capacity@4:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+20]
	sub	eax, DWORD PTR [edx+12]
	sar	eax, 3
	mov	DWORD PTR tv70[ebp], eax
$LN4@capacity@4:
	mov	eax, DWORD PTR tv70[ebp]

; 636  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?capacity@?$vector@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@QBEIXZ ENDP ; std::vector<Ogre::D3DSMSCONFLICT_T,std::allocator<Ogre::D3DSMSCONFLICT_T> >::capacity
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@QAE@PAUD3DSMSCONFLICT_T@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::D3DSMSCONFLICT_T,std::allocator<Ogre::D3DSMSCONFLICT_T> >::_Vector_iterator<Ogre::D3DSMSCONFLICT_T,std::allocator<Ogre::D3DSMSCONFLICT_T> >
; Function compile flags: /Odtp
;	COMDAT ?end@?$vector@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@2@XZ PROC ; std::vector<Ogre::D3DSMSCONFLICT_T,std::allocator<Ogre::D3DSMSCONFLICT_T> >::end, COMDAT
; _this$ = ecx

; 650  : 		{	// return iterator for end of mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 651  : 		return (iterator(_Mylast, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@QAE@PAUD3DSMSCONFLICT_T@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::D3DSMSCONFLICT_T,std::allocator<Ogre::D3DSMSCONFLICT_T> >::_Vector_iterator<Ogre::D3DSMSCONFLICT_T,std::allocator<Ogre::D3DSMSCONFLICT_T> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 652  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?end@?$vector@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@2@XZ ENDP ; std::vector<Ogre::D3DSMSCONFLICT_T,std::allocator<Ogre::D3DSMSCONFLICT_T> >::end
_TEXT	ENDS
PUBLIC	??H?$_Vector_iterator@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<Ogre::D3DSMSCONFLICT_T,std::allocator<Ogre::D3DSMSCONFLICT_T> >::operator+
PUBLIC	?_Insert_n@?$vector@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@2@IABUD3DSMSCONFLICT_T@Ogre@@@Z ; std::vector<Ogre::D3DSMSCONFLICT_T,std::allocator<Ogre::D3DSMSCONFLICT_T> >::_Insert_n
PUBLIC	??G?$_Vector_const_iterator@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@QBEHABV01@@Z ; std::_Vector_const_iterator<Ogre::D3DSMSCONFLICT_T,std::allocator<Ogre::D3DSMSCONFLICT_T> >::operator-
PUBLIC	?begin@?$vector@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@2@XZ ; std::vector<Ogre::D3DSMSCONFLICT_T,std::allocator<Ogre::D3DSMSCONFLICT_T> >::begin
; Function compile flags: /Odtp
;	COMDAT ?insert@?$vector@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@2@V?$_Vector_const_iterator@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@2@ABUD3DSMSCONFLICT_T@Ogre@@@Z
_TEXT	SEGMENT
tv77 = -28						; size = 4
_this$ = -24						; size = 4
$T142051 = -20						; size = 8
$T142048 = -12						; size = 8
__Off$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 8
__Val$ = 20						; size = 4
?insert@?$vector@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@2@V?$_Vector_const_iterator@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@2@ABUD3DSMSCONFLICT_T@Ogre@@@Z PROC ; std::vector<Ogre::D3DSMSCONFLICT_T,std::allocator<Ogre::D3DSMSCONFLICT_T> >::insert, COMDAT
; _this$ = ecx

; 875  : 		{	// insert _Val at _Where

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR _this$[ebp], ecx

; 876  : 		size_type _Off = size() == 0 ? 0 : _Where - begin();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::D3DSMSCONFLICT_T,std::allocator<Ogre::D3DSMSCONFLICT_T> >::size
	test	eax, eax
	jne	SHORT $LN3@insert@4
	mov	DWORD PTR tv77[ebp], 0
	jmp	SHORT $LN4@insert@4
$LN3@insert@4:
	lea	eax, DWORD PTR $T142048[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$vector@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@2@XZ ; std::vector<Ogre::D3DSMSCONFLICT_T,std::allocator<Ogre::D3DSMSCONFLICT_T> >::begin
	push	eax
	lea	ecx, DWORD PTR __Where$[ebp]
	call	??G?$_Vector_const_iterator@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@QBEHABV01@@Z ; std::_Vector_const_iterator<Ogre::D3DSMSCONFLICT_T,std::allocator<Ogre::D3DSMSCONFLICT_T> >::operator-
	mov	DWORD PTR tv77[ebp], eax
$LN4@insert@4:
	mov	ecx, DWORD PTR tv77[ebp]
	mov	DWORD PTR __Off$[ebp], ecx

; 877  : 		_Insert_n(_Where, (size_type)1, _Val);

	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	push	1
	mov	eax, DWORD PTR __Where$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert_n@?$vector@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@2@IABUD3DSMSCONFLICT_T@Ogre@@@Z ; std::vector<Ogre::D3DSMSCONFLICT_T,std::allocator<Ogre::D3DSMSCONFLICT_T> >::_Insert_n

; 878  : 		return (begin() + _Off);

	mov	edx, DWORD PTR __Off$[ebp]
	push	edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T142051[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$vector@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@2@XZ ; std::vector<Ogre::D3DSMSCONFLICT_T,std::allocator<Ogre::D3DSMSCONFLICT_T> >::begin
	mov	ecx, eax
	call	??H?$_Vector_iterator@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<Ogre::D3DSMSCONFLICT_T,std::allocator<Ogre::D3DSMSCONFLICT_T> >::operator+
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 879  : 		}

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?insert@?$vector@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@2@V?$_Vector_const_iterator@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@2@ABUD3DSMSCONFLICT_T@Ogre@@@Z ENDP ; std::vector<Ogre::D3DSMSCONFLICT_T,std::allocator<Ogre::D3DSMSCONFLICT_T> >::insert
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@QAEPAUD3DSMSCONFLICT_T@Ogre@@I@Z ; std::allocator<Ogre::D3DSMSCONFLICT_T>::allocate
PUBLIC	?_Xlen@?$vector@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@KAXXZ ; std::vector<Ogre::D3DSMSCONFLICT_T,std::allocator<Ogre::D3DSMSCONFLICT_T> >::_Xlen
PUBLIC	?max_size@?$vector@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::D3DSMSCONFLICT_T,std::allocator<Ogre::D3DSMSCONFLICT_T> >::max_size
; Function compile flags: /Odtp
;	COMDAT ?_Buy@?$vector@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Capacity$ = 8						; size = 4
?_Buy@?$vector@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@IAE_NI@Z PROC ; std::vector<Ogre::D3DSMSCONFLICT_T,std::allocator<Ogre::D3DSMSCONFLICT_T> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+20], 0

; 1104 : 		if (_Capacity == 0)

	cmp	DWORD PTR __Capacity$[ebp], 0
	jne	SHORT $LN4@Buy@4

; 1105 : 			return (false);

	xor	al, al
	jmp	SHORT $LN5@Buy@4
	jmp	SHORT $LN3@Buy@4
$LN4@Buy@4:

; 1106 : 		else if (max_size() < _Capacity)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::D3DSMSCONFLICT_T,std::allocator<Ogre::D3DSMSCONFLICT_T> >::max_size
	cmp	eax, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN2@Buy@4

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@KAXXZ ; std::vector<Ogre::D3DSMSCONFLICT_T,std::allocator<Ogre::D3DSMSCONFLICT_T> >::_Xlen

; 1108 : 		else

	jmp	SHORT $LN3@Buy@4
$LN2@Buy@4:

; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	mov	eax, DWORD PTR __Capacity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?allocate@?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@QAEPAUD3DSMSCONFLICT_T@Ogre@@I@Z ; std::allocator<Ogre::D3DSMSCONFLICT_T>::allocate
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [edx+16], ecx

; 1112 : 			_Myend = _Myfirst + _Capacity;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR __Capacity$[ebp]
	lea	edx, DWORD PTR [eax+ecx*8]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], edx
$LN3@Buy@4:

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
$LN5@Buy@4:

; 1115 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Buy@?$vector@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<Ogre::D3DSMSCONFLICT_T,std::allocator<Ogre::D3DSMSCONFLICT_T> >::_Buy
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@QAEXPAUD3DSMSCONFLICT_T@Ogre@@I@Z ; std::allocator<Ogre::D3DSMSCONFLICT_T>::deallocate
PUBLIC	?_Destroy@?$vector@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@IAEXPAUD3DSMSCONFLICT_T@Ogre@@0@Z ; std::vector<Ogre::D3DSMSCONFLICT_T,std::allocator<Ogre::D3DSMSCONFLICT_T> >::_Destroy
; Function compile flags: /Odtp
;	COMDAT ?_Tidy@?$vector@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Tidy@?$vector@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@IAEXXZ PROC ; std::vector<Ogre::D3DSMSCONFLICT_T,std::allocator<Ogre::D3DSMSCONFLICT_T> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	je	SHORT $LN1@Tidy@4

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@IAEXPAUD3DSMSCONFLICT_T@Ogre@@0@Z ; std::vector<Ogre::D3DSMSCONFLICT_T,std::allocator<Ogre::D3DSMSCONFLICT_T> >::_Destroy

; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+20]
	sub	ecx, DWORD PTR [eax+12]
	sar	ecx, 3
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?deallocate@?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@QAEXPAUD3DSMSCONFLICT_T@Ogre@@I@Z ; std::allocator<Ogre::D3DSMSCONFLICT_T>::deallocate
$LN1@Tidy@4:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+16], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], 0

; 1135 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$vector@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@IAEXXZ ENDP ; std::vector<Ogre::D3DSMSCONFLICT_T,std::allocator<Ogre::D3DSMSCONFLICT_T> >::_Tidy
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_fill_n@PAUD3DSMSCONFLICT_T@Ogre@@IU12@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@stdext@@YAXPAUD3DSMSCONFLICT_T@Ogre@@IABU12@AAV?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@Z ; stdext::unchecked_uninitialized_fill_n<Ogre::D3DSMSCONFLICT_T *,unsigned int,Ogre::D3DSMSCONFLICT_T,std::allocator<Ogre::D3DSMSCONFLICT_T> >
; Function compile flags: /Odtp
;	COMDAT ?_Ufill@?$vector@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@IAEPAUD3DSMSCONFLICT_T@Ogre@@PAU34@IABU34@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Ufill@?$vector@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@IAEPAUD3DSMSCONFLICT_T@Ogre@@PAU34@IABU34@@Z PROC ; std::vector<Ogre::D3DSMSCONFLICT_T,std::allocator<Ogre::D3DSMSCONFLICT_T> >::_Ufill, COMDAT
; _this$ = ecx

; 1253 : 		{	// copy initializing _Count * _Val, using allocator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1254 : 		_STDEXT unchecked_uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??$unchecked_uninitialized_fill_n@PAUD3DSMSCONFLICT_T@Ogre@@IU12@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@stdext@@YAXPAUD3DSMSCONFLICT_T@Ogre@@IABU12@AAV?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@Z ; stdext::unchecked_uninitialized_fill_n<Ogre::D3DSMSCONFLICT_T *,unsigned int,Ogre::D3DSMSCONFLICT_T,std::allocator<Ogre::D3DSMSCONFLICT_T> >
	add	esp, 16					; 00000010H

; 1255 : 		return (_Ptr + _Count);

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Ptr$[ebp]
	lea	eax, DWORD PTR [edx+ecx*8]

; 1256 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?_Ufill@?$vector@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@IAEPAUD3DSMSCONFLICT_T@Ogre@@PAU34@IABU34@@Z ENDP ; std::vector<Ogre::D3DSMSCONFLICT_T,std::allocator<Ogre::D3DSMSCONFLICT_T> >::_Ufill
_TEXT	ENDS
PUBLIC	??0?$_Container_base_aux_alloc_real@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@IAE@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::D3DSMSCONFLICT_T> >::_Container_base_aux_alloc_real<std::allocator<Ogre::D3DSMSCONFLICT_T> >
PUBLIC	??0?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::D3DSMSCONFLICT_T>::allocator<Ogre::D3DSMSCONFLICT_T>
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$_Vector_val@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@IAE@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Vector_val@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@IAE@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@1@@Z$0
__ehfuncinfo$??0?$_Vector_val@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@IAE@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Vector_val@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@IAE@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Vector_val@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@IAE@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@1@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T142060 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 1
??0?$_Vector_val@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@IAE@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@1@@Z PROC ; std::_Vector_val<Ogre::D3DSMSCONFLICT_T,std::allocator<Ogre::D3DSMSCONFLICT_T> >::_Vector_val<Ogre::D3DSMSCONFLICT_T,std::allocator<Ogre::D3DSMSCONFLICT_T> >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Vector_val@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@IAE@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T142060[ebp], esp
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	call	??0?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::D3DSMSCONFLICT_T>::allocator<Ogre::D3DSMSCONFLICT_T>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Container_base_aux_alloc_real@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@IAE@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::D3DSMSCONFLICT_T> >::_Container_base_aux_alloc_real<std::allocator<Ogre::D3DSMSCONFLICT_T> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??0?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::D3DSMSCONFLICT_T>::allocator<Ogre::D3DSMSCONFLICT_T>

; 426  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Vector_val@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@IAE@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Container_base_aux_alloc_real@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::D3DSMSCONFLICT_T> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::D3DSMSCONFLICT_T> >
__ehhandler$??0?$_Vector_val@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@IAE@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Vector_val@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@IAE@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Vector_val@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@IAE@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@1@@Z ENDP ; std::_Vector_val<Ogre::D3DSMSCONFLICT_T,std::allocator<Ogre::D3DSMSCONFLICT_T> >::_Vector_val<Ogre::D3DSMSCONFLICT_T,std::allocator<Ogre::D3DSMSCONFLICT_T> >
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??1?$_Container_base_aux_alloc_real@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@IAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Container_base_aux_alloc_real@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@IAE@XZ$0
__ehfuncinfo$??1?$_Container_base_aux_alloc_real@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@IAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Container_base_aux_alloc_real@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@IAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$_Container_base_aux_alloc_real@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Container_base_aux_alloc_real@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::D3DSMSCONFLICT_T> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::D3DSMSCONFLICT_T> >, COMDAT
; _this$ = ecx

; 436  : 		{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Container_base_aux_alloc_real@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@IAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 437  : 		_Myownedaux->~_Aux_cont();
; 438  : 
; 439  : 		_Alaux.deallocate(_Myownedaux, 1);

	push	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?deallocate@?$allocator@V_Aux_cont@std@@@std@@QAEXPAV_Aux_cont@2@I@Z ; std::allocator<std::_Aux_cont>::deallocate

; 440  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Container_base_aux_alloc_real@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@IAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
__ehhandler$??1?$_Container_base_aux_alloc_real@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@IAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Container_base_aux_alloc_real@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@IAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Container_base_aux_alloc_real@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::D3DSMSCONFLICT_T> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::D3DSMSCONFLICT_T> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@QAE@XZ PROC ; std::allocator<Ogre::D3DSMSCONFLICT_T>::allocator<Ogre::D3DSMSCONFLICT_T>, COMDAT
; _this$ = ecx

; 119  : 	allocator() _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@QAE@XZ ENDP ; std::allocator<Ogre::D3DSMSCONFLICT_T>::allocator<Ogre::D3DSMSCONFLICT_T>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?capacity@?$vector@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
tv70 = -8						; size = 4
_this$ = -4						; size = 4
?capacity@?$vector@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@QBEIXZ PROC ; std::vector<enum Ogre::VERTPROCESS_T,std::allocator<enum Ogre::VERTPROCESS_T> >::capacity, COMDAT
; _this$ = ecx

; 634  : 		{	// return current length of allocated storage

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	jne	SHORT $LN3@capacity@5
	mov	DWORD PTR tv70[ebp], 0
	jmp	SHORT $LN4@capacity@5
$LN3@capacity@5:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+20]
	sub	eax, DWORD PTR [edx+12]
	sar	eax, 2
	mov	DWORD PTR tv70[ebp], eax
$LN4@capacity@5:
	mov	eax, DWORD PTR tv70[ebp]

; 636  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?capacity@?$vector@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@QBEIXZ ENDP ; std::vector<enum Ogre::VERTPROCESS_T,std::allocator<enum Ogre::VERTPROCESS_T> >::capacity
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@QAE@PAW4VERTPROCESS_T@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<enum Ogre::VERTPROCESS_T,std::allocator<enum Ogre::VERTPROCESS_T> >::_Vector_iterator<enum Ogre::VERTPROCESS_T,std::allocator<enum Ogre::VERTPROCESS_T> >
; Function compile flags: /Odtp
;	COMDAT ?end@?$vector@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@2@XZ PROC ; std::vector<enum Ogre::VERTPROCESS_T,std::allocator<enum Ogre::VERTPROCESS_T> >::end, COMDAT
; _this$ = ecx

; 650  : 		{	// return iterator for end of mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 651  : 		return (iterator(_Mylast, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@QAE@PAW4VERTPROCESS_T@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<enum Ogre::VERTPROCESS_T,std::allocator<enum Ogre::VERTPROCESS_T> >::_Vector_iterator<enum Ogre::VERTPROCESS_T,std::allocator<enum Ogre::VERTPROCESS_T> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 652  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?end@?$vector@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@2@XZ ENDP ; std::vector<enum Ogre::VERTPROCESS_T,std::allocator<enum Ogre::VERTPROCESS_T> >::end
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?size@?$vector@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$vector@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@QBEIXZ PROC ; std::vector<enum Ogre::VERTPROCESS_T,std::allocator<enum Ogre::VERTPROCESS_T> >::size, COMDAT
; _this$ = ecx

; 725  : 		{	// return length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+16]
	sub	eax, DWORD PTR [ecx+12]
	sar	eax, 2

; 727  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?size@?$vector@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@QBEIXZ ENDP ; std::vector<enum Ogre::VERTPROCESS_T,std::allocator<enum Ogre::VERTPROCESS_T> >::size
_TEXT	ENDS
PUBLIC	??H?$_Vector_iterator@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<enum Ogre::VERTPROCESS_T,std::allocator<enum Ogre::VERTPROCESS_T> >::operator+
PUBLIC	?_Insert_n@?$vector@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@2@IABW4VERTPROCESS_T@Ogre@@@Z ; std::vector<enum Ogre::VERTPROCESS_T,std::allocator<enum Ogre::VERTPROCESS_T> >::_Insert_n
PUBLIC	??G?$_Vector_const_iterator@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@QBEHABV01@@Z ; std::_Vector_const_iterator<enum Ogre::VERTPROCESS_T,std::allocator<enum Ogre::VERTPROCESS_T> >::operator-
PUBLIC	?begin@?$vector@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@2@XZ ; std::vector<enum Ogre::VERTPROCESS_T,std::allocator<enum Ogre::VERTPROCESS_T> >::begin
; Function compile flags: /Odtp
;	COMDAT ?insert@?$vector@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@2@V?$_Vector_const_iterator@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@2@ABW4VERTPROCESS_T@Ogre@@@Z
_TEXT	SEGMENT
tv77 = -28						; size = 4
_this$ = -24						; size = 4
$T142092 = -20						; size = 8
$T142089 = -12						; size = 8
__Off$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 8
__Val$ = 20						; size = 4
?insert@?$vector@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@2@V?$_Vector_const_iterator@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@2@ABW4VERTPROCESS_T@Ogre@@@Z PROC ; std::vector<enum Ogre::VERTPROCESS_T,std::allocator<enum Ogre::VERTPROCESS_T> >::insert, COMDAT
; _this$ = ecx

; 875  : 		{	// insert _Val at _Where

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR _this$[ebp], ecx

; 876  : 		size_type _Off = size() == 0 ? 0 : _Where - begin();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@QBEIXZ ; std::vector<enum Ogre::VERTPROCESS_T,std::allocator<enum Ogre::VERTPROCESS_T> >::size
	test	eax, eax
	jne	SHORT $LN3@insert@5
	mov	DWORD PTR tv77[ebp], 0
	jmp	SHORT $LN4@insert@5
$LN3@insert@5:
	lea	eax, DWORD PTR $T142089[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$vector@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@2@XZ ; std::vector<enum Ogre::VERTPROCESS_T,std::allocator<enum Ogre::VERTPROCESS_T> >::begin
	push	eax
	lea	ecx, DWORD PTR __Where$[ebp]
	call	??G?$_Vector_const_iterator@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@QBEHABV01@@Z ; std::_Vector_const_iterator<enum Ogre::VERTPROCESS_T,std::allocator<enum Ogre::VERTPROCESS_T> >::operator-
	mov	DWORD PTR tv77[ebp], eax
$LN4@insert@5:
	mov	ecx, DWORD PTR tv77[ebp]
	mov	DWORD PTR __Off$[ebp], ecx

; 877  : 		_Insert_n(_Where, (size_type)1, _Val);

	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	push	1
	mov	eax, DWORD PTR __Where$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert_n@?$vector@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@2@IABW4VERTPROCESS_T@Ogre@@@Z ; std::vector<enum Ogre::VERTPROCESS_T,std::allocator<enum Ogre::VERTPROCESS_T> >::_Insert_n

; 878  : 		return (begin() + _Off);

	mov	edx, DWORD PTR __Off$[ebp]
	push	edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T142092[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$vector@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@2@XZ ; std::vector<enum Ogre::VERTPROCESS_T,std::allocator<enum Ogre::VERTPROCESS_T> >::begin
	mov	ecx, eax
	call	??H?$_Vector_iterator@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<enum Ogre::VERTPROCESS_T,std::allocator<enum Ogre::VERTPROCESS_T> >::operator+
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 879  : 		}

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?insert@?$vector@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@2@V?$_Vector_const_iterator@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@2@ABW4VERTPROCESS_T@Ogre@@@Z ENDP ; std::vector<enum Ogre::VERTPROCESS_T,std::allocator<enum Ogre::VERTPROCESS_T> >::insert
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@W4VERTPROCESS_T@Ogre@@@std@@QAEPAW4VERTPROCESS_T@Ogre@@I@Z ; std::allocator<enum Ogre::VERTPROCESS_T>::allocate
PUBLIC	?_Xlen@?$vector@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@KAXXZ ; std::vector<enum Ogre::VERTPROCESS_T,std::allocator<enum Ogre::VERTPROCESS_T> >::_Xlen
PUBLIC	?max_size@?$vector@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@QBEIXZ ; std::vector<enum Ogre::VERTPROCESS_T,std::allocator<enum Ogre::VERTPROCESS_T> >::max_size
; Function compile flags: /Odtp
;	COMDAT ?_Buy@?$vector@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Capacity$ = 8						; size = 4
?_Buy@?$vector@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@IAE_NI@Z PROC ; std::vector<enum Ogre::VERTPROCESS_T,std::allocator<enum Ogre::VERTPROCESS_T> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+20], 0

; 1104 : 		if (_Capacity == 0)

	cmp	DWORD PTR __Capacity$[ebp], 0
	jne	SHORT $LN4@Buy@5

; 1105 : 			return (false);

	xor	al, al
	jmp	SHORT $LN5@Buy@5
	jmp	SHORT $LN3@Buy@5
$LN4@Buy@5:

; 1106 : 		else if (max_size() < _Capacity)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@QBEIXZ ; std::vector<enum Ogre::VERTPROCESS_T,std::allocator<enum Ogre::VERTPROCESS_T> >::max_size
	cmp	eax, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN2@Buy@5

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@KAXXZ ; std::vector<enum Ogre::VERTPROCESS_T,std::allocator<enum Ogre::VERTPROCESS_T> >::_Xlen

; 1108 : 		else

	jmp	SHORT $LN3@Buy@5
$LN2@Buy@5:

; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	mov	eax, DWORD PTR __Capacity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?allocate@?$allocator@W4VERTPROCESS_T@Ogre@@@std@@QAEPAW4VERTPROCESS_T@Ogre@@I@Z ; std::allocator<enum Ogre::VERTPROCESS_T>::allocate
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [edx+16], ecx

; 1112 : 			_Myend = _Myfirst + _Capacity;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR __Capacity$[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], edx
$LN3@Buy@5:

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
$LN5@Buy@5:

; 1115 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Buy@?$vector@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<enum Ogre::VERTPROCESS_T,std::allocator<enum Ogre::VERTPROCESS_T> >::_Buy
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@W4VERTPROCESS_T@Ogre@@@std@@QAEXPAW4VERTPROCESS_T@Ogre@@I@Z ; std::allocator<enum Ogre::VERTPROCESS_T>::deallocate
PUBLIC	?_Destroy@?$vector@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@IAEXPAW4VERTPROCESS_T@Ogre@@0@Z ; std::vector<enum Ogre::VERTPROCESS_T,std::allocator<enum Ogre::VERTPROCESS_T> >::_Destroy
; Function compile flags: /Odtp
;	COMDAT ?_Tidy@?$vector@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Tidy@?$vector@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@IAEXXZ PROC ; std::vector<enum Ogre::VERTPROCESS_T,std::allocator<enum Ogre::VERTPROCESS_T> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	je	SHORT $LN1@Tidy@5

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@IAEXPAW4VERTPROCESS_T@Ogre@@0@Z ; std::vector<enum Ogre::VERTPROCESS_T,std::allocator<enum Ogre::VERTPROCESS_T> >::_Destroy

; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+20]
	sub	ecx, DWORD PTR [eax+12]
	sar	ecx, 2
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?deallocate@?$allocator@W4VERTPROCESS_T@Ogre@@@std@@QAEXPAW4VERTPROCESS_T@Ogre@@I@Z ; std::allocator<enum Ogre::VERTPROCESS_T>::deallocate
$LN1@Tidy@5:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+16], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], 0

; 1135 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$vector@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@IAEXXZ ENDP ; std::vector<enum Ogre::VERTPROCESS_T,std::allocator<enum Ogre::VERTPROCESS_T> >::_Tidy
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_fill_n@PAW4VERTPROCESS_T@Ogre@@IW412@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@stdext@@YAXPAW4VERTPROCESS_T@Ogre@@IABW412@AAV?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@Z ; stdext::unchecked_uninitialized_fill_n<enum Ogre::VERTPROCESS_T *,unsigned int,enum Ogre::VERTPROCESS_T,std::allocator<enum Ogre::VERTPROCESS_T> >
; Function compile flags: /Odtp
;	COMDAT ?_Ufill@?$vector@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@IAEPAW4VERTPROCESS_T@Ogre@@PAW434@IABW434@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Ufill@?$vector@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@IAEPAW4VERTPROCESS_T@Ogre@@PAW434@IABW434@@Z PROC ; std::vector<enum Ogre::VERTPROCESS_T,std::allocator<enum Ogre::VERTPROCESS_T> >::_Ufill, COMDAT
; _this$ = ecx

; 1253 : 		{	// copy initializing _Count * _Val, using allocator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1254 : 		_STDEXT unchecked_uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??$unchecked_uninitialized_fill_n@PAW4VERTPROCESS_T@Ogre@@IW412@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@stdext@@YAXPAW4VERTPROCESS_T@Ogre@@IABW412@AAV?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@Z ; stdext::unchecked_uninitialized_fill_n<enum Ogre::VERTPROCESS_T *,unsigned int,enum Ogre::VERTPROCESS_T,std::allocator<enum Ogre::VERTPROCESS_T> >
	add	esp, 16					; 00000010H

; 1255 : 		return (_Ptr + _Count);

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Ptr$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]

; 1256 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?_Ufill@?$vector@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@IAEPAW4VERTPROCESS_T@Ogre@@PAW434@IABW434@@Z ENDP ; std::vector<enum Ogre::VERTPROCESS_T,std::allocator<enum Ogre::VERTPROCESS_T> >::_Ufill
_TEXT	ENDS
PUBLIC	??0?$_Container_base_aux_alloc_real@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@IAE@V?$allocator@W4VERTPROCESS_T@Ogre@@@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<enum Ogre::VERTPROCESS_T> >::_Container_base_aux_alloc_real<std::allocator<enum Ogre::VERTPROCESS_T> >
PUBLIC	??0?$allocator@W4VERTPROCESS_T@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<enum Ogre::VERTPROCESS_T>::allocator<enum Ogre::VERTPROCESS_T>
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$_Vector_val@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@IAE@V?$allocator@W4VERTPROCESS_T@Ogre@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Vector_val@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@IAE@V?$allocator@W4VERTPROCESS_T@Ogre@@@1@@Z$0
__ehfuncinfo$??0?$_Vector_val@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@IAE@V?$allocator@W4VERTPROCESS_T@Ogre@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Vector_val@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@IAE@V?$allocator@W4VERTPROCESS_T@Ogre@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Vector_val@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@IAE@V?$allocator@W4VERTPROCESS_T@Ogre@@@1@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T142101 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 1
??0?$_Vector_val@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@IAE@V?$allocator@W4VERTPROCESS_T@Ogre@@@1@@Z PROC ; std::_Vector_val<enum Ogre::VERTPROCESS_T,std::allocator<enum Ogre::VERTPROCESS_T> >::_Vector_val<enum Ogre::VERTPROCESS_T,std::allocator<enum Ogre::VERTPROCESS_T> >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Vector_val@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@IAE@V?$allocator@W4VERTPROCESS_T@Ogre@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T142101[ebp], esp
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	call	??0?$allocator@W4VERTPROCESS_T@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<enum Ogre::VERTPROCESS_T>::allocator<enum Ogre::VERTPROCESS_T>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Container_base_aux_alloc_real@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@IAE@V?$allocator@W4VERTPROCESS_T@Ogre@@@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<enum Ogre::VERTPROCESS_T> >::_Container_base_aux_alloc_real<std::allocator<enum Ogre::VERTPROCESS_T> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??0?$allocator@W4VERTPROCESS_T@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<enum Ogre::VERTPROCESS_T>::allocator<enum Ogre::VERTPROCESS_T>

; 426  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Vector_val@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@IAE@V?$allocator@W4VERTPROCESS_T@Ogre@@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Container_base_aux_alloc_real@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<enum Ogre::VERTPROCESS_T> >::~_Container_base_aux_alloc_real<std::allocator<enum Ogre::VERTPROCESS_T> >
__ehhandler$??0?$_Vector_val@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@IAE@V?$allocator@W4VERTPROCESS_T@Ogre@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Vector_val@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@IAE@V?$allocator@W4VERTPROCESS_T@Ogre@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Vector_val@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@IAE@V?$allocator@W4VERTPROCESS_T@Ogre@@@1@@Z ENDP ; std::_Vector_val<enum Ogre::VERTPROCESS_T,std::allocator<enum Ogre::VERTPROCESS_T> >::_Vector_val<enum Ogre::VERTPROCESS_T,std::allocator<enum Ogre::VERTPROCESS_T> >
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??1?$_Container_base_aux_alloc_real@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@IAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Container_base_aux_alloc_real@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@IAE@XZ$0
__ehfuncinfo$??1?$_Container_base_aux_alloc_real@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@IAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Container_base_aux_alloc_real@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@IAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$_Container_base_aux_alloc_real@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Container_base_aux_alloc_real@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_real<std::allocator<enum Ogre::VERTPROCESS_T> >::~_Container_base_aux_alloc_real<std::allocator<enum Ogre::VERTPROCESS_T> >, COMDAT
; _this$ = ecx

; 436  : 		{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Container_base_aux_alloc_real@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@IAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 437  : 		_Myownedaux->~_Aux_cont();
; 438  : 
; 439  : 		_Alaux.deallocate(_Myownedaux, 1);

	push	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?deallocate@?$allocator@V_Aux_cont@std@@@std@@QAEXPAV_Aux_cont@2@I@Z ; std::allocator<std::_Aux_cont>::deallocate

; 440  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Container_base_aux_alloc_real@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@IAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
__ehhandler$??1?$_Container_base_aux_alloc_real@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@IAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Container_base_aux_alloc_real@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@IAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Container_base_aux_alloc_real@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_real<std::allocator<enum Ogre::VERTPROCESS_T> >::~_Container_base_aux_alloc_real<std::allocator<enum Ogre::VERTPROCESS_T> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@W4VERTPROCESS_T@Ogre@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@W4VERTPROCESS_T@Ogre@@@std@@QAE@XZ PROC	; std::allocator<enum Ogre::VERTPROCESS_T>::allocator<enum Ogre::VERTPROCESS_T>, COMDAT
; _this$ = ecx

; 119  : 	allocator() _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$allocator@W4VERTPROCESS_T@Ogre@@@std@@QAE@XZ ENDP	; std::allocator<enum Ogre::VERTPROCESS_T>::allocator<enum Ogre::VERTPROCESS_T>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?capacity@?$vector@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
tv70 = -8						; size = 4
_this$ = -4						; size = 4
?capacity@?$vector@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@QBEIXZ PROC ; std::vector<Ogre::D3DDEVCOMBO_T *,std::allocator<Ogre::D3DDEVCOMBO_T *> >::capacity, COMDAT
; _this$ = ecx

; 634  : 		{	// return current length of allocated storage

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	jne	SHORT $LN3@capacity@6
	mov	DWORD PTR tv70[ebp], 0
	jmp	SHORT $LN4@capacity@6
$LN3@capacity@6:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+20]
	sub	eax, DWORD PTR [edx+12]
	sar	eax, 2
	mov	DWORD PTR tv70[ebp], eax
$LN4@capacity@6:
	mov	eax, DWORD PTR tv70[ebp]

; 636  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?capacity@?$vector@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@QBEIXZ ENDP ; std::vector<Ogre::D3DDEVCOMBO_T *,std::allocator<Ogre::D3DDEVCOMBO_T *> >::capacity
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@QAE@PAPAUD3DDEVCOMBO_T@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::D3DDEVCOMBO_T *,std::allocator<Ogre::D3DDEVCOMBO_T *> >::_Vector_iterator<Ogre::D3DDEVCOMBO_T *,std::allocator<Ogre::D3DDEVCOMBO_T *> >
; Function compile flags: /Odtp
;	COMDAT ?end@?$vector@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@2@XZ PROC ; std::vector<Ogre::D3DDEVCOMBO_T *,std::allocator<Ogre::D3DDEVCOMBO_T *> >::end, COMDAT
; _this$ = ecx

; 650  : 		{	// return iterator for end of mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 651  : 		return (iterator(_Mylast, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@QAE@PAPAUD3DDEVCOMBO_T@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::D3DDEVCOMBO_T *,std::allocator<Ogre::D3DDEVCOMBO_T *> >::_Vector_iterator<Ogre::D3DDEVCOMBO_T *,std::allocator<Ogre::D3DDEVCOMBO_T *> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 652  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?end@?$vector@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@2@XZ ENDP ; std::vector<Ogre::D3DDEVCOMBO_T *,std::allocator<Ogre::D3DDEVCOMBO_T *> >::end
_TEXT	ENDS
PUBLIC	??H?$_Vector_iterator@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<Ogre::D3DDEVCOMBO_T *,std::allocator<Ogre::D3DDEVCOMBO_T *> >::operator+
PUBLIC	?_Insert_n@?$vector@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@2@IABQAUD3DDEVCOMBO_T@Ogre@@@Z ; std::vector<Ogre::D3DDEVCOMBO_T *,std::allocator<Ogre::D3DDEVCOMBO_T *> >::_Insert_n
PUBLIC	??G?$_Vector_const_iterator@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@QBEHABV01@@Z ; std::_Vector_const_iterator<Ogre::D3DDEVCOMBO_T *,std::allocator<Ogre::D3DDEVCOMBO_T *> >::operator-
PUBLIC	?begin@?$vector@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@2@XZ ; std::vector<Ogre::D3DDEVCOMBO_T *,std::allocator<Ogre::D3DDEVCOMBO_T *> >::begin
; Function compile flags: /Odtp
;	COMDAT ?insert@?$vector@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@2@ABQAUD3DDEVCOMBO_T@Ogre@@@Z
_TEXT	SEGMENT
tv77 = -28						; size = 4
_this$ = -24						; size = 4
$T142131 = -20						; size = 8
$T142128 = -12						; size = 8
__Off$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 8
__Val$ = 20						; size = 4
?insert@?$vector@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@2@ABQAUD3DDEVCOMBO_T@Ogre@@@Z PROC ; std::vector<Ogre::D3DDEVCOMBO_T *,std::allocator<Ogre::D3DDEVCOMBO_T *> >::insert, COMDAT
; _this$ = ecx

; 875  : 		{	// insert _Val at _Where

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR _this$[ebp], ecx

; 876  : 		size_type _Off = size() == 0 ? 0 : _Where - begin();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::D3DDEVCOMBO_T *,std::allocator<Ogre::D3DDEVCOMBO_T *> >::size
	test	eax, eax
	jne	SHORT $LN3@insert@6
	mov	DWORD PTR tv77[ebp], 0
	jmp	SHORT $LN4@insert@6
$LN3@insert@6:
	lea	eax, DWORD PTR $T142128[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$vector@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@2@XZ ; std::vector<Ogre::D3DDEVCOMBO_T *,std::allocator<Ogre::D3DDEVCOMBO_T *> >::begin
	push	eax
	lea	ecx, DWORD PTR __Where$[ebp]
	call	??G?$_Vector_const_iterator@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@QBEHABV01@@Z ; std::_Vector_const_iterator<Ogre::D3DDEVCOMBO_T *,std::allocator<Ogre::D3DDEVCOMBO_T *> >::operator-
	mov	DWORD PTR tv77[ebp], eax
$LN4@insert@6:
	mov	ecx, DWORD PTR tv77[ebp]
	mov	DWORD PTR __Off$[ebp], ecx

; 877  : 		_Insert_n(_Where, (size_type)1, _Val);

	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	push	1
	mov	eax, DWORD PTR __Where$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert_n@?$vector@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@2@IABQAUD3DDEVCOMBO_T@Ogre@@@Z ; std::vector<Ogre::D3DDEVCOMBO_T *,std::allocator<Ogre::D3DDEVCOMBO_T *> >::_Insert_n

; 878  : 		return (begin() + _Off);

	mov	edx, DWORD PTR __Off$[ebp]
	push	edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T142131[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$vector@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@2@XZ ; std::vector<Ogre::D3DDEVCOMBO_T *,std::allocator<Ogre::D3DDEVCOMBO_T *> >::begin
	mov	ecx, eax
	call	??H?$_Vector_iterator@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<Ogre::D3DDEVCOMBO_T *,std::allocator<Ogre::D3DDEVCOMBO_T *> >::operator+
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 879  : 		}

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?insert@?$vector@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@2@ABQAUD3DDEVCOMBO_T@Ogre@@@Z ENDP ; std::vector<Ogre::D3DDEVCOMBO_T *,std::allocator<Ogre::D3DDEVCOMBO_T *> >::insert
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@QAEPAPAUD3DDEVCOMBO_T@Ogre@@I@Z ; std::allocator<Ogre::D3DDEVCOMBO_T *>::allocate
PUBLIC	?_Xlen@?$vector@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@KAXXZ ; std::vector<Ogre::D3DDEVCOMBO_T *,std::allocator<Ogre::D3DDEVCOMBO_T *> >::_Xlen
PUBLIC	?max_size@?$vector@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::D3DDEVCOMBO_T *,std::allocator<Ogre::D3DDEVCOMBO_T *> >::max_size
; Function compile flags: /Odtp
;	COMDAT ?_Buy@?$vector@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Capacity$ = 8						; size = 4
?_Buy@?$vector@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@IAE_NI@Z PROC ; std::vector<Ogre::D3DDEVCOMBO_T *,std::allocator<Ogre::D3DDEVCOMBO_T *> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+20], 0

; 1104 : 		if (_Capacity == 0)

	cmp	DWORD PTR __Capacity$[ebp], 0
	jne	SHORT $LN4@Buy@6

; 1105 : 			return (false);

	xor	al, al
	jmp	SHORT $LN5@Buy@6
	jmp	SHORT $LN3@Buy@6
$LN4@Buy@6:

; 1106 : 		else if (max_size() < _Capacity)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::D3DDEVCOMBO_T *,std::allocator<Ogre::D3DDEVCOMBO_T *> >::max_size
	cmp	eax, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN2@Buy@6

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@KAXXZ ; std::vector<Ogre::D3DDEVCOMBO_T *,std::allocator<Ogre::D3DDEVCOMBO_T *> >::_Xlen

; 1108 : 		else

	jmp	SHORT $LN3@Buy@6
$LN2@Buy@6:

; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	mov	eax, DWORD PTR __Capacity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?allocate@?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@QAEPAPAUD3DDEVCOMBO_T@Ogre@@I@Z ; std::allocator<Ogre::D3DDEVCOMBO_T *>::allocate
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [edx+16], ecx

; 1112 : 			_Myend = _Myfirst + _Capacity;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR __Capacity$[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], edx
$LN3@Buy@6:

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
$LN5@Buy@6:

; 1115 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Buy@?$vector@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<Ogre::D3DDEVCOMBO_T *,std::allocator<Ogre::D3DDEVCOMBO_T *> >::_Buy
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@QAEXPAPAUD3DDEVCOMBO_T@Ogre@@I@Z ; std::allocator<Ogre::D3DDEVCOMBO_T *>::deallocate
PUBLIC	?_Destroy@?$vector@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@IAEXPAPAUD3DDEVCOMBO_T@Ogre@@0@Z ; std::vector<Ogre::D3DDEVCOMBO_T *,std::allocator<Ogre::D3DDEVCOMBO_T *> >::_Destroy
; Function compile flags: /Odtp
;	COMDAT ?_Tidy@?$vector@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Tidy@?$vector@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@IAEXXZ PROC ; std::vector<Ogre::D3DDEVCOMBO_T *,std::allocator<Ogre::D3DDEVCOMBO_T *> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	je	SHORT $LN1@Tidy@6

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@IAEXPAPAUD3DDEVCOMBO_T@Ogre@@0@Z ; std::vector<Ogre::D3DDEVCOMBO_T *,std::allocator<Ogre::D3DDEVCOMBO_T *> >::_Destroy

; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+20]
	sub	ecx, DWORD PTR [eax+12]
	sar	ecx, 2
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?deallocate@?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@QAEXPAPAUD3DDEVCOMBO_T@Ogre@@I@Z ; std::allocator<Ogre::D3DDEVCOMBO_T *>::deallocate
$LN1@Tidy@6:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+16], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], 0

; 1135 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$vector@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@IAEXXZ ENDP ; std::vector<Ogre::D3DDEVCOMBO_T *,std::allocator<Ogre::D3DDEVCOMBO_T *> >::_Tidy
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_fill_n@PAPAUD3DDEVCOMBO_T@Ogre@@IPAU12@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@stdext@@YAXPAPAUD3DDEVCOMBO_T@Ogre@@IABQAU12@AAV?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@Z ; stdext::unchecked_uninitialized_fill_n<Ogre::D3DDEVCOMBO_T * *,unsigned int,Ogre::D3DDEVCOMBO_T *,std::allocator<Ogre::D3DDEVCOMBO_T *> >
; Function compile flags: /Odtp
;	COMDAT ?_Ufill@?$vector@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@IAEPAPAUD3DDEVCOMBO_T@Ogre@@PAPAU34@IABQAU34@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Ufill@?$vector@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@IAEPAPAUD3DDEVCOMBO_T@Ogre@@PAPAU34@IABQAU34@@Z PROC ; std::vector<Ogre::D3DDEVCOMBO_T *,std::allocator<Ogre::D3DDEVCOMBO_T *> >::_Ufill, COMDAT
; _this$ = ecx

; 1253 : 		{	// copy initializing _Count * _Val, using allocator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1254 : 		_STDEXT unchecked_uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??$unchecked_uninitialized_fill_n@PAPAUD3DDEVCOMBO_T@Ogre@@IPAU12@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@stdext@@YAXPAPAUD3DDEVCOMBO_T@Ogre@@IABQAU12@AAV?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@Z ; stdext::unchecked_uninitialized_fill_n<Ogre::D3DDEVCOMBO_T * *,unsigned int,Ogre::D3DDEVCOMBO_T *,std::allocator<Ogre::D3DDEVCOMBO_T *> >
	add	esp, 16					; 00000010H

; 1255 : 		return (_Ptr + _Count);

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Ptr$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]

; 1256 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?_Ufill@?$vector@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@IAEPAPAUD3DDEVCOMBO_T@Ogre@@PAPAU34@IABQAU34@@Z ENDP ; std::vector<Ogre::D3DDEVCOMBO_T *,std::allocator<Ogre::D3DDEVCOMBO_T *> >::_Ufill
_TEXT	ENDS
PUBLIC	??0?$_Container_base_aux_alloc_real@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@IAE@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::D3DDEVCOMBO_T *> >::_Container_base_aux_alloc_real<std::allocator<Ogre::D3DDEVCOMBO_T *> >
PUBLIC	??0?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::D3DDEVCOMBO_T *>::allocator<Ogre::D3DDEVCOMBO_T *>
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$_Vector_val@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@IAE@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Vector_val@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@IAE@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@1@@Z$0
__ehfuncinfo$??0?$_Vector_val@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@IAE@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Vector_val@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@IAE@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Vector_val@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@IAE@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@1@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T142140 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 1
??0?$_Vector_val@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@IAE@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@1@@Z PROC ; std::_Vector_val<Ogre::D3DDEVCOMBO_T *,std::allocator<Ogre::D3DDEVCOMBO_T *> >::_Vector_val<Ogre::D3DDEVCOMBO_T *,std::allocator<Ogre::D3DDEVCOMBO_T *> >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Vector_val@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@IAE@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T142140[ebp], esp
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	call	??0?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::D3DDEVCOMBO_T *>::allocator<Ogre::D3DDEVCOMBO_T *>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Container_base_aux_alloc_real@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@IAE@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::D3DDEVCOMBO_T *> >::_Container_base_aux_alloc_real<std::allocator<Ogre::D3DDEVCOMBO_T *> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??0?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::D3DDEVCOMBO_T *>::allocator<Ogre::D3DDEVCOMBO_T *>

; 426  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Vector_val@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@IAE@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Container_base_aux_alloc_real@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::D3DDEVCOMBO_T *> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::D3DDEVCOMBO_T *> >
__ehhandler$??0?$_Vector_val@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@IAE@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Vector_val@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@IAE@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Vector_val@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@IAE@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@1@@Z ENDP ; std::_Vector_val<Ogre::D3DDEVCOMBO_T *,std::allocator<Ogre::D3DDEVCOMBO_T *> >::_Vector_val<Ogre::D3DDEVCOMBO_T *,std::allocator<Ogre::D3DDEVCOMBO_T *> >
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??1?$_Container_base_aux_alloc_real@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@IAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Container_base_aux_alloc_real@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@IAE@XZ$0
__ehfuncinfo$??1?$_Container_base_aux_alloc_real@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@IAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Container_base_aux_alloc_real@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@IAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$_Container_base_aux_alloc_real@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Container_base_aux_alloc_real@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::D3DDEVCOMBO_T *> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::D3DDEVCOMBO_T *> >, COMDAT
; _this$ = ecx

; 436  : 		{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Container_base_aux_alloc_real@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@IAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 437  : 		_Myownedaux->~_Aux_cont();
; 438  : 
; 439  : 		_Alaux.deallocate(_Myownedaux, 1);

	push	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?deallocate@?$allocator@V_Aux_cont@std@@@std@@QAEXPAV_Aux_cont@2@I@Z ; std::allocator<std::_Aux_cont>::deallocate

; 440  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Container_base_aux_alloc_real@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@IAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
__ehhandler$??1?$_Container_base_aux_alloc_real@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@IAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Container_base_aux_alloc_real@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@IAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Container_base_aux_alloc_real@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::D3DDEVCOMBO_T *> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::D3DDEVCOMBO_T *> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@QAE@XZ PROC	; std::allocator<Ogre::D3DDEVCOMBO_T *>::allocator<Ogre::D3DDEVCOMBO_T *>, COMDAT
; _this$ = ecx

; 119  : 	allocator() _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@QAE@XZ ENDP	; std::allocator<Ogre::D3DDEVCOMBO_T *>::allocator<Ogre::D3DDEVCOMBO_T *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?capacity@?$vector@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
tv70 = -8						; size = 4
_this$ = -4						; size = 4
?capacity@?$vector@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@QBEIXZ PROC ; std::vector<_D3DDISPLAYMODE,std::allocator<_D3DDISPLAYMODE> >::capacity, COMDAT
; _this$ = ecx

; 634  : 		{	// return current length of allocated storage

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	jne	SHORT $LN3@capacity@7
	mov	DWORD PTR tv70[ebp], 0
	jmp	SHORT $LN4@capacity@7
$LN3@capacity@7:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+20]
	sub	eax, DWORD PTR [edx+12]
	sar	eax, 4
	mov	DWORD PTR tv70[ebp], eax
$LN4@capacity@7:
	mov	eax, DWORD PTR tv70[ebp]

; 636  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?capacity@?$vector@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@QBEIXZ ENDP ; std::vector<_D3DDISPLAYMODE,std::allocator<_D3DDISPLAYMODE> >::capacity
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@QAE@PAU_D3DDISPLAYMODE@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<_D3DDISPLAYMODE,std::allocator<_D3DDISPLAYMODE> >::_Vector_iterator<_D3DDISPLAYMODE,std::allocator<_D3DDISPLAYMODE> >
; Function compile flags: /Odtp
;	COMDAT ?end@?$vector@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@QAE?AV?$_Vector_iterator@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@QAE?AV?$_Vector_iterator@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@2@XZ PROC ; std::vector<_D3DDISPLAYMODE,std::allocator<_D3DDISPLAYMODE> >::end, COMDAT
; _this$ = ecx

; 650  : 		{	// return iterator for end of mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 651  : 		return (iterator(_Mylast, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@QAE@PAU_D3DDISPLAYMODE@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<_D3DDISPLAYMODE,std::allocator<_D3DDISPLAYMODE> >::_Vector_iterator<_D3DDISPLAYMODE,std::allocator<_D3DDISPLAYMODE> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 652  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?end@?$vector@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@QAE?AV?$_Vector_iterator@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@2@XZ ENDP ; std::vector<_D3DDISPLAYMODE,std::allocator<_D3DDISPLAYMODE> >::end
_TEXT	ENDS
PUBLIC	??H?$_Vector_iterator@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<_D3DDISPLAYMODE,std::allocator<_D3DDISPLAYMODE> >::operator+
PUBLIC	?_Insert_n@?$vector@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@IAEXV?$_Vector_const_iterator@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@2@IABU_D3DDISPLAYMODE@@@Z ; std::vector<_D3DDISPLAYMODE,std::allocator<_D3DDISPLAYMODE> >::_Insert_n
PUBLIC	??G?$_Vector_const_iterator@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@QBEHABV01@@Z ; std::_Vector_const_iterator<_D3DDISPLAYMODE,std::allocator<_D3DDISPLAYMODE> >::operator-
PUBLIC	?begin@?$vector@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@QAE?AV?$_Vector_iterator@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@2@XZ ; std::vector<_D3DDISPLAYMODE,std::allocator<_D3DDISPLAYMODE> >::begin
; Function compile flags: /Odtp
;	COMDAT ?insert@?$vector@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@QAE?AV?$_Vector_iterator@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@2@V?$_Vector_const_iterator@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@2@ABU_D3DDISPLAYMODE@@@Z
_TEXT	SEGMENT
tv77 = -28						; size = 4
_this$ = -24						; size = 4
$T142170 = -20						; size = 8
$T142167 = -12						; size = 8
__Off$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 8
__Val$ = 20						; size = 4
?insert@?$vector@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@QAE?AV?$_Vector_iterator@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@2@V?$_Vector_const_iterator@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@2@ABU_D3DDISPLAYMODE@@@Z PROC ; std::vector<_D3DDISPLAYMODE,std::allocator<_D3DDISPLAYMODE> >::insert, COMDAT
; _this$ = ecx

; 875  : 		{	// insert _Val at _Where

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR _this$[ebp], ecx

; 876  : 		size_type _Off = size() == 0 ? 0 : _Where - begin();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@QBEIXZ ; std::vector<_D3DDISPLAYMODE,std::allocator<_D3DDISPLAYMODE> >::size
	test	eax, eax
	jne	SHORT $LN3@insert@7
	mov	DWORD PTR tv77[ebp], 0
	jmp	SHORT $LN4@insert@7
$LN3@insert@7:
	lea	eax, DWORD PTR $T142167[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$vector@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@QAE?AV?$_Vector_iterator@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@2@XZ ; std::vector<_D3DDISPLAYMODE,std::allocator<_D3DDISPLAYMODE> >::begin
	push	eax
	lea	ecx, DWORD PTR __Where$[ebp]
	call	??G?$_Vector_const_iterator@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@QBEHABV01@@Z ; std::_Vector_const_iterator<_D3DDISPLAYMODE,std::allocator<_D3DDISPLAYMODE> >::operator-
	mov	DWORD PTR tv77[ebp], eax
$LN4@insert@7:
	mov	ecx, DWORD PTR tv77[ebp]
	mov	DWORD PTR __Off$[ebp], ecx

; 877  : 		_Insert_n(_Where, (size_type)1, _Val);

	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	push	1
	mov	eax, DWORD PTR __Where$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert_n@?$vector@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@IAEXV?$_Vector_const_iterator@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@2@IABU_D3DDISPLAYMODE@@@Z ; std::vector<_D3DDISPLAYMODE,std::allocator<_D3DDISPLAYMODE> >::_Insert_n

; 878  : 		return (begin() + _Off);

	mov	edx, DWORD PTR __Off$[ebp]
	push	edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T142170[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$vector@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@QAE?AV?$_Vector_iterator@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@2@XZ ; std::vector<_D3DDISPLAYMODE,std::allocator<_D3DDISPLAYMODE> >::begin
	mov	ecx, eax
	call	??H?$_Vector_iterator@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<_D3DDISPLAYMODE,std::allocator<_D3DDISPLAYMODE> >::operator+
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 879  : 		}

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?insert@?$vector@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@QAE?AV?$_Vector_iterator@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@2@V?$_Vector_const_iterator@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@2@ABU_D3DDISPLAYMODE@@@Z ENDP ; std::vector<_D3DDISPLAYMODE,std::allocator<_D3DDISPLAYMODE> >::insert
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@U_D3DDISPLAYMODE@@@std@@QAEPAU_D3DDISPLAYMODE@@I@Z ; std::allocator<_D3DDISPLAYMODE>::allocate
PUBLIC	?_Xlen@?$vector@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@KAXXZ ; std::vector<_D3DDISPLAYMODE,std::allocator<_D3DDISPLAYMODE> >::_Xlen
PUBLIC	?max_size@?$vector@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@QBEIXZ ; std::vector<_D3DDISPLAYMODE,std::allocator<_D3DDISPLAYMODE> >::max_size
; Function compile flags: /Odtp
;	COMDAT ?_Buy@?$vector@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Capacity$ = 8						; size = 4
?_Buy@?$vector@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@IAE_NI@Z PROC ; std::vector<_D3DDISPLAYMODE,std::allocator<_D3DDISPLAYMODE> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+20], 0

; 1104 : 		if (_Capacity == 0)

	cmp	DWORD PTR __Capacity$[ebp], 0
	jne	SHORT $LN4@Buy@7

; 1105 : 			return (false);

	xor	al, al
	jmp	SHORT $LN5@Buy@7
	jmp	SHORT $LN3@Buy@7
$LN4@Buy@7:

; 1106 : 		else if (max_size() < _Capacity)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@QBEIXZ ; std::vector<_D3DDISPLAYMODE,std::allocator<_D3DDISPLAYMODE> >::max_size
	cmp	eax, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN2@Buy@7

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@KAXXZ ; std::vector<_D3DDISPLAYMODE,std::allocator<_D3DDISPLAYMODE> >::_Xlen

; 1108 : 		else

	jmp	SHORT $LN3@Buy@7
$LN2@Buy@7:

; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	mov	eax, DWORD PTR __Capacity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?allocate@?$allocator@U_D3DDISPLAYMODE@@@std@@QAEPAU_D3DDISPLAYMODE@@I@Z ; std::allocator<_D3DDISPLAYMODE>::allocate
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [edx+16], ecx

; 1112 : 			_Myend = _Myfirst + _Capacity;

	mov	edx, DWORD PTR __Capacity$[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+12]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+20], edx
$LN3@Buy@7:

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
$LN5@Buy@7:

; 1115 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Buy@?$vector@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<_D3DDISPLAYMODE,std::allocator<_D3DDISPLAYMODE> >::_Buy
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@U_D3DDISPLAYMODE@@@std@@QAEXPAU_D3DDISPLAYMODE@@I@Z ; std::allocator<_D3DDISPLAYMODE>::deallocate
PUBLIC	?_Destroy@?$vector@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@IAEXPAU_D3DDISPLAYMODE@@0@Z ; std::vector<_D3DDISPLAYMODE,std::allocator<_D3DDISPLAYMODE> >::_Destroy
; Function compile flags: /Odtp
;	COMDAT ?_Tidy@?$vector@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Tidy@?$vector@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@IAEXXZ PROC ; std::vector<_D3DDISPLAYMODE,std::allocator<_D3DDISPLAYMODE> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	je	SHORT $LN1@Tidy@7

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@IAEXPAU_D3DDISPLAYMODE@@0@Z ; std::vector<_D3DDISPLAYMODE,std::allocator<_D3DDISPLAYMODE> >::_Destroy

; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+20]
	sub	ecx, DWORD PTR [eax+12]
	sar	ecx, 4
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?deallocate@?$allocator@U_D3DDISPLAYMODE@@@std@@QAEXPAU_D3DDISPLAYMODE@@I@Z ; std::allocator<_D3DDISPLAYMODE>::deallocate
$LN1@Tidy@7:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+16], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], 0

; 1135 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$vector@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@IAEXXZ ENDP ; std::vector<_D3DDISPLAYMODE,std::allocator<_D3DDISPLAYMODE> >::_Tidy
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_fill_n@PAU_D3DDISPLAYMODE@@IU1@V?$allocator@U_D3DDISPLAYMODE@@@std@@@stdext@@YAXPAU_D3DDISPLAYMODE@@IABU1@AAV?$allocator@U_D3DDISPLAYMODE@@@std@@@Z ; stdext::unchecked_uninitialized_fill_n<_D3DDISPLAYMODE *,unsigned int,_D3DDISPLAYMODE,std::allocator<_D3DDISPLAYMODE> >
; Function compile flags: /Odtp
;	COMDAT ?_Ufill@?$vector@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@IAEPAU_D3DDISPLAYMODE@@PAU3@IABU3@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Ufill@?$vector@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@IAEPAU_D3DDISPLAYMODE@@PAU3@IABU3@@Z PROC ; std::vector<_D3DDISPLAYMODE,std::allocator<_D3DDISPLAYMODE> >::_Ufill, COMDAT
; _this$ = ecx

; 1253 : 		{	// copy initializing _Count * _Val, using allocator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1254 : 		_STDEXT unchecked_uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??$unchecked_uninitialized_fill_n@PAU_D3DDISPLAYMODE@@IU1@V?$allocator@U_D3DDISPLAYMODE@@@std@@@stdext@@YAXPAU_D3DDISPLAYMODE@@IABU1@AAV?$allocator@U_D3DDISPLAYMODE@@@std@@@Z ; stdext::unchecked_uninitialized_fill_n<_D3DDISPLAYMODE *,unsigned int,_D3DDISPLAYMODE,std::allocator<_D3DDISPLAYMODE> >
	add	esp, 16					; 00000010H

; 1255 : 		return (_Ptr + _Count);

	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 4
	add	eax, DWORD PTR __Ptr$[ebp]

; 1256 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?_Ufill@?$vector@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@IAEPAU_D3DDISPLAYMODE@@PAU3@IABU3@@Z ENDP ; std::vector<_D3DDISPLAYMODE,std::allocator<_D3DDISPLAYMODE> >::_Ufill
_TEXT	ENDS
PUBLIC	??0?$_Container_base_aux_alloc_real@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@IAE@V?$allocator@U_D3DDISPLAYMODE@@@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<_D3DDISPLAYMODE> >::_Container_base_aux_alloc_real<std::allocator<_D3DDISPLAYMODE> >
PUBLIC	??0?$allocator@U_D3DDISPLAYMODE@@@std@@QAE@ABV01@@Z ; std::allocator<_D3DDISPLAYMODE>::allocator<_D3DDISPLAYMODE>
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$_Vector_val@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@IAE@V?$allocator@U_D3DDISPLAYMODE@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Vector_val@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@IAE@V?$allocator@U_D3DDISPLAYMODE@@@1@@Z$0
__ehfuncinfo$??0?$_Vector_val@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@IAE@V?$allocator@U_D3DDISPLAYMODE@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Vector_val@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@IAE@V?$allocator@U_D3DDISPLAYMODE@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Vector_val@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@IAE@V?$allocator@U_D3DDISPLAYMODE@@@1@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T142179 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 1
??0?$_Vector_val@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@IAE@V?$allocator@U_D3DDISPLAYMODE@@@1@@Z PROC ; std::_Vector_val<_D3DDISPLAYMODE,std::allocator<_D3DDISPLAYMODE> >::_Vector_val<_D3DDISPLAYMODE,std::allocator<_D3DDISPLAYMODE> >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Vector_val@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@IAE@V?$allocator@U_D3DDISPLAYMODE@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T142179[ebp], esp
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	call	??0?$allocator@U_D3DDISPLAYMODE@@@std@@QAE@ABV01@@Z ; std::allocator<_D3DDISPLAYMODE>::allocator<_D3DDISPLAYMODE>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Container_base_aux_alloc_real@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@IAE@V?$allocator@U_D3DDISPLAYMODE@@@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<_D3DDISPLAYMODE> >::_Container_base_aux_alloc_real<std::allocator<_D3DDISPLAYMODE> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??0?$allocator@U_D3DDISPLAYMODE@@@std@@QAE@ABV01@@Z ; std::allocator<_D3DDISPLAYMODE>::allocator<_D3DDISPLAYMODE>

; 426  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Vector_val@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@IAE@V?$allocator@U_D3DDISPLAYMODE@@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Container_base_aux_alloc_real@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<_D3DDISPLAYMODE> >::~_Container_base_aux_alloc_real<std::allocator<_D3DDISPLAYMODE> >
__ehhandler$??0?$_Vector_val@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@IAE@V?$allocator@U_D3DDISPLAYMODE@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Vector_val@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@IAE@V?$allocator@U_D3DDISPLAYMODE@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Vector_val@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@IAE@V?$allocator@U_D3DDISPLAYMODE@@@1@@Z ENDP ; std::_Vector_val<_D3DDISPLAYMODE,std::allocator<_D3DDISPLAYMODE> >::_Vector_val<_D3DDISPLAYMODE,std::allocator<_D3DDISPLAYMODE> >
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??1?$_Container_base_aux_alloc_real@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@IAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Container_base_aux_alloc_real@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@IAE@XZ$0
__ehfuncinfo$??1?$_Container_base_aux_alloc_real@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@IAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Container_base_aux_alloc_real@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@IAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$_Container_base_aux_alloc_real@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Container_base_aux_alloc_real@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_real<std::allocator<_D3DDISPLAYMODE> >::~_Container_base_aux_alloc_real<std::allocator<_D3DDISPLAYMODE> >, COMDAT
; _this$ = ecx

; 436  : 		{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Container_base_aux_alloc_real@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@IAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 437  : 		_Myownedaux->~_Aux_cont();
; 438  : 
; 439  : 		_Alaux.deallocate(_Myownedaux, 1);

	push	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?deallocate@?$allocator@V_Aux_cont@std@@@std@@QAEXPAV_Aux_cont@2@I@Z ; std::allocator<std::_Aux_cont>::deallocate

; 440  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Container_base_aux_alloc_real@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@IAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
__ehhandler$??1?$_Container_base_aux_alloc_real@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@IAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Container_base_aux_alloc_real@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@IAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Container_base_aux_alloc_real@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_real<std::allocator<_D3DDISPLAYMODE> >::~_Container_base_aux_alloc_real<std::allocator<_D3DDISPLAYMODE> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@U_D3DDISPLAYMODE@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@U_D3DDISPLAYMODE@@@std@@QAE@XZ PROC	; std::allocator<_D3DDISPLAYMODE>::allocator<_D3DDISPLAYMODE>, COMDAT
; _this$ = ecx

; 119  : 	allocator() _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$allocator@U_D3DDISPLAYMODE@@@std@@QAE@XZ ENDP	; std::allocator<_D3DDISPLAYMODE>::allocator<_D3DDISPLAYMODE>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?capacity@?$vector@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
tv70 = -8						; size = 4
_this$ = -4						; size = 4
?capacity@?$vector@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@QBEIXZ PROC ; std::vector<Ogre::D3DDEVICEINFO_T *,std::allocator<Ogre::D3DDEVICEINFO_T *> >::capacity, COMDAT
; _this$ = ecx

; 634  : 		{	// return current length of allocated storage

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	jne	SHORT $LN3@capacity@8
	mov	DWORD PTR tv70[ebp], 0
	jmp	SHORT $LN4@capacity@8
$LN3@capacity@8:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+20]
	sub	eax, DWORD PTR [edx+12]
	sar	eax, 2
	mov	DWORD PTR tv70[ebp], eax
$LN4@capacity@8:
	mov	eax, DWORD PTR tv70[ebp]

; 636  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?capacity@?$vector@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@QBEIXZ ENDP ; std::vector<Ogre::D3DDEVICEINFO_T *,std::allocator<Ogre::D3DDEVICEINFO_T *> >::capacity
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@QAE@PAPAUD3DDEVICEINFO_T@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::D3DDEVICEINFO_T *,std::allocator<Ogre::D3DDEVICEINFO_T *> >::_Vector_iterator<Ogre::D3DDEVICEINFO_T *,std::allocator<Ogre::D3DDEVICEINFO_T *> >
; Function compile flags: /Odtp
;	COMDAT ?end@?$vector@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@2@XZ PROC ; std::vector<Ogre::D3DDEVICEINFO_T *,std::allocator<Ogre::D3DDEVICEINFO_T *> >::end, COMDAT
; _this$ = ecx

; 650  : 		{	// return iterator for end of mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 651  : 		return (iterator(_Mylast, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@QAE@PAPAUD3DDEVICEINFO_T@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::D3DDEVICEINFO_T *,std::allocator<Ogre::D3DDEVICEINFO_T *> >::_Vector_iterator<Ogre::D3DDEVICEINFO_T *,std::allocator<Ogre::D3DDEVICEINFO_T *> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 652  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?end@?$vector@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@2@XZ ENDP ; std::vector<Ogre::D3DDEVICEINFO_T *,std::allocator<Ogre::D3DDEVICEINFO_T *> >::end
_TEXT	ENDS
PUBLIC	??H?$_Vector_iterator@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<Ogre::D3DDEVICEINFO_T *,std::allocator<Ogre::D3DDEVICEINFO_T *> >::operator+
PUBLIC	?_Insert_n@?$vector@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@2@IABQAUD3DDEVICEINFO_T@Ogre@@@Z ; std::vector<Ogre::D3DDEVICEINFO_T *,std::allocator<Ogre::D3DDEVICEINFO_T *> >::_Insert_n
PUBLIC	??G?$_Vector_const_iterator@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@QBEHABV01@@Z ; std::_Vector_const_iterator<Ogre::D3DDEVICEINFO_T *,std::allocator<Ogre::D3DDEVICEINFO_T *> >::operator-
PUBLIC	?begin@?$vector@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@2@XZ ; std::vector<Ogre::D3DDEVICEINFO_T *,std::allocator<Ogre::D3DDEVICEINFO_T *> >::begin
; Function compile flags: /Odtp
;	COMDAT ?insert@?$vector@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@2@ABQAUD3DDEVICEINFO_T@Ogre@@@Z
_TEXT	SEGMENT
tv77 = -28						; size = 4
_this$ = -24						; size = 4
$T142209 = -20						; size = 8
$T142206 = -12						; size = 8
__Off$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 8
__Val$ = 20						; size = 4
?insert@?$vector@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@2@ABQAUD3DDEVICEINFO_T@Ogre@@@Z PROC ; std::vector<Ogre::D3DDEVICEINFO_T *,std::allocator<Ogre::D3DDEVICEINFO_T *> >::insert, COMDAT
; _this$ = ecx

; 875  : 		{	// insert _Val at _Where

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR _this$[ebp], ecx

; 876  : 		size_type _Off = size() == 0 ? 0 : _Where - begin();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::D3DDEVICEINFO_T *,std::allocator<Ogre::D3DDEVICEINFO_T *> >::size
	test	eax, eax
	jne	SHORT $LN3@insert@8
	mov	DWORD PTR tv77[ebp], 0
	jmp	SHORT $LN4@insert@8
$LN3@insert@8:
	lea	eax, DWORD PTR $T142206[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$vector@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@2@XZ ; std::vector<Ogre::D3DDEVICEINFO_T *,std::allocator<Ogre::D3DDEVICEINFO_T *> >::begin
	push	eax
	lea	ecx, DWORD PTR __Where$[ebp]
	call	??G?$_Vector_const_iterator@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@QBEHABV01@@Z ; std::_Vector_const_iterator<Ogre::D3DDEVICEINFO_T *,std::allocator<Ogre::D3DDEVICEINFO_T *> >::operator-
	mov	DWORD PTR tv77[ebp], eax
$LN4@insert@8:
	mov	ecx, DWORD PTR tv77[ebp]
	mov	DWORD PTR __Off$[ebp], ecx

; 877  : 		_Insert_n(_Where, (size_type)1, _Val);

	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	push	1
	mov	eax, DWORD PTR __Where$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert_n@?$vector@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@2@IABQAUD3DDEVICEINFO_T@Ogre@@@Z ; std::vector<Ogre::D3DDEVICEINFO_T *,std::allocator<Ogre::D3DDEVICEINFO_T *> >::_Insert_n

; 878  : 		return (begin() + _Off);

	mov	edx, DWORD PTR __Off$[ebp]
	push	edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T142209[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$vector@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@2@XZ ; std::vector<Ogre::D3DDEVICEINFO_T *,std::allocator<Ogre::D3DDEVICEINFO_T *> >::begin
	mov	ecx, eax
	call	??H?$_Vector_iterator@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<Ogre::D3DDEVICEINFO_T *,std::allocator<Ogre::D3DDEVICEINFO_T *> >::operator+
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 879  : 		}

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?insert@?$vector@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@2@ABQAUD3DDEVICEINFO_T@Ogre@@@Z ENDP ; std::vector<Ogre::D3DDEVICEINFO_T *,std::allocator<Ogre::D3DDEVICEINFO_T *> >::insert
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@QAEPAPAUD3DDEVICEINFO_T@Ogre@@I@Z ; std::allocator<Ogre::D3DDEVICEINFO_T *>::allocate
PUBLIC	?_Xlen@?$vector@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@KAXXZ ; std::vector<Ogre::D3DDEVICEINFO_T *,std::allocator<Ogre::D3DDEVICEINFO_T *> >::_Xlen
PUBLIC	?max_size@?$vector@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::D3DDEVICEINFO_T *,std::allocator<Ogre::D3DDEVICEINFO_T *> >::max_size
; Function compile flags: /Odtp
;	COMDAT ?_Buy@?$vector@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Capacity$ = 8						; size = 4
?_Buy@?$vector@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@IAE_NI@Z PROC ; std::vector<Ogre::D3DDEVICEINFO_T *,std::allocator<Ogre::D3DDEVICEINFO_T *> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+20], 0

; 1104 : 		if (_Capacity == 0)

	cmp	DWORD PTR __Capacity$[ebp], 0
	jne	SHORT $LN4@Buy@8

; 1105 : 			return (false);

	xor	al, al
	jmp	SHORT $LN5@Buy@8
	jmp	SHORT $LN3@Buy@8
$LN4@Buy@8:

; 1106 : 		else if (max_size() < _Capacity)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::D3DDEVICEINFO_T *,std::allocator<Ogre::D3DDEVICEINFO_T *> >::max_size
	cmp	eax, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN2@Buy@8

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@KAXXZ ; std::vector<Ogre::D3DDEVICEINFO_T *,std::allocator<Ogre::D3DDEVICEINFO_T *> >::_Xlen

; 1108 : 		else

	jmp	SHORT $LN3@Buy@8
$LN2@Buy@8:

; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	mov	eax, DWORD PTR __Capacity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?allocate@?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@QAEPAPAUD3DDEVICEINFO_T@Ogre@@I@Z ; std::allocator<Ogre::D3DDEVICEINFO_T *>::allocate
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [edx+16], ecx

; 1112 : 			_Myend = _Myfirst + _Capacity;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR __Capacity$[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], edx
$LN3@Buy@8:

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
$LN5@Buy@8:

; 1115 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Buy@?$vector@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<Ogre::D3DDEVICEINFO_T *,std::allocator<Ogre::D3DDEVICEINFO_T *> >::_Buy
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@QAEXPAPAUD3DDEVICEINFO_T@Ogre@@I@Z ; std::allocator<Ogre::D3DDEVICEINFO_T *>::deallocate
PUBLIC	?_Destroy@?$vector@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@IAEXPAPAUD3DDEVICEINFO_T@Ogre@@0@Z ; std::vector<Ogre::D3DDEVICEINFO_T *,std::allocator<Ogre::D3DDEVICEINFO_T *> >::_Destroy
; Function compile flags: /Odtp
;	COMDAT ?_Tidy@?$vector@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Tidy@?$vector@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@IAEXXZ PROC ; std::vector<Ogre::D3DDEVICEINFO_T *,std::allocator<Ogre::D3DDEVICEINFO_T *> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	je	SHORT $LN1@Tidy@8

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@IAEXPAPAUD3DDEVICEINFO_T@Ogre@@0@Z ; std::vector<Ogre::D3DDEVICEINFO_T *,std::allocator<Ogre::D3DDEVICEINFO_T *> >::_Destroy

; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+20]
	sub	ecx, DWORD PTR [eax+12]
	sar	ecx, 2
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?deallocate@?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@QAEXPAPAUD3DDEVICEINFO_T@Ogre@@I@Z ; std::allocator<Ogre::D3DDEVICEINFO_T *>::deallocate
$LN1@Tidy@8:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+16], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], 0

; 1135 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$vector@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@IAEXXZ ENDP ; std::vector<Ogre::D3DDEVICEINFO_T *,std::allocator<Ogre::D3DDEVICEINFO_T *> >::_Tidy
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_fill_n@PAPAUD3DDEVICEINFO_T@Ogre@@IPAU12@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@stdext@@YAXPAPAUD3DDEVICEINFO_T@Ogre@@IABQAU12@AAV?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@Z ; stdext::unchecked_uninitialized_fill_n<Ogre::D3DDEVICEINFO_T * *,unsigned int,Ogre::D3DDEVICEINFO_T *,std::allocator<Ogre::D3DDEVICEINFO_T *> >
; Function compile flags: /Odtp
;	COMDAT ?_Ufill@?$vector@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@IAEPAPAUD3DDEVICEINFO_T@Ogre@@PAPAU34@IABQAU34@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Ufill@?$vector@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@IAEPAPAUD3DDEVICEINFO_T@Ogre@@PAPAU34@IABQAU34@@Z PROC ; std::vector<Ogre::D3DDEVICEINFO_T *,std::allocator<Ogre::D3DDEVICEINFO_T *> >::_Ufill, COMDAT
; _this$ = ecx

; 1253 : 		{	// copy initializing _Count * _Val, using allocator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1254 : 		_STDEXT unchecked_uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??$unchecked_uninitialized_fill_n@PAPAUD3DDEVICEINFO_T@Ogre@@IPAU12@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@stdext@@YAXPAPAUD3DDEVICEINFO_T@Ogre@@IABQAU12@AAV?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@Z ; stdext::unchecked_uninitialized_fill_n<Ogre::D3DDEVICEINFO_T * *,unsigned int,Ogre::D3DDEVICEINFO_T *,std::allocator<Ogre::D3DDEVICEINFO_T *> >
	add	esp, 16					; 00000010H

; 1255 : 		return (_Ptr + _Count);

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Ptr$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]

; 1256 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?_Ufill@?$vector@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@IAEPAPAUD3DDEVICEINFO_T@Ogre@@PAPAU34@IABQAU34@@Z ENDP ; std::vector<Ogre::D3DDEVICEINFO_T *,std::allocator<Ogre::D3DDEVICEINFO_T *> >::_Ufill
_TEXT	ENDS
PUBLIC	??0?$_Container_base_aux_alloc_real@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@IAE@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::D3DDEVICEINFO_T *> >::_Container_base_aux_alloc_real<std::allocator<Ogre::D3DDEVICEINFO_T *> >
PUBLIC	??0?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::D3DDEVICEINFO_T *>::allocator<Ogre::D3DDEVICEINFO_T *>
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$_Vector_val@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@IAE@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Vector_val@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@IAE@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@1@@Z$0
__ehfuncinfo$??0?$_Vector_val@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@IAE@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Vector_val@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@IAE@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Vector_val@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@IAE@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@1@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T142218 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 1
??0?$_Vector_val@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@IAE@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@1@@Z PROC ; std::_Vector_val<Ogre::D3DDEVICEINFO_T *,std::allocator<Ogre::D3DDEVICEINFO_T *> >::_Vector_val<Ogre::D3DDEVICEINFO_T *,std::allocator<Ogre::D3DDEVICEINFO_T *> >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Vector_val@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@IAE@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T142218[ebp], esp
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	call	??0?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::D3DDEVICEINFO_T *>::allocator<Ogre::D3DDEVICEINFO_T *>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Container_base_aux_alloc_real@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@IAE@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::D3DDEVICEINFO_T *> >::_Container_base_aux_alloc_real<std::allocator<Ogre::D3DDEVICEINFO_T *> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??0?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::D3DDEVICEINFO_T *>::allocator<Ogre::D3DDEVICEINFO_T *>

; 426  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Vector_val@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@IAE@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Container_base_aux_alloc_real@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::D3DDEVICEINFO_T *> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::D3DDEVICEINFO_T *> >
__ehhandler$??0?$_Vector_val@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@IAE@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Vector_val@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@IAE@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Vector_val@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@IAE@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@1@@Z ENDP ; std::_Vector_val<Ogre::D3DDEVICEINFO_T *,std::allocator<Ogre::D3DDEVICEINFO_T *> >::_Vector_val<Ogre::D3DDEVICEINFO_T *,std::allocator<Ogre::D3DDEVICEINFO_T *> >
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??1?$_Container_base_aux_alloc_real@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@IAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Container_base_aux_alloc_real@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@IAE@XZ$0
__ehfuncinfo$??1?$_Container_base_aux_alloc_real@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@IAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Container_base_aux_alloc_real@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@IAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$_Container_base_aux_alloc_real@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Container_base_aux_alloc_real@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::D3DDEVICEINFO_T *> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::D3DDEVICEINFO_T *> >, COMDAT
; _this$ = ecx

; 436  : 		{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Container_base_aux_alloc_real@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@IAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 437  : 		_Myownedaux->~_Aux_cont();
; 438  : 
; 439  : 		_Alaux.deallocate(_Myownedaux, 1);

	push	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?deallocate@?$allocator@V_Aux_cont@std@@@std@@QAEXPAV_Aux_cont@2@I@Z ; std::allocator<std::_Aux_cont>::deallocate

; 440  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Container_base_aux_alloc_real@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@IAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
__ehhandler$??1?$_Container_base_aux_alloc_real@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@IAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Container_base_aux_alloc_real@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@IAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Container_base_aux_alloc_real@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::D3DDEVICEINFO_T *> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::D3DDEVICEINFO_T *> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@QAE@XZ PROC ; std::allocator<Ogre::D3DDEVICEINFO_T *>::allocator<Ogre::D3DDEVICEINFO_T *>, COMDAT
; _this$ = ecx

; 119  : 	allocator() _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@QAE@XZ ENDP ; std::allocator<Ogre::D3DDEVICEINFO_T *>::allocator<Ogre::D3DDEVICEINFO_T *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?capacity@?$vector@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
tv70 = -8						; size = 4
_this$ = -4						; size = 4
?capacity@?$vector@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@QBEIXZ PROC ; std::vector<Ogre::D3DADAPTER_T *,std::allocator<Ogre::D3DADAPTER_T *> >::capacity, COMDAT
; _this$ = ecx

; 634  : 		{	// return current length of allocated storage

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	jne	SHORT $LN3@capacity@9
	mov	DWORD PTR tv70[ebp], 0
	jmp	SHORT $LN4@capacity@9
$LN3@capacity@9:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+20]
	sub	eax, DWORD PTR [edx+12]
	sar	eax, 2
	mov	DWORD PTR tv70[ebp], eax
$LN4@capacity@9:
	mov	eax, DWORD PTR tv70[ebp]

; 636  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?capacity@?$vector@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@QBEIXZ ENDP ; std::vector<Ogre::D3DADAPTER_T *,std::allocator<Ogre::D3DADAPTER_T *> >::capacity
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@QAE@PAPAUD3DADAPTER_T@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::D3DADAPTER_T *,std::allocator<Ogre::D3DADAPTER_T *> >::_Vector_iterator<Ogre::D3DADAPTER_T *,std::allocator<Ogre::D3DADAPTER_T *> >
; Function compile flags: /Odtp
;	COMDAT ?end@?$vector@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@2@XZ PROC ; std::vector<Ogre::D3DADAPTER_T *,std::allocator<Ogre::D3DADAPTER_T *> >::end, COMDAT
; _this$ = ecx

; 650  : 		{	// return iterator for end of mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 651  : 		return (iterator(_Mylast, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@QAE@PAPAUD3DADAPTER_T@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::D3DADAPTER_T *,std::allocator<Ogre::D3DADAPTER_T *> >::_Vector_iterator<Ogre::D3DADAPTER_T *,std::allocator<Ogre::D3DADAPTER_T *> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 652  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?end@?$vector@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@2@XZ ENDP ; std::vector<Ogre::D3DADAPTER_T *,std::allocator<Ogre::D3DADAPTER_T *> >::end
_TEXT	ENDS
PUBLIC	??H?$_Vector_iterator@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<Ogre::D3DADAPTER_T *,std::allocator<Ogre::D3DADAPTER_T *> >::operator+
PUBLIC	?_Insert_n@?$vector@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@2@IABQAUD3DADAPTER_T@Ogre@@@Z ; std::vector<Ogre::D3DADAPTER_T *,std::allocator<Ogre::D3DADAPTER_T *> >::_Insert_n
PUBLIC	??G?$_Vector_const_iterator@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@QBEHABV01@@Z ; std::_Vector_const_iterator<Ogre::D3DADAPTER_T *,std::allocator<Ogre::D3DADAPTER_T *> >::operator-
PUBLIC	?begin@?$vector@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@2@XZ ; std::vector<Ogre::D3DADAPTER_T *,std::allocator<Ogre::D3DADAPTER_T *> >::begin
; Function compile flags: /Odtp
;	COMDAT ?insert@?$vector@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@2@ABQAUD3DADAPTER_T@Ogre@@@Z
_TEXT	SEGMENT
tv77 = -28						; size = 4
_this$ = -24						; size = 4
$T142248 = -20						; size = 8
$T142245 = -12						; size = 8
__Off$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 8
__Val$ = 20						; size = 4
?insert@?$vector@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@2@ABQAUD3DADAPTER_T@Ogre@@@Z PROC ; std::vector<Ogre::D3DADAPTER_T *,std::allocator<Ogre::D3DADAPTER_T *> >::insert, COMDAT
; _this$ = ecx

; 875  : 		{	// insert _Val at _Where

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR _this$[ebp], ecx

; 876  : 		size_type _Off = size() == 0 ? 0 : _Where - begin();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::D3DADAPTER_T *,std::allocator<Ogre::D3DADAPTER_T *> >::size
	test	eax, eax
	jne	SHORT $LN3@insert@9
	mov	DWORD PTR tv77[ebp], 0
	jmp	SHORT $LN4@insert@9
$LN3@insert@9:
	lea	eax, DWORD PTR $T142245[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$vector@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@2@XZ ; std::vector<Ogre::D3DADAPTER_T *,std::allocator<Ogre::D3DADAPTER_T *> >::begin
	push	eax
	lea	ecx, DWORD PTR __Where$[ebp]
	call	??G?$_Vector_const_iterator@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@QBEHABV01@@Z ; std::_Vector_const_iterator<Ogre::D3DADAPTER_T *,std::allocator<Ogre::D3DADAPTER_T *> >::operator-
	mov	DWORD PTR tv77[ebp], eax
$LN4@insert@9:
	mov	ecx, DWORD PTR tv77[ebp]
	mov	DWORD PTR __Off$[ebp], ecx

; 877  : 		_Insert_n(_Where, (size_type)1, _Val);

	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	push	1
	mov	eax, DWORD PTR __Where$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert_n@?$vector@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@2@IABQAUD3DADAPTER_T@Ogre@@@Z ; std::vector<Ogre::D3DADAPTER_T *,std::allocator<Ogre::D3DADAPTER_T *> >::_Insert_n

; 878  : 		return (begin() + _Off);

	mov	edx, DWORD PTR __Off$[ebp]
	push	edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T142248[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$vector@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@2@XZ ; std::vector<Ogre::D3DADAPTER_T *,std::allocator<Ogre::D3DADAPTER_T *> >::begin
	mov	ecx, eax
	call	??H?$_Vector_iterator@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<Ogre::D3DADAPTER_T *,std::allocator<Ogre::D3DADAPTER_T *> >::operator+
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 879  : 		}

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?insert@?$vector@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@2@ABQAUD3DADAPTER_T@Ogre@@@Z ENDP ; std::vector<Ogre::D3DADAPTER_T *,std::allocator<Ogre::D3DADAPTER_T *> >::insert
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@QAEPAPAUD3DADAPTER_T@Ogre@@I@Z ; std::allocator<Ogre::D3DADAPTER_T *>::allocate
PUBLIC	?_Xlen@?$vector@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@KAXXZ ; std::vector<Ogre::D3DADAPTER_T *,std::allocator<Ogre::D3DADAPTER_T *> >::_Xlen
PUBLIC	?max_size@?$vector@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::D3DADAPTER_T *,std::allocator<Ogre::D3DADAPTER_T *> >::max_size
; Function compile flags: /Odtp
;	COMDAT ?_Buy@?$vector@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Capacity$ = 8						; size = 4
?_Buy@?$vector@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@IAE_NI@Z PROC ; std::vector<Ogre::D3DADAPTER_T *,std::allocator<Ogre::D3DADAPTER_T *> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+20], 0

; 1104 : 		if (_Capacity == 0)

	cmp	DWORD PTR __Capacity$[ebp], 0
	jne	SHORT $LN4@Buy@9

; 1105 : 			return (false);

	xor	al, al
	jmp	SHORT $LN5@Buy@9
	jmp	SHORT $LN3@Buy@9
$LN4@Buy@9:

; 1106 : 		else if (max_size() < _Capacity)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::D3DADAPTER_T *,std::allocator<Ogre::D3DADAPTER_T *> >::max_size
	cmp	eax, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN2@Buy@9

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@KAXXZ ; std::vector<Ogre::D3DADAPTER_T *,std::allocator<Ogre::D3DADAPTER_T *> >::_Xlen

; 1108 : 		else

	jmp	SHORT $LN3@Buy@9
$LN2@Buy@9:

; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	mov	eax, DWORD PTR __Capacity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?allocate@?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@QAEPAPAUD3DADAPTER_T@Ogre@@I@Z ; std::allocator<Ogre::D3DADAPTER_T *>::allocate
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [edx+16], ecx

; 1112 : 			_Myend = _Myfirst + _Capacity;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR __Capacity$[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], edx
$LN3@Buy@9:

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
$LN5@Buy@9:

; 1115 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Buy@?$vector@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<Ogre::D3DADAPTER_T *,std::allocator<Ogre::D3DADAPTER_T *> >::_Buy
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@QAEXPAPAUD3DADAPTER_T@Ogre@@I@Z ; std::allocator<Ogre::D3DADAPTER_T *>::deallocate
PUBLIC	?_Destroy@?$vector@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@IAEXPAPAUD3DADAPTER_T@Ogre@@0@Z ; std::vector<Ogre::D3DADAPTER_T *,std::allocator<Ogre::D3DADAPTER_T *> >::_Destroy
; Function compile flags: /Odtp
;	COMDAT ?_Tidy@?$vector@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Tidy@?$vector@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@IAEXXZ PROC ; std::vector<Ogre::D3DADAPTER_T *,std::allocator<Ogre::D3DADAPTER_T *> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	je	SHORT $LN1@Tidy@9

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@IAEXPAPAUD3DADAPTER_T@Ogre@@0@Z ; std::vector<Ogre::D3DADAPTER_T *,std::allocator<Ogre::D3DADAPTER_T *> >::_Destroy

; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+20]
	sub	ecx, DWORD PTR [eax+12]
	sar	ecx, 2
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?deallocate@?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@QAEXPAPAUD3DADAPTER_T@Ogre@@I@Z ; std::allocator<Ogre::D3DADAPTER_T *>::deallocate
$LN1@Tidy@9:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+16], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], 0

; 1135 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$vector@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@IAEXXZ ENDP ; std::vector<Ogre::D3DADAPTER_T *,std::allocator<Ogre::D3DADAPTER_T *> >::_Tidy
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_fill_n@PAPAUD3DADAPTER_T@Ogre@@IPAU12@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@stdext@@YAXPAPAUD3DADAPTER_T@Ogre@@IABQAU12@AAV?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@Z ; stdext::unchecked_uninitialized_fill_n<Ogre::D3DADAPTER_T * *,unsigned int,Ogre::D3DADAPTER_T *,std::allocator<Ogre::D3DADAPTER_T *> >
; Function compile flags: /Odtp
;	COMDAT ?_Ufill@?$vector@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@IAEPAPAUD3DADAPTER_T@Ogre@@PAPAU34@IABQAU34@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Ufill@?$vector@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@IAEPAPAUD3DADAPTER_T@Ogre@@PAPAU34@IABQAU34@@Z PROC ; std::vector<Ogre::D3DADAPTER_T *,std::allocator<Ogre::D3DADAPTER_T *> >::_Ufill, COMDAT
; _this$ = ecx

; 1253 : 		{	// copy initializing _Count * _Val, using allocator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1254 : 		_STDEXT unchecked_uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??$unchecked_uninitialized_fill_n@PAPAUD3DADAPTER_T@Ogre@@IPAU12@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@stdext@@YAXPAPAUD3DADAPTER_T@Ogre@@IABQAU12@AAV?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@Z ; stdext::unchecked_uninitialized_fill_n<Ogre::D3DADAPTER_T * *,unsigned int,Ogre::D3DADAPTER_T *,std::allocator<Ogre::D3DADAPTER_T *> >
	add	esp, 16					; 00000010H

; 1255 : 		return (_Ptr + _Count);

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Ptr$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]

; 1256 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?_Ufill@?$vector@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@IAEPAPAUD3DADAPTER_T@Ogre@@PAPAU34@IABQAU34@@Z ENDP ; std::vector<Ogre::D3DADAPTER_T *,std::allocator<Ogre::D3DADAPTER_T *> >::_Ufill
_TEXT	ENDS
PUBLIC	??0?$_Container_base_aux_alloc_real@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@IAE@V?$allocator@PAUD3DADAPTER_T@Ogre@@@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::D3DADAPTER_T *> >::_Container_base_aux_alloc_real<std::allocator<Ogre::D3DADAPTER_T *> >
PUBLIC	??0?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::D3DADAPTER_T *>::allocator<Ogre::D3DADAPTER_T *>
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$_Vector_val@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@IAE@V?$allocator@PAUD3DADAPTER_T@Ogre@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Vector_val@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@IAE@V?$allocator@PAUD3DADAPTER_T@Ogre@@@1@@Z$0
__ehfuncinfo$??0?$_Vector_val@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@IAE@V?$allocator@PAUD3DADAPTER_T@Ogre@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Vector_val@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@IAE@V?$allocator@PAUD3DADAPTER_T@Ogre@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Vector_val@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@IAE@V?$allocator@PAUD3DADAPTER_T@Ogre@@@1@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T142257 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 1
??0?$_Vector_val@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@IAE@V?$allocator@PAUD3DADAPTER_T@Ogre@@@1@@Z PROC ; std::_Vector_val<Ogre::D3DADAPTER_T *,std::allocator<Ogre::D3DADAPTER_T *> >::_Vector_val<Ogre::D3DADAPTER_T *,std::allocator<Ogre::D3DADAPTER_T *> >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Vector_val@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@IAE@V?$allocator@PAUD3DADAPTER_T@Ogre@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T142257[ebp], esp
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	call	??0?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::D3DADAPTER_T *>::allocator<Ogre::D3DADAPTER_T *>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Container_base_aux_alloc_real@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@IAE@V?$allocator@PAUD3DADAPTER_T@Ogre@@@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::D3DADAPTER_T *> >::_Container_base_aux_alloc_real<std::allocator<Ogre::D3DADAPTER_T *> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??0?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::D3DADAPTER_T *>::allocator<Ogre::D3DADAPTER_T *>

; 426  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Vector_val@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@IAE@V?$allocator@PAUD3DADAPTER_T@Ogre@@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Container_base_aux_alloc_real@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::D3DADAPTER_T *> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::D3DADAPTER_T *> >
__ehhandler$??0?$_Vector_val@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@IAE@V?$allocator@PAUD3DADAPTER_T@Ogre@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Vector_val@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@IAE@V?$allocator@PAUD3DADAPTER_T@Ogre@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Vector_val@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@IAE@V?$allocator@PAUD3DADAPTER_T@Ogre@@@1@@Z ENDP ; std::_Vector_val<Ogre::D3DADAPTER_T *,std::allocator<Ogre::D3DADAPTER_T *> >::_Vector_val<Ogre::D3DADAPTER_T *,std::allocator<Ogre::D3DADAPTER_T *> >
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??1?$_Container_base_aux_alloc_real@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@IAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Container_base_aux_alloc_real@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@IAE@XZ$0
__ehfuncinfo$??1?$_Container_base_aux_alloc_real@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@IAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Container_base_aux_alloc_real@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@IAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$_Container_base_aux_alloc_real@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Container_base_aux_alloc_real@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::D3DADAPTER_T *> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::D3DADAPTER_T *> >, COMDAT
; _this$ = ecx

; 436  : 		{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Container_base_aux_alloc_real@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@IAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 437  : 		_Myownedaux->~_Aux_cont();
; 438  : 
; 439  : 		_Alaux.deallocate(_Myownedaux, 1);

	push	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?deallocate@?$allocator@V_Aux_cont@std@@@std@@QAEXPAV_Aux_cont@2@I@Z ; std::allocator<std::_Aux_cont>::deallocate

; 440  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Container_base_aux_alloc_real@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@IAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
__ehhandler$??1?$_Container_base_aux_alloc_real@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@IAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Container_base_aux_alloc_real@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@IAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Container_base_aux_alloc_real@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::D3DADAPTER_T *> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::D3DADAPTER_T *> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@QAE@XZ PROC	; std::allocator<Ogre::D3DADAPTER_T *>::allocator<Ogre::D3DADAPTER_T *>, COMDAT
; _this$ = ecx

; 119  : 	allocator() _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@QAE@XZ ENDP	; std::allocator<Ogre::D3DADAPTER_T *>::allocator<Ogre::D3DADAPTER_T *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?begin@?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@QAE?AV?$_Vector_iterator@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@QAE?AV?$_Vector_iterator@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@2@XZ PROC ; std::vector<enum _D3DFORMAT,std::allocator<enum _D3DFORMAT> >::begin, COMDAT
; _this$ = ecx

; 640  : 		{	// return iterator for beginning of mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 641  : 		return (iterator(_Myfirst, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@QAE@PAW4_D3DFORMAT@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<enum _D3DFORMAT,std::allocator<enum _D3DFORMAT> >::_Vector_iterator<enum _D3DFORMAT,std::allocator<enum _D3DFORMAT> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 642  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?begin@?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@QAE?AV?$_Vector_iterator@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@2@XZ ENDP ; std::vector<enum _D3DFORMAT,std::allocator<enum _D3DFORMAT> >::begin
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@W4_D3DFORMAT@@@std@@QBEIXZ ; std::allocator<enum _D3DFORMAT>::max_size
; Function compile flags: /Odtp
;	COMDAT ?max_size@?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@QBEIXZ PROC ; std::vector<enum _D3DFORMAT,std::allocator<enum _D3DFORMAT> >::max_size, COMDAT
; _this$ = ecx

; 730  : 		{	// return maximum possible length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 731  : 		return (this->_Alval.max_size());

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?max_size@?$allocator@W4_D3DFORMAT@@@std@@QBEIXZ ; std::allocator<enum _D3DFORMAT>::max_size

; 732  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@QBEIXZ ENDP ; std::vector<enum _D3DFORMAT,std::allocator<enum _D3DFORMAT> >::max_size
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@W4_D3DFORMAT@@@std@@@std@@YAXPAW4_D3DFORMAT@@0AAV?$allocator@W4_D3DFORMAT@@@0@@Z ; std::_Destroy_range<std::allocator<enum _D3DFORMAT> >
; Function compile flags: /Odtp
;	COMDAT ?_Destroy@?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@IAEXPAW4_D3DFORMAT@@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@IAEXPAW4_D3DFORMAT@@0@Z PROC ; std::vector<enum _D3DFORMAT,std::allocator<enum _D3DFORMAT> >::_Destroy, COMDAT
; _this$ = ecx

; 1118 : 		{	// destroy [_First, _Last) using allocator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Destroy_range@V?$allocator@W4_D3DFORMAT@@@std@@@std@@YAXPAW4_D3DFORMAT@@0AAV?$allocator@W4_D3DFORMAT@@@0@@Z ; std::_Destroy_range<std::allocator<enum _D3DFORMAT> >
	add	esp, 12					; 0000000cH

; 1120 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?_Destroy@?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@IAEXPAW4_D3DFORMAT@@0@Z ENDP ; std::vector<enum _D3DFORMAT,std::allocator<enum _D3DFORMAT> >::_Destroy
_TEXT	ENDS
PUBLIC	??$_Unchecked_move_backward@PAW4_D3DFORMAT@@PAW41@@stdext@@YAPAW4_D3DFORMAT@@PAW41@00@Z ; stdext::_Unchecked_move_backward<enum _D3DFORMAT *,enum _D3DFORMAT *>
PUBLIC	??$fill@PAW4_D3DFORMAT@@W41@@std@@YAXPAW4_D3DFORMAT@@0ABW41@@Z ; std::fill<enum _D3DFORMAT *,enum _D3DFORMAT>
PUBLIC	??$_Umove@PAW4_D3DFORMAT@@@?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@IAEPAW4_D3DFORMAT@@PAW42@00@Z ; std::vector<enum _D3DFORMAT,std::allocator<enum _D3DFORMAT> >::_Umove<enum _D3DFORMAT *>
EXTRN	__CxxThrowException@8:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Insert_n@?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@2@IABW4_D3DFORMAT@@@Z$5 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@2@IABW4_D3DFORMAT@@@Z$2
__catchsym$?_Insert_n@?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@2@IABW4_D3DFORMAT@@@Z$4 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@2@IABW4_D3DFORMAT@@@Z$0
__unwindtable$?_Insert_n@?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@2@IABW4_D3DFORMAT@@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$?_Insert_n@?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@2@IABW4_D3DFORMAT@@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Insert_n@?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@2@IABW4_D3DFORMAT@@@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Insert_n@?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@2@IABW4_D3DFORMAT@@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__tryblocktable$?_Insert_n@?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@2@IABW4_D3DFORMAT@@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@2@IABW4_D3DFORMAT@@@Z$4
	DD	02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@2@IABW4_D3DFORMAT@@@Z$5
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?_Insert_n@?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@2@IABW4_D3DFORMAT@@@Z
_TEXT	SEGMENT
tv84 = -52						; size = 4
_this$ = -48						; size = 4
__Tmp$133782 = -44					; size = 4
__Oldend$133783 = -40					; size = 4
__Tmp$133772 = -36					; size = 4
__Ncopied$133759 = -32					; size = 4
__Newvec$133757 = -28					; size = 4
__Whereoff$133758 = -24					; size = 4
__Capacity$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Where$ = 8						; size = 8
__Count$ = 16						; size = 4
__Val$ = 20						; size = 4
?_Insert_n@?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@2@IABW4_D3DFORMAT@@@Z PROC ; std::vector<enum _D3DFORMAT,std::allocator<enum _D3DFORMAT> >::_Insert_n, COMDAT
; _this$ = ecx

; 1153 : 		{	// insert _Count * _Val at _Where

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Insert_n@?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@2@IABW4_D3DFORMAT@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 36					; 00000024H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1154 : 
; 1155 :  #if _HAS_ITERATOR_DEBUGGING
; 1156 : 		if (_Where._Mycont != this
; 1157 : 			|| _Where._Myptr < _Myfirst || _Mylast < _Where._Myptr)
; 1158 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1159 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1160 : 
; 1161 : 		size_type _Capacity = capacity();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?capacity@?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@QBEIXZ ; std::vector<enum _D3DFORMAT,std::allocator<enum _D3DFORMAT> >::capacity
	mov	DWORD PTR __Capacity$[ebp], eax

; 1162 : 
; 1163 : 		if (_Count == 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN14@Insert_n
	jmp	$LN16@Insert_n
$LN14@Insert_n:

; 1164 : 			;
; 1165 : 		else if (max_size() - size() < _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@QBEIXZ ; std::vector<enum _D3DFORMAT,std::allocator<enum _D3DFORMAT> >::max_size
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@QBEIXZ ; std::vector<enum _D3DFORMAT,std::allocator<enum _D3DFORMAT> >::size
	sub	esi, eax
	cmp	esi, DWORD PTR __Count$[ebp]
	jae	SHORT $LN12@Insert_n

; 1166 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@KAXXZ ; std::vector<enum _D3DFORMAT,std::allocator<enum _D3DFORMAT> >::_Xlen
	jmp	$LN16@Insert_n
$LN12@Insert_n:

; 1167 : 		else if (_Capacity < size() + _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@QBEIXZ ; std::vector<enum _D3DFORMAT,std::allocator<enum _D3DFORMAT> >::size
	add	eax, DWORD PTR __Count$[ebp]
	cmp	DWORD PTR __Capacity$[ebp], eax
	jae	$LN10@Insert_n

; 1168 : 			{	// not enough room, reallocate
; 1169 : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1170 : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@QBEIXZ ; std::vector<enum _D3DFORMAT,std::allocator<enum _D3DFORMAT> >::max_size
	mov	ecx, DWORD PTR __Capacity$[ebp]
	shr	ecx, 1
	sub	eax, ecx
	cmp	eax, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN17@Insert_n
	mov	DWORD PTR tv84[ebp], 0
	jmp	SHORT $LN18@Insert_n
$LN17@Insert_n:
	mov	edx, DWORD PTR __Capacity$[ebp]
	shr	edx, 1
	add	edx, DWORD PTR __Capacity$[ebp]
	mov	DWORD PTR tv84[ebp], edx
$LN18@Insert_n:
	mov	eax, DWORD PTR tv84[ebp]
	mov	DWORD PTR __Capacity$[ebp], eax

; 1171 : 			if (_Capacity < size() + _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@QBEIXZ ; std::vector<enum _D3DFORMAT,std::allocator<enum _D3DFORMAT> >::size
	add	eax, DWORD PTR __Count$[ebp]
	cmp	DWORD PTR __Capacity$[ebp], eax
	jae	SHORT $LN9@Insert_n

; 1172 : 				_Capacity = size() + _Count;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@QBEIXZ ; std::vector<enum _D3DFORMAT,std::allocator<enum _D3DFORMAT> >::size
	add	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Capacity$[ebp], eax
$LN9@Insert_n:

; 1173 : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

	mov	ecx, DWORD PTR __Capacity$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?allocate@?$allocator@W4_D3DFORMAT@@@std@@QAEPAW4_D3DFORMAT@@I@Z ; std::allocator<enum _D3DFORMAT>::allocate
	mov	DWORD PTR __Newvec$133757[ebp], eax

; 1174 : 			size_type _Whereoff = _VEC_ITER_BASE(_Where) - _Myfirst;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Where$[ebp+4]
	sub	eax, DWORD PTR [edx+12]
	sar	eax, 2
	mov	DWORD PTR __Whereoff$133758[ebp], eax

; 1175 : 			int _Ncopied = 0;

	mov	DWORD PTR __Ncopied$133759[ebp], 0

; 1176 : 
; 1177 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1178 : 			_Ufill(_Newvec + _Whereoff, _Count, _Val);	// add new stuff

	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __Whereoff$133758[ebp]
	mov	ecx, DWORD PTR __Newvec$133757[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Ufill@?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@IAEPAW4_D3DFORMAT@@PAW43@IABW43@@Z ; std::vector<enum _D3DFORMAT,std::allocator<enum _D3DFORMAT> >::_Ufill

; 1179 : 			++_Ncopied;

	mov	eax, DWORD PTR __Ncopied$133759[ebp]
	add	eax, 1
	mov	DWORD PTR __Ncopied$133759[ebp], eax

; 1180 : 			_Umove(this->_Myfirst, _VEC_ITER_BASE(_Where),
; 1181 : 				_Newvec);	// move prefix

	mov	ecx, DWORD PTR __Newvec$133757[ebp]
	push	ecx
	mov	edx, DWORD PTR __Where$[ebp+4]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Umove@PAW4_D3DFORMAT@@@?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@IAEPAW4_D3DFORMAT@@PAW42@00@Z ; std::vector<enum _D3DFORMAT,std::allocator<enum _D3DFORMAT> >::_Umove<enum _D3DFORMAT *>

; 1182 : 			++_Ncopied;

	mov	edx, DWORD PTR __Ncopied$133759[ebp]
	add	edx, 1
	mov	DWORD PTR __Ncopied$133759[ebp], edx

; 1183 : 			_Umove(_VEC_ITER_BASE(_Where), this->_Mylast,
; 1184 : 				_Newvec + (_Whereoff + _Count));	// move suffix

	mov	eax, DWORD PTR __Whereoff$133758[ebp]
	add	eax, DWORD PTR __Count$[ebp]
	mov	ecx, DWORD PTR __Newvec$133757[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Where$[ebp+4]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Umove@PAW4_D3DFORMAT@@@?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@IAEPAW4_D3DFORMAT@@PAW42@00@Z ; std::vector<enum _D3DFORMAT,std::allocator<enum _D3DFORMAT> >::_Umove<enum _D3DFORMAT *>
	jmp	SHORT $LN19@Insert_n
__catch$?_Insert_n@?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@2@IABW4_D3DFORMAT@@@Z$0:

; 1185 : 			_CATCH_ALL
; 1186 : 			if (1 < _Ncopied)

	cmp	DWORD PTR __Ncopied$133759[ebp], 1
	jle	SHORT $LN7@Insert_n

; 1187 : 				_Destroy(_Newvec, _Newvec + _Whereoff);

	mov	eax, DWORD PTR __Whereoff$133758[ebp]
	mov	ecx, DWORD PTR __Newvec$133757[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	push	edx
	mov	eax, DWORD PTR __Newvec$133757[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@IAEXPAW4_D3DFORMAT@@0@Z ; std::vector<enum _D3DFORMAT,std::allocator<enum _D3DFORMAT> >::_Destroy
$LN7@Insert_n:

; 1188 : 			if (0 < _Ncopied)

	cmp	DWORD PTR __Ncopied$133759[ebp], 0
	jle	SHORT $LN6@Insert_n

; 1189 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);

	mov	ecx, DWORD PTR __Whereoff$133758[ebp]
	mov	edx, DWORD PTR __Newvec$133757[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR __Count$[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]
	push	edx
	mov	eax, DWORD PTR __Whereoff$133758[ebp]
	mov	ecx, DWORD PTR __Newvec$133757[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@IAEXPAW4_D3DFORMAT@@0@Z ; std::vector<enum _D3DFORMAT,std::allocator<enum _D3DFORMAT> >::_Destroy
$LN6@Insert_n:

; 1190 : 			this->_Alval.deallocate(_Newvec, _Capacity);

	mov	eax, DWORD PTR __Capacity$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Newvec$133757[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?deallocate@?$allocator@W4_D3DFORMAT@@@std@@QAEXPAW4_D3DFORMAT@@I@Z ; std::allocator<enum _D3DFORMAT>::deallocate

; 1191 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1192 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$?_Insert_n@?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@2@IABW4_D3DFORMAT@@@Z$1
	ret	0
$LN19@Insert_n:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Insert_n@?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@2@IABW4_D3DFORMAT@@@Z$1:

; 1193 : 
; 1194 : 			_Count += size();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@QBEIXZ ; std::vector<enum _D3DFORMAT,std::allocator<enum _D3DFORMAT> >::size
	add	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Count$[ebp], eax

; 1195 : 			if (_Myfirst != 0)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+12], 0
	je	SHORT $LN5@Insert_n

; 1196 : 				{	// destroy and deallocate old array
; 1197 : 				_Destroy(_Myfirst, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@IAEXPAW4_D3DFORMAT@@0@Z ; std::vector<enum _D3DFORMAT,std::allocator<enum _D3DFORMAT> >::_Destroy

; 1198 : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+20]
	sub	eax, DWORD PTR [edx+12]
	sar	eax, 2
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?deallocate@?$allocator@W4_D3DFORMAT@@@std@@QAEXPAW4_D3DFORMAT@@I@Z ; std::allocator<enum _D3DFORMAT>::deallocate
$LN5@Insert_n:

; 1199 : 				}
; 1200 : 
; 1201 :  #if _HAS_ITERATOR_DEBUGGING
; 1202 : 			this->_Orphan_all();
; 1203 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1204 : 
; 1205 : 			_Myend = _Newvec + _Capacity;

	mov	eax, DWORD PTR __Capacity$[ebp]
	mov	ecx, DWORD PTR __Newvec$133757[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], edx

; 1206 : 			_Mylast = _Newvec + _Count;

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Newvec$133757[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 1207 : 			_Myfirst = _Newvec;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Newvec$133757[ebp]
	mov	DWORD PTR [edx+12], eax
	jmp	$LN16@Insert_n
$LN10@Insert_n:

; 1208 : 			}
; 1209 : 		else if ((size_type)(_Mylast - _VEC_ITER_BASE(_Where)) < _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	sub	edx, DWORD PTR __Where$[ebp+4]
	sar	edx, 2
	cmp	edx, DWORD PTR __Count$[ebp]
	jae	$LN3@Insert_n

; 1210 : 			{	// new stuff spills off end
; 1211 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Tmp$133772[ebp], ecx

; 1212 : 
; 1213 : 			_Umove(_VEC_ITER_BASE(_Where), _Mylast,
; 1214 : 				_VEC_ITER_BASE(_Where) + _Count);	// copy suffix

	mov	edx, DWORD PTR __Count$[ebp]
	mov	eax, DWORD PTR __Where$[ebp+4]
	lea	ecx, DWORD PTR [eax+edx*4]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp+4]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Umove@PAW4_D3DFORMAT@@@?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@IAEPAW4_D3DFORMAT@@PAW42@00@Z ; std::vector<enum _D3DFORMAT,std::allocator<enum _D3DFORMAT> >::_Umove<enum _D3DFORMAT *>

; 1215 : 
; 1216 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 2

; 1217 : 			_Ufill(_Mylast, _Count - (_Mylast - _VEC_ITER_BASE(_Where)),
; 1218 : 				_Tmp);	// insert new stuff off end

	lea	edx, DWORD PTR __Tmp$133772[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	sub	ecx, DWORD PTR __Where$[ebp+4]
	sar	ecx, 2
	mov	edx, DWORD PTR __Count$[ebp]
	sub	edx, ecx
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Ufill@?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@IAEPAW4_D3DFORMAT@@PAW43@IABW43@@Z ; std::vector<enum _D3DFORMAT,std::allocator<enum _D3DFORMAT> >::_Ufill
	jmp	SHORT $LN21@Insert_n
__catch$?_Insert_n@?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@2@IABW4_D3DFORMAT@@@Z$2:

; 1219 : 			_CATCH_ALL
; 1220 : 			_Destroy(_VEC_ITER_BASE(_Where) + _Count, _Mylast + _Count);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR __Count$[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	mov	ecx, DWORD PTR __Where$[ebp+4]
	lea	edx, DWORD PTR [ecx+eax*4]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@IAEXPAW4_D3DFORMAT@@0@Z ; std::vector<enum _D3DFORMAT,std::allocator<enum _D3DFORMAT> >::_Destroy

; 1221 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1222 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$?_Insert_n@?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@2@IABW4_D3DFORMAT@@@Z$3
	ret	0
$LN21@Insert_n:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Insert_n@?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@2@IABW4_D3DFORMAT@@@Z$3:

; 1223 : 
; 1224 : 			_Mylast += _Count;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR __Count$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 1225 : 
; 1226 :  #if _HAS_ITERATOR_DEBUGGING
; 1227 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1228 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1229 : 
; 1230 : 			std::fill(_VEC_ITER_BASE(_Where), _Mylast - _Count,
; 1231 : 				_Tmp);	// insert up to old end

	lea	edx, DWORD PTR __Tmp$133772[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 2
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	sub	edx, eax
	push	edx
	mov	eax, DWORD PTR __Where$[ebp+4]
	push	eax
	call	??$fill@PAW4_D3DFORMAT@@W41@@std@@YAXPAW4_D3DFORMAT@@0ABW41@@Z ; std::fill<enum _D3DFORMAT *,enum _D3DFORMAT>
	add	esp, 12					; 0000000cH

; 1232 : 			}
; 1233 : 		else

	jmp	SHORT $LN16@Insert_n
$LN3@Insert_n:

; 1234 : 			{	// new stuff can all be assigned
; 1235 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	ecx, DWORD PTR __Val$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR __Tmp$133782[ebp], edx

; 1236 : 
; 1237 : 			pointer _Oldend = _Mylast;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR __Oldend$133783[ebp], ecx

; 1238 : 			_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1239 : 				_Mylast);	// copy suffix

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR __Oldend$133783[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count$[ebp]
	shl	edx, 2
	mov	eax, DWORD PTR __Oldend$133783[ebp]
	sub	eax, edx
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Umove@PAW4_D3DFORMAT@@@?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@IAEPAW4_D3DFORMAT@@PAW42@00@Z ; std::vector<enum _D3DFORMAT,std::allocator<enum _D3DFORMAT> >::_Umove<enum _D3DFORMAT *>
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 1240 : 
; 1241 :  #if _HAS_ITERATOR_DEBUGGING
; 1242 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1243 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1244 : 
; 1245 : 			_STDEXT _Unchecked_move_backward(_VEC_ITER_BASE(_Where), _Oldend - _Count,
; 1246 : 				_Oldend);	// copy hole

	mov	edx, DWORD PTR __Oldend$133783[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 2
	mov	ecx, DWORD PTR __Oldend$133783[ebp]
	sub	ecx, eax
	push	ecx
	mov	edx, DWORD PTR __Where$[ebp+4]
	push	edx
	call	??$_Unchecked_move_backward@PAW4_D3DFORMAT@@PAW41@@stdext@@YAPAW4_D3DFORMAT@@PAW41@00@Z ; stdext::_Unchecked_move_backward<enum _D3DFORMAT *,enum _D3DFORMAT *>
	add	esp, 12					; 0000000cH

; 1247 : 			std::fill(_VEC_ITER_BASE(_Where), _VEC_ITER_BASE(_Where) + _Count,
; 1248 : 				_Tmp);	// insert into hole

	lea	eax, DWORD PTR __Tmp$133782[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Where$[ebp+4]
	lea	eax, DWORD PTR [edx+ecx*4]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp+4]
	push	ecx
	call	??$fill@PAW4_D3DFORMAT@@W41@@std@@YAXPAW4_D3DFORMAT@@0ABW41@@Z ; std::fill<enum _D3DFORMAT *,enum _D3DFORMAT>
	add	esp, 12					; 0000000cH
$LN16@Insert_n:

; 1249 : 			}
; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Insert_n@?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@2@IABW4_D3DFORMAT@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-56]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Insert_n@?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@2@IABW4_D3DFORMAT@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Insert_n@?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@2@IABW4_D3DFORMAT@@@Z ENDP ; std::vector<enum _D3DFORMAT,std::allocator<enum _D3DFORMAT> >::_Insert_n
PUBLIC	__TI3?AVlength_error@std@@
PUBLIC	??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::length_error::length_error
PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	??1length_error@std@@UAE@XZ			; std::length_error::~length_error
PUBLIC	__CTA3?AVlength_error@std@@
PUBLIC	__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
PUBLIC	??_R0?AVlength_error@std@@@8			; std::length_error `RTTI Type Descriptor'
PUBLIC	??0length_error@std@@QAE@ABV01@@Z		; std::length_error::length_error
PUBLIC	__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
PUBLIC	??_R0?AVlogic_error@std@@@8			; std::logic_error `RTTI Type Descriptor'
PUBLIC	??0logic_error@std@@QAE@ABV01@@Z		; std::logic_error::logic_error
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
EXTRN	__imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:PROC
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	??0exception@std@@QAE@ABV01@@Z:PROC		; std::exception::exception
;	COMDAT ??_R0?AVexception@std@@@8
_DATA	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVlogic_error@std@@@8
_DATA	SEGMENT
??_R0?AVlogic_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::logic_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlogic_error@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0logic_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVlength_error@std@@@8
_DATA	SEGMENT
??_R0?AVlength_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::length_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlength_error@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlength_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0length_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA3?AVlength_error@std@@
xdata$x	SEGMENT
__CTA3?AVlength_error@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVlength_error@std@@
xdata$x	SEGMENT
__TI3?AVlength_error@std@@ DD 00H
	DD	FLAT:??1length_error@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVlength_error@std@@
xdata$x	ENDS
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ DB 'vector<T> too long'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@KAXXZ$0
__ehfuncinfo$?_Xlen@?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@KAXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T142309 = -80						; size = 28
$T142308 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@KAXXZ PROC ; std::vector<enum _D3DFORMAT,std::allocator<enum _D3DFORMAT> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Xlen@?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T142309[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR $T142309[ebp]
	push	eax
	lea	ecx, DWORD PTR $T142308[ebp]
	call	??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::length_error::length_error
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T142308[ebp]
	push	ecx
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T142309[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN2@Xlen:

; 1261 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T142309[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?_Xlen@?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@KAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@KAXXZ ENDP ; std::vector<enum _D3DFORMAT,std::allocator<enum _D3DFORMAT> >::_Xlen
PUBLIC	??1logic_error@std@@UAE@XZ			; std::logic_error::~logic_error
PUBLIC	??_7length_error@std@@6B@			; std::length_error::`vftable'
PUBLIC	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
PUBLIC	??_R4length_error@std@@6B@			; std::length_error::`RTTI Complete Object Locator'
PUBLIC	??_R3length_error@std@@8			; std::length_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2length_error@std@@8			; std::length_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@length_error@std@@8		; std::length_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@logic_error@std@@8		; std::logic_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3logic_error@std@@8				; std::logic_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2logic_error@std@@8				; std::logic_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
PUBLIC	?what@logic_error@std@@UBEPBDXZ			; std::logic_error::what
EXTRN	??_Elength_error@std@@UAEPAXI@Z:PROC		; std::length_error::`vector deleting destructor'
;	COMDAT ??_R2exception@std@@8
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R2logic_error@std@@8
rdata$r	SEGMENT
??_R2logic_error@std@@8 DD FLAT:??_R1A@?0A@EA@logic_error@std@@8 ; std::logic_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3logic_error@std@@8
rdata$r	SEGMENT
??_R3logic_error@std@@8 DD 00H				; std::logic_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@logic_error@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@logic_error@std@@8 DD FLAT:??_R0?AVlogic_error@std@@@8 ; std::logic_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@length_error@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@length_error@std@@8 DD FLAT:??_R0?AVlength_error@std@@@8 ; std::length_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2length_error@std@@8
rdata$r	SEGMENT
??_R2length_error@std@@8 DD FLAT:??_R1A@?0A@EA@length_error@std@@8 ; std::length_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@logic_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3length_error@std@@8
rdata$r	SEGMENT
??_R3length_error@std@@8 DD 00H				; std::length_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R4length_error@std@@6B@
rdata$r	SEGMENT
??_R4length_error@std@@6B@ DD 00H			; std::length_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVlength_error@std@@@8
	DD	FLAT:??_R3length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_7length_error@std@@6B@
CONST	SEGMENT
??_7length_error@std@@6B@ DD FLAT:??_R4length_error@std@@6B@ ; std::length_error::`vftable'
	DD	FLAT:??_Elength_error@std@@UAEPAXI@Z
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0
__ehfuncinfo$??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Message$ = 8						; size = 4
??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::length_error::length_error, COMDAT
; _this$ = ecx

; 105  : 		{	// construct from message string

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Message$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7length_error@std@@6B@

; 106  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1logic_error@std@@UAE@XZ		; std::logic_error::~logic_error
__ehhandler$??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::length_error::length_error
PUBLIC	??_7logic_error@std@@6B@			; std::logic_error::`vftable'
PUBLIC	??_R4logic_error@std@@6B@			; std::logic_error::`RTTI Complete Object Locator'
EXTRN	__imp_??1exception@std@@UAE@XZ:PROC
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z:PROC
EXTRN	__imp_??0exception@std@@QAE@XZ:PROC
EXTRN	??_Elogic_error@std@@UAEPAXI@Z:PROC		; std::logic_error::`vector deleting destructor'
;	COMDAT ??_R4logic_error@std@@6B@
rdata$r	SEGMENT
??_R4logic_error@std@@6B@ DD 00H			; std::logic_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	FLAT:??_R3logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_7logic_error@std@@6B@
CONST	SEGMENT
??_7logic_error@std@@6B@ DD FLAT:??_R4logic_error@std@@6B@ ; std::logic_error::`vftable'
	DD	FLAT:??_Elogic_error@std@@UAEPAXI@Z
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$1
__ehfuncinfo$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Message$ = 8						; size = 4
??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::logic_error::logic_error, COMDAT
; _this$ = ecx

; 26   : 		{	// construct from message string

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7logic_error@std@@6B@
	mov	ecx, DWORD PTR __Message$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 27   : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__unwindfunclet$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::logic_error::logic_error
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1logic_error@std@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1logic_error@std@@UAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1logic_error@std@@UAE@XZ$1
__ehfuncinfo$??1logic_error@std@@UAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??1logic_error@std@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1logic_error@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1logic_error@std@@UAE@XZ PROC				; std::logic_error::~logic_error, COMDAT
; _this$ = ecx

; 30   : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1logic_error@std@@UAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7logic_error@std@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 31   : 		}

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1logic_error@std@@UAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__unwindfunclet$??1logic_error@std@@UAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$??1logic_error@std@@UAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1logic_error@std@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1logic_error@std@@UAE@XZ ENDP				; std::logic_error::~logic_error
EXTRN	__imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ:PROC
; Function compile flags: /Odtp
;	COMDAT ?what@logic_error@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?what@logic_error@std@@UBEPBDXZ PROC			; std::logic_error::what, COMDAT
; _this$ = ecx

; 34   : 		{	// return pointer to message string

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 35   : 		return (_Str.c_str());

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ

; 36   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?what@logic_error@std@@UBEPBDXZ ENDP			; std::logic_error::what
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_Glogic_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Glogic_error@std@@UAEPAXI@Z PROC			; std::logic_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1logic_error@std@@UAE@XZ		; std::logic_error::~logic_error
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@4
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@4:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Glogic_error@std@@UAEPAXI@Z ENDP			; std::logic_error::`scalar deleting destructor'
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1length_error@std@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1length_error@std@@UAE@XZ$0
__ehfuncinfo$??1length_error@std@@UAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1length_error@std@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1length_error@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1length_error@std@@UAE@XZ PROC			; std::length_error::~length_error, COMDAT
; _this$ = ecx

; 109  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1length_error@std@@UAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7length_error@std@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 110  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1logic_error@std@@UAE@XZ		; std::logic_error::~logic_error
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1length_error@std@@UAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1logic_error@std@@UAE@XZ		; std::logic_error::~logic_error
__ehhandler$??1length_error@std@@UAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1length_error@std@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1length_error@std@@UAE@XZ ENDP			; std::length_error::~length_error
; Function compile flags: /Odtp
;	COMDAT ??_Glength_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Glength_error@std@@UAEPAXI@Z PROC			; std::length_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1length_error@std@@UAE@XZ		; std::length_error::~length_error
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@5
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@5:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Glength_error@std@@UAEPAXI@Z ENDP			; std::length_error::`scalar deleting destructor'
_TEXT	ENDS
EXTRN	__imp_??0exception@std@@QAE@ABV01@@Z:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0logic_error@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$1
__ehfuncinfo$??0logic_error@std@@QAE@ABV01@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0logic_error@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0logic_error@std@@QAE@ABV01@@Z PROC			; std::logic_error::logic_error, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0logic_error@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7logic_error@std@@6B@
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 12					; 0000000cH
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$??0logic_error@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0logic_error@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0logic_error@std@@QAE@ABV01@@Z ENDP			; std::logic_error::logic_error
PUBLIC	??3@YAXPAX0@Z					; operator delete
PUBLIC	??0_Aux_cont@std@@QAE@QBV_Container_base_aux@1@@Z ; std::_Aux_cont::_Aux_cont
PUBLIC	??2@YAPAXIPAX@Z					; operator new
PUBLIC	?allocate@?$allocator@V_Aux_cont@std@@@std@@QAEPAV_Aux_cont@2@I@Z ; std::allocator<std::_Aux_cont>::allocate
PUBLIC	??$?0W4_D3DFORMAT@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@W4_D3DFORMAT@@@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><enum _D3DFORMAT>
PUBLIC	??0_Container_base_aux@std@@QAE@XZ		; std::_Container_base_aux::_Container_base_aux
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??0?$_Container_base_aux_alloc_real@V?$allocator@W4_D3DFORMAT@@@std@@@std@@IAE@V?$allocator@W4_D3DFORMAT@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@W4_D3DFORMAT@@@std@@@std@@IAE@V?$allocator@W4_D3DFORMAT@@@1@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@W4_D3DFORMAT@@@std@@@std@@IAE@V?$allocator@W4_D3DFORMAT@@@1@@Z$1
__ehfuncinfo$??0?$_Container_base_aux_alloc_real@V?$allocator@W4_D3DFORMAT@@@std@@@std@@IAE@V?$allocator@W4_D3DFORMAT@@@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0?$_Container_base_aux_alloc_real@V?$allocator@W4_D3DFORMAT@@@std@@@std@@IAE@V?$allocator@W4_D3DFORMAT@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Container_base_aux_alloc_real@V?$allocator@W4_D3DFORMAT@@@std@@@std@@IAE@V?$allocator@W4_D3DFORMAT@@@1@@Z
_TEXT	SEGMENT
tv133 = -32						; size = 4
_this$ = -28						; size = 4
$T142375 = -24						; size = 4
$T142374 = -20						; size = 4
$T142373 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 1
??0?$_Container_base_aux_alloc_real@V?$allocator@W4_D3DFORMAT@@@std@@@std@@IAE@V?$allocator@W4_D3DFORMAT@@@1@@Z PROC ; std::_Container_base_aux_alloc_real<std::allocator<enum _D3DFORMAT> >::_Container_base_aux_alloc_real<std::allocator<enum _D3DFORMAT> >, COMDAT
; _this$ = ecx

; 419  : 		{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Container_base_aux_alloc_real@V?$allocator@W4_D3DFORMAT@@@std@@@std@@IAE@V?$allocator@W4_D3DFORMAT@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 20					; 00000014H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::_Container_base_aux
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??$?0W4_D3DFORMAT@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@W4_D3DFORMAT@@@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><enum _D3DFORMAT>

; 420  : 		_Myownedaux = new (_Alaux.allocate(1)) _Aux_cont(this);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?allocate@?$allocator@V_Aux_cont@std@@@std@@QAEPAV_Aux_cont@2@I@Z ; std::allocator<std::_Aux_cont>::allocate
	mov	DWORD PTR $T142375[ebp], eax
	mov	ecx, DWORD PTR $T142375[ebp]
	push	ecx
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T142374[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	cmp	DWORD PTR $T142374[ebp], 0
	je	SHORT $LN3@Container_
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T142374[ebp]
	call	??0_Aux_cont@std@@QAE@QBV_Container_base_aux@1@@Z ; std::_Aux_cont::_Aux_cont
	mov	DWORD PTR tv133[ebp], eax
	jmp	SHORT $LN4@Container_
$LN3@Container_:
	mov	DWORD PTR tv133[ebp], 0
$LN4@Container_:
	mov	eax, DWORD PTR tv133[ebp]
	mov	DWORD PTR $T142373[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T142373[ebp]
	mov	DWORD PTR [ecx], edx

; 421  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@W4_D3DFORMAT@@@std@@@std@@IAE@V?$allocator@W4_D3DFORMAT@@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@W4_D3DFORMAT@@@std@@@std@@IAE@V?$allocator@W4_D3DFORMAT@@@1@@Z$1:
	mov	eax, DWORD PTR $T142375[ebp]
	push	eax
	mov	ecx, DWORD PTR $T142374[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??0?$_Container_base_aux_alloc_real@V?$allocator@W4_D3DFORMAT@@@std@@@std@@IAE@V?$allocator@W4_D3DFORMAT@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Container_base_aux_alloc_real@V?$allocator@W4_D3DFORMAT@@@std@@@std@@IAE@V?$allocator@W4_D3DFORMAT@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Container_base_aux_alloc_real@V?$allocator@W4_D3DFORMAT@@@std@@@std@@IAE@V?$allocator@W4_D3DFORMAT@@@1@@Z ENDP ; std::_Container_base_aux_alloc_real<std::allocator<enum _D3DFORMAT> >::_Container_base_aux_alloc_real<std::allocator<enum _D3DFORMAT> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\new
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 58   : 	{	// construct array with placement at _Where

	push	ebp
	mov	ebp, esp

; 59   : 	return (_Where);

	mov	eax, DWORD PTR __Where$[ebp]

; 60   : 	}

	pop	ebp
	ret	0
??2@YAPAXIPAX@Z ENDP					; operator new
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??3@YAXPAX0@Z PROC					; operator delete, COMDAT

; 63   : 	{	// delete if placement new fails

	push	ebp
	mov	ebp, esp

; 64   : 	}

	pop	ebp
	ret	0
??3@YAXPAX0@Z ENDP					; operator delete
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??0_Aux_cont@std@@QAE@QBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pcont$ = 8						; size = 4
??0_Aux_cont@std@@QAE@QBV_Container_base_aux@1@@Z PROC	; std::_Aux_cont::_Aux_cont, COMDAT
; _this$ = ecx

; 364  : 	explicit _Aux_cont(const _Container_base_aux * const _Pcont)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Pcont$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0_Aux_cont@std@@QAE@QBV_Container_base_aux@1@@Z ENDP	; std::_Aux_cont::_Aux_cont
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0_Container_base_aux@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_Container_base_aux@std@@QAE@XZ PROC			; std::_Container_base_aux::_Container_base_aux, COMDAT
; _this$ = ecx

; 379  : 	_Container_base_aux()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 380  : 		{
; 381  : 		// Do nothing: _Container_base_aux_alloc_real() will construct the aux object.
; 382  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0_Container_base_aux@std@@QAE@XZ ENDP			; std::_Container_base_aux::_Container_base_aux
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@W4_D3DFORMAT@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$allocator@W4_D3DFORMAT@@@std@@QAE@ABV01@@Z PROC	; std::allocator<enum _D3DFORMAT>::allocator<enum _D3DFORMAT>, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$allocator@W4_D3DFORMAT@@@std@@QAE@ABV01@@Z ENDP	; std::allocator<enum _D3DFORMAT>::allocator<enum _D3DFORMAT>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@W4_D3DFORMAT@@@std@@QAEXPAW4_D3DFORMAT@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@W4_D3DFORMAT@@@std@@QAEXPAW4_D3DFORMAT@@I@Z PROC ; std::allocator<enum _D3DFORMAT>::deallocate, COMDAT
; _this$ = ecx

; 139  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 141  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@W4_D3DFORMAT@@@std@@QAEXPAW4_D3DFORMAT@@I@Z ENDP ; std::allocator<enum _D3DFORMAT>::deallocate
_TEXT	ENDS
PUBLIC	??$_Allocate@W4_D3DFORMAT@@@std@@YAPAW4_D3DFORMAT@@IPAW41@@Z ; std::_Allocate<enum _D3DFORMAT>
; Function compile flags: /Odtp
;	COMDAT ?allocate@?$allocator@W4_D3DFORMAT@@@std@@QAEPAW4_D3DFORMAT@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@W4_D3DFORMAT@@@std@@QAEPAW4_D3DFORMAT@@I@Z PROC ; std::allocator<enum _D3DFORMAT>::allocate, COMDAT
; _this$ = ecx

; 144  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@W4_D3DFORMAT@@@std@@YAPAW4_D3DFORMAT@@IPAW41@@Z ; std::_Allocate<enum _D3DFORMAT>
	add	esp, 8

; 146  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@W4_D3DFORMAT@@@std@@QAEPAW4_D3DFORMAT@@I@Z ENDP ; std::allocator<enum _D3DFORMAT>::allocate
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@V_Aux_cont@std@@@std@@QAEXPAV_Aux_cont@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@V_Aux_cont@std@@@std@@QAEXPAV_Aux_cont@2@I@Z PROC ; std::allocator<std::_Aux_cont>::deallocate, COMDAT
; _this$ = ecx

; 139  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 141  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@V_Aux_cont@std@@@std@@QAEXPAV_Aux_cont@2@I@Z ENDP ; std::allocator<std::_Aux_cont>::deallocate
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?begin@?$vector@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@QAE?AV?$_Vector_iterator@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@QAE?AV?$_Vector_iterator@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@2@XZ PROC ; std::vector<enum _D3DMULTISAMPLE_TYPE,std::allocator<enum _D3DMULTISAMPLE_TYPE> >::begin, COMDAT
; _this$ = ecx

; 640  : 		{	// return iterator for beginning of mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 641  : 		return (iterator(_Myfirst, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@QAE@PAW4_D3DMULTISAMPLE_TYPE@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<enum _D3DMULTISAMPLE_TYPE,std::allocator<enum _D3DMULTISAMPLE_TYPE> >::_Vector_iterator<enum _D3DMULTISAMPLE_TYPE,std::allocator<enum _D3DMULTISAMPLE_TYPE> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 642  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?begin@?$vector@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@QAE?AV?$_Vector_iterator@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@2@XZ ENDP ; std::vector<enum _D3DMULTISAMPLE_TYPE,std::allocator<enum _D3DMULTISAMPLE_TYPE> >::begin
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@QBEIXZ ; std::allocator<enum _D3DMULTISAMPLE_TYPE>::max_size
; Function compile flags: /Odtp
;	COMDAT ?max_size@?$vector@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$vector@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@QBEIXZ PROC ; std::vector<enum _D3DMULTISAMPLE_TYPE,std::allocator<enum _D3DMULTISAMPLE_TYPE> >::max_size, COMDAT
; _this$ = ecx

; 730  : 		{	// return maximum possible length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 731  : 		return (this->_Alval.max_size());

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?max_size@?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@QBEIXZ ; std::allocator<enum _D3DMULTISAMPLE_TYPE>::max_size

; 732  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$vector@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@QBEIXZ ENDP ; std::vector<enum _D3DMULTISAMPLE_TYPE,std::allocator<enum _D3DMULTISAMPLE_TYPE> >::max_size
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@YAXPAW4_D3DMULTISAMPLE_TYPE@@0AAV?$allocator@W4_D3DMULTISAMPLE_TYPE@@@0@@Z ; std::_Destroy_range<std::allocator<enum _D3DMULTISAMPLE_TYPE> >
; Function compile flags: /Odtp
;	COMDAT ?_Destroy@?$vector@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@IAEXPAW4_D3DMULTISAMPLE_TYPE@@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@IAEXPAW4_D3DMULTISAMPLE_TYPE@@0@Z PROC ; std::vector<enum _D3DMULTISAMPLE_TYPE,std::allocator<enum _D3DMULTISAMPLE_TYPE> >::_Destroy, COMDAT
; _this$ = ecx

; 1118 : 		{	// destroy [_First, _Last) using allocator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Destroy_range@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@YAXPAW4_D3DMULTISAMPLE_TYPE@@0AAV?$allocator@W4_D3DMULTISAMPLE_TYPE@@@0@@Z ; std::_Destroy_range<std::allocator<enum _D3DMULTISAMPLE_TYPE> >
	add	esp, 12					; 0000000cH

; 1120 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?_Destroy@?$vector@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@IAEXPAW4_D3DMULTISAMPLE_TYPE@@0@Z ENDP ; std::vector<enum _D3DMULTISAMPLE_TYPE,std::allocator<enum _D3DMULTISAMPLE_TYPE> >::_Destroy
_TEXT	ENDS
PUBLIC	??$_Unchecked_move_backward@PAW4_D3DMULTISAMPLE_TYPE@@PAW41@@stdext@@YAPAW4_D3DMULTISAMPLE_TYPE@@PAW41@00@Z ; stdext::_Unchecked_move_backward<enum _D3DMULTISAMPLE_TYPE *,enum _D3DMULTISAMPLE_TYPE *>
PUBLIC	??$fill@PAW4_D3DMULTISAMPLE_TYPE@@W41@@std@@YAXPAW4_D3DMULTISAMPLE_TYPE@@0ABW41@@Z ; std::fill<enum _D3DMULTISAMPLE_TYPE *,enum _D3DMULTISAMPLE_TYPE>
PUBLIC	??$_Umove@PAW4_D3DMULTISAMPLE_TYPE@@@?$vector@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@IAEPAW4_D3DMULTISAMPLE_TYPE@@PAW42@00@Z ; std::vector<enum _D3DMULTISAMPLE_TYPE,std::allocator<enum _D3DMULTISAMPLE_TYPE> >::_Umove<enum _D3DMULTISAMPLE_TYPE *>
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Insert_n@?$vector@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@2@IABW4_D3DMULTISAMPLE_TYPE@@@Z$5 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@2@IABW4_D3DMULTISAMPLE_TYPE@@@Z$2
__catchsym$?_Insert_n@?$vector@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@2@IABW4_D3DMULTISAMPLE_TYPE@@@Z$4 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@2@IABW4_D3DMULTISAMPLE_TYPE@@@Z$0
__unwindtable$?_Insert_n@?$vector@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@2@IABW4_D3DMULTISAMPLE_TYPE@@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$?_Insert_n@?$vector@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@2@IABW4_D3DMULTISAMPLE_TYPE@@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Insert_n@?$vector@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@2@IABW4_D3DMULTISAMPLE_TYPE@@@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Insert_n@?$vector@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@2@IABW4_D3DMULTISAMPLE_TYPE@@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__tryblocktable$?_Insert_n@?$vector@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@2@IABW4_D3DMULTISAMPLE_TYPE@@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@2@IABW4_D3DMULTISAMPLE_TYPE@@@Z$4
	DD	02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@2@IABW4_D3DMULTISAMPLE_TYPE@@@Z$5
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?_Insert_n@?$vector@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@2@IABW4_D3DMULTISAMPLE_TYPE@@@Z
_TEXT	SEGMENT
tv84 = -52						; size = 4
_this$ = -48						; size = 4
__Tmp$133875 = -44					; size = 4
__Oldend$133876 = -40					; size = 4
__Tmp$133865 = -36					; size = 4
__Ncopied$133852 = -32					; size = 4
__Newvec$133850 = -28					; size = 4
__Whereoff$133851 = -24					; size = 4
__Capacity$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Where$ = 8						; size = 8
__Count$ = 16						; size = 4
__Val$ = 20						; size = 4
?_Insert_n@?$vector@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@2@IABW4_D3DMULTISAMPLE_TYPE@@@Z PROC ; std::vector<enum _D3DMULTISAMPLE_TYPE,std::allocator<enum _D3DMULTISAMPLE_TYPE> >::_Insert_n, COMDAT
; _this$ = ecx

; 1153 : 		{	// insert _Count * _Val at _Where

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Insert_n@?$vector@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@2@IABW4_D3DMULTISAMPLE_TYPE@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 36					; 00000024H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1154 : 
; 1155 :  #if _HAS_ITERATOR_DEBUGGING
; 1156 : 		if (_Where._Mycont != this
; 1157 : 			|| _Where._Myptr < _Myfirst || _Mylast < _Where._Myptr)
; 1158 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1159 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1160 : 
; 1161 : 		size_type _Capacity = capacity();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?capacity@?$vector@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@QBEIXZ ; std::vector<enum _D3DMULTISAMPLE_TYPE,std::allocator<enum _D3DMULTISAMPLE_TYPE> >::capacity
	mov	DWORD PTR __Capacity$[ebp], eax

; 1162 : 
; 1163 : 		if (_Count == 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN14@Insert_n@2
	jmp	$LN16@Insert_n@2
$LN14@Insert_n@2:

; 1164 : 			;
; 1165 : 		else if (max_size() - size() < _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@QBEIXZ ; std::vector<enum _D3DMULTISAMPLE_TYPE,std::allocator<enum _D3DMULTISAMPLE_TYPE> >::max_size
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@QBEIXZ ; std::vector<enum _D3DMULTISAMPLE_TYPE,std::allocator<enum _D3DMULTISAMPLE_TYPE> >::size
	sub	esi, eax
	cmp	esi, DWORD PTR __Count$[ebp]
	jae	SHORT $LN12@Insert_n@2

; 1166 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@KAXXZ ; std::vector<enum _D3DMULTISAMPLE_TYPE,std::allocator<enum _D3DMULTISAMPLE_TYPE> >::_Xlen
	jmp	$LN16@Insert_n@2
$LN12@Insert_n@2:

; 1167 : 		else if (_Capacity < size() + _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@QBEIXZ ; std::vector<enum _D3DMULTISAMPLE_TYPE,std::allocator<enum _D3DMULTISAMPLE_TYPE> >::size
	add	eax, DWORD PTR __Count$[ebp]
	cmp	DWORD PTR __Capacity$[ebp], eax
	jae	$LN10@Insert_n@2

; 1168 : 			{	// not enough room, reallocate
; 1169 : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1170 : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@QBEIXZ ; std::vector<enum _D3DMULTISAMPLE_TYPE,std::allocator<enum _D3DMULTISAMPLE_TYPE> >::max_size
	mov	ecx, DWORD PTR __Capacity$[ebp]
	shr	ecx, 1
	sub	eax, ecx
	cmp	eax, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN17@Insert_n@2
	mov	DWORD PTR tv84[ebp], 0
	jmp	SHORT $LN18@Insert_n@2
$LN17@Insert_n@2:
	mov	edx, DWORD PTR __Capacity$[ebp]
	shr	edx, 1
	add	edx, DWORD PTR __Capacity$[ebp]
	mov	DWORD PTR tv84[ebp], edx
$LN18@Insert_n@2:
	mov	eax, DWORD PTR tv84[ebp]
	mov	DWORD PTR __Capacity$[ebp], eax

; 1171 : 			if (_Capacity < size() + _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@QBEIXZ ; std::vector<enum _D3DMULTISAMPLE_TYPE,std::allocator<enum _D3DMULTISAMPLE_TYPE> >::size
	add	eax, DWORD PTR __Count$[ebp]
	cmp	DWORD PTR __Capacity$[ebp], eax
	jae	SHORT $LN9@Insert_n@2

; 1172 : 				_Capacity = size() + _Count;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@QBEIXZ ; std::vector<enum _D3DMULTISAMPLE_TYPE,std::allocator<enum _D3DMULTISAMPLE_TYPE> >::size
	add	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Capacity$[ebp], eax
$LN9@Insert_n@2:

; 1173 : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

	mov	ecx, DWORD PTR __Capacity$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?allocate@?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@QAEPAW4_D3DMULTISAMPLE_TYPE@@I@Z ; std::allocator<enum _D3DMULTISAMPLE_TYPE>::allocate
	mov	DWORD PTR __Newvec$133850[ebp], eax

; 1174 : 			size_type _Whereoff = _VEC_ITER_BASE(_Where) - _Myfirst;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Where$[ebp+4]
	sub	eax, DWORD PTR [edx+12]
	sar	eax, 2
	mov	DWORD PTR __Whereoff$133851[ebp], eax

; 1175 : 			int _Ncopied = 0;

	mov	DWORD PTR __Ncopied$133852[ebp], 0

; 1176 : 
; 1177 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1178 : 			_Ufill(_Newvec + _Whereoff, _Count, _Val);	// add new stuff

	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __Whereoff$133851[ebp]
	mov	ecx, DWORD PTR __Newvec$133850[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Ufill@?$vector@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@IAEPAW4_D3DMULTISAMPLE_TYPE@@PAW43@IABW43@@Z ; std::vector<enum _D3DMULTISAMPLE_TYPE,std::allocator<enum _D3DMULTISAMPLE_TYPE> >::_Ufill

; 1179 : 			++_Ncopied;

	mov	eax, DWORD PTR __Ncopied$133852[ebp]
	add	eax, 1
	mov	DWORD PTR __Ncopied$133852[ebp], eax

; 1180 : 			_Umove(this->_Myfirst, _VEC_ITER_BASE(_Where),
; 1181 : 				_Newvec);	// move prefix

	mov	ecx, DWORD PTR __Newvec$133850[ebp]
	push	ecx
	mov	edx, DWORD PTR __Where$[ebp+4]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Umove@PAW4_D3DMULTISAMPLE_TYPE@@@?$vector@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@IAEPAW4_D3DMULTISAMPLE_TYPE@@PAW42@00@Z ; std::vector<enum _D3DMULTISAMPLE_TYPE,std::allocator<enum _D3DMULTISAMPLE_TYPE> >::_Umove<enum _D3DMULTISAMPLE_TYPE *>

; 1182 : 			++_Ncopied;

	mov	edx, DWORD PTR __Ncopied$133852[ebp]
	add	edx, 1
	mov	DWORD PTR __Ncopied$133852[ebp], edx

; 1183 : 			_Umove(_VEC_ITER_BASE(_Where), this->_Mylast,
; 1184 : 				_Newvec + (_Whereoff + _Count));	// move suffix

	mov	eax, DWORD PTR __Whereoff$133851[ebp]
	add	eax, DWORD PTR __Count$[ebp]
	mov	ecx, DWORD PTR __Newvec$133850[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Where$[ebp+4]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Umove@PAW4_D3DMULTISAMPLE_TYPE@@@?$vector@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@IAEPAW4_D3DMULTISAMPLE_TYPE@@PAW42@00@Z ; std::vector<enum _D3DMULTISAMPLE_TYPE,std::allocator<enum _D3DMULTISAMPLE_TYPE> >::_Umove<enum _D3DMULTISAMPLE_TYPE *>
	jmp	SHORT $LN19@Insert_n@2
__catch$?_Insert_n@?$vector@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@2@IABW4_D3DMULTISAMPLE_TYPE@@@Z$0:

; 1185 : 			_CATCH_ALL
; 1186 : 			if (1 < _Ncopied)

	cmp	DWORD PTR __Ncopied$133852[ebp], 1
	jle	SHORT $LN7@Insert_n@2

; 1187 : 				_Destroy(_Newvec, _Newvec + _Whereoff);

	mov	eax, DWORD PTR __Whereoff$133851[ebp]
	mov	ecx, DWORD PTR __Newvec$133850[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	push	edx
	mov	eax, DWORD PTR __Newvec$133850[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@IAEXPAW4_D3DMULTISAMPLE_TYPE@@0@Z ; std::vector<enum _D3DMULTISAMPLE_TYPE,std::allocator<enum _D3DMULTISAMPLE_TYPE> >::_Destroy
$LN7@Insert_n@2:

; 1188 : 			if (0 < _Ncopied)

	cmp	DWORD PTR __Ncopied$133852[ebp], 0
	jle	SHORT $LN6@Insert_n@2

; 1189 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);

	mov	ecx, DWORD PTR __Whereoff$133851[ebp]
	mov	edx, DWORD PTR __Newvec$133850[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR __Count$[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]
	push	edx
	mov	eax, DWORD PTR __Whereoff$133851[ebp]
	mov	ecx, DWORD PTR __Newvec$133850[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@IAEXPAW4_D3DMULTISAMPLE_TYPE@@0@Z ; std::vector<enum _D3DMULTISAMPLE_TYPE,std::allocator<enum _D3DMULTISAMPLE_TYPE> >::_Destroy
$LN6@Insert_n@2:

; 1190 : 			this->_Alval.deallocate(_Newvec, _Capacity);

	mov	eax, DWORD PTR __Capacity$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Newvec$133850[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?deallocate@?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@QAEXPAW4_D3DMULTISAMPLE_TYPE@@I@Z ; std::allocator<enum _D3DMULTISAMPLE_TYPE>::deallocate

; 1191 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1192 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$?_Insert_n@?$vector@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@2@IABW4_D3DMULTISAMPLE_TYPE@@@Z$1
	ret	0
$LN19@Insert_n@2:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Insert_n@?$vector@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@2@IABW4_D3DMULTISAMPLE_TYPE@@@Z$1:

; 1193 : 
; 1194 : 			_Count += size();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@QBEIXZ ; std::vector<enum _D3DMULTISAMPLE_TYPE,std::allocator<enum _D3DMULTISAMPLE_TYPE> >::size
	add	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Count$[ebp], eax

; 1195 : 			if (_Myfirst != 0)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+12], 0
	je	SHORT $LN5@Insert_n@2

; 1196 : 				{	// destroy and deallocate old array
; 1197 : 				_Destroy(_Myfirst, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@IAEXPAW4_D3DMULTISAMPLE_TYPE@@0@Z ; std::vector<enum _D3DMULTISAMPLE_TYPE,std::allocator<enum _D3DMULTISAMPLE_TYPE> >::_Destroy

; 1198 : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+20]
	sub	eax, DWORD PTR [edx+12]
	sar	eax, 2
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?deallocate@?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@QAEXPAW4_D3DMULTISAMPLE_TYPE@@I@Z ; std::allocator<enum _D3DMULTISAMPLE_TYPE>::deallocate
$LN5@Insert_n@2:

; 1199 : 				}
; 1200 : 
; 1201 :  #if _HAS_ITERATOR_DEBUGGING
; 1202 : 			this->_Orphan_all();
; 1203 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1204 : 
; 1205 : 			_Myend = _Newvec + _Capacity;

	mov	eax, DWORD PTR __Capacity$[ebp]
	mov	ecx, DWORD PTR __Newvec$133850[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], edx

; 1206 : 			_Mylast = _Newvec + _Count;

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Newvec$133850[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 1207 : 			_Myfirst = _Newvec;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Newvec$133850[ebp]
	mov	DWORD PTR [edx+12], eax
	jmp	$LN16@Insert_n@2
$LN10@Insert_n@2:

; 1208 : 			}
; 1209 : 		else if ((size_type)(_Mylast - _VEC_ITER_BASE(_Where)) < _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	sub	edx, DWORD PTR __Where$[ebp+4]
	sar	edx, 2
	cmp	edx, DWORD PTR __Count$[ebp]
	jae	$LN3@Insert_n@2

; 1210 : 			{	// new stuff spills off end
; 1211 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Tmp$133865[ebp], ecx

; 1212 : 
; 1213 : 			_Umove(_VEC_ITER_BASE(_Where), _Mylast,
; 1214 : 				_VEC_ITER_BASE(_Where) + _Count);	// copy suffix

	mov	edx, DWORD PTR __Count$[ebp]
	mov	eax, DWORD PTR __Where$[ebp+4]
	lea	ecx, DWORD PTR [eax+edx*4]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp+4]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Umove@PAW4_D3DMULTISAMPLE_TYPE@@@?$vector@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@IAEPAW4_D3DMULTISAMPLE_TYPE@@PAW42@00@Z ; std::vector<enum _D3DMULTISAMPLE_TYPE,std::allocator<enum _D3DMULTISAMPLE_TYPE> >::_Umove<enum _D3DMULTISAMPLE_TYPE *>

; 1215 : 
; 1216 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 2

; 1217 : 			_Ufill(_Mylast, _Count - (_Mylast - _VEC_ITER_BASE(_Where)),
; 1218 : 				_Tmp);	// insert new stuff off end

	lea	edx, DWORD PTR __Tmp$133865[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	sub	ecx, DWORD PTR __Where$[ebp+4]
	sar	ecx, 2
	mov	edx, DWORD PTR __Count$[ebp]
	sub	edx, ecx
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Ufill@?$vector@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@IAEPAW4_D3DMULTISAMPLE_TYPE@@PAW43@IABW43@@Z ; std::vector<enum _D3DMULTISAMPLE_TYPE,std::allocator<enum _D3DMULTISAMPLE_TYPE> >::_Ufill
	jmp	SHORT $LN21@Insert_n@2
__catch$?_Insert_n@?$vector@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@2@IABW4_D3DMULTISAMPLE_TYPE@@@Z$2:

; 1219 : 			_CATCH_ALL
; 1220 : 			_Destroy(_VEC_ITER_BASE(_Where) + _Count, _Mylast + _Count);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR __Count$[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	mov	ecx, DWORD PTR __Where$[ebp+4]
	lea	edx, DWORD PTR [ecx+eax*4]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@IAEXPAW4_D3DMULTISAMPLE_TYPE@@0@Z ; std::vector<enum _D3DMULTISAMPLE_TYPE,std::allocator<enum _D3DMULTISAMPLE_TYPE> >::_Destroy

; 1221 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1222 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$?_Insert_n@?$vector@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@2@IABW4_D3DMULTISAMPLE_TYPE@@@Z$3
	ret	0
$LN21@Insert_n@2:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Insert_n@?$vector@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@2@IABW4_D3DMULTISAMPLE_TYPE@@@Z$3:

; 1223 : 
; 1224 : 			_Mylast += _Count;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR __Count$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 1225 : 
; 1226 :  #if _HAS_ITERATOR_DEBUGGING
; 1227 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1228 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1229 : 
; 1230 : 			std::fill(_VEC_ITER_BASE(_Where), _Mylast - _Count,
; 1231 : 				_Tmp);	// insert up to old end

	lea	edx, DWORD PTR __Tmp$133865[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 2
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	sub	edx, eax
	push	edx
	mov	eax, DWORD PTR __Where$[ebp+4]
	push	eax
	call	??$fill@PAW4_D3DMULTISAMPLE_TYPE@@W41@@std@@YAXPAW4_D3DMULTISAMPLE_TYPE@@0ABW41@@Z ; std::fill<enum _D3DMULTISAMPLE_TYPE *,enum _D3DMULTISAMPLE_TYPE>
	add	esp, 12					; 0000000cH

; 1232 : 			}
; 1233 : 		else

	jmp	SHORT $LN16@Insert_n@2
$LN3@Insert_n@2:

; 1234 : 			{	// new stuff can all be assigned
; 1235 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	ecx, DWORD PTR __Val$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR __Tmp$133875[ebp], edx

; 1236 : 
; 1237 : 			pointer _Oldend = _Mylast;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR __Oldend$133876[ebp], ecx

; 1238 : 			_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1239 : 				_Mylast);	// copy suffix

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR __Oldend$133876[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count$[ebp]
	shl	edx, 2
	mov	eax, DWORD PTR __Oldend$133876[ebp]
	sub	eax, edx
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Umove@PAW4_D3DMULTISAMPLE_TYPE@@@?$vector@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@IAEPAW4_D3DMULTISAMPLE_TYPE@@PAW42@00@Z ; std::vector<enum _D3DMULTISAMPLE_TYPE,std::allocator<enum _D3DMULTISAMPLE_TYPE> >::_Umove<enum _D3DMULTISAMPLE_TYPE *>
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 1240 : 
; 1241 :  #if _HAS_ITERATOR_DEBUGGING
; 1242 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1243 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1244 : 
; 1245 : 			_STDEXT _Unchecked_move_backward(_VEC_ITER_BASE(_Where), _Oldend - _Count,
; 1246 : 				_Oldend);	// copy hole

	mov	edx, DWORD PTR __Oldend$133876[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 2
	mov	ecx, DWORD PTR __Oldend$133876[ebp]
	sub	ecx, eax
	push	ecx
	mov	edx, DWORD PTR __Where$[ebp+4]
	push	edx
	call	??$_Unchecked_move_backward@PAW4_D3DMULTISAMPLE_TYPE@@PAW41@@stdext@@YAPAW4_D3DMULTISAMPLE_TYPE@@PAW41@00@Z ; stdext::_Unchecked_move_backward<enum _D3DMULTISAMPLE_TYPE *,enum _D3DMULTISAMPLE_TYPE *>
	add	esp, 12					; 0000000cH

; 1247 : 			std::fill(_VEC_ITER_BASE(_Where), _VEC_ITER_BASE(_Where) + _Count,
; 1248 : 				_Tmp);	// insert into hole

	lea	eax, DWORD PTR __Tmp$133875[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Where$[ebp+4]
	lea	eax, DWORD PTR [edx+ecx*4]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp+4]
	push	ecx
	call	??$fill@PAW4_D3DMULTISAMPLE_TYPE@@W41@@std@@YAXPAW4_D3DMULTISAMPLE_TYPE@@0ABW41@@Z ; std::fill<enum _D3DMULTISAMPLE_TYPE *,enum _D3DMULTISAMPLE_TYPE>
	add	esp, 12					; 0000000cH
$LN16@Insert_n@2:

; 1249 : 			}
; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Insert_n@?$vector@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@2@IABW4_D3DMULTISAMPLE_TYPE@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-56]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Insert_n@?$vector@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@2@IABW4_D3DMULTISAMPLE_TYPE@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Insert_n@?$vector@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@2@IABW4_D3DMULTISAMPLE_TYPE@@@Z ENDP ; std::vector<enum _D3DMULTISAMPLE_TYPE,std::allocator<enum _D3DMULTISAMPLE_TYPE> >::_Insert_n
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@KAXXZ$0
__ehfuncinfo$?_Xlen@?$vector@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@KAXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T142434 = -80						; size = 28
$T142433 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@KAXXZ PROC ; std::vector<enum _D3DMULTISAMPLE_TYPE,std::allocator<enum _D3DMULTISAMPLE_TYPE> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Xlen@?$vector@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T142434[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR $T142434[ebp]
	push	eax
	lea	ecx, DWORD PTR $T142433[ebp]
	call	??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::length_error::length_error
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T142433[ebp]
	push	ecx
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T142434[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN2@Xlen@2:

; 1261 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T142434[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?_Xlen@?$vector@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@KAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@KAXXZ ENDP ; std::vector<enum _D3DMULTISAMPLE_TYPE,std::allocator<enum _D3DMULTISAMPLE_TYPE> >::_Xlen
PUBLIC	??$?0W4_D3DMULTISAMPLE_TYPE@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@W4_D3DMULTISAMPLE_TYPE@@@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><enum _D3DMULTISAMPLE_TYPE>
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??0?$_Container_base_aux_alloc_real@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@IAE@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@IAE@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@1@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@IAE@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@1@@Z$1
__ehfuncinfo$??0?$_Container_base_aux_alloc_real@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@IAE@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0?$_Container_base_aux_alloc_real@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@IAE@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Container_base_aux_alloc_real@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@IAE@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@1@@Z
_TEXT	SEGMENT
tv133 = -32						; size = 4
_this$ = -28						; size = 4
$T142446 = -24						; size = 4
$T142445 = -20						; size = 4
$T142444 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 1
??0?$_Container_base_aux_alloc_real@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@IAE@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@1@@Z PROC ; std::_Container_base_aux_alloc_real<std::allocator<enum _D3DMULTISAMPLE_TYPE> >::_Container_base_aux_alloc_real<std::allocator<enum _D3DMULTISAMPLE_TYPE> >, COMDAT
; _this$ = ecx

; 419  : 		{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Container_base_aux_alloc_real@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@IAE@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 20					; 00000014H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::_Container_base_aux
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??$?0W4_D3DMULTISAMPLE_TYPE@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@W4_D3DMULTISAMPLE_TYPE@@@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><enum _D3DMULTISAMPLE_TYPE>

; 420  : 		_Myownedaux = new (_Alaux.allocate(1)) _Aux_cont(this);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?allocate@?$allocator@V_Aux_cont@std@@@std@@QAEPAV_Aux_cont@2@I@Z ; std::allocator<std::_Aux_cont>::allocate
	mov	DWORD PTR $T142446[ebp], eax
	mov	ecx, DWORD PTR $T142446[ebp]
	push	ecx
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T142445[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	cmp	DWORD PTR $T142445[ebp], 0
	je	SHORT $LN3@Container_@2
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T142445[ebp]
	call	??0_Aux_cont@std@@QAE@QBV_Container_base_aux@1@@Z ; std::_Aux_cont::_Aux_cont
	mov	DWORD PTR tv133[ebp], eax
	jmp	SHORT $LN4@Container_@2
$LN3@Container_@2:
	mov	DWORD PTR tv133[ebp], 0
$LN4@Container_@2:
	mov	eax, DWORD PTR tv133[ebp]
	mov	DWORD PTR $T142444[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T142444[ebp]
	mov	DWORD PTR [ecx], edx

; 421  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@IAE@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@IAE@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@1@@Z$1:
	mov	eax, DWORD PTR $T142446[ebp]
	push	eax
	mov	ecx, DWORD PTR $T142445[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??0?$_Container_base_aux_alloc_real@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@IAE@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Container_base_aux_alloc_real@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@IAE@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Container_base_aux_alloc_real@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@IAE@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@1@@Z ENDP ; std::_Container_base_aux_alloc_real<std::allocator<enum _D3DMULTISAMPLE_TYPE> >::_Container_base_aux_alloc_real<std::allocator<enum _D3DMULTISAMPLE_TYPE> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@QAE@ABV01@@Z PROC ; std::allocator<enum _D3DMULTISAMPLE_TYPE>::allocator<enum _D3DMULTISAMPLE_TYPE>, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<enum _D3DMULTISAMPLE_TYPE>::allocator<enum _D3DMULTISAMPLE_TYPE>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@QAEXPAW4_D3DMULTISAMPLE_TYPE@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@QAEXPAW4_D3DMULTISAMPLE_TYPE@@I@Z PROC ; std::allocator<enum _D3DMULTISAMPLE_TYPE>::deallocate, COMDAT
; _this$ = ecx

; 139  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 141  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@QAEXPAW4_D3DMULTISAMPLE_TYPE@@I@Z ENDP ; std::allocator<enum _D3DMULTISAMPLE_TYPE>::deallocate
_TEXT	ENDS
PUBLIC	??$_Allocate@W4_D3DMULTISAMPLE_TYPE@@@std@@YAPAW4_D3DMULTISAMPLE_TYPE@@IPAW41@@Z ; std::_Allocate<enum _D3DMULTISAMPLE_TYPE>
; Function compile flags: /Odtp
;	COMDAT ?allocate@?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@QAEPAW4_D3DMULTISAMPLE_TYPE@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@QAEPAW4_D3DMULTISAMPLE_TYPE@@I@Z PROC ; std::allocator<enum _D3DMULTISAMPLE_TYPE>::allocate, COMDAT
; _this$ = ecx

; 144  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@W4_D3DMULTISAMPLE_TYPE@@@std@@YAPAW4_D3DMULTISAMPLE_TYPE@@IPAW41@@Z ; std::_Allocate<enum _D3DMULTISAMPLE_TYPE>
	add	esp, 8

; 146  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@QAEPAW4_D3DMULTISAMPLE_TYPE@@I@Z ENDP ; std::allocator<enum _D3DMULTISAMPLE_TYPE>::allocate
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?begin@?$vector@IV?$allocator@I@std@@@std@@QAE?AV?$_Vector_iterator@IV?$allocator@I@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@IV?$allocator@I@std@@@std@@QAE?AV?$_Vector_iterator@IV?$allocator@I@std@@@2@XZ PROC ; std::vector<unsigned int,std::allocator<unsigned int> >::begin, COMDAT
; _this$ = ecx

; 640  : 		{	// return iterator for beginning of mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 641  : 		return (iterator(_Myfirst, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@IV?$allocator@I@std@@@std@@QAE@PAIPBV_Container_base_aux@1@@Z ; std::_Vector_iterator<unsigned int,std::allocator<unsigned int> >::_Vector_iterator<unsigned int,std::allocator<unsigned int> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 642  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?begin@?$vector@IV?$allocator@I@std@@@std@@QAE?AV?$_Vector_iterator@IV?$allocator@I@std@@@2@XZ ENDP ; std::vector<unsigned int,std::allocator<unsigned int> >::begin
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@I@std@@QBEIXZ		; std::allocator<unsigned int>::max_size
; Function compile flags: /Odtp
;	COMDAT ?max_size@?$vector@IV?$allocator@I@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$vector@IV?$allocator@I@std@@@std@@QBEIXZ PROC ; std::vector<unsigned int,std::allocator<unsigned int> >::max_size, COMDAT
; _this$ = ecx

; 730  : 		{	// return maximum possible length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 731  : 		return (this->_Alval.max_size());

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?max_size@?$allocator@I@std@@QBEIXZ	; std::allocator<unsigned int>::max_size

; 732  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$vector@IV?$allocator@I@std@@@std@@QBEIXZ ENDP ; std::vector<unsigned int,std::allocator<unsigned int> >::max_size
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@I@std@@@std@@YAXPAI0AAV?$allocator@I@0@@Z ; std::_Destroy_range<std::allocator<unsigned int> >
; Function compile flags: /Odtp
;	COMDAT ?_Destroy@?$vector@IV?$allocator@I@std@@@std@@IAEXPAI0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@IV?$allocator@I@std@@@std@@IAEXPAI0@Z PROC ; std::vector<unsigned int,std::allocator<unsigned int> >::_Destroy, COMDAT
; _this$ = ecx

; 1118 : 		{	// destroy [_First, _Last) using allocator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Destroy_range@V?$allocator@I@std@@@std@@YAXPAI0AAV?$allocator@I@0@@Z ; std::_Destroy_range<std::allocator<unsigned int> >
	add	esp, 12					; 0000000cH

; 1120 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?_Destroy@?$vector@IV?$allocator@I@std@@@std@@IAEXPAI0@Z ENDP ; std::vector<unsigned int,std::allocator<unsigned int> >::_Destroy
_TEXT	ENDS
PUBLIC	??$_Unchecked_move_backward@PAIPAI@stdext@@YAPAIPAI00@Z ; stdext::_Unchecked_move_backward<unsigned int *,unsigned int *>
PUBLIC	??$fill@PAII@std@@YAXPAI0ABI@Z			; std::fill<unsigned int *,unsigned int>
PUBLIC	??$_Umove@PAI@?$vector@IV?$allocator@I@std@@@std@@IAEPAIPAI00@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Umove<unsigned int *>
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Insert_n@?$vector@IV?$allocator@I@std@@@std@@IAEXV?$_Vector_const_iterator@IV?$allocator@I@std@@@2@IABI@Z$5 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@IV?$allocator@I@std@@@std@@IAEXV?$_Vector_const_iterator@IV?$allocator@I@std@@@2@IABI@Z$2
__catchsym$?_Insert_n@?$vector@IV?$allocator@I@std@@@std@@IAEXV?$_Vector_const_iterator@IV?$allocator@I@std@@@2@IABI@Z$4 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@IV?$allocator@I@std@@@std@@IAEXV?$_Vector_const_iterator@IV?$allocator@I@std@@@2@IABI@Z$0
__unwindtable$?_Insert_n@?$vector@IV?$allocator@I@std@@@std@@IAEXV?$_Vector_const_iterator@IV?$allocator@I@std@@@2@IABI@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$?_Insert_n@?$vector@IV?$allocator@I@std@@@std@@IAEXV?$_Vector_const_iterator@IV?$allocator@I@std@@@2@IABI@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Insert_n@?$vector@IV?$allocator@I@std@@@std@@IAEXV?$_Vector_const_iterator@IV?$allocator@I@std@@@2@IABI@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Insert_n@?$vector@IV?$allocator@I@std@@@std@@IAEXV?$_Vector_const_iterator@IV?$allocator@I@std@@@2@IABI@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__tryblocktable$?_Insert_n@?$vector@IV?$allocator@I@std@@@std@@IAEXV?$_Vector_const_iterator@IV?$allocator@I@std@@@2@IABI@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@IV?$allocator@I@std@@@std@@IAEXV?$_Vector_const_iterator@IV?$allocator@I@std@@@2@IABI@Z$4
	DD	02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@IV?$allocator@I@std@@@std@@IAEXV?$_Vector_const_iterator@IV?$allocator@I@std@@@2@IABI@Z$5
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?_Insert_n@?$vector@IV?$allocator@I@std@@@std@@IAEXV?$_Vector_const_iterator@IV?$allocator@I@std@@@2@IABI@Z
_TEXT	SEGMENT
tv84 = -52						; size = 4
_this$ = -48						; size = 4
__Tmp$133961 = -44					; size = 4
__Oldend$133962 = -40					; size = 4
__Tmp$133951 = -36					; size = 4
__Ncopied$133938 = -32					; size = 4
__Newvec$133936 = -28					; size = 4
__Whereoff$133937 = -24					; size = 4
__Capacity$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Where$ = 8						; size = 8
__Count$ = 16						; size = 4
__Val$ = 20						; size = 4
?_Insert_n@?$vector@IV?$allocator@I@std@@@std@@IAEXV?$_Vector_const_iterator@IV?$allocator@I@std@@@2@IABI@Z PROC ; std::vector<unsigned int,std::allocator<unsigned int> >::_Insert_n, COMDAT
; _this$ = ecx

; 1153 : 		{	// insert _Count * _Val at _Where

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Insert_n@?$vector@IV?$allocator@I@std@@@std@@IAEXV?$_Vector_const_iterator@IV?$allocator@I@std@@@2@IABI@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 36					; 00000024H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1154 : 
; 1155 :  #if _HAS_ITERATOR_DEBUGGING
; 1156 : 		if (_Where._Mycont != this
; 1157 : 			|| _Where._Myptr < _Myfirst || _Mylast < _Where._Myptr)
; 1158 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1159 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1160 : 
; 1161 : 		size_type _Capacity = capacity();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?capacity@?$vector@IV?$allocator@I@std@@@std@@QBEIXZ ; std::vector<unsigned int,std::allocator<unsigned int> >::capacity
	mov	DWORD PTR __Capacity$[ebp], eax

; 1162 : 
; 1163 : 		if (_Count == 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN14@Insert_n@3
	jmp	$LN16@Insert_n@3
$LN14@Insert_n@3:

; 1164 : 			;
; 1165 : 		else if (max_size() - size() < _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@IV?$allocator@I@std@@@std@@QBEIXZ ; std::vector<unsigned int,std::allocator<unsigned int> >::max_size
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@IV?$allocator@I@std@@@std@@QBEIXZ ; std::vector<unsigned int,std::allocator<unsigned int> >::size
	sub	esi, eax
	cmp	esi, DWORD PTR __Count$[ebp]
	jae	SHORT $LN12@Insert_n@3

; 1166 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@IV?$allocator@I@std@@@std@@KAXXZ ; std::vector<unsigned int,std::allocator<unsigned int> >::_Xlen
	jmp	$LN16@Insert_n@3
$LN12@Insert_n@3:

; 1167 : 		else if (_Capacity < size() + _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@IV?$allocator@I@std@@@std@@QBEIXZ ; std::vector<unsigned int,std::allocator<unsigned int> >::size
	add	eax, DWORD PTR __Count$[ebp]
	cmp	DWORD PTR __Capacity$[ebp], eax
	jae	$LN10@Insert_n@3

; 1168 : 			{	// not enough room, reallocate
; 1169 : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1170 : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@IV?$allocator@I@std@@@std@@QBEIXZ ; std::vector<unsigned int,std::allocator<unsigned int> >::max_size
	mov	ecx, DWORD PTR __Capacity$[ebp]
	shr	ecx, 1
	sub	eax, ecx
	cmp	eax, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN17@Insert_n@3
	mov	DWORD PTR tv84[ebp], 0
	jmp	SHORT $LN18@Insert_n@3
$LN17@Insert_n@3:
	mov	edx, DWORD PTR __Capacity$[ebp]
	shr	edx, 1
	add	edx, DWORD PTR __Capacity$[ebp]
	mov	DWORD PTR tv84[ebp], edx
$LN18@Insert_n@3:
	mov	eax, DWORD PTR tv84[ebp]
	mov	DWORD PTR __Capacity$[ebp], eax

; 1171 : 			if (_Capacity < size() + _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@IV?$allocator@I@std@@@std@@QBEIXZ ; std::vector<unsigned int,std::allocator<unsigned int> >::size
	add	eax, DWORD PTR __Count$[ebp]
	cmp	DWORD PTR __Capacity$[ebp], eax
	jae	SHORT $LN9@Insert_n@3

; 1172 : 				_Capacity = size() + _Count;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@IV?$allocator@I@std@@@std@@QBEIXZ ; std::vector<unsigned int,std::allocator<unsigned int> >::size
	add	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Capacity$[ebp], eax
$LN9@Insert_n@3:

; 1173 : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

	mov	ecx, DWORD PTR __Capacity$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?allocate@?$allocator@I@std@@QAEPAII@Z	; std::allocator<unsigned int>::allocate
	mov	DWORD PTR __Newvec$133936[ebp], eax

; 1174 : 			size_type _Whereoff = _VEC_ITER_BASE(_Where) - _Myfirst;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Where$[ebp+4]
	sub	eax, DWORD PTR [edx+12]
	sar	eax, 2
	mov	DWORD PTR __Whereoff$133937[ebp], eax

; 1175 : 			int _Ncopied = 0;

	mov	DWORD PTR __Ncopied$133938[ebp], 0

; 1176 : 
; 1177 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1178 : 			_Ufill(_Newvec + _Whereoff, _Count, _Val);	// add new stuff

	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __Whereoff$133937[ebp]
	mov	ecx, DWORD PTR __Newvec$133936[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Ufill@?$vector@IV?$allocator@I@std@@@std@@IAEPAIPAIIABI@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Ufill

; 1179 : 			++_Ncopied;

	mov	eax, DWORD PTR __Ncopied$133938[ebp]
	add	eax, 1
	mov	DWORD PTR __Ncopied$133938[ebp], eax

; 1180 : 			_Umove(this->_Myfirst, _VEC_ITER_BASE(_Where),
; 1181 : 				_Newvec);	// move prefix

	mov	ecx, DWORD PTR __Newvec$133936[ebp]
	push	ecx
	mov	edx, DWORD PTR __Where$[ebp+4]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Umove@PAI@?$vector@IV?$allocator@I@std@@@std@@IAEPAIPAI00@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Umove<unsigned int *>

; 1182 : 			++_Ncopied;

	mov	edx, DWORD PTR __Ncopied$133938[ebp]
	add	edx, 1
	mov	DWORD PTR __Ncopied$133938[ebp], edx

; 1183 : 			_Umove(_VEC_ITER_BASE(_Where), this->_Mylast,
; 1184 : 				_Newvec + (_Whereoff + _Count));	// move suffix

	mov	eax, DWORD PTR __Whereoff$133937[ebp]
	add	eax, DWORD PTR __Count$[ebp]
	mov	ecx, DWORD PTR __Newvec$133936[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Where$[ebp+4]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Umove@PAI@?$vector@IV?$allocator@I@std@@@std@@IAEPAIPAI00@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Umove<unsigned int *>
	jmp	SHORT $LN19@Insert_n@3
__catch$?_Insert_n@?$vector@IV?$allocator@I@std@@@std@@IAEXV?$_Vector_const_iterator@IV?$allocator@I@std@@@2@IABI@Z$0:

; 1185 : 			_CATCH_ALL
; 1186 : 			if (1 < _Ncopied)

	cmp	DWORD PTR __Ncopied$133938[ebp], 1
	jle	SHORT $LN7@Insert_n@3

; 1187 : 				_Destroy(_Newvec, _Newvec + _Whereoff);

	mov	eax, DWORD PTR __Whereoff$133937[ebp]
	mov	ecx, DWORD PTR __Newvec$133936[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	push	edx
	mov	eax, DWORD PTR __Newvec$133936[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@IV?$allocator@I@std@@@std@@IAEXPAI0@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Destroy
$LN7@Insert_n@3:

; 1188 : 			if (0 < _Ncopied)

	cmp	DWORD PTR __Ncopied$133938[ebp], 0
	jle	SHORT $LN6@Insert_n@3

; 1189 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);

	mov	ecx, DWORD PTR __Whereoff$133937[ebp]
	mov	edx, DWORD PTR __Newvec$133936[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR __Count$[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]
	push	edx
	mov	eax, DWORD PTR __Whereoff$133937[ebp]
	mov	ecx, DWORD PTR __Newvec$133936[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@IV?$allocator@I@std@@@std@@IAEXPAI0@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Destroy
$LN6@Insert_n@3:

; 1190 : 			this->_Alval.deallocate(_Newvec, _Capacity);

	mov	eax, DWORD PTR __Capacity$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Newvec$133936[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?deallocate@?$allocator@I@std@@QAEXPAII@Z ; std::allocator<unsigned int>::deallocate

; 1191 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1192 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$?_Insert_n@?$vector@IV?$allocator@I@std@@@std@@IAEXV?$_Vector_const_iterator@IV?$allocator@I@std@@@2@IABI@Z$1
	ret	0
$LN19@Insert_n@3:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Insert_n@?$vector@IV?$allocator@I@std@@@std@@IAEXV?$_Vector_const_iterator@IV?$allocator@I@std@@@2@IABI@Z$1:

; 1193 : 
; 1194 : 			_Count += size();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@IV?$allocator@I@std@@@std@@QBEIXZ ; std::vector<unsigned int,std::allocator<unsigned int> >::size
	add	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Count$[ebp], eax

; 1195 : 			if (_Myfirst != 0)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+12], 0
	je	SHORT $LN5@Insert_n@3

; 1196 : 				{	// destroy and deallocate old array
; 1197 : 				_Destroy(_Myfirst, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@IV?$allocator@I@std@@@std@@IAEXPAI0@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Destroy

; 1198 : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+20]
	sub	eax, DWORD PTR [edx+12]
	sar	eax, 2
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?deallocate@?$allocator@I@std@@QAEXPAII@Z ; std::allocator<unsigned int>::deallocate
$LN5@Insert_n@3:

; 1199 : 				}
; 1200 : 
; 1201 :  #if _HAS_ITERATOR_DEBUGGING
; 1202 : 			this->_Orphan_all();
; 1203 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1204 : 
; 1205 : 			_Myend = _Newvec + _Capacity;

	mov	eax, DWORD PTR __Capacity$[ebp]
	mov	ecx, DWORD PTR __Newvec$133936[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], edx

; 1206 : 			_Mylast = _Newvec + _Count;

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Newvec$133936[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 1207 : 			_Myfirst = _Newvec;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Newvec$133936[ebp]
	mov	DWORD PTR [edx+12], eax
	jmp	$LN16@Insert_n@3
$LN10@Insert_n@3:

; 1208 : 			}
; 1209 : 		else if ((size_type)(_Mylast - _VEC_ITER_BASE(_Where)) < _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	sub	edx, DWORD PTR __Where$[ebp+4]
	sar	edx, 2
	cmp	edx, DWORD PTR __Count$[ebp]
	jae	$LN3@Insert_n@3

; 1210 : 			{	// new stuff spills off end
; 1211 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Tmp$133951[ebp], ecx

; 1212 : 
; 1213 : 			_Umove(_VEC_ITER_BASE(_Where), _Mylast,
; 1214 : 				_VEC_ITER_BASE(_Where) + _Count);	// copy suffix

	mov	edx, DWORD PTR __Count$[ebp]
	mov	eax, DWORD PTR __Where$[ebp+4]
	lea	ecx, DWORD PTR [eax+edx*4]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp+4]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Umove@PAI@?$vector@IV?$allocator@I@std@@@std@@IAEPAIPAI00@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Umove<unsigned int *>

; 1215 : 
; 1216 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 2

; 1217 : 			_Ufill(_Mylast, _Count - (_Mylast - _VEC_ITER_BASE(_Where)),
; 1218 : 				_Tmp);	// insert new stuff off end

	lea	edx, DWORD PTR __Tmp$133951[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	sub	ecx, DWORD PTR __Where$[ebp+4]
	sar	ecx, 2
	mov	edx, DWORD PTR __Count$[ebp]
	sub	edx, ecx
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Ufill@?$vector@IV?$allocator@I@std@@@std@@IAEPAIPAIIABI@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Ufill
	jmp	SHORT $LN21@Insert_n@3
__catch$?_Insert_n@?$vector@IV?$allocator@I@std@@@std@@IAEXV?$_Vector_const_iterator@IV?$allocator@I@std@@@2@IABI@Z$2:

; 1219 : 			_CATCH_ALL
; 1220 : 			_Destroy(_VEC_ITER_BASE(_Where) + _Count, _Mylast + _Count);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR __Count$[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	mov	ecx, DWORD PTR __Where$[ebp+4]
	lea	edx, DWORD PTR [ecx+eax*4]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@IV?$allocator@I@std@@@std@@IAEXPAI0@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Destroy

; 1221 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1222 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$?_Insert_n@?$vector@IV?$allocator@I@std@@@std@@IAEXV?$_Vector_const_iterator@IV?$allocator@I@std@@@2@IABI@Z$3
	ret	0
$LN21@Insert_n@3:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Insert_n@?$vector@IV?$allocator@I@std@@@std@@IAEXV?$_Vector_const_iterator@IV?$allocator@I@std@@@2@IABI@Z$3:

; 1223 : 
; 1224 : 			_Mylast += _Count;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR __Count$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 1225 : 
; 1226 :  #if _HAS_ITERATOR_DEBUGGING
; 1227 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1228 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1229 : 
; 1230 : 			std::fill(_VEC_ITER_BASE(_Where), _Mylast - _Count,
; 1231 : 				_Tmp);	// insert up to old end

	lea	edx, DWORD PTR __Tmp$133951[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 2
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	sub	edx, eax
	push	edx
	mov	eax, DWORD PTR __Where$[ebp+4]
	push	eax
	call	??$fill@PAII@std@@YAXPAI0ABI@Z		; std::fill<unsigned int *,unsigned int>
	add	esp, 12					; 0000000cH

; 1232 : 			}
; 1233 : 		else

	jmp	SHORT $LN16@Insert_n@3
$LN3@Insert_n@3:

; 1234 : 			{	// new stuff can all be assigned
; 1235 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	ecx, DWORD PTR __Val$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR __Tmp$133961[ebp], edx

; 1236 : 
; 1237 : 			pointer _Oldend = _Mylast;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR __Oldend$133962[ebp], ecx

; 1238 : 			_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1239 : 				_Mylast);	// copy suffix

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR __Oldend$133962[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count$[ebp]
	shl	edx, 2
	mov	eax, DWORD PTR __Oldend$133962[ebp]
	sub	eax, edx
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Umove@PAI@?$vector@IV?$allocator@I@std@@@std@@IAEPAIPAI00@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Umove<unsigned int *>
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 1240 : 
; 1241 :  #if _HAS_ITERATOR_DEBUGGING
; 1242 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1243 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1244 : 
; 1245 : 			_STDEXT _Unchecked_move_backward(_VEC_ITER_BASE(_Where), _Oldend - _Count,
; 1246 : 				_Oldend);	// copy hole

	mov	edx, DWORD PTR __Oldend$133962[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 2
	mov	ecx, DWORD PTR __Oldend$133962[ebp]
	sub	ecx, eax
	push	ecx
	mov	edx, DWORD PTR __Where$[ebp+4]
	push	edx
	call	??$_Unchecked_move_backward@PAIPAI@stdext@@YAPAIPAI00@Z ; stdext::_Unchecked_move_backward<unsigned int *,unsigned int *>
	add	esp, 12					; 0000000cH

; 1247 : 			std::fill(_VEC_ITER_BASE(_Where), _VEC_ITER_BASE(_Where) + _Count,
; 1248 : 				_Tmp);	// insert into hole

	lea	eax, DWORD PTR __Tmp$133961[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Where$[ebp+4]
	lea	eax, DWORD PTR [edx+ecx*4]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp+4]
	push	ecx
	call	??$fill@PAII@std@@YAXPAI0ABI@Z		; std::fill<unsigned int *,unsigned int>
	add	esp, 12					; 0000000cH
$LN16@Insert_n@3:

; 1249 : 			}
; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Insert_n@?$vector@IV?$allocator@I@std@@@std@@IAEXV?$_Vector_const_iterator@IV?$allocator@I@std@@@2@IABI@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-56]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Insert_n@?$vector@IV?$allocator@I@std@@@std@@IAEXV?$_Vector_const_iterator@IV?$allocator@I@std@@@2@IABI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Insert_n@?$vector@IV?$allocator@I@std@@@std@@IAEXV?$_Vector_const_iterator@IV?$allocator@I@std@@@2@IABI@Z ENDP ; std::vector<unsigned int,std::allocator<unsigned int> >::_Insert_n
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@IV?$allocator@I@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@IV?$allocator@I@std@@@std@@KAXXZ$0
__ehfuncinfo$?_Xlen@?$vector@IV?$allocator@I@std@@@std@@KAXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@IV?$allocator@I@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@IV?$allocator@I@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T142495 = -80						; size = 28
$T142494 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@IV?$allocator@I@std@@@std@@KAXXZ PROC	; std::vector<unsigned int,std::allocator<unsigned int> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Xlen@?$vector@IV?$allocator@I@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T142495[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR $T142495[ebp]
	push	eax
	lea	ecx, DWORD PTR $T142494[ebp]
	call	??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::length_error::length_error
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T142494[ebp]
	push	ecx
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T142495[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN2@Xlen@3:

; 1261 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@IV?$allocator@I@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T142495[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?_Xlen@?$vector@IV?$allocator@I@std@@@std@@KAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@IV?$allocator@I@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@IV?$allocator@I@std@@@std@@KAXXZ ENDP	; std::vector<unsigned int,std::allocator<unsigned int> >::_Xlen
PUBLIC	??$?0I@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@I@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><unsigned int>
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??0?$_Container_base_aux_alloc_real@V?$allocator@I@std@@@std@@IAE@V?$allocator@I@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@I@std@@@std@@IAE@V?$allocator@I@1@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@I@std@@@std@@IAE@V?$allocator@I@1@@Z$1
__ehfuncinfo$??0?$_Container_base_aux_alloc_real@V?$allocator@I@std@@@std@@IAE@V?$allocator@I@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0?$_Container_base_aux_alloc_real@V?$allocator@I@std@@@std@@IAE@V?$allocator@I@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Container_base_aux_alloc_real@V?$allocator@I@std@@@std@@IAE@V?$allocator@I@1@@Z
_TEXT	SEGMENT
tv133 = -32						; size = 4
_this$ = -28						; size = 4
$T142507 = -24						; size = 4
$T142506 = -20						; size = 4
$T142505 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 1
??0?$_Container_base_aux_alloc_real@V?$allocator@I@std@@@std@@IAE@V?$allocator@I@1@@Z PROC ; std::_Container_base_aux_alloc_real<std::allocator<unsigned int> >::_Container_base_aux_alloc_real<std::allocator<unsigned int> >, COMDAT
; _this$ = ecx

; 419  : 		{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Container_base_aux_alloc_real@V?$allocator@I@std@@@std@@IAE@V?$allocator@I@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 20					; 00000014H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::_Container_base_aux
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??$?0I@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@I@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><unsigned int>

; 420  : 		_Myownedaux = new (_Alaux.allocate(1)) _Aux_cont(this);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?allocate@?$allocator@V_Aux_cont@std@@@std@@QAEPAV_Aux_cont@2@I@Z ; std::allocator<std::_Aux_cont>::allocate
	mov	DWORD PTR $T142507[ebp], eax
	mov	ecx, DWORD PTR $T142507[ebp]
	push	ecx
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T142506[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	cmp	DWORD PTR $T142506[ebp], 0
	je	SHORT $LN3@Container_@3
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T142506[ebp]
	call	??0_Aux_cont@std@@QAE@QBV_Container_base_aux@1@@Z ; std::_Aux_cont::_Aux_cont
	mov	DWORD PTR tv133[ebp], eax
	jmp	SHORT $LN4@Container_@3
$LN3@Container_@3:
	mov	DWORD PTR tv133[ebp], 0
$LN4@Container_@3:
	mov	eax, DWORD PTR tv133[ebp]
	mov	DWORD PTR $T142505[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T142505[ebp]
	mov	DWORD PTR [ecx], edx

; 421  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@I@std@@@std@@IAE@V?$allocator@I@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@I@std@@@std@@IAE@V?$allocator@I@1@@Z$1:
	mov	eax, DWORD PTR $T142507[ebp]
	push	eax
	mov	ecx, DWORD PTR $T142506[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??0?$_Container_base_aux_alloc_real@V?$allocator@I@std@@@std@@IAE@V?$allocator@I@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Container_base_aux_alloc_real@V?$allocator@I@std@@@std@@IAE@V?$allocator@I@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Container_base_aux_alloc_real@V?$allocator@I@std@@@std@@IAE@V?$allocator@I@1@@Z ENDP ; std::_Container_base_aux_alloc_real<std::allocator<unsigned int> >::_Container_base_aux_alloc_real<std::allocator<unsigned int> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@I@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$allocator@I@std@@QAE@ABV01@@Z PROC			; std::allocator<unsigned int>::allocator<unsigned int>, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$allocator@I@std@@QAE@ABV01@@Z ENDP			; std::allocator<unsigned int>::allocator<unsigned int>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@I@std@@QAEXPAII@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@I@std@@QAEXPAII@Z PROC		; std::allocator<unsigned int>::deallocate, COMDAT
; _this$ = ecx

; 139  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 141  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@I@std@@QAEXPAII@Z ENDP		; std::allocator<unsigned int>::deallocate
_TEXT	ENDS
PUBLIC	??$_Allocate@I@std@@YAPAIIPAI@Z			; std::_Allocate<unsigned int>
; Function compile flags: /Odtp
;	COMDAT ?allocate@?$allocator@I@std@@QAEPAII@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@I@std@@QAEPAII@Z PROC		; std::allocator<unsigned int>::allocate, COMDAT
; _this$ = ecx

; 144  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@I@std@@YAPAIIPAI@Z		; std::_Allocate<unsigned int>
	add	esp, 8

; 146  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@I@std@@QAEPAII@Z ENDP		; std::allocator<unsigned int>::allocate
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?begin@?$vector@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@2@XZ PROC ; std::vector<Ogre::D3DSMSCONFLICT_T,std::allocator<Ogre::D3DSMSCONFLICT_T> >::begin, COMDAT
; _this$ = ecx

; 640  : 		{	// return iterator for beginning of mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 641  : 		return (iterator(_Myfirst, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@QAE@PAUD3DSMSCONFLICT_T@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::D3DSMSCONFLICT_T,std::allocator<Ogre::D3DSMSCONFLICT_T> >::_Vector_iterator<Ogre::D3DSMSCONFLICT_T,std::allocator<Ogre::D3DSMSCONFLICT_T> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 642  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?begin@?$vector@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@2@XZ ENDP ; std::vector<Ogre::D3DSMSCONFLICT_T,std::allocator<Ogre::D3DSMSCONFLICT_T> >::begin
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@QBEIXZ ; std::allocator<Ogre::D3DSMSCONFLICT_T>::max_size
; Function compile flags: /Odtp
;	COMDAT ?max_size@?$vector@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$vector@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@QBEIXZ PROC ; std::vector<Ogre::D3DSMSCONFLICT_T,std::allocator<Ogre::D3DSMSCONFLICT_T> >::max_size, COMDAT
; _this$ = ecx

; 730  : 		{	// return maximum possible length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 731  : 		return (this->_Alval.max_size());

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?max_size@?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@QBEIXZ ; std::allocator<Ogre::D3DSMSCONFLICT_T>::max_size

; 732  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$vector@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@QBEIXZ ENDP ; std::vector<Ogre::D3DSMSCONFLICT_T,std::allocator<Ogre::D3DSMSCONFLICT_T> >::max_size
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@YAXPAUD3DSMSCONFLICT_T@Ogre@@0AAV?$allocator@UD3DSMSCONFLICT_T@Ogre@@@0@@Z ; std::_Destroy_range<std::allocator<Ogre::D3DSMSCONFLICT_T> >
; Function compile flags: /Odtp
;	COMDAT ?_Destroy@?$vector@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@IAEXPAUD3DSMSCONFLICT_T@Ogre@@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@IAEXPAUD3DSMSCONFLICT_T@Ogre@@0@Z PROC ; std::vector<Ogre::D3DSMSCONFLICT_T,std::allocator<Ogre::D3DSMSCONFLICT_T> >::_Destroy, COMDAT
; _this$ = ecx

; 1118 : 		{	// destroy [_First, _Last) using allocator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Destroy_range@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@YAXPAUD3DSMSCONFLICT_T@Ogre@@0AAV?$allocator@UD3DSMSCONFLICT_T@Ogre@@@0@@Z ; std::_Destroy_range<std::allocator<Ogre::D3DSMSCONFLICT_T> >
	add	esp, 12					; 0000000cH

; 1120 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?_Destroy@?$vector@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@IAEXPAUD3DSMSCONFLICT_T@Ogre@@0@Z ENDP ; std::vector<Ogre::D3DSMSCONFLICT_T,std::allocator<Ogre::D3DSMSCONFLICT_T> >::_Destroy
_TEXT	ENDS
PUBLIC	??$_Unchecked_move_backward@PAUD3DSMSCONFLICT_T@Ogre@@PAU12@@stdext@@YAPAUD3DSMSCONFLICT_T@Ogre@@PAU12@00@Z ; stdext::_Unchecked_move_backward<Ogre::D3DSMSCONFLICT_T *,Ogre::D3DSMSCONFLICT_T *>
PUBLIC	??$fill@PAUD3DSMSCONFLICT_T@Ogre@@U12@@std@@YAXPAUD3DSMSCONFLICT_T@Ogre@@0ABU12@@Z ; std::fill<Ogre::D3DSMSCONFLICT_T *,Ogre::D3DSMSCONFLICT_T>
PUBLIC	??$_Umove@PAUD3DSMSCONFLICT_T@Ogre@@@?$vector@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@IAEPAUD3DSMSCONFLICT_T@Ogre@@PAU23@00@Z ; std::vector<Ogre::D3DSMSCONFLICT_T,std::allocator<Ogre::D3DSMSCONFLICT_T> >::_Umove<Ogre::D3DSMSCONFLICT_T *>
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Insert_n@?$vector@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@2@IABUD3DSMSCONFLICT_T@Ogre@@@Z$5 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@2@IABUD3DSMSCONFLICT_T@Ogre@@@Z$2
__catchsym$?_Insert_n@?$vector@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@2@IABUD3DSMSCONFLICT_T@Ogre@@@Z$4 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@2@IABUD3DSMSCONFLICT_T@Ogre@@@Z$0
__unwindtable$?_Insert_n@?$vector@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@2@IABUD3DSMSCONFLICT_T@Ogre@@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$?_Insert_n@?$vector@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@2@IABUD3DSMSCONFLICT_T@Ogre@@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Insert_n@?$vector@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@2@IABUD3DSMSCONFLICT_T@Ogre@@@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Insert_n@?$vector@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@2@IABUD3DSMSCONFLICT_T@Ogre@@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__tryblocktable$?_Insert_n@?$vector@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@2@IABUD3DSMSCONFLICT_T@Ogre@@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@2@IABUD3DSMSCONFLICT_T@Ogre@@@Z$4
	DD	02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@2@IABUD3DSMSCONFLICT_T@Ogre@@@Z$5
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?_Insert_n@?$vector@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@2@IABUD3DSMSCONFLICT_T@Ogre@@@Z
_TEXT	SEGMENT
tv84 = -60						; size = 4
_this$ = -56						; size = 4
__Tmp$134047 = -52					; size = 8
__Oldend$134048 = -44					; size = 4
__Tmp$134037 = -40					; size = 8
__Ncopied$134024 = -32					; size = 4
__Newvec$134022 = -28					; size = 4
__Whereoff$134023 = -24					; size = 4
__Capacity$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Where$ = 8						; size = 8
__Count$ = 16						; size = 4
__Val$ = 20						; size = 4
?_Insert_n@?$vector@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@2@IABUD3DSMSCONFLICT_T@Ogre@@@Z PROC ; std::vector<Ogre::D3DSMSCONFLICT_T,std::allocator<Ogre::D3DSMSCONFLICT_T> >::_Insert_n, COMDAT
; _this$ = ecx

; 1153 : 		{	// insert _Count * _Val at _Where

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Insert_n@?$vector@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@2@IABUD3DSMSCONFLICT_T@Ogre@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 44					; 0000002cH
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1154 : 
; 1155 :  #if _HAS_ITERATOR_DEBUGGING
; 1156 : 		if (_Where._Mycont != this
; 1157 : 			|| _Where._Myptr < _Myfirst || _Mylast < _Where._Myptr)
; 1158 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1159 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1160 : 
; 1161 : 		size_type _Capacity = capacity();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?capacity@?$vector@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::D3DSMSCONFLICT_T,std::allocator<Ogre::D3DSMSCONFLICT_T> >::capacity
	mov	DWORD PTR __Capacity$[ebp], eax

; 1162 : 
; 1163 : 		if (_Count == 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN14@Insert_n@4
	jmp	$LN16@Insert_n@4
$LN14@Insert_n@4:

; 1164 : 			;
; 1165 : 		else if (max_size() - size() < _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::D3DSMSCONFLICT_T,std::allocator<Ogre::D3DSMSCONFLICT_T> >::max_size
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::D3DSMSCONFLICT_T,std::allocator<Ogre::D3DSMSCONFLICT_T> >::size
	sub	esi, eax
	cmp	esi, DWORD PTR __Count$[ebp]
	jae	SHORT $LN12@Insert_n@4

; 1166 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@KAXXZ ; std::vector<Ogre::D3DSMSCONFLICT_T,std::allocator<Ogre::D3DSMSCONFLICT_T> >::_Xlen
	jmp	$LN16@Insert_n@4
$LN12@Insert_n@4:

; 1167 : 		else if (_Capacity < size() + _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::D3DSMSCONFLICT_T,std::allocator<Ogre::D3DSMSCONFLICT_T> >::size
	add	eax, DWORD PTR __Count$[ebp]
	cmp	DWORD PTR __Capacity$[ebp], eax
	jae	$LN10@Insert_n@4

; 1168 : 			{	// not enough room, reallocate
; 1169 : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1170 : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::D3DSMSCONFLICT_T,std::allocator<Ogre::D3DSMSCONFLICT_T> >::max_size
	mov	ecx, DWORD PTR __Capacity$[ebp]
	shr	ecx, 1
	sub	eax, ecx
	cmp	eax, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN17@Insert_n@4
	mov	DWORD PTR tv84[ebp], 0
	jmp	SHORT $LN18@Insert_n@4
$LN17@Insert_n@4:
	mov	edx, DWORD PTR __Capacity$[ebp]
	shr	edx, 1
	add	edx, DWORD PTR __Capacity$[ebp]
	mov	DWORD PTR tv84[ebp], edx
$LN18@Insert_n@4:
	mov	eax, DWORD PTR tv84[ebp]
	mov	DWORD PTR __Capacity$[ebp], eax

; 1171 : 			if (_Capacity < size() + _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::D3DSMSCONFLICT_T,std::allocator<Ogre::D3DSMSCONFLICT_T> >::size
	add	eax, DWORD PTR __Count$[ebp]
	cmp	DWORD PTR __Capacity$[ebp], eax
	jae	SHORT $LN9@Insert_n@4

; 1172 : 				_Capacity = size() + _Count;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::D3DSMSCONFLICT_T,std::allocator<Ogre::D3DSMSCONFLICT_T> >::size
	add	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Capacity$[ebp], eax
$LN9@Insert_n@4:

; 1173 : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

	mov	ecx, DWORD PTR __Capacity$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?allocate@?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@QAEPAUD3DSMSCONFLICT_T@Ogre@@I@Z ; std::allocator<Ogre::D3DSMSCONFLICT_T>::allocate
	mov	DWORD PTR __Newvec$134022[ebp], eax

; 1174 : 			size_type _Whereoff = _VEC_ITER_BASE(_Where) - _Myfirst;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Where$[ebp+4]
	sub	eax, DWORD PTR [edx+12]
	sar	eax, 3
	mov	DWORD PTR __Whereoff$134023[ebp], eax

; 1175 : 			int _Ncopied = 0;

	mov	DWORD PTR __Ncopied$134024[ebp], 0

; 1176 : 
; 1177 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1178 : 			_Ufill(_Newvec + _Whereoff, _Count, _Val);	// add new stuff

	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __Whereoff$134023[ebp]
	mov	ecx, DWORD PTR __Newvec$134022[ebp]
	lea	edx, DWORD PTR [ecx+eax*8]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Ufill@?$vector@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@IAEPAUD3DSMSCONFLICT_T@Ogre@@PAU34@IABU34@@Z ; std::vector<Ogre::D3DSMSCONFLICT_T,std::allocator<Ogre::D3DSMSCONFLICT_T> >::_Ufill

; 1179 : 			++_Ncopied;

	mov	eax, DWORD PTR __Ncopied$134024[ebp]
	add	eax, 1
	mov	DWORD PTR __Ncopied$134024[ebp], eax

; 1180 : 			_Umove(this->_Myfirst, _VEC_ITER_BASE(_Where),
; 1181 : 				_Newvec);	// move prefix

	mov	ecx, DWORD PTR __Newvec$134022[ebp]
	push	ecx
	mov	edx, DWORD PTR __Where$[ebp+4]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Umove@PAUD3DSMSCONFLICT_T@Ogre@@@?$vector@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@IAEPAUD3DSMSCONFLICT_T@Ogre@@PAU23@00@Z ; std::vector<Ogre::D3DSMSCONFLICT_T,std::allocator<Ogre::D3DSMSCONFLICT_T> >::_Umove<Ogre::D3DSMSCONFLICT_T *>

; 1182 : 			++_Ncopied;

	mov	edx, DWORD PTR __Ncopied$134024[ebp]
	add	edx, 1
	mov	DWORD PTR __Ncopied$134024[ebp], edx

; 1183 : 			_Umove(_VEC_ITER_BASE(_Where), this->_Mylast,
; 1184 : 				_Newvec + (_Whereoff + _Count));	// move suffix

	mov	eax, DWORD PTR __Whereoff$134023[ebp]
	add	eax, DWORD PTR __Count$[ebp]
	mov	ecx, DWORD PTR __Newvec$134022[ebp]
	lea	edx, DWORD PTR [ecx+eax*8]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Where$[ebp+4]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Umove@PAUD3DSMSCONFLICT_T@Ogre@@@?$vector@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@IAEPAUD3DSMSCONFLICT_T@Ogre@@PAU23@00@Z ; std::vector<Ogre::D3DSMSCONFLICT_T,std::allocator<Ogre::D3DSMSCONFLICT_T> >::_Umove<Ogre::D3DSMSCONFLICT_T *>
	jmp	SHORT $LN19@Insert_n@4
__catch$?_Insert_n@?$vector@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@2@IABUD3DSMSCONFLICT_T@Ogre@@@Z$0:

; 1185 : 			_CATCH_ALL
; 1186 : 			if (1 < _Ncopied)

	cmp	DWORD PTR __Ncopied$134024[ebp], 1
	jle	SHORT $LN7@Insert_n@4

; 1187 : 				_Destroy(_Newvec, _Newvec + _Whereoff);

	mov	eax, DWORD PTR __Whereoff$134023[ebp]
	mov	ecx, DWORD PTR __Newvec$134022[ebp]
	lea	edx, DWORD PTR [ecx+eax*8]
	push	edx
	mov	eax, DWORD PTR __Newvec$134022[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@IAEXPAUD3DSMSCONFLICT_T@Ogre@@0@Z ; std::vector<Ogre::D3DSMSCONFLICT_T,std::allocator<Ogre::D3DSMSCONFLICT_T> >::_Destroy
$LN7@Insert_n@4:

; 1188 : 			if (0 < _Ncopied)

	cmp	DWORD PTR __Ncopied$134024[ebp], 0
	jle	SHORT $LN6@Insert_n@4

; 1189 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);

	mov	ecx, DWORD PTR __Whereoff$134023[ebp]
	mov	edx, DWORD PTR __Newvec$134022[ebp]
	lea	eax, DWORD PTR [edx+ecx*8]
	mov	ecx, DWORD PTR __Count$[ebp]
	lea	edx, DWORD PTR [eax+ecx*8]
	push	edx
	mov	eax, DWORD PTR __Whereoff$134023[ebp]
	mov	ecx, DWORD PTR __Newvec$134022[ebp]
	lea	edx, DWORD PTR [ecx+eax*8]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@IAEXPAUD3DSMSCONFLICT_T@Ogre@@0@Z ; std::vector<Ogre::D3DSMSCONFLICT_T,std::allocator<Ogre::D3DSMSCONFLICT_T> >::_Destroy
$LN6@Insert_n@4:

; 1190 : 			this->_Alval.deallocate(_Newvec, _Capacity);

	mov	eax, DWORD PTR __Capacity$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Newvec$134022[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?deallocate@?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@QAEXPAUD3DSMSCONFLICT_T@Ogre@@I@Z ; std::allocator<Ogre::D3DSMSCONFLICT_T>::deallocate

; 1191 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1192 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$?_Insert_n@?$vector@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@2@IABUD3DSMSCONFLICT_T@Ogre@@@Z$1
	ret	0
$LN19@Insert_n@4:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Insert_n@?$vector@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@2@IABUD3DSMSCONFLICT_T@Ogre@@@Z$1:

; 1193 : 
; 1194 : 			_Count += size();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::D3DSMSCONFLICT_T,std::allocator<Ogre::D3DSMSCONFLICT_T> >::size
	add	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Count$[ebp], eax

; 1195 : 			if (_Myfirst != 0)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+12], 0
	je	SHORT $LN5@Insert_n@4

; 1196 : 				{	// destroy and deallocate old array
; 1197 : 				_Destroy(_Myfirst, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@IAEXPAUD3DSMSCONFLICT_T@Ogre@@0@Z ; std::vector<Ogre::D3DSMSCONFLICT_T,std::allocator<Ogre::D3DSMSCONFLICT_T> >::_Destroy

; 1198 : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+20]
	sub	eax, DWORD PTR [edx+12]
	sar	eax, 3
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?deallocate@?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@QAEXPAUD3DSMSCONFLICT_T@Ogre@@I@Z ; std::allocator<Ogre::D3DSMSCONFLICT_T>::deallocate
$LN5@Insert_n@4:

; 1199 : 				}
; 1200 : 
; 1201 :  #if _HAS_ITERATOR_DEBUGGING
; 1202 : 			this->_Orphan_all();
; 1203 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1204 : 
; 1205 : 			_Myend = _Newvec + _Capacity;

	mov	eax, DWORD PTR __Capacity$[ebp]
	mov	ecx, DWORD PTR __Newvec$134022[ebp]
	lea	edx, DWORD PTR [ecx+eax*8]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], edx

; 1206 : 			_Mylast = _Newvec + _Count;

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Newvec$134022[ebp]
	lea	eax, DWORD PTR [edx+ecx*8]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 1207 : 			_Myfirst = _Newvec;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Newvec$134022[ebp]
	mov	DWORD PTR [edx+12], eax
	jmp	$LN16@Insert_n@4
$LN10@Insert_n@4:

; 1208 : 			}
; 1209 : 		else if ((size_type)(_Mylast - _VEC_ITER_BASE(_Where)) < _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	sub	edx, DWORD PTR __Where$[ebp+4]
	sar	edx, 3
	cmp	edx, DWORD PTR __Count$[ebp]
	jae	$LN3@Insert_n@4

; 1210 : 			{	// new stuff spills off end
; 1211 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR __Tmp$134037[ebp], ecx
	mov	DWORD PTR __Tmp$134037[ebp+4], edx

; 1212 : 
; 1213 : 			_Umove(_VEC_ITER_BASE(_Where), _Mylast,
; 1214 : 				_VEC_ITER_BASE(_Where) + _Count);	// copy suffix

	mov	eax, DWORD PTR __Count$[ebp]
	mov	ecx, DWORD PTR __Where$[ebp+4]
	lea	edx, DWORD PTR [ecx+eax*8]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Where$[ebp+4]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Umove@PAUD3DSMSCONFLICT_T@Ogre@@@?$vector@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@IAEPAUD3DSMSCONFLICT_T@Ogre@@PAU23@00@Z ; std::vector<Ogre::D3DSMSCONFLICT_T,std::allocator<Ogre::D3DSMSCONFLICT_T> >::_Umove<Ogre::D3DSMSCONFLICT_T *>

; 1215 : 
; 1216 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 2

; 1217 : 			_Ufill(_Mylast, _Count - (_Mylast - _VEC_ITER_BASE(_Where)),
; 1218 : 				_Tmp);	// insert new stuff off end

	lea	eax, DWORD PTR __Tmp$134037[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	sub	edx, DWORD PTR __Where$[ebp+4]
	sar	edx, 3
	mov	eax, DWORD PTR __Count$[ebp]
	sub	eax, edx
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Ufill@?$vector@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@IAEPAUD3DSMSCONFLICT_T@Ogre@@PAU34@IABU34@@Z ; std::vector<Ogre::D3DSMSCONFLICT_T,std::allocator<Ogre::D3DSMSCONFLICT_T> >::_Ufill
	jmp	SHORT $LN21@Insert_n@4
__catch$?_Insert_n@?$vector@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@2@IABUD3DSMSCONFLICT_T@Ogre@@@Z$2:

; 1219 : 			_CATCH_ALL
; 1220 : 			_Destroy(_VEC_ITER_BASE(_Where) + _Count, _Mylast + _Count);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR __Count$[ebp]
	lea	eax, DWORD PTR [ecx+edx*8]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Where$[ebp+4]
	lea	eax, DWORD PTR [edx+ecx*8]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@IAEXPAUD3DSMSCONFLICT_T@Ogre@@0@Z ; std::vector<Ogre::D3DSMSCONFLICT_T,std::allocator<Ogre::D3DSMSCONFLICT_T> >::_Destroy

; 1221 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1222 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$?_Insert_n@?$vector@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@2@IABUD3DSMSCONFLICT_T@Ogre@@@Z$3
	ret	0
$LN21@Insert_n@4:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Insert_n@?$vector@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@2@IABUD3DSMSCONFLICT_T@Ogre@@@Z$3:

; 1223 : 
; 1224 : 			_Mylast += _Count;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR __Count$[ebp]
	lea	ecx, DWORD PTR [edx+eax*8]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+16], ecx

; 1225 : 
; 1226 :  #if _HAS_ITERATOR_DEBUGGING
; 1227 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1228 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1229 : 
; 1230 : 			std::fill(_VEC_ITER_BASE(_Where), _Mylast - _Count,
; 1231 : 				_Tmp);	// insert up to old end

	lea	eax, DWORD PTR __Tmp$134037[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 3
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	sub	eax, ecx
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp+4]
	push	ecx
	call	??$fill@PAUD3DSMSCONFLICT_T@Ogre@@U12@@std@@YAXPAUD3DSMSCONFLICT_T@Ogre@@0ABU12@@Z ; std::fill<Ogre::D3DSMSCONFLICT_T *,Ogre::D3DSMSCONFLICT_T>
	add	esp, 12					; 0000000cH

; 1232 : 			}
; 1233 : 		else

	jmp	SHORT $LN16@Insert_n@4
$LN3@Insert_n@4:

; 1234 : 			{	// new stuff can all be assigned
; 1235 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	edx, DWORD PTR __Val$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR __Tmp$134047[ebp], eax
	mov	DWORD PTR __Tmp$134047[ebp+4], ecx

; 1236 : 
; 1237 : 			pointer _Oldend = _Mylast;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR __Oldend$134048[ebp], eax

; 1238 : 			_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1239 : 				_Mylast);	// copy suffix

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR __Oldend$134048[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 3
	mov	edx, DWORD PTR __Oldend$134048[ebp]
	sub	edx, ecx
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Umove@PAUD3DSMSCONFLICT_T@Ogre@@@?$vector@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@IAEPAUD3DSMSCONFLICT_T@Ogre@@PAU23@00@Z ; std::vector<Ogre::D3DSMSCONFLICT_T,std::allocator<Ogre::D3DSMSCONFLICT_T> >::_Umove<Ogre::D3DSMSCONFLICT_T *>
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 1240 : 
; 1241 :  #if _HAS_ITERATOR_DEBUGGING
; 1242 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1243 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1244 : 
; 1245 : 			_STDEXT _Unchecked_move_backward(_VEC_ITER_BASE(_Where), _Oldend - _Count,
; 1246 : 				_Oldend);	// copy hole

	mov	edx, DWORD PTR __Oldend$134048[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 3
	mov	ecx, DWORD PTR __Oldend$134048[ebp]
	sub	ecx, eax
	push	ecx
	mov	edx, DWORD PTR __Where$[ebp+4]
	push	edx
	call	??$_Unchecked_move_backward@PAUD3DSMSCONFLICT_T@Ogre@@PAU12@@stdext@@YAPAUD3DSMSCONFLICT_T@Ogre@@PAU12@00@Z ; stdext::_Unchecked_move_backward<Ogre::D3DSMSCONFLICT_T *,Ogre::D3DSMSCONFLICT_T *>
	add	esp, 12					; 0000000cH

; 1247 : 			std::fill(_VEC_ITER_BASE(_Where), _VEC_ITER_BASE(_Where) + _Count,
; 1248 : 				_Tmp);	// insert into hole

	lea	eax, DWORD PTR __Tmp$134047[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Where$[ebp+4]
	lea	eax, DWORD PTR [edx+ecx*8]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp+4]
	push	ecx
	call	??$fill@PAUD3DSMSCONFLICT_T@Ogre@@U12@@std@@YAXPAUD3DSMSCONFLICT_T@Ogre@@0ABU12@@Z ; std::fill<Ogre::D3DSMSCONFLICT_T *,Ogre::D3DSMSCONFLICT_T>
	add	esp, 12					; 0000000cH
$LN16@Insert_n@4:

; 1249 : 			}
; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Insert_n@?$vector@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@2@IABUD3DSMSCONFLICT_T@Ogre@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-64]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Insert_n@?$vector@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@2@IABUD3DSMSCONFLICT_T@Ogre@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Insert_n@?$vector@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@2@IABUD3DSMSCONFLICT_T@Ogre@@@Z ENDP ; std::vector<Ogre::D3DSMSCONFLICT_T,std::allocator<Ogre::D3DSMSCONFLICT_T> >::_Insert_n
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@KAXXZ$0
__ehfuncinfo$?_Xlen@?$vector@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@KAXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T142556 = -80						; size = 28
$T142555 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@KAXXZ PROC ; std::vector<Ogre::D3DSMSCONFLICT_T,std::allocator<Ogre::D3DSMSCONFLICT_T> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Xlen@?$vector@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T142556[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR $T142556[ebp]
	push	eax
	lea	ecx, DWORD PTR $T142555[ebp]
	call	??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::length_error::length_error
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T142555[ebp]
	push	ecx
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T142556[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN2@Xlen@4:

; 1261 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T142556[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?_Xlen@?$vector@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@KAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@KAXXZ ENDP ; std::vector<Ogre::D3DSMSCONFLICT_T,std::allocator<Ogre::D3DSMSCONFLICT_T> >::_Xlen
PUBLIC	??$?0UD3DSMSCONFLICT_T@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@UD3DSMSCONFLICT_T@Ogre@@@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::D3DSMSCONFLICT_T>
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??0?$_Container_base_aux_alloc_real@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@IAE@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@IAE@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@1@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@IAE@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@1@@Z$1
__ehfuncinfo$??0?$_Container_base_aux_alloc_real@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@IAE@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0?$_Container_base_aux_alloc_real@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@IAE@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Container_base_aux_alloc_real@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@IAE@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@1@@Z
_TEXT	SEGMENT
tv133 = -32						; size = 4
_this$ = -28						; size = 4
$T142568 = -24						; size = 4
$T142567 = -20						; size = 4
$T142566 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 1
??0?$_Container_base_aux_alloc_real@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@IAE@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@1@@Z PROC ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::D3DSMSCONFLICT_T> >::_Container_base_aux_alloc_real<std::allocator<Ogre::D3DSMSCONFLICT_T> >, COMDAT
; _this$ = ecx

; 419  : 		{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Container_base_aux_alloc_real@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@IAE@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 20					; 00000014H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::_Container_base_aux
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??$?0UD3DSMSCONFLICT_T@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@UD3DSMSCONFLICT_T@Ogre@@@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::D3DSMSCONFLICT_T>

; 420  : 		_Myownedaux = new (_Alaux.allocate(1)) _Aux_cont(this);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?allocate@?$allocator@V_Aux_cont@std@@@std@@QAEPAV_Aux_cont@2@I@Z ; std::allocator<std::_Aux_cont>::allocate
	mov	DWORD PTR $T142568[ebp], eax
	mov	ecx, DWORD PTR $T142568[ebp]
	push	ecx
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T142567[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	cmp	DWORD PTR $T142567[ebp], 0
	je	SHORT $LN3@Container_@4
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T142567[ebp]
	call	??0_Aux_cont@std@@QAE@QBV_Container_base_aux@1@@Z ; std::_Aux_cont::_Aux_cont
	mov	DWORD PTR tv133[ebp], eax
	jmp	SHORT $LN4@Container_@4
$LN3@Container_@4:
	mov	DWORD PTR tv133[ebp], 0
$LN4@Container_@4:
	mov	eax, DWORD PTR tv133[ebp]
	mov	DWORD PTR $T142566[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T142566[ebp]
	mov	DWORD PTR [ecx], edx

; 421  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@IAE@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@IAE@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@1@@Z$1:
	mov	eax, DWORD PTR $T142568[ebp]
	push	eax
	mov	ecx, DWORD PTR $T142567[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??0?$_Container_base_aux_alloc_real@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@IAE@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Container_base_aux_alloc_real@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@IAE@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Container_base_aux_alloc_real@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@IAE@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@1@@Z ENDP ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::D3DSMSCONFLICT_T> >::_Container_base_aux_alloc_real<std::allocator<Ogre::D3DSMSCONFLICT_T> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@QAE@ABV01@@Z PROC ; std::allocator<Ogre::D3DSMSCONFLICT_T>::allocator<Ogre::D3DSMSCONFLICT_T>, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<Ogre::D3DSMSCONFLICT_T>::allocator<Ogre::D3DSMSCONFLICT_T>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@QAEXPAUD3DSMSCONFLICT_T@Ogre@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@QAEXPAUD3DSMSCONFLICT_T@Ogre@@I@Z PROC ; std::allocator<Ogre::D3DSMSCONFLICT_T>::deallocate, COMDAT
; _this$ = ecx

; 139  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 141  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@QAEXPAUD3DSMSCONFLICT_T@Ogre@@I@Z ENDP ; std::allocator<Ogre::D3DSMSCONFLICT_T>::deallocate
_TEXT	ENDS
PUBLIC	??$_Allocate@UD3DSMSCONFLICT_T@Ogre@@@std@@YAPAUD3DSMSCONFLICT_T@Ogre@@IPAU12@@Z ; std::_Allocate<Ogre::D3DSMSCONFLICT_T>
; Function compile flags: /Odtp
;	COMDAT ?allocate@?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@QAEPAUD3DSMSCONFLICT_T@Ogre@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@QAEPAUD3DSMSCONFLICT_T@Ogre@@I@Z PROC ; std::allocator<Ogre::D3DSMSCONFLICT_T>::allocate, COMDAT
; _this$ = ecx

; 144  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@UD3DSMSCONFLICT_T@Ogre@@@std@@YAPAUD3DSMSCONFLICT_T@Ogre@@IPAU12@@Z ; std::_Allocate<Ogre::D3DSMSCONFLICT_T>
	add	esp, 8

; 146  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@QAEPAUD3DSMSCONFLICT_T@Ogre@@I@Z ENDP ; std::allocator<Ogre::D3DSMSCONFLICT_T>::allocate
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?begin@?$vector@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@2@XZ PROC ; std::vector<enum Ogre::VERTPROCESS_T,std::allocator<enum Ogre::VERTPROCESS_T> >::begin, COMDAT
; _this$ = ecx

; 640  : 		{	// return iterator for beginning of mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 641  : 		return (iterator(_Myfirst, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@QAE@PAW4VERTPROCESS_T@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<enum Ogre::VERTPROCESS_T,std::allocator<enum Ogre::VERTPROCESS_T> >::_Vector_iterator<enum Ogre::VERTPROCESS_T,std::allocator<enum Ogre::VERTPROCESS_T> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 642  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?begin@?$vector@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@2@XZ ENDP ; std::vector<enum Ogre::VERTPROCESS_T,std::allocator<enum Ogre::VERTPROCESS_T> >::begin
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@W4VERTPROCESS_T@Ogre@@@std@@QBEIXZ ; std::allocator<enum Ogre::VERTPROCESS_T>::max_size
; Function compile flags: /Odtp
;	COMDAT ?max_size@?$vector@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$vector@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@QBEIXZ PROC ; std::vector<enum Ogre::VERTPROCESS_T,std::allocator<enum Ogre::VERTPROCESS_T> >::max_size, COMDAT
; _this$ = ecx

; 730  : 		{	// return maximum possible length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 731  : 		return (this->_Alval.max_size());

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?max_size@?$allocator@W4VERTPROCESS_T@Ogre@@@std@@QBEIXZ ; std::allocator<enum Ogre::VERTPROCESS_T>::max_size

; 732  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$vector@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@QBEIXZ ENDP ; std::vector<enum Ogre::VERTPROCESS_T,std::allocator<enum Ogre::VERTPROCESS_T> >::max_size
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@YAXPAW4VERTPROCESS_T@Ogre@@0AAV?$allocator@W4VERTPROCESS_T@Ogre@@@0@@Z ; std::_Destroy_range<std::allocator<enum Ogre::VERTPROCESS_T> >
; Function compile flags: /Odtp
;	COMDAT ?_Destroy@?$vector@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@IAEXPAW4VERTPROCESS_T@Ogre@@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@IAEXPAW4VERTPROCESS_T@Ogre@@0@Z PROC ; std::vector<enum Ogre::VERTPROCESS_T,std::allocator<enum Ogre::VERTPROCESS_T> >::_Destroy, COMDAT
; _this$ = ecx

; 1118 : 		{	// destroy [_First, _Last) using allocator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Destroy_range@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@YAXPAW4VERTPROCESS_T@Ogre@@0AAV?$allocator@W4VERTPROCESS_T@Ogre@@@0@@Z ; std::_Destroy_range<std::allocator<enum Ogre::VERTPROCESS_T> >
	add	esp, 12					; 0000000cH

; 1120 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?_Destroy@?$vector@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@IAEXPAW4VERTPROCESS_T@Ogre@@0@Z ENDP ; std::vector<enum Ogre::VERTPROCESS_T,std::allocator<enum Ogre::VERTPROCESS_T> >::_Destroy
_TEXT	ENDS
PUBLIC	??$_Unchecked_move_backward@PAW4VERTPROCESS_T@Ogre@@PAW412@@stdext@@YAPAW4VERTPROCESS_T@Ogre@@PAW412@00@Z ; stdext::_Unchecked_move_backward<enum Ogre::VERTPROCESS_T *,enum Ogre::VERTPROCESS_T *>
PUBLIC	??$fill@PAW4VERTPROCESS_T@Ogre@@W412@@std@@YAXPAW4VERTPROCESS_T@Ogre@@0ABW412@@Z ; std::fill<enum Ogre::VERTPROCESS_T *,enum Ogre::VERTPROCESS_T>
PUBLIC	??$_Umove@PAW4VERTPROCESS_T@Ogre@@@?$vector@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@IAEPAW4VERTPROCESS_T@Ogre@@PAW423@00@Z ; std::vector<enum Ogre::VERTPROCESS_T,std::allocator<enum Ogre::VERTPROCESS_T> >::_Umove<enum Ogre::VERTPROCESS_T *>
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Insert_n@?$vector@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@2@IABW4VERTPROCESS_T@Ogre@@@Z$5 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@2@IABW4VERTPROCESS_T@Ogre@@@Z$2
__catchsym$?_Insert_n@?$vector@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@2@IABW4VERTPROCESS_T@Ogre@@@Z$4 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@2@IABW4VERTPROCESS_T@Ogre@@@Z$0
__unwindtable$?_Insert_n@?$vector@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@2@IABW4VERTPROCESS_T@Ogre@@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$?_Insert_n@?$vector@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@2@IABW4VERTPROCESS_T@Ogre@@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Insert_n@?$vector@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@2@IABW4VERTPROCESS_T@Ogre@@@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Insert_n@?$vector@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@2@IABW4VERTPROCESS_T@Ogre@@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__tryblocktable$?_Insert_n@?$vector@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@2@IABW4VERTPROCESS_T@Ogre@@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@2@IABW4VERTPROCESS_T@Ogre@@@Z$4
	DD	02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@2@IABW4VERTPROCESS_T@Ogre@@@Z$5
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?_Insert_n@?$vector@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@2@IABW4VERTPROCESS_T@Ogre@@@Z
_TEXT	SEGMENT
tv84 = -52						; size = 4
_this$ = -48						; size = 4
__Tmp$134133 = -44					; size = 4
__Oldend$134134 = -40					; size = 4
__Tmp$134123 = -36					; size = 4
__Ncopied$134110 = -32					; size = 4
__Newvec$134108 = -28					; size = 4
__Whereoff$134109 = -24					; size = 4
__Capacity$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Where$ = 8						; size = 8
__Count$ = 16						; size = 4
__Val$ = 20						; size = 4
?_Insert_n@?$vector@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@2@IABW4VERTPROCESS_T@Ogre@@@Z PROC ; std::vector<enum Ogre::VERTPROCESS_T,std::allocator<enum Ogre::VERTPROCESS_T> >::_Insert_n, COMDAT
; _this$ = ecx

; 1153 : 		{	// insert _Count * _Val at _Where

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Insert_n@?$vector@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@2@IABW4VERTPROCESS_T@Ogre@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 36					; 00000024H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1154 : 
; 1155 :  #if _HAS_ITERATOR_DEBUGGING
; 1156 : 		if (_Where._Mycont != this
; 1157 : 			|| _Where._Myptr < _Myfirst || _Mylast < _Where._Myptr)
; 1158 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1159 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1160 : 
; 1161 : 		size_type _Capacity = capacity();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?capacity@?$vector@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@QBEIXZ ; std::vector<enum Ogre::VERTPROCESS_T,std::allocator<enum Ogre::VERTPROCESS_T> >::capacity
	mov	DWORD PTR __Capacity$[ebp], eax

; 1162 : 
; 1163 : 		if (_Count == 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN14@Insert_n@5
	jmp	$LN16@Insert_n@5
$LN14@Insert_n@5:

; 1164 : 			;
; 1165 : 		else if (max_size() - size() < _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@QBEIXZ ; std::vector<enum Ogre::VERTPROCESS_T,std::allocator<enum Ogre::VERTPROCESS_T> >::max_size
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@QBEIXZ ; std::vector<enum Ogre::VERTPROCESS_T,std::allocator<enum Ogre::VERTPROCESS_T> >::size
	sub	esi, eax
	cmp	esi, DWORD PTR __Count$[ebp]
	jae	SHORT $LN12@Insert_n@5

; 1166 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@KAXXZ ; std::vector<enum Ogre::VERTPROCESS_T,std::allocator<enum Ogre::VERTPROCESS_T> >::_Xlen
	jmp	$LN16@Insert_n@5
$LN12@Insert_n@5:

; 1167 : 		else if (_Capacity < size() + _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@QBEIXZ ; std::vector<enum Ogre::VERTPROCESS_T,std::allocator<enum Ogre::VERTPROCESS_T> >::size
	add	eax, DWORD PTR __Count$[ebp]
	cmp	DWORD PTR __Capacity$[ebp], eax
	jae	$LN10@Insert_n@5

; 1168 : 			{	// not enough room, reallocate
; 1169 : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1170 : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@QBEIXZ ; std::vector<enum Ogre::VERTPROCESS_T,std::allocator<enum Ogre::VERTPROCESS_T> >::max_size
	mov	ecx, DWORD PTR __Capacity$[ebp]
	shr	ecx, 1
	sub	eax, ecx
	cmp	eax, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN17@Insert_n@5
	mov	DWORD PTR tv84[ebp], 0
	jmp	SHORT $LN18@Insert_n@5
$LN17@Insert_n@5:
	mov	edx, DWORD PTR __Capacity$[ebp]
	shr	edx, 1
	add	edx, DWORD PTR __Capacity$[ebp]
	mov	DWORD PTR tv84[ebp], edx
$LN18@Insert_n@5:
	mov	eax, DWORD PTR tv84[ebp]
	mov	DWORD PTR __Capacity$[ebp], eax

; 1171 : 			if (_Capacity < size() + _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@QBEIXZ ; std::vector<enum Ogre::VERTPROCESS_T,std::allocator<enum Ogre::VERTPROCESS_T> >::size
	add	eax, DWORD PTR __Count$[ebp]
	cmp	DWORD PTR __Capacity$[ebp], eax
	jae	SHORT $LN9@Insert_n@5

; 1172 : 				_Capacity = size() + _Count;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@QBEIXZ ; std::vector<enum Ogre::VERTPROCESS_T,std::allocator<enum Ogre::VERTPROCESS_T> >::size
	add	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Capacity$[ebp], eax
$LN9@Insert_n@5:

; 1173 : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

	mov	ecx, DWORD PTR __Capacity$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?allocate@?$allocator@W4VERTPROCESS_T@Ogre@@@std@@QAEPAW4VERTPROCESS_T@Ogre@@I@Z ; std::allocator<enum Ogre::VERTPROCESS_T>::allocate
	mov	DWORD PTR __Newvec$134108[ebp], eax

; 1174 : 			size_type _Whereoff = _VEC_ITER_BASE(_Where) - _Myfirst;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Where$[ebp+4]
	sub	eax, DWORD PTR [edx+12]
	sar	eax, 2
	mov	DWORD PTR __Whereoff$134109[ebp], eax

; 1175 : 			int _Ncopied = 0;

	mov	DWORD PTR __Ncopied$134110[ebp], 0

; 1176 : 
; 1177 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1178 : 			_Ufill(_Newvec + _Whereoff, _Count, _Val);	// add new stuff

	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __Whereoff$134109[ebp]
	mov	ecx, DWORD PTR __Newvec$134108[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Ufill@?$vector@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@IAEPAW4VERTPROCESS_T@Ogre@@PAW434@IABW434@@Z ; std::vector<enum Ogre::VERTPROCESS_T,std::allocator<enum Ogre::VERTPROCESS_T> >::_Ufill

; 1179 : 			++_Ncopied;

	mov	eax, DWORD PTR __Ncopied$134110[ebp]
	add	eax, 1
	mov	DWORD PTR __Ncopied$134110[ebp], eax

; 1180 : 			_Umove(this->_Myfirst, _VEC_ITER_BASE(_Where),
; 1181 : 				_Newvec);	// move prefix

	mov	ecx, DWORD PTR __Newvec$134108[ebp]
	push	ecx
	mov	edx, DWORD PTR __Where$[ebp+4]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Umove@PAW4VERTPROCESS_T@Ogre@@@?$vector@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@IAEPAW4VERTPROCESS_T@Ogre@@PAW423@00@Z ; std::vector<enum Ogre::VERTPROCESS_T,std::allocator<enum Ogre::VERTPROCESS_T> >::_Umove<enum Ogre::VERTPROCESS_T *>

; 1182 : 			++_Ncopied;

	mov	edx, DWORD PTR __Ncopied$134110[ebp]
	add	edx, 1
	mov	DWORD PTR __Ncopied$134110[ebp], edx

; 1183 : 			_Umove(_VEC_ITER_BASE(_Where), this->_Mylast,
; 1184 : 				_Newvec + (_Whereoff + _Count));	// move suffix

	mov	eax, DWORD PTR __Whereoff$134109[ebp]
	add	eax, DWORD PTR __Count$[ebp]
	mov	ecx, DWORD PTR __Newvec$134108[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Where$[ebp+4]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Umove@PAW4VERTPROCESS_T@Ogre@@@?$vector@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@IAEPAW4VERTPROCESS_T@Ogre@@PAW423@00@Z ; std::vector<enum Ogre::VERTPROCESS_T,std::allocator<enum Ogre::VERTPROCESS_T> >::_Umove<enum Ogre::VERTPROCESS_T *>
	jmp	SHORT $LN19@Insert_n@5
__catch$?_Insert_n@?$vector@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@2@IABW4VERTPROCESS_T@Ogre@@@Z$0:

; 1185 : 			_CATCH_ALL
; 1186 : 			if (1 < _Ncopied)

	cmp	DWORD PTR __Ncopied$134110[ebp], 1
	jle	SHORT $LN7@Insert_n@5

; 1187 : 				_Destroy(_Newvec, _Newvec + _Whereoff);

	mov	eax, DWORD PTR __Whereoff$134109[ebp]
	mov	ecx, DWORD PTR __Newvec$134108[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	push	edx
	mov	eax, DWORD PTR __Newvec$134108[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@IAEXPAW4VERTPROCESS_T@Ogre@@0@Z ; std::vector<enum Ogre::VERTPROCESS_T,std::allocator<enum Ogre::VERTPROCESS_T> >::_Destroy
$LN7@Insert_n@5:

; 1188 : 			if (0 < _Ncopied)

	cmp	DWORD PTR __Ncopied$134110[ebp], 0
	jle	SHORT $LN6@Insert_n@5

; 1189 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);

	mov	ecx, DWORD PTR __Whereoff$134109[ebp]
	mov	edx, DWORD PTR __Newvec$134108[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR __Count$[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]
	push	edx
	mov	eax, DWORD PTR __Whereoff$134109[ebp]
	mov	ecx, DWORD PTR __Newvec$134108[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@IAEXPAW4VERTPROCESS_T@Ogre@@0@Z ; std::vector<enum Ogre::VERTPROCESS_T,std::allocator<enum Ogre::VERTPROCESS_T> >::_Destroy
$LN6@Insert_n@5:

; 1190 : 			this->_Alval.deallocate(_Newvec, _Capacity);

	mov	eax, DWORD PTR __Capacity$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Newvec$134108[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?deallocate@?$allocator@W4VERTPROCESS_T@Ogre@@@std@@QAEXPAW4VERTPROCESS_T@Ogre@@I@Z ; std::allocator<enum Ogre::VERTPROCESS_T>::deallocate

; 1191 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1192 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$?_Insert_n@?$vector@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@2@IABW4VERTPROCESS_T@Ogre@@@Z$1
	ret	0
$LN19@Insert_n@5:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Insert_n@?$vector@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@2@IABW4VERTPROCESS_T@Ogre@@@Z$1:

; 1193 : 
; 1194 : 			_Count += size();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@QBEIXZ ; std::vector<enum Ogre::VERTPROCESS_T,std::allocator<enum Ogre::VERTPROCESS_T> >::size
	add	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Count$[ebp], eax

; 1195 : 			if (_Myfirst != 0)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+12], 0
	je	SHORT $LN5@Insert_n@5

; 1196 : 				{	// destroy and deallocate old array
; 1197 : 				_Destroy(_Myfirst, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@IAEXPAW4VERTPROCESS_T@Ogre@@0@Z ; std::vector<enum Ogre::VERTPROCESS_T,std::allocator<enum Ogre::VERTPROCESS_T> >::_Destroy

; 1198 : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+20]
	sub	eax, DWORD PTR [edx+12]
	sar	eax, 2
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?deallocate@?$allocator@W4VERTPROCESS_T@Ogre@@@std@@QAEXPAW4VERTPROCESS_T@Ogre@@I@Z ; std::allocator<enum Ogre::VERTPROCESS_T>::deallocate
$LN5@Insert_n@5:

; 1199 : 				}
; 1200 : 
; 1201 :  #if _HAS_ITERATOR_DEBUGGING
; 1202 : 			this->_Orphan_all();
; 1203 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1204 : 
; 1205 : 			_Myend = _Newvec + _Capacity;

	mov	eax, DWORD PTR __Capacity$[ebp]
	mov	ecx, DWORD PTR __Newvec$134108[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], edx

; 1206 : 			_Mylast = _Newvec + _Count;

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Newvec$134108[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 1207 : 			_Myfirst = _Newvec;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Newvec$134108[ebp]
	mov	DWORD PTR [edx+12], eax
	jmp	$LN16@Insert_n@5
$LN10@Insert_n@5:

; 1208 : 			}
; 1209 : 		else if ((size_type)(_Mylast - _VEC_ITER_BASE(_Where)) < _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	sub	edx, DWORD PTR __Where$[ebp+4]
	sar	edx, 2
	cmp	edx, DWORD PTR __Count$[ebp]
	jae	$LN3@Insert_n@5

; 1210 : 			{	// new stuff spills off end
; 1211 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Tmp$134123[ebp], ecx

; 1212 : 
; 1213 : 			_Umove(_VEC_ITER_BASE(_Where), _Mylast,
; 1214 : 				_VEC_ITER_BASE(_Where) + _Count);	// copy suffix

	mov	edx, DWORD PTR __Count$[ebp]
	mov	eax, DWORD PTR __Where$[ebp+4]
	lea	ecx, DWORD PTR [eax+edx*4]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp+4]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Umove@PAW4VERTPROCESS_T@Ogre@@@?$vector@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@IAEPAW4VERTPROCESS_T@Ogre@@PAW423@00@Z ; std::vector<enum Ogre::VERTPROCESS_T,std::allocator<enum Ogre::VERTPROCESS_T> >::_Umove<enum Ogre::VERTPROCESS_T *>

; 1215 : 
; 1216 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 2

; 1217 : 			_Ufill(_Mylast, _Count - (_Mylast - _VEC_ITER_BASE(_Where)),
; 1218 : 				_Tmp);	// insert new stuff off end

	lea	edx, DWORD PTR __Tmp$134123[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	sub	ecx, DWORD PTR __Where$[ebp+4]
	sar	ecx, 2
	mov	edx, DWORD PTR __Count$[ebp]
	sub	edx, ecx
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Ufill@?$vector@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@IAEPAW4VERTPROCESS_T@Ogre@@PAW434@IABW434@@Z ; std::vector<enum Ogre::VERTPROCESS_T,std::allocator<enum Ogre::VERTPROCESS_T> >::_Ufill
	jmp	SHORT $LN21@Insert_n@5
__catch$?_Insert_n@?$vector@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@2@IABW4VERTPROCESS_T@Ogre@@@Z$2:

; 1219 : 			_CATCH_ALL
; 1220 : 			_Destroy(_VEC_ITER_BASE(_Where) + _Count, _Mylast + _Count);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR __Count$[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	mov	ecx, DWORD PTR __Where$[ebp+4]
	lea	edx, DWORD PTR [ecx+eax*4]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@IAEXPAW4VERTPROCESS_T@Ogre@@0@Z ; std::vector<enum Ogre::VERTPROCESS_T,std::allocator<enum Ogre::VERTPROCESS_T> >::_Destroy

; 1221 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1222 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$?_Insert_n@?$vector@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@2@IABW4VERTPROCESS_T@Ogre@@@Z$3
	ret	0
$LN21@Insert_n@5:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Insert_n@?$vector@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@2@IABW4VERTPROCESS_T@Ogre@@@Z$3:

; 1223 : 
; 1224 : 			_Mylast += _Count;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR __Count$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 1225 : 
; 1226 :  #if _HAS_ITERATOR_DEBUGGING
; 1227 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1228 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1229 : 
; 1230 : 			std::fill(_VEC_ITER_BASE(_Where), _Mylast - _Count,
; 1231 : 				_Tmp);	// insert up to old end

	lea	edx, DWORD PTR __Tmp$134123[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 2
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	sub	edx, eax
	push	edx
	mov	eax, DWORD PTR __Where$[ebp+4]
	push	eax
	call	??$fill@PAW4VERTPROCESS_T@Ogre@@W412@@std@@YAXPAW4VERTPROCESS_T@Ogre@@0ABW412@@Z ; std::fill<enum Ogre::VERTPROCESS_T *,enum Ogre::VERTPROCESS_T>
	add	esp, 12					; 0000000cH

; 1232 : 			}
; 1233 : 		else

	jmp	SHORT $LN16@Insert_n@5
$LN3@Insert_n@5:

; 1234 : 			{	// new stuff can all be assigned
; 1235 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	ecx, DWORD PTR __Val$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR __Tmp$134133[ebp], edx

; 1236 : 
; 1237 : 			pointer _Oldend = _Mylast;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR __Oldend$134134[ebp], ecx

; 1238 : 			_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1239 : 				_Mylast);	// copy suffix

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR __Oldend$134134[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count$[ebp]
	shl	edx, 2
	mov	eax, DWORD PTR __Oldend$134134[ebp]
	sub	eax, edx
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Umove@PAW4VERTPROCESS_T@Ogre@@@?$vector@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@IAEPAW4VERTPROCESS_T@Ogre@@PAW423@00@Z ; std::vector<enum Ogre::VERTPROCESS_T,std::allocator<enum Ogre::VERTPROCESS_T> >::_Umove<enum Ogre::VERTPROCESS_T *>
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 1240 : 
; 1241 :  #if _HAS_ITERATOR_DEBUGGING
; 1242 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1243 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1244 : 
; 1245 : 			_STDEXT _Unchecked_move_backward(_VEC_ITER_BASE(_Where), _Oldend - _Count,
; 1246 : 				_Oldend);	// copy hole

	mov	edx, DWORD PTR __Oldend$134134[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 2
	mov	ecx, DWORD PTR __Oldend$134134[ebp]
	sub	ecx, eax
	push	ecx
	mov	edx, DWORD PTR __Where$[ebp+4]
	push	edx
	call	??$_Unchecked_move_backward@PAW4VERTPROCESS_T@Ogre@@PAW412@@stdext@@YAPAW4VERTPROCESS_T@Ogre@@PAW412@00@Z ; stdext::_Unchecked_move_backward<enum Ogre::VERTPROCESS_T *,enum Ogre::VERTPROCESS_T *>
	add	esp, 12					; 0000000cH

; 1247 : 			std::fill(_VEC_ITER_BASE(_Where), _VEC_ITER_BASE(_Where) + _Count,
; 1248 : 				_Tmp);	// insert into hole

	lea	eax, DWORD PTR __Tmp$134133[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Where$[ebp+4]
	lea	eax, DWORD PTR [edx+ecx*4]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp+4]
	push	ecx
	call	??$fill@PAW4VERTPROCESS_T@Ogre@@W412@@std@@YAXPAW4VERTPROCESS_T@Ogre@@0ABW412@@Z ; std::fill<enum Ogre::VERTPROCESS_T *,enum Ogre::VERTPROCESS_T>
	add	esp, 12					; 0000000cH
$LN16@Insert_n@5:

; 1249 : 			}
; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Insert_n@?$vector@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@2@IABW4VERTPROCESS_T@Ogre@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-56]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Insert_n@?$vector@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@2@IABW4VERTPROCESS_T@Ogre@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Insert_n@?$vector@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@2@IABW4VERTPROCESS_T@Ogre@@@Z ENDP ; std::vector<enum Ogre::VERTPROCESS_T,std::allocator<enum Ogre::VERTPROCESS_T> >::_Insert_n
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@KAXXZ$0
__ehfuncinfo$?_Xlen@?$vector@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@KAXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T142617 = -80						; size = 28
$T142616 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@KAXXZ PROC ; std::vector<enum Ogre::VERTPROCESS_T,std::allocator<enum Ogre::VERTPROCESS_T> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Xlen@?$vector@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T142617[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR $T142617[ebp]
	push	eax
	lea	ecx, DWORD PTR $T142616[ebp]
	call	??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::length_error::length_error
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T142616[ebp]
	push	ecx
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T142617[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN2@Xlen@5:

; 1261 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T142617[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?_Xlen@?$vector@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@KAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@KAXXZ ENDP ; std::vector<enum Ogre::VERTPROCESS_T,std::allocator<enum Ogre::VERTPROCESS_T> >::_Xlen
PUBLIC	??$?0W4VERTPROCESS_T@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@W4VERTPROCESS_T@Ogre@@@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><enum Ogre::VERTPROCESS_T>
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??0?$_Container_base_aux_alloc_real@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@IAE@V?$allocator@W4VERTPROCESS_T@Ogre@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@IAE@V?$allocator@W4VERTPROCESS_T@Ogre@@@1@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@IAE@V?$allocator@W4VERTPROCESS_T@Ogre@@@1@@Z$1
__ehfuncinfo$??0?$_Container_base_aux_alloc_real@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@IAE@V?$allocator@W4VERTPROCESS_T@Ogre@@@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0?$_Container_base_aux_alloc_real@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@IAE@V?$allocator@W4VERTPROCESS_T@Ogre@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Container_base_aux_alloc_real@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@IAE@V?$allocator@W4VERTPROCESS_T@Ogre@@@1@@Z
_TEXT	SEGMENT
tv133 = -32						; size = 4
_this$ = -28						; size = 4
$T142629 = -24						; size = 4
$T142628 = -20						; size = 4
$T142627 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 1
??0?$_Container_base_aux_alloc_real@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@IAE@V?$allocator@W4VERTPROCESS_T@Ogre@@@1@@Z PROC ; std::_Container_base_aux_alloc_real<std::allocator<enum Ogre::VERTPROCESS_T> >::_Container_base_aux_alloc_real<std::allocator<enum Ogre::VERTPROCESS_T> >, COMDAT
; _this$ = ecx

; 419  : 		{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Container_base_aux_alloc_real@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@IAE@V?$allocator@W4VERTPROCESS_T@Ogre@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 20					; 00000014H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::_Container_base_aux
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??$?0W4VERTPROCESS_T@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@W4VERTPROCESS_T@Ogre@@@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><enum Ogre::VERTPROCESS_T>

; 420  : 		_Myownedaux = new (_Alaux.allocate(1)) _Aux_cont(this);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?allocate@?$allocator@V_Aux_cont@std@@@std@@QAEPAV_Aux_cont@2@I@Z ; std::allocator<std::_Aux_cont>::allocate
	mov	DWORD PTR $T142629[ebp], eax
	mov	ecx, DWORD PTR $T142629[ebp]
	push	ecx
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T142628[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	cmp	DWORD PTR $T142628[ebp], 0
	je	SHORT $LN3@Container_@5
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T142628[ebp]
	call	??0_Aux_cont@std@@QAE@QBV_Container_base_aux@1@@Z ; std::_Aux_cont::_Aux_cont
	mov	DWORD PTR tv133[ebp], eax
	jmp	SHORT $LN4@Container_@5
$LN3@Container_@5:
	mov	DWORD PTR tv133[ebp], 0
$LN4@Container_@5:
	mov	eax, DWORD PTR tv133[ebp]
	mov	DWORD PTR $T142627[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T142627[ebp]
	mov	DWORD PTR [ecx], edx

; 421  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@IAE@V?$allocator@W4VERTPROCESS_T@Ogre@@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@IAE@V?$allocator@W4VERTPROCESS_T@Ogre@@@1@@Z$1:
	mov	eax, DWORD PTR $T142629[ebp]
	push	eax
	mov	ecx, DWORD PTR $T142628[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??0?$_Container_base_aux_alloc_real@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@IAE@V?$allocator@W4VERTPROCESS_T@Ogre@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Container_base_aux_alloc_real@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@IAE@V?$allocator@W4VERTPROCESS_T@Ogre@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Container_base_aux_alloc_real@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@IAE@V?$allocator@W4VERTPROCESS_T@Ogre@@@1@@Z ENDP ; std::_Container_base_aux_alloc_real<std::allocator<enum Ogre::VERTPROCESS_T> >::_Container_base_aux_alloc_real<std::allocator<enum Ogre::VERTPROCESS_T> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@W4VERTPROCESS_T@Ogre@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$allocator@W4VERTPROCESS_T@Ogre@@@std@@QAE@ABV01@@Z PROC ; std::allocator<enum Ogre::VERTPROCESS_T>::allocator<enum Ogre::VERTPROCESS_T>, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$allocator@W4VERTPROCESS_T@Ogre@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<enum Ogre::VERTPROCESS_T>::allocator<enum Ogre::VERTPROCESS_T>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@W4VERTPROCESS_T@Ogre@@@std@@QAEXPAW4VERTPROCESS_T@Ogre@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@W4VERTPROCESS_T@Ogre@@@std@@QAEXPAW4VERTPROCESS_T@Ogre@@I@Z PROC ; std::allocator<enum Ogre::VERTPROCESS_T>::deallocate, COMDAT
; _this$ = ecx

; 139  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 141  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@W4VERTPROCESS_T@Ogre@@@std@@QAEXPAW4VERTPROCESS_T@Ogre@@I@Z ENDP ; std::allocator<enum Ogre::VERTPROCESS_T>::deallocate
_TEXT	ENDS
PUBLIC	??$_Allocate@W4VERTPROCESS_T@Ogre@@@std@@YAPAW4VERTPROCESS_T@Ogre@@IPAW412@@Z ; std::_Allocate<enum Ogre::VERTPROCESS_T>
; Function compile flags: /Odtp
;	COMDAT ?allocate@?$allocator@W4VERTPROCESS_T@Ogre@@@std@@QAEPAW4VERTPROCESS_T@Ogre@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@W4VERTPROCESS_T@Ogre@@@std@@QAEPAW4VERTPROCESS_T@Ogre@@I@Z PROC ; std::allocator<enum Ogre::VERTPROCESS_T>::allocate, COMDAT
; _this$ = ecx

; 144  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@W4VERTPROCESS_T@Ogre@@@std@@YAPAW4VERTPROCESS_T@Ogre@@IPAW412@@Z ; std::_Allocate<enum Ogre::VERTPROCESS_T>
	add	esp, 8

; 146  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@W4VERTPROCESS_T@Ogre@@@std@@QAEPAW4VERTPROCESS_T@Ogre@@I@Z ENDP ; std::allocator<enum Ogre::VERTPROCESS_T>::allocate
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?begin@?$vector@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@2@XZ PROC ; std::vector<Ogre::D3DDEVCOMBO_T *,std::allocator<Ogre::D3DDEVCOMBO_T *> >::begin, COMDAT
; _this$ = ecx

; 640  : 		{	// return iterator for beginning of mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 641  : 		return (iterator(_Myfirst, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@QAE@PAPAUD3DDEVCOMBO_T@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::D3DDEVCOMBO_T *,std::allocator<Ogre::D3DDEVCOMBO_T *> >::_Vector_iterator<Ogre::D3DDEVCOMBO_T *,std::allocator<Ogre::D3DDEVCOMBO_T *> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 642  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?begin@?$vector@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@2@XZ ENDP ; std::vector<Ogre::D3DDEVCOMBO_T *,std::allocator<Ogre::D3DDEVCOMBO_T *> >::begin
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@QBEIXZ ; std::allocator<Ogre::D3DDEVCOMBO_T *>::max_size
; Function compile flags: /Odtp
;	COMDAT ?max_size@?$vector@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$vector@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@QBEIXZ PROC ; std::vector<Ogre::D3DDEVCOMBO_T *,std::allocator<Ogre::D3DDEVCOMBO_T *> >::max_size, COMDAT
; _this$ = ecx

; 730  : 		{	// return maximum possible length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 731  : 		return (this->_Alval.max_size());

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?max_size@?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@QBEIXZ ; std::allocator<Ogre::D3DDEVCOMBO_T *>::max_size

; 732  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$vector@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@QBEIXZ ENDP ; std::vector<Ogre::D3DDEVCOMBO_T *,std::allocator<Ogre::D3DDEVCOMBO_T *> >::max_size
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@YAXPAPAUD3DDEVCOMBO_T@Ogre@@0AAV?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@0@@Z ; std::_Destroy_range<std::allocator<Ogre::D3DDEVCOMBO_T *> >
; Function compile flags: /Odtp
;	COMDAT ?_Destroy@?$vector@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@IAEXPAPAUD3DDEVCOMBO_T@Ogre@@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@IAEXPAPAUD3DDEVCOMBO_T@Ogre@@0@Z PROC ; std::vector<Ogre::D3DDEVCOMBO_T *,std::allocator<Ogre::D3DDEVCOMBO_T *> >::_Destroy, COMDAT
; _this$ = ecx

; 1118 : 		{	// destroy [_First, _Last) using allocator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Destroy_range@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@YAXPAPAUD3DDEVCOMBO_T@Ogre@@0AAV?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@0@@Z ; std::_Destroy_range<std::allocator<Ogre::D3DDEVCOMBO_T *> >
	add	esp, 12					; 0000000cH

; 1120 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?_Destroy@?$vector@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@IAEXPAPAUD3DDEVCOMBO_T@Ogre@@0@Z ENDP ; std::vector<Ogre::D3DDEVCOMBO_T *,std::allocator<Ogre::D3DDEVCOMBO_T *> >::_Destroy
_TEXT	ENDS
PUBLIC	??$_Unchecked_move_backward@PAPAUD3DDEVCOMBO_T@Ogre@@PAPAU12@@stdext@@YAPAPAUD3DDEVCOMBO_T@Ogre@@PAPAU12@00@Z ; stdext::_Unchecked_move_backward<Ogre::D3DDEVCOMBO_T * *,Ogre::D3DDEVCOMBO_T * *>
PUBLIC	??$fill@PAPAUD3DDEVCOMBO_T@Ogre@@PAU12@@std@@YAXPAPAUD3DDEVCOMBO_T@Ogre@@0ABQAU12@@Z ; std::fill<Ogre::D3DDEVCOMBO_T * *,Ogre::D3DDEVCOMBO_T *>
PUBLIC	??$_Umove@PAPAUD3DDEVCOMBO_T@Ogre@@@?$vector@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@IAEPAPAUD3DDEVCOMBO_T@Ogre@@PAPAU23@00@Z ; std::vector<Ogre::D3DDEVCOMBO_T *,std::allocator<Ogre::D3DDEVCOMBO_T *> >::_Umove<Ogre::D3DDEVCOMBO_T * *>
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Insert_n@?$vector@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@2@IABQAUD3DDEVCOMBO_T@Ogre@@@Z$5 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@2@IABQAUD3DDEVCOMBO_T@Ogre@@@Z$2
__catchsym$?_Insert_n@?$vector@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@2@IABQAUD3DDEVCOMBO_T@Ogre@@@Z$4 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@2@IABQAUD3DDEVCOMBO_T@Ogre@@@Z$0
__unwindtable$?_Insert_n@?$vector@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@2@IABQAUD3DDEVCOMBO_T@Ogre@@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$?_Insert_n@?$vector@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@2@IABQAUD3DDEVCOMBO_T@Ogre@@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Insert_n@?$vector@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@2@IABQAUD3DDEVCOMBO_T@Ogre@@@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Insert_n@?$vector@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@2@IABQAUD3DDEVCOMBO_T@Ogre@@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__tryblocktable$?_Insert_n@?$vector@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@2@IABQAUD3DDEVCOMBO_T@Ogre@@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@2@IABQAUD3DDEVCOMBO_T@Ogre@@@Z$4
	DD	02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@2@IABQAUD3DDEVCOMBO_T@Ogre@@@Z$5
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?_Insert_n@?$vector@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@2@IABQAUD3DDEVCOMBO_T@Ogre@@@Z
_TEXT	SEGMENT
tv84 = -52						; size = 4
_this$ = -48						; size = 4
__Tmp$134219 = -44					; size = 4
__Oldend$134220 = -40					; size = 4
__Tmp$134209 = -36					; size = 4
__Ncopied$134196 = -32					; size = 4
__Newvec$134194 = -28					; size = 4
__Whereoff$134195 = -24					; size = 4
__Capacity$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Where$ = 8						; size = 8
__Count$ = 16						; size = 4
__Val$ = 20						; size = 4
?_Insert_n@?$vector@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@2@IABQAUD3DDEVCOMBO_T@Ogre@@@Z PROC ; std::vector<Ogre::D3DDEVCOMBO_T *,std::allocator<Ogre::D3DDEVCOMBO_T *> >::_Insert_n, COMDAT
; _this$ = ecx

; 1153 : 		{	// insert _Count * _Val at _Where

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Insert_n@?$vector@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@2@IABQAUD3DDEVCOMBO_T@Ogre@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 36					; 00000024H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1154 : 
; 1155 :  #if _HAS_ITERATOR_DEBUGGING
; 1156 : 		if (_Where._Mycont != this
; 1157 : 			|| _Where._Myptr < _Myfirst || _Mylast < _Where._Myptr)
; 1158 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1159 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1160 : 
; 1161 : 		size_type _Capacity = capacity();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?capacity@?$vector@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::D3DDEVCOMBO_T *,std::allocator<Ogre::D3DDEVCOMBO_T *> >::capacity
	mov	DWORD PTR __Capacity$[ebp], eax

; 1162 : 
; 1163 : 		if (_Count == 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN14@Insert_n@6
	jmp	$LN16@Insert_n@6
$LN14@Insert_n@6:

; 1164 : 			;
; 1165 : 		else if (max_size() - size() < _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::D3DDEVCOMBO_T *,std::allocator<Ogre::D3DDEVCOMBO_T *> >::max_size
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::D3DDEVCOMBO_T *,std::allocator<Ogre::D3DDEVCOMBO_T *> >::size
	sub	esi, eax
	cmp	esi, DWORD PTR __Count$[ebp]
	jae	SHORT $LN12@Insert_n@6

; 1166 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@KAXXZ ; std::vector<Ogre::D3DDEVCOMBO_T *,std::allocator<Ogre::D3DDEVCOMBO_T *> >::_Xlen
	jmp	$LN16@Insert_n@6
$LN12@Insert_n@6:

; 1167 : 		else if (_Capacity < size() + _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::D3DDEVCOMBO_T *,std::allocator<Ogre::D3DDEVCOMBO_T *> >::size
	add	eax, DWORD PTR __Count$[ebp]
	cmp	DWORD PTR __Capacity$[ebp], eax
	jae	$LN10@Insert_n@6

; 1168 : 			{	// not enough room, reallocate
; 1169 : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1170 : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::D3DDEVCOMBO_T *,std::allocator<Ogre::D3DDEVCOMBO_T *> >::max_size
	mov	ecx, DWORD PTR __Capacity$[ebp]
	shr	ecx, 1
	sub	eax, ecx
	cmp	eax, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN17@Insert_n@6
	mov	DWORD PTR tv84[ebp], 0
	jmp	SHORT $LN18@Insert_n@6
$LN17@Insert_n@6:
	mov	edx, DWORD PTR __Capacity$[ebp]
	shr	edx, 1
	add	edx, DWORD PTR __Capacity$[ebp]
	mov	DWORD PTR tv84[ebp], edx
$LN18@Insert_n@6:
	mov	eax, DWORD PTR tv84[ebp]
	mov	DWORD PTR __Capacity$[ebp], eax

; 1171 : 			if (_Capacity < size() + _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::D3DDEVCOMBO_T *,std::allocator<Ogre::D3DDEVCOMBO_T *> >::size
	add	eax, DWORD PTR __Count$[ebp]
	cmp	DWORD PTR __Capacity$[ebp], eax
	jae	SHORT $LN9@Insert_n@6

; 1172 : 				_Capacity = size() + _Count;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::D3DDEVCOMBO_T *,std::allocator<Ogre::D3DDEVCOMBO_T *> >::size
	add	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Capacity$[ebp], eax
$LN9@Insert_n@6:

; 1173 : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

	mov	ecx, DWORD PTR __Capacity$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?allocate@?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@QAEPAPAUD3DDEVCOMBO_T@Ogre@@I@Z ; std::allocator<Ogre::D3DDEVCOMBO_T *>::allocate
	mov	DWORD PTR __Newvec$134194[ebp], eax

; 1174 : 			size_type _Whereoff = _VEC_ITER_BASE(_Where) - _Myfirst;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Where$[ebp+4]
	sub	eax, DWORD PTR [edx+12]
	sar	eax, 2
	mov	DWORD PTR __Whereoff$134195[ebp], eax

; 1175 : 			int _Ncopied = 0;

	mov	DWORD PTR __Ncopied$134196[ebp], 0

; 1176 : 
; 1177 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1178 : 			_Ufill(_Newvec + _Whereoff, _Count, _Val);	// add new stuff

	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __Whereoff$134195[ebp]
	mov	ecx, DWORD PTR __Newvec$134194[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Ufill@?$vector@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@IAEPAPAUD3DDEVCOMBO_T@Ogre@@PAPAU34@IABQAU34@@Z ; std::vector<Ogre::D3DDEVCOMBO_T *,std::allocator<Ogre::D3DDEVCOMBO_T *> >::_Ufill

; 1179 : 			++_Ncopied;

	mov	eax, DWORD PTR __Ncopied$134196[ebp]
	add	eax, 1
	mov	DWORD PTR __Ncopied$134196[ebp], eax

; 1180 : 			_Umove(this->_Myfirst, _VEC_ITER_BASE(_Where),
; 1181 : 				_Newvec);	// move prefix

	mov	ecx, DWORD PTR __Newvec$134194[ebp]
	push	ecx
	mov	edx, DWORD PTR __Where$[ebp+4]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Umove@PAPAUD3DDEVCOMBO_T@Ogre@@@?$vector@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@IAEPAPAUD3DDEVCOMBO_T@Ogre@@PAPAU23@00@Z ; std::vector<Ogre::D3DDEVCOMBO_T *,std::allocator<Ogre::D3DDEVCOMBO_T *> >::_Umove<Ogre::D3DDEVCOMBO_T * *>

; 1182 : 			++_Ncopied;

	mov	edx, DWORD PTR __Ncopied$134196[ebp]
	add	edx, 1
	mov	DWORD PTR __Ncopied$134196[ebp], edx

; 1183 : 			_Umove(_VEC_ITER_BASE(_Where), this->_Mylast,
; 1184 : 				_Newvec + (_Whereoff + _Count));	// move suffix

	mov	eax, DWORD PTR __Whereoff$134195[ebp]
	add	eax, DWORD PTR __Count$[ebp]
	mov	ecx, DWORD PTR __Newvec$134194[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Where$[ebp+4]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Umove@PAPAUD3DDEVCOMBO_T@Ogre@@@?$vector@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@IAEPAPAUD3DDEVCOMBO_T@Ogre@@PAPAU23@00@Z ; std::vector<Ogre::D3DDEVCOMBO_T *,std::allocator<Ogre::D3DDEVCOMBO_T *> >::_Umove<Ogre::D3DDEVCOMBO_T * *>
	jmp	SHORT $LN19@Insert_n@6
__catch$?_Insert_n@?$vector@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@2@IABQAUD3DDEVCOMBO_T@Ogre@@@Z$0:

; 1185 : 			_CATCH_ALL
; 1186 : 			if (1 < _Ncopied)

	cmp	DWORD PTR __Ncopied$134196[ebp], 1
	jle	SHORT $LN7@Insert_n@6

; 1187 : 				_Destroy(_Newvec, _Newvec + _Whereoff);

	mov	eax, DWORD PTR __Whereoff$134195[ebp]
	mov	ecx, DWORD PTR __Newvec$134194[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	push	edx
	mov	eax, DWORD PTR __Newvec$134194[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@IAEXPAPAUD3DDEVCOMBO_T@Ogre@@0@Z ; std::vector<Ogre::D3DDEVCOMBO_T *,std::allocator<Ogre::D3DDEVCOMBO_T *> >::_Destroy
$LN7@Insert_n@6:

; 1188 : 			if (0 < _Ncopied)

	cmp	DWORD PTR __Ncopied$134196[ebp], 0
	jle	SHORT $LN6@Insert_n@6

; 1189 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);

	mov	ecx, DWORD PTR __Whereoff$134195[ebp]
	mov	edx, DWORD PTR __Newvec$134194[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR __Count$[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]
	push	edx
	mov	eax, DWORD PTR __Whereoff$134195[ebp]
	mov	ecx, DWORD PTR __Newvec$134194[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@IAEXPAPAUD3DDEVCOMBO_T@Ogre@@0@Z ; std::vector<Ogre::D3DDEVCOMBO_T *,std::allocator<Ogre::D3DDEVCOMBO_T *> >::_Destroy
$LN6@Insert_n@6:

; 1190 : 			this->_Alval.deallocate(_Newvec, _Capacity);

	mov	eax, DWORD PTR __Capacity$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Newvec$134194[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?deallocate@?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@QAEXPAPAUD3DDEVCOMBO_T@Ogre@@I@Z ; std::allocator<Ogre::D3DDEVCOMBO_T *>::deallocate

; 1191 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1192 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$?_Insert_n@?$vector@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@2@IABQAUD3DDEVCOMBO_T@Ogre@@@Z$1
	ret	0
$LN19@Insert_n@6:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Insert_n@?$vector@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@2@IABQAUD3DDEVCOMBO_T@Ogre@@@Z$1:

; 1193 : 
; 1194 : 			_Count += size();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::D3DDEVCOMBO_T *,std::allocator<Ogre::D3DDEVCOMBO_T *> >::size
	add	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Count$[ebp], eax

; 1195 : 			if (_Myfirst != 0)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+12], 0
	je	SHORT $LN5@Insert_n@6

; 1196 : 				{	// destroy and deallocate old array
; 1197 : 				_Destroy(_Myfirst, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@IAEXPAPAUD3DDEVCOMBO_T@Ogre@@0@Z ; std::vector<Ogre::D3DDEVCOMBO_T *,std::allocator<Ogre::D3DDEVCOMBO_T *> >::_Destroy

; 1198 : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+20]
	sub	eax, DWORD PTR [edx+12]
	sar	eax, 2
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?deallocate@?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@QAEXPAPAUD3DDEVCOMBO_T@Ogre@@I@Z ; std::allocator<Ogre::D3DDEVCOMBO_T *>::deallocate
$LN5@Insert_n@6:

; 1199 : 				}
; 1200 : 
; 1201 :  #if _HAS_ITERATOR_DEBUGGING
; 1202 : 			this->_Orphan_all();
; 1203 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1204 : 
; 1205 : 			_Myend = _Newvec + _Capacity;

	mov	eax, DWORD PTR __Capacity$[ebp]
	mov	ecx, DWORD PTR __Newvec$134194[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], edx

; 1206 : 			_Mylast = _Newvec + _Count;

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Newvec$134194[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 1207 : 			_Myfirst = _Newvec;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Newvec$134194[ebp]
	mov	DWORD PTR [edx+12], eax
	jmp	$LN16@Insert_n@6
$LN10@Insert_n@6:

; 1208 : 			}
; 1209 : 		else if ((size_type)(_Mylast - _VEC_ITER_BASE(_Where)) < _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	sub	edx, DWORD PTR __Where$[ebp+4]
	sar	edx, 2
	cmp	edx, DWORD PTR __Count$[ebp]
	jae	$LN3@Insert_n@6

; 1210 : 			{	// new stuff spills off end
; 1211 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Tmp$134209[ebp], ecx

; 1212 : 
; 1213 : 			_Umove(_VEC_ITER_BASE(_Where), _Mylast,
; 1214 : 				_VEC_ITER_BASE(_Where) + _Count);	// copy suffix

	mov	edx, DWORD PTR __Count$[ebp]
	mov	eax, DWORD PTR __Where$[ebp+4]
	lea	ecx, DWORD PTR [eax+edx*4]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp+4]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Umove@PAPAUD3DDEVCOMBO_T@Ogre@@@?$vector@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@IAEPAPAUD3DDEVCOMBO_T@Ogre@@PAPAU23@00@Z ; std::vector<Ogre::D3DDEVCOMBO_T *,std::allocator<Ogre::D3DDEVCOMBO_T *> >::_Umove<Ogre::D3DDEVCOMBO_T * *>

; 1215 : 
; 1216 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 2

; 1217 : 			_Ufill(_Mylast, _Count - (_Mylast - _VEC_ITER_BASE(_Where)),
; 1218 : 				_Tmp);	// insert new stuff off end

	lea	edx, DWORD PTR __Tmp$134209[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	sub	ecx, DWORD PTR __Where$[ebp+4]
	sar	ecx, 2
	mov	edx, DWORD PTR __Count$[ebp]
	sub	edx, ecx
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Ufill@?$vector@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@IAEPAPAUD3DDEVCOMBO_T@Ogre@@PAPAU34@IABQAU34@@Z ; std::vector<Ogre::D3DDEVCOMBO_T *,std::allocator<Ogre::D3DDEVCOMBO_T *> >::_Ufill
	jmp	SHORT $LN21@Insert_n@6
__catch$?_Insert_n@?$vector@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@2@IABQAUD3DDEVCOMBO_T@Ogre@@@Z$2:

; 1219 : 			_CATCH_ALL
; 1220 : 			_Destroy(_VEC_ITER_BASE(_Where) + _Count, _Mylast + _Count);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR __Count$[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	mov	ecx, DWORD PTR __Where$[ebp+4]
	lea	edx, DWORD PTR [ecx+eax*4]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@IAEXPAPAUD3DDEVCOMBO_T@Ogre@@0@Z ; std::vector<Ogre::D3DDEVCOMBO_T *,std::allocator<Ogre::D3DDEVCOMBO_T *> >::_Destroy

; 1221 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1222 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$?_Insert_n@?$vector@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@2@IABQAUD3DDEVCOMBO_T@Ogre@@@Z$3
	ret	0
$LN21@Insert_n@6:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Insert_n@?$vector@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@2@IABQAUD3DDEVCOMBO_T@Ogre@@@Z$3:

; 1223 : 
; 1224 : 			_Mylast += _Count;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR __Count$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 1225 : 
; 1226 :  #if _HAS_ITERATOR_DEBUGGING
; 1227 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1228 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1229 : 
; 1230 : 			std::fill(_VEC_ITER_BASE(_Where), _Mylast - _Count,
; 1231 : 				_Tmp);	// insert up to old end

	lea	edx, DWORD PTR __Tmp$134209[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 2
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	sub	edx, eax
	push	edx
	mov	eax, DWORD PTR __Where$[ebp+4]
	push	eax
	call	??$fill@PAPAUD3DDEVCOMBO_T@Ogre@@PAU12@@std@@YAXPAPAUD3DDEVCOMBO_T@Ogre@@0ABQAU12@@Z ; std::fill<Ogre::D3DDEVCOMBO_T * *,Ogre::D3DDEVCOMBO_T *>
	add	esp, 12					; 0000000cH

; 1232 : 			}
; 1233 : 		else

	jmp	SHORT $LN16@Insert_n@6
$LN3@Insert_n@6:

; 1234 : 			{	// new stuff can all be assigned
; 1235 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	ecx, DWORD PTR __Val$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR __Tmp$134219[ebp], edx

; 1236 : 
; 1237 : 			pointer _Oldend = _Mylast;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR __Oldend$134220[ebp], ecx

; 1238 : 			_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1239 : 				_Mylast);	// copy suffix

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR __Oldend$134220[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count$[ebp]
	shl	edx, 2
	mov	eax, DWORD PTR __Oldend$134220[ebp]
	sub	eax, edx
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Umove@PAPAUD3DDEVCOMBO_T@Ogre@@@?$vector@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@IAEPAPAUD3DDEVCOMBO_T@Ogre@@PAPAU23@00@Z ; std::vector<Ogre::D3DDEVCOMBO_T *,std::allocator<Ogre::D3DDEVCOMBO_T *> >::_Umove<Ogre::D3DDEVCOMBO_T * *>
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 1240 : 
; 1241 :  #if _HAS_ITERATOR_DEBUGGING
; 1242 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1243 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1244 : 
; 1245 : 			_STDEXT _Unchecked_move_backward(_VEC_ITER_BASE(_Where), _Oldend - _Count,
; 1246 : 				_Oldend);	// copy hole

	mov	edx, DWORD PTR __Oldend$134220[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 2
	mov	ecx, DWORD PTR __Oldend$134220[ebp]
	sub	ecx, eax
	push	ecx
	mov	edx, DWORD PTR __Where$[ebp+4]
	push	edx
	call	??$_Unchecked_move_backward@PAPAUD3DDEVCOMBO_T@Ogre@@PAPAU12@@stdext@@YAPAPAUD3DDEVCOMBO_T@Ogre@@PAPAU12@00@Z ; stdext::_Unchecked_move_backward<Ogre::D3DDEVCOMBO_T * *,Ogre::D3DDEVCOMBO_T * *>
	add	esp, 12					; 0000000cH

; 1247 : 			std::fill(_VEC_ITER_BASE(_Where), _VEC_ITER_BASE(_Where) + _Count,
; 1248 : 				_Tmp);	// insert into hole

	lea	eax, DWORD PTR __Tmp$134219[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Where$[ebp+4]
	lea	eax, DWORD PTR [edx+ecx*4]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp+4]
	push	ecx
	call	??$fill@PAPAUD3DDEVCOMBO_T@Ogre@@PAU12@@std@@YAXPAPAUD3DDEVCOMBO_T@Ogre@@0ABQAU12@@Z ; std::fill<Ogre::D3DDEVCOMBO_T * *,Ogre::D3DDEVCOMBO_T *>
	add	esp, 12					; 0000000cH
$LN16@Insert_n@6:

; 1249 : 			}
; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Insert_n@?$vector@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@2@IABQAUD3DDEVCOMBO_T@Ogre@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-56]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Insert_n@?$vector@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@2@IABQAUD3DDEVCOMBO_T@Ogre@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Insert_n@?$vector@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@2@IABQAUD3DDEVCOMBO_T@Ogre@@@Z ENDP ; std::vector<Ogre::D3DDEVCOMBO_T *,std::allocator<Ogre::D3DDEVCOMBO_T *> >::_Insert_n
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@KAXXZ$0
__ehfuncinfo$?_Xlen@?$vector@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@KAXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T142678 = -80						; size = 28
$T142677 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@KAXXZ PROC ; std::vector<Ogre::D3DDEVCOMBO_T *,std::allocator<Ogre::D3DDEVCOMBO_T *> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Xlen@?$vector@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T142678[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR $T142678[ebp]
	push	eax
	lea	ecx, DWORD PTR $T142677[ebp]
	call	??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::length_error::length_error
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T142677[ebp]
	push	ecx
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T142678[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN2@Xlen@6:

; 1261 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T142678[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?_Xlen@?$vector@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@KAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@KAXXZ ENDP ; std::vector<Ogre::D3DDEVCOMBO_T *,std::allocator<Ogre::D3DDEVCOMBO_T *> >::_Xlen
PUBLIC	??$?0PAUD3DDEVCOMBO_T@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::D3DDEVCOMBO_T *>
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??0?$_Container_base_aux_alloc_real@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@IAE@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@IAE@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@1@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@IAE@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@1@@Z$1
__ehfuncinfo$??0?$_Container_base_aux_alloc_real@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@IAE@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0?$_Container_base_aux_alloc_real@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@IAE@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Container_base_aux_alloc_real@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@IAE@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@1@@Z
_TEXT	SEGMENT
tv133 = -32						; size = 4
_this$ = -28						; size = 4
$T142690 = -24						; size = 4
$T142689 = -20						; size = 4
$T142688 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 1
??0?$_Container_base_aux_alloc_real@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@IAE@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@1@@Z PROC ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::D3DDEVCOMBO_T *> >::_Container_base_aux_alloc_real<std::allocator<Ogre::D3DDEVCOMBO_T *> >, COMDAT
; _this$ = ecx

; 419  : 		{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Container_base_aux_alloc_real@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@IAE@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 20					; 00000014H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::_Container_base_aux
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??$?0PAUD3DDEVCOMBO_T@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::D3DDEVCOMBO_T *>

; 420  : 		_Myownedaux = new (_Alaux.allocate(1)) _Aux_cont(this);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?allocate@?$allocator@V_Aux_cont@std@@@std@@QAEPAV_Aux_cont@2@I@Z ; std::allocator<std::_Aux_cont>::allocate
	mov	DWORD PTR $T142690[ebp], eax
	mov	ecx, DWORD PTR $T142690[ebp]
	push	ecx
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T142689[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	cmp	DWORD PTR $T142689[ebp], 0
	je	SHORT $LN3@Container_@6
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T142689[ebp]
	call	??0_Aux_cont@std@@QAE@QBV_Container_base_aux@1@@Z ; std::_Aux_cont::_Aux_cont
	mov	DWORD PTR tv133[ebp], eax
	jmp	SHORT $LN4@Container_@6
$LN3@Container_@6:
	mov	DWORD PTR tv133[ebp], 0
$LN4@Container_@6:
	mov	eax, DWORD PTR tv133[ebp]
	mov	DWORD PTR $T142688[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T142688[ebp]
	mov	DWORD PTR [ecx], edx

; 421  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@IAE@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@IAE@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@1@@Z$1:
	mov	eax, DWORD PTR $T142690[ebp]
	push	eax
	mov	ecx, DWORD PTR $T142689[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??0?$_Container_base_aux_alloc_real@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@IAE@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Container_base_aux_alloc_real@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@IAE@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Container_base_aux_alloc_real@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@IAE@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@1@@Z ENDP ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::D3DDEVCOMBO_T *> >::_Container_base_aux_alloc_real<std::allocator<Ogre::D3DDEVCOMBO_T *> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@QAE@ABV01@@Z PROC ; std::allocator<Ogre::D3DDEVCOMBO_T *>::allocator<Ogre::D3DDEVCOMBO_T *>, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<Ogre::D3DDEVCOMBO_T *>::allocator<Ogre::D3DDEVCOMBO_T *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@QAEXPAPAUD3DDEVCOMBO_T@Ogre@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@QAEXPAPAUD3DDEVCOMBO_T@Ogre@@I@Z PROC ; std::allocator<Ogre::D3DDEVCOMBO_T *>::deallocate, COMDAT
; _this$ = ecx

; 139  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 141  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@QAEXPAPAUD3DDEVCOMBO_T@Ogre@@I@Z ENDP ; std::allocator<Ogre::D3DDEVCOMBO_T *>::deallocate
_TEXT	ENDS
PUBLIC	??$_Allocate@PAUD3DDEVCOMBO_T@Ogre@@@std@@YAPAPAUD3DDEVCOMBO_T@Ogre@@IPAPAU12@@Z ; std::_Allocate<Ogre::D3DDEVCOMBO_T *>
; Function compile flags: /Odtp
;	COMDAT ?allocate@?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@QAEPAPAUD3DDEVCOMBO_T@Ogre@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@QAEPAPAUD3DDEVCOMBO_T@Ogre@@I@Z PROC ; std::allocator<Ogre::D3DDEVCOMBO_T *>::allocate, COMDAT
; _this$ = ecx

; 144  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@PAUD3DDEVCOMBO_T@Ogre@@@std@@YAPAPAUD3DDEVCOMBO_T@Ogre@@IPAPAU12@@Z ; std::_Allocate<Ogre::D3DDEVCOMBO_T *>
	add	esp, 8

; 146  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@QAEPAPAUD3DDEVCOMBO_T@Ogre@@I@Z ENDP ; std::allocator<Ogre::D3DDEVCOMBO_T *>::allocate
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?begin@?$vector@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@QAE?AV?$_Vector_iterator@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@QAE?AV?$_Vector_iterator@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@2@XZ PROC ; std::vector<_D3DDISPLAYMODE,std::allocator<_D3DDISPLAYMODE> >::begin, COMDAT
; _this$ = ecx

; 640  : 		{	// return iterator for beginning of mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 641  : 		return (iterator(_Myfirst, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@QAE@PAU_D3DDISPLAYMODE@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<_D3DDISPLAYMODE,std::allocator<_D3DDISPLAYMODE> >::_Vector_iterator<_D3DDISPLAYMODE,std::allocator<_D3DDISPLAYMODE> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 642  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?begin@?$vector@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@QAE?AV?$_Vector_iterator@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@2@XZ ENDP ; std::vector<_D3DDISPLAYMODE,std::allocator<_D3DDISPLAYMODE> >::begin
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@U_D3DDISPLAYMODE@@@std@@QBEIXZ ; std::allocator<_D3DDISPLAYMODE>::max_size
; Function compile flags: /Odtp
;	COMDAT ?max_size@?$vector@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$vector@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@QBEIXZ PROC ; std::vector<_D3DDISPLAYMODE,std::allocator<_D3DDISPLAYMODE> >::max_size, COMDAT
; _this$ = ecx

; 730  : 		{	// return maximum possible length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 731  : 		return (this->_Alval.max_size());

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?max_size@?$allocator@U_D3DDISPLAYMODE@@@std@@QBEIXZ ; std::allocator<_D3DDISPLAYMODE>::max_size

; 732  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$vector@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@QBEIXZ ENDP ; std::vector<_D3DDISPLAYMODE,std::allocator<_D3DDISPLAYMODE> >::max_size
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@YAXPAU_D3DDISPLAYMODE@@0AAV?$allocator@U_D3DDISPLAYMODE@@@0@@Z ; std::_Destroy_range<std::allocator<_D3DDISPLAYMODE> >
; Function compile flags: /Odtp
;	COMDAT ?_Destroy@?$vector@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@IAEXPAU_D3DDISPLAYMODE@@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@IAEXPAU_D3DDISPLAYMODE@@0@Z PROC ; std::vector<_D3DDISPLAYMODE,std::allocator<_D3DDISPLAYMODE> >::_Destroy, COMDAT
; _this$ = ecx

; 1118 : 		{	// destroy [_First, _Last) using allocator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Destroy_range@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@YAXPAU_D3DDISPLAYMODE@@0AAV?$allocator@U_D3DDISPLAYMODE@@@0@@Z ; std::_Destroy_range<std::allocator<_D3DDISPLAYMODE> >
	add	esp, 12					; 0000000cH

; 1120 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?_Destroy@?$vector@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@IAEXPAU_D3DDISPLAYMODE@@0@Z ENDP ; std::vector<_D3DDISPLAYMODE,std::allocator<_D3DDISPLAYMODE> >::_Destroy
_TEXT	ENDS
PUBLIC	??$_Unchecked_move_backward@PAU_D3DDISPLAYMODE@@PAU1@@stdext@@YAPAU_D3DDISPLAYMODE@@PAU1@00@Z ; stdext::_Unchecked_move_backward<_D3DDISPLAYMODE *,_D3DDISPLAYMODE *>
PUBLIC	??$fill@PAU_D3DDISPLAYMODE@@U1@@std@@YAXPAU_D3DDISPLAYMODE@@0ABU1@@Z ; std::fill<_D3DDISPLAYMODE *,_D3DDISPLAYMODE>
PUBLIC	??$_Umove@PAU_D3DDISPLAYMODE@@@?$vector@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@IAEPAU_D3DDISPLAYMODE@@PAU2@00@Z ; std::vector<_D3DDISPLAYMODE,std::allocator<_D3DDISPLAYMODE> >::_Umove<_D3DDISPLAYMODE *>
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Insert_n@?$vector@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@IAEXV?$_Vector_const_iterator@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@2@IABU_D3DDISPLAYMODE@@@Z$5 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@IAEXV?$_Vector_const_iterator@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@2@IABU_D3DDISPLAYMODE@@@Z$2
__catchsym$?_Insert_n@?$vector@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@IAEXV?$_Vector_const_iterator@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@2@IABU_D3DDISPLAYMODE@@@Z$4 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@IAEXV?$_Vector_const_iterator@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@2@IABU_D3DDISPLAYMODE@@@Z$0
__unwindtable$?_Insert_n@?$vector@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@IAEXV?$_Vector_const_iterator@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@2@IABU_D3DDISPLAYMODE@@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$?_Insert_n@?$vector@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@IAEXV?$_Vector_const_iterator@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@2@IABU_D3DDISPLAYMODE@@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Insert_n@?$vector@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@IAEXV?$_Vector_const_iterator@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@2@IABU_D3DDISPLAYMODE@@@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Insert_n@?$vector@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@IAEXV?$_Vector_const_iterator@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@2@IABU_D3DDISPLAYMODE@@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__tryblocktable$?_Insert_n@?$vector@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@IAEXV?$_Vector_const_iterator@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@2@IABU_D3DDISPLAYMODE@@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@IAEXV?$_Vector_const_iterator@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@2@IABU_D3DDISPLAYMODE@@@Z$4
	DD	02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@IAEXV?$_Vector_const_iterator@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@2@IABU_D3DDISPLAYMODE@@@Z$5
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?_Insert_n@?$vector@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@IAEXV?$_Vector_const_iterator@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@2@IABU_D3DDISPLAYMODE@@@Z
_TEXT	SEGMENT
tv84 = -76						; size = 4
_this$ = -72						; size = 4
__Tmp$134305 = -68					; size = 16
__Oldend$134306 = -52					; size = 4
__Tmp$134295 = -48					; size = 16
__Ncopied$134282 = -32					; size = 4
__Newvec$134280 = -28					; size = 4
__Whereoff$134281 = -24					; size = 4
__Capacity$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Where$ = 8						; size = 8
__Count$ = 16						; size = 4
__Val$ = 20						; size = 4
?_Insert_n@?$vector@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@IAEXV?$_Vector_const_iterator@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@2@IABU_D3DDISPLAYMODE@@@Z PROC ; std::vector<_D3DDISPLAYMODE,std::allocator<_D3DDISPLAYMODE> >::_Insert_n, COMDAT
; _this$ = ecx

; 1153 : 		{	// insert _Count * _Val at _Where

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Insert_n@?$vector@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@IAEXV?$_Vector_const_iterator@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@2@IABU_D3DDISPLAYMODE@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 60					; 0000003cH
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1154 : 
; 1155 :  #if _HAS_ITERATOR_DEBUGGING
; 1156 : 		if (_Where._Mycont != this
; 1157 : 			|| _Where._Myptr < _Myfirst || _Mylast < _Where._Myptr)
; 1158 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1159 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1160 : 
; 1161 : 		size_type _Capacity = capacity();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?capacity@?$vector@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@QBEIXZ ; std::vector<_D3DDISPLAYMODE,std::allocator<_D3DDISPLAYMODE> >::capacity
	mov	DWORD PTR __Capacity$[ebp], eax

; 1162 : 
; 1163 : 		if (_Count == 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN14@Insert_n@7
	jmp	$LN16@Insert_n@7
$LN14@Insert_n@7:

; 1164 : 			;
; 1165 : 		else if (max_size() - size() < _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@QBEIXZ ; std::vector<_D3DDISPLAYMODE,std::allocator<_D3DDISPLAYMODE> >::max_size
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@QBEIXZ ; std::vector<_D3DDISPLAYMODE,std::allocator<_D3DDISPLAYMODE> >::size
	sub	esi, eax
	cmp	esi, DWORD PTR __Count$[ebp]
	jae	SHORT $LN12@Insert_n@7

; 1166 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@KAXXZ ; std::vector<_D3DDISPLAYMODE,std::allocator<_D3DDISPLAYMODE> >::_Xlen
	jmp	$LN16@Insert_n@7
$LN12@Insert_n@7:

; 1167 : 		else if (_Capacity < size() + _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@QBEIXZ ; std::vector<_D3DDISPLAYMODE,std::allocator<_D3DDISPLAYMODE> >::size
	add	eax, DWORD PTR __Count$[ebp]
	cmp	DWORD PTR __Capacity$[ebp], eax
	jae	$LN10@Insert_n@7

; 1168 : 			{	// not enough room, reallocate
; 1169 : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1170 : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@QBEIXZ ; std::vector<_D3DDISPLAYMODE,std::allocator<_D3DDISPLAYMODE> >::max_size
	mov	ecx, DWORD PTR __Capacity$[ebp]
	shr	ecx, 1
	sub	eax, ecx
	cmp	eax, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN17@Insert_n@7
	mov	DWORD PTR tv84[ebp], 0
	jmp	SHORT $LN18@Insert_n@7
$LN17@Insert_n@7:
	mov	edx, DWORD PTR __Capacity$[ebp]
	shr	edx, 1
	add	edx, DWORD PTR __Capacity$[ebp]
	mov	DWORD PTR tv84[ebp], edx
$LN18@Insert_n@7:
	mov	eax, DWORD PTR tv84[ebp]
	mov	DWORD PTR __Capacity$[ebp], eax

; 1171 : 			if (_Capacity < size() + _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@QBEIXZ ; std::vector<_D3DDISPLAYMODE,std::allocator<_D3DDISPLAYMODE> >::size
	add	eax, DWORD PTR __Count$[ebp]
	cmp	DWORD PTR __Capacity$[ebp], eax
	jae	SHORT $LN9@Insert_n@7

; 1172 : 				_Capacity = size() + _Count;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@QBEIXZ ; std::vector<_D3DDISPLAYMODE,std::allocator<_D3DDISPLAYMODE> >::size
	add	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Capacity$[ebp], eax
$LN9@Insert_n@7:

; 1173 : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

	mov	ecx, DWORD PTR __Capacity$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?allocate@?$allocator@U_D3DDISPLAYMODE@@@std@@QAEPAU_D3DDISPLAYMODE@@I@Z ; std::allocator<_D3DDISPLAYMODE>::allocate
	mov	DWORD PTR __Newvec$134280[ebp], eax

; 1174 : 			size_type _Whereoff = _VEC_ITER_BASE(_Where) - _Myfirst;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Where$[ebp+4]
	sub	eax, DWORD PTR [edx+12]
	sar	eax, 4
	mov	DWORD PTR __Whereoff$134281[ebp], eax

; 1175 : 			int _Ncopied = 0;

	mov	DWORD PTR __Ncopied$134282[ebp], 0

; 1176 : 
; 1177 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1178 : 			_Ufill(_Newvec + _Whereoff, _Count, _Val);	// add new stuff

	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __Whereoff$134281[ebp]
	shl	eax, 4
	add	eax, DWORD PTR __Newvec$134280[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Ufill@?$vector@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@IAEPAU_D3DDISPLAYMODE@@PAU3@IABU3@@Z ; std::vector<_D3DDISPLAYMODE,std::allocator<_D3DDISPLAYMODE> >::_Ufill

; 1179 : 			++_Ncopied;

	mov	ecx, DWORD PTR __Ncopied$134282[ebp]
	add	ecx, 1
	mov	DWORD PTR __Ncopied$134282[ebp], ecx

; 1180 : 			_Umove(this->_Myfirst, _VEC_ITER_BASE(_Where),
; 1181 : 				_Newvec);	// move prefix

	mov	edx, DWORD PTR __Newvec$134280[ebp]
	push	edx
	mov	eax, DWORD PTR __Where$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Umove@PAU_D3DDISPLAYMODE@@@?$vector@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@IAEPAU_D3DDISPLAYMODE@@PAU2@00@Z ; std::vector<_D3DDISPLAYMODE,std::allocator<_D3DDISPLAYMODE> >::_Umove<_D3DDISPLAYMODE *>

; 1182 : 			++_Ncopied;

	mov	eax, DWORD PTR __Ncopied$134282[ebp]
	add	eax, 1
	mov	DWORD PTR __Ncopied$134282[ebp], eax

; 1183 : 			_Umove(_VEC_ITER_BASE(_Where), this->_Mylast,
; 1184 : 				_Newvec + (_Whereoff + _Count));	// move suffix

	mov	ecx, DWORD PTR __Whereoff$134281[ebp]
	add	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 4
	add	ecx, DWORD PTR __Newvec$134280[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp+4]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Umove@PAU_D3DDISPLAYMODE@@@?$vector@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@IAEPAU_D3DDISPLAYMODE@@PAU2@00@Z ; std::vector<_D3DDISPLAYMODE,std::allocator<_D3DDISPLAYMODE> >::_Umove<_D3DDISPLAYMODE *>
	jmp	SHORT $LN19@Insert_n@7
__catch$?_Insert_n@?$vector@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@IAEXV?$_Vector_const_iterator@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@2@IABU_D3DDISPLAYMODE@@@Z$0:

; 1185 : 			_CATCH_ALL
; 1186 : 			if (1 < _Ncopied)

	cmp	DWORD PTR __Ncopied$134282[ebp], 1
	jle	SHORT $LN7@Insert_n@7

; 1187 : 				_Destroy(_Newvec, _Newvec + _Whereoff);

	mov	edx, DWORD PTR __Whereoff$134281[ebp]
	shl	edx, 4
	add	edx, DWORD PTR __Newvec$134280[ebp]
	push	edx
	mov	eax, DWORD PTR __Newvec$134280[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@IAEXPAU_D3DDISPLAYMODE@@0@Z ; std::vector<_D3DDISPLAYMODE,std::allocator<_D3DDISPLAYMODE> >::_Destroy
$LN7@Insert_n@7:

; 1188 : 			if (0 < _Ncopied)

	cmp	DWORD PTR __Ncopied$134282[ebp], 0
	jle	SHORT $LN6@Insert_n@7

; 1189 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);

	mov	ecx, DWORD PTR __Whereoff$134281[ebp]
	shl	ecx, 4
	add	ecx, DWORD PTR __Newvec$134280[ebp]
	mov	edx, DWORD PTR __Count$[ebp]
	shl	edx, 4
	add	ecx, edx
	push	ecx
	mov	eax, DWORD PTR __Whereoff$134281[ebp]
	shl	eax, 4
	add	eax, DWORD PTR __Newvec$134280[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@IAEXPAU_D3DDISPLAYMODE@@0@Z ; std::vector<_D3DDISPLAYMODE,std::allocator<_D3DDISPLAYMODE> >::_Destroy
$LN6@Insert_n@7:

; 1190 : 			this->_Alval.deallocate(_Newvec, _Capacity);

	mov	ecx, DWORD PTR __Capacity$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Newvec$134280[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?deallocate@?$allocator@U_D3DDISPLAYMODE@@@std@@QAEXPAU_D3DDISPLAYMODE@@I@Z ; std::allocator<_D3DDISPLAYMODE>::deallocate

; 1191 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1192 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$?_Insert_n@?$vector@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@IAEXV?$_Vector_const_iterator@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@2@IABU_D3DDISPLAYMODE@@@Z$1
	ret	0
$LN19@Insert_n@7:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Insert_n@?$vector@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@IAEXV?$_Vector_const_iterator@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@2@IABU_D3DDISPLAYMODE@@@Z$1:

; 1193 : 
; 1194 : 			_Count += size();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@QBEIXZ ; std::vector<_D3DDISPLAYMODE,std::allocator<_D3DDISPLAYMODE> >::size
	add	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Count$[ebp], eax

; 1195 : 			if (_Myfirst != 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	je	SHORT $LN5@Insert_n@7

; 1196 : 				{	// destroy and deallocate old array
; 1197 : 				_Destroy(_Myfirst, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@IAEXPAU_D3DDISPLAYMODE@@0@Z ; std::vector<_D3DDISPLAYMODE,std::allocator<_D3DDISPLAYMODE> >::_Destroy

; 1198 : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+20]
	sub	ecx, DWORD PTR [eax+12]
	sar	ecx, 4
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?deallocate@?$allocator@U_D3DDISPLAYMODE@@@std@@QAEXPAU_D3DDISPLAYMODE@@I@Z ; std::allocator<_D3DDISPLAYMODE>::deallocate
$LN5@Insert_n@7:

; 1199 : 				}
; 1200 : 
; 1201 :  #if _HAS_ITERATOR_DEBUGGING
; 1202 : 			this->_Orphan_all();
; 1203 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1204 : 
; 1205 : 			_Myend = _Newvec + _Capacity;

	mov	ecx, DWORD PTR __Capacity$[ebp]
	shl	ecx, 4
	add	ecx, DWORD PTR __Newvec$134280[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+20], ecx

; 1206 : 			_Mylast = _Newvec + _Count;

	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 4
	add	eax, DWORD PTR __Newvec$134280[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 1207 : 			_Myfirst = _Newvec;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Newvec$134280[ebp]
	mov	DWORD PTR [edx+12], eax
	jmp	$LN16@Insert_n@7
$LN10@Insert_n@7:

; 1208 : 			}
; 1209 : 		else if ((size_type)(_Mylast - _VEC_ITER_BASE(_Where)) < _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	sub	edx, DWORD PTR __Where$[ebp+4]
	sar	edx, 4
	cmp	edx, DWORD PTR __Count$[ebp]
	jae	$LN3@Insert_n@7

; 1210 : 			{	// new stuff spills off end
; 1211 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Tmp$134295[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR __Tmp$134295[ebp+4], edx
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR __Tmp$134295[ebp+8], ecx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR __Tmp$134295[ebp+12], edx

; 1212 : 
; 1213 : 			_Umove(_VEC_ITER_BASE(_Where), _Mylast,
; 1214 : 				_VEC_ITER_BASE(_Where) + _Count);	// copy suffix

	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 4
	add	eax, DWORD PTR __Where$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR __Where$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Umove@PAU_D3DDISPLAYMODE@@@?$vector@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@IAEPAU_D3DDISPLAYMODE@@PAU2@00@Z ; std::vector<_D3DDISPLAYMODE,std::allocator<_D3DDISPLAYMODE> >::_Umove<_D3DDISPLAYMODE *>

; 1215 : 
; 1216 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 2

; 1217 : 			_Ufill(_Mylast, _Count - (_Mylast - _VEC_ITER_BASE(_Where)),
; 1218 : 				_Tmp);	// insert new stuff off end

	lea	ecx, DWORD PTR __Tmp$134295[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	sub	eax, DWORD PTR __Where$[ebp+4]
	sar	eax, 4
	mov	ecx, DWORD PTR __Count$[ebp]
	sub	ecx, eax
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Ufill@?$vector@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@IAEPAU_D3DDISPLAYMODE@@PAU3@IABU3@@Z ; std::vector<_D3DDISPLAYMODE,std::allocator<_D3DDISPLAYMODE> >::_Ufill
	jmp	SHORT $LN21@Insert_n@7
__catch$?_Insert_n@?$vector@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@IAEXV?$_Vector_const_iterator@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@2@IABU_D3DDISPLAYMODE@@@Z$2:

; 1219 : 			_CATCH_ALL
; 1220 : 			_Destroy(_VEC_ITER_BASE(_Where) + _Count, _Mylast + _Count);

	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+16]
	push	ecx
	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 4
	add	eax, DWORD PTR __Where$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@IAEXPAU_D3DDISPLAYMODE@@0@Z ; std::vector<_D3DDISPLAYMODE,std::allocator<_D3DDISPLAYMODE> >::_Destroy

; 1221 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1222 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$?_Insert_n@?$vector@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@IAEXV?$_Vector_const_iterator@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@2@IABU_D3DDISPLAYMODE@@@Z$3
	ret	0
$LN21@Insert_n@7:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Insert_n@?$vector@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@IAEXV?$_Vector_const_iterator@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@2@IABU_D3DDISPLAYMODE@@@Z$3:

; 1223 : 
; 1224 : 			_Mylast += _Count;

	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+16]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+16], ecx

; 1225 : 
; 1226 :  #if _HAS_ITERATOR_DEBUGGING
; 1227 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1228 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1229 : 
; 1230 : 			std::fill(_VEC_ITER_BASE(_Where), _Mylast - _Count,
; 1231 : 				_Tmp);	// insert up to old end

	lea	ecx, DWORD PTR __Tmp$134295[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count$[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	sub	ecx, edx
	push	ecx
	mov	edx, DWORD PTR __Where$[ebp+4]
	push	edx
	call	??$fill@PAU_D3DDISPLAYMODE@@U1@@std@@YAXPAU_D3DDISPLAYMODE@@0ABU1@@Z ; std::fill<_D3DDISPLAYMODE *,_D3DDISPLAYMODE>
	add	esp, 12					; 0000000cH

; 1232 : 			}
; 1233 : 		else

	jmp	SHORT $LN16@Insert_n@7
$LN3@Insert_n@7:

; 1234 : 			{	// new stuff can all be assigned
; 1235 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Tmp$134305[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR __Tmp$134305[ebp+4], edx
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR __Tmp$134305[ebp+8], ecx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR __Tmp$134305[ebp+12], edx

; 1236 : 
; 1237 : 			pointer _Oldend = _Mylast;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR __Oldend$134306[ebp], ecx

; 1238 : 			_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1239 : 				_Mylast);	// copy suffix

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR __Oldend$134306[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count$[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR __Oldend$134306[ebp]
	sub	eax, edx
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Umove@PAU_D3DDISPLAYMODE@@@?$vector@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@IAEPAU_D3DDISPLAYMODE@@PAU2@00@Z ; std::vector<_D3DDISPLAYMODE,std::allocator<_D3DDISPLAYMODE> >::_Umove<_D3DDISPLAYMODE *>
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 1240 : 
; 1241 :  #if _HAS_ITERATOR_DEBUGGING
; 1242 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1243 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1244 : 
; 1245 : 			_STDEXT _Unchecked_move_backward(_VEC_ITER_BASE(_Where), _Oldend - _Count,
; 1246 : 				_Oldend);	// copy hole

	mov	edx, DWORD PTR __Oldend$134306[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR __Oldend$134306[ebp]
	sub	ecx, eax
	push	ecx
	mov	edx, DWORD PTR __Where$[ebp+4]
	push	edx
	call	??$_Unchecked_move_backward@PAU_D3DDISPLAYMODE@@PAU1@@stdext@@YAPAU_D3DDISPLAYMODE@@PAU1@00@Z ; stdext::_Unchecked_move_backward<_D3DDISPLAYMODE *,_D3DDISPLAYMODE *>
	add	esp, 12					; 0000000cH

; 1247 : 			std::fill(_VEC_ITER_BASE(_Where), _VEC_ITER_BASE(_Where) + _Count,
; 1248 : 				_Tmp);	// insert into hole

	lea	eax, DWORD PTR __Tmp$134305[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 4
	add	ecx, DWORD PTR __Where$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR __Where$[ebp+4]
	push	edx
	call	??$fill@PAU_D3DDISPLAYMODE@@U1@@std@@YAXPAU_D3DDISPLAYMODE@@0ABU1@@Z ; std::fill<_D3DDISPLAYMODE *,_D3DDISPLAYMODE>
	add	esp, 12					; 0000000cH
$LN16@Insert_n@7:

; 1249 : 			}
; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Insert_n@?$vector@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@IAEXV?$_Vector_const_iterator@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@2@IABU_D3DDISPLAYMODE@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-80]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Insert_n@?$vector@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@IAEXV?$_Vector_const_iterator@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@2@IABU_D3DDISPLAYMODE@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Insert_n@?$vector@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@IAEXV?$_Vector_const_iterator@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@2@IABU_D3DDISPLAYMODE@@@Z ENDP ; std::vector<_D3DDISPLAYMODE,std::allocator<_D3DDISPLAYMODE> >::_Insert_n
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@KAXXZ$0
__ehfuncinfo$?_Xlen@?$vector@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@KAXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T142739 = -80						; size = 28
$T142738 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@KAXXZ PROC ; std::vector<_D3DDISPLAYMODE,std::allocator<_D3DDISPLAYMODE> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Xlen@?$vector@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T142739[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR $T142739[ebp]
	push	eax
	lea	ecx, DWORD PTR $T142738[ebp]
	call	??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::length_error::length_error
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T142738[ebp]
	push	ecx
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T142739[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN2@Xlen@7:

; 1261 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T142739[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?_Xlen@?$vector@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@KAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@KAXXZ ENDP ; std::vector<_D3DDISPLAYMODE,std::allocator<_D3DDISPLAYMODE> >::_Xlen
PUBLIC	??$?0U_D3DDISPLAYMODE@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@U_D3DDISPLAYMODE@@@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><_D3DDISPLAYMODE>
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??0?$_Container_base_aux_alloc_real@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@IAE@V?$allocator@U_D3DDISPLAYMODE@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@IAE@V?$allocator@U_D3DDISPLAYMODE@@@1@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@IAE@V?$allocator@U_D3DDISPLAYMODE@@@1@@Z$1
__ehfuncinfo$??0?$_Container_base_aux_alloc_real@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@IAE@V?$allocator@U_D3DDISPLAYMODE@@@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0?$_Container_base_aux_alloc_real@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@IAE@V?$allocator@U_D3DDISPLAYMODE@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Container_base_aux_alloc_real@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@IAE@V?$allocator@U_D3DDISPLAYMODE@@@1@@Z
_TEXT	SEGMENT
tv133 = -32						; size = 4
_this$ = -28						; size = 4
$T142751 = -24						; size = 4
$T142750 = -20						; size = 4
$T142749 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 1
??0?$_Container_base_aux_alloc_real@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@IAE@V?$allocator@U_D3DDISPLAYMODE@@@1@@Z PROC ; std::_Container_base_aux_alloc_real<std::allocator<_D3DDISPLAYMODE> >::_Container_base_aux_alloc_real<std::allocator<_D3DDISPLAYMODE> >, COMDAT
; _this$ = ecx

; 419  : 		{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Container_base_aux_alloc_real@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@IAE@V?$allocator@U_D3DDISPLAYMODE@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 20					; 00000014H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::_Container_base_aux
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??$?0U_D3DDISPLAYMODE@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@U_D3DDISPLAYMODE@@@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><_D3DDISPLAYMODE>

; 420  : 		_Myownedaux = new (_Alaux.allocate(1)) _Aux_cont(this);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?allocate@?$allocator@V_Aux_cont@std@@@std@@QAEPAV_Aux_cont@2@I@Z ; std::allocator<std::_Aux_cont>::allocate
	mov	DWORD PTR $T142751[ebp], eax
	mov	ecx, DWORD PTR $T142751[ebp]
	push	ecx
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T142750[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	cmp	DWORD PTR $T142750[ebp], 0
	je	SHORT $LN3@Container_@7
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T142750[ebp]
	call	??0_Aux_cont@std@@QAE@QBV_Container_base_aux@1@@Z ; std::_Aux_cont::_Aux_cont
	mov	DWORD PTR tv133[ebp], eax
	jmp	SHORT $LN4@Container_@7
$LN3@Container_@7:
	mov	DWORD PTR tv133[ebp], 0
$LN4@Container_@7:
	mov	eax, DWORD PTR tv133[ebp]
	mov	DWORD PTR $T142749[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T142749[ebp]
	mov	DWORD PTR [ecx], edx

; 421  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@IAE@V?$allocator@U_D3DDISPLAYMODE@@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@IAE@V?$allocator@U_D3DDISPLAYMODE@@@1@@Z$1:
	mov	eax, DWORD PTR $T142751[ebp]
	push	eax
	mov	ecx, DWORD PTR $T142750[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??0?$_Container_base_aux_alloc_real@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@IAE@V?$allocator@U_D3DDISPLAYMODE@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Container_base_aux_alloc_real@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@IAE@V?$allocator@U_D3DDISPLAYMODE@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Container_base_aux_alloc_real@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@IAE@V?$allocator@U_D3DDISPLAYMODE@@@1@@Z ENDP ; std::_Container_base_aux_alloc_real<std::allocator<_D3DDISPLAYMODE> >::_Container_base_aux_alloc_real<std::allocator<_D3DDISPLAYMODE> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@U_D3DDISPLAYMODE@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$allocator@U_D3DDISPLAYMODE@@@std@@QAE@ABV01@@Z PROC ; std::allocator<_D3DDISPLAYMODE>::allocator<_D3DDISPLAYMODE>, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$allocator@U_D3DDISPLAYMODE@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<_D3DDISPLAYMODE>::allocator<_D3DDISPLAYMODE>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@U_D3DDISPLAYMODE@@@std@@QAEXPAU_D3DDISPLAYMODE@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@U_D3DDISPLAYMODE@@@std@@QAEXPAU_D3DDISPLAYMODE@@I@Z PROC ; std::allocator<_D3DDISPLAYMODE>::deallocate, COMDAT
; _this$ = ecx

; 139  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 141  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@U_D3DDISPLAYMODE@@@std@@QAEXPAU_D3DDISPLAYMODE@@I@Z ENDP ; std::allocator<_D3DDISPLAYMODE>::deallocate
_TEXT	ENDS
PUBLIC	??$_Allocate@U_D3DDISPLAYMODE@@@std@@YAPAU_D3DDISPLAYMODE@@IPAU1@@Z ; std::_Allocate<_D3DDISPLAYMODE>
; Function compile flags: /Odtp
;	COMDAT ?allocate@?$allocator@U_D3DDISPLAYMODE@@@std@@QAEPAU_D3DDISPLAYMODE@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@U_D3DDISPLAYMODE@@@std@@QAEPAU_D3DDISPLAYMODE@@I@Z PROC ; std::allocator<_D3DDISPLAYMODE>::allocate, COMDAT
; _this$ = ecx

; 144  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@U_D3DDISPLAYMODE@@@std@@YAPAU_D3DDISPLAYMODE@@IPAU1@@Z ; std::_Allocate<_D3DDISPLAYMODE>
	add	esp, 8

; 146  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@U_D3DDISPLAYMODE@@@std@@QAEPAU_D3DDISPLAYMODE@@I@Z ENDP ; std::allocator<_D3DDISPLAYMODE>::allocate
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?begin@?$vector@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@2@XZ PROC ; std::vector<Ogre::D3DDEVICEINFO_T *,std::allocator<Ogre::D3DDEVICEINFO_T *> >::begin, COMDAT
; _this$ = ecx

; 640  : 		{	// return iterator for beginning of mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 641  : 		return (iterator(_Myfirst, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@QAE@PAPAUD3DDEVICEINFO_T@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::D3DDEVICEINFO_T *,std::allocator<Ogre::D3DDEVICEINFO_T *> >::_Vector_iterator<Ogre::D3DDEVICEINFO_T *,std::allocator<Ogre::D3DDEVICEINFO_T *> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 642  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?begin@?$vector@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@2@XZ ENDP ; std::vector<Ogre::D3DDEVICEINFO_T *,std::allocator<Ogre::D3DDEVICEINFO_T *> >::begin
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@QBEIXZ ; std::allocator<Ogre::D3DDEVICEINFO_T *>::max_size
; Function compile flags: /Odtp
;	COMDAT ?max_size@?$vector@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$vector@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@QBEIXZ PROC ; std::vector<Ogre::D3DDEVICEINFO_T *,std::allocator<Ogre::D3DDEVICEINFO_T *> >::max_size, COMDAT
; _this$ = ecx

; 730  : 		{	// return maximum possible length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 731  : 		return (this->_Alval.max_size());

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?max_size@?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@QBEIXZ ; std::allocator<Ogre::D3DDEVICEINFO_T *>::max_size

; 732  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$vector@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@QBEIXZ ENDP ; std::vector<Ogre::D3DDEVICEINFO_T *,std::allocator<Ogre::D3DDEVICEINFO_T *> >::max_size
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@YAXPAPAUD3DDEVICEINFO_T@Ogre@@0AAV?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@0@@Z ; std::_Destroy_range<std::allocator<Ogre::D3DDEVICEINFO_T *> >
; Function compile flags: /Odtp
;	COMDAT ?_Destroy@?$vector@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@IAEXPAPAUD3DDEVICEINFO_T@Ogre@@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@IAEXPAPAUD3DDEVICEINFO_T@Ogre@@0@Z PROC ; std::vector<Ogre::D3DDEVICEINFO_T *,std::allocator<Ogre::D3DDEVICEINFO_T *> >::_Destroy, COMDAT
; _this$ = ecx

; 1118 : 		{	// destroy [_First, _Last) using allocator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Destroy_range@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@YAXPAPAUD3DDEVICEINFO_T@Ogre@@0AAV?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@0@@Z ; std::_Destroy_range<std::allocator<Ogre::D3DDEVICEINFO_T *> >
	add	esp, 12					; 0000000cH

; 1120 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?_Destroy@?$vector@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@IAEXPAPAUD3DDEVICEINFO_T@Ogre@@0@Z ENDP ; std::vector<Ogre::D3DDEVICEINFO_T *,std::allocator<Ogre::D3DDEVICEINFO_T *> >::_Destroy
_TEXT	ENDS
PUBLIC	??$_Unchecked_move_backward@PAPAUD3DDEVICEINFO_T@Ogre@@PAPAU12@@stdext@@YAPAPAUD3DDEVICEINFO_T@Ogre@@PAPAU12@00@Z ; stdext::_Unchecked_move_backward<Ogre::D3DDEVICEINFO_T * *,Ogre::D3DDEVICEINFO_T * *>
PUBLIC	??$fill@PAPAUD3DDEVICEINFO_T@Ogre@@PAU12@@std@@YAXPAPAUD3DDEVICEINFO_T@Ogre@@0ABQAU12@@Z ; std::fill<Ogre::D3DDEVICEINFO_T * *,Ogre::D3DDEVICEINFO_T *>
PUBLIC	??$_Umove@PAPAUD3DDEVICEINFO_T@Ogre@@@?$vector@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@IAEPAPAUD3DDEVICEINFO_T@Ogre@@PAPAU23@00@Z ; std::vector<Ogre::D3DDEVICEINFO_T *,std::allocator<Ogre::D3DDEVICEINFO_T *> >::_Umove<Ogre::D3DDEVICEINFO_T * *>
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Insert_n@?$vector@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@2@IABQAUD3DDEVICEINFO_T@Ogre@@@Z$5 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@2@IABQAUD3DDEVICEINFO_T@Ogre@@@Z$2
__catchsym$?_Insert_n@?$vector@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@2@IABQAUD3DDEVICEINFO_T@Ogre@@@Z$4 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@2@IABQAUD3DDEVICEINFO_T@Ogre@@@Z$0
__unwindtable$?_Insert_n@?$vector@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@2@IABQAUD3DDEVICEINFO_T@Ogre@@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$?_Insert_n@?$vector@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@2@IABQAUD3DDEVICEINFO_T@Ogre@@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Insert_n@?$vector@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@2@IABQAUD3DDEVICEINFO_T@Ogre@@@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Insert_n@?$vector@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@2@IABQAUD3DDEVICEINFO_T@Ogre@@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__tryblocktable$?_Insert_n@?$vector@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@2@IABQAUD3DDEVICEINFO_T@Ogre@@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@2@IABQAUD3DDEVICEINFO_T@Ogre@@@Z$4
	DD	02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@2@IABQAUD3DDEVICEINFO_T@Ogre@@@Z$5
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?_Insert_n@?$vector@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@2@IABQAUD3DDEVICEINFO_T@Ogre@@@Z
_TEXT	SEGMENT
tv84 = -52						; size = 4
_this$ = -48						; size = 4
__Tmp$134391 = -44					; size = 4
__Oldend$134392 = -40					; size = 4
__Tmp$134381 = -36					; size = 4
__Ncopied$134368 = -32					; size = 4
__Newvec$134366 = -28					; size = 4
__Whereoff$134367 = -24					; size = 4
__Capacity$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Where$ = 8						; size = 8
__Count$ = 16						; size = 4
__Val$ = 20						; size = 4
?_Insert_n@?$vector@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@2@IABQAUD3DDEVICEINFO_T@Ogre@@@Z PROC ; std::vector<Ogre::D3DDEVICEINFO_T *,std::allocator<Ogre::D3DDEVICEINFO_T *> >::_Insert_n, COMDAT
; _this$ = ecx

; 1153 : 		{	// insert _Count * _Val at _Where

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Insert_n@?$vector@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@2@IABQAUD3DDEVICEINFO_T@Ogre@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 36					; 00000024H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1154 : 
; 1155 :  #if _HAS_ITERATOR_DEBUGGING
; 1156 : 		if (_Where._Mycont != this
; 1157 : 			|| _Where._Myptr < _Myfirst || _Mylast < _Where._Myptr)
; 1158 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1159 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1160 : 
; 1161 : 		size_type _Capacity = capacity();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?capacity@?$vector@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::D3DDEVICEINFO_T *,std::allocator<Ogre::D3DDEVICEINFO_T *> >::capacity
	mov	DWORD PTR __Capacity$[ebp], eax

; 1162 : 
; 1163 : 		if (_Count == 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN14@Insert_n@8
	jmp	$LN16@Insert_n@8
$LN14@Insert_n@8:

; 1164 : 			;
; 1165 : 		else if (max_size() - size() < _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::D3DDEVICEINFO_T *,std::allocator<Ogre::D3DDEVICEINFO_T *> >::max_size
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::D3DDEVICEINFO_T *,std::allocator<Ogre::D3DDEVICEINFO_T *> >::size
	sub	esi, eax
	cmp	esi, DWORD PTR __Count$[ebp]
	jae	SHORT $LN12@Insert_n@8

; 1166 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@KAXXZ ; std::vector<Ogre::D3DDEVICEINFO_T *,std::allocator<Ogre::D3DDEVICEINFO_T *> >::_Xlen
	jmp	$LN16@Insert_n@8
$LN12@Insert_n@8:

; 1167 : 		else if (_Capacity < size() + _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::D3DDEVICEINFO_T *,std::allocator<Ogre::D3DDEVICEINFO_T *> >::size
	add	eax, DWORD PTR __Count$[ebp]
	cmp	DWORD PTR __Capacity$[ebp], eax
	jae	$LN10@Insert_n@8

; 1168 : 			{	// not enough room, reallocate
; 1169 : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1170 : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::D3DDEVICEINFO_T *,std::allocator<Ogre::D3DDEVICEINFO_T *> >::max_size
	mov	ecx, DWORD PTR __Capacity$[ebp]
	shr	ecx, 1
	sub	eax, ecx
	cmp	eax, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN17@Insert_n@8
	mov	DWORD PTR tv84[ebp], 0
	jmp	SHORT $LN18@Insert_n@8
$LN17@Insert_n@8:
	mov	edx, DWORD PTR __Capacity$[ebp]
	shr	edx, 1
	add	edx, DWORD PTR __Capacity$[ebp]
	mov	DWORD PTR tv84[ebp], edx
$LN18@Insert_n@8:
	mov	eax, DWORD PTR tv84[ebp]
	mov	DWORD PTR __Capacity$[ebp], eax

; 1171 : 			if (_Capacity < size() + _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::D3DDEVICEINFO_T *,std::allocator<Ogre::D3DDEVICEINFO_T *> >::size
	add	eax, DWORD PTR __Count$[ebp]
	cmp	DWORD PTR __Capacity$[ebp], eax
	jae	SHORT $LN9@Insert_n@8

; 1172 : 				_Capacity = size() + _Count;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::D3DDEVICEINFO_T *,std::allocator<Ogre::D3DDEVICEINFO_T *> >::size
	add	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Capacity$[ebp], eax
$LN9@Insert_n@8:

; 1173 : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

	mov	ecx, DWORD PTR __Capacity$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?allocate@?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@QAEPAPAUD3DDEVICEINFO_T@Ogre@@I@Z ; std::allocator<Ogre::D3DDEVICEINFO_T *>::allocate
	mov	DWORD PTR __Newvec$134366[ebp], eax

; 1174 : 			size_type _Whereoff = _VEC_ITER_BASE(_Where) - _Myfirst;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Where$[ebp+4]
	sub	eax, DWORD PTR [edx+12]
	sar	eax, 2
	mov	DWORD PTR __Whereoff$134367[ebp], eax

; 1175 : 			int _Ncopied = 0;

	mov	DWORD PTR __Ncopied$134368[ebp], 0

; 1176 : 
; 1177 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1178 : 			_Ufill(_Newvec + _Whereoff, _Count, _Val);	// add new stuff

	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __Whereoff$134367[ebp]
	mov	ecx, DWORD PTR __Newvec$134366[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Ufill@?$vector@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@IAEPAPAUD3DDEVICEINFO_T@Ogre@@PAPAU34@IABQAU34@@Z ; std::vector<Ogre::D3DDEVICEINFO_T *,std::allocator<Ogre::D3DDEVICEINFO_T *> >::_Ufill

; 1179 : 			++_Ncopied;

	mov	eax, DWORD PTR __Ncopied$134368[ebp]
	add	eax, 1
	mov	DWORD PTR __Ncopied$134368[ebp], eax

; 1180 : 			_Umove(this->_Myfirst, _VEC_ITER_BASE(_Where),
; 1181 : 				_Newvec);	// move prefix

	mov	ecx, DWORD PTR __Newvec$134366[ebp]
	push	ecx
	mov	edx, DWORD PTR __Where$[ebp+4]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Umove@PAPAUD3DDEVICEINFO_T@Ogre@@@?$vector@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@IAEPAPAUD3DDEVICEINFO_T@Ogre@@PAPAU23@00@Z ; std::vector<Ogre::D3DDEVICEINFO_T *,std::allocator<Ogre::D3DDEVICEINFO_T *> >::_Umove<Ogre::D3DDEVICEINFO_T * *>

; 1182 : 			++_Ncopied;

	mov	edx, DWORD PTR __Ncopied$134368[ebp]
	add	edx, 1
	mov	DWORD PTR __Ncopied$134368[ebp], edx

; 1183 : 			_Umove(_VEC_ITER_BASE(_Where), this->_Mylast,
; 1184 : 				_Newvec + (_Whereoff + _Count));	// move suffix

	mov	eax, DWORD PTR __Whereoff$134367[ebp]
	add	eax, DWORD PTR __Count$[ebp]
	mov	ecx, DWORD PTR __Newvec$134366[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Where$[ebp+4]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Umove@PAPAUD3DDEVICEINFO_T@Ogre@@@?$vector@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@IAEPAPAUD3DDEVICEINFO_T@Ogre@@PAPAU23@00@Z ; std::vector<Ogre::D3DDEVICEINFO_T *,std::allocator<Ogre::D3DDEVICEINFO_T *> >::_Umove<Ogre::D3DDEVICEINFO_T * *>
	jmp	SHORT $LN19@Insert_n@8
__catch$?_Insert_n@?$vector@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@2@IABQAUD3DDEVICEINFO_T@Ogre@@@Z$0:

; 1185 : 			_CATCH_ALL
; 1186 : 			if (1 < _Ncopied)

	cmp	DWORD PTR __Ncopied$134368[ebp], 1
	jle	SHORT $LN7@Insert_n@8

; 1187 : 				_Destroy(_Newvec, _Newvec + _Whereoff);

	mov	eax, DWORD PTR __Whereoff$134367[ebp]
	mov	ecx, DWORD PTR __Newvec$134366[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	push	edx
	mov	eax, DWORD PTR __Newvec$134366[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@IAEXPAPAUD3DDEVICEINFO_T@Ogre@@0@Z ; std::vector<Ogre::D3DDEVICEINFO_T *,std::allocator<Ogre::D3DDEVICEINFO_T *> >::_Destroy
$LN7@Insert_n@8:

; 1188 : 			if (0 < _Ncopied)

	cmp	DWORD PTR __Ncopied$134368[ebp], 0
	jle	SHORT $LN6@Insert_n@8

; 1189 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);

	mov	ecx, DWORD PTR __Whereoff$134367[ebp]
	mov	edx, DWORD PTR __Newvec$134366[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR __Count$[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]
	push	edx
	mov	eax, DWORD PTR __Whereoff$134367[ebp]
	mov	ecx, DWORD PTR __Newvec$134366[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@IAEXPAPAUD3DDEVICEINFO_T@Ogre@@0@Z ; std::vector<Ogre::D3DDEVICEINFO_T *,std::allocator<Ogre::D3DDEVICEINFO_T *> >::_Destroy
$LN6@Insert_n@8:

; 1190 : 			this->_Alval.deallocate(_Newvec, _Capacity);

	mov	eax, DWORD PTR __Capacity$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Newvec$134366[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?deallocate@?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@QAEXPAPAUD3DDEVICEINFO_T@Ogre@@I@Z ; std::allocator<Ogre::D3DDEVICEINFO_T *>::deallocate

; 1191 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1192 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$?_Insert_n@?$vector@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@2@IABQAUD3DDEVICEINFO_T@Ogre@@@Z$1
	ret	0
$LN19@Insert_n@8:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Insert_n@?$vector@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@2@IABQAUD3DDEVICEINFO_T@Ogre@@@Z$1:

; 1193 : 
; 1194 : 			_Count += size();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::D3DDEVICEINFO_T *,std::allocator<Ogre::D3DDEVICEINFO_T *> >::size
	add	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Count$[ebp], eax

; 1195 : 			if (_Myfirst != 0)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+12], 0
	je	SHORT $LN5@Insert_n@8

; 1196 : 				{	// destroy and deallocate old array
; 1197 : 				_Destroy(_Myfirst, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@IAEXPAPAUD3DDEVICEINFO_T@Ogre@@0@Z ; std::vector<Ogre::D3DDEVICEINFO_T *,std::allocator<Ogre::D3DDEVICEINFO_T *> >::_Destroy

; 1198 : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+20]
	sub	eax, DWORD PTR [edx+12]
	sar	eax, 2
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?deallocate@?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@QAEXPAPAUD3DDEVICEINFO_T@Ogre@@I@Z ; std::allocator<Ogre::D3DDEVICEINFO_T *>::deallocate
$LN5@Insert_n@8:

; 1199 : 				}
; 1200 : 
; 1201 :  #if _HAS_ITERATOR_DEBUGGING
; 1202 : 			this->_Orphan_all();
; 1203 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1204 : 
; 1205 : 			_Myend = _Newvec + _Capacity;

	mov	eax, DWORD PTR __Capacity$[ebp]
	mov	ecx, DWORD PTR __Newvec$134366[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], edx

; 1206 : 			_Mylast = _Newvec + _Count;

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Newvec$134366[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 1207 : 			_Myfirst = _Newvec;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Newvec$134366[ebp]
	mov	DWORD PTR [edx+12], eax
	jmp	$LN16@Insert_n@8
$LN10@Insert_n@8:

; 1208 : 			}
; 1209 : 		else if ((size_type)(_Mylast - _VEC_ITER_BASE(_Where)) < _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	sub	edx, DWORD PTR __Where$[ebp+4]
	sar	edx, 2
	cmp	edx, DWORD PTR __Count$[ebp]
	jae	$LN3@Insert_n@8

; 1210 : 			{	// new stuff spills off end
; 1211 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Tmp$134381[ebp], ecx

; 1212 : 
; 1213 : 			_Umove(_VEC_ITER_BASE(_Where), _Mylast,
; 1214 : 				_VEC_ITER_BASE(_Where) + _Count);	// copy suffix

	mov	edx, DWORD PTR __Count$[ebp]
	mov	eax, DWORD PTR __Where$[ebp+4]
	lea	ecx, DWORD PTR [eax+edx*4]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp+4]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Umove@PAPAUD3DDEVICEINFO_T@Ogre@@@?$vector@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@IAEPAPAUD3DDEVICEINFO_T@Ogre@@PAPAU23@00@Z ; std::vector<Ogre::D3DDEVICEINFO_T *,std::allocator<Ogre::D3DDEVICEINFO_T *> >::_Umove<Ogre::D3DDEVICEINFO_T * *>

; 1215 : 
; 1216 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 2

; 1217 : 			_Ufill(_Mylast, _Count - (_Mylast - _VEC_ITER_BASE(_Where)),
; 1218 : 				_Tmp);	// insert new stuff off end

	lea	edx, DWORD PTR __Tmp$134381[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	sub	ecx, DWORD PTR __Where$[ebp+4]
	sar	ecx, 2
	mov	edx, DWORD PTR __Count$[ebp]
	sub	edx, ecx
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Ufill@?$vector@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@IAEPAPAUD3DDEVICEINFO_T@Ogre@@PAPAU34@IABQAU34@@Z ; std::vector<Ogre::D3DDEVICEINFO_T *,std::allocator<Ogre::D3DDEVICEINFO_T *> >::_Ufill
	jmp	SHORT $LN21@Insert_n@8
__catch$?_Insert_n@?$vector@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@2@IABQAUD3DDEVICEINFO_T@Ogre@@@Z$2:

; 1219 : 			_CATCH_ALL
; 1220 : 			_Destroy(_VEC_ITER_BASE(_Where) + _Count, _Mylast + _Count);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR __Count$[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	mov	ecx, DWORD PTR __Where$[ebp+4]
	lea	edx, DWORD PTR [ecx+eax*4]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@IAEXPAPAUD3DDEVICEINFO_T@Ogre@@0@Z ; std::vector<Ogre::D3DDEVICEINFO_T *,std::allocator<Ogre::D3DDEVICEINFO_T *> >::_Destroy

; 1221 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1222 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$?_Insert_n@?$vector@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@2@IABQAUD3DDEVICEINFO_T@Ogre@@@Z$3
	ret	0
$LN21@Insert_n@8:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Insert_n@?$vector@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@2@IABQAUD3DDEVICEINFO_T@Ogre@@@Z$3:

; 1223 : 
; 1224 : 			_Mylast += _Count;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR __Count$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 1225 : 
; 1226 :  #if _HAS_ITERATOR_DEBUGGING
; 1227 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1228 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1229 : 
; 1230 : 			std::fill(_VEC_ITER_BASE(_Where), _Mylast - _Count,
; 1231 : 				_Tmp);	// insert up to old end

	lea	edx, DWORD PTR __Tmp$134381[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 2
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	sub	edx, eax
	push	edx
	mov	eax, DWORD PTR __Where$[ebp+4]
	push	eax
	call	??$fill@PAPAUD3DDEVICEINFO_T@Ogre@@PAU12@@std@@YAXPAPAUD3DDEVICEINFO_T@Ogre@@0ABQAU12@@Z ; std::fill<Ogre::D3DDEVICEINFO_T * *,Ogre::D3DDEVICEINFO_T *>
	add	esp, 12					; 0000000cH

; 1232 : 			}
; 1233 : 		else

	jmp	SHORT $LN16@Insert_n@8
$LN3@Insert_n@8:

; 1234 : 			{	// new stuff can all be assigned
; 1235 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	ecx, DWORD PTR __Val$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR __Tmp$134391[ebp], edx

; 1236 : 
; 1237 : 			pointer _Oldend = _Mylast;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR __Oldend$134392[ebp], ecx

; 1238 : 			_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1239 : 				_Mylast);	// copy suffix

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR __Oldend$134392[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count$[ebp]
	shl	edx, 2
	mov	eax, DWORD PTR __Oldend$134392[ebp]
	sub	eax, edx
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Umove@PAPAUD3DDEVICEINFO_T@Ogre@@@?$vector@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@IAEPAPAUD3DDEVICEINFO_T@Ogre@@PAPAU23@00@Z ; std::vector<Ogre::D3DDEVICEINFO_T *,std::allocator<Ogre::D3DDEVICEINFO_T *> >::_Umove<Ogre::D3DDEVICEINFO_T * *>
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 1240 : 
; 1241 :  #if _HAS_ITERATOR_DEBUGGING
; 1242 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1243 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1244 : 
; 1245 : 			_STDEXT _Unchecked_move_backward(_VEC_ITER_BASE(_Where), _Oldend - _Count,
; 1246 : 				_Oldend);	// copy hole

	mov	edx, DWORD PTR __Oldend$134392[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 2
	mov	ecx, DWORD PTR __Oldend$134392[ebp]
	sub	ecx, eax
	push	ecx
	mov	edx, DWORD PTR __Where$[ebp+4]
	push	edx
	call	??$_Unchecked_move_backward@PAPAUD3DDEVICEINFO_T@Ogre@@PAPAU12@@stdext@@YAPAPAUD3DDEVICEINFO_T@Ogre@@PAPAU12@00@Z ; stdext::_Unchecked_move_backward<Ogre::D3DDEVICEINFO_T * *,Ogre::D3DDEVICEINFO_T * *>
	add	esp, 12					; 0000000cH

; 1247 : 			std::fill(_VEC_ITER_BASE(_Where), _VEC_ITER_BASE(_Where) + _Count,
; 1248 : 				_Tmp);	// insert into hole

	lea	eax, DWORD PTR __Tmp$134391[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Where$[ebp+4]
	lea	eax, DWORD PTR [edx+ecx*4]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp+4]
	push	ecx
	call	??$fill@PAPAUD3DDEVICEINFO_T@Ogre@@PAU12@@std@@YAXPAPAUD3DDEVICEINFO_T@Ogre@@0ABQAU12@@Z ; std::fill<Ogre::D3DDEVICEINFO_T * *,Ogre::D3DDEVICEINFO_T *>
	add	esp, 12					; 0000000cH
$LN16@Insert_n@8:

; 1249 : 			}
; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Insert_n@?$vector@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@2@IABQAUD3DDEVICEINFO_T@Ogre@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-56]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Insert_n@?$vector@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@2@IABQAUD3DDEVICEINFO_T@Ogre@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Insert_n@?$vector@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@2@IABQAUD3DDEVICEINFO_T@Ogre@@@Z ENDP ; std::vector<Ogre::D3DDEVICEINFO_T *,std::allocator<Ogre::D3DDEVICEINFO_T *> >::_Insert_n
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@KAXXZ$0
__ehfuncinfo$?_Xlen@?$vector@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@KAXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T142800 = -80						; size = 28
$T142799 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@KAXXZ PROC ; std::vector<Ogre::D3DDEVICEINFO_T *,std::allocator<Ogre::D3DDEVICEINFO_T *> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Xlen@?$vector@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T142800[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR $T142800[ebp]
	push	eax
	lea	ecx, DWORD PTR $T142799[ebp]
	call	??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::length_error::length_error
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T142799[ebp]
	push	ecx
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T142800[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN2@Xlen@8:

; 1261 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T142800[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?_Xlen@?$vector@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@KAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@KAXXZ ENDP ; std::vector<Ogre::D3DDEVICEINFO_T *,std::allocator<Ogre::D3DDEVICEINFO_T *> >::_Xlen
PUBLIC	??$?0PAUD3DDEVICEINFO_T@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::D3DDEVICEINFO_T *>
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??0?$_Container_base_aux_alloc_real@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@IAE@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@IAE@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@1@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@IAE@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@1@@Z$1
__ehfuncinfo$??0?$_Container_base_aux_alloc_real@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@IAE@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0?$_Container_base_aux_alloc_real@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@IAE@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Container_base_aux_alloc_real@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@IAE@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@1@@Z
_TEXT	SEGMENT
tv133 = -32						; size = 4
_this$ = -28						; size = 4
$T142812 = -24						; size = 4
$T142811 = -20						; size = 4
$T142810 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 1
??0?$_Container_base_aux_alloc_real@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@IAE@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@1@@Z PROC ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::D3DDEVICEINFO_T *> >::_Container_base_aux_alloc_real<std::allocator<Ogre::D3DDEVICEINFO_T *> >, COMDAT
; _this$ = ecx

; 419  : 		{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Container_base_aux_alloc_real@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@IAE@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 20					; 00000014H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::_Container_base_aux
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??$?0PAUD3DDEVICEINFO_T@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::D3DDEVICEINFO_T *>

; 420  : 		_Myownedaux = new (_Alaux.allocate(1)) _Aux_cont(this);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?allocate@?$allocator@V_Aux_cont@std@@@std@@QAEPAV_Aux_cont@2@I@Z ; std::allocator<std::_Aux_cont>::allocate
	mov	DWORD PTR $T142812[ebp], eax
	mov	ecx, DWORD PTR $T142812[ebp]
	push	ecx
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T142811[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	cmp	DWORD PTR $T142811[ebp], 0
	je	SHORT $LN3@Container_@8
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T142811[ebp]
	call	??0_Aux_cont@std@@QAE@QBV_Container_base_aux@1@@Z ; std::_Aux_cont::_Aux_cont
	mov	DWORD PTR tv133[ebp], eax
	jmp	SHORT $LN4@Container_@8
$LN3@Container_@8:
	mov	DWORD PTR tv133[ebp], 0
$LN4@Container_@8:
	mov	eax, DWORD PTR tv133[ebp]
	mov	DWORD PTR $T142810[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T142810[ebp]
	mov	DWORD PTR [ecx], edx

; 421  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@IAE@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@IAE@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@1@@Z$1:
	mov	eax, DWORD PTR $T142812[ebp]
	push	eax
	mov	ecx, DWORD PTR $T142811[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??0?$_Container_base_aux_alloc_real@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@IAE@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Container_base_aux_alloc_real@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@IAE@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Container_base_aux_alloc_real@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@IAE@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@1@@Z ENDP ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::D3DDEVICEINFO_T *> >::_Container_base_aux_alloc_real<std::allocator<Ogre::D3DDEVICEINFO_T *> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@QAE@ABV01@@Z PROC ; std::allocator<Ogre::D3DDEVICEINFO_T *>::allocator<Ogre::D3DDEVICEINFO_T *>, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<Ogre::D3DDEVICEINFO_T *>::allocator<Ogre::D3DDEVICEINFO_T *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@QAEXPAPAUD3DDEVICEINFO_T@Ogre@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@QAEXPAPAUD3DDEVICEINFO_T@Ogre@@I@Z PROC ; std::allocator<Ogre::D3DDEVICEINFO_T *>::deallocate, COMDAT
; _this$ = ecx

; 139  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 141  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@QAEXPAPAUD3DDEVICEINFO_T@Ogre@@I@Z ENDP ; std::allocator<Ogre::D3DDEVICEINFO_T *>::deallocate
_TEXT	ENDS
PUBLIC	??$_Allocate@PAUD3DDEVICEINFO_T@Ogre@@@std@@YAPAPAUD3DDEVICEINFO_T@Ogre@@IPAPAU12@@Z ; std::_Allocate<Ogre::D3DDEVICEINFO_T *>
; Function compile flags: /Odtp
;	COMDAT ?allocate@?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@QAEPAPAUD3DDEVICEINFO_T@Ogre@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@QAEPAPAUD3DDEVICEINFO_T@Ogre@@I@Z PROC ; std::allocator<Ogre::D3DDEVICEINFO_T *>::allocate, COMDAT
; _this$ = ecx

; 144  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@PAUD3DDEVICEINFO_T@Ogre@@@std@@YAPAPAUD3DDEVICEINFO_T@Ogre@@IPAPAU12@@Z ; std::_Allocate<Ogre::D3DDEVICEINFO_T *>
	add	esp, 8

; 146  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@QAEPAPAUD3DDEVICEINFO_T@Ogre@@I@Z ENDP ; std::allocator<Ogre::D3DDEVICEINFO_T *>::allocate
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?begin@?$vector@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@2@XZ PROC ; std::vector<Ogre::D3DADAPTER_T *,std::allocator<Ogre::D3DADAPTER_T *> >::begin, COMDAT
; _this$ = ecx

; 640  : 		{	// return iterator for beginning of mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 641  : 		return (iterator(_Myfirst, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@QAE@PAPAUD3DADAPTER_T@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::D3DADAPTER_T *,std::allocator<Ogre::D3DADAPTER_T *> >::_Vector_iterator<Ogre::D3DADAPTER_T *,std::allocator<Ogre::D3DADAPTER_T *> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 642  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?begin@?$vector@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@2@XZ ENDP ; std::vector<Ogre::D3DADAPTER_T *,std::allocator<Ogre::D3DADAPTER_T *> >::begin
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@QBEIXZ ; std::allocator<Ogre::D3DADAPTER_T *>::max_size
; Function compile flags: /Odtp
;	COMDAT ?max_size@?$vector@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$vector@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@QBEIXZ PROC ; std::vector<Ogre::D3DADAPTER_T *,std::allocator<Ogre::D3DADAPTER_T *> >::max_size, COMDAT
; _this$ = ecx

; 730  : 		{	// return maximum possible length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 731  : 		return (this->_Alval.max_size());

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?max_size@?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@QBEIXZ ; std::allocator<Ogre::D3DADAPTER_T *>::max_size

; 732  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$vector@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@QBEIXZ ENDP ; std::vector<Ogre::D3DADAPTER_T *,std::allocator<Ogre::D3DADAPTER_T *> >::max_size
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@YAXPAPAUD3DADAPTER_T@Ogre@@0AAV?$allocator@PAUD3DADAPTER_T@Ogre@@@0@@Z ; std::_Destroy_range<std::allocator<Ogre::D3DADAPTER_T *> >
; Function compile flags: /Odtp
;	COMDAT ?_Destroy@?$vector@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@IAEXPAPAUD3DADAPTER_T@Ogre@@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@IAEXPAPAUD3DADAPTER_T@Ogre@@0@Z PROC ; std::vector<Ogre::D3DADAPTER_T *,std::allocator<Ogre::D3DADAPTER_T *> >::_Destroy, COMDAT
; _this$ = ecx

; 1118 : 		{	// destroy [_First, _Last) using allocator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Destroy_range@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@YAXPAPAUD3DADAPTER_T@Ogre@@0AAV?$allocator@PAUD3DADAPTER_T@Ogre@@@0@@Z ; std::_Destroy_range<std::allocator<Ogre::D3DADAPTER_T *> >
	add	esp, 12					; 0000000cH

; 1120 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?_Destroy@?$vector@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@IAEXPAPAUD3DADAPTER_T@Ogre@@0@Z ENDP ; std::vector<Ogre::D3DADAPTER_T *,std::allocator<Ogre::D3DADAPTER_T *> >::_Destroy
_TEXT	ENDS
PUBLIC	??$_Unchecked_move_backward@PAPAUD3DADAPTER_T@Ogre@@PAPAU12@@stdext@@YAPAPAUD3DADAPTER_T@Ogre@@PAPAU12@00@Z ; stdext::_Unchecked_move_backward<Ogre::D3DADAPTER_T * *,Ogre::D3DADAPTER_T * *>
PUBLIC	??$fill@PAPAUD3DADAPTER_T@Ogre@@PAU12@@std@@YAXPAPAUD3DADAPTER_T@Ogre@@0ABQAU12@@Z ; std::fill<Ogre::D3DADAPTER_T * *,Ogre::D3DADAPTER_T *>
PUBLIC	??$_Umove@PAPAUD3DADAPTER_T@Ogre@@@?$vector@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@IAEPAPAUD3DADAPTER_T@Ogre@@PAPAU23@00@Z ; std::vector<Ogre::D3DADAPTER_T *,std::allocator<Ogre::D3DADAPTER_T *> >::_Umove<Ogre::D3DADAPTER_T * *>
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Insert_n@?$vector@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@2@IABQAUD3DADAPTER_T@Ogre@@@Z$5 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@2@IABQAUD3DADAPTER_T@Ogre@@@Z$2
__catchsym$?_Insert_n@?$vector@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@2@IABQAUD3DADAPTER_T@Ogre@@@Z$4 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@2@IABQAUD3DADAPTER_T@Ogre@@@Z$0
__unwindtable$?_Insert_n@?$vector@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@2@IABQAUD3DADAPTER_T@Ogre@@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$?_Insert_n@?$vector@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@2@IABQAUD3DADAPTER_T@Ogre@@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Insert_n@?$vector@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@2@IABQAUD3DADAPTER_T@Ogre@@@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Insert_n@?$vector@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@2@IABQAUD3DADAPTER_T@Ogre@@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__tryblocktable$?_Insert_n@?$vector@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@2@IABQAUD3DADAPTER_T@Ogre@@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@2@IABQAUD3DADAPTER_T@Ogre@@@Z$4
	DD	02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@2@IABQAUD3DADAPTER_T@Ogre@@@Z$5
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?_Insert_n@?$vector@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@2@IABQAUD3DADAPTER_T@Ogre@@@Z
_TEXT	SEGMENT
tv84 = -52						; size = 4
_this$ = -48						; size = 4
__Tmp$134477 = -44					; size = 4
__Oldend$134478 = -40					; size = 4
__Tmp$134467 = -36					; size = 4
__Ncopied$134454 = -32					; size = 4
__Newvec$134452 = -28					; size = 4
__Whereoff$134453 = -24					; size = 4
__Capacity$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Where$ = 8						; size = 8
__Count$ = 16						; size = 4
__Val$ = 20						; size = 4
?_Insert_n@?$vector@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@2@IABQAUD3DADAPTER_T@Ogre@@@Z PROC ; std::vector<Ogre::D3DADAPTER_T *,std::allocator<Ogre::D3DADAPTER_T *> >::_Insert_n, COMDAT
; _this$ = ecx

; 1153 : 		{	// insert _Count * _Val at _Where

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Insert_n@?$vector@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@2@IABQAUD3DADAPTER_T@Ogre@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 36					; 00000024H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1154 : 
; 1155 :  #if _HAS_ITERATOR_DEBUGGING
; 1156 : 		if (_Where._Mycont != this
; 1157 : 			|| _Where._Myptr < _Myfirst || _Mylast < _Where._Myptr)
; 1158 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1159 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1160 : 
; 1161 : 		size_type _Capacity = capacity();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?capacity@?$vector@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::D3DADAPTER_T *,std::allocator<Ogre::D3DADAPTER_T *> >::capacity
	mov	DWORD PTR __Capacity$[ebp], eax

; 1162 : 
; 1163 : 		if (_Count == 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN14@Insert_n@9
	jmp	$LN16@Insert_n@9
$LN14@Insert_n@9:

; 1164 : 			;
; 1165 : 		else if (max_size() - size() < _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::D3DADAPTER_T *,std::allocator<Ogre::D3DADAPTER_T *> >::max_size
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::D3DADAPTER_T *,std::allocator<Ogre::D3DADAPTER_T *> >::size
	sub	esi, eax
	cmp	esi, DWORD PTR __Count$[ebp]
	jae	SHORT $LN12@Insert_n@9

; 1166 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@KAXXZ ; std::vector<Ogre::D3DADAPTER_T *,std::allocator<Ogre::D3DADAPTER_T *> >::_Xlen
	jmp	$LN16@Insert_n@9
$LN12@Insert_n@9:

; 1167 : 		else if (_Capacity < size() + _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::D3DADAPTER_T *,std::allocator<Ogre::D3DADAPTER_T *> >::size
	add	eax, DWORD PTR __Count$[ebp]
	cmp	DWORD PTR __Capacity$[ebp], eax
	jae	$LN10@Insert_n@9

; 1168 : 			{	// not enough room, reallocate
; 1169 : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1170 : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::D3DADAPTER_T *,std::allocator<Ogre::D3DADAPTER_T *> >::max_size
	mov	ecx, DWORD PTR __Capacity$[ebp]
	shr	ecx, 1
	sub	eax, ecx
	cmp	eax, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN17@Insert_n@9
	mov	DWORD PTR tv84[ebp], 0
	jmp	SHORT $LN18@Insert_n@9
$LN17@Insert_n@9:
	mov	edx, DWORD PTR __Capacity$[ebp]
	shr	edx, 1
	add	edx, DWORD PTR __Capacity$[ebp]
	mov	DWORD PTR tv84[ebp], edx
$LN18@Insert_n@9:
	mov	eax, DWORD PTR tv84[ebp]
	mov	DWORD PTR __Capacity$[ebp], eax

; 1171 : 			if (_Capacity < size() + _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::D3DADAPTER_T *,std::allocator<Ogre::D3DADAPTER_T *> >::size
	add	eax, DWORD PTR __Count$[ebp]
	cmp	DWORD PTR __Capacity$[ebp], eax
	jae	SHORT $LN9@Insert_n@9

; 1172 : 				_Capacity = size() + _Count;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::D3DADAPTER_T *,std::allocator<Ogre::D3DADAPTER_T *> >::size
	add	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Capacity$[ebp], eax
$LN9@Insert_n@9:

; 1173 : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

	mov	ecx, DWORD PTR __Capacity$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?allocate@?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@QAEPAPAUD3DADAPTER_T@Ogre@@I@Z ; std::allocator<Ogre::D3DADAPTER_T *>::allocate
	mov	DWORD PTR __Newvec$134452[ebp], eax

; 1174 : 			size_type _Whereoff = _VEC_ITER_BASE(_Where) - _Myfirst;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Where$[ebp+4]
	sub	eax, DWORD PTR [edx+12]
	sar	eax, 2
	mov	DWORD PTR __Whereoff$134453[ebp], eax

; 1175 : 			int _Ncopied = 0;

	mov	DWORD PTR __Ncopied$134454[ebp], 0

; 1176 : 
; 1177 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1178 : 			_Ufill(_Newvec + _Whereoff, _Count, _Val);	// add new stuff

	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __Whereoff$134453[ebp]
	mov	ecx, DWORD PTR __Newvec$134452[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Ufill@?$vector@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@IAEPAPAUD3DADAPTER_T@Ogre@@PAPAU34@IABQAU34@@Z ; std::vector<Ogre::D3DADAPTER_T *,std::allocator<Ogre::D3DADAPTER_T *> >::_Ufill

; 1179 : 			++_Ncopied;

	mov	eax, DWORD PTR __Ncopied$134454[ebp]
	add	eax, 1
	mov	DWORD PTR __Ncopied$134454[ebp], eax

; 1180 : 			_Umove(this->_Myfirst, _VEC_ITER_BASE(_Where),
; 1181 : 				_Newvec);	// move prefix

	mov	ecx, DWORD PTR __Newvec$134452[ebp]
	push	ecx
	mov	edx, DWORD PTR __Where$[ebp+4]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Umove@PAPAUD3DADAPTER_T@Ogre@@@?$vector@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@IAEPAPAUD3DADAPTER_T@Ogre@@PAPAU23@00@Z ; std::vector<Ogre::D3DADAPTER_T *,std::allocator<Ogre::D3DADAPTER_T *> >::_Umove<Ogre::D3DADAPTER_T * *>

; 1182 : 			++_Ncopied;

	mov	edx, DWORD PTR __Ncopied$134454[ebp]
	add	edx, 1
	mov	DWORD PTR __Ncopied$134454[ebp], edx

; 1183 : 			_Umove(_VEC_ITER_BASE(_Where), this->_Mylast,
; 1184 : 				_Newvec + (_Whereoff + _Count));	// move suffix

	mov	eax, DWORD PTR __Whereoff$134453[ebp]
	add	eax, DWORD PTR __Count$[ebp]
	mov	ecx, DWORD PTR __Newvec$134452[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Where$[ebp+4]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Umove@PAPAUD3DADAPTER_T@Ogre@@@?$vector@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@IAEPAPAUD3DADAPTER_T@Ogre@@PAPAU23@00@Z ; std::vector<Ogre::D3DADAPTER_T *,std::allocator<Ogre::D3DADAPTER_T *> >::_Umove<Ogre::D3DADAPTER_T * *>
	jmp	SHORT $LN19@Insert_n@9
__catch$?_Insert_n@?$vector@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@2@IABQAUD3DADAPTER_T@Ogre@@@Z$0:

; 1185 : 			_CATCH_ALL
; 1186 : 			if (1 < _Ncopied)

	cmp	DWORD PTR __Ncopied$134454[ebp], 1
	jle	SHORT $LN7@Insert_n@9

; 1187 : 				_Destroy(_Newvec, _Newvec + _Whereoff);

	mov	eax, DWORD PTR __Whereoff$134453[ebp]
	mov	ecx, DWORD PTR __Newvec$134452[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	push	edx
	mov	eax, DWORD PTR __Newvec$134452[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@IAEXPAPAUD3DADAPTER_T@Ogre@@0@Z ; std::vector<Ogre::D3DADAPTER_T *,std::allocator<Ogre::D3DADAPTER_T *> >::_Destroy
$LN7@Insert_n@9:

; 1188 : 			if (0 < _Ncopied)

	cmp	DWORD PTR __Ncopied$134454[ebp], 0
	jle	SHORT $LN6@Insert_n@9

; 1189 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);

	mov	ecx, DWORD PTR __Whereoff$134453[ebp]
	mov	edx, DWORD PTR __Newvec$134452[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR __Count$[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]
	push	edx
	mov	eax, DWORD PTR __Whereoff$134453[ebp]
	mov	ecx, DWORD PTR __Newvec$134452[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@IAEXPAPAUD3DADAPTER_T@Ogre@@0@Z ; std::vector<Ogre::D3DADAPTER_T *,std::allocator<Ogre::D3DADAPTER_T *> >::_Destroy
$LN6@Insert_n@9:

; 1190 : 			this->_Alval.deallocate(_Newvec, _Capacity);

	mov	eax, DWORD PTR __Capacity$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Newvec$134452[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?deallocate@?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@QAEXPAPAUD3DADAPTER_T@Ogre@@I@Z ; std::allocator<Ogre::D3DADAPTER_T *>::deallocate

; 1191 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1192 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$?_Insert_n@?$vector@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@2@IABQAUD3DADAPTER_T@Ogre@@@Z$1
	ret	0
$LN19@Insert_n@9:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Insert_n@?$vector@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@2@IABQAUD3DADAPTER_T@Ogre@@@Z$1:

; 1193 : 
; 1194 : 			_Count += size();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::D3DADAPTER_T *,std::allocator<Ogre::D3DADAPTER_T *> >::size
	add	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Count$[ebp], eax

; 1195 : 			if (_Myfirst != 0)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+12], 0
	je	SHORT $LN5@Insert_n@9

; 1196 : 				{	// destroy and deallocate old array
; 1197 : 				_Destroy(_Myfirst, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@IAEXPAPAUD3DADAPTER_T@Ogre@@0@Z ; std::vector<Ogre::D3DADAPTER_T *,std::allocator<Ogre::D3DADAPTER_T *> >::_Destroy

; 1198 : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+20]
	sub	eax, DWORD PTR [edx+12]
	sar	eax, 2
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?deallocate@?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@QAEXPAPAUD3DADAPTER_T@Ogre@@I@Z ; std::allocator<Ogre::D3DADAPTER_T *>::deallocate
$LN5@Insert_n@9:

; 1199 : 				}
; 1200 : 
; 1201 :  #if _HAS_ITERATOR_DEBUGGING
; 1202 : 			this->_Orphan_all();
; 1203 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1204 : 
; 1205 : 			_Myend = _Newvec + _Capacity;

	mov	eax, DWORD PTR __Capacity$[ebp]
	mov	ecx, DWORD PTR __Newvec$134452[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], edx

; 1206 : 			_Mylast = _Newvec + _Count;

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Newvec$134452[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 1207 : 			_Myfirst = _Newvec;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Newvec$134452[ebp]
	mov	DWORD PTR [edx+12], eax
	jmp	$LN16@Insert_n@9
$LN10@Insert_n@9:

; 1208 : 			}
; 1209 : 		else if ((size_type)(_Mylast - _VEC_ITER_BASE(_Where)) < _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	sub	edx, DWORD PTR __Where$[ebp+4]
	sar	edx, 2
	cmp	edx, DWORD PTR __Count$[ebp]
	jae	$LN3@Insert_n@9

; 1210 : 			{	// new stuff spills off end
; 1211 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Tmp$134467[ebp], ecx

; 1212 : 
; 1213 : 			_Umove(_VEC_ITER_BASE(_Where), _Mylast,
; 1214 : 				_VEC_ITER_BASE(_Where) + _Count);	// copy suffix

	mov	edx, DWORD PTR __Count$[ebp]
	mov	eax, DWORD PTR __Where$[ebp+4]
	lea	ecx, DWORD PTR [eax+edx*4]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp+4]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Umove@PAPAUD3DADAPTER_T@Ogre@@@?$vector@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@IAEPAPAUD3DADAPTER_T@Ogre@@PAPAU23@00@Z ; std::vector<Ogre::D3DADAPTER_T *,std::allocator<Ogre::D3DADAPTER_T *> >::_Umove<Ogre::D3DADAPTER_T * *>

; 1215 : 
; 1216 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 2

; 1217 : 			_Ufill(_Mylast, _Count - (_Mylast - _VEC_ITER_BASE(_Where)),
; 1218 : 				_Tmp);	// insert new stuff off end

	lea	edx, DWORD PTR __Tmp$134467[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	sub	ecx, DWORD PTR __Where$[ebp+4]
	sar	ecx, 2
	mov	edx, DWORD PTR __Count$[ebp]
	sub	edx, ecx
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Ufill@?$vector@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@IAEPAPAUD3DADAPTER_T@Ogre@@PAPAU34@IABQAU34@@Z ; std::vector<Ogre::D3DADAPTER_T *,std::allocator<Ogre::D3DADAPTER_T *> >::_Ufill
	jmp	SHORT $LN21@Insert_n@9
__catch$?_Insert_n@?$vector@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@2@IABQAUD3DADAPTER_T@Ogre@@@Z$2:

; 1219 : 			_CATCH_ALL
; 1220 : 			_Destroy(_VEC_ITER_BASE(_Where) + _Count, _Mylast + _Count);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR __Count$[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	mov	ecx, DWORD PTR __Where$[ebp+4]
	lea	edx, DWORD PTR [ecx+eax*4]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@IAEXPAPAUD3DADAPTER_T@Ogre@@0@Z ; std::vector<Ogre::D3DADAPTER_T *,std::allocator<Ogre::D3DADAPTER_T *> >::_Destroy

; 1221 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1222 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$?_Insert_n@?$vector@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@2@IABQAUD3DADAPTER_T@Ogre@@@Z$3
	ret	0
$LN21@Insert_n@9:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Insert_n@?$vector@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@2@IABQAUD3DADAPTER_T@Ogre@@@Z$3:

; 1223 : 
; 1224 : 			_Mylast += _Count;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR __Count$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 1225 : 
; 1226 :  #if _HAS_ITERATOR_DEBUGGING
; 1227 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1228 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1229 : 
; 1230 : 			std::fill(_VEC_ITER_BASE(_Where), _Mylast - _Count,
; 1231 : 				_Tmp);	// insert up to old end

	lea	edx, DWORD PTR __Tmp$134467[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 2
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	sub	edx, eax
	push	edx
	mov	eax, DWORD PTR __Where$[ebp+4]
	push	eax
	call	??$fill@PAPAUD3DADAPTER_T@Ogre@@PAU12@@std@@YAXPAPAUD3DADAPTER_T@Ogre@@0ABQAU12@@Z ; std::fill<Ogre::D3DADAPTER_T * *,Ogre::D3DADAPTER_T *>
	add	esp, 12					; 0000000cH

; 1232 : 			}
; 1233 : 		else

	jmp	SHORT $LN16@Insert_n@9
$LN3@Insert_n@9:

; 1234 : 			{	// new stuff can all be assigned
; 1235 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	ecx, DWORD PTR __Val$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR __Tmp$134477[ebp], edx

; 1236 : 
; 1237 : 			pointer _Oldend = _Mylast;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR __Oldend$134478[ebp], ecx

; 1238 : 			_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1239 : 				_Mylast);	// copy suffix

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR __Oldend$134478[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count$[ebp]
	shl	edx, 2
	mov	eax, DWORD PTR __Oldend$134478[ebp]
	sub	eax, edx
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Umove@PAPAUD3DADAPTER_T@Ogre@@@?$vector@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@IAEPAPAUD3DADAPTER_T@Ogre@@PAPAU23@00@Z ; std::vector<Ogre::D3DADAPTER_T *,std::allocator<Ogre::D3DADAPTER_T *> >::_Umove<Ogre::D3DADAPTER_T * *>
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 1240 : 
; 1241 :  #if _HAS_ITERATOR_DEBUGGING
; 1242 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1243 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1244 : 
; 1245 : 			_STDEXT _Unchecked_move_backward(_VEC_ITER_BASE(_Where), _Oldend - _Count,
; 1246 : 				_Oldend);	// copy hole

	mov	edx, DWORD PTR __Oldend$134478[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 2
	mov	ecx, DWORD PTR __Oldend$134478[ebp]
	sub	ecx, eax
	push	ecx
	mov	edx, DWORD PTR __Where$[ebp+4]
	push	edx
	call	??$_Unchecked_move_backward@PAPAUD3DADAPTER_T@Ogre@@PAPAU12@@stdext@@YAPAPAUD3DADAPTER_T@Ogre@@PAPAU12@00@Z ; stdext::_Unchecked_move_backward<Ogre::D3DADAPTER_T * *,Ogre::D3DADAPTER_T * *>
	add	esp, 12					; 0000000cH

; 1247 : 			std::fill(_VEC_ITER_BASE(_Where), _VEC_ITER_BASE(_Where) + _Count,
; 1248 : 				_Tmp);	// insert into hole

	lea	eax, DWORD PTR __Tmp$134477[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Where$[ebp+4]
	lea	eax, DWORD PTR [edx+ecx*4]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp+4]
	push	ecx
	call	??$fill@PAPAUD3DADAPTER_T@Ogre@@PAU12@@std@@YAXPAPAUD3DADAPTER_T@Ogre@@0ABQAU12@@Z ; std::fill<Ogre::D3DADAPTER_T * *,Ogre::D3DADAPTER_T *>
	add	esp, 12					; 0000000cH
$LN16@Insert_n@9:

; 1249 : 			}
; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Insert_n@?$vector@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@2@IABQAUD3DADAPTER_T@Ogre@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-56]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Insert_n@?$vector@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@2@IABQAUD3DADAPTER_T@Ogre@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Insert_n@?$vector@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@2@IABQAUD3DADAPTER_T@Ogre@@@Z ENDP ; std::vector<Ogre::D3DADAPTER_T *,std::allocator<Ogre::D3DADAPTER_T *> >::_Insert_n
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@KAXXZ$0
__ehfuncinfo$?_Xlen@?$vector@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@KAXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T142861 = -80						; size = 28
$T142860 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@KAXXZ PROC ; std::vector<Ogre::D3DADAPTER_T *,std::allocator<Ogre::D3DADAPTER_T *> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Xlen@?$vector@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T142861[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR $T142861[ebp]
	push	eax
	lea	ecx, DWORD PTR $T142860[ebp]
	call	??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::length_error::length_error
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T142860[ebp]
	push	ecx
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T142861[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN2@Xlen@9:

; 1261 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T142861[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?_Xlen@?$vector@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@KAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@KAXXZ ENDP ; std::vector<Ogre::D3DADAPTER_T *,std::allocator<Ogre::D3DADAPTER_T *> >::_Xlen
PUBLIC	??$?0PAUD3DADAPTER_T@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@PAUD3DADAPTER_T@Ogre@@@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::D3DADAPTER_T *>
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??0?$_Container_base_aux_alloc_real@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@IAE@V?$allocator@PAUD3DADAPTER_T@Ogre@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@IAE@V?$allocator@PAUD3DADAPTER_T@Ogre@@@1@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@IAE@V?$allocator@PAUD3DADAPTER_T@Ogre@@@1@@Z$1
__ehfuncinfo$??0?$_Container_base_aux_alloc_real@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@IAE@V?$allocator@PAUD3DADAPTER_T@Ogre@@@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0?$_Container_base_aux_alloc_real@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@IAE@V?$allocator@PAUD3DADAPTER_T@Ogre@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Container_base_aux_alloc_real@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@IAE@V?$allocator@PAUD3DADAPTER_T@Ogre@@@1@@Z
_TEXT	SEGMENT
tv133 = -32						; size = 4
_this$ = -28						; size = 4
$T142873 = -24						; size = 4
$T142872 = -20						; size = 4
$T142871 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 1
??0?$_Container_base_aux_alloc_real@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@IAE@V?$allocator@PAUD3DADAPTER_T@Ogre@@@1@@Z PROC ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::D3DADAPTER_T *> >::_Container_base_aux_alloc_real<std::allocator<Ogre::D3DADAPTER_T *> >, COMDAT
; _this$ = ecx

; 419  : 		{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Container_base_aux_alloc_real@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@IAE@V?$allocator@PAUD3DADAPTER_T@Ogre@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 20					; 00000014H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::_Container_base_aux
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??$?0PAUD3DADAPTER_T@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@PAUD3DADAPTER_T@Ogre@@@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::D3DADAPTER_T *>

; 420  : 		_Myownedaux = new (_Alaux.allocate(1)) _Aux_cont(this);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?allocate@?$allocator@V_Aux_cont@std@@@std@@QAEPAV_Aux_cont@2@I@Z ; std::allocator<std::_Aux_cont>::allocate
	mov	DWORD PTR $T142873[ebp], eax
	mov	ecx, DWORD PTR $T142873[ebp]
	push	ecx
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T142872[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	cmp	DWORD PTR $T142872[ebp], 0
	je	SHORT $LN3@Container_@9
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T142872[ebp]
	call	??0_Aux_cont@std@@QAE@QBV_Container_base_aux@1@@Z ; std::_Aux_cont::_Aux_cont
	mov	DWORD PTR tv133[ebp], eax
	jmp	SHORT $LN4@Container_@9
$LN3@Container_@9:
	mov	DWORD PTR tv133[ebp], 0
$LN4@Container_@9:
	mov	eax, DWORD PTR tv133[ebp]
	mov	DWORD PTR $T142871[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T142871[ebp]
	mov	DWORD PTR [ecx], edx

; 421  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@IAE@V?$allocator@PAUD3DADAPTER_T@Ogre@@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@IAE@V?$allocator@PAUD3DADAPTER_T@Ogre@@@1@@Z$1:
	mov	eax, DWORD PTR $T142873[ebp]
	push	eax
	mov	ecx, DWORD PTR $T142872[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??0?$_Container_base_aux_alloc_real@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@IAE@V?$allocator@PAUD3DADAPTER_T@Ogre@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Container_base_aux_alloc_real@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@IAE@V?$allocator@PAUD3DADAPTER_T@Ogre@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Container_base_aux_alloc_real@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@IAE@V?$allocator@PAUD3DADAPTER_T@Ogre@@@1@@Z ENDP ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::D3DADAPTER_T *> >::_Container_base_aux_alloc_real<std::allocator<Ogre::D3DADAPTER_T *> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@QAE@ABV01@@Z PROC ; std::allocator<Ogre::D3DADAPTER_T *>::allocator<Ogre::D3DADAPTER_T *>, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<Ogre::D3DADAPTER_T *>::allocator<Ogre::D3DADAPTER_T *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@QAEXPAPAUD3DADAPTER_T@Ogre@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@QAEXPAPAUD3DADAPTER_T@Ogre@@I@Z PROC ; std::allocator<Ogre::D3DADAPTER_T *>::deallocate, COMDAT
; _this$ = ecx

; 139  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 141  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@QAEXPAPAUD3DADAPTER_T@Ogre@@I@Z ENDP ; std::allocator<Ogre::D3DADAPTER_T *>::deallocate
_TEXT	ENDS
PUBLIC	??$_Allocate@PAUD3DADAPTER_T@Ogre@@@std@@YAPAPAUD3DADAPTER_T@Ogre@@IPAPAU12@@Z ; std::_Allocate<Ogre::D3DADAPTER_T *>
; Function compile flags: /Odtp
;	COMDAT ?allocate@?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@QAEPAPAUD3DADAPTER_T@Ogre@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@QAEPAPAUD3DADAPTER_T@Ogre@@I@Z PROC ; std::allocator<Ogre::D3DADAPTER_T *>::allocate, COMDAT
; _this$ = ecx

; 144  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@PAUD3DADAPTER_T@Ogre@@@std@@YAPAPAUD3DADAPTER_T@Ogre@@IPAPAU12@@Z ; std::_Allocate<Ogre::D3DADAPTER_T *>
	add	esp, 8

; 146  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@QAEPAPAUD3DADAPTER_T@Ogre@@I@Z ENDP ; std::allocator<Ogre::D3DADAPTER_T *>::allocate
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@QAE@PAW4_D3DFORMAT@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<enum _D3DFORMAT,std::allocator<enum _D3DFORMAT> >::_Vector_const_iterator<enum _D3DFORMAT,std::allocator<enum _D3DFORMAT> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$_Vector_iterator@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@QAE@PAW4_D3DFORMAT@@PBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@QAE@PAW4_D3DFORMAT@@PBV_Container_base_aux@1@@Z PROC ; std::_Vector_iterator<enum _D3DFORMAT,std::allocator<enum _D3DFORMAT> >::_Vector_iterator<enum _D3DFORMAT,std::allocator<enum _D3DFORMAT> >, COMDAT
; _this$ = ecx

; 327  : 		{	// construct with pointer _Ptr

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Pvector$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_const_iterator@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@QAE@PAW4_D3DFORMAT@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<enum _D3DFORMAT,std::allocator<enum _D3DFORMAT> >::_Vector_const_iterator<enum _D3DFORMAT,std::allocator<enum _D3DFORMAT> >

; 328  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Vector_iterator@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@QAE@PAW4_D3DFORMAT@@PBV_Container_base_aux@1@@Z ENDP ; std::_Vector_iterator<enum _D3DFORMAT,std::allocator<enum _D3DFORMAT> >::_Vector_iterator<enum _D3DFORMAT,std::allocator<enum _D3DFORMAT> >
_TEXT	ENDS
PUBLIC	??Y?$_Vector_iterator@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<enum _D3DFORMAT,std::allocator<enum _D3DFORMAT> >::operator+=
; Function compile flags: /Odtp
;	COMDAT ??H?$_Vector_iterator@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
__Tmp$ = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Vector_iterator@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<enum _D3DFORMAT,std::allocator<enum _D3DFORMAT> >::operator+, COMDAT
; _this$ = ecx

; 380  : 		{	// return this + integer

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 381  : 		_Myt _Tmp = *this;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR __Tmp$[ebp], ecx
	mov	DWORD PTR __Tmp$[ebp+4], edx

; 382  : 		return (_Tmp += _Off);

	mov	eax, DWORD PTR __Off$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Tmp$[ebp]
	call	??Y?$_Vector_iterator@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<enum _D3DFORMAT,std::allocator<enum _D3DFORMAT> >::operator+=
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 383  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
??H?$_Vector_iterator@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<enum _D3DFORMAT,std::allocator<enum _D3DFORMAT> >::operator+
_TEXT	ENDS
PUBLIC	?_Same_container@_Iterator_base_aux@std@@QBE_NABV12@@Z ; std::_Iterator_base_aux::_Same_container
PUBLIC	?_Has_container@_Iterator_base_aux@std@@QBE_NXZ	; std::_Iterator_base_aux::_Has_container
; Function compile flags: /Odtp
;	COMDAT ??G?$_Vector_const_iterator@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@QBEHABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??G?$_Vector_const_iterator@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@QBEHABV01@@Z PROC ; std::_Vector_const_iterator<enum _D3DFORMAT,std::allocator<enum _D3DFORMAT> >::operator-, COMDAT
; _this$ = ecx

; 186  : 		{	// return difference of iterators

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 187  : 
; 188  :  #if _HAS_ITERATOR_DEBUGGING
; 189  : 		_Compat(_Right);
; 190  :  #else
; 191  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Has_container@_Iterator_base_aux@std@@QBE_NXZ ; std::_Iterator_base_aux::_Has_container
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@operator@8
	mov	ecx, DWORD PTR __Right$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Same_container@_Iterator_base_aux@std@@QBE_NABV12@@Z ; std::_Iterator_base_aux::_Same_container
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN2@operator@8
$LN1@operator@8:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@operator@8:

; 192  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 193  : 
; 194  : 		return (_Myptr - _Right._Myptr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [eax+4]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 195  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??G?$_Vector_const_iterator@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@QBEHABV01@@Z ENDP ; std::_Vector_const_iterator<enum _D3DFORMAT,std::allocator<enum _D3DFORMAT> >::operator-
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ?_Same_container@_Iterator_base_aux@std@@QBE_NABV12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Other$ = 8						; size = 4
?_Same_container@_Iterator_base_aux@std@@QBE_NABV12@@Z PROC ; std::_Iterator_base_aux::_Same_container, COMDAT
; _this$ = ecx

; 462  : 		{	// Accelerate the comparison by not going through the aux object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 463  : 		return _Myaux == _Other._Myaux;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Other$[ebp]
	mov	edx, DWORD PTR [eax]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx]
	sete	al

; 464  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Same_container@_Iterator_base_aux@std@@QBE_NABV12@@Z ENDP ; std::_Iterator_base_aux::_Same_container
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Has_container@_Iterator_base_aux@std@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Has_container@_Iterator_base_aux@std@@QBE_NXZ PROC	; std::_Iterator_base_aux::_Has_container, COMDAT
; _this$ = ecx

; 467  : 		{	// Accelerate the comparison by not going through the aux object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 468  : 		return _Myaux != 0;

	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	cmp	DWORD PTR [eax], 0
	setne	cl
	mov	al, cl

; 469  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Has_container@_Iterator_base_aux@std@@QBE_NXZ ENDP	; std::_Iterator_base_aux::_Has_container
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@QAE@PAW4_D3DMULTISAMPLE_TYPE@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<enum _D3DMULTISAMPLE_TYPE,std::allocator<enum _D3DMULTISAMPLE_TYPE> >::_Vector_const_iterator<enum _D3DMULTISAMPLE_TYPE,std::allocator<enum _D3DMULTISAMPLE_TYPE> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$_Vector_iterator@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@QAE@PAW4_D3DMULTISAMPLE_TYPE@@PBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@QAE@PAW4_D3DMULTISAMPLE_TYPE@@PBV_Container_base_aux@1@@Z PROC ; std::_Vector_iterator<enum _D3DMULTISAMPLE_TYPE,std::allocator<enum _D3DMULTISAMPLE_TYPE> >::_Vector_iterator<enum _D3DMULTISAMPLE_TYPE,std::allocator<enum _D3DMULTISAMPLE_TYPE> >, COMDAT
; _this$ = ecx

; 327  : 		{	// construct with pointer _Ptr

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Pvector$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_const_iterator@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@QAE@PAW4_D3DMULTISAMPLE_TYPE@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<enum _D3DMULTISAMPLE_TYPE,std::allocator<enum _D3DMULTISAMPLE_TYPE> >::_Vector_const_iterator<enum _D3DMULTISAMPLE_TYPE,std::allocator<enum _D3DMULTISAMPLE_TYPE> >

; 328  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Vector_iterator@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@QAE@PAW4_D3DMULTISAMPLE_TYPE@@PBV_Container_base_aux@1@@Z ENDP ; std::_Vector_iterator<enum _D3DMULTISAMPLE_TYPE,std::allocator<enum _D3DMULTISAMPLE_TYPE> >::_Vector_iterator<enum _D3DMULTISAMPLE_TYPE,std::allocator<enum _D3DMULTISAMPLE_TYPE> >
_TEXT	ENDS
PUBLIC	??Y?$_Vector_iterator@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<enum _D3DMULTISAMPLE_TYPE,std::allocator<enum _D3DMULTISAMPLE_TYPE> >::operator+=
; Function compile flags: /Odtp
;	COMDAT ??H?$_Vector_iterator@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
__Tmp$ = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Vector_iterator@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<enum _D3DMULTISAMPLE_TYPE,std::allocator<enum _D3DMULTISAMPLE_TYPE> >::operator+, COMDAT
; _this$ = ecx

; 380  : 		{	// return this + integer

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 381  : 		_Myt _Tmp = *this;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR __Tmp$[ebp], ecx
	mov	DWORD PTR __Tmp$[ebp+4], edx

; 382  : 		return (_Tmp += _Off);

	mov	eax, DWORD PTR __Off$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Tmp$[ebp]
	call	??Y?$_Vector_iterator@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<enum _D3DMULTISAMPLE_TYPE,std::allocator<enum _D3DMULTISAMPLE_TYPE> >::operator+=
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 383  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
??H?$_Vector_iterator@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<enum _D3DMULTISAMPLE_TYPE,std::allocator<enum _D3DMULTISAMPLE_TYPE> >::operator+
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??G?$_Vector_const_iterator@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@QBEHABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??G?$_Vector_const_iterator@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@QBEHABV01@@Z PROC ; std::_Vector_const_iterator<enum _D3DMULTISAMPLE_TYPE,std::allocator<enum _D3DMULTISAMPLE_TYPE> >::operator-, COMDAT
; _this$ = ecx

; 186  : 		{	// return difference of iterators

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 187  : 
; 188  :  #if _HAS_ITERATOR_DEBUGGING
; 189  : 		_Compat(_Right);
; 190  :  #else
; 191  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Has_container@_Iterator_base_aux@std@@QBE_NXZ ; std::_Iterator_base_aux::_Has_container
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@operator@9
	mov	ecx, DWORD PTR __Right$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Same_container@_Iterator_base_aux@std@@QBE_NABV12@@Z ; std::_Iterator_base_aux::_Same_container
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN2@operator@9
$LN1@operator@9:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@operator@9:

; 192  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 193  : 
; 194  : 		return (_Myptr - _Right._Myptr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [eax+4]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 195  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??G?$_Vector_const_iterator@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@QBEHABV01@@Z ENDP ; std::_Vector_const_iterator<enum _D3DMULTISAMPLE_TYPE,std::allocator<enum _D3DMULTISAMPLE_TYPE> >::operator-
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@QAE@PAIPBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> >::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> >
; Function compile flags: /Odtp
;	COMDAT ??0?$_Vector_iterator@IV?$allocator@I@std@@@std@@QAE@PAIPBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@IV?$allocator@I@std@@@std@@QAE@PAIPBV_Container_base_aux@1@@Z PROC ; std::_Vector_iterator<unsigned int,std::allocator<unsigned int> >::_Vector_iterator<unsigned int,std::allocator<unsigned int> >, COMDAT
; _this$ = ecx

; 327  : 		{	// construct with pointer _Ptr

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Pvector$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@QAE@PAIPBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> >::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> >

; 328  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Vector_iterator@IV?$allocator@I@std@@@std@@QAE@PAIPBV_Container_base_aux@1@@Z ENDP ; std::_Vector_iterator<unsigned int,std::allocator<unsigned int> >::_Vector_iterator<unsigned int,std::allocator<unsigned int> >
_TEXT	ENDS
PUBLIC	??Y?$_Vector_iterator@IV?$allocator@I@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<unsigned int,std::allocator<unsigned int> >::operator+=
; Function compile flags: /Odtp
;	COMDAT ??H?$_Vector_iterator@IV?$allocator@I@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
__Tmp$ = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Vector_iterator@IV?$allocator@I@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<unsigned int,std::allocator<unsigned int> >::operator+, COMDAT
; _this$ = ecx

; 380  : 		{	// return this + integer

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 381  : 		_Myt _Tmp = *this;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR __Tmp$[ebp], ecx
	mov	DWORD PTR __Tmp$[ebp+4], edx

; 382  : 		return (_Tmp += _Off);

	mov	eax, DWORD PTR __Off$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Tmp$[ebp]
	call	??Y?$_Vector_iterator@IV?$allocator@I@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<unsigned int,std::allocator<unsigned int> >::operator+=
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 383  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
??H?$_Vector_iterator@IV?$allocator@I@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<unsigned int,std::allocator<unsigned int> >::operator+
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??G?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@QBEHABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??G?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@QBEHABV01@@Z PROC ; std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> >::operator-, COMDAT
; _this$ = ecx

; 186  : 		{	// return difference of iterators

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 187  : 
; 188  :  #if _HAS_ITERATOR_DEBUGGING
; 189  : 		_Compat(_Right);
; 190  :  #else
; 191  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Has_container@_Iterator_base_aux@std@@QBE_NXZ ; std::_Iterator_base_aux::_Has_container
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@operator@10
	mov	ecx, DWORD PTR __Right$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Same_container@_Iterator_base_aux@std@@QBE_NABV12@@Z ; std::_Iterator_base_aux::_Same_container
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN2@operator@10
$LN1@operator@10:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@operator@10:

; 192  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 193  : 
; 194  : 		return (_Myptr - _Right._Myptr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [eax+4]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 195  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??G?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@QBEHABV01@@Z ENDP ; std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> >::operator-
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@QAE@PAUD3DSMSCONFLICT_T@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<Ogre::D3DSMSCONFLICT_T,std::allocator<Ogre::D3DSMSCONFLICT_T> >::_Vector_const_iterator<Ogre::D3DSMSCONFLICT_T,std::allocator<Ogre::D3DSMSCONFLICT_T> >
; Function compile flags: /Odtp
;	COMDAT ??0?$_Vector_iterator@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@QAE@PAUD3DSMSCONFLICT_T@Ogre@@PBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@QAE@PAUD3DSMSCONFLICT_T@Ogre@@PBV_Container_base_aux@1@@Z PROC ; std::_Vector_iterator<Ogre::D3DSMSCONFLICT_T,std::allocator<Ogre::D3DSMSCONFLICT_T> >::_Vector_iterator<Ogre::D3DSMSCONFLICT_T,std::allocator<Ogre::D3DSMSCONFLICT_T> >, COMDAT
; _this$ = ecx

; 327  : 		{	// construct with pointer _Ptr

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Pvector$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_const_iterator@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@QAE@PAUD3DSMSCONFLICT_T@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<Ogre::D3DSMSCONFLICT_T,std::allocator<Ogre::D3DSMSCONFLICT_T> >::_Vector_const_iterator<Ogre::D3DSMSCONFLICT_T,std::allocator<Ogre::D3DSMSCONFLICT_T> >

; 328  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Vector_iterator@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@QAE@PAUD3DSMSCONFLICT_T@Ogre@@PBV_Container_base_aux@1@@Z ENDP ; std::_Vector_iterator<Ogre::D3DSMSCONFLICT_T,std::allocator<Ogre::D3DSMSCONFLICT_T> >::_Vector_iterator<Ogre::D3DSMSCONFLICT_T,std::allocator<Ogre::D3DSMSCONFLICT_T> >
_TEXT	ENDS
PUBLIC	??Y?$_Vector_iterator@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<Ogre::D3DSMSCONFLICT_T,std::allocator<Ogre::D3DSMSCONFLICT_T> >::operator+=
; Function compile flags: /Odtp
;	COMDAT ??H?$_Vector_iterator@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
__Tmp$ = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Vector_iterator@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<Ogre::D3DSMSCONFLICT_T,std::allocator<Ogre::D3DSMSCONFLICT_T> >::operator+, COMDAT
; _this$ = ecx

; 380  : 		{	// return this + integer

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 381  : 		_Myt _Tmp = *this;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR __Tmp$[ebp], ecx
	mov	DWORD PTR __Tmp$[ebp+4], edx

; 382  : 		return (_Tmp += _Off);

	mov	eax, DWORD PTR __Off$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Tmp$[ebp]
	call	??Y?$_Vector_iterator@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<Ogre::D3DSMSCONFLICT_T,std::allocator<Ogre::D3DSMSCONFLICT_T> >::operator+=
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 383  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
??H?$_Vector_iterator@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<Ogre::D3DSMSCONFLICT_T,std::allocator<Ogre::D3DSMSCONFLICT_T> >::operator+
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??G?$_Vector_const_iterator@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@QBEHABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??G?$_Vector_const_iterator@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@QBEHABV01@@Z PROC ; std::_Vector_const_iterator<Ogre::D3DSMSCONFLICT_T,std::allocator<Ogre::D3DSMSCONFLICT_T> >::operator-, COMDAT
; _this$ = ecx

; 186  : 		{	// return difference of iterators

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 187  : 
; 188  :  #if _HAS_ITERATOR_DEBUGGING
; 189  : 		_Compat(_Right);
; 190  :  #else
; 191  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Has_container@_Iterator_base_aux@std@@QBE_NXZ ; std::_Iterator_base_aux::_Has_container
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@operator@11
	mov	ecx, DWORD PTR __Right$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Same_container@_Iterator_base_aux@std@@QBE_NABV12@@Z ; std::_Iterator_base_aux::_Same_container
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN2@operator@11
$LN1@operator@11:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@operator@11:

; 192  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 193  : 
; 194  : 		return (_Myptr - _Right._Myptr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [eax+4]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 3

; 195  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??G?$_Vector_const_iterator@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@QBEHABV01@@Z ENDP ; std::_Vector_const_iterator<Ogre::D3DSMSCONFLICT_T,std::allocator<Ogre::D3DSMSCONFLICT_T> >::operator-
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@QAE@PAW4VERTPROCESS_T@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<enum Ogre::VERTPROCESS_T,std::allocator<enum Ogre::VERTPROCESS_T> >::_Vector_const_iterator<enum Ogre::VERTPROCESS_T,std::allocator<enum Ogre::VERTPROCESS_T> >
; Function compile flags: /Odtp
;	COMDAT ??0?$_Vector_iterator@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@QAE@PAW4VERTPROCESS_T@Ogre@@PBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@QAE@PAW4VERTPROCESS_T@Ogre@@PBV_Container_base_aux@1@@Z PROC ; std::_Vector_iterator<enum Ogre::VERTPROCESS_T,std::allocator<enum Ogre::VERTPROCESS_T> >::_Vector_iterator<enum Ogre::VERTPROCESS_T,std::allocator<enum Ogre::VERTPROCESS_T> >, COMDAT
; _this$ = ecx

; 327  : 		{	// construct with pointer _Ptr

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Pvector$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_const_iterator@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@QAE@PAW4VERTPROCESS_T@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<enum Ogre::VERTPROCESS_T,std::allocator<enum Ogre::VERTPROCESS_T> >::_Vector_const_iterator<enum Ogre::VERTPROCESS_T,std::allocator<enum Ogre::VERTPROCESS_T> >

; 328  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Vector_iterator@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@QAE@PAW4VERTPROCESS_T@Ogre@@PBV_Container_base_aux@1@@Z ENDP ; std::_Vector_iterator<enum Ogre::VERTPROCESS_T,std::allocator<enum Ogre::VERTPROCESS_T> >::_Vector_iterator<enum Ogre::VERTPROCESS_T,std::allocator<enum Ogre::VERTPROCESS_T> >
_TEXT	ENDS
PUBLIC	??Y?$_Vector_iterator@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<enum Ogre::VERTPROCESS_T,std::allocator<enum Ogre::VERTPROCESS_T> >::operator+=
; Function compile flags: /Odtp
;	COMDAT ??H?$_Vector_iterator@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
__Tmp$ = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Vector_iterator@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<enum Ogre::VERTPROCESS_T,std::allocator<enum Ogre::VERTPROCESS_T> >::operator+, COMDAT
; _this$ = ecx

; 380  : 		{	// return this + integer

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 381  : 		_Myt _Tmp = *this;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR __Tmp$[ebp], ecx
	mov	DWORD PTR __Tmp$[ebp+4], edx

; 382  : 		return (_Tmp += _Off);

	mov	eax, DWORD PTR __Off$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Tmp$[ebp]
	call	??Y?$_Vector_iterator@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<enum Ogre::VERTPROCESS_T,std::allocator<enum Ogre::VERTPROCESS_T> >::operator+=
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 383  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
??H?$_Vector_iterator@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<enum Ogre::VERTPROCESS_T,std::allocator<enum Ogre::VERTPROCESS_T> >::operator+
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??G?$_Vector_const_iterator@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@QBEHABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??G?$_Vector_const_iterator@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@QBEHABV01@@Z PROC ; std::_Vector_const_iterator<enum Ogre::VERTPROCESS_T,std::allocator<enum Ogre::VERTPROCESS_T> >::operator-, COMDAT
; _this$ = ecx

; 186  : 		{	// return difference of iterators

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 187  : 
; 188  :  #if _HAS_ITERATOR_DEBUGGING
; 189  : 		_Compat(_Right);
; 190  :  #else
; 191  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Has_container@_Iterator_base_aux@std@@QBE_NXZ ; std::_Iterator_base_aux::_Has_container
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@operator@12
	mov	ecx, DWORD PTR __Right$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Same_container@_Iterator_base_aux@std@@QBE_NABV12@@Z ; std::_Iterator_base_aux::_Same_container
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN2@operator@12
$LN1@operator@12:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@operator@12:

; 192  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 193  : 
; 194  : 		return (_Myptr - _Right._Myptr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [eax+4]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 195  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??G?$_Vector_const_iterator@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@QBEHABV01@@Z ENDP ; std::_Vector_const_iterator<enum Ogre::VERTPROCESS_T,std::allocator<enum Ogre::VERTPROCESS_T> >::operator-
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@QAE@PAPAUD3DDEVCOMBO_T@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<Ogre::D3DDEVCOMBO_T *,std::allocator<Ogre::D3DDEVCOMBO_T *> >::_Vector_const_iterator<Ogre::D3DDEVCOMBO_T *,std::allocator<Ogre::D3DDEVCOMBO_T *> >
; Function compile flags: /Odtp
;	COMDAT ??0?$_Vector_iterator@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@QAE@PAPAUD3DDEVCOMBO_T@Ogre@@PBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@QAE@PAPAUD3DDEVCOMBO_T@Ogre@@PBV_Container_base_aux@1@@Z PROC ; std::_Vector_iterator<Ogre::D3DDEVCOMBO_T *,std::allocator<Ogre::D3DDEVCOMBO_T *> >::_Vector_iterator<Ogre::D3DDEVCOMBO_T *,std::allocator<Ogre::D3DDEVCOMBO_T *> >, COMDAT
; _this$ = ecx

; 327  : 		{	// construct with pointer _Ptr

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Pvector$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_const_iterator@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@QAE@PAPAUD3DDEVCOMBO_T@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<Ogre::D3DDEVCOMBO_T *,std::allocator<Ogre::D3DDEVCOMBO_T *> >::_Vector_const_iterator<Ogre::D3DDEVCOMBO_T *,std::allocator<Ogre::D3DDEVCOMBO_T *> >

; 328  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Vector_iterator@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@QAE@PAPAUD3DDEVCOMBO_T@Ogre@@PBV_Container_base_aux@1@@Z ENDP ; std::_Vector_iterator<Ogre::D3DDEVCOMBO_T *,std::allocator<Ogre::D3DDEVCOMBO_T *> >::_Vector_iterator<Ogre::D3DDEVCOMBO_T *,std::allocator<Ogre::D3DDEVCOMBO_T *> >
_TEXT	ENDS
PUBLIC	??Y?$_Vector_iterator@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<Ogre::D3DDEVCOMBO_T *,std::allocator<Ogre::D3DDEVCOMBO_T *> >::operator+=
; Function compile flags: /Odtp
;	COMDAT ??H?$_Vector_iterator@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
__Tmp$ = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Vector_iterator@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<Ogre::D3DDEVCOMBO_T *,std::allocator<Ogre::D3DDEVCOMBO_T *> >::operator+, COMDAT
; _this$ = ecx

; 380  : 		{	// return this + integer

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 381  : 		_Myt _Tmp = *this;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR __Tmp$[ebp], ecx
	mov	DWORD PTR __Tmp$[ebp+4], edx

; 382  : 		return (_Tmp += _Off);

	mov	eax, DWORD PTR __Off$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Tmp$[ebp]
	call	??Y?$_Vector_iterator@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<Ogre::D3DDEVCOMBO_T *,std::allocator<Ogre::D3DDEVCOMBO_T *> >::operator+=
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 383  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
??H?$_Vector_iterator@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<Ogre::D3DDEVCOMBO_T *,std::allocator<Ogre::D3DDEVCOMBO_T *> >::operator+
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??G?$_Vector_const_iterator@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@QBEHABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??G?$_Vector_const_iterator@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@QBEHABV01@@Z PROC ; std::_Vector_const_iterator<Ogre::D3DDEVCOMBO_T *,std::allocator<Ogre::D3DDEVCOMBO_T *> >::operator-, COMDAT
; _this$ = ecx

; 186  : 		{	// return difference of iterators

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 187  : 
; 188  :  #if _HAS_ITERATOR_DEBUGGING
; 189  : 		_Compat(_Right);
; 190  :  #else
; 191  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Has_container@_Iterator_base_aux@std@@QBE_NXZ ; std::_Iterator_base_aux::_Has_container
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@operator@13
	mov	ecx, DWORD PTR __Right$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Same_container@_Iterator_base_aux@std@@QBE_NABV12@@Z ; std::_Iterator_base_aux::_Same_container
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN2@operator@13
$LN1@operator@13:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@operator@13:

; 192  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 193  : 
; 194  : 		return (_Myptr - _Right._Myptr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [eax+4]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 195  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??G?$_Vector_const_iterator@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@QBEHABV01@@Z ENDP ; std::_Vector_const_iterator<Ogre::D3DDEVCOMBO_T *,std::allocator<Ogre::D3DDEVCOMBO_T *> >::operator-
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@QAE@PAU_D3DDISPLAYMODE@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<_D3DDISPLAYMODE,std::allocator<_D3DDISPLAYMODE> >::_Vector_const_iterator<_D3DDISPLAYMODE,std::allocator<_D3DDISPLAYMODE> >
; Function compile flags: /Odtp
;	COMDAT ??0?$_Vector_iterator@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@QAE@PAU_D3DDISPLAYMODE@@PBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@QAE@PAU_D3DDISPLAYMODE@@PBV_Container_base_aux@1@@Z PROC ; std::_Vector_iterator<_D3DDISPLAYMODE,std::allocator<_D3DDISPLAYMODE> >::_Vector_iterator<_D3DDISPLAYMODE,std::allocator<_D3DDISPLAYMODE> >, COMDAT
; _this$ = ecx

; 327  : 		{	// construct with pointer _Ptr

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Pvector$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_const_iterator@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@QAE@PAU_D3DDISPLAYMODE@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<_D3DDISPLAYMODE,std::allocator<_D3DDISPLAYMODE> >::_Vector_const_iterator<_D3DDISPLAYMODE,std::allocator<_D3DDISPLAYMODE> >

; 328  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Vector_iterator@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@QAE@PAU_D3DDISPLAYMODE@@PBV_Container_base_aux@1@@Z ENDP ; std::_Vector_iterator<_D3DDISPLAYMODE,std::allocator<_D3DDISPLAYMODE> >::_Vector_iterator<_D3DDISPLAYMODE,std::allocator<_D3DDISPLAYMODE> >
_TEXT	ENDS
PUBLIC	??Y?$_Vector_iterator@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<_D3DDISPLAYMODE,std::allocator<_D3DDISPLAYMODE> >::operator+=
; Function compile flags: /Odtp
;	COMDAT ??H?$_Vector_iterator@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
__Tmp$ = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Vector_iterator@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<_D3DDISPLAYMODE,std::allocator<_D3DDISPLAYMODE> >::operator+, COMDAT
; _this$ = ecx

; 380  : 		{	// return this + integer

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 381  : 		_Myt _Tmp = *this;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR __Tmp$[ebp], ecx
	mov	DWORD PTR __Tmp$[ebp+4], edx

; 382  : 		return (_Tmp += _Off);

	mov	eax, DWORD PTR __Off$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Tmp$[ebp]
	call	??Y?$_Vector_iterator@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<_D3DDISPLAYMODE,std::allocator<_D3DDISPLAYMODE> >::operator+=
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 383  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
??H?$_Vector_iterator@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<_D3DDISPLAYMODE,std::allocator<_D3DDISPLAYMODE> >::operator+
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??G?$_Vector_const_iterator@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@QBEHABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??G?$_Vector_const_iterator@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@QBEHABV01@@Z PROC ; std::_Vector_const_iterator<_D3DDISPLAYMODE,std::allocator<_D3DDISPLAYMODE> >::operator-, COMDAT
; _this$ = ecx

; 186  : 		{	// return difference of iterators

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 187  : 
; 188  :  #if _HAS_ITERATOR_DEBUGGING
; 189  : 		_Compat(_Right);
; 190  :  #else
; 191  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Has_container@_Iterator_base_aux@std@@QBE_NXZ ; std::_Iterator_base_aux::_Has_container
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@operator@14
	mov	ecx, DWORD PTR __Right$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Same_container@_Iterator_base_aux@std@@QBE_NABV12@@Z ; std::_Iterator_base_aux::_Same_container
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN2@operator@14
$LN1@operator@14:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@operator@14:

; 192  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 193  : 
; 194  : 		return (_Myptr - _Right._Myptr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [eax+4]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 4

; 195  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??G?$_Vector_const_iterator@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@QBEHABV01@@Z ENDP ; std::_Vector_const_iterator<_D3DDISPLAYMODE,std::allocator<_D3DDISPLAYMODE> >::operator-
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@QAE@PAPAUD3DDEVICEINFO_T@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<Ogre::D3DDEVICEINFO_T *,std::allocator<Ogre::D3DDEVICEINFO_T *> >::_Vector_const_iterator<Ogre::D3DDEVICEINFO_T *,std::allocator<Ogre::D3DDEVICEINFO_T *> >
; Function compile flags: /Odtp
;	COMDAT ??0?$_Vector_iterator@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@QAE@PAPAUD3DDEVICEINFO_T@Ogre@@PBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@QAE@PAPAUD3DDEVICEINFO_T@Ogre@@PBV_Container_base_aux@1@@Z PROC ; std::_Vector_iterator<Ogre::D3DDEVICEINFO_T *,std::allocator<Ogre::D3DDEVICEINFO_T *> >::_Vector_iterator<Ogre::D3DDEVICEINFO_T *,std::allocator<Ogre::D3DDEVICEINFO_T *> >, COMDAT
; _this$ = ecx

; 327  : 		{	// construct with pointer _Ptr

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Pvector$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_const_iterator@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@QAE@PAPAUD3DDEVICEINFO_T@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<Ogre::D3DDEVICEINFO_T *,std::allocator<Ogre::D3DDEVICEINFO_T *> >::_Vector_const_iterator<Ogre::D3DDEVICEINFO_T *,std::allocator<Ogre::D3DDEVICEINFO_T *> >

; 328  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Vector_iterator@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@QAE@PAPAUD3DDEVICEINFO_T@Ogre@@PBV_Container_base_aux@1@@Z ENDP ; std::_Vector_iterator<Ogre::D3DDEVICEINFO_T *,std::allocator<Ogre::D3DDEVICEINFO_T *> >::_Vector_iterator<Ogre::D3DDEVICEINFO_T *,std::allocator<Ogre::D3DDEVICEINFO_T *> >
_TEXT	ENDS
PUBLIC	??Y?$_Vector_iterator@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<Ogre::D3DDEVICEINFO_T *,std::allocator<Ogre::D3DDEVICEINFO_T *> >::operator+=
; Function compile flags: /Odtp
;	COMDAT ??H?$_Vector_iterator@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
__Tmp$ = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Vector_iterator@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<Ogre::D3DDEVICEINFO_T *,std::allocator<Ogre::D3DDEVICEINFO_T *> >::operator+, COMDAT
; _this$ = ecx

; 380  : 		{	// return this + integer

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 381  : 		_Myt _Tmp = *this;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR __Tmp$[ebp], ecx
	mov	DWORD PTR __Tmp$[ebp+4], edx

; 382  : 		return (_Tmp += _Off);

	mov	eax, DWORD PTR __Off$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Tmp$[ebp]
	call	??Y?$_Vector_iterator@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<Ogre::D3DDEVICEINFO_T *,std::allocator<Ogre::D3DDEVICEINFO_T *> >::operator+=
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 383  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
??H?$_Vector_iterator@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<Ogre::D3DDEVICEINFO_T *,std::allocator<Ogre::D3DDEVICEINFO_T *> >::operator+
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??G?$_Vector_const_iterator@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@QBEHABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??G?$_Vector_const_iterator@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@QBEHABV01@@Z PROC ; std::_Vector_const_iterator<Ogre::D3DDEVICEINFO_T *,std::allocator<Ogre::D3DDEVICEINFO_T *> >::operator-, COMDAT
; _this$ = ecx

; 186  : 		{	// return difference of iterators

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 187  : 
; 188  :  #if _HAS_ITERATOR_DEBUGGING
; 189  : 		_Compat(_Right);
; 190  :  #else
; 191  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Has_container@_Iterator_base_aux@std@@QBE_NXZ ; std::_Iterator_base_aux::_Has_container
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@operator@15
	mov	ecx, DWORD PTR __Right$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Same_container@_Iterator_base_aux@std@@QBE_NABV12@@Z ; std::_Iterator_base_aux::_Same_container
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN2@operator@15
$LN1@operator@15:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@operator@15:

; 192  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 193  : 
; 194  : 		return (_Myptr - _Right._Myptr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [eax+4]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 195  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??G?$_Vector_const_iterator@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@QBEHABV01@@Z ENDP ; std::_Vector_const_iterator<Ogre::D3DDEVICEINFO_T *,std::allocator<Ogre::D3DDEVICEINFO_T *> >::operator-
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@QAE@PAPAUD3DADAPTER_T@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<Ogre::D3DADAPTER_T *,std::allocator<Ogre::D3DADAPTER_T *> >::_Vector_const_iterator<Ogre::D3DADAPTER_T *,std::allocator<Ogre::D3DADAPTER_T *> >
; Function compile flags: /Odtp
;	COMDAT ??0?$_Vector_iterator@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@QAE@PAPAUD3DADAPTER_T@Ogre@@PBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@QAE@PAPAUD3DADAPTER_T@Ogre@@PBV_Container_base_aux@1@@Z PROC ; std::_Vector_iterator<Ogre::D3DADAPTER_T *,std::allocator<Ogre::D3DADAPTER_T *> >::_Vector_iterator<Ogre::D3DADAPTER_T *,std::allocator<Ogre::D3DADAPTER_T *> >, COMDAT
; _this$ = ecx

; 327  : 		{	// construct with pointer _Ptr

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Pvector$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_const_iterator@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@QAE@PAPAUD3DADAPTER_T@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<Ogre::D3DADAPTER_T *,std::allocator<Ogre::D3DADAPTER_T *> >::_Vector_const_iterator<Ogre::D3DADAPTER_T *,std::allocator<Ogre::D3DADAPTER_T *> >

; 328  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Vector_iterator@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@QAE@PAPAUD3DADAPTER_T@Ogre@@PBV_Container_base_aux@1@@Z ENDP ; std::_Vector_iterator<Ogre::D3DADAPTER_T *,std::allocator<Ogre::D3DADAPTER_T *> >::_Vector_iterator<Ogre::D3DADAPTER_T *,std::allocator<Ogre::D3DADAPTER_T *> >
_TEXT	ENDS
PUBLIC	??Y?$_Vector_iterator@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<Ogre::D3DADAPTER_T *,std::allocator<Ogre::D3DADAPTER_T *> >::operator+=
; Function compile flags: /Odtp
;	COMDAT ??H?$_Vector_iterator@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
__Tmp$ = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Vector_iterator@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<Ogre::D3DADAPTER_T *,std::allocator<Ogre::D3DADAPTER_T *> >::operator+, COMDAT
; _this$ = ecx

; 380  : 		{	// return this + integer

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 381  : 		_Myt _Tmp = *this;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR __Tmp$[ebp], ecx
	mov	DWORD PTR __Tmp$[ebp+4], edx

; 382  : 		return (_Tmp += _Off);

	mov	eax, DWORD PTR __Off$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Tmp$[ebp]
	call	??Y?$_Vector_iterator@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<Ogre::D3DADAPTER_T *,std::allocator<Ogre::D3DADAPTER_T *> >::operator+=
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 383  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
??H?$_Vector_iterator@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<Ogre::D3DADAPTER_T *,std::allocator<Ogre::D3DADAPTER_T *> >::operator+
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??G?$_Vector_const_iterator@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@QBEHABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??G?$_Vector_const_iterator@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@QBEHABV01@@Z PROC ; std::_Vector_const_iterator<Ogre::D3DADAPTER_T *,std::allocator<Ogre::D3DADAPTER_T *> >::operator-, COMDAT
; _this$ = ecx

; 186  : 		{	// return difference of iterators

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 187  : 
; 188  :  #if _HAS_ITERATOR_DEBUGGING
; 189  : 		_Compat(_Right);
; 190  :  #else
; 191  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Has_container@_Iterator_base_aux@std@@QBE_NXZ ; std::_Iterator_base_aux::_Has_container
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@operator@16
	mov	ecx, DWORD PTR __Right$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Same_container@_Iterator_base_aux@std@@QBE_NABV12@@Z ; std::_Iterator_base_aux::_Same_container
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN2@operator@16
$LN1@operator@16:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@operator@16:

; 192  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 193  : 
; 194  : 		return (_Myptr - _Right._Myptr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [eax+4]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 195  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??G?$_Vector_const_iterator@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@QBEHABV01@@Z ENDP ; std::_Vector_const_iterator<Ogre::D3DADAPTER_T *,std::allocator<Ogre::D3DADAPTER_T *> >::operator-
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0length_error@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0length_error@std@@QAE@ABV01@@Z$0
__ehfuncinfo$??0length_error@std@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0length_error@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0length_error@std@@QAE@ABV01@@Z PROC			; std::length_error::length_error, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0length_error@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0logic_error@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7length_error@std@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0length_error@std@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1logic_error@std@@UAE@XZ		; std::logic_error::~logic_error
__ehhandler$??0length_error@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0length_error@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0length_error@std@@QAE@ABV01@@Z ENDP			; std::length_error::length_error
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?max_size@?$allocator@W4_D3DFORMAT@@@std@@QBEIXZ
_TEXT	SEGMENT
tv65 = -12						; size = 4
_this$ = -8						; size = 4
__Count$ = -4						; size = 4
?max_size@?$allocator@W4_D3DFORMAT@@@std@@QBEIXZ PROC	; std::allocator<enum _D3DFORMAT>::max_size, COMDAT
; _this$ = ecx

; 164  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);

	mov	DWORD PTR __Count$[ebp], 1073741823	; 3fffffffH

; 166  : 		return (0 < _Count ? _Count : 1);

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN3@max_size
	mov	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR tv65[ebp], eax
	jmp	SHORT $LN4@max_size
$LN3@max_size:
	mov	DWORD PTR tv65[ebp], 1
$LN4@max_size:
	mov	eax, DWORD PTR tv65[ebp]

; 167  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$allocator@W4_D3DFORMAT@@@std@@QBEIXZ ENDP	; std::allocator<enum _D3DFORMAT>::max_size
_TEXT	ENDS
PUBLIC	??$_Allocate@V_Aux_cont@std@@@std@@YAPAV_Aux_cont@0@IPAV10@@Z ; std::_Allocate<std::_Aux_cont>
; Function compile flags: /Odtp
;	COMDAT ?allocate@?$allocator@V_Aux_cont@std@@@std@@QAEPAV_Aux_cont@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@V_Aux_cont@std@@@std@@QAEPAV_Aux_cont@2@I@Z PROC ; std::allocator<std::_Aux_cont>::allocate, COMDAT
; _this$ = ecx

; 144  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@V_Aux_cont@std@@@std@@YAPAV_Aux_cont@0@IPAV10@@Z ; std::_Allocate<std::_Aux_cont>
	add	esp, 8

; 146  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@V_Aux_cont@std@@@std@@QAEPAV_Aux_cont@2@I@Z ENDP ; std::allocator<std::_Aux_cont>::allocate
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@QBEIXZ
_TEXT	SEGMENT
tv65 = -12						; size = 4
_this$ = -8						; size = 4
__Count$ = -4						; size = 4
?max_size@?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@QBEIXZ PROC ; std::allocator<enum _D3DMULTISAMPLE_TYPE>::max_size, COMDAT
; _this$ = ecx

; 164  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);

	mov	DWORD PTR __Count$[ebp], 1073741823	; 3fffffffH

; 166  : 		return (0 < _Count ? _Count : 1);

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN3@max_size@2
	mov	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR tv65[ebp], eax
	jmp	SHORT $LN4@max_size@2
$LN3@max_size@2:
	mov	DWORD PTR tv65[ebp], 1
$LN4@max_size@2:
	mov	eax, DWORD PTR tv65[ebp]

; 167  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@QBEIXZ ENDP ; std::allocator<enum _D3DMULTISAMPLE_TYPE>::max_size
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@I@std@@QBEIXZ
_TEXT	SEGMENT
tv65 = -12						; size = 4
_this$ = -8						; size = 4
__Count$ = -4						; size = 4
?max_size@?$allocator@I@std@@QBEIXZ PROC		; std::allocator<unsigned int>::max_size, COMDAT
; _this$ = ecx

; 164  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);

	mov	DWORD PTR __Count$[ebp], 1073741823	; 3fffffffH

; 166  : 		return (0 < _Count ? _Count : 1);

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN3@max_size@3
	mov	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR tv65[ebp], eax
	jmp	SHORT $LN4@max_size@3
$LN3@max_size@3:
	mov	DWORD PTR tv65[ebp], 1
$LN4@max_size@3:
	mov	eax, DWORD PTR tv65[ebp]

; 167  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$allocator@I@std@@QBEIXZ ENDP		; std::allocator<unsigned int>::max_size
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@QBEIXZ
_TEXT	SEGMENT
tv65 = -12						; size = 4
_this$ = -8						; size = 4
__Count$ = -4						; size = 4
?max_size@?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@QBEIXZ PROC ; std::allocator<Ogre::D3DSMSCONFLICT_T>::max_size, COMDAT
; _this$ = ecx

; 164  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);

	mov	DWORD PTR __Count$[ebp], 536870911	; 1fffffffH

; 166  : 		return (0 < _Count ? _Count : 1);

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN3@max_size@4
	mov	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR tv65[ebp], eax
	jmp	SHORT $LN4@max_size@4
$LN3@max_size@4:
	mov	DWORD PTR tv65[ebp], 1
$LN4@max_size@4:
	mov	eax, DWORD PTR tv65[ebp]

; 167  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@QBEIXZ ENDP ; std::allocator<Ogre::D3DSMSCONFLICT_T>::max_size
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@W4VERTPROCESS_T@Ogre@@@std@@QBEIXZ
_TEXT	SEGMENT
tv65 = -12						; size = 4
_this$ = -8						; size = 4
__Count$ = -4						; size = 4
?max_size@?$allocator@W4VERTPROCESS_T@Ogre@@@std@@QBEIXZ PROC ; std::allocator<enum Ogre::VERTPROCESS_T>::max_size, COMDAT
; _this$ = ecx

; 164  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);

	mov	DWORD PTR __Count$[ebp], 1073741823	; 3fffffffH

; 166  : 		return (0 < _Count ? _Count : 1);

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN3@max_size@5
	mov	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR tv65[ebp], eax
	jmp	SHORT $LN4@max_size@5
$LN3@max_size@5:
	mov	DWORD PTR tv65[ebp], 1
$LN4@max_size@5:
	mov	eax, DWORD PTR tv65[ebp]

; 167  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$allocator@W4VERTPROCESS_T@Ogre@@@std@@QBEIXZ ENDP ; std::allocator<enum Ogre::VERTPROCESS_T>::max_size
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@QBEIXZ
_TEXT	SEGMENT
tv65 = -12						; size = 4
_this$ = -8						; size = 4
__Count$ = -4						; size = 4
?max_size@?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@QBEIXZ PROC ; std::allocator<Ogre::D3DDEVCOMBO_T *>::max_size, COMDAT
; _this$ = ecx

; 164  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);

	mov	DWORD PTR __Count$[ebp], 1073741823	; 3fffffffH

; 166  : 		return (0 < _Count ? _Count : 1);

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN3@max_size@6
	mov	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR tv65[ebp], eax
	jmp	SHORT $LN4@max_size@6
$LN3@max_size@6:
	mov	DWORD PTR tv65[ebp], 1
$LN4@max_size@6:
	mov	eax, DWORD PTR tv65[ebp]

; 167  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@QBEIXZ ENDP ; std::allocator<Ogre::D3DDEVCOMBO_T *>::max_size
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@U_D3DDISPLAYMODE@@@std@@QBEIXZ
_TEXT	SEGMENT
tv65 = -12						; size = 4
_this$ = -8						; size = 4
__Count$ = -4						; size = 4
?max_size@?$allocator@U_D3DDISPLAYMODE@@@std@@QBEIXZ PROC ; std::allocator<_D3DDISPLAYMODE>::max_size, COMDAT
; _this$ = ecx

; 164  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);

	mov	DWORD PTR __Count$[ebp], 268435455	; 0fffffffH

; 166  : 		return (0 < _Count ? _Count : 1);

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN3@max_size@7
	mov	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR tv65[ebp], eax
	jmp	SHORT $LN4@max_size@7
$LN3@max_size@7:
	mov	DWORD PTR tv65[ebp], 1
$LN4@max_size@7:
	mov	eax, DWORD PTR tv65[ebp]

; 167  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$allocator@U_D3DDISPLAYMODE@@@std@@QBEIXZ ENDP ; std::allocator<_D3DDISPLAYMODE>::max_size
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@QBEIXZ
_TEXT	SEGMENT
tv65 = -12						; size = 4
_this$ = -8						; size = 4
__Count$ = -4						; size = 4
?max_size@?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@QBEIXZ PROC ; std::allocator<Ogre::D3DDEVICEINFO_T *>::max_size, COMDAT
; _this$ = ecx

; 164  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);

	mov	DWORD PTR __Count$[ebp], 1073741823	; 3fffffffH

; 166  : 		return (0 < _Count ? _Count : 1);

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN3@max_size@8
	mov	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR tv65[ebp], eax
	jmp	SHORT $LN4@max_size@8
$LN3@max_size@8:
	mov	DWORD PTR tv65[ebp], 1
$LN4@max_size@8:
	mov	eax, DWORD PTR tv65[ebp]

; 167  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@QBEIXZ ENDP ; std::allocator<Ogre::D3DDEVICEINFO_T *>::max_size
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@QBEIXZ
_TEXT	SEGMENT
tv65 = -12						; size = 4
_this$ = -8						; size = 4
__Count$ = -4						; size = 4
?max_size@?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@QBEIXZ PROC ; std::allocator<Ogre::D3DADAPTER_T *>::max_size, COMDAT
; _this$ = ecx

; 164  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);

	mov	DWORD PTR __Count$[ebp], 1073741823	; 3fffffffH

; 166  : 		return (0 < _Count ? _Count : 1);

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN3@max_size@9
	mov	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR tv65[ebp], eax
	jmp	SHORT $LN4@max_size@9
$LN3@max_size@9:
	mov	DWORD PTR tv65[ebp], 1
$LN4@max_size@9:
	mov	eax, DWORD PTR tv65[ebp]

; 167  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@QBEIXZ ENDP ; std::allocator<Ogre::D3DADAPTER_T *>::max_size
_TEXT	ENDS
PUBLIC	??Y?$_Vector_const_iterator@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<enum _D3DFORMAT,std::allocator<enum _D3DFORMAT> >::operator+=
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??Y?$_Vector_iterator@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
??Y?$_Vector_iterator@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<enum _D3DFORMAT,std::allocator<enum _D3DFORMAT> >::operator+=, COMDAT
; _this$ = ecx

; 374  : 		{	// increment by integer

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 375  : 		(*(_Mybase *)this) += _Off;

	mov	eax, DWORD PTR __Off$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??Y?$_Vector_const_iterator@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<enum _D3DFORMAT,std::allocator<enum _D3DFORMAT> >::operator+=

; 376  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 377  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??Y?$_Vector_iterator@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<enum _D3DFORMAT,std::allocator<enum _D3DFORMAT> >::operator+=
_TEXT	ENDS
PUBLIC	?_Set_container@_Iterator_base_aux@std@@QAEXQBV_Container_base_aux@2@@Z ; std::_Iterator_base_aux::_Set_container
PUBLIC	??0?$_Ranit@W4_D3DFORMAT@@HPBW41@ABW41@@std@@QAE@XZ ; std::_Ranit<enum _D3DFORMAT,int,enum _D3DFORMAT const *,enum _D3DFORMAT const &>::_Ranit<enum _D3DFORMAT,int,enum _D3DFORMAT const *,enum _D3DFORMAT const &>
; Function compile flags: /Odtp
;	COMDAT ??0?$_Vector_const_iterator@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@QAE@PAW4_D3DFORMAT@@PBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@QAE@PAW4_D3DFORMAT@@PBV_Container_base_aux@1@@Z PROC ; std::_Vector_const_iterator<enum _D3DFORMAT,std::allocator<enum _D3DFORMAT> >::_Vector_const_iterator<enum _D3DFORMAT,std::allocator<enum _D3DFORMAT> >, COMDAT
; _this$ = ecx

; 76   : 	_Vector_const_iterator(_Tptr _Ptr, const _Container_base *_Pvector)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Ranit@W4_D3DFORMAT@@HPBW41@ABW41@@std@@QAE@XZ

; 77   : 		{	// construct with pointer _Ptr
; 78   : 		_SCL_SECURE_VALIDATE(_Pvector != NULL && ((_Myvec *)_Pvector)->_Myfirst <= _Ptr && _Ptr <= ((_Myvec *)_Pvector)->_Mylast);

	cmp	DWORD PTR __Pvector$[ebp], 0
	je	SHORT $LN1@Vector_con
	mov	eax, DWORD PTR __Pvector$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	cmp	ecx, DWORD PTR __Ptr$[ebp]
	ja	SHORT $LN1@Vector_con
	mov	edx, DWORD PTR __Pvector$[ebp]
	mov	eax, DWORD PTR __Ptr$[ebp]
	cmp	eax, DWORD PTR [edx+16]
	jbe	SHORT $LN2@Vector_con
$LN1@Vector_con:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@Vector_con:

; 79   : 		this->_Set_container(_Pvector);

	mov	ecx, DWORD PTR __Pvector$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Set_container@_Iterator_base_aux@std@@QAEXQBV_Container_base_aux@2@@Z ; std::_Iterator_base_aux::_Set_container

; 80   : 		_Myptr = _Ptr;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR [edx+4], eax

; 81   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Vector_const_iterator@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@QAE@PAW4_D3DFORMAT@@PBV_Container_base_aux@1@@Z ENDP ; std::_Vector_const_iterator<enum _D3DFORMAT,std::allocator<enum _D3DFORMAT> >::_Vector_const_iterator<enum _D3DFORMAT,std::allocator<enum _D3DFORMAT> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ?_Set_container@_Iterator_base_aux@std@@QAEXQBV_Container_base_aux@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pcont$ = 8						; size = 4
?_Set_container@_Iterator_base_aux@std@@QAEXQBV_Container_base_aux@2@@Z PROC ; std::_Iterator_base_aux::_Set_container, COMDAT
; _this$ = ecx

; 452  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 453  : 		_Myaux = _Pcont->_Myownedaux;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Pcont$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 454  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Set_container@_Iterator_base_aux@std@@QAEXQBV_Container_base_aux@2@@Z ENDP ; std::_Iterator_base_aux::_Set_container
_TEXT	ENDS
PUBLIC	??Y?$_Vector_const_iterator@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<enum _D3DMULTISAMPLE_TYPE,std::allocator<enum _D3DMULTISAMPLE_TYPE> >::operator+=
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??Y?$_Vector_iterator@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
??Y?$_Vector_iterator@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<enum _D3DMULTISAMPLE_TYPE,std::allocator<enum _D3DMULTISAMPLE_TYPE> >::operator+=, COMDAT
; _this$ = ecx

; 374  : 		{	// increment by integer

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 375  : 		(*(_Mybase *)this) += _Off;

	mov	eax, DWORD PTR __Off$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??Y?$_Vector_const_iterator@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<enum _D3DMULTISAMPLE_TYPE,std::allocator<enum _D3DMULTISAMPLE_TYPE> >::operator+=

; 376  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 377  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??Y?$_Vector_iterator@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<enum _D3DMULTISAMPLE_TYPE,std::allocator<enum _D3DMULTISAMPLE_TYPE> >::operator+=
_TEXT	ENDS
PUBLIC	??0?$_Ranit@W4_D3DMULTISAMPLE_TYPE@@HPBW41@ABW41@@std@@QAE@XZ ; std::_Ranit<enum _D3DMULTISAMPLE_TYPE,int,enum _D3DMULTISAMPLE_TYPE const *,enum _D3DMULTISAMPLE_TYPE const &>::_Ranit<enum _D3DMULTISAMPLE_TYPE,int,enum _D3DMULTISAMPLE_TYPE const *,enum _D3DMULTISAMPLE_TYPE const &>
; Function compile flags: /Odtp
;	COMDAT ??0?$_Vector_const_iterator@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@QAE@PAW4_D3DMULTISAMPLE_TYPE@@PBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@QAE@PAW4_D3DMULTISAMPLE_TYPE@@PBV_Container_base_aux@1@@Z PROC ; std::_Vector_const_iterator<enum _D3DMULTISAMPLE_TYPE,std::allocator<enum _D3DMULTISAMPLE_TYPE> >::_Vector_const_iterator<enum _D3DMULTISAMPLE_TYPE,std::allocator<enum _D3DMULTISAMPLE_TYPE> >, COMDAT
; _this$ = ecx

; 76   : 	_Vector_const_iterator(_Tptr _Ptr, const _Container_base *_Pvector)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Ranit@W4_D3DMULTISAMPLE_TYPE@@HPBW41@ABW41@@std@@QAE@XZ

; 77   : 		{	// construct with pointer _Ptr
; 78   : 		_SCL_SECURE_VALIDATE(_Pvector != NULL && ((_Myvec *)_Pvector)->_Myfirst <= _Ptr && _Ptr <= ((_Myvec *)_Pvector)->_Mylast);

	cmp	DWORD PTR __Pvector$[ebp], 0
	je	SHORT $LN1@Vector_con@2
	mov	eax, DWORD PTR __Pvector$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	cmp	ecx, DWORD PTR __Ptr$[ebp]
	ja	SHORT $LN1@Vector_con@2
	mov	edx, DWORD PTR __Pvector$[ebp]
	mov	eax, DWORD PTR __Ptr$[ebp]
	cmp	eax, DWORD PTR [edx+16]
	jbe	SHORT $LN2@Vector_con@2
$LN1@Vector_con@2:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@Vector_con@2:

; 79   : 		this->_Set_container(_Pvector);

	mov	ecx, DWORD PTR __Pvector$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Set_container@_Iterator_base_aux@std@@QAEXQBV_Container_base_aux@2@@Z ; std::_Iterator_base_aux::_Set_container

; 80   : 		_Myptr = _Ptr;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR [edx+4], eax

; 81   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Vector_const_iterator@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@QAE@PAW4_D3DMULTISAMPLE_TYPE@@PBV_Container_base_aux@1@@Z ENDP ; std::_Vector_const_iterator<enum _D3DMULTISAMPLE_TYPE,std::allocator<enum _D3DMULTISAMPLE_TYPE> >::_Vector_const_iterator<enum _D3DMULTISAMPLE_TYPE,std::allocator<enum _D3DMULTISAMPLE_TYPE> >
_TEXT	ENDS
PUBLIC	??Y?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> >::operator+=
; Function compile flags: /Odtp
;	COMDAT ??Y?$_Vector_iterator@IV?$allocator@I@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
??Y?$_Vector_iterator@IV?$allocator@I@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<unsigned int,std::allocator<unsigned int> >::operator+=, COMDAT
; _this$ = ecx

; 374  : 		{	// increment by integer

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 375  : 		(*(_Mybase *)this) += _Off;

	mov	eax, DWORD PTR __Off$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??Y?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> >::operator+=

; 376  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 377  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??Y?$_Vector_iterator@IV?$allocator@I@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<unsigned int,std::allocator<unsigned int> >::operator+=
_TEXT	ENDS
PUBLIC	??0?$_Ranit@IHPBIABI@std@@QAE@XZ		; std::_Ranit<unsigned int,int,unsigned int const *,unsigned int const &>::_Ranit<unsigned int,int,unsigned int const *,unsigned int const &>
; Function compile flags: /Odtp
;	COMDAT ??0?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@QAE@PAIPBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@QAE@PAIPBV_Container_base_aux@1@@Z PROC ; std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> >::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> >, COMDAT
; _this$ = ecx

; 76   : 	_Vector_const_iterator(_Tptr _Ptr, const _Container_base *_Pvector)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Ranit@IHPBIABI@std@@QAE@XZ

; 77   : 		{	// construct with pointer _Ptr
; 78   : 		_SCL_SECURE_VALIDATE(_Pvector != NULL && ((_Myvec *)_Pvector)->_Myfirst <= _Ptr && _Ptr <= ((_Myvec *)_Pvector)->_Mylast);

	cmp	DWORD PTR __Pvector$[ebp], 0
	je	SHORT $LN1@Vector_con@3
	mov	eax, DWORD PTR __Pvector$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	cmp	ecx, DWORD PTR __Ptr$[ebp]
	ja	SHORT $LN1@Vector_con@3
	mov	edx, DWORD PTR __Pvector$[ebp]
	mov	eax, DWORD PTR __Ptr$[ebp]
	cmp	eax, DWORD PTR [edx+16]
	jbe	SHORT $LN2@Vector_con@3
$LN1@Vector_con@3:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@Vector_con@3:

; 79   : 		this->_Set_container(_Pvector);

	mov	ecx, DWORD PTR __Pvector$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Set_container@_Iterator_base_aux@std@@QAEXQBV_Container_base_aux@2@@Z ; std::_Iterator_base_aux::_Set_container

; 80   : 		_Myptr = _Ptr;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR [edx+4], eax

; 81   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@QAE@PAIPBV_Container_base_aux@1@@Z ENDP ; std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> >::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> >
_TEXT	ENDS
PUBLIC	??Y?$_Vector_const_iterator@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<Ogre::D3DSMSCONFLICT_T,std::allocator<Ogre::D3DSMSCONFLICT_T> >::operator+=
; Function compile flags: /Odtp
;	COMDAT ??Y?$_Vector_iterator@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
??Y?$_Vector_iterator@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<Ogre::D3DSMSCONFLICT_T,std::allocator<Ogre::D3DSMSCONFLICT_T> >::operator+=, COMDAT
; _this$ = ecx

; 374  : 		{	// increment by integer

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 375  : 		(*(_Mybase *)this) += _Off;

	mov	eax, DWORD PTR __Off$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??Y?$_Vector_const_iterator@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<Ogre::D3DSMSCONFLICT_T,std::allocator<Ogre::D3DSMSCONFLICT_T> >::operator+=

; 376  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 377  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??Y?$_Vector_iterator@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<Ogre::D3DSMSCONFLICT_T,std::allocator<Ogre::D3DSMSCONFLICT_T> >::operator+=
_TEXT	ENDS
PUBLIC	??0?$_Ranit@UD3DSMSCONFLICT_T@Ogre@@HPBU12@ABU12@@std@@QAE@XZ ; std::_Ranit<Ogre::D3DSMSCONFLICT_T,int,Ogre::D3DSMSCONFLICT_T const *,Ogre::D3DSMSCONFLICT_T const &>::_Ranit<Ogre::D3DSMSCONFLICT_T,int,Ogre::D3DSMSCONFLICT_T const *,Ogre::D3DSMSCONFLICT_T const &>
; Function compile flags: /Odtp
;	COMDAT ??0?$_Vector_const_iterator@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@QAE@PAUD3DSMSCONFLICT_T@Ogre@@PBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@QAE@PAUD3DSMSCONFLICT_T@Ogre@@PBV_Container_base_aux@1@@Z PROC ; std::_Vector_const_iterator<Ogre::D3DSMSCONFLICT_T,std::allocator<Ogre::D3DSMSCONFLICT_T> >::_Vector_const_iterator<Ogre::D3DSMSCONFLICT_T,std::allocator<Ogre::D3DSMSCONFLICT_T> >, COMDAT
; _this$ = ecx

; 76   : 	_Vector_const_iterator(_Tptr _Ptr, const _Container_base *_Pvector)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Ranit@UD3DSMSCONFLICT_T@Ogre@@HPBU12@ABU12@@std@@QAE@XZ

; 77   : 		{	// construct with pointer _Ptr
; 78   : 		_SCL_SECURE_VALIDATE(_Pvector != NULL && ((_Myvec *)_Pvector)->_Myfirst <= _Ptr && _Ptr <= ((_Myvec *)_Pvector)->_Mylast);

	cmp	DWORD PTR __Pvector$[ebp], 0
	je	SHORT $LN1@Vector_con@4
	mov	eax, DWORD PTR __Pvector$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	cmp	ecx, DWORD PTR __Ptr$[ebp]
	ja	SHORT $LN1@Vector_con@4
	mov	edx, DWORD PTR __Pvector$[ebp]
	mov	eax, DWORD PTR __Ptr$[ebp]
	cmp	eax, DWORD PTR [edx+16]
	jbe	SHORT $LN2@Vector_con@4
$LN1@Vector_con@4:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@Vector_con@4:

; 79   : 		this->_Set_container(_Pvector);

	mov	ecx, DWORD PTR __Pvector$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Set_container@_Iterator_base_aux@std@@QAEXQBV_Container_base_aux@2@@Z ; std::_Iterator_base_aux::_Set_container

; 80   : 		_Myptr = _Ptr;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR [edx+4], eax

; 81   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Vector_const_iterator@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@QAE@PAUD3DSMSCONFLICT_T@Ogre@@PBV_Container_base_aux@1@@Z ENDP ; std::_Vector_const_iterator<Ogre::D3DSMSCONFLICT_T,std::allocator<Ogre::D3DSMSCONFLICT_T> >::_Vector_const_iterator<Ogre::D3DSMSCONFLICT_T,std::allocator<Ogre::D3DSMSCONFLICT_T> >
_TEXT	ENDS
PUBLIC	??Y?$_Vector_const_iterator@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<enum Ogre::VERTPROCESS_T,std::allocator<enum Ogre::VERTPROCESS_T> >::operator+=
; Function compile flags: /Odtp
;	COMDAT ??Y?$_Vector_iterator@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
??Y?$_Vector_iterator@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<enum Ogre::VERTPROCESS_T,std::allocator<enum Ogre::VERTPROCESS_T> >::operator+=, COMDAT
; _this$ = ecx

; 374  : 		{	// increment by integer

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 375  : 		(*(_Mybase *)this) += _Off;

	mov	eax, DWORD PTR __Off$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??Y?$_Vector_const_iterator@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<enum Ogre::VERTPROCESS_T,std::allocator<enum Ogre::VERTPROCESS_T> >::operator+=

; 376  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 377  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??Y?$_Vector_iterator@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<enum Ogre::VERTPROCESS_T,std::allocator<enum Ogre::VERTPROCESS_T> >::operator+=
_TEXT	ENDS
PUBLIC	??0?$_Ranit@W4VERTPROCESS_T@Ogre@@HPBW412@ABW412@@std@@QAE@XZ ; std::_Ranit<enum Ogre::VERTPROCESS_T,int,enum Ogre::VERTPROCESS_T const *,enum Ogre::VERTPROCESS_T const &>::_Ranit<enum Ogre::VERTPROCESS_T,int,enum Ogre::VERTPROCESS_T const *,enum Ogre::VERTPROCESS_T const &>
; Function compile flags: /Odtp
;	COMDAT ??0?$_Vector_const_iterator@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@QAE@PAW4VERTPROCESS_T@Ogre@@PBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@QAE@PAW4VERTPROCESS_T@Ogre@@PBV_Container_base_aux@1@@Z PROC ; std::_Vector_const_iterator<enum Ogre::VERTPROCESS_T,std::allocator<enum Ogre::VERTPROCESS_T> >::_Vector_const_iterator<enum Ogre::VERTPROCESS_T,std::allocator<enum Ogre::VERTPROCESS_T> >, COMDAT
; _this$ = ecx

; 76   : 	_Vector_const_iterator(_Tptr _Ptr, const _Container_base *_Pvector)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Ranit@W4VERTPROCESS_T@Ogre@@HPBW412@ABW412@@std@@QAE@XZ

; 77   : 		{	// construct with pointer _Ptr
; 78   : 		_SCL_SECURE_VALIDATE(_Pvector != NULL && ((_Myvec *)_Pvector)->_Myfirst <= _Ptr && _Ptr <= ((_Myvec *)_Pvector)->_Mylast);

	cmp	DWORD PTR __Pvector$[ebp], 0
	je	SHORT $LN1@Vector_con@5
	mov	eax, DWORD PTR __Pvector$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	cmp	ecx, DWORD PTR __Ptr$[ebp]
	ja	SHORT $LN1@Vector_con@5
	mov	edx, DWORD PTR __Pvector$[ebp]
	mov	eax, DWORD PTR __Ptr$[ebp]
	cmp	eax, DWORD PTR [edx+16]
	jbe	SHORT $LN2@Vector_con@5
$LN1@Vector_con@5:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@Vector_con@5:

; 79   : 		this->_Set_container(_Pvector);

	mov	ecx, DWORD PTR __Pvector$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Set_container@_Iterator_base_aux@std@@QAEXQBV_Container_base_aux@2@@Z ; std::_Iterator_base_aux::_Set_container

; 80   : 		_Myptr = _Ptr;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR [edx+4], eax

; 81   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Vector_const_iterator@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@QAE@PAW4VERTPROCESS_T@Ogre@@PBV_Container_base_aux@1@@Z ENDP ; std::_Vector_const_iterator<enum Ogre::VERTPROCESS_T,std::allocator<enum Ogre::VERTPROCESS_T> >::_Vector_const_iterator<enum Ogre::VERTPROCESS_T,std::allocator<enum Ogre::VERTPROCESS_T> >
_TEXT	ENDS
PUBLIC	??Y?$_Vector_const_iterator@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<Ogre::D3DDEVCOMBO_T *,std::allocator<Ogre::D3DDEVCOMBO_T *> >::operator+=
; Function compile flags: /Odtp
;	COMDAT ??Y?$_Vector_iterator@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
??Y?$_Vector_iterator@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<Ogre::D3DDEVCOMBO_T *,std::allocator<Ogre::D3DDEVCOMBO_T *> >::operator+=, COMDAT
; _this$ = ecx

; 374  : 		{	// increment by integer

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 375  : 		(*(_Mybase *)this) += _Off;

	mov	eax, DWORD PTR __Off$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??Y?$_Vector_const_iterator@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<Ogre::D3DDEVCOMBO_T *,std::allocator<Ogre::D3DDEVCOMBO_T *> >::operator+=

; 376  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 377  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??Y?$_Vector_iterator@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<Ogre::D3DDEVCOMBO_T *,std::allocator<Ogre::D3DDEVCOMBO_T *> >::operator+=
_TEXT	ENDS
PUBLIC	??0?$_Ranit@PAUD3DDEVCOMBO_T@Ogre@@HPBQAU12@ABQAU12@@std@@QAE@XZ ; std::_Ranit<Ogre::D3DDEVCOMBO_T *,int,Ogre::D3DDEVCOMBO_T * const *,Ogre::D3DDEVCOMBO_T * const &>::_Ranit<Ogre::D3DDEVCOMBO_T *,int,Ogre::D3DDEVCOMBO_T * const *,Ogre::D3DDEVCOMBO_T * const &>
; Function compile flags: /Odtp
;	COMDAT ??0?$_Vector_const_iterator@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@QAE@PAPAUD3DDEVCOMBO_T@Ogre@@PBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@QAE@PAPAUD3DDEVCOMBO_T@Ogre@@PBV_Container_base_aux@1@@Z PROC ; std::_Vector_const_iterator<Ogre::D3DDEVCOMBO_T *,std::allocator<Ogre::D3DDEVCOMBO_T *> >::_Vector_const_iterator<Ogre::D3DDEVCOMBO_T *,std::allocator<Ogre::D3DDEVCOMBO_T *> >, COMDAT
; _this$ = ecx

; 76   : 	_Vector_const_iterator(_Tptr _Ptr, const _Container_base *_Pvector)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Ranit@PAUD3DDEVCOMBO_T@Ogre@@HPBQAU12@ABQAU12@@std@@QAE@XZ

; 77   : 		{	// construct with pointer _Ptr
; 78   : 		_SCL_SECURE_VALIDATE(_Pvector != NULL && ((_Myvec *)_Pvector)->_Myfirst <= _Ptr && _Ptr <= ((_Myvec *)_Pvector)->_Mylast);

	cmp	DWORD PTR __Pvector$[ebp], 0
	je	SHORT $LN1@Vector_con@6
	mov	eax, DWORD PTR __Pvector$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	cmp	ecx, DWORD PTR __Ptr$[ebp]
	ja	SHORT $LN1@Vector_con@6
	mov	edx, DWORD PTR __Pvector$[ebp]
	mov	eax, DWORD PTR __Ptr$[ebp]
	cmp	eax, DWORD PTR [edx+16]
	jbe	SHORT $LN2@Vector_con@6
$LN1@Vector_con@6:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@Vector_con@6:

; 79   : 		this->_Set_container(_Pvector);

	mov	ecx, DWORD PTR __Pvector$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Set_container@_Iterator_base_aux@std@@QAEXQBV_Container_base_aux@2@@Z ; std::_Iterator_base_aux::_Set_container

; 80   : 		_Myptr = _Ptr;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR [edx+4], eax

; 81   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Vector_const_iterator@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@QAE@PAPAUD3DDEVCOMBO_T@Ogre@@PBV_Container_base_aux@1@@Z ENDP ; std::_Vector_const_iterator<Ogre::D3DDEVCOMBO_T *,std::allocator<Ogre::D3DDEVCOMBO_T *> >::_Vector_const_iterator<Ogre::D3DDEVCOMBO_T *,std::allocator<Ogre::D3DDEVCOMBO_T *> >
_TEXT	ENDS
PUBLIC	??Y?$_Vector_const_iterator@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<_D3DDISPLAYMODE,std::allocator<_D3DDISPLAYMODE> >::operator+=
; Function compile flags: /Odtp
;	COMDAT ??Y?$_Vector_iterator@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
??Y?$_Vector_iterator@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<_D3DDISPLAYMODE,std::allocator<_D3DDISPLAYMODE> >::operator+=, COMDAT
; _this$ = ecx

; 374  : 		{	// increment by integer

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 375  : 		(*(_Mybase *)this) += _Off;

	mov	eax, DWORD PTR __Off$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??Y?$_Vector_const_iterator@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<_D3DDISPLAYMODE,std::allocator<_D3DDISPLAYMODE> >::operator+=

; 376  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 377  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??Y?$_Vector_iterator@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<_D3DDISPLAYMODE,std::allocator<_D3DDISPLAYMODE> >::operator+=
_TEXT	ENDS
PUBLIC	??0?$_Ranit@U_D3DDISPLAYMODE@@HPBU1@ABU1@@std@@QAE@XZ ; std::_Ranit<_D3DDISPLAYMODE,int,_D3DDISPLAYMODE const *,_D3DDISPLAYMODE const &>::_Ranit<_D3DDISPLAYMODE,int,_D3DDISPLAYMODE const *,_D3DDISPLAYMODE const &>
; Function compile flags: /Odtp
;	COMDAT ??0?$_Vector_const_iterator@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@QAE@PAU_D3DDISPLAYMODE@@PBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@QAE@PAU_D3DDISPLAYMODE@@PBV_Container_base_aux@1@@Z PROC ; std::_Vector_const_iterator<_D3DDISPLAYMODE,std::allocator<_D3DDISPLAYMODE> >::_Vector_const_iterator<_D3DDISPLAYMODE,std::allocator<_D3DDISPLAYMODE> >, COMDAT
; _this$ = ecx

; 76   : 	_Vector_const_iterator(_Tptr _Ptr, const _Container_base *_Pvector)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Ranit@U_D3DDISPLAYMODE@@HPBU1@ABU1@@std@@QAE@XZ

; 77   : 		{	// construct with pointer _Ptr
; 78   : 		_SCL_SECURE_VALIDATE(_Pvector != NULL && ((_Myvec *)_Pvector)->_Myfirst <= _Ptr && _Ptr <= ((_Myvec *)_Pvector)->_Mylast);

	cmp	DWORD PTR __Pvector$[ebp], 0
	je	SHORT $LN1@Vector_con@7
	mov	eax, DWORD PTR __Pvector$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	cmp	ecx, DWORD PTR __Ptr$[ebp]
	ja	SHORT $LN1@Vector_con@7
	mov	edx, DWORD PTR __Pvector$[ebp]
	mov	eax, DWORD PTR __Ptr$[ebp]
	cmp	eax, DWORD PTR [edx+16]
	jbe	SHORT $LN2@Vector_con@7
$LN1@Vector_con@7:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@Vector_con@7:

; 79   : 		this->_Set_container(_Pvector);

	mov	ecx, DWORD PTR __Pvector$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Set_container@_Iterator_base_aux@std@@QAEXQBV_Container_base_aux@2@@Z ; std::_Iterator_base_aux::_Set_container

; 80   : 		_Myptr = _Ptr;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR [edx+4], eax

; 81   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Vector_const_iterator@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@QAE@PAU_D3DDISPLAYMODE@@PBV_Container_base_aux@1@@Z ENDP ; std::_Vector_const_iterator<_D3DDISPLAYMODE,std::allocator<_D3DDISPLAYMODE> >::_Vector_const_iterator<_D3DDISPLAYMODE,std::allocator<_D3DDISPLAYMODE> >
_TEXT	ENDS
PUBLIC	??Y?$_Vector_const_iterator@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<Ogre::D3DDEVICEINFO_T *,std::allocator<Ogre::D3DDEVICEINFO_T *> >::operator+=
; Function compile flags: /Odtp
;	COMDAT ??Y?$_Vector_iterator@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
??Y?$_Vector_iterator@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<Ogre::D3DDEVICEINFO_T *,std::allocator<Ogre::D3DDEVICEINFO_T *> >::operator+=, COMDAT
; _this$ = ecx

; 374  : 		{	// increment by integer

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 375  : 		(*(_Mybase *)this) += _Off;

	mov	eax, DWORD PTR __Off$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??Y?$_Vector_const_iterator@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<Ogre::D3DDEVICEINFO_T *,std::allocator<Ogre::D3DDEVICEINFO_T *> >::operator+=

; 376  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 377  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??Y?$_Vector_iterator@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<Ogre::D3DDEVICEINFO_T *,std::allocator<Ogre::D3DDEVICEINFO_T *> >::operator+=
_TEXT	ENDS
PUBLIC	??0?$_Ranit@PAUD3DDEVICEINFO_T@Ogre@@HPBQAU12@ABQAU12@@std@@QAE@XZ ; std::_Ranit<Ogre::D3DDEVICEINFO_T *,int,Ogre::D3DDEVICEINFO_T * const *,Ogre::D3DDEVICEINFO_T * const &>::_Ranit<Ogre::D3DDEVICEINFO_T *,int,Ogre::D3DDEVICEINFO_T * const *,Ogre::D3DDEVICEINFO_T * const &>
; Function compile flags: /Odtp
;	COMDAT ??0?$_Vector_const_iterator@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@QAE@PAPAUD3DDEVICEINFO_T@Ogre@@PBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@QAE@PAPAUD3DDEVICEINFO_T@Ogre@@PBV_Container_base_aux@1@@Z PROC ; std::_Vector_const_iterator<Ogre::D3DDEVICEINFO_T *,std::allocator<Ogre::D3DDEVICEINFO_T *> >::_Vector_const_iterator<Ogre::D3DDEVICEINFO_T *,std::allocator<Ogre::D3DDEVICEINFO_T *> >, COMDAT
; _this$ = ecx

; 76   : 	_Vector_const_iterator(_Tptr _Ptr, const _Container_base *_Pvector)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Ranit@PAUD3DDEVICEINFO_T@Ogre@@HPBQAU12@ABQAU12@@std@@QAE@XZ

; 77   : 		{	// construct with pointer _Ptr
; 78   : 		_SCL_SECURE_VALIDATE(_Pvector != NULL && ((_Myvec *)_Pvector)->_Myfirst <= _Ptr && _Ptr <= ((_Myvec *)_Pvector)->_Mylast);

	cmp	DWORD PTR __Pvector$[ebp], 0
	je	SHORT $LN1@Vector_con@8
	mov	eax, DWORD PTR __Pvector$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	cmp	ecx, DWORD PTR __Ptr$[ebp]
	ja	SHORT $LN1@Vector_con@8
	mov	edx, DWORD PTR __Pvector$[ebp]
	mov	eax, DWORD PTR __Ptr$[ebp]
	cmp	eax, DWORD PTR [edx+16]
	jbe	SHORT $LN2@Vector_con@8
$LN1@Vector_con@8:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@Vector_con@8:

; 79   : 		this->_Set_container(_Pvector);

	mov	ecx, DWORD PTR __Pvector$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Set_container@_Iterator_base_aux@std@@QAEXQBV_Container_base_aux@2@@Z ; std::_Iterator_base_aux::_Set_container

; 80   : 		_Myptr = _Ptr;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR [edx+4], eax

; 81   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Vector_const_iterator@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@QAE@PAPAUD3DDEVICEINFO_T@Ogre@@PBV_Container_base_aux@1@@Z ENDP ; std::_Vector_const_iterator<Ogre::D3DDEVICEINFO_T *,std::allocator<Ogre::D3DDEVICEINFO_T *> >::_Vector_const_iterator<Ogre::D3DDEVICEINFO_T *,std::allocator<Ogre::D3DDEVICEINFO_T *> >
_TEXT	ENDS
PUBLIC	??Y?$_Vector_const_iterator@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<Ogre::D3DADAPTER_T *,std::allocator<Ogre::D3DADAPTER_T *> >::operator+=
; Function compile flags: /Odtp
;	COMDAT ??Y?$_Vector_iterator@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
??Y?$_Vector_iterator@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<Ogre::D3DADAPTER_T *,std::allocator<Ogre::D3DADAPTER_T *> >::operator+=, COMDAT
; _this$ = ecx

; 374  : 		{	// increment by integer

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 375  : 		(*(_Mybase *)this) += _Off;

	mov	eax, DWORD PTR __Off$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??Y?$_Vector_const_iterator@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<Ogre::D3DADAPTER_T *,std::allocator<Ogre::D3DADAPTER_T *> >::operator+=

; 376  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 377  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??Y?$_Vector_iterator@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<Ogre::D3DADAPTER_T *,std::allocator<Ogre::D3DADAPTER_T *> >::operator+=
_TEXT	ENDS
PUBLIC	??0?$_Ranit@PAUD3DADAPTER_T@Ogre@@HPBQAU12@ABQAU12@@std@@QAE@XZ ; std::_Ranit<Ogre::D3DADAPTER_T *,int,Ogre::D3DADAPTER_T * const *,Ogre::D3DADAPTER_T * const &>::_Ranit<Ogre::D3DADAPTER_T *,int,Ogre::D3DADAPTER_T * const *,Ogre::D3DADAPTER_T * const &>
; Function compile flags: /Odtp
;	COMDAT ??0?$_Vector_const_iterator@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@QAE@PAPAUD3DADAPTER_T@Ogre@@PBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@QAE@PAPAUD3DADAPTER_T@Ogre@@PBV_Container_base_aux@1@@Z PROC ; std::_Vector_const_iterator<Ogre::D3DADAPTER_T *,std::allocator<Ogre::D3DADAPTER_T *> >::_Vector_const_iterator<Ogre::D3DADAPTER_T *,std::allocator<Ogre::D3DADAPTER_T *> >, COMDAT
; _this$ = ecx

; 76   : 	_Vector_const_iterator(_Tptr _Ptr, const _Container_base *_Pvector)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Ranit@PAUD3DADAPTER_T@Ogre@@HPBQAU12@ABQAU12@@std@@QAE@XZ

; 77   : 		{	// construct with pointer _Ptr
; 78   : 		_SCL_SECURE_VALIDATE(_Pvector != NULL && ((_Myvec *)_Pvector)->_Myfirst <= _Ptr && _Ptr <= ((_Myvec *)_Pvector)->_Mylast);

	cmp	DWORD PTR __Pvector$[ebp], 0
	je	SHORT $LN1@Vector_con@9
	mov	eax, DWORD PTR __Pvector$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	cmp	ecx, DWORD PTR __Ptr$[ebp]
	ja	SHORT $LN1@Vector_con@9
	mov	edx, DWORD PTR __Pvector$[ebp]
	mov	eax, DWORD PTR __Ptr$[ebp]
	cmp	eax, DWORD PTR [edx+16]
	jbe	SHORT $LN2@Vector_con@9
$LN1@Vector_con@9:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@Vector_con@9:

; 79   : 		this->_Set_container(_Pvector);

	mov	ecx, DWORD PTR __Pvector$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Set_container@_Iterator_base_aux@std@@QAEXQBV_Container_base_aux@2@@Z ; std::_Iterator_base_aux::_Set_container

; 80   : 		_Myptr = _Ptr;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR [edx+4], eax

; 81   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Vector_const_iterator@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@QAE@PAPAUD3DADAPTER_T@Ogre@@PBV_Container_base_aux@1@@Z ENDP ; std::_Vector_const_iterator<Ogre::D3DADAPTER_T *,std::allocator<Ogre::D3DADAPTER_T *> >::_Vector_const_iterator<Ogre::D3DADAPTER_T *,std::allocator<Ogre::D3DADAPTER_T *> >
_TEXT	ENDS
PUBLIC	??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@W4_D3DFORMAT@@HPBW43@ABW43@V_Iterator_base_aux@2@@std@@QAE@XZ ; std::_Iterator_with_base<std::random_access_iterator_tag,enum _D3DFORMAT,int,enum _D3DFORMAT const *,enum _D3DFORMAT const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,enum _D3DFORMAT,int,enum _D3DFORMAT const *,enum _D3DFORMAT const &,std::_Iterator_base_aux>
; Function compile flags: /Odtp
;	COMDAT ??0?$_Ranit@W4_D3DFORMAT@@HPBW41@ABW41@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Ranit@W4_D3DFORMAT@@HPBW41@ABW41@@std@@QAE@XZ PROC ; std::_Ranit<enum _D3DFORMAT,int,enum _D3DFORMAT const *,enum _D3DFORMAT const &>::_Ranit<enum _D3DFORMAT,int,enum _D3DFORMAT const *,enum _D3DFORMAT const &>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@W4_D3DFORMAT@@HPBW43@ABW43@V_Iterator_base_aux@2@@std@@QAE@XZ
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Ranit@W4_D3DFORMAT@@HPBW41@ABW41@@std@@QAE@XZ ENDP ; std::_Ranit<enum _D3DFORMAT,int,enum _D3DFORMAT const *,enum _D3DFORMAT const &>::_Ranit<enum _D3DFORMAT,int,enum _D3DFORMAT const *,enum _D3DFORMAT const &>
_TEXT	ENDS
PUBLIC	??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@W4_D3DMULTISAMPLE_TYPE@@HPBW43@ABW43@V_Iterator_base_aux@2@@std@@QAE@XZ ; std::_Iterator_with_base<std::random_access_iterator_tag,enum _D3DMULTISAMPLE_TYPE,int,enum _D3DMULTISAMPLE_TYPE const *,enum _D3DMULTISAMPLE_TYPE const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,enum _D3DMULTISAMPLE_TYPE,int,enum _D3DMULTISAMPLE_TYPE const *,enum _D3DMULTISAMPLE_TYPE const &,std::_Iterator_base_aux>
; Function compile flags: /Odtp
;	COMDAT ??0?$_Ranit@W4_D3DMULTISAMPLE_TYPE@@HPBW41@ABW41@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Ranit@W4_D3DMULTISAMPLE_TYPE@@HPBW41@ABW41@@std@@QAE@XZ PROC ; std::_Ranit<enum _D3DMULTISAMPLE_TYPE,int,enum _D3DMULTISAMPLE_TYPE const *,enum _D3DMULTISAMPLE_TYPE const &>::_Ranit<enum _D3DMULTISAMPLE_TYPE,int,enum _D3DMULTISAMPLE_TYPE const *,enum _D3DMULTISAMPLE_TYPE const &>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@W4_D3DMULTISAMPLE_TYPE@@HPBW43@ABW43@V_Iterator_base_aux@2@@std@@QAE@XZ
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Ranit@W4_D3DMULTISAMPLE_TYPE@@HPBW41@ABW41@@std@@QAE@XZ ENDP ; std::_Ranit<enum _D3DMULTISAMPLE_TYPE,int,enum _D3DMULTISAMPLE_TYPE const *,enum _D3DMULTISAMPLE_TYPE const &>::_Ranit<enum _D3DMULTISAMPLE_TYPE,int,enum _D3DMULTISAMPLE_TYPE const *,enum _D3DMULTISAMPLE_TYPE const &>
_TEXT	ENDS
PUBLIC	??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@IHPBIABIV_Iterator_base_aux@2@@std@@QAE@XZ ; std::_Iterator_with_base<std::random_access_iterator_tag,unsigned int,int,unsigned int const *,unsigned int const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,unsigned int,int,unsigned int const *,unsigned int const &,std::_Iterator_base_aux>
; Function compile flags: /Odtp
;	COMDAT ??0?$_Ranit@IHPBIABI@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Ranit@IHPBIABI@std@@QAE@XZ PROC			; std::_Ranit<unsigned int,int,unsigned int const *,unsigned int const &>::_Ranit<unsigned int,int,unsigned int const *,unsigned int const &>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@IHPBIABIV_Iterator_base_aux@2@@std@@QAE@XZ
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Ranit@IHPBIABI@std@@QAE@XZ ENDP			; std::_Ranit<unsigned int,int,unsigned int const *,unsigned int const &>::_Ranit<unsigned int,int,unsigned int const *,unsigned int const &>
_TEXT	ENDS
PUBLIC	??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@UD3DSMSCONFLICT_T@Ogre@@HPBU34@ABU34@V_Iterator_base_aux@2@@std@@QAE@XZ ; std::_Iterator_with_base<std::random_access_iterator_tag,Ogre::D3DSMSCONFLICT_T,int,Ogre::D3DSMSCONFLICT_T const *,Ogre::D3DSMSCONFLICT_T const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,Ogre::D3DSMSCONFLICT_T,int,Ogre::D3DSMSCONFLICT_T const *,Ogre::D3DSMSCONFLICT_T const &,std::_Iterator_base_aux>
; Function compile flags: /Odtp
;	COMDAT ??0?$_Ranit@UD3DSMSCONFLICT_T@Ogre@@HPBU12@ABU12@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Ranit@UD3DSMSCONFLICT_T@Ogre@@HPBU12@ABU12@@std@@QAE@XZ PROC ; std::_Ranit<Ogre::D3DSMSCONFLICT_T,int,Ogre::D3DSMSCONFLICT_T const *,Ogre::D3DSMSCONFLICT_T const &>::_Ranit<Ogre::D3DSMSCONFLICT_T,int,Ogre::D3DSMSCONFLICT_T const *,Ogre::D3DSMSCONFLICT_T const &>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@UD3DSMSCONFLICT_T@Ogre@@HPBU34@ABU34@V_Iterator_base_aux@2@@std@@QAE@XZ
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Ranit@UD3DSMSCONFLICT_T@Ogre@@HPBU12@ABU12@@std@@QAE@XZ ENDP ; std::_Ranit<Ogre::D3DSMSCONFLICT_T,int,Ogre::D3DSMSCONFLICT_T const *,Ogre::D3DSMSCONFLICT_T const &>::_Ranit<Ogre::D3DSMSCONFLICT_T,int,Ogre::D3DSMSCONFLICT_T const *,Ogre::D3DSMSCONFLICT_T const &>
_TEXT	ENDS
PUBLIC	??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@W4VERTPROCESS_T@Ogre@@HPBW434@ABW434@V_Iterator_base_aux@2@@std@@QAE@XZ ; std::_Iterator_with_base<std::random_access_iterator_tag,enum Ogre::VERTPROCESS_T,int,enum Ogre::VERTPROCESS_T const *,enum Ogre::VERTPROCESS_T const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,enum Ogre::VERTPROCESS_T,int,enum Ogre::VERTPROCESS_T const *,enum Ogre::VERTPROCESS_T const &,std::_Iterator_base_aux>
; Function compile flags: /Odtp
;	COMDAT ??0?$_Ranit@W4VERTPROCESS_T@Ogre@@HPBW412@ABW412@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Ranit@W4VERTPROCESS_T@Ogre@@HPBW412@ABW412@@std@@QAE@XZ PROC ; std::_Ranit<enum Ogre::VERTPROCESS_T,int,enum Ogre::VERTPROCESS_T const *,enum Ogre::VERTPROCESS_T const &>::_Ranit<enum Ogre::VERTPROCESS_T,int,enum Ogre::VERTPROCESS_T const *,enum Ogre::VERTPROCESS_T const &>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@W4VERTPROCESS_T@Ogre@@HPBW434@ABW434@V_Iterator_base_aux@2@@std@@QAE@XZ
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Ranit@W4VERTPROCESS_T@Ogre@@HPBW412@ABW412@@std@@QAE@XZ ENDP ; std::_Ranit<enum Ogre::VERTPROCESS_T,int,enum Ogre::VERTPROCESS_T const *,enum Ogre::VERTPROCESS_T const &>::_Ranit<enum Ogre::VERTPROCESS_T,int,enum Ogre::VERTPROCESS_T const *,enum Ogre::VERTPROCESS_T const &>
_TEXT	ENDS
PUBLIC	??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@PAUD3DDEVCOMBO_T@Ogre@@HPBQAU34@ABQAU34@V_Iterator_base_aux@2@@std@@QAE@XZ ; std::_Iterator_with_base<std::random_access_iterator_tag,Ogre::D3DDEVCOMBO_T *,int,Ogre::D3DDEVCOMBO_T * const *,Ogre::D3DDEVCOMBO_T * const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,Ogre::D3DDEVCOMBO_T *,int,Ogre::D3DDEVCOMBO_T * const *,Ogre::D3DDEVCOMBO_T * const &,std::_Iterator_base_aux>
; Function compile flags: /Odtp
;	COMDAT ??0?$_Ranit@PAUD3DDEVCOMBO_T@Ogre@@HPBQAU12@ABQAU12@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Ranit@PAUD3DDEVCOMBO_T@Ogre@@HPBQAU12@ABQAU12@@std@@QAE@XZ PROC ; std::_Ranit<Ogre::D3DDEVCOMBO_T *,int,Ogre::D3DDEVCOMBO_T * const *,Ogre::D3DDEVCOMBO_T * const &>::_Ranit<Ogre::D3DDEVCOMBO_T *,int,Ogre::D3DDEVCOMBO_T * const *,Ogre::D3DDEVCOMBO_T * const &>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@PAUD3DDEVCOMBO_T@Ogre@@HPBQAU34@ABQAU34@V_Iterator_base_aux@2@@std@@QAE@XZ
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Ranit@PAUD3DDEVCOMBO_T@Ogre@@HPBQAU12@ABQAU12@@std@@QAE@XZ ENDP ; std::_Ranit<Ogre::D3DDEVCOMBO_T *,int,Ogre::D3DDEVCOMBO_T * const *,Ogre::D3DDEVCOMBO_T * const &>::_Ranit<Ogre::D3DDEVCOMBO_T *,int,Ogre::D3DDEVCOMBO_T * const *,Ogre::D3DDEVCOMBO_T * const &>
_TEXT	ENDS
PUBLIC	??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@U_D3DDISPLAYMODE@@HPBU3@ABU3@V_Iterator_base_aux@2@@std@@QAE@XZ ; std::_Iterator_with_base<std::random_access_iterator_tag,_D3DDISPLAYMODE,int,_D3DDISPLAYMODE const *,_D3DDISPLAYMODE const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,_D3DDISPLAYMODE,int,_D3DDISPLAYMODE const *,_D3DDISPLAYMODE const &,std::_Iterator_base_aux>
; Function compile flags: /Odtp
;	COMDAT ??0?$_Ranit@U_D3DDISPLAYMODE@@HPBU1@ABU1@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Ranit@U_D3DDISPLAYMODE@@HPBU1@ABU1@@std@@QAE@XZ PROC ; std::_Ranit<_D3DDISPLAYMODE,int,_D3DDISPLAYMODE const *,_D3DDISPLAYMODE const &>::_Ranit<_D3DDISPLAYMODE,int,_D3DDISPLAYMODE const *,_D3DDISPLAYMODE const &>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@U_D3DDISPLAYMODE@@HPBU3@ABU3@V_Iterator_base_aux@2@@std@@QAE@XZ
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Ranit@U_D3DDISPLAYMODE@@HPBU1@ABU1@@std@@QAE@XZ ENDP ; std::_Ranit<_D3DDISPLAYMODE,int,_D3DDISPLAYMODE const *,_D3DDISPLAYMODE const &>::_Ranit<_D3DDISPLAYMODE,int,_D3DDISPLAYMODE const *,_D3DDISPLAYMODE const &>
_TEXT	ENDS
PUBLIC	??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@PAUD3DDEVICEINFO_T@Ogre@@HPBQAU34@ABQAU34@V_Iterator_base_aux@2@@std@@QAE@XZ ; std::_Iterator_with_base<std::random_access_iterator_tag,Ogre::D3DDEVICEINFO_T *,int,Ogre::D3DDEVICEINFO_T * const *,Ogre::D3DDEVICEINFO_T * const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,Ogre::D3DDEVICEINFO_T *,int,Ogre::D3DDEVICEINFO_T * const *,Ogre::D3DDEVICEINFO_T * const &,std::_Iterator_base_aux>
; Function compile flags: /Odtp
;	COMDAT ??0?$_Ranit@PAUD3DDEVICEINFO_T@Ogre@@HPBQAU12@ABQAU12@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Ranit@PAUD3DDEVICEINFO_T@Ogre@@HPBQAU12@ABQAU12@@std@@QAE@XZ PROC ; std::_Ranit<Ogre::D3DDEVICEINFO_T *,int,Ogre::D3DDEVICEINFO_T * const *,Ogre::D3DDEVICEINFO_T * const &>::_Ranit<Ogre::D3DDEVICEINFO_T *,int,Ogre::D3DDEVICEINFO_T * const *,Ogre::D3DDEVICEINFO_T * const &>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@PAUD3DDEVICEINFO_T@Ogre@@HPBQAU34@ABQAU34@V_Iterator_base_aux@2@@std@@QAE@XZ
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Ranit@PAUD3DDEVICEINFO_T@Ogre@@HPBQAU12@ABQAU12@@std@@QAE@XZ ENDP ; std::_Ranit<Ogre::D3DDEVICEINFO_T *,int,Ogre::D3DDEVICEINFO_T * const *,Ogre::D3DDEVICEINFO_T * const &>::_Ranit<Ogre::D3DDEVICEINFO_T *,int,Ogre::D3DDEVICEINFO_T * const *,Ogre::D3DDEVICEINFO_T * const &>
_TEXT	ENDS
PUBLIC	??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@PAUD3DADAPTER_T@Ogre@@HPBQAU34@ABQAU34@V_Iterator_base_aux@2@@std@@QAE@XZ ; std::_Iterator_with_base<std::random_access_iterator_tag,Ogre::D3DADAPTER_T *,int,Ogre::D3DADAPTER_T * const *,Ogre::D3DADAPTER_T * const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,Ogre::D3DADAPTER_T *,int,Ogre::D3DADAPTER_T * const *,Ogre::D3DADAPTER_T * const &,std::_Iterator_base_aux>
; Function compile flags: /Odtp
;	COMDAT ??0?$_Ranit@PAUD3DADAPTER_T@Ogre@@HPBQAU12@ABQAU12@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Ranit@PAUD3DADAPTER_T@Ogre@@HPBQAU12@ABQAU12@@std@@QAE@XZ PROC ; std::_Ranit<Ogre::D3DADAPTER_T *,int,Ogre::D3DADAPTER_T * const *,Ogre::D3DADAPTER_T * const &>::_Ranit<Ogre::D3DADAPTER_T *,int,Ogre::D3DADAPTER_T * const *,Ogre::D3DADAPTER_T * const &>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@PAUD3DADAPTER_T@Ogre@@HPBQAU34@ABQAU34@V_Iterator_base_aux@2@@std@@QAE@XZ
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Ranit@PAUD3DADAPTER_T@Ogre@@HPBQAU12@ABQAU12@@std@@QAE@XZ ENDP ; std::_Ranit<Ogre::D3DADAPTER_T *,int,Ogre::D3DADAPTER_T * const *,Ogre::D3DADAPTER_T * const &>::_Ranit<Ogre::D3DADAPTER_T *,int,Ogre::D3DADAPTER_T * const *,Ogre::D3DADAPTER_T * const &>
_TEXT	ENDS
PUBLIC	??0_Iterator_base_aux@std@@QAE@XZ		; std::_Iterator_base_aux::_Iterator_base_aux
; Function compile flags: /Odtp
;	COMDAT ??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@W4_D3DFORMAT@@HPBW43@ABW43@V_Iterator_base_aux@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@W4_D3DFORMAT@@HPBW43@ABW43@V_Iterator_base_aux@2@@std@@QAE@XZ PROC ; std::_Iterator_with_base<std::random_access_iterator_tag,enum _D3DFORMAT,int,enum _D3DFORMAT const *,enum _D3DFORMAT const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,enum _D3DFORMAT,int,enum _D3DFORMAT const *,enum _D3DFORMAT const &,std::_Iterator_base_aux>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Iterator_base_aux@std@@QAE@XZ	; std::_Iterator_base_aux::_Iterator_base_aux
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@W4_D3DFORMAT@@HPBW43@ABW43@V_Iterator_base_aux@2@@std@@QAE@XZ ENDP ; std::_Iterator_with_base<std::random_access_iterator_tag,enum _D3DFORMAT,int,enum _D3DFORMAT const *,enum _D3DFORMAT const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,enum _D3DFORMAT,int,enum _D3DFORMAT const *,enum _D3DFORMAT const &,std::_Iterator_base_aux>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??0_Iterator_base_aux@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_Iterator_base_aux@std@@QAE@XZ PROC			; std::_Iterator_base_aux::_Iterator_base_aux, COMDAT
; _this$ = ecx

; 448  : 	_Iterator_base_aux()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0_Iterator_base_aux@std@@QAE@XZ ENDP			; std::_Iterator_base_aux::_Iterator_base_aux
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@W4_D3DMULTISAMPLE_TYPE@@HPBW43@ABW43@V_Iterator_base_aux@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@W4_D3DMULTISAMPLE_TYPE@@HPBW43@ABW43@V_Iterator_base_aux@2@@std@@QAE@XZ PROC ; std::_Iterator_with_base<std::random_access_iterator_tag,enum _D3DMULTISAMPLE_TYPE,int,enum _D3DMULTISAMPLE_TYPE const *,enum _D3DMULTISAMPLE_TYPE const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,enum _D3DMULTISAMPLE_TYPE,int,enum _D3DMULTISAMPLE_TYPE const *,enum _D3DMULTISAMPLE_TYPE const &,std::_Iterator_base_aux>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Iterator_base_aux@std@@QAE@XZ	; std::_Iterator_base_aux::_Iterator_base_aux
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@W4_D3DMULTISAMPLE_TYPE@@HPBW43@ABW43@V_Iterator_base_aux@2@@std@@QAE@XZ ENDP ; std::_Iterator_with_base<std::random_access_iterator_tag,enum _D3DMULTISAMPLE_TYPE,int,enum _D3DMULTISAMPLE_TYPE const *,enum _D3DMULTISAMPLE_TYPE const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,enum _D3DMULTISAMPLE_TYPE,int,enum _D3DMULTISAMPLE_TYPE const *,enum _D3DMULTISAMPLE_TYPE const &,std::_Iterator_base_aux>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@IHPBIABIV_Iterator_base_aux@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@IHPBIABIV_Iterator_base_aux@2@@std@@QAE@XZ PROC ; std::_Iterator_with_base<std::random_access_iterator_tag,unsigned int,int,unsigned int const *,unsigned int const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,unsigned int,int,unsigned int const *,unsigned int const &,std::_Iterator_base_aux>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Iterator_base_aux@std@@QAE@XZ	; std::_Iterator_base_aux::_Iterator_base_aux
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@IHPBIABIV_Iterator_base_aux@2@@std@@QAE@XZ ENDP ; std::_Iterator_with_base<std::random_access_iterator_tag,unsigned int,int,unsigned int const *,unsigned int const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,unsigned int,int,unsigned int const *,unsigned int const &,std::_Iterator_base_aux>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@UD3DSMSCONFLICT_T@Ogre@@HPBU34@ABU34@V_Iterator_base_aux@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@UD3DSMSCONFLICT_T@Ogre@@HPBU34@ABU34@V_Iterator_base_aux@2@@std@@QAE@XZ PROC ; std::_Iterator_with_base<std::random_access_iterator_tag,Ogre::D3DSMSCONFLICT_T,int,Ogre::D3DSMSCONFLICT_T const *,Ogre::D3DSMSCONFLICT_T const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,Ogre::D3DSMSCONFLICT_T,int,Ogre::D3DSMSCONFLICT_T const *,Ogre::D3DSMSCONFLICT_T const &,std::_Iterator_base_aux>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Iterator_base_aux@std@@QAE@XZ	; std::_Iterator_base_aux::_Iterator_base_aux
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@UD3DSMSCONFLICT_T@Ogre@@HPBU34@ABU34@V_Iterator_base_aux@2@@std@@QAE@XZ ENDP ; std::_Iterator_with_base<std::random_access_iterator_tag,Ogre::D3DSMSCONFLICT_T,int,Ogre::D3DSMSCONFLICT_T const *,Ogre::D3DSMSCONFLICT_T const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,Ogre::D3DSMSCONFLICT_T,int,Ogre::D3DSMSCONFLICT_T const *,Ogre::D3DSMSCONFLICT_T const &,std::_Iterator_base_aux>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@W4VERTPROCESS_T@Ogre@@HPBW434@ABW434@V_Iterator_base_aux@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@W4VERTPROCESS_T@Ogre@@HPBW434@ABW434@V_Iterator_base_aux@2@@std@@QAE@XZ PROC ; std::_Iterator_with_base<std::random_access_iterator_tag,enum Ogre::VERTPROCESS_T,int,enum Ogre::VERTPROCESS_T const *,enum Ogre::VERTPROCESS_T const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,enum Ogre::VERTPROCESS_T,int,enum Ogre::VERTPROCESS_T const *,enum Ogre::VERTPROCESS_T const &,std::_Iterator_base_aux>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Iterator_base_aux@std@@QAE@XZ	; std::_Iterator_base_aux::_Iterator_base_aux
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@W4VERTPROCESS_T@Ogre@@HPBW434@ABW434@V_Iterator_base_aux@2@@std@@QAE@XZ ENDP ; std::_Iterator_with_base<std::random_access_iterator_tag,enum Ogre::VERTPROCESS_T,int,enum Ogre::VERTPROCESS_T const *,enum Ogre::VERTPROCESS_T const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,enum Ogre::VERTPROCESS_T,int,enum Ogre::VERTPROCESS_T const *,enum Ogre::VERTPROCESS_T const &,std::_Iterator_base_aux>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@PAUD3DDEVCOMBO_T@Ogre@@HPBQAU34@ABQAU34@V_Iterator_base_aux@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@PAUD3DDEVCOMBO_T@Ogre@@HPBQAU34@ABQAU34@V_Iterator_base_aux@2@@std@@QAE@XZ PROC ; std::_Iterator_with_base<std::random_access_iterator_tag,Ogre::D3DDEVCOMBO_T *,int,Ogre::D3DDEVCOMBO_T * const *,Ogre::D3DDEVCOMBO_T * const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,Ogre::D3DDEVCOMBO_T *,int,Ogre::D3DDEVCOMBO_T * const *,Ogre::D3DDEVCOMBO_T * const &,std::_Iterator_base_aux>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Iterator_base_aux@std@@QAE@XZ	; std::_Iterator_base_aux::_Iterator_base_aux
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@PAUD3DDEVCOMBO_T@Ogre@@HPBQAU34@ABQAU34@V_Iterator_base_aux@2@@std@@QAE@XZ ENDP ; std::_Iterator_with_base<std::random_access_iterator_tag,Ogre::D3DDEVCOMBO_T *,int,Ogre::D3DDEVCOMBO_T * const *,Ogre::D3DDEVCOMBO_T * const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,Ogre::D3DDEVCOMBO_T *,int,Ogre::D3DDEVCOMBO_T * const *,Ogre::D3DDEVCOMBO_T * const &,std::_Iterator_base_aux>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@U_D3DDISPLAYMODE@@HPBU3@ABU3@V_Iterator_base_aux@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@U_D3DDISPLAYMODE@@HPBU3@ABU3@V_Iterator_base_aux@2@@std@@QAE@XZ PROC ; std::_Iterator_with_base<std::random_access_iterator_tag,_D3DDISPLAYMODE,int,_D3DDISPLAYMODE const *,_D3DDISPLAYMODE const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,_D3DDISPLAYMODE,int,_D3DDISPLAYMODE const *,_D3DDISPLAYMODE const &,std::_Iterator_base_aux>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Iterator_base_aux@std@@QAE@XZ	; std::_Iterator_base_aux::_Iterator_base_aux
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@U_D3DDISPLAYMODE@@HPBU3@ABU3@V_Iterator_base_aux@2@@std@@QAE@XZ ENDP ; std::_Iterator_with_base<std::random_access_iterator_tag,_D3DDISPLAYMODE,int,_D3DDISPLAYMODE const *,_D3DDISPLAYMODE const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,_D3DDISPLAYMODE,int,_D3DDISPLAYMODE const *,_D3DDISPLAYMODE const &,std::_Iterator_base_aux>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@PAUD3DDEVICEINFO_T@Ogre@@HPBQAU34@ABQAU34@V_Iterator_base_aux@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@PAUD3DDEVICEINFO_T@Ogre@@HPBQAU34@ABQAU34@V_Iterator_base_aux@2@@std@@QAE@XZ PROC ; std::_Iterator_with_base<std::random_access_iterator_tag,Ogre::D3DDEVICEINFO_T *,int,Ogre::D3DDEVICEINFO_T * const *,Ogre::D3DDEVICEINFO_T * const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,Ogre::D3DDEVICEINFO_T *,int,Ogre::D3DDEVICEINFO_T * const *,Ogre::D3DDEVICEINFO_T * const &,std::_Iterator_base_aux>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Iterator_base_aux@std@@QAE@XZ	; std::_Iterator_base_aux::_Iterator_base_aux
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@PAUD3DDEVICEINFO_T@Ogre@@HPBQAU34@ABQAU34@V_Iterator_base_aux@2@@std@@QAE@XZ ENDP ; std::_Iterator_with_base<std::random_access_iterator_tag,Ogre::D3DDEVICEINFO_T *,int,Ogre::D3DDEVICEINFO_T * const *,Ogre::D3DDEVICEINFO_T * const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,Ogre::D3DDEVICEINFO_T *,int,Ogre::D3DDEVICEINFO_T * const *,Ogre::D3DDEVICEINFO_T * const &,std::_Iterator_base_aux>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@PAUD3DADAPTER_T@Ogre@@HPBQAU34@ABQAU34@V_Iterator_base_aux@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@PAUD3DADAPTER_T@Ogre@@HPBQAU34@ABQAU34@V_Iterator_base_aux@2@@std@@QAE@XZ PROC ; std::_Iterator_with_base<std::random_access_iterator_tag,Ogre::D3DADAPTER_T *,int,Ogre::D3DADAPTER_T * const *,Ogre::D3DADAPTER_T * const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,Ogre::D3DADAPTER_T *,int,Ogre::D3DADAPTER_T * const *,Ogre::D3DADAPTER_T * const &,std::_Iterator_base_aux>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Iterator_base_aux@std@@QAE@XZ	; std::_Iterator_base_aux::_Iterator_base_aux
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@PAUD3DADAPTER_T@Ogre@@HPBQAU34@ABQAU34@V_Iterator_base_aux@2@@std@@QAE@XZ ENDP ; std::_Iterator_with_base<std::random_access_iterator_tag,Ogre::D3DADAPTER_T *,int,Ogre::D3DADAPTER_T * const *,Ogre::D3DADAPTER_T * const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,Ogre::D3DADAPTER_T *,int,Ogre::D3DADAPTER_T * const *,Ogre::D3DADAPTER_T * const &,std::_Iterator_base_aux>
_TEXT	ENDS
PUBLIC	?_Getmycont@_Iterator_base_aux@std@@QBEPBV_Container_base_aux@2@XZ ; std::_Iterator_base_aux::_Getmycont
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??Y?$_Vector_const_iterator@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
??Y?$_Vector_const_iterator@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<enum _D3DFORMAT,std::allocator<enum _D3DFORMAT> >::operator+=, COMDAT
; _this$ = ecx

; 159  : 		{	// increment by integer

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 160  : 		_SCL_SECURE_VALIDATE(this->_Has_container());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Has_container@_Iterator_base_aux@std@@QBE_NXZ ; std::_Iterator_base_aux::_Has_container
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN3@operator@17
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN3@operator@17:

; 161  : 		_SCL_SECURE_VALIDATE_RANGE(

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR __Off$[ebp]
	lea	esi, DWORD PTR [edx+eax*4]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getmycont@_Iterator_base_aux@std@@QBEPBV_Container_base_aux@2@XZ ; std::_Iterator_base_aux::_Getmycont
	cmp	esi, DWORD PTR [eax+16]
	ja	SHORT $LN1@operator@17
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR __Off$[ebp]
	lea	esi, DWORD PTR [edx+eax*4]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getmycont@_Iterator_base_aux@std@@QBEPBV_Container_base_aux@2@XZ ; std::_Iterator_base_aux::_Getmycont
	cmp	esi, DWORD PTR [eax+12]
	jae	SHORT $LN2@operator@17
$LN1@operator@17:

; 162  : 			_Myptr + _Off <= ((_Myvec *)(this->_Getmycont()))->_Mylast &&
; 163  : 			_Myptr + _Off >= ((_Myvec *)(this->_Getmycont()))->_Myfirst);

	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@operator@17:

; 164  : 		_Myptr += _Off;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR __Off$[ebp]
	lea	ecx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 165  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 166  : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
??Y?$_Vector_const_iterator@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<enum _D3DFORMAT,std::allocator<enum _D3DFORMAT> >::operator+=
_TEXT	ENDS
PUBLIC	?_Getcont@_Aux_cont@std@@QBEPBV_Container_base_aux@2@XZ ; std::_Aux_cont::_Getcont
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ?_Getmycont@_Iterator_base_aux@std@@QBEPBV_Container_base_aux@2@XZ
_TEXT	SEGMENT
tv67 = -8						; size = 4
_this$ = -4						; size = 4
?_Getmycont@_Iterator_base_aux@std@@QBEPBV_Container_base_aux@2@XZ PROC ; std::_Iterator_base_aux::_Getmycont, COMDAT
; _this$ = ecx

; 457  : 		{	// Go through the aux object to get the container

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 458  : 		return _Myaux ? _Myaux->_Getcont() : 0;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN3@Getmycont
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?_Getcont@_Aux_cont@std@@QBEPBV_Container_base_aux@2@XZ ; std::_Aux_cont::_Getcont
	mov	DWORD PTR tv67[ebp], eax
	jmp	SHORT $LN4@Getmycont
$LN3@Getmycont:
	mov	DWORD PTR tv67[ebp], 0
$LN4@Getmycont:
	mov	eax, DWORD PTR tv67[ebp]

; 459  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Getmycont@_Iterator_base_aux@std@@QBEPBV_Container_base_aux@2@XZ ENDP ; std::_Iterator_base_aux::_Getmycont
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Getcont@_Aux_cont@std@@QBEPBV_Container_base_aux@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Getcont@_Aux_cont@std@@QBEPBV_Container_base_aux@2@XZ PROC ; std::_Aux_cont::_Getcont, COMDAT
; _this$ = ecx

; 368  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 369  : 		return _Mycontainer;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 370  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Getcont@_Aux_cont@std@@QBEPBV_Container_base_aux@2@XZ ENDP ; std::_Aux_cont::_Getcont
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ??Y?$_Vector_const_iterator@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
??Y?$_Vector_const_iterator@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<enum _D3DMULTISAMPLE_TYPE,std::allocator<enum _D3DMULTISAMPLE_TYPE> >::operator+=, COMDAT
; _this$ = ecx

; 159  : 		{	// increment by integer

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 160  : 		_SCL_SECURE_VALIDATE(this->_Has_container());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Has_container@_Iterator_base_aux@std@@QBE_NXZ ; std::_Iterator_base_aux::_Has_container
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN3@operator@18
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN3@operator@18:

; 161  : 		_SCL_SECURE_VALIDATE_RANGE(

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR __Off$[ebp]
	lea	esi, DWORD PTR [edx+eax*4]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getmycont@_Iterator_base_aux@std@@QBEPBV_Container_base_aux@2@XZ ; std::_Iterator_base_aux::_Getmycont
	cmp	esi, DWORD PTR [eax+16]
	ja	SHORT $LN1@operator@18
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR __Off$[ebp]
	lea	esi, DWORD PTR [edx+eax*4]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getmycont@_Iterator_base_aux@std@@QBEPBV_Container_base_aux@2@XZ ; std::_Iterator_base_aux::_Getmycont
	cmp	esi, DWORD PTR [eax+12]
	jae	SHORT $LN2@operator@18
$LN1@operator@18:

; 162  : 			_Myptr + _Off <= ((_Myvec *)(this->_Getmycont()))->_Mylast &&
; 163  : 			_Myptr + _Off >= ((_Myvec *)(this->_Getmycont()))->_Myfirst);

	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@operator@18:

; 164  : 		_Myptr += _Off;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR __Off$[ebp]
	lea	ecx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 165  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 166  : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
??Y?$_Vector_const_iterator@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<enum _D3DMULTISAMPLE_TYPE,std::allocator<enum _D3DMULTISAMPLE_TYPE> >::operator+=
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??Y?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
??Y?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> >::operator+=, COMDAT
; _this$ = ecx

; 159  : 		{	// increment by integer

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 160  : 		_SCL_SECURE_VALIDATE(this->_Has_container());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Has_container@_Iterator_base_aux@std@@QBE_NXZ ; std::_Iterator_base_aux::_Has_container
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN3@operator@19
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN3@operator@19:

; 161  : 		_SCL_SECURE_VALIDATE_RANGE(

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR __Off$[ebp]
	lea	esi, DWORD PTR [edx+eax*4]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getmycont@_Iterator_base_aux@std@@QBEPBV_Container_base_aux@2@XZ ; std::_Iterator_base_aux::_Getmycont
	cmp	esi, DWORD PTR [eax+16]
	ja	SHORT $LN1@operator@19
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR __Off$[ebp]
	lea	esi, DWORD PTR [edx+eax*4]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getmycont@_Iterator_base_aux@std@@QBEPBV_Container_base_aux@2@XZ ; std::_Iterator_base_aux::_Getmycont
	cmp	esi, DWORD PTR [eax+12]
	jae	SHORT $LN2@operator@19
$LN1@operator@19:

; 162  : 			_Myptr + _Off <= ((_Myvec *)(this->_Getmycont()))->_Mylast &&
; 163  : 			_Myptr + _Off >= ((_Myvec *)(this->_Getmycont()))->_Myfirst);

	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@operator@19:

; 164  : 		_Myptr += _Off;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR __Off$[ebp]
	lea	ecx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 165  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 166  : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
??Y?$_Vector_const_iterator@IV?$allocator@I@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<unsigned int,std::allocator<unsigned int> >::operator+=
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??Y?$_Vector_const_iterator@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
??Y?$_Vector_const_iterator@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<Ogre::D3DSMSCONFLICT_T,std::allocator<Ogre::D3DSMSCONFLICT_T> >::operator+=, COMDAT
; _this$ = ecx

; 159  : 		{	// increment by integer

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 160  : 		_SCL_SECURE_VALIDATE(this->_Has_container());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Has_container@_Iterator_base_aux@std@@QBE_NXZ ; std::_Iterator_base_aux::_Has_container
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN3@operator@20
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN3@operator@20:

; 161  : 		_SCL_SECURE_VALIDATE_RANGE(

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR __Off$[ebp]
	lea	esi, DWORD PTR [edx+eax*8]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getmycont@_Iterator_base_aux@std@@QBEPBV_Container_base_aux@2@XZ ; std::_Iterator_base_aux::_Getmycont
	cmp	esi, DWORD PTR [eax+16]
	ja	SHORT $LN1@operator@20
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR __Off$[ebp]
	lea	esi, DWORD PTR [edx+eax*8]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getmycont@_Iterator_base_aux@std@@QBEPBV_Container_base_aux@2@XZ ; std::_Iterator_base_aux::_Getmycont
	cmp	esi, DWORD PTR [eax+12]
	jae	SHORT $LN2@operator@20
$LN1@operator@20:

; 162  : 			_Myptr + _Off <= ((_Myvec *)(this->_Getmycont()))->_Mylast &&
; 163  : 			_Myptr + _Off >= ((_Myvec *)(this->_Getmycont()))->_Myfirst);

	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@operator@20:

; 164  : 		_Myptr += _Off;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR __Off$[ebp]
	lea	ecx, DWORD PTR [edx+eax*8]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 165  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 166  : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
??Y?$_Vector_const_iterator@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<Ogre::D3DSMSCONFLICT_T,std::allocator<Ogre::D3DSMSCONFLICT_T> >::operator+=
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??Y?$_Vector_const_iterator@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
??Y?$_Vector_const_iterator@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<enum Ogre::VERTPROCESS_T,std::allocator<enum Ogre::VERTPROCESS_T> >::operator+=, COMDAT
; _this$ = ecx

; 159  : 		{	// increment by integer

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 160  : 		_SCL_SECURE_VALIDATE(this->_Has_container());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Has_container@_Iterator_base_aux@std@@QBE_NXZ ; std::_Iterator_base_aux::_Has_container
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN3@operator@21
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN3@operator@21:

; 161  : 		_SCL_SECURE_VALIDATE_RANGE(

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR __Off$[ebp]
	lea	esi, DWORD PTR [edx+eax*4]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getmycont@_Iterator_base_aux@std@@QBEPBV_Container_base_aux@2@XZ ; std::_Iterator_base_aux::_Getmycont
	cmp	esi, DWORD PTR [eax+16]
	ja	SHORT $LN1@operator@21
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR __Off$[ebp]
	lea	esi, DWORD PTR [edx+eax*4]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getmycont@_Iterator_base_aux@std@@QBEPBV_Container_base_aux@2@XZ ; std::_Iterator_base_aux::_Getmycont
	cmp	esi, DWORD PTR [eax+12]
	jae	SHORT $LN2@operator@21
$LN1@operator@21:

; 162  : 			_Myptr + _Off <= ((_Myvec *)(this->_Getmycont()))->_Mylast &&
; 163  : 			_Myptr + _Off >= ((_Myvec *)(this->_Getmycont()))->_Myfirst);

	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@operator@21:

; 164  : 		_Myptr += _Off;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR __Off$[ebp]
	lea	ecx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 165  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 166  : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
??Y?$_Vector_const_iterator@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<enum Ogre::VERTPROCESS_T,std::allocator<enum Ogre::VERTPROCESS_T> >::operator+=
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??Y?$_Vector_const_iterator@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
??Y?$_Vector_const_iterator@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<Ogre::D3DDEVCOMBO_T *,std::allocator<Ogre::D3DDEVCOMBO_T *> >::operator+=, COMDAT
; _this$ = ecx

; 159  : 		{	// increment by integer

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 160  : 		_SCL_SECURE_VALIDATE(this->_Has_container());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Has_container@_Iterator_base_aux@std@@QBE_NXZ ; std::_Iterator_base_aux::_Has_container
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN3@operator@22
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN3@operator@22:

; 161  : 		_SCL_SECURE_VALIDATE_RANGE(

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR __Off$[ebp]
	lea	esi, DWORD PTR [edx+eax*4]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getmycont@_Iterator_base_aux@std@@QBEPBV_Container_base_aux@2@XZ ; std::_Iterator_base_aux::_Getmycont
	cmp	esi, DWORD PTR [eax+16]
	ja	SHORT $LN1@operator@22
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR __Off$[ebp]
	lea	esi, DWORD PTR [edx+eax*4]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getmycont@_Iterator_base_aux@std@@QBEPBV_Container_base_aux@2@XZ ; std::_Iterator_base_aux::_Getmycont
	cmp	esi, DWORD PTR [eax+12]
	jae	SHORT $LN2@operator@22
$LN1@operator@22:

; 162  : 			_Myptr + _Off <= ((_Myvec *)(this->_Getmycont()))->_Mylast &&
; 163  : 			_Myptr + _Off >= ((_Myvec *)(this->_Getmycont()))->_Myfirst);

	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@operator@22:

; 164  : 		_Myptr += _Off;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR __Off$[ebp]
	lea	ecx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 165  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 166  : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
??Y?$_Vector_const_iterator@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<Ogre::D3DDEVCOMBO_T *,std::allocator<Ogre::D3DDEVCOMBO_T *> >::operator+=
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??Y?$_Vector_const_iterator@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
??Y?$_Vector_const_iterator@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<_D3DDISPLAYMODE,std::allocator<_D3DDISPLAYMODE> >::operator+=, COMDAT
; _this$ = ecx

; 159  : 		{	// increment by integer

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 160  : 		_SCL_SECURE_VALIDATE(this->_Has_container());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Has_container@_Iterator_base_aux@std@@QBE_NXZ ; std::_Iterator_base_aux::_Has_container
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN3@operator@23
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN3@operator@23:

; 161  : 		_SCL_SECURE_VALIDATE_RANGE(

	mov	esi, DWORD PTR __Off$[ebp]
	shl	esi, 4
	mov	ecx, DWORD PTR _this$[ebp]
	add	esi, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getmycont@_Iterator_base_aux@std@@QBEPBV_Container_base_aux@2@XZ ; std::_Iterator_base_aux::_Getmycont
	cmp	esi, DWORD PTR [eax+16]
	ja	SHORT $LN1@operator@23
	mov	esi, DWORD PTR __Off$[ebp]
	shl	esi, 4
	mov	edx, DWORD PTR _this$[ebp]
	add	esi, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getmycont@_Iterator_base_aux@std@@QBEPBV_Container_base_aux@2@XZ ; std::_Iterator_base_aux::_Getmycont
	cmp	esi, DWORD PTR [eax+12]
	jae	SHORT $LN2@operator@23
$LN1@operator@23:

; 162  : 			_Myptr + _Off <= ((_Myvec *)(this->_Getmycont()))->_Mylast &&
; 163  : 			_Myptr + _Off >= ((_Myvec *)(this->_Getmycont()))->_Myfirst);

	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@operator@23:

; 164  : 		_Myptr += _Off;

	mov	eax, DWORD PTR __Off$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], eax

; 165  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 166  : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
??Y?$_Vector_const_iterator@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<_D3DDISPLAYMODE,std::allocator<_D3DDISPLAYMODE> >::operator+=
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??Y?$_Vector_const_iterator@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
??Y?$_Vector_const_iterator@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<Ogre::D3DDEVICEINFO_T *,std::allocator<Ogre::D3DDEVICEINFO_T *> >::operator+=, COMDAT
; _this$ = ecx

; 159  : 		{	// increment by integer

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 160  : 		_SCL_SECURE_VALIDATE(this->_Has_container());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Has_container@_Iterator_base_aux@std@@QBE_NXZ ; std::_Iterator_base_aux::_Has_container
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN3@operator@24
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN3@operator@24:

; 161  : 		_SCL_SECURE_VALIDATE_RANGE(

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR __Off$[ebp]
	lea	esi, DWORD PTR [edx+eax*4]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getmycont@_Iterator_base_aux@std@@QBEPBV_Container_base_aux@2@XZ ; std::_Iterator_base_aux::_Getmycont
	cmp	esi, DWORD PTR [eax+16]
	ja	SHORT $LN1@operator@24
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR __Off$[ebp]
	lea	esi, DWORD PTR [edx+eax*4]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getmycont@_Iterator_base_aux@std@@QBEPBV_Container_base_aux@2@XZ ; std::_Iterator_base_aux::_Getmycont
	cmp	esi, DWORD PTR [eax+12]
	jae	SHORT $LN2@operator@24
$LN1@operator@24:

; 162  : 			_Myptr + _Off <= ((_Myvec *)(this->_Getmycont()))->_Mylast &&
; 163  : 			_Myptr + _Off >= ((_Myvec *)(this->_Getmycont()))->_Myfirst);

	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@operator@24:

; 164  : 		_Myptr += _Off;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR __Off$[ebp]
	lea	ecx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 165  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 166  : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
??Y?$_Vector_const_iterator@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<Ogre::D3DDEVICEINFO_T *,std::allocator<Ogre::D3DDEVICEINFO_T *> >::operator+=
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??Y?$_Vector_const_iterator@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
??Y?$_Vector_const_iterator@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<Ogre::D3DADAPTER_T *,std::allocator<Ogre::D3DADAPTER_T *> >::operator+=, COMDAT
; _this$ = ecx

; 159  : 		{	// increment by integer

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 160  : 		_SCL_SECURE_VALIDATE(this->_Has_container());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Has_container@_Iterator_base_aux@std@@QBE_NXZ ; std::_Iterator_base_aux::_Has_container
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN3@operator@25
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN3@operator@25:

; 161  : 		_SCL_SECURE_VALIDATE_RANGE(

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR __Off$[ebp]
	lea	esi, DWORD PTR [edx+eax*4]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getmycont@_Iterator_base_aux@std@@QBEPBV_Container_base_aux@2@XZ ; std::_Iterator_base_aux::_Getmycont
	cmp	esi, DWORD PTR [eax+16]
	ja	SHORT $LN1@operator@25
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR __Off$[ebp]
	lea	esi, DWORD PTR [edx+eax*4]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getmycont@_Iterator_base_aux@std@@QBEPBV_Container_base_aux@2@XZ ; std::_Iterator_base_aux::_Getmycont
	cmp	esi, DWORD PTR [eax+12]
	jae	SHORT $LN2@operator@25
$LN1@operator@25:

; 162  : 			_Myptr + _Off <= ((_Myvec *)(this->_Getmycont()))->_Mylast &&
; 163  : 			_Myptr + _Off >= ((_Myvec *)(this->_Getmycont()))->_Myfirst);

	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@operator@25:

; 164  : 		_Myptr += _Off;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR __Off$[ebp]
	lea	ecx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 165  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 166  : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
??Y?$_Vector_const_iterator@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<Ogre::D3DADAPTER_T *,std::allocator<Ogre::D3DADAPTER_T *> >::operator+=
_TEXT	ENDS
EXTRN	_memcmp:PROC
; Function compile flags: /Odtp
; File i:\svnroot\client\plugins\rendersystem_d3d9\ogred3d9driverenum.cpp
;	COMDAT ??$IsVectorContain@W4_D3DFORMAT@@@Ogre@@YAHAAV?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@ABW4_D3DFORMAT@@@Z
_TEXT	SEGMENT
_i$135183 = -4						; size = 4
_array$ = 8						; size = 4
_obj$ = 12						; size = 4
??$IsVectorContain@W4_D3DFORMAT@@@Ogre@@YAHAAV?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@ABW4_D3DFORMAT@@@Z PROC ; Ogre::IsVectorContain<enum _D3DFORMAT>, COMDAT

; 172  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 173  : 		for( UINT32 i=0; i<array.size(); i++ )

	mov	DWORD PTR _i$135183[ebp], 0
	jmp	SHORT $LN4@IsVectorCo
$LN3@IsVectorCo:
	mov	eax, DWORD PTR _i$135183[ebp]
	add	eax, 1
	mov	DWORD PTR _i$135183[ebp], eax
$LN4@IsVectorCo:
	mov	ecx, DWORD PTR _array$[ebp]
	call	?size@?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@QBEIXZ ; std::vector<enum _D3DFORMAT,std::allocator<enum _D3DFORMAT> >::size
	cmp	DWORD PTR _i$135183[ebp], eax
	jae	SHORT $LN2@IsVectorCo

; 174  : 		{
; 175  : 			if( memcmp(&array[i], &obj, sizeof(T)) == 0 ) return TRUE;

	push	4
	mov	ecx, DWORD PTR _obj$[ebp]
	push	ecx
	mov	edx, DWORD PTR _i$135183[ebp]
	push	edx
	mov	ecx, DWORD PTR _array$[ebp]
	call	??A?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@QAEAAW4_D3DFORMAT@@I@Z ; std::vector<enum _D3DFORMAT,std::allocator<enum _D3DFORMAT> >::operator[]
	push	eax
	call	_memcmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN1@IsVectorCo
	mov	eax, 1
	jmp	SHORT $LN5@IsVectorCo
$LN1@IsVectorCo:

; 176  : 		}

	jmp	SHORT $LN3@IsVectorCo
$LN2@IsVectorCo:

; 177  : 		return FALSE;

	xor	eax, eax
$LN5@IsVectorCo:

; 178  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$IsVectorContain@W4_D3DFORMAT@@@Ogre@@YAHAAV?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@ABW4_D3DFORMAT@@@Z ENDP ; Ogre::IsVectorContain<enum _D3DFORMAT>
_TEXT	ENDS
PUBLIC	?MakePtrGuard@?$PtrScopeGuardImpl@UD3DDEVCOMBO_T@Ogre@@@Ogre@@SA?AV12@PAUD3DDEVCOMBO_T@2@@Z ; Ogre::PtrScopeGuardImpl<Ogre::D3DDEVCOMBO_T>::MakePtrGuard
;	COMDAT xdata$x
; File i:\svnroot\client\ogremain\ogrescopeguard.h
xdata$x	SEGMENT
__unwindtable$??$MakePtrGuard@UD3DDEVCOMBO_T@Ogre@@@Ogre@@YA?AV?$PtrScopeGuardImpl@UD3DDEVCOMBO_T@Ogre@@@0@PAUD3DDEVCOMBO_T@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$MakePtrGuard@UD3DDEVCOMBO_T@Ogre@@@Ogre@@YA?AV?$PtrScopeGuardImpl@UD3DDEVCOMBO_T@Ogre@@@0@PAUD3DDEVCOMBO_T@0@@Z$0
__ehfuncinfo$??$MakePtrGuard@UD3DDEVCOMBO_T@Ogre@@@Ogre@@YA?AV?$PtrScopeGuardImpl@UD3DDEVCOMBO_T@Ogre@@@0@PAUD3DDEVCOMBO_T@0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$MakePtrGuard@UD3DDEVCOMBO_T@Ogre@@@Ogre@@YA?AV?$PtrScopeGuardImpl@UD3DDEVCOMBO_T@Ogre@@@0@PAUD3DDEVCOMBO_T@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??$MakePtrGuard@UD3DDEVCOMBO_T@Ogre@@@Ogre@@YA?AV?$PtrScopeGuardImpl@UD3DDEVCOMBO_T@Ogre@@@0@PAUD3DDEVCOMBO_T@0@@Z
_TEXT	SEGMENT
$T143100 = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_p$ = 12						; size = 4
??$MakePtrGuard@UD3DDEVCOMBO_T@Ogre@@@Ogre@@YA?AV?$PtrScopeGuardImpl@UD3DDEVCOMBO_T@Ogre@@@0@PAUD3DDEVCOMBO_T@0@@Z PROC ; Ogre::MakePtrGuard<Ogre::D3DDEVCOMBO_T>, COMDAT

; 305  : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$MakePtrGuard@UD3DDEVCOMBO_T@Ogre@@@Ogre@@YA?AV?$PtrScopeGuardImpl@UD3DDEVCOMBO_T@Ogre@@@0@PAUD3DDEVCOMBO_T@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR $T143100[ebp], 0

; 306  : 		return PtrScopeGuardImpl<T>::MakePtrGuard( p );

	mov	eax, DWORD PTR _p$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	push	ecx
	call	?MakePtrGuard@?$PtrScopeGuardImpl@UD3DDEVCOMBO_T@Ogre@@@Ogre@@SA?AV12@PAUD3DDEVCOMBO_T@2@@Z ; Ogre::PtrScopeGuardImpl<Ogre::D3DDEVCOMBO_T>::MakePtrGuard
	add	esp, 8
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	edx, DWORD PTR $T143100[ebp]
	or	edx, 1
	mov	DWORD PTR $T143100[ebp], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 307  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$MakePtrGuard@UD3DDEVCOMBO_T@Ogre@@@Ogre@@YA?AV?$PtrScopeGuardImpl@UD3DDEVCOMBO_T@Ogre@@@0@PAUD3DDEVCOMBO_T@0@@Z$0:
	mov	eax, DWORD PTR $T143100[ebp]
	and	eax, 1
	je	$LN4@MakePtrGua
	and	DWORD PTR $T143100[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	??1?$PtrScopeGuardImpl@UD3DDEVCOMBO_T@Ogre@@@Ogre@@QAE@XZ ; Ogre::PtrScopeGuardImpl<Ogre::D3DDEVCOMBO_T>::~PtrScopeGuardImpl<Ogre::D3DDEVCOMBO_T>
$LN4@MakePtrGua:
	ret	0
__ehhandler$??$MakePtrGuard@UD3DDEVCOMBO_T@Ogre@@@Ogre@@YA?AV?$PtrScopeGuardImpl@UD3DDEVCOMBO_T@Ogre@@@0@PAUD3DDEVCOMBO_T@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$MakePtrGuard@UD3DDEVCOMBO_T@Ogre@@@Ogre@@YA?AV?$PtrScopeGuardImpl@UD3DDEVCOMBO_T@Ogre@@@0@PAUD3DDEVCOMBO_T@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$MakePtrGuard@UD3DDEVCOMBO_T@Ogre@@@Ogre@@YA?AV?$PtrScopeGuardImpl@UD3DDEVCOMBO_T@Ogre@@@0@PAUD3DDEVCOMBO_T@0@@Z ENDP ; Ogre::MakePtrGuard<Ogre::D3DDEVCOMBO_T>
PUBLIC	??A?$vector@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@QAEAAW4VERTPROCESS_T@Ogre@@I@Z ; std::vector<enum Ogre::VERTPROCESS_T,std::allocator<enum Ogre::VERTPROCESS_T> >::operator[]
; Function compile flags: /Odtp
; File i:\svnroot\client\plugins\rendersystem_d3d9\ogred3d9driverenum.cpp
;	COMDAT ??$IsValueInArray@W4VERTPROCESS_T@Ogre@@@Ogre@@YA_NW4VERTPROCESS_T@0@AAV?$vector@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@@Z
_TEXT	SEGMENT
_i$135194 = -4						; size = 4
_v$ = 8							; size = 4
_array$ = 12						; size = 4
??$IsValueInArray@W4VERTPROCESS_T@Ogre@@@Ogre@@YA_NW4VERTPROCESS_T@0@AAV?$vector@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@@Z PROC ; Ogre::IsValueInArray<enum Ogre::VERTPROCESS_T>, COMDAT

; 472  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 473  : 		for(size_t i=0; i<array.size(); i++)

	mov	DWORD PTR _i$135194[ebp], 0
	jmp	SHORT $LN4@IsValueInA
$LN3@IsValueInA:
	mov	eax, DWORD PTR _i$135194[ebp]
	add	eax, 1
	mov	DWORD PTR _i$135194[ebp], eax
$LN4@IsValueInA:
	mov	ecx, DWORD PTR _array$[ebp]
	call	?size@?$vector@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@QBEIXZ ; std::vector<enum Ogre::VERTPROCESS_T,std::allocator<enum Ogre::VERTPROCESS_T> >::size
	cmp	DWORD PTR _i$135194[ebp], eax
	jae	SHORT $LN2@IsValueInA

; 474  : 		{
; 475  : 			if(v == array[i]) return true;

	mov	ecx, DWORD PTR _i$135194[ebp]
	push	ecx
	mov	ecx, DWORD PTR _array$[ebp]
	call	??A?$vector@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@QAEAAW4VERTPROCESS_T@Ogre@@I@Z ; std::vector<enum Ogre::VERTPROCESS_T,std::allocator<enum Ogre::VERTPROCESS_T> >::operator[]
	mov	edx, DWORD PTR _v$[ebp]
	cmp	edx, DWORD PTR [eax]
	jne	SHORT $LN1@IsValueInA
	mov	al, 1
	jmp	SHORT $LN5@IsValueInA
$LN1@IsValueInA:

; 476  : 		}

	jmp	SHORT $LN3@IsValueInA
$LN2@IsValueInA:

; 477  : 		return false;

	xor	al, al
$LN5@IsValueInA:

; 478  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$IsValueInArray@W4VERTPROCESS_T@Ogre@@@Ogre@@YA_NW4VERTPROCESS_T@0@AAV?$vector@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@@Z ENDP ; Ogre::IsValueInArray<enum Ogre::VERTPROCESS_T>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$IsValueInArray@W4_D3DMULTISAMPLE_TYPE@@@Ogre@@YA_NW4_D3DMULTISAMPLE_TYPE@@AAV?$vector@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@@Z
_TEXT	SEGMENT
_i$135200 = -4						; size = 4
_v$ = 8							; size = 4
_array$ = 12						; size = 4
??$IsValueInArray@W4_D3DMULTISAMPLE_TYPE@@@Ogre@@YA_NW4_D3DMULTISAMPLE_TYPE@@AAV?$vector@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@@Z PROC ; Ogre::IsValueInArray<enum _D3DMULTISAMPLE_TYPE>, COMDAT

; 472  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 473  : 		for(size_t i=0; i<array.size(); i++)

	mov	DWORD PTR _i$135200[ebp], 0
	jmp	SHORT $LN4@IsValueInA@2
$LN3@IsValueInA@2:
	mov	eax, DWORD PTR _i$135200[ebp]
	add	eax, 1
	mov	DWORD PTR _i$135200[ebp], eax
$LN4@IsValueInA@2:
	mov	ecx, DWORD PTR _array$[ebp]
	call	?size@?$vector@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@QBEIXZ ; std::vector<enum _D3DMULTISAMPLE_TYPE,std::allocator<enum _D3DMULTISAMPLE_TYPE> >::size
	cmp	DWORD PTR _i$135200[ebp], eax
	jae	SHORT $LN2@IsValueInA@2

; 474  : 		{
; 475  : 			if(v == array[i]) return true;

	mov	ecx, DWORD PTR _i$135200[ebp]
	push	ecx
	mov	ecx, DWORD PTR _array$[ebp]
	call	??A?$vector@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@QAEAAW4_D3DMULTISAMPLE_TYPE@@I@Z ; std::vector<enum _D3DMULTISAMPLE_TYPE,std::allocator<enum _D3DMULTISAMPLE_TYPE> >::operator[]
	mov	edx, DWORD PTR _v$[ebp]
	cmp	edx, DWORD PTR [eax]
	jne	SHORT $LN1@IsValueInA@2
	mov	al, 1
	jmp	SHORT $LN5@IsValueInA@2
$LN1@IsValueInA@2:

; 476  : 		}

	jmp	SHORT $LN3@IsValueInA@2
$LN2@IsValueInA@2:

; 477  : 		return false;

	xor	al, al
$LN5@IsValueInA@2:

; 478  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$IsValueInArray@W4_D3DMULTISAMPLE_TYPE@@@Ogre@@YA_NW4_D3DMULTISAMPLE_TYPE@@AAV?$vector@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@@Z ENDP ; Ogre::IsValueInArray<enum _D3DMULTISAMPLE_TYPE>
_TEXT	ENDS
PUBLIC	?Execute@?$PtrScopeGuardImpl@UD3DDEVCOMBO_T@Ogre@@@Ogre@@QAEXXZ ; Ogre::PtrScopeGuardImpl<Ogre::D3DDEVCOMBO_T>::Execute
;	COMDAT xdata$x
; File i:\svnroot\client\ogremain\ogrescopeguard.h
xdata$x	SEGMENT
__catchsym$??$SafeExecute@V?$PtrScopeGuardImpl@UD3DDEVCOMBO_T@Ogre@@@Ogre@@@ScopeGuardImplBase@Ogre@@KAXAAV?$PtrScopeGuardImpl@UD3DDEVCOMBO_T@Ogre@@@1@@Z$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$SafeExecute@V?$PtrScopeGuardImpl@UD3DDEVCOMBO_T@Ogre@@@Ogre@@@ScopeGuardImplBase@Ogre@@KAXAAV?$PtrScopeGuardImpl@UD3DDEVCOMBO_T@Ogre@@@1@@Z$0
__unwindtable$??$SafeExecute@V?$PtrScopeGuardImpl@UD3DDEVCOMBO_T@Ogre@@@Ogre@@@ScopeGuardImplBase@Ogre@@KAXAAV?$PtrScopeGuardImpl@UD3DDEVCOMBO_T@Ogre@@@1@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$SafeExecute@V?$PtrScopeGuardImpl@UD3DDEVCOMBO_T@Ogre@@@Ogre@@@ScopeGuardImplBase@Ogre@@KAXAAV?$PtrScopeGuardImpl@UD3DDEVCOMBO_T@Ogre@@@1@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$SafeExecute@V?$PtrScopeGuardImpl@UD3DDEVCOMBO_T@Ogre@@@Ogre@@@ScopeGuardImplBase@Ogre@@KAXAAV?$PtrScopeGuardImpl@UD3DDEVCOMBO_T@Ogre@@@1@@Z$2
__ehfuncinfo$??$SafeExecute@V?$PtrScopeGuardImpl@UD3DDEVCOMBO_T@Ogre@@@Ogre@@@ScopeGuardImplBase@Ogre@@KAXAAV?$PtrScopeGuardImpl@UD3DDEVCOMBO_T@Ogre@@@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$SafeExecute@V?$PtrScopeGuardImpl@UD3DDEVCOMBO_T@Ogre@@@Ogre@@@ScopeGuardImplBase@Ogre@@KAXAAV?$PtrScopeGuardImpl@UD3DDEVCOMBO_T@Ogre@@@1@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$SafeExecute@V?$PtrScopeGuardImpl@UD3DDEVCOMBO_T@Ogre@@@Ogre@@@ScopeGuardImplBase@Ogre@@KAXAAV?$PtrScopeGuardImpl@UD3DDEVCOMBO_T@Ogre@@@1@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??$SafeExecute@V?$PtrScopeGuardImpl@UD3DDEVCOMBO_T@Ogre@@@Ogre@@@ScopeGuardImplBase@Ogre@@KAXAAV?$PtrScopeGuardImpl@UD3DDEVCOMBO_T@Ogre@@@1@@Z
_TEXT	SEGMENT
__$EHRec$ = -16						; size = 16
_j$ = 8							; size = 4
??$SafeExecute@V?$PtrScopeGuardImpl@UD3DDEVCOMBO_T@Ogre@@@Ogre@@@ScopeGuardImplBase@Ogre@@KAXAAV?$PtrScopeGuardImpl@UD3DDEVCOMBO_T@Ogre@@@1@@Z PROC ; Ogre::ScopeGuardImplBase::SafeExecute<Ogre::PtrScopeGuardImpl<Ogre::D3DDEVCOMBO_T> >, COMDAT

; 42   : 		{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$SafeExecute@V?$PtrScopeGuardImpl@UD3DDEVCOMBO_T@Ogre@@@Ogre@@@ScopeGuardImplBase@Ogre@@KAXAAV?$PtrScopeGuardImpl@UD3DDEVCOMBO_T@Ogre@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 43   : 			if (!j.dismissed_)

	mov	eax, DWORD PTR _j$[ebp]
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN3@SafeExecut

; 44   : 				try
; 45   : 			{

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 46   : 				j.Execute();

	mov	ecx, DWORD PTR _j$[ebp]
	call	?Execute@?$PtrScopeGuardImpl@UD3DDEVCOMBO_T@Ogre@@@Ogre@@QAEXXZ ; Ogre::PtrScopeGuardImpl<Ogre::D3DDEVCOMBO_T>::Execute

; 47   : 			}

	jmp	SHORT $LN5@SafeExecut
__catch$??$SafeExecute@V?$PtrScopeGuardImpl@UD3DDEVCOMBO_T@Ogre@@@Ogre@@@ScopeGuardImplBase@Ogre@@KAXAAV?$PtrScopeGuardImpl@UD3DDEVCOMBO_T@Ogre@@@1@@Z$0:

; 48   : 			catch(...)
; 49   : 			{
; 50   : 			}

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, $LN3@SafeExecut
	ret	0
$LN5@SafeExecut:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
$LN3@SafeExecut:

; 51   : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$SafeExecute@V?$PtrScopeGuardImpl@UD3DDEVCOMBO_T@Ogre@@@Ogre@@@ScopeGuardImplBase@Ogre@@KAXAAV?$PtrScopeGuardImpl@UD3DDEVCOMBO_T@Ogre@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$SafeExecute@V?$PtrScopeGuardImpl@UD3DDEVCOMBO_T@Ogre@@@Ogre@@@ScopeGuardImplBase@Ogre@@KAXAAV?$PtrScopeGuardImpl@UD3DDEVCOMBO_T@Ogre@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$SafeExecute@V?$PtrScopeGuardImpl@UD3DDEVCOMBO_T@Ogre@@@Ogre@@@ScopeGuardImplBase@Ogre@@KAXAAV?$PtrScopeGuardImpl@UD3DDEVCOMBO_T@Ogre@@@1@@Z ENDP ; Ogre::ScopeGuardImplBase::SafeExecute<Ogre::PtrScopeGuardImpl<Ogre::D3DDEVCOMBO_T> >
PUBLIC	??$_Uninit_fill_n@PAW4_D3DFORMAT@@IW41@V?$allocator@W4_D3DFORMAT@@@std@@@std@@YAXPAW4_D3DFORMAT@@IABW41@AAV?$allocator@W4_D3DFORMAT@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<enum _D3DFORMAT *,unsigned int,enum _D3DFORMAT,std::allocator<enum _D3DFORMAT> >
PUBLIC	??$_Ptr_cat@PAW4_D3DFORMAT@@PAW41@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAW4_D3DFORMAT@@0@Z ; std::_Ptr_cat<enum _D3DFORMAT *,enum _D3DFORMAT *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_fill_n@PAW4_D3DFORMAT@@IW41@V?$allocator@W4_D3DFORMAT@@@std@@@stdext@@YAXPAW4_D3DFORMAT@@IABW41@AAV?$allocator@W4_D3DFORMAT@@@std@@@Z
_TEXT	SEGMENT
$T143130 = -2						; size = 1
$T143129 = -1						; size = 1
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_fill_n@PAW4_D3DFORMAT@@IW41@V?$allocator@W4_D3DFORMAT@@@std@@@stdext@@YAXPAW4_D3DFORMAT@@IABW41@AAV?$allocator@W4_D3DFORMAT@@@std@@@Z PROC ; stdext::unchecked_uninitialized_fill_n<enum _D3DFORMAT *,unsigned int,enum _D3DFORMAT,std::allocator<enum _D3DFORMAT> >, COMDAT

; 940  : 	{	// copy _Count *_Val to raw _First, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 941  : 	_STD _Uninit_fill_n(_First, _Count, _Val, _Al,
; 942  : 		_STD _Ptr_cat(_First, _First), _STD _Range_checked_iterator_tag());

	xor	eax, eax
	mov	BYTE PTR $T143129[ebp], al
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAW4_D3DFORMAT@@PAW41@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAW4_D3DFORMAT@@0@Z ; std::_Ptr_cat<enum _D3DFORMAT *,enum _D3DFORMAT *>
	add	esp, 8
	mov	BYTE PTR $T143130[ebp], al
	movzx	eax, BYTE PTR $T143129[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T143130[ebp]
	push	ecx
	mov	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Uninit_fill_n@PAW4_D3DFORMAT@@IW41@V?$allocator@W4_D3DFORMAT@@@std@@@std@@YAXPAW4_D3DFORMAT@@IABW41@AAV?$allocator@W4_D3DFORMAT@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<enum _D3DFORMAT *,unsigned int,enum _D3DFORMAT,std::allocator<enum _D3DFORMAT> >
	add	esp, 24					; 00000018H

; 943  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_fill_n@PAW4_D3DFORMAT@@IW41@V?$allocator@W4_D3DFORMAT@@@std@@@stdext@@YAXPAW4_D3DFORMAT@@IABW41@AAV?$allocator@W4_D3DFORMAT@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_fill_n<enum _D3DFORMAT *,unsigned int,enum _D3DFORMAT,std::allocator<enum _D3DFORMAT> >
_TEXT	ENDS
PUBLIC	??$_Uninit_fill_n@PAW4_D3DMULTISAMPLE_TYPE@@IW41@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@YAXPAW4_D3DMULTISAMPLE_TYPE@@IABW41@AAV?$allocator@W4_D3DMULTISAMPLE_TYPE@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<enum _D3DMULTISAMPLE_TYPE *,unsigned int,enum _D3DMULTISAMPLE_TYPE,std::allocator<enum _D3DMULTISAMPLE_TYPE> >
PUBLIC	??$_Ptr_cat@PAW4_D3DMULTISAMPLE_TYPE@@PAW41@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAW4_D3DMULTISAMPLE_TYPE@@0@Z ; std::_Ptr_cat<enum _D3DMULTISAMPLE_TYPE *,enum _D3DMULTISAMPLE_TYPE *>
; Function compile flags: /Odtp
;	COMDAT ??$unchecked_uninitialized_fill_n@PAW4_D3DMULTISAMPLE_TYPE@@IW41@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@stdext@@YAXPAW4_D3DMULTISAMPLE_TYPE@@IABW41@AAV?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@Z
_TEXT	SEGMENT
$T143134 = -2						; size = 1
$T143133 = -1						; size = 1
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_fill_n@PAW4_D3DMULTISAMPLE_TYPE@@IW41@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@stdext@@YAXPAW4_D3DMULTISAMPLE_TYPE@@IABW41@AAV?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@Z PROC ; stdext::unchecked_uninitialized_fill_n<enum _D3DMULTISAMPLE_TYPE *,unsigned int,enum _D3DMULTISAMPLE_TYPE,std::allocator<enum _D3DMULTISAMPLE_TYPE> >, COMDAT

; 940  : 	{	// copy _Count *_Val to raw _First, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 941  : 	_STD _Uninit_fill_n(_First, _Count, _Val, _Al,
; 942  : 		_STD _Ptr_cat(_First, _First), _STD _Range_checked_iterator_tag());

	xor	eax, eax
	mov	BYTE PTR $T143133[ebp], al
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAW4_D3DMULTISAMPLE_TYPE@@PAW41@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAW4_D3DMULTISAMPLE_TYPE@@0@Z ; std::_Ptr_cat<enum _D3DMULTISAMPLE_TYPE *,enum _D3DMULTISAMPLE_TYPE *>
	add	esp, 8
	mov	BYTE PTR $T143134[ebp], al
	movzx	eax, BYTE PTR $T143133[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T143134[ebp]
	push	ecx
	mov	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Uninit_fill_n@PAW4_D3DMULTISAMPLE_TYPE@@IW41@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@YAXPAW4_D3DMULTISAMPLE_TYPE@@IABW41@AAV?$allocator@W4_D3DMULTISAMPLE_TYPE@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<enum _D3DMULTISAMPLE_TYPE *,unsigned int,enum _D3DMULTISAMPLE_TYPE,std::allocator<enum _D3DMULTISAMPLE_TYPE> >
	add	esp, 24					; 00000018H

; 943  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_fill_n@PAW4_D3DMULTISAMPLE_TYPE@@IW41@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@stdext@@YAXPAW4_D3DMULTISAMPLE_TYPE@@IABW41@AAV?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_fill_n<enum _D3DMULTISAMPLE_TYPE *,unsigned int,enum _D3DMULTISAMPLE_TYPE,std::allocator<enum _D3DMULTISAMPLE_TYPE> >
_TEXT	ENDS
PUBLIC	??$_Uninit_fill_n@PAIIIV?$allocator@I@std@@@std@@YAXPAIIABIAAV?$allocator@I@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<unsigned int *,unsigned int,unsigned int,std::allocator<unsigned int> >
PUBLIC	??$_Ptr_cat@PAIPAI@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAI0@Z ; std::_Ptr_cat<unsigned int *,unsigned int *>
; Function compile flags: /Odtp
;	COMDAT ??$unchecked_uninitialized_fill_n@PAIIIV?$allocator@I@std@@@stdext@@YAXPAIIABIAAV?$allocator@I@std@@@Z
_TEXT	SEGMENT
$T143138 = -2						; size = 1
$T143137 = -1						; size = 1
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_fill_n@PAIIIV?$allocator@I@std@@@stdext@@YAXPAIIABIAAV?$allocator@I@std@@@Z PROC ; stdext::unchecked_uninitialized_fill_n<unsigned int *,unsigned int,unsigned int,std::allocator<unsigned int> >, COMDAT

; 940  : 	{	// copy _Count *_Val to raw _First, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 941  : 	_STD _Uninit_fill_n(_First, _Count, _Val, _Al,
; 942  : 		_STD _Ptr_cat(_First, _First), _STD _Range_checked_iterator_tag());

	xor	eax, eax
	mov	BYTE PTR $T143137[ebp], al
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAIPAI@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAI0@Z ; std::_Ptr_cat<unsigned int *,unsigned int *>
	add	esp, 8
	mov	BYTE PTR $T143138[ebp], al
	movzx	eax, BYTE PTR $T143137[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T143138[ebp]
	push	ecx
	mov	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Uninit_fill_n@PAIIIV?$allocator@I@std@@@std@@YAXPAIIABIAAV?$allocator@I@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<unsigned int *,unsigned int,unsigned int,std::allocator<unsigned int> >
	add	esp, 24					; 00000018H

; 943  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_fill_n@PAIIIV?$allocator@I@std@@@stdext@@YAXPAIIABIAAV?$allocator@I@std@@@Z ENDP ; stdext::unchecked_uninitialized_fill_n<unsigned int *,unsigned int,unsigned int,std::allocator<unsigned int> >
_TEXT	ENDS
PUBLIC	??$_Uninit_fill_n@PAUD3DSMSCONFLICT_T@Ogre@@IU12@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@YAXPAUD3DSMSCONFLICT_T@Ogre@@IABU12@AAV?$allocator@UD3DSMSCONFLICT_T@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<Ogre::D3DSMSCONFLICT_T *,unsigned int,Ogre::D3DSMSCONFLICT_T,std::allocator<Ogre::D3DSMSCONFLICT_T> >
PUBLIC	??$_Ptr_cat@PAUD3DSMSCONFLICT_T@Ogre@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUD3DSMSCONFLICT_T@Ogre@@0@Z ; std::_Ptr_cat<Ogre::D3DSMSCONFLICT_T *,Ogre::D3DSMSCONFLICT_T *>
; Function compile flags: /Odtp
;	COMDAT ??$unchecked_uninitialized_fill_n@PAUD3DSMSCONFLICT_T@Ogre@@IU12@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@stdext@@YAXPAUD3DSMSCONFLICT_T@Ogre@@IABU12@AAV?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@Z
_TEXT	SEGMENT
$T143142 = -2						; size = 1
$T143141 = -1						; size = 1
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_fill_n@PAUD3DSMSCONFLICT_T@Ogre@@IU12@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@stdext@@YAXPAUD3DSMSCONFLICT_T@Ogre@@IABU12@AAV?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@Z PROC ; stdext::unchecked_uninitialized_fill_n<Ogre::D3DSMSCONFLICT_T *,unsigned int,Ogre::D3DSMSCONFLICT_T,std::allocator<Ogre::D3DSMSCONFLICT_T> >, COMDAT

; 940  : 	{	// copy _Count *_Val to raw _First, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 941  : 	_STD _Uninit_fill_n(_First, _Count, _Val, _Al,
; 942  : 		_STD _Ptr_cat(_First, _First), _STD _Range_checked_iterator_tag());

	xor	eax, eax
	mov	BYTE PTR $T143141[ebp], al
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAUD3DSMSCONFLICT_T@Ogre@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUD3DSMSCONFLICT_T@Ogre@@0@Z ; std::_Ptr_cat<Ogre::D3DSMSCONFLICT_T *,Ogre::D3DSMSCONFLICT_T *>
	add	esp, 8
	mov	BYTE PTR $T143142[ebp], al
	movzx	eax, BYTE PTR $T143141[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T143142[ebp]
	push	ecx
	mov	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Uninit_fill_n@PAUD3DSMSCONFLICT_T@Ogre@@IU12@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@YAXPAUD3DSMSCONFLICT_T@Ogre@@IABU12@AAV?$allocator@UD3DSMSCONFLICT_T@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<Ogre::D3DSMSCONFLICT_T *,unsigned int,Ogre::D3DSMSCONFLICT_T,std::allocator<Ogre::D3DSMSCONFLICT_T> >
	add	esp, 24					; 00000018H

; 943  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_fill_n@PAUD3DSMSCONFLICT_T@Ogre@@IU12@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@stdext@@YAXPAUD3DSMSCONFLICT_T@Ogre@@IABU12@AAV?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_fill_n<Ogre::D3DSMSCONFLICT_T *,unsigned int,Ogre::D3DSMSCONFLICT_T,std::allocator<Ogre::D3DSMSCONFLICT_T> >
_TEXT	ENDS
PUBLIC	??$_Uninit_fill_n@PAW4VERTPROCESS_T@Ogre@@IW412@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@YAXPAW4VERTPROCESS_T@Ogre@@IABW412@AAV?$allocator@W4VERTPROCESS_T@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<enum Ogre::VERTPROCESS_T *,unsigned int,enum Ogre::VERTPROCESS_T,std::allocator<enum Ogre::VERTPROCESS_T> >
PUBLIC	??$_Ptr_cat@PAW4VERTPROCESS_T@Ogre@@PAW412@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAW4VERTPROCESS_T@Ogre@@0@Z ; std::_Ptr_cat<enum Ogre::VERTPROCESS_T *,enum Ogre::VERTPROCESS_T *>
; Function compile flags: /Odtp
;	COMDAT ??$unchecked_uninitialized_fill_n@PAW4VERTPROCESS_T@Ogre@@IW412@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@stdext@@YAXPAW4VERTPROCESS_T@Ogre@@IABW412@AAV?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@Z
_TEXT	SEGMENT
$T143146 = -2						; size = 1
$T143145 = -1						; size = 1
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_fill_n@PAW4VERTPROCESS_T@Ogre@@IW412@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@stdext@@YAXPAW4VERTPROCESS_T@Ogre@@IABW412@AAV?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@Z PROC ; stdext::unchecked_uninitialized_fill_n<enum Ogre::VERTPROCESS_T *,unsigned int,enum Ogre::VERTPROCESS_T,std::allocator<enum Ogre::VERTPROCESS_T> >, COMDAT

; 940  : 	{	// copy _Count *_Val to raw _First, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 941  : 	_STD _Uninit_fill_n(_First, _Count, _Val, _Al,
; 942  : 		_STD _Ptr_cat(_First, _First), _STD _Range_checked_iterator_tag());

	xor	eax, eax
	mov	BYTE PTR $T143145[ebp], al
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAW4VERTPROCESS_T@Ogre@@PAW412@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAW4VERTPROCESS_T@Ogre@@0@Z ; std::_Ptr_cat<enum Ogre::VERTPROCESS_T *,enum Ogre::VERTPROCESS_T *>
	add	esp, 8
	mov	BYTE PTR $T143146[ebp], al
	movzx	eax, BYTE PTR $T143145[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T143146[ebp]
	push	ecx
	mov	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Uninit_fill_n@PAW4VERTPROCESS_T@Ogre@@IW412@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@YAXPAW4VERTPROCESS_T@Ogre@@IABW412@AAV?$allocator@W4VERTPROCESS_T@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<enum Ogre::VERTPROCESS_T *,unsigned int,enum Ogre::VERTPROCESS_T,std::allocator<enum Ogre::VERTPROCESS_T> >
	add	esp, 24					; 00000018H

; 943  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_fill_n@PAW4VERTPROCESS_T@Ogre@@IW412@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@stdext@@YAXPAW4VERTPROCESS_T@Ogre@@IABW412@AAV?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_fill_n<enum Ogre::VERTPROCESS_T *,unsigned int,enum Ogre::VERTPROCESS_T,std::allocator<enum Ogre::VERTPROCESS_T> >
_TEXT	ENDS
PUBLIC	??$_Uninit_fill_n@PAPAUD3DDEVCOMBO_T@Ogre@@IPAU12@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@YAXPAPAUD3DDEVCOMBO_T@Ogre@@IABQAU12@AAV?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<Ogre::D3DDEVCOMBO_T * *,unsigned int,Ogre::D3DDEVCOMBO_T *,std::allocator<Ogre::D3DDEVCOMBO_T *> >
PUBLIC	??$_Ptr_cat@PAPAUD3DDEVCOMBO_T@Ogre@@PAPAU12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAUD3DDEVCOMBO_T@Ogre@@0@Z ; std::_Ptr_cat<Ogre::D3DDEVCOMBO_T * *,Ogre::D3DDEVCOMBO_T * *>
; Function compile flags: /Odtp
;	COMDAT ??$unchecked_uninitialized_fill_n@PAPAUD3DDEVCOMBO_T@Ogre@@IPAU12@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@stdext@@YAXPAPAUD3DDEVCOMBO_T@Ogre@@IABQAU12@AAV?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@Z
_TEXT	SEGMENT
$T143150 = -2						; size = 1
$T143149 = -1						; size = 1
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_fill_n@PAPAUD3DDEVCOMBO_T@Ogre@@IPAU12@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@stdext@@YAXPAPAUD3DDEVCOMBO_T@Ogre@@IABQAU12@AAV?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@Z PROC ; stdext::unchecked_uninitialized_fill_n<Ogre::D3DDEVCOMBO_T * *,unsigned int,Ogre::D3DDEVCOMBO_T *,std::allocator<Ogre::D3DDEVCOMBO_T *> >, COMDAT

; 940  : 	{	// copy _Count *_Val to raw _First, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 941  : 	_STD _Uninit_fill_n(_First, _Count, _Val, _Al,
; 942  : 		_STD _Ptr_cat(_First, _First), _STD _Range_checked_iterator_tag());

	xor	eax, eax
	mov	BYTE PTR $T143149[ebp], al
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAPAUD3DDEVCOMBO_T@Ogre@@PAPAU12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAUD3DDEVCOMBO_T@Ogre@@0@Z ; std::_Ptr_cat<Ogre::D3DDEVCOMBO_T * *,Ogre::D3DDEVCOMBO_T * *>
	add	esp, 8
	mov	BYTE PTR $T143150[ebp], al
	movzx	eax, BYTE PTR $T143149[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T143150[ebp]
	push	ecx
	mov	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Uninit_fill_n@PAPAUD3DDEVCOMBO_T@Ogre@@IPAU12@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@YAXPAPAUD3DDEVCOMBO_T@Ogre@@IABQAU12@AAV?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<Ogre::D3DDEVCOMBO_T * *,unsigned int,Ogre::D3DDEVCOMBO_T *,std::allocator<Ogre::D3DDEVCOMBO_T *> >
	add	esp, 24					; 00000018H

; 943  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_fill_n@PAPAUD3DDEVCOMBO_T@Ogre@@IPAU12@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@stdext@@YAXPAPAUD3DDEVCOMBO_T@Ogre@@IABQAU12@AAV?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_fill_n<Ogre::D3DDEVCOMBO_T * *,unsigned int,Ogre::D3DDEVCOMBO_T *,std::allocator<Ogre::D3DDEVCOMBO_T *> >
_TEXT	ENDS
PUBLIC	??$_Uninit_fill_n@PAU_D3DDISPLAYMODE@@IU1@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@YAXPAU_D3DDISPLAYMODE@@IABU1@AAV?$allocator@U_D3DDISPLAYMODE@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<_D3DDISPLAYMODE *,unsigned int,_D3DDISPLAYMODE,std::allocator<_D3DDISPLAYMODE> >
PUBLIC	??$_Ptr_cat@PAU_D3DDISPLAYMODE@@PAU1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAU_D3DDISPLAYMODE@@0@Z ; std::_Ptr_cat<_D3DDISPLAYMODE *,_D3DDISPLAYMODE *>
; Function compile flags: /Odtp
;	COMDAT ??$unchecked_uninitialized_fill_n@PAU_D3DDISPLAYMODE@@IU1@V?$allocator@U_D3DDISPLAYMODE@@@std@@@stdext@@YAXPAU_D3DDISPLAYMODE@@IABU1@AAV?$allocator@U_D3DDISPLAYMODE@@@std@@@Z
_TEXT	SEGMENT
$T143154 = -2						; size = 1
$T143153 = -1						; size = 1
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_fill_n@PAU_D3DDISPLAYMODE@@IU1@V?$allocator@U_D3DDISPLAYMODE@@@std@@@stdext@@YAXPAU_D3DDISPLAYMODE@@IABU1@AAV?$allocator@U_D3DDISPLAYMODE@@@std@@@Z PROC ; stdext::unchecked_uninitialized_fill_n<_D3DDISPLAYMODE *,unsigned int,_D3DDISPLAYMODE,std::allocator<_D3DDISPLAYMODE> >, COMDAT

; 940  : 	{	// copy _Count *_Val to raw _First, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 941  : 	_STD _Uninit_fill_n(_First, _Count, _Val, _Al,
; 942  : 		_STD _Ptr_cat(_First, _First), _STD _Range_checked_iterator_tag());

	xor	eax, eax
	mov	BYTE PTR $T143153[ebp], al
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAU_D3DDISPLAYMODE@@PAU1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAU_D3DDISPLAYMODE@@0@Z ; std::_Ptr_cat<_D3DDISPLAYMODE *,_D3DDISPLAYMODE *>
	add	esp, 8
	mov	BYTE PTR $T143154[ebp], al
	movzx	eax, BYTE PTR $T143153[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T143154[ebp]
	push	ecx
	mov	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Uninit_fill_n@PAU_D3DDISPLAYMODE@@IU1@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@YAXPAU_D3DDISPLAYMODE@@IABU1@AAV?$allocator@U_D3DDISPLAYMODE@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<_D3DDISPLAYMODE *,unsigned int,_D3DDISPLAYMODE,std::allocator<_D3DDISPLAYMODE> >
	add	esp, 24					; 00000018H

; 943  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_fill_n@PAU_D3DDISPLAYMODE@@IU1@V?$allocator@U_D3DDISPLAYMODE@@@std@@@stdext@@YAXPAU_D3DDISPLAYMODE@@IABU1@AAV?$allocator@U_D3DDISPLAYMODE@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_fill_n<_D3DDISPLAYMODE *,unsigned int,_D3DDISPLAYMODE,std::allocator<_D3DDISPLAYMODE> >
_TEXT	ENDS
PUBLIC	??$_Uninit_fill_n@PAPAUD3DDEVICEINFO_T@Ogre@@IPAU12@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@YAXPAPAUD3DDEVICEINFO_T@Ogre@@IABQAU12@AAV?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<Ogre::D3DDEVICEINFO_T * *,unsigned int,Ogre::D3DDEVICEINFO_T *,std::allocator<Ogre::D3DDEVICEINFO_T *> >
PUBLIC	??$_Ptr_cat@PAPAUD3DDEVICEINFO_T@Ogre@@PAPAU12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAUD3DDEVICEINFO_T@Ogre@@0@Z ; std::_Ptr_cat<Ogre::D3DDEVICEINFO_T * *,Ogre::D3DDEVICEINFO_T * *>
; Function compile flags: /Odtp
;	COMDAT ??$unchecked_uninitialized_fill_n@PAPAUD3DDEVICEINFO_T@Ogre@@IPAU12@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@stdext@@YAXPAPAUD3DDEVICEINFO_T@Ogre@@IABQAU12@AAV?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@Z
_TEXT	SEGMENT
$T143158 = -2						; size = 1
$T143157 = -1						; size = 1
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_fill_n@PAPAUD3DDEVICEINFO_T@Ogre@@IPAU12@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@stdext@@YAXPAPAUD3DDEVICEINFO_T@Ogre@@IABQAU12@AAV?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@Z PROC ; stdext::unchecked_uninitialized_fill_n<Ogre::D3DDEVICEINFO_T * *,unsigned int,Ogre::D3DDEVICEINFO_T *,std::allocator<Ogre::D3DDEVICEINFO_T *> >, COMDAT

; 940  : 	{	// copy _Count *_Val to raw _First, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 941  : 	_STD _Uninit_fill_n(_First, _Count, _Val, _Al,
; 942  : 		_STD _Ptr_cat(_First, _First), _STD _Range_checked_iterator_tag());

	xor	eax, eax
	mov	BYTE PTR $T143157[ebp], al
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAPAUD3DDEVICEINFO_T@Ogre@@PAPAU12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAUD3DDEVICEINFO_T@Ogre@@0@Z ; std::_Ptr_cat<Ogre::D3DDEVICEINFO_T * *,Ogre::D3DDEVICEINFO_T * *>
	add	esp, 8
	mov	BYTE PTR $T143158[ebp], al
	movzx	eax, BYTE PTR $T143157[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T143158[ebp]
	push	ecx
	mov	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Uninit_fill_n@PAPAUD3DDEVICEINFO_T@Ogre@@IPAU12@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@YAXPAPAUD3DDEVICEINFO_T@Ogre@@IABQAU12@AAV?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<Ogre::D3DDEVICEINFO_T * *,unsigned int,Ogre::D3DDEVICEINFO_T *,std::allocator<Ogre::D3DDEVICEINFO_T *> >
	add	esp, 24					; 00000018H

; 943  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_fill_n@PAPAUD3DDEVICEINFO_T@Ogre@@IPAU12@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@stdext@@YAXPAPAUD3DDEVICEINFO_T@Ogre@@IABQAU12@AAV?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_fill_n<Ogre::D3DDEVICEINFO_T * *,unsigned int,Ogre::D3DDEVICEINFO_T *,std::allocator<Ogre::D3DDEVICEINFO_T *> >
_TEXT	ENDS
PUBLIC	??$_Uninit_fill_n@PAPAUD3DADAPTER_T@Ogre@@IPAU12@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@YAXPAPAUD3DADAPTER_T@Ogre@@IABQAU12@AAV?$allocator@PAUD3DADAPTER_T@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<Ogre::D3DADAPTER_T * *,unsigned int,Ogre::D3DADAPTER_T *,std::allocator<Ogre::D3DADAPTER_T *> >
PUBLIC	??$_Ptr_cat@PAPAUD3DADAPTER_T@Ogre@@PAPAU12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAUD3DADAPTER_T@Ogre@@0@Z ; std::_Ptr_cat<Ogre::D3DADAPTER_T * *,Ogre::D3DADAPTER_T * *>
; Function compile flags: /Odtp
;	COMDAT ??$unchecked_uninitialized_fill_n@PAPAUD3DADAPTER_T@Ogre@@IPAU12@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@stdext@@YAXPAPAUD3DADAPTER_T@Ogre@@IABQAU12@AAV?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@Z
_TEXT	SEGMENT
$T143162 = -2						; size = 1
$T143161 = -1						; size = 1
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_fill_n@PAPAUD3DADAPTER_T@Ogre@@IPAU12@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@stdext@@YAXPAPAUD3DADAPTER_T@Ogre@@IABQAU12@AAV?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@Z PROC ; stdext::unchecked_uninitialized_fill_n<Ogre::D3DADAPTER_T * *,unsigned int,Ogre::D3DADAPTER_T *,std::allocator<Ogre::D3DADAPTER_T *> >, COMDAT

; 940  : 	{	// copy _Count *_Val to raw _First, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 941  : 	_STD _Uninit_fill_n(_First, _Count, _Val, _Al,
; 942  : 		_STD _Ptr_cat(_First, _First), _STD _Range_checked_iterator_tag());

	xor	eax, eax
	mov	BYTE PTR $T143161[ebp], al
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAPAUD3DADAPTER_T@Ogre@@PAPAU12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAUD3DADAPTER_T@Ogre@@0@Z ; std::_Ptr_cat<Ogre::D3DADAPTER_T * *,Ogre::D3DADAPTER_T * *>
	add	esp, 8
	mov	BYTE PTR $T143162[ebp], al
	movzx	eax, BYTE PTR $T143161[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T143162[ebp]
	push	ecx
	mov	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Uninit_fill_n@PAPAUD3DADAPTER_T@Ogre@@IPAU12@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@YAXPAPAUD3DADAPTER_T@Ogre@@IABQAU12@AAV?$allocator@PAUD3DADAPTER_T@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<Ogre::D3DADAPTER_T * *,unsigned int,Ogre::D3DADAPTER_T *,std::allocator<Ogre::D3DADAPTER_T *> >
	add	esp, 24					; 00000018H

; 943  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_fill_n@PAPAUD3DADAPTER_T@Ogre@@IPAU12@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@stdext@@YAXPAPAUD3DADAPTER_T@Ogre@@IABQAU12@AAV?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_fill_n<Ogre::D3DADAPTER_T * *,unsigned int,Ogre::D3DADAPTER_T *,std::allocator<Ogre::D3DADAPTER_T *> >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@W4_D3DFORMAT@@@std@@@std@@YAXPAW4_D3DFORMAT@@0AAV?$allocator@W4_D3DFORMAT@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<enum _D3DFORMAT> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@W4_D3DFORMAT@@@std@@@std@@YAXPAW4_D3DFORMAT@@0AAV?$allocator@W4_D3DFORMAT@@@0@@Z
_TEXT	SEGMENT
$T143165 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@W4_D3DFORMAT@@@std@@@std@@YAXPAW4_D3DFORMAT@@0AAV?$allocator@W4_D3DFORMAT@@@0@@Z PROC ; std::_Destroy_range<std::allocator<enum _D3DFORMAT> >, COMDAT

; 224  : 	{	// destroy [_First, _Last)

	push	ebp
	mov	ebp, esp
	push	ecx

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Ptr_cat@PAW4_D3DFORMAT@@PAW41@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAW4_D3DFORMAT@@0@Z ; std::_Ptr_cat<enum _D3DFORMAT *,enum _D3DFORMAT *>
	add	esp, 8
	mov	BYTE PTR $T143165[ebp], al
	movzx	edx, BYTE PTR $T143165[ebp]
	push	edx
	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Destroy_range@V?$allocator@W4_D3DFORMAT@@@std@@@std@@YAXPAW4_D3DFORMAT@@0AAV?$allocator@W4_D3DFORMAT@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<enum _D3DFORMAT> >
	add	esp, 16					; 00000010H

; 226  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Destroy_range@V?$allocator@W4_D3DFORMAT@@@std@@@std@@YAXPAW4_D3DFORMAT@@0AAV?$allocator@W4_D3DFORMAT@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<enum _D3DFORMAT> >
_TEXT	ENDS
PUBLIC	??$_Unchecked_uninitialized_move@PAW4_D3DFORMAT@@PAW41@V?$allocator@W4_D3DFORMAT@@@std@@@stdext@@YAPAW4_D3DFORMAT@@PAW41@00AAV?$allocator@W4_D3DFORMAT@@@std@@@Z ; stdext::_Unchecked_uninitialized_move<enum _D3DFORMAT *,enum _D3DFORMAT *,std::allocator<enum _D3DFORMAT> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??$_Umove@PAW4_D3DFORMAT@@@?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@IAEPAW4_D3DFORMAT@@PAW42@00@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Umove@PAW4_D3DFORMAT@@@?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@IAEPAW4_D3DFORMAT@@PAW42@00@Z PROC ; std::vector<enum _D3DFORMAT,std::allocator<enum _D3DFORMAT> >::_Umove<enum _D3DFORMAT *>, COMDAT
; _this$ = ecx

; 1145 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1146 : 		{	// move initializing [_First, _Last), using allocator
; 1147 : 		return (_STDEXT _Unchecked_uninitialized_move(_First, _Last,
; 1148 : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Unchecked_uninitialized_move@PAW4_D3DFORMAT@@PAW41@V?$allocator@W4_D3DFORMAT@@@std@@@stdext@@YAPAW4_D3DFORMAT@@PAW41@00AAV?$allocator@W4_D3DFORMAT@@@std@@@Z ; stdext::_Unchecked_uninitialized_move<enum _D3DFORMAT *,enum _D3DFORMAT *,std::allocator<enum _D3DFORMAT> >
	add	esp, 16					; 00000010H

; 1149 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??$_Umove@PAW4_D3DFORMAT@@@?$vector@W4_D3DFORMAT@@V?$allocator@W4_D3DFORMAT@@@std@@@std@@IAEPAW4_D3DFORMAT@@PAW42@00@Z ENDP ; std::vector<enum _D3DFORMAT,std::allocator<enum _D3DFORMAT> >::_Umove<enum _D3DFORMAT *>
_TEXT	ENDS
PUBLIC	??$_Fill@PAW4_D3DFORMAT@@W41@@std@@YAXPAW4_D3DFORMAT@@0ABW41@@Z ; std::_Fill<enum _D3DFORMAT *,enum _D3DFORMAT>
PUBLIC	??$_Checked_base@PAW4_D3DFORMAT@@@std@@YAPAW4_D3DFORMAT@@AAPAW41@@Z ; std::_Checked_base<enum _D3DFORMAT *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$fill@PAW4_D3DFORMAT@@W41@@std@@YAXPAW4_D3DFORMAT@@0ABW41@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$fill@PAW4_D3DFORMAT@@W41@@std@@YAXPAW4_D3DFORMAT@@0ABW41@@Z PROC ; std::fill<enum _D3DFORMAT *,enum _D3DFORMAT>, COMDAT

; 3186 : 	{	// copy _Val through [_First, _Last)

	push	ebp
	mov	ebp, esp

; 3187 : 	_Fill(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@PAW4_D3DFORMAT@@@std@@YAPAW4_D3DFORMAT@@AAPAW41@@Z ; std::_Checked_base<enum _D3DFORMAT *>
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@PAW4_D3DFORMAT@@@std@@YAPAW4_D3DFORMAT@@AAPAW41@@Z ; std::_Checked_base<enum _D3DFORMAT *>
	add	esp, 4
	push	eax
	call	??$_Fill@PAW4_D3DFORMAT@@W41@@std@@YAXPAW4_D3DFORMAT@@0ABW41@@Z ; std::_Fill<enum _D3DFORMAT *,enum _D3DFORMAT>
	add	esp, 12					; 0000000cH

; 3188 : 	}

	pop	ebp
	ret	0
??$fill@PAW4_D3DFORMAT@@W41@@std@@YAXPAW4_D3DFORMAT@@0ABW41@@Z ENDP ; std::fill<enum _D3DFORMAT *,enum _D3DFORMAT>
_TEXT	ENDS
PUBLIC	??$_Move_backward_opt@PAW4_D3DFORMAT@@PAW41@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAW4_D3DFORMAT@@PAW41@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Move_backward_opt<enum _D3DFORMAT *,enum _D3DFORMAT *,std::random_access_iterator_tag,std::_Undefined_move_tag>
PUBLIC	??$_Iter_random@PAW4_D3DFORMAT@@PAW41@@std@@YA?AUrandom_access_iterator_tag@0@ABQAW4_D3DFORMAT@@0@Z ; std::_Iter_random<enum _D3DFORMAT *,enum _D3DFORMAT *>
PUBLIC	??$_Move_cat@PAW4_D3DFORMAT@@@std@@YA?AU_Undefined_move_tag@0@ABQAW4_D3DFORMAT@@@Z ; std::_Move_cat<enum _D3DFORMAT *>
; Function compile flags: /Odtp
;	COMDAT ??$_Unchecked_move_backward@PAW4_D3DFORMAT@@PAW41@@stdext@@YAPAW4_D3DFORMAT@@PAW41@00@Z
_TEXT	SEGMENT
$T143174 = -3						; size = 1
$T143173 = -2						; size = 1
$T143172 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Unchecked_move_backward@PAW4_D3DFORMAT@@PAW41@@stdext@@YAPAW4_D3DFORMAT@@PAW41@00@Z PROC ; stdext::_Unchecked_move_backward<enum _D3DFORMAT *,enum _D3DFORMAT *>, COMDAT

; 3694 : 	{	// move [_First, _Last) backwards to [..., _Dest)

	push	ebp
	mov	ebp, esp
	push	ecx

; 3695 : 		return (_STD _Move_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3696 : 			_STD _Iter_random(_First, _Dest), _STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T143172[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	??$_Move_cat@PAW4_D3DFORMAT@@@std@@YA?AU_Undefined_move_tag@0@ABQAW4_D3DFORMAT@@@Z ; std::_Move_cat<enum _D3DFORMAT *>
	add	esp, 4
	mov	BYTE PTR $T143173[ebp], al
	movzx	edx, BYTE PTR $T143172[ebp]
	push	edx
	movzx	eax, BYTE PTR $T143173[ebp]
	push	eax
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	lea	eax, DWORD PTR $T143174[ebp]
	push	eax
	call	??$_Iter_random@PAW4_D3DFORMAT@@PAW41@@std@@YA?AUrandom_access_iterator_tag@0@ABQAW4_D3DFORMAT@@0@Z ; std::_Iter_random<enum _D3DFORMAT *,enum _D3DFORMAT *>
	add	esp, 12					; 0000000cH
	movzx	ecx, BYTE PTR [eax]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	call	??$_Checked_base@PAW4_D3DFORMAT@@@std@@YAPAW4_D3DFORMAT@@AAPAW41@@Z ; std::_Checked_base<enum _D3DFORMAT *>
	add	esp, 4
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Checked_base@PAW4_D3DFORMAT@@@std@@YAPAW4_D3DFORMAT@@AAPAW41@@Z ; std::_Checked_base<enum _D3DFORMAT *>
	add	esp, 4
	push	eax
	call	??$_Move_backward_opt@PAW4_D3DFORMAT@@PAW41@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAW4_D3DFORMAT@@PAW41@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Move_backward_opt<enum _D3DFORMAT *,enum _D3DFORMAT *,std::random_access_iterator_tag,std::_Undefined_move_tag>
	add	esp, 24					; 00000018H

; 3697 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Unchecked_move_backward@PAW4_D3DFORMAT@@PAW41@@stdext@@YAPAW4_D3DFORMAT@@PAW41@00@Z ENDP ; stdext::_Unchecked_move_backward<enum _D3DFORMAT *,enum _D3DFORMAT *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$?0W4_D3DFORMAT@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@W4_D3DFORMAT@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??$?0W4_D3DFORMAT@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@W4_D3DFORMAT@@@1@@Z PROC ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><enum _D3DFORMAT>, COMDAT
; _this$ = ecx

; 128  : 		allocator(const allocator<_Other>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0W4_D3DFORMAT@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@W4_D3DFORMAT@@@1@@Z ENDP ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><enum _D3DFORMAT>
_TEXT	ENDS
PUBLIC	__TI2?AVbad_alloc@std@@
PUBLIC	??0bad_alloc@std@@QAE@PBD@Z			; std::bad_alloc::bad_alloc
PUBLIC	??1bad_alloc@std@@UAE@XZ			; std::bad_alloc::~bad_alloc
PUBLIC	__CTA2?AVbad_alloc@std@@
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
;	COMDAT ??_R0?AVbad_alloc@std@@@8
_DATA	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_alloc@std@@
xdata$x	SEGMENT
__CTA2?AVbad_alloc@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI2?AVbad_alloc@std@@
xdata$x	SEGMENT
__TI2?AVbad_alloc@std@@ DD 00H
	DD	FLAT:??1bad_alloc@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVbad_alloc@std@@
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??$_Allocate@W4_D3DFORMAT@@@std@@YAPAW4_D3DFORMAT@@IPAW41@@Z
_TEXT	SEGMENT
$T143179 = -12						; size = 12
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@W4_D3DFORMAT@@@std@@YAPAW4_D3DFORMAT@@IPAW41@@Z PROC ; std::_Allocate<enum _D3DFORMAT>, COMDAT

; 36   : 	{	// check for integer overflow

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 37   : 	if (_Count <= 0)

	cmp	DWORD PTR __Count$[ebp], 0
	ja	SHORT $LN3@Allocate

; 38   : 		_Count = 0;

	mov	DWORD PTR __Count$[ebp], 0
	jmp	SHORT $LN2@Allocate
$LN3@Allocate:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Count$[ebp]
	cmp	eax, 4
	jae	SHORT $LN2@Allocate

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	push	0
	lea	ecx, DWORD PTR $T143179[ebp]
	call	??0bad_alloc@std@@QAE@PBD@Z		; std::bad_alloc::bad_alloc
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	eax, DWORD PTR $T143179[ebp]
	push	eax
	call	__CxxThrowException@8
$LN2@Allocate:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 2
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
$LN5@Allocate:

; 44   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@W4_D3DFORMAT@@@std@@YAPAW4_D3DFORMAT@@IPAW41@@Z ENDP ; std::_Allocate<enum _D3DFORMAT>
_TEXT	ENDS
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	__imp_??0exception@std@@QAE@ABQBD@Z:PROC
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	?what@exception@std@@UBEPBDXZ:PROC		; std::exception::what
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0bad_alloc@std@@QAE@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0bad_alloc@std@@QAE@PBD@Z$0
__ehfuncinfo$??0bad_alloc@std@@QAE@PBD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0bad_alloc@std@@QAE@PBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@PBD@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Message$ = 8						; size = 4
??0bad_alloc@std@@QAE@PBD@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx

; 371  : 		{	// construct from message string

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0bad_alloc@std@@QAE@PBD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	lea	eax, DWORD PTR __Message$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7bad_alloc@std@@6B@

; 372  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0bad_alloc@std@@QAE@PBD@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??0bad_alloc@std@@QAE@PBD@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0bad_alloc@std@@QAE@PBD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0bad_alloc@std@@QAE@PBD@Z ENDP			; std::bad_alloc::bad_alloc
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1bad_alloc@std@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1bad_alloc@std@@UAE@XZ$0
__ehfuncinfo$??1bad_alloc@std@@UAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1bad_alloc@std@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1bad_alloc@std@@UAE@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
; _this$ = ecx

; 380  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1bad_alloc@std@@UAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 381  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1bad_alloc@std@@UAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??1bad_alloc@std@@UAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1bad_alloc@std@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1bad_alloc@std@@UAE@XZ ENDP				; std::bad_alloc::~bad_alloc
; Function compile flags: /Odtp
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1bad_alloc@std@@UAE@XZ		; std::bad_alloc::~bad_alloc
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@6
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@6:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@YAXPAW4_D3DMULTISAMPLE_TYPE@@0AAV?$allocator@W4_D3DMULTISAMPLE_TYPE@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<enum _D3DMULTISAMPLE_TYPE> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@YAXPAW4_D3DMULTISAMPLE_TYPE@@0AAV?$allocator@W4_D3DMULTISAMPLE_TYPE@@@0@@Z
_TEXT	SEGMENT
$T143202 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@YAXPAW4_D3DMULTISAMPLE_TYPE@@0AAV?$allocator@W4_D3DMULTISAMPLE_TYPE@@@0@@Z PROC ; std::_Destroy_range<std::allocator<enum _D3DMULTISAMPLE_TYPE> >, COMDAT

; 224  : 	{	// destroy [_First, _Last)

	push	ebp
	mov	ebp, esp
	push	ecx

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Ptr_cat@PAW4_D3DMULTISAMPLE_TYPE@@PAW41@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAW4_D3DMULTISAMPLE_TYPE@@0@Z ; std::_Ptr_cat<enum _D3DMULTISAMPLE_TYPE *,enum _D3DMULTISAMPLE_TYPE *>
	add	esp, 8
	mov	BYTE PTR $T143202[ebp], al
	movzx	edx, BYTE PTR $T143202[ebp]
	push	edx
	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Destroy_range@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@YAXPAW4_D3DMULTISAMPLE_TYPE@@0AAV?$allocator@W4_D3DMULTISAMPLE_TYPE@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<enum _D3DMULTISAMPLE_TYPE> >
	add	esp, 16					; 00000010H

; 226  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Destroy_range@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@YAXPAW4_D3DMULTISAMPLE_TYPE@@0AAV?$allocator@W4_D3DMULTISAMPLE_TYPE@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<enum _D3DMULTISAMPLE_TYPE> >
_TEXT	ENDS
PUBLIC	??$_Unchecked_uninitialized_move@PAW4_D3DMULTISAMPLE_TYPE@@PAW41@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@stdext@@YAPAW4_D3DMULTISAMPLE_TYPE@@PAW41@00AAV?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@Z ; stdext::_Unchecked_uninitialized_move<enum _D3DMULTISAMPLE_TYPE *,enum _D3DMULTISAMPLE_TYPE *,std::allocator<enum _D3DMULTISAMPLE_TYPE> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??$_Umove@PAW4_D3DMULTISAMPLE_TYPE@@@?$vector@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@IAEPAW4_D3DMULTISAMPLE_TYPE@@PAW42@00@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Umove@PAW4_D3DMULTISAMPLE_TYPE@@@?$vector@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@IAEPAW4_D3DMULTISAMPLE_TYPE@@PAW42@00@Z PROC ; std::vector<enum _D3DMULTISAMPLE_TYPE,std::allocator<enum _D3DMULTISAMPLE_TYPE> >::_Umove<enum _D3DMULTISAMPLE_TYPE *>, COMDAT
; _this$ = ecx

; 1145 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1146 : 		{	// move initializing [_First, _Last), using allocator
; 1147 : 		return (_STDEXT _Unchecked_uninitialized_move(_First, _Last,
; 1148 : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Unchecked_uninitialized_move@PAW4_D3DMULTISAMPLE_TYPE@@PAW41@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@stdext@@YAPAW4_D3DMULTISAMPLE_TYPE@@PAW41@00AAV?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@Z ; stdext::_Unchecked_uninitialized_move<enum _D3DMULTISAMPLE_TYPE *,enum _D3DMULTISAMPLE_TYPE *,std::allocator<enum _D3DMULTISAMPLE_TYPE> >
	add	esp, 16					; 00000010H

; 1149 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??$_Umove@PAW4_D3DMULTISAMPLE_TYPE@@@?$vector@W4_D3DMULTISAMPLE_TYPE@@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@IAEPAW4_D3DMULTISAMPLE_TYPE@@PAW42@00@Z ENDP ; std::vector<enum _D3DMULTISAMPLE_TYPE,std::allocator<enum _D3DMULTISAMPLE_TYPE> >::_Umove<enum _D3DMULTISAMPLE_TYPE *>
_TEXT	ENDS
PUBLIC	??$_Fill@PAW4_D3DMULTISAMPLE_TYPE@@W41@@std@@YAXPAW4_D3DMULTISAMPLE_TYPE@@0ABW41@@Z ; std::_Fill<enum _D3DMULTISAMPLE_TYPE *,enum _D3DMULTISAMPLE_TYPE>
PUBLIC	??$_Checked_base@PAW4_D3DMULTISAMPLE_TYPE@@@std@@YAPAW4_D3DMULTISAMPLE_TYPE@@AAPAW41@@Z ; std::_Checked_base<enum _D3DMULTISAMPLE_TYPE *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$fill@PAW4_D3DMULTISAMPLE_TYPE@@W41@@std@@YAXPAW4_D3DMULTISAMPLE_TYPE@@0ABW41@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$fill@PAW4_D3DMULTISAMPLE_TYPE@@W41@@std@@YAXPAW4_D3DMULTISAMPLE_TYPE@@0ABW41@@Z PROC ; std::fill<enum _D3DMULTISAMPLE_TYPE *,enum _D3DMULTISAMPLE_TYPE>, COMDAT

; 3186 : 	{	// copy _Val through [_First, _Last)

	push	ebp
	mov	ebp, esp

; 3187 : 	_Fill(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@PAW4_D3DMULTISAMPLE_TYPE@@@std@@YAPAW4_D3DMULTISAMPLE_TYPE@@AAPAW41@@Z ; std::_Checked_base<enum _D3DMULTISAMPLE_TYPE *>
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@PAW4_D3DMULTISAMPLE_TYPE@@@std@@YAPAW4_D3DMULTISAMPLE_TYPE@@AAPAW41@@Z ; std::_Checked_base<enum _D3DMULTISAMPLE_TYPE *>
	add	esp, 4
	push	eax
	call	??$_Fill@PAW4_D3DMULTISAMPLE_TYPE@@W41@@std@@YAXPAW4_D3DMULTISAMPLE_TYPE@@0ABW41@@Z ; std::_Fill<enum _D3DMULTISAMPLE_TYPE *,enum _D3DMULTISAMPLE_TYPE>
	add	esp, 12					; 0000000cH

; 3188 : 	}

	pop	ebp
	ret	0
??$fill@PAW4_D3DMULTISAMPLE_TYPE@@W41@@std@@YAXPAW4_D3DMULTISAMPLE_TYPE@@0ABW41@@Z ENDP ; std::fill<enum _D3DMULTISAMPLE_TYPE *,enum _D3DMULTISAMPLE_TYPE>
_TEXT	ENDS
PUBLIC	??$_Move_backward_opt@PAW4_D3DMULTISAMPLE_TYPE@@PAW41@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAW4_D3DMULTISAMPLE_TYPE@@PAW41@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Move_backward_opt<enum _D3DMULTISAMPLE_TYPE *,enum _D3DMULTISAMPLE_TYPE *,std::random_access_iterator_tag,std::_Undefined_move_tag>
PUBLIC	??$_Iter_random@PAW4_D3DMULTISAMPLE_TYPE@@PAW41@@std@@YA?AUrandom_access_iterator_tag@0@ABQAW4_D3DMULTISAMPLE_TYPE@@0@Z ; std::_Iter_random<enum _D3DMULTISAMPLE_TYPE *,enum _D3DMULTISAMPLE_TYPE *>
PUBLIC	??$_Move_cat@PAW4_D3DMULTISAMPLE_TYPE@@@std@@YA?AU_Undefined_move_tag@0@ABQAW4_D3DMULTISAMPLE_TYPE@@@Z ; std::_Move_cat<enum _D3DMULTISAMPLE_TYPE *>
; Function compile flags: /Odtp
;	COMDAT ??$_Unchecked_move_backward@PAW4_D3DMULTISAMPLE_TYPE@@PAW41@@stdext@@YAPAW4_D3DMULTISAMPLE_TYPE@@PAW41@00@Z
_TEXT	SEGMENT
$T143211 = -3						; size = 1
$T143210 = -2						; size = 1
$T143209 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Unchecked_move_backward@PAW4_D3DMULTISAMPLE_TYPE@@PAW41@@stdext@@YAPAW4_D3DMULTISAMPLE_TYPE@@PAW41@00@Z PROC ; stdext::_Unchecked_move_backward<enum _D3DMULTISAMPLE_TYPE *,enum _D3DMULTISAMPLE_TYPE *>, COMDAT

; 3694 : 	{	// move [_First, _Last) backwards to [..., _Dest)

	push	ebp
	mov	ebp, esp
	push	ecx

; 3695 : 		return (_STD _Move_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3696 : 			_STD _Iter_random(_First, _Dest), _STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T143209[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	??$_Move_cat@PAW4_D3DMULTISAMPLE_TYPE@@@std@@YA?AU_Undefined_move_tag@0@ABQAW4_D3DMULTISAMPLE_TYPE@@@Z ; std::_Move_cat<enum _D3DMULTISAMPLE_TYPE *>
	add	esp, 4
	mov	BYTE PTR $T143210[ebp], al
	movzx	edx, BYTE PTR $T143209[ebp]
	push	edx
	movzx	eax, BYTE PTR $T143210[ebp]
	push	eax
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	lea	eax, DWORD PTR $T143211[ebp]
	push	eax
	call	??$_Iter_random@PAW4_D3DMULTISAMPLE_TYPE@@PAW41@@std@@YA?AUrandom_access_iterator_tag@0@ABQAW4_D3DMULTISAMPLE_TYPE@@0@Z ; std::_Iter_random<enum _D3DMULTISAMPLE_TYPE *,enum _D3DMULTISAMPLE_TYPE *>
	add	esp, 12					; 0000000cH
	movzx	ecx, BYTE PTR [eax]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	call	??$_Checked_base@PAW4_D3DMULTISAMPLE_TYPE@@@std@@YAPAW4_D3DMULTISAMPLE_TYPE@@AAPAW41@@Z ; std::_Checked_base<enum _D3DMULTISAMPLE_TYPE *>
	add	esp, 4
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Checked_base@PAW4_D3DMULTISAMPLE_TYPE@@@std@@YAPAW4_D3DMULTISAMPLE_TYPE@@AAPAW41@@Z ; std::_Checked_base<enum _D3DMULTISAMPLE_TYPE *>
	add	esp, 4
	push	eax
	call	??$_Move_backward_opt@PAW4_D3DMULTISAMPLE_TYPE@@PAW41@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAW4_D3DMULTISAMPLE_TYPE@@PAW41@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Move_backward_opt<enum _D3DMULTISAMPLE_TYPE *,enum _D3DMULTISAMPLE_TYPE *,std::random_access_iterator_tag,std::_Undefined_move_tag>
	add	esp, 24					; 00000018H

; 3697 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Unchecked_move_backward@PAW4_D3DMULTISAMPLE_TYPE@@PAW41@@stdext@@YAPAW4_D3DMULTISAMPLE_TYPE@@PAW41@00@Z ENDP ; stdext::_Unchecked_move_backward<enum _D3DMULTISAMPLE_TYPE *,enum _D3DMULTISAMPLE_TYPE *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$?0W4_D3DMULTISAMPLE_TYPE@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@W4_D3DMULTISAMPLE_TYPE@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??$?0W4_D3DMULTISAMPLE_TYPE@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@W4_D3DMULTISAMPLE_TYPE@@@1@@Z PROC ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><enum _D3DMULTISAMPLE_TYPE>, COMDAT
; _this$ = ecx

; 128  : 		allocator(const allocator<_Other>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0W4_D3DMULTISAMPLE_TYPE@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@W4_D3DMULTISAMPLE_TYPE@@@1@@Z ENDP ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><enum _D3DMULTISAMPLE_TYPE>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Allocate@W4_D3DMULTISAMPLE_TYPE@@@std@@YAPAW4_D3DMULTISAMPLE_TYPE@@IPAW41@@Z
_TEXT	SEGMENT
$T143216 = -12						; size = 12
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@W4_D3DMULTISAMPLE_TYPE@@@std@@YAPAW4_D3DMULTISAMPLE_TYPE@@IPAW41@@Z PROC ; std::_Allocate<enum _D3DMULTISAMPLE_TYPE>, COMDAT

; 36   : 	{	// check for integer overflow

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 37   : 	if (_Count <= 0)

	cmp	DWORD PTR __Count$[ebp], 0
	ja	SHORT $LN3@Allocate@2

; 38   : 		_Count = 0;

	mov	DWORD PTR __Count$[ebp], 0
	jmp	SHORT $LN2@Allocate@2
$LN3@Allocate@2:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Count$[ebp]
	cmp	eax, 4
	jae	SHORT $LN2@Allocate@2

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	push	0
	lea	ecx, DWORD PTR $T143216[ebp]
	call	??0bad_alloc@std@@QAE@PBD@Z		; std::bad_alloc::bad_alloc
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	eax, DWORD PTR $T143216[ebp]
	push	eax
	call	__CxxThrowException@8
$LN2@Allocate@2:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 2
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
$LN5@Allocate@2:

; 44   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@W4_D3DMULTISAMPLE_TYPE@@@std@@YAPAW4_D3DMULTISAMPLE_TYPE@@IPAW41@@Z ENDP ; std::_Allocate<enum _D3DMULTISAMPLE_TYPE>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@I@std@@@std@@YAXPAI0AAV?$allocator@I@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<unsigned int> >
; Function compile flags: /Odtp
;	COMDAT ??$_Destroy_range@V?$allocator@I@std@@@std@@YAXPAI0AAV?$allocator@I@0@@Z
_TEXT	SEGMENT
$T143219 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@I@std@@@std@@YAXPAI0AAV?$allocator@I@0@@Z PROC ; std::_Destroy_range<std::allocator<unsigned int> >, COMDAT

; 224  : 	{	// destroy [_First, _Last)

	push	ebp
	mov	ebp, esp
	push	ecx

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Ptr_cat@PAIPAI@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAI0@Z ; std::_Ptr_cat<unsigned int *,unsigned int *>
	add	esp, 8
	mov	BYTE PTR $T143219[ebp], al
	movzx	edx, BYTE PTR $T143219[ebp]
	push	edx
	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Destroy_range@V?$allocator@I@std@@@std@@YAXPAI0AAV?$allocator@I@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<unsigned int> >
	add	esp, 16					; 00000010H

; 226  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Destroy_range@V?$allocator@I@std@@@std@@YAXPAI0AAV?$allocator@I@0@@Z ENDP ; std::_Destroy_range<std::allocator<unsigned int> >
_TEXT	ENDS
PUBLIC	??$_Unchecked_uninitialized_move@PAIPAIV?$allocator@I@std@@@stdext@@YAPAIPAI00AAV?$allocator@I@std@@@Z ; stdext::_Unchecked_uninitialized_move<unsigned int *,unsigned int *,std::allocator<unsigned int> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??$_Umove@PAI@?$vector@IV?$allocator@I@std@@@std@@IAEPAIPAI00@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Umove@PAI@?$vector@IV?$allocator@I@std@@@std@@IAEPAIPAI00@Z PROC ; std::vector<unsigned int,std::allocator<unsigned int> >::_Umove<unsigned int *>, COMDAT
; _this$ = ecx

; 1145 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1146 : 		{	// move initializing [_First, _Last), using allocator
; 1147 : 		return (_STDEXT _Unchecked_uninitialized_move(_First, _Last,
; 1148 : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Unchecked_uninitialized_move@PAIPAIV?$allocator@I@std@@@stdext@@YAPAIPAI00AAV?$allocator@I@std@@@Z ; stdext::_Unchecked_uninitialized_move<unsigned int *,unsigned int *,std::allocator<unsigned int> >
	add	esp, 16					; 00000010H

; 1149 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??$_Umove@PAI@?$vector@IV?$allocator@I@std@@@std@@IAEPAIPAI00@Z ENDP ; std::vector<unsigned int,std::allocator<unsigned int> >::_Umove<unsigned int *>
_TEXT	ENDS
PUBLIC	??$_Fill@PAII@std@@YAXPAI0ABI@Z			; std::_Fill<unsigned int *,unsigned int>
PUBLIC	??$_Checked_base@PAI@std@@YAPAIAAPAI@Z		; std::_Checked_base<unsigned int *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$fill@PAII@std@@YAXPAI0ABI@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$fill@PAII@std@@YAXPAI0ABI@Z PROC			; std::fill<unsigned int *,unsigned int>, COMDAT

; 3186 : 	{	// copy _Val through [_First, _Last)

	push	ebp
	mov	ebp, esp

; 3187 : 	_Fill(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@PAI@std@@YAPAIAAPAI@Z	; std::_Checked_base<unsigned int *>
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@PAI@std@@YAPAIAAPAI@Z	; std::_Checked_base<unsigned int *>
	add	esp, 4
	push	eax
	call	??$_Fill@PAII@std@@YAXPAI0ABI@Z		; std::_Fill<unsigned int *,unsigned int>
	add	esp, 12					; 0000000cH

; 3188 : 	}

	pop	ebp
	ret	0
??$fill@PAII@std@@YAXPAI0ABI@Z ENDP			; std::fill<unsigned int *,unsigned int>
_TEXT	ENDS
PUBLIC	??$_Move_backward_opt@PAIPAIUrandom_access_iterator_tag@std@@U_Undefined_move_tag@2@@std@@YAPAIPAI00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Move_backward_opt<unsigned int *,unsigned int *,std::random_access_iterator_tag,std::_Undefined_move_tag>
PUBLIC	??$_Iter_random@PAIPAI@std@@YA?AUrandom_access_iterator_tag@0@ABQAI0@Z ; std::_Iter_random<unsigned int *,unsigned int *>
PUBLIC	??$_Move_cat@PAI@std@@YA?AU_Undefined_move_tag@0@ABQAI@Z ; std::_Move_cat<unsigned int *>
; Function compile flags: /Odtp
;	COMDAT ??$_Unchecked_move_backward@PAIPAI@stdext@@YAPAIPAI00@Z
_TEXT	SEGMENT
$T143228 = -3						; size = 1
$T143227 = -2						; size = 1
$T143226 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Unchecked_move_backward@PAIPAI@stdext@@YAPAIPAI00@Z PROC ; stdext::_Unchecked_move_backward<unsigned int *,unsigned int *>, COMDAT

; 3694 : 	{	// move [_First, _Last) backwards to [..., _Dest)

	push	ebp
	mov	ebp, esp
	push	ecx

; 3695 : 		return (_STD _Move_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3696 : 			_STD _Iter_random(_First, _Dest), _STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T143226[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	??$_Move_cat@PAI@std@@YA?AU_Undefined_move_tag@0@ABQAI@Z ; std::_Move_cat<unsigned int *>
	add	esp, 4
	mov	BYTE PTR $T143227[ebp], al
	movzx	edx, BYTE PTR $T143226[ebp]
	push	edx
	movzx	eax, BYTE PTR $T143227[ebp]
	push	eax
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	lea	eax, DWORD PTR $T143228[ebp]
	push	eax
	call	??$_Iter_random@PAIPAI@std@@YA?AUrandom_access_iterator_tag@0@ABQAI0@Z ; std::_Iter_random<unsigned int *,unsigned int *>
	add	esp, 12					; 0000000cH
	movzx	ecx, BYTE PTR [eax]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	call	??$_Checked_base@PAI@std@@YAPAIAAPAI@Z	; std::_Checked_base<unsigned int *>
	add	esp, 4
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Checked_base@PAI@std@@YAPAIAAPAI@Z	; std::_Checked_base<unsigned int *>
	add	esp, 4
	push	eax
	call	??$_Move_backward_opt@PAIPAIUrandom_access_iterator_tag@std@@U_Undefined_move_tag@2@@std@@YAPAIPAI00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Move_backward_opt<unsigned int *,unsigned int *,std::random_access_iterator_tag,std::_Undefined_move_tag>
	add	esp, 24					; 00000018H

; 3697 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Unchecked_move_backward@PAIPAI@stdext@@YAPAIPAI00@Z ENDP ; stdext::_Unchecked_move_backward<unsigned int *,unsigned int *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$?0I@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@I@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??$?0I@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@I@1@@Z PROC ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><unsigned int>, COMDAT
; _this$ = ecx

; 128  : 		allocator(const allocator<_Other>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0I@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@I@1@@Z ENDP ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><unsigned int>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Allocate@I@std@@YAPAIIPAI@Z
_TEXT	SEGMENT
$T143233 = -12						; size = 12
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@I@std@@YAPAIIPAI@Z PROC			; std::_Allocate<unsigned int>, COMDAT

; 36   : 	{	// check for integer overflow

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 37   : 	if (_Count <= 0)

	cmp	DWORD PTR __Count$[ebp], 0
	ja	SHORT $LN3@Allocate@3

; 38   : 		_Count = 0;

	mov	DWORD PTR __Count$[ebp], 0
	jmp	SHORT $LN2@Allocate@3
$LN3@Allocate@3:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Count$[ebp]
	cmp	eax, 4
	jae	SHORT $LN2@Allocate@3

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	push	0
	lea	ecx, DWORD PTR $T143233[ebp]
	call	??0bad_alloc@std@@QAE@PBD@Z		; std::bad_alloc::bad_alloc
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	eax, DWORD PTR $T143233[ebp]
	push	eax
	call	__CxxThrowException@8
$LN2@Allocate@3:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 2
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
$LN5@Allocate@3:

; 44   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@I@std@@YAPAIIPAI@Z ENDP			; std::_Allocate<unsigned int>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@YAXPAUD3DSMSCONFLICT_T@Ogre@@0AAV?$allocator@UD3DSMSCONFLICT_T@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<Ogre::D3DSMSCONFLICT_T> >
; Function compile flags: /Odtp
;	COMDAT ??$_Destroy_range@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@YAXPAUD3DSMSCONFLICT_T@Ogre@@0AAV?$allocator@UD3DSMSCONFLICT_T@Ogre@@@0@@Z
_TEXT	SEGMENT
$T143236 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@YAXPAUD3DSMSCONFLICT_T@Ogre@@0AAV?$allocator@UD3DSMSCONFLICT_T@Ogre@@@0@@Z PROC ; std::_Destroy_range<std::allocator<Ogre::D3DSMSCONFLICT_T> >, COMDAT

; 224  : 	{	// destroy [_First, _Last)

	push	ebp
	mov	ebp, esp
	push	ecx

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Ptr_cat@PAUD3DSMSCONFLICT_T@Ogre@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUD3DSMSCONFLICT_T@Ogre@@0@Z ; std::_Ptr_cat<Ogre::D3DSMSCONFLICT_T *,Ogre::D3DSMSCONFLICT_T *>
	add	esp, 8
	mov	BYTE PTR $T143236[ebp], al
	movzx	edx, BYTE PTR $T143236[ebp]
	push	edx
	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Destroy_range@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@YAXPAUD3DSMSCONFLICT_T@Ogre@@0AAV?$allocator@UD3DSMSCONFLICT_T@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<Ogre::D3DSMSCONFLICT_T> >
	add	esp, 16					; 00000010H

; 226  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Destroy_range@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@YAXPAUD3DSMSCONFLICT_T@Ogre@@0AAV?$allocator@UD3DSMSCONFLICT_T@Ogre@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<Ogre::D3DSMSCONFLICT_T> >
_TEXT	ENDS
PUBLIC	??$_Unchecked_uninitialized_move@PAUD3DSMSCONFLICT_T@Ogre@@PAU12@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@stdext@@YAPAUD3DSMSCONFLICT_T@Ogre@@PAU12@00AAV?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@Z ; stdext::_Unchecked_uninitialized_move<Ogre::D3DSMSCONFLICT_T *,Ogre::D3DSMSCONFLICT_T *,std::allocator<Ogre::D3DSMSCONFLICT_T> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??$_Umove@PAUD3DSMSCONFLICT_T@Ogre@@@?$vector@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@IAEPAUD3DSMSCONFLICT_T@Ogre@@PAU23@00@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Umove@PAUD3DSMSCONFLICT_T@Ogre@@@?$vector@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@IAEPAUD3DSMSCONFLICT_T@Ogre@@PAU23@00@Z PROC ; std::vector<Ogre::D3DSMSCONFLICT_T,std::allocator<Ogre::D3DSMSCONFLICT_T> >::_Umove<Ogre::D3DSMSCONFLICT_T *>, COMDAT
; _this$ = ecx

; 1145 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1146 : 		{	// move initializing [_First, _Last), using allocator
; 1147 : 		return (_STDEXT _Unchecked_uninitialized_move(_First, _Last,
; 1148 : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Unchecked_uninitialized_move@PAUD3DSMSCONFLICT_T@Ogre@@PAU12@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@stdext@@YAPAUD3DSMSCONFLICT_T@Ogre@@PAU12@00AAV?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@Z ; stdext::_Unchecked_uninitialized_move<Ogre::D3DSMSCONFLICT_T *,Ogre::D3DSMSCONFLICT_T *,std::allocator<Ogre::D3DSMSCONFLICT_T> >
	add	esp, 16					; 00000010H

; 1149 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??$_Umove@PAUD3DSMSCONFLICT_T@Ogre@@@?$vector@UD3DSMSCONFLICT_T@Ogre@@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@IAEPAUD3DSMSCONFLICT_T@Ogre@@PAU23@00@Z ENDP ; std::vector<Ogre::D3DSMSCONFLICT_T,std::allocator<Ogre::D3DSMSCONFLICT_T> >::_Umove<Ogre::D3DSMSCONFLICT_T *>
_TEXT	ENDS
PUBLIC	??$_Fill@PAUD3DSMSCONFLICT_T@Ogre@@U12@@std@@YAXPAUD3DSMSCONFLICT_T@Ogre@@0ABU12@@Z ; std::_Fill<Ogre::D3DSMSCONFLICT_T *,Ogre::D3DSMSCONFLICT_T>
PUBLIC	??$_Checked_base@PAUD3DSMSCONFLICT_T@Ogre@@@std@@YAPAUD3DSMSCONFLICT_T@Ogre@@AAPAU12@@Z ; std::_Checked_base<Ogre::D3DSMSCONFLICT_T *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$fill@PAUD3DSMSCONFLICT_T@Ogre@@U12@@std@@YAXPAUD3DSMSCONFLICT_T@Ogre@@0ABU12@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$fill@PAUD3DSMSCONFLICT_T@Ogre@@U12@@std@@YAXPAUD3DSMSCONFLICT_T@Ogre@@0ABU12@@Z PROC ; std::fill<Ogre::D3DSMSCONFLICT_T *,Ogre::D3DSMSCONFLICT_T>, COMDAT

; 3186 : 	{	// copy _Val through [_First, _Last)

	push	ebp
	mov	ebp, esp

; 3187 : 	_Fill(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@PAUD3DSMSCONFLICT_T@Ogre@@@std@@YAPAUD3DSMSCONFLICT_T@Ogre@@AAPAU12@@Z ; std::_Checked_base<Ogre::D3DSMSCONFLICT_T *>
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@PAUD3DSMSCONFLICT_T@Ogre@@@std@@YAPAUD3DSMSCONFLICT_T@Ogre@@AAPAU12@@Z ; std::_Checked_base<Ogre::D3DSMSCONFLICT_T *>
	add	esp, 4
	push	eax
	call	??$_Fill@PAUD3DSMSCONFLICT_T@Ogre@@U12@@std@@YAXPAUD3DSMSCONFLICT_T@Ogre@@0ABU12@@Z ; std::_Fill<Ogre::D3DSMSCONFLICT_T *,Ogre::D3DSMSCONFLICT_T>
	add	esp, 12					; 0000000cH

; 3188 : 	}

	pop	ebp
	ret	0
??$fill@PAUD3DSMSCONFLICT_T@Ogre@@U12@@std@@YAXPAUD3DSMSCONFLICT_T@Ogre@@0ABU12@@Z ENDP ; std::fill<Ogre::D3DSMSCONFLICT_T *,Ogre::D3DSMSCONFLICT_T>
_TEXT	ENDS
PUBLIC	??$_Move_backward_opt@PAUD3DSMSCONFLICT_T@Ogre@@PAU12@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@4@@std@@YAPAUD3DSMSCONFLICT_T@Ogre@@PAU12@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Move_backward_opt<Ogre::D3DSMSCONFLICT_T *,Ogre::D3DSMSCONFLICT_T *,std::random_access_iterator_tag,std::_Undefined_move_tag>
PUBLIC	??$_Iter_random@PAUD3DSMSCONFLICT_T@Ogre@@PAU12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUD3DSMSCONFLICT_T@Ogre@@0@Z ; std::_Iter_random<Ogre::D3DSMSCONFLICT_T *,Ogre::D3DSMSCONFLICT_T *>
PUBLIC	??$_Move_cat@PAUD3DSMSCONFLICT_T@Ogre@@@std@@YA?AU_Undefined_move_tag@0@ABQAUD3DSMSCONFLICT_T@Ogre@@@Z ; std::_Move_cat<Ogre::D3DSMSCONFLICT_T *>
; Function compile flags: /Odtp
;	COMDAT ??$_Unchecked_move_backward@PAUD3DSMSCONFLICT_T@Ogre@@PAU12@@stdext@@YAPAUD3DSMSCONFLICT_T@Ogre@@PAU12@00@Z
_TEXT	SEGMENT
$T143245 = -3						; size = 1
$T143244 = -2						; size = 1
$T143243 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Unchecked_move_backward@PAUD3DSMSCONFLICT_T@Ogre@@PAU12@@stdext@@YAPAUD3DSMSCONFLICT_T@Ogre@@PAU12@00@Z PROC ; stdext::_Unchecked_move_backward<Ogre::D3DSMSCONFLICT_T *,Ogre::D3DSMSCONFLICT_T *>, COMDAT

; 3694 : 	{	// move [_First, _Last) backwards to [..., _Dest)

	push	ebp
	mov	ebp, esp
	push	ecx

; 3695 : 		return (_STD _Move_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3696 : 			_STD _Iter_random(_First, _Dest), _STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T143243[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	??$_Move_cat@PAUD3DSMSCONFLICT_T@Ogre@@@std@@YA?AU_Undefined_move_tag@0@ABQAUD3DSMSCONFLICT_T@Ogre@@@Z ; std::_Move_cat<Ogre::D3DSMSCONFLICT_T *>
	add	esp, 4
	mov	BYTE PTR $T143244[ebp], al
	movzx	edx, BYTE PTR $T143243[ebp]
	push	edx
	movzx	eax, BYTE PTR $T143244[ebp]
	push	eax
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	lea	eax, DWORD PTR $T143245[ebp]
	push	eax
	call	??$_Iter_random@PAUD3DSMSCONFLICT_T@Ogre@@PAU12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUD3DSMSCONFLICT_T@Ogre@@0@Z ; std::_Iter_random<Ogre::D3DSMSCONFLICT_T *,Ogre::D3DSMSCONFLICT_T *>
	add	esp, 12					; 0000000cH
	movzx	ecx, BYTE PTR [eax]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	call	??$_Checked_base@PAUD3DSMSCONFLICT_T@Ogre@@@std@@YAPAUD3DSMSCONFLICT_T@Ogre@@AAPAU12@@Z ; std::_Checked_base<Ogre::D3DSMSCONFLICT_T *>
	add	esp, 4
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Checked_base@PAUD3DSMSCONFLICT_T@Ogre@@@std@@YAPAUD3DSMSCONFLICT_T@Ogre@@AAPAU12@@Z ; std::_Checked_base<Ogre::D3DSMSCONFLICT_T *>
	add	esp, 4
	push	eax
	call	??$_Move_backward_opt@PAUD3DSMSCONFLICT_T@Ogre@@PAU12@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@4@@std@@YAPAUD3DSMSCONFLICT_T@Ogre@@PAU12@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Move_backward_opt<Ogre::D3DSMSCONFLICT_T *,Ogre::D3DSMSCONFLICT_T *,std::random_access_iterator_tag,std::_Undefined_move_tag>
	add	esp, 24					; 00000018H

; 3697 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Unchecked_move_backward@PAUD3DSMSCONFLICT_T@Ogre@@PAU12@@stdext@@YAPAUD3DSMSCONFLICT_T@Ogre@@PAU12@00@Z ENDP ; stdext::_Unchecked_move_backward<Ogre::D3DSMSCONFLICT_T *,Ogre::D3DSMSCONFLICT_T *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$?0UD3DSMSCONFLICT_T@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@UD3DSMSCONFLICT_T@Ogre@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??$?0UD3DSMSCONFLICT_T@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@UD3DSMSCONFLICT_T@Ogre@@@1@@Z PROC ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::D3DSMSCONFLICT_T>, COMDAT
; _this$ = ecx

; 128  : 		allocator(const allocator<_Other>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0UD3DSMSCONFLICT_T@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@UD3DSMSCONFLICT_T@Ogre@@@1@@Z ENDP ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::D3DSMSCONFLICT_T>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Allocate@UD3DSMSCONFLICT_T@Ogre@@@std@@YAPAUD3DSMSCONFLICT_T@Ogre@@IPAU12@@Z
_TEXT	SEGMENT
$T143250 = -12						; size = 12
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@UD3DSMSCONFLICT_T@Ogre@@@std@@YAPAUD3DSMSCONFLICT_T@Ogre@@IPAU12@@Z PROC ; std::_Allocate<Ogre::D3DSMSCONFLICT_T>, COMDAT

; 36   : 	{	// check for integer overflow

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 37   : 	if (_Count <= 0)

	cmp	DWORD PTR __Count$[ebp], 0
	ja	SHORT $LN3@Allocate@4

; 38   : 		_Count = 0;

	mov	DWORD PTR __Count$[ebp], 0
	jmp	SHORT $LN2@Allocate@4
$LN3@Allocate@4:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Count$[ebp]
	cmp	eax, 8
	jae	SHORT $LN2@Allocate@4

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	push	0
	lea	ecx, DWORD PTR $T143250[ebp]
	call	??0bad_alloc@std@@QAE@PBD@Z		; std::bad_alloc::bad_alloc
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	eax, DWORD PTR $T143250[ebp]
	push	eax
	call	__CxxThrowException@8
$LN2@Allocate@4:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 3
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
$LN5@Allocate@4:

; 44   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@UD3DSMSCONFLICT_T@Ogre@@@std@@YAPAUD3DSMSCONFLICT_T@Ogre@@IPAU12@@Z ENDP ; std::_Allocate<Ogre::D3DSMSCONFLICT_T>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@YAXPAW4VERTPROCESS_T@Ogre@@0AAV?$allocator@W4VERTPROCESS_T@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<enum Ogre::VERTPROCESS_T> >
; Function compile flags: /Odtp
;	COMDAT ??$_Destroy_range@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@YAXPAW4VERTPROCESS_T@Ogre@@0AAV?$allocator@W4VERTPROCESS_T@Ogre@@@0@@Z
_TEXT	SEGMENT
$T143253 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@YAXPAW4VERTPROCESS_T@Ogre@@0AAV?$allocator@W4VERTPROCESS_T@Ogre@@@0@@Z PROC ; std::_Destroy_range<std::allocator<enum Ogre::VERTPROCESS_T> >, COMDAT

; 224  : 	{	// destroy [_First, _Last)

	push	ebp
	mov	ebp, esp
	push	ecx

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Ptr_cat@PAW4VERTPROCESS_T@Ogre@@PAW412@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAW4VERTPROCESS_T@Ogre@@0@Z ; std::_Ptr_cat<enum Ogre::VERTPROCESS_T *,enum Ogre::VERTPROCESS_T *>
	add	esp, 8
	mov	BYTE PTR $T143253[ebp], al
	movzx	edx, BYTE PTR $T143253[ebp]
	push	edx
	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Destroy_range@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@YAXPAW4VERTPROCESS_T@Ogre@@0AAV?$allocator@W4VERTPROCESS_T@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<enum Ogre::VERTPROCESS_T> >
	add	esp, 16					; 00000010H

; 226  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Destroy_range@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@YAXPAW4VERTPROCESS_T@Ogre@@0AAV?$allocator@W4VERTPROCESS_T@Ogre@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<enum Ogre::VERTPROCESS_T> >
_TEXT	ENDS
PUBLIC	??$_Unchecked_uninitialized_move@PAW4VERTPROCESS_T@Ogre@@PAW412@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@stdext@@YAPAW4VERTPROCESS_T@Ogre@@PAW412@00AAV?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@Z ; stdext::_Unchecked_uninitialized_move<enum Ogre::VERTPROCESS_T *,enum Ogre::VERTPROCESS_T *,std::allocator<enum Ogre::VERTPROCESS_T> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??$_Umove@PAW4VERTPROCESS_T@Ogre@@@?$vector@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@IAEPAW4VERTPROCESS_T@Ogre@@PAW423@00@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Umove@PAW4VERTPROCESS_T@Ogre@@@?$vector@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@IAEPAW4VERTPROCESS_T@Ogre@@PAW423@00@Z PROC ; std::vector<enum Ogre::VERTPROCESS_T,std::allocator<enum Ogre::VERTPROCESS_T> >::_Umove<enum Ogre::VERTPROCESS_T *>, COMDAT
; _this$ = ecx

; 1145 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1146 : 		{	// move initializing [_First, _Last), using allocator
; 1147 : 		return (_STDEXT _Unchecked_uninitialized_move(_First, _Last,
; 1148 : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Unchecked_uninitialized_move@PAW4VERTPROCESS_T@Ogre@@PAW412@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@stdext@@YAPAW4VERTPROCESS_T@Ogre@@PAW412@00AAV?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@Z ; stdext::_Unchecked_uninitialized_move<enum Ogre::VERTPROCESS_T *,enum Ogre::VERTPROCESS_T *,std::allocator<enum Ogre::VERTPROCESS_T> >
	add	esp, 16					; 00000010H

; 1149 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??$_Umove@PAW4VERTPROCESS_T@Ogre@@@?$vector@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@IAEPAW4VERTPROCESS_T@Ogre@@PAW423@00@Z ENDP ; std::vector<enum Ogre::VERTPROCESS_T,std::allocator<enum Ogre::VERTPROCESS_T> >::_Umove<enum Ogre::VERTPROCESS_T *>
_TEXT	ENDS
PUBLIC	??$_Fill@PAW4VERTPROCESS_T@Ogre@@W412@@std@@YAXPAW4VERTPROCESS_T@Ogre@@0ABW412@@Z ; std::_Fill<enum Ogre::VERTPROCESS_T *,enum Ogre::VERTPROCESS_T>
PUBLIC	??$_Checked_base@PAW4VERTPROCESS_T@Ogre@@@std@@YAPAW4VERTPROCESS_T@Ogre@@AAPAW412@@Z ; std::_Checked_base<enum Ogre::VERTPROCESS_T *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$fill@PAW4VERTPROCESS_T@Ogre@@W412@@std@@YAXPAW4VERTPROCESS_T@Ogre@@0ABW412@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$fill@PAW4VERTPROCESS_T@Ogre@@W412@@std@@YAXPAW4VERTPROCESS_T@Ogre@@0ABW412@@Z PROC ; std::fill<enum Ogre::VERTPROCESS_T *,enum Ogre::VERTPROCESS_T>, COMDAT

; 3186 : 	{	// copy _Val through [_First, _Last)

	push	ebp
	mov	ebp, esp

; 3187 : 	_Fill(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@PAW4VERTPROCESS_T@Ogre@@@std@@YAPAW4VERTPROCESS_T@Ogre@@AAPAW412@@Z ; std::_Checked_base<enum Ogre::VERTPROCESS_T *>
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@PAW4VERTPROCESS_T@Ogre@@@std@@YAPAW4VERTPROCESS_T@Ogre@@AAPAW412@@Z ; std::_Checked_base<enum Ogre::VERTPROCESS_T *>
	add	esp, 4
	push	eax
	call	??$_Fill@PAW4VERTPROCESS_T@Ogre@@W412@@std@@YAXPAW4VERTPROCESS_T@Ogre@@0ABW412@@Z ; std::_Fill<enum Ogre::VERTPROCESS_T *,enum Ogre::VERTPROCESS_T>
	add	esp, 12					; 0000000cH

; 3188 : 	}

	pop	ebp
	ret	0
??$fill@PAW4VERTPROCESS_T@Ogre@@W412@@std@@YAXPAW4VERTPROCESS_T@Ogre@@0ABW412@@Z ENDP ; std::fill<enum Ogre::VERTPROCESS_T *,enum Ogre::VERTPROCESS_T>
_TEXT	ENDS
PUBLIC	??$_Move_backward_opt@PAW4VERTPROCESS_T@Ogre@@PAW412@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@4@@std@@YAPAW4VERTPROCESS_T@Ogre@@PAW412@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Move_backward_opt<enum Ogre::VERTPROCESS_T *,enum Ogre::VERTPROCESS_T *,std::random_access_iterator_tag,std::_Undefined_move_tag>
PUBLIC	??$_Iter_random@PAW4VERTPROCESS_T@Ogre@@PAW412@@std@@YA?AUrandom_access_iterator_tag@0@ABQAW4VERTPROCESS_T@Ogre@@0@Z ; std::_Iter_random<enum Ogre::VERTPROCESS_T *,enum Ogre::VERTPROCESS_T *>
PUBLIC	??$_Move_cat@PAW4VERTPROCESS_T@Ogre@@@std@@YA?AU_Undefined_move_tag@0@ABQAW4VERTPROCESS_T@Ogre@@@Z ; std::_Move_cat<enum Ogre::VERTPROCESS_T *>
; Function compile flags: /Odtp
;	COMDAT ??$_Unchecked_move_backward@PAW4VERTPROCESS_T@Ogre@@PAW412@@stdext@@YAPAW4VERTPROCESS_T@Ogre@@PAW412@00@Z
_TEXT	SEGMENT
$T143262 = -3						; size = 1
$T143261 = -2						; size = 1
$T143260 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Unchecked_move_backward@PAW4VERTPROCESS_T@Ogre@@PAW412@@stdext@@YAPAW4VERTPROCESS_T@Ogre@@PAW412@00@Z PROC ; stdext::_Unchecked_move_backward<enum Ogre::VERTPROCESS_T *,enum Ogre::VERTPROCESS_T *>, COMDAT

; 3694 : 	{	// move [_First, _Last) backwards to [..., _Dest)

	push	ebp
	mov	ebp, esp
	push	ecx

; 3695 : 		return (_STD _Move_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3696 : 			_STD _Iter_random(_First, _Dest), _STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T143260[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	??$_Move_cat@PAW4VERTPROCESS_T@Ogre@@@std@@YA?AU_Undefined_move_tag@0@ABQAW4VERTPROCESS_T@Ogre@@@Z ; std::_Move_cat<enum Ogre::VERTPROCESS_T *>
	add	esp, 4
	mov	BYTE PTR $T143261[ebp], al
	movzx	edx, BYTE PTR $T143260[ebp]
	push	edx
	movzx	eax, BYTE PTR $T143261[ebp]
	push	eax
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	lea	eax, DWORD PTR $T143262[ebp]
	push	eax
	call	??$_Iter_random@PAW4VERTPROCESS_T@Ogre@@PAW412@@std@@YA?AUrandom_access_iterator_tag@0@ABQAW4VERTPROCESS_T@Ogre@@0@Z ; std::_Iter_random<enum Ogre::VERTPROCESS_T *,enum Ogre::VERTPROCESS_T *>
	add	esp, 12					; 0000000cH
	movzx	ecx, BYTE PTR [eax]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	call	??$_Checked_base@PAW4VERTPROCESS_T@Ogre@@@std@@YAPAW4VERTPROCESS_T@Ogre@@AAPAW412@@Z ; std::_Checked_base<enum Ogre::VERTPROCESS_T *>
	add	esp, 4
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Checked_base@PAW4VERTPROCESS_T@Ogre@@@std@@YAPAW4VERTPROCESS_T@Ogre@@AAPAW412@@Z ; std::_Checked_base<enum Ogre::VERTPROCESS_T *>
	add	esp, 4
	push	eax
	call	??$_Move_backward_opt@PAW4VERTPROCESS_T@Ogre@@PAW412@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@4@@std@@YAPAW4VERTPROCESS_T@Ogre@@PAW412@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Move_backward_opt<enum Ogre::VERTPROCESS_T *,enum Ogre::VERTPROCESS_T *,std::random_access_iterator_tag,std::_Undefined_move_tag>
	add	esp, 24					; 00000018H

; 3697 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Unchecked_move_backward@PAW4VERTPROCESS_T@Ogre@@PAW412@@stdext@@YAPAW4VERTPROCESS_T@Ogre@@PAW412@00@Z ENDP ; stdext::_Unchecked_move_backward<enum Ogre::VERTPROCESS_T *,enum Ogre::VERTPROCESS_T *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$?0W4VERTPROCESS_T@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@W4VERTPROCESS_T@Ogre@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??$?0W4VERTPROCESS_T@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@W4VERTPROCESS_T@Ogre@@@1@@Z PROC ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><enum Ogre::VERTPROCESS_T>, COMDAT
; _this$ = ecx

; 128  : 		allocator(const allocator<_Other>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0W4VERTPROCESS_T@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@W4VERTPROCESS_T@Ogre@@@1@@Z ENDP ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><enum Ogre::VERTPROCESS_T>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Allocate@W4VERTPROCESS_T@Ogre@@@std@@YAPAW4VERTPROCESS_T@Ogre@@IPAW412@@Z
_TEXT	SEGMENT
$T143267 = -12						; size = 12
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@W4VERTPROCESS_T@Ogre@@@std@@YAPAW4VERTPROCESS_T@Ogre@@IPAW412@@Z PROC ; std::_Allocate<enum Ogre::VERTPROCESS_T>, COMDAT

; 36   : 	{	// check for integer overflow

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 37   : 	if (_Count <= 0)

	cmp	DWORD PTR __Count$[ebp], 0
	ja	SHORT $LN3@Allocate@5

; 38   : 		_Count = 0;

	mov	DWORD PTR __Count$[ebp], 0
	jmp	SHORT $LN2@Allocate@5
$LN3@Allocate@5:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Count$[ebp]
	cmp	eax, 4
	jae	SHORT $LN2@Allocate@5

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	push	0
	lea	ecx, DWORD PTR $T143267[ebp]
	call	??0bad_alloc@std@@QAE@PBD@Z		; std::bad_alloc::bad_alloc
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	eax, DWORD PTR $T143267[ebp]
	push	eax
	call	__CxxThrowException@8
$LN2@Allocate@5:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 2
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
$LN5@Allocate@5:

; 44   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@W4VERTPROCESS_T@Ogre@@@std@@YAPAW4VERTPROCESS_T@Ogre@@IPAW412@@Z ENDP ; std::_Allocate<enum Ogre::VERTPROCESS_T>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@YAXPAPAUD3DDEVCOMBO_T@Ogre@@0AAV?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<Ogre::D3DDEVCOMBO_T *> >
; Function compile flags: /Odtp
;	COMDAT ??$_Destroy_range@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@YAXPAPAUD3DDEVCOMBO_T@Ogre@@0AAV?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@0@@Z
_TEXT	SEGMENT
$T143270 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@YAXPAPAUD3DDEVCOMBO_T@Ogre@@0AAV?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@0@@Z PROC ; std::_Destroy_range<std::allocator<Ogre::D3DDEVCOMBO_T *> >, COMDAT

; 224  : 	{	// destroy [_First, _Last)

	push	ebp
	mov	ebp, esp
	push	ecx

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Ptr_cat@PAPAUD3DDEVCOMBO_T@Ogre@@PAPAU12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAUD3DDEVCOMBO_T@Ogre@@0@Z ; std::_Ptr_cat<Ogre::D3DDEVCOMBO_T * *,Ogre::D3DDEVCOMBO_T * *>
	add	esp, 8
	mov	BYTE PTR $T143270[ebp], al
	movzx	edx, BYTE PTR $T143270[ebp]
	push	edx
	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Destroy_range@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@YAXPAPAUD3DDEVCOMBO_T@Ogre@@0AAV?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<Ogre::D3DDEVCOMBO_T *> >
	add	esp, 16					; 00000010H

; 226  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Destroy_range@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@YAXPAPAUD3DDEVCOMBO_T@Ogre@@0AAV?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<Ogre::D3DDEVCOMBO_T *> >
_TEXT	ENDS
PUBLIC	??$_Unchecked_uninitialized_move@PAPAUD3DDEVCOMBO_T@Ogre@@PAPAU12@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@stdext@@YAPAPAUD3DDEVCOMBO_T@Ogre@@PAPAU12@00AAV?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@Z ; stdext::_Unchecked_uninitialized_move<Ogre::D3DDEVCOMBO_T * *,Ogre::D3DDEVCOMBO_T * *,std::allocator<Ogre::D3DDEVCOMBO_T *> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??$_Umove@PAPAUD3DDEVCOMBO_T@Ogre@@@?$vector@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@IAEPAPAUD3DDEVCOMBO_T@Ogre@@PAPAU23@00@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Umove@PAPAUD3DDEVCOMBO_T@Ogre@@@?$vector@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@IAEPAPAUD3DDEVCOMBO_T@Ogre@@PAPAU23@00@Z PROC ; std::vector<Ogre::D3DDEVCOMBO_T *,std::allocator<Ogre::D3DDEVCOMBO_T *> >::_Umove<Ogre::D3DDEVCOMBO_T * *>, COMDAT
; _this$ = ecx

; 1145 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1146 : 		{	// move initializing [_First, _Last), using allocator
; 1147 : 		return (_STDEXT _Unchecked_uninitialized_move(_First, _Last,
; 1148 : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Unchecked_uninitialized_move@PAPAUD3DDEVCOMBO_T@Ogre@@PAPAU12@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@stdext@@YAPAPAUD3DDEVCOMBO_T@Ogre@@PAPAU12@00AAV?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@Z ; stdext::_Unchecked_uninitialized_move<Ogre::D3DDEVCOMBO_T * *,Ogre::D3DDEVCOMBO_T * *,std::allocator<Ogre::D3DDEVCOMBO_T *> >
	add	esp, 16					; 00000010H

; 1149 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??$_Umove@PAPAUD3DDEVCOMBO_T@Ogre@@@?$vector@PAUD3DDEVCOMBO_T@Ogre@@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@IAEPAPAUD3DDEVCOMBO_T@Ogre@@PAPAU23@00@Z ENDP ; std::vector<Ogre::D3DDEVCOMBO_T *,std::allocator<Ogre::D3DDEVCOMBO_T *> >::_Umove<Ogre::D3DDEVCOMBO_T * *>
_TEXT	ENDS
PUBLIC	??$_Fill@PAPAUD3DDEVCOMBO_T@Ogre@@PAU12@@std@@YAXPAPAUD3DDEVCOMBO_T@Ogre@@0ABQAU12@@Z ; std::_Fill<Ogre::D3DDEVCOMBO_T * *,Ogre::D3DDEVCOMBO_T *>
PUBLIC	??$_Checked_base@PAPAUD3DDEVCOMBO_T@Ogre@@@std@@YAPAPAUD3DDEVCOMBO_T@Ogre@@AAPAPAU12@@Z ; std::_Checked_base<Ogre::D3DDEVCOMBO_T * *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$fill@PAPAUD3DDEVCOMBO_T@Ogre@@PAU12@@std@@YAXPAPAUD3DDEVCOMBO_T@Ogre@@0ABQAU12@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$fill@PAPAUD3DDEVCOMBO_T@Ogre@@PAU12@@std@@YAXPAPAUD3DDEVCOMBO_T@Ogre@@0ABQAU12@@Z PROC ; std::fill<Ogre::D3DDEVCOMBO_T * *,Ogre::D3DDEVCOMBO_T *>, COMDAT

; 3186 : 	{	// copy _Val through [_First, _Last)

	push	ebp
	mov	ebp, esp

; 3187 : 	_Fill(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@PAPAUD3DDEVCOMBO_T@Ogre@@@std@@YAPAPAUD3DDEVCOMBO_T@Ogre@@AAPAPAU12@@Z ; std::_Checked_base<Ogre::D3DDEVCOMBO_T * *>
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@PAPAUD3DDEVCOMBO_T@Ogre@@@std@@YAPAPAUD3DDEVCOMBO_T@Ogre@@AAPAPAU12@@Z ; std::_Checked_base<Ogre::D3DDEVCOMBO_T * *>
	add	esp, 4
	push	eax
	call	??$_Fill@PAPAUD3DDEVCOMBO_T@Ogre@@PAU12@@std@@YAXPAPAUD3DDEVCOMBO_T@Ogre@@0ABQAU12@@Z ; std::_Fill<Ogre::D3DDEVCOMBO_T * *,Ogre::D3DDEVCOMBO_T *>
	add	esp, 12					; 0000000cH

; 3188 : 	}

	pop	ebp
	ret	0
??$fill@PAPAUD3DDEVCOMBO_T@Ogre@@PAU12@@std@@YAXPAPAUD3DDEVCOMBO_T@Ogre@@0ABQAU12@@Z ENDP ; std::fill<Ogre::D3DDEVCOMBO_T * *,Ogre::D3DDEVCOMBO_T *>
_TEXT	ENDS
PUBLIC	??$_Move_backward_opt@PAPAUD3DDEVCOMBO_T@Ogre@@PAPAU12@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@4@@std@@YAPAPAUD3DDEVCOMBO_T@Ogre@@PAPAU12@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Move_backward_opt<Ogre::D3DDEVCOMBO_T * *,Ogre::D3DDEVCOMBO_T * *,std::random_access_iterator_tag,std::_Undefined_move_tag>
PUBLIC	??$_Iter_random@PAPAUD3DDEVCOMBO_T@Ogre@@PAPAU12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAUD3DDEVCOMBO_T@Ogre@@0@Z ; std::_Iter_random<Ogre::D3DDEVCOMBO_T * *,Ogre::D3DDEVCOMBO_T * *>
PUBLIC	??$_Move_cat@PAPAUD3DDEVCOMBO_T@Ogre@@@std@@YA?AU_Undefined_move_tag@0@ABQAPAUD3DDEVCOMBO_T@Ogre@@@Z ; std::_Move_cat<Ogre::D3DDEVCOMBO_T * *>
; Function compile flags: /Odtp
;	COMDAT ??$_Unchecked_move_backward@PAPAUD3DDEVCOMBO_T@Ogre@@PAPAU12@@stdext@@YAPAPAUD3DDEVCOMBO_T@Ogre@@PAPAU12@00@Z
_TEXT	SEGMENT
$T143279 = -3						; size = 1
$T143278 = -2						; size = 1
$T143277 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Unchecked_move_backward@PAPAUD3DDEVCOMBO_T@Ogre@@PAPAU12@@stdext@@YAPAPAUD3DDEVCOMBO_T@Ogre@@PAPAU12@00@Z PROC ; stdext::_Unchecked_move_backward<Ogre::D3DDEVCOMBO_T * *,Ogre::D3DDEVCOMBO_T * *>, COMDAT

; 3694 : 	{	// move [_First, _Last) backwards to [..., _Dest)

	push	ebp
	mov	ebp, esp
	push	ecx

; 3695 : 		return (_STD _Move_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3696 : 			_STD _Iter_random(_First, _Dest), _STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T143277[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	??$_Move_cat@PAPAUD3DDEVCOMBO_T@Ogre@@@std@@YA?AU_Undefined_move_tag@0@ABQAPAUD3DDEVCOMBO_T@Ogre@@@Z ; std::_Move_cat<Ogre::D3DDEVCOMBO_T * *>
	add	esp, 4
	mov	BYTE PTR $T143278[ebp], al
	movzx	edx, BYTE PTR $T143277[ebp]
	push	edx
	movzx	eax, BYTE PTR $T143278[ebp]
	push	eax
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	lea	eax, DWORD PTR $T143279[ebp]
	push	eax
	call	??$_Iter_random@PAPAUD3DDEVCOMBO_T@Ogre@@PAPAU12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAUD3DDEVCOMBO_T@Ogre@@0@Z ; std::_Iter_random<Ogre::D3DDEVCOMBO_T * *,Ogre::D3DDEVCOMBO_T * *>
	add	esp, 12					; 0000000cH
	movzx	ecx, BYTE PTR [eax]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	call	??$_Checked_base@PAPAUD3DDEVCOMBO_T@Ogre@@@std@@YAPAPAUD3DDEVCOMBO_T@Ogre@@AAPAPAU12@@Z ; std::_Checked_base<Ogre::D3DDEVCOMBO_T * *>
	add	esp, 4
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Checked_base@PAPAUD3DDEVCOMBO_T@Ogre@@@std@@YAPAPAUD3DDEVCOMBO_T@Ogre@@AAPAPAU12@@Z ; std::_Checked_base<Ogre::D3DDEVCOMBO_T * *>
	add	esp, 4
	push	eax
	call	??$_Move_backward_opt@PAPAUD3DDEVCOMBO_T@Ogre@@PAPAU12@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@4@@std@@YAPAPAUD3DDEVCOMBO_T@Ogre@@PAPAU12@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Move_backward_opt<Ogre::D3DDEVCOMBO_T * *,Ogre::D3DDEVCOMBO_T * *,std::random_access_iterator_tag,std::_Undefined_move_tag>
	add	esp, 24					; 00000018H

; 3697 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Unchecked_move_backward@PAPAUD3DDEVCOMBO_T@Ogre@@PAPAU12@@stdext@@YAPAPAUD3DDEVCOMBO_T@Ogre@@PAPAU12@00@Z ENDP ; stdext::_Unchecked_move_backward<Ogre::D3DDEVCOMBO_T * *,Ogre::D3DDEVCOMBO_T * *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$?0PAUD3DDEVCOMBO_T@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??$?0PAUD3DDEVCOMBO_T@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@1@@Z PROC ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::D3DDEVCOMBO_T *>, COMDAT
; _this$ = ecx

; 128  : 		allocator(const allocator<_Other>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0PAUD3DDEVCOMBO_T@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@1@@Z ENDP ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::D3DDEVCOMBO_T *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Allocate@PAUD3DDEVCOMBO_T@Ogre@@@std@@YAPAPAUD3DDEVCOMBO_T@Ogre@@IPAPAU12@@Z
_TEXT	SEGMENT
$T143284 = -12						; size = 12
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@PAUD3DDEVCOMBO_T@Ogre@@@std@@YAPAPAUD3DDEVCOMBO_T@Ogre@@IPAPAU12@@Z PROC ; std::_Allocate<Ogre::D3DDEVCOMBO_T *>, COMDAT

; 36   : 	{	// check for integer overflow

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 37   : 	if (_Count <= 0)

	cmp	DWORD PTR __Count$[ebp], 0
	ja	SHORT $LN3@Allocate@6

; 38   : 		_Count = 0;

	mov	DWORD PTR __Count$[ebp], 0
	jmp	SHORT $LN2@Allocate@6
$LN3@Allocate@6:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Count$[ebp]
	cmp	eax, 4
	jae	SHORT $LN2@Allocate@6

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	push	0
	lea	ecx, DWORD PTR $T143284[ebp]
	call	??0bad_alloc@std@@QAE@PBD@Z		; std::bad_alloc::bad_alloc
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	eax, DWORD PTR $T143284[ebp]
	push	eax
	call	__CxxThrowException@8
$LN2@Allocate@6:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 2
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
$LN5@Allocate@6:

; 44   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@PAUD3DDEVCOMBO_T@Ogre@@@std@@YAPAPAUD3DDEVCOMBO_T@Ogre@@IPAPAU12@@Z ENDP ; std::_Allocate<Ogre::D3DDEVCOMBO_T *>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@YAXPAU_D3DDISPLAYMODE@@0AAV?$allocator@U_D3DDISPLAYMODE@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<_D3DDISPLAYMODE> >
; Function compile flags: /Odtp
;	COMDAT ??$_Destroy_range@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@YAXPAU_D3DDISPLAYMODE@@0AAV?$allocator@U_D3DDISPLAYMODE@@@0@@Z
_TEXT	SEGMENT
$T143287 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@YAXPAU_D3DDISPLAYMODE@@0AAV?$allocator@U_D3DDISPLAYMODE@@@0@@Z PROC ; std::_Destroy_range<std::allocator<_D3DDISPLAYMODE> >, COMDAT

; 224  : 	{	// destroy [_First, _Last)

	push	ebp
	mov	ebp, esp
	push	ecx

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Ptr_cat@PAU_D3DDISPLAYMODE@@PAU1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAU_D3DDISPLAYMODE@@0@Z ; std::_Ptr_cat<_D3DDISPLAYMODE *,_D3DDISPLAYMODE *>
	add	esp, 8
	mov	BYTE PTR $T143287[ebp], al
	movzx	edx, BYTE PTR $T143287[ebp]
	push	edx
	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Destroy_range@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@YAXPAU_D3DDISPLAYMODE@@0AAV?$allocator@U_D3DDISPLAYMODE@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<_D3DDISPLAYMODE> >
	add	esp, 16					; 00000010H

; 226  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Destroy_range@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@YAXPAU_D3DDISPLAYMODE@@0AAV?$allocator@U_D3DDISPLAYMODE@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<_D3DDISPLAYMODE> >
_TEXT	ENDS
PUBLIC	??$_Unchecked_uninitialized_move@PAU_D3DDISPLAYMODE@@PAU1@V?$allocator@U_D3DDISPLAYMODE@@@std@@@stdext@@YAPAU_D3DDISPLAYMODE@@PAU1@00AAV?$allocator@U_D3DDISPLAYMODE@@@std@@@Z ; stdext::_Unchecked_uninitialized_move<_D3DDISPLAYMODE *,_D3DDISPLAYMODE *,std::allocator<_D3DDISPLAYMODE> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??$_Umove@PAU_D3DDISPLAYMODE@@@?$vector@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@IAEPAU_D3DDISPLAYMODE@@PAU2@00@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Umove@PAU_D3DDISPLAYMODE@@@?$vector@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@IAEPAU_D3DDISPLAYMODE@@PAU2@00@Z PROC ; std::vector<_D3DDISPLAYMODE,std::allocator<_D3DDISPLAYMODE> >::_Umove<_D3DDISPLAYMODE *>, COMDAT
; _this$ = ecx

; 1145 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1146 : 		{	// move initializing [_First, _Last), using allocator
; 1147 : 		return (_STDEXT _Unchecked_uninitialized_move(_First, _Last,
; 1148 : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Unchecked_uninitialized_move@PAU_D3DDISPLAYMODE@@PAU1@V?$allocator@U_D3DDISPLAYMODE@@@std@@@stdext@@YAPAU_D3DDISPLAYMODE@@PAU1@00AAV?$allocator@U_D3DDISPLAYMODE@@@std@@@Z ; stdext::_Unchecked_uninitialized_move<_D3DDISPLAYMODE *,_D3DDISPLAYMODE *,std::allocator<_D3DDISPLAYMODE> >
	add	esp, 16					; 00000010H

; 1149 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??$_Umove@PAU_D3DDISPLAYMODE@@@?$vector@U_D3DDISPLAYMODE@@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@IAEPAU_D3DDISPLAYMODE@@PAU2@00@Z ENDP ; std::vector<_D3DDISPLAYMODE,std::allocator<_D3DDISPLAYMODE> >::_Umove<_D3DDISPLAYMODE *>
_TEXT	ENDS
PUBLIC	??$_Fill@PAU_D3DDISPLAYMODE@@U1@@std@@YAXPAU_D3DDISPLAYMODE@@0ABU1@@Z ; std::_Fill<_D3DDISPLAYMODE *,_D3DDISPLAYMODE>
PUBLIC	??$_Checked_base@PAU_D3DDISPLAYMODE@@@std@@YAPAU_D3DDISPLAYMODE@@AAPAU1@@Z ; std::_Checked_base<_D3DDISPLAYMODE *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$fill@PAU_D3DDISPLAYMODE@@U1@@std@@YAXPAU_D3DDISPLAYMODE@@0ABU1@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$fill@PAU_D3DDISPLAYMODE@@U1@@std@@YAXPAU_D3DDISPLAYMODE@@0ABU1@@Z PROC ; std::fill<_D3DDISPLAYMODE *,_D3DDISPLAYMODE>, COMDAT

; 3186 : 	{	// copy _Val through [_First, _Last)

	push	ebp
	mov	ebp, esp

; 3187 : 	_Fill(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@PAU_D3DDISPLAYMODE@@@std@@YAPAU_D3DDISPLAYMODE@@AAPAU1@@Z ; std::_Checked_base<_D3DDISPLAYMODE *>
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@PAU_D3DDISPLAYMODE@@@std@@YAPAU_D3DDISPLAYMODE@@AAPAU1@@Z ; std::_Checked_base<_D3DDISPLAYMODE *>
	add	esp, 4
	push	eax
	call	??$_Fill@PAU_D3DDISPLAYMODE@@U1@@std@@YAXPAU_D3DDISPLAYMODE@@0ABU1@@Z ; std::_Fill<_D3DDISPLAYMODE *,_D3DDISPLAYMODE>
	add	esp, 12					; 0000000cH

; 3188 : 	}

	pop	ebp
	ret	0
??$fill@PAU_D3DDISPLAYMODE@@U1@@std@@YAXPAU_D3DDISPLAYMODE@@0ABU1@@Z ENDP ; std::fill<_D3DDISPLAYMODE *,_D3DDISPLAYMODE>
_TEXT	ENDS
PUBLIC	??$_Move_backward_opt@PAU_D3DDISPLAYMODE@@PAU1@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAU_D3DDISPLAYMODE@@PAU1@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Move_backward_opt<_D3DDISPLAYMODE *,_D3DDISPLAYMODE *,std::random_access_iterator_tag,std::_Undefined_move_tag>
PUBLIC	??$_Iter_random@PAU_D3DDISPLAYMODE@@PAU1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAU_D3DDISPLAYMODE@@0@Z ; std::_Iter_random<_D3DDISPLAYMODE *,_D3DDISPLAYMODE *>
PUBLIC	??$_Move_cat@PAU_D3DDISPLAYMODE@@@std@@YA?AU_Undefined_move_tag@0@ABQAU_D3DDISPLAYMODE@@@Z ; std::_Move_cat<_D3DDISPLAYMODE *>
; Function compile flags: /Odtp
;	COMDAT ??$_Unchecked_move_backward@PAU_D3DDISPLAYMODE@@PAU1@@stdext@@YAPAU_D3DDISPLAYMODE@@PAU1@00@Z
_TEXT	SEGMENT
$T143296 = -3						; size = 1
$T143295 = -2						; size = 1
$T143294 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Unchecked_move_backward@PAU_D3DDISPLAYMODE@@PAU1@@stdext@@YAPAU_D3DDISPLAYMODE@@PAU1@00@Z PROC ; stdext::_Unchecked_move_backward<_D3DDISPLAYMODE *,_D3DDISPLAYMODE *>, COMDAT

; 3694 : 	{	// move [_First, _Last) backwards to [..., _Dest)

	push	ebp
	mov	ebp, esp
	push	ecx

; 3695 : 		return (_STD _Move_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3696 : 			_STD _Iter_random(_First, _Dest), _STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T143294[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	??$_Move_cat@PAU_D3DDISPLAYMODE@@@std@@YA?AU_Undefined_move_tag@0@ABQAU_D3DDISPLAYMODE@@@Z ; std::_Move_cat<_D3DDISPLAYMODE *>
	add	esp, 4
	mov	BYTE PTR $T143295[ebp], al
	movzx	edx, BYTE PTR $T143294[ebp]
	push	edx
	movzx	eax, BYTE PTR $T143295[ebp]
	push	eax
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	lea	eax, DWORD PTR $T143296[ebp]
	push	eax
	call	??$_Iter_random@PAU_D3DDISPLAYMODE@@PAU1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAU_D3DDISPLAYMODE@@0@Z ; std::_Iter_random<_D3DDISPLAYMODE *,_D3DDISPLAYMODE *>
	add	esp, 12					; 0000000cH
	movzx	ecx, BYTE PTR [eax]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	call	??$_Checked_base@PAU_D3DDISPLAYMODE@@@std@@YAPAU_D3DDISPLAYMODE@@AAPAU1@@Z ; std::_Checked_base<_D3DDISPLAYMODE *>
	add	esp, 4
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Checked_base@PAU_D3DDISPLAYMODE@@@std@@YAPAU_D3DDISPLAYMODE@@AAPAU1@@Z ; std::_Checked_base<_D3DDISPLAYMODE *>
	add	esp, 4
	push	eax
	call	??$_Move_backward_opt@PAU_D3DDISPLAYMODE@@PAU1@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAU_D3DDISPLAYMODE@@PAU1@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Move_backward_opt<_D3DDISPLAYMODE *,_D3DDISPLAYMODE *,std::random_access_iterator_tag,std::_Undefined_move_tag>
	add	esp, 24					; 00000018H

; 3697 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Unchecked_move_backward@PAU_D3DDISPLAYMODE@@PAU1@@stdext@@YAPAU_D3DDISPLAYMODE@@PAU1@00@Z ENDP ; stdext::_Unchecked_move_backward<_D3DDISPLAYMODE *,_D3DDISPLAYMODE *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$?0U_D3DDISPLAYMODE@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@U_D3DDISPLAYMODE@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??$?0U_D3DDISPLAYMODE@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@U_D3DDISPLAYMODE@@@1@@Z PROC ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><_D3DDISPLAYMODE>, COMDAT
; _this$ = ecx

; 128  : 		allocator(const allocator<_Other>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0U_D3DDISPLAYMODE@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@U_D3DDISPLAYMODE@@@1@@Z ENDP ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><_D3DDISPLAYMODE>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Allocate@U_D3DDISPLAYMODE@@@std@@YAPAU_D3DDISPLAYMODE@@IPAU1@@Z
_TEXT	SEGMENT
$T143301 = -12						; size = 12
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@U_D3DDISPLAYMODE@@@std@@YAPAU_D3DDISPLAYMODE@@IPAU1@@Z PROC ; std::_Allocate<_D3DDISPLAYMODE>, COMDAT

; 36   : 	{	// check for integer overflow

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 37   : 	if (_Count <= 0)

	cmp	DWORD PTR __Count$[ebp], 0
	ja	SHORT $LN3@Allocate@7

; 38   : 		_Count = 0;

	mov	DWORD PTR __Count$[ebp], 0
	jmp	SHORT $LN2@Allocate@7
$LN3@Allocate@7:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Count$[ebp]
	cmp	eax, 16					; 00000010H
	jae	SHORT $LN2@Allocate@7

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	push	0
	lea	ecx, DWORD PTR $T143301[ebp]
	call	??0bad_alloc@std@@QAE@PBD@Z		; std::bad_alloc::bad_alloc
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	eax, DWORD PTR $T143301[ebp]
	push	eax
	call	__CxxThrowException@8
$LN2@Allocate@7:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 4
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
$LN5@Allocate@7:

; 44   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@U_D3DDISPLAYMODE@@@std@@YAPAU_D3DDISPLAYMODE@@IPAU1@@Z ENDP ; std::_Allocate<_D3DDISPLAYMODE>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@YAXPAPAUD3DDEVICEINFO_T@Ogre@@0AAV?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<Ogre::D3DDEVICEINFO_T *> >
; Function compile flags: /Odtp
;	COMDAT ??$_Destroy_range@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@YAXPAPAUD3DDEVICEINFO_T@Ogre@@0AAV?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@0@@Z
_TEXT	SEGMENT
$T143304 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@YAXPAPAUD3DDEVICEINFO_T@Ogre@@0AAV?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@0@@Z PROC ; std::_Destroy_range<std::allocator<Ogre::D3DDEVICEINFO_T *> >, COMDAT

; 224  : 	{	// destroy [_First, _Last)

	push	ebp
	mov	ebp, esp
	push	ecx

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Ptr_cat@PAPAUD3DDEVICEINFO_T@Ogre@@PAPAU12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAUD3DDEVICEINFO_T@Ogre@@0@Z ; std::_Ptr_cat<Ogre::D3DDEVICEINFO_T * *,Ogre::D3DDEVICEINFO_T * *>
	add	esp, 8
	mov	BYTE PTR $T143304[ebp], al
	movzx	edx, BYTE PTR $T143304[ebp]
	push	edx
	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Destroy_range@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@YAXPAPAUD3DDEVICEINFO_T@Ogre@@0AAV?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<Ogre::D3DDEVICEINFO_T *> >
	add	esp, 16					; 00000010H

; 226  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Destroy_range@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@YAXPAPAUD3DDEVICEINFO_T@Ogre@@0AAV?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<Ogre::D3DDEVICEINFO_T *> >
_TEXT	ENDS
PUBLIC	??$_Unchecked_uninitialized_move@PAPAUD3DDEVICEINFO_T@Ogre@@PAPAU12@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@stdext@@YAPAPAUD3DDEVICEINFO_T@Ogre@@PAPAU12@00AAV?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@Z ; stdext::_Unchecked_uninitialized_move<Ogre::D3DDEVICEINFO_T * *,Ogre::D3DDEVICEINFO_T * *,std::allocator<Ogre::D3DDEVICEINFO_T *> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??$_Umove@PAPAUD3DDEVICEINFO_T@Ogre@@@?$vector@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@IAEPAPAUD3DDEVICEINFO_T@Ogre@@PAPAU23@00@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Umove@PAPAUD3DDEVICEINFO_T@Ogre@@@?$vector@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@IAEPAPAUD3DDEVICEINFO_T@Ogre@@PAPAU23@00@Z PROC ; std::vector<Ogre::D3DDEVICEINFO_T *,std::allocator<Ogre::D3DDEVICEINFO_T *> >::_Umove<Ogre::D3DDEVICEINFO_T * *>, COMDAT
; _this$ = ecx

; 1145 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1146 : 		{	// move initializing [_First, _Last), using allocator
; 1147 : 		return (_STDEXT _Unchecked_uninitialized_move(_First, _Last,
; 1148 : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Unchecked_uninitialized_move@PAPAUD3DDEVICEINFO_T@Ogre@@PAPAU12@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@stdext@@YAPAPAUD3DDEVICEINFO_T@Ogre@@PAPAU12@00AAV?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@Z ; stdext::_Unchecked_uninitialized_move<Ogre::D3DDEVICEINFO_T * *,Ogre::D3DDEVICEINFO_T * *,std::allocator<Ogre::D3DDEVICEINFO_T *> >
	add	esp, 16					; 00000010H

; 1149 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??$_Umove@PAPAUD3DDEVICEINFO_T@Ogre@@@?$vector@PAUD3DDEVICEINFO_T@Ogre@@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@IAEPAPAUD3DDEVICEINFO_T@Ogre@@PAPAU23@00@Z ENDP ; std::vector<Ogre::D3DDEVICEINFO_T *,std::allocator<Ogre::D3DDEVICEINFO_T *> >::_Umove<Ogre::D3DDEVICEINFO_T * *>
_TEXT	ENDS
PUBLIC	??$_Fill@PAPAUD3DDEVICEINFO_T@Ogre@@PAU12@@std@@YAXPAPAUD3DDEVICEINFO_T@Ogre@@0ABQAU12@@Z ; std::_Fill<Ogre::D3DDEVICEINFO_T * *,Ogre::D3DDEVICEINFO_T *>
PUBLIC	??$_Checked_base@PAPAUD3DDEVICEINFO_T@Ogre@@@std@@YAPAPAUD3DDEVICEINFO_T@Ogre@@AAPAPAU12@@Z ; std::_Checked_base<Ogre::D3DDEVICEINFO_T * *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$fill@PAPAUD3DDEVICEINFO_T@Ogre@@PAU12@@std@@YAXPAPAUD3DDEVICEINFO_T@Ogre@@0ABQAU12@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$fill@PAPAUD3DDEVICEINFO_T@Ogre@@PAU12@@std@@YAXPAPAUD3DDEVICEINFO_T@Ogre@@0ABQAU12@@Z PROC ; std::fill<Ogre::D3DDEVICEINFO_T * *,Ogre::D3DDEVICEINFO_T *>, COMDAT

; 3186 : 	{	// copy _Val through [_First, _Last)

	push	ebp
	mov	ebp, esp

; 3187 : 	_Fill(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@PAPAUD3DDEVICEINFO_T@Ogre@@@std@@YAPAPAUD3DDEVICEINFO_T@Ogre@@AAPAPAU12@@Z ; std::_Checked_base<Ogre::D3DDEVICEINFO_T * *>
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@PAPAUD3DDEVICEINFO_T@Ogre@@@std@@YAPAPAUD3DDEVICEINFO_T@Ogre@@AAPAPAU12@@Z ; std::_Checked_base<Ogre::D3DDEVICEINFO_T * *>
	add	esp, 4
	push	eax
	call	??$_Fill@PAPAUD3DDEVICEINFO_T@Ogre@@PAU12@@std@@YAXPAPAUD3DDEVICEINFO_T@Ogre@@0ABQAU12@@Z ; std::_Fill<Ogre::D3DDEVICEINFO_T * *,Ogre::D3DDEVICEINFO_T *>
	add	esp, 12					; 0000000cH

; 3188 : 	}

	pop	ebp
	ret	0
??$fill@PAPAUD3DDEVICEINFO_T@Ogre@@PAU12@@std@@YAXPAPAUD3DDEVICEINFO_T@Ogre@@0ABQAU12@@Z ENDP ; std::fill<Ogre::D3DDEVICEINFO_T * *,Ogre::D3DDEVICEINFO_T *>
_TEXT	ENDS
PUBLIC	??$_Move_backward_opt@PAPAUD3DDEVICEINFO_T@Ogre@@PAPAU12@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@4@@std@@YAPAPAUD3DDEVICEINFO_T@Ogre@@PAPAU12@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Move_backward_opt<Ogre::D3DDEVICEINFO_T * *,Ogre::D3DDEVICEINFO_T * *,std::random_access_iterator_tag,std::_Undefined_move_tag>
PUBLIC	??$_Iter_random@PAPAUD3DDEVICEINFO_T@Ogre@@PAPAU12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAUD3DDEVICEINFO_T@Ogre@@0@Z ; std::_Iter_random<Ogre::D3DDEVICEINFO_T * *,Ogre::D3DDEVICEINFO_T * *>
PUBLIC	??$_Move_cat@PAPAUD3DDEVICEINFO_T@Ogre@@@std@@YA?AU_Undefined_move_tag@0@ABQAPAUD3DDEVICEINFO_T@Ogre@@@Z ; std::_Move_cat<Ogre::D3DDEVICEINFO_T * *>
; Function compile flags: /Odtp
;	COMDAT ??$_Unchecked_move_backward@PAPAUD3DDEVICEINFO_T@Ogre@@PAPAU12@@stdext@@YAPAPAUD3DDEVICEINFO_T@Ogre@@PAPAU12@00@Z
_TEXT	SEGMENT
$T143313 = -3						; size = 1
$T143312 = -2						; size = 1
$T143311 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Unchecked_move_backward@PAPAUD3DDEVICEINFO_T@Ogre@@PAPAU12@@stdext@@YAPAPAUD3DDEVICEINFO_T@Ogre@@PAPAU12@00@Z PROC ; stdext::_Unchecked_move_backward<Ogre::D3DDEVICEINFO_T * *,Ogre::D3DDEVICEINFO_T * *>, COMDAT

; 3694 : 	{	// move [_First, _Last) backwards to [..., _Dest)

	push	ebp
	mov	ebp, esp
	push	ecx

; 3695 : 		return (_STD _Move_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3696 : 			_STD _Iter_random(_First, _Dest), _STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T143311[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	??$_Move_cat@PAPAUD3DDEVICEINFO_T@Ogre@@@std@@YA?AU_Undefined_move_tag@0@ABQAPAUD3DDEVICEINFO_T@Ogre@@@Z ; std::_Move_cat<Ogre::D3DDEVICEINFO_T * *>
	add	esp, 4
	mov	BYTE PTR $T143312[ebp], al
	movzx	edx, BYTE PTR $T143311[ebp]
	push	edx
	movzx	eax, BYTE PTR $T143312[ebp]
	push	eax
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	lea	eax, DWORD PTR $T143313[ebp]
	push	eax
	call	??$_Iter_random@PAPAUD3DDEVICEINFO_T@Ogre@@PAPAU12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAUD3DDEVICEINFO_T@Ogre@@0@Z ; std::_Iter_random<Ogre::D3DDEVICEINFO_T * *,Ogre::D3DDEVICEINFO_T * *>
	add	esp, 12					; 0000000cH
	movzx	ecx, BYTE PTR [eax]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	call	??$_Checked_base@PAPAUD3DDEVICEINFO_T@Ogre@@@std@@YAPAPAUD3DDEVICEINFO_T@Ogre@@AAPAPAU12@@Z ; std::_Checked_base<Ogre::D3DDEVICEINFO_T * *>
	add	esp, 4
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Checked_base@PAPAUD3DDEVICEINFO_T@Ogre@@@std@@YAPAPAUD3DDEVICEINFO_T@Ogre@@AAPAPAU12@@Z ; std::_Checked_base<Ogre::D3DDEVICEINFO_T * *>
	add	esp, 4
	push	eax
	call	??$_Move_backward_opt@PAPAUD3DDEVICEINFO_T@Ogre@@PAPAU12@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@4@@std@@YAPAPAUD3DDEVICEINFO_T@Ogre@@PAPAU12@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Move_backward_opt<Ogre::D3DDEVICEINFO_T * *,Ogre::D3DDEVICEINFO_T * *,std::random_access_iterator_tag,std::_Undefined_move_tag>
	add	esp, 24					; 00000018H

; 3697 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Unchecked_move_backward@PAPAUD3DDEVICEINFO_T@Ogre@@PAPAU12@@stdext@@YAPAPAUD3DDEVICEINFO_T@Ogre@@PAPAU12@00@Z ENDP ; stdext::_Unchecked_move_backward<Ogre::D3DDEVICEINFO_T * *,Ogre::D3DDEVICEINFO_T * *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$?0PAUD3DDEVICEINFO_T@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??$?0PAUD3DDEVICEINFO_T@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@1@@Z PROC ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::D3DDEVICEINFO_T *>, COMDAT
; _this$ = ecx

; 128  : 		allocator(const allocator<_Other>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0PAUD3DDEVICEINFO_T@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@1@@Z ENDP ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::D3DDEVICEINFO_T *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Allocate@PAUD3DDEVICEINFO_T@Ogre@@@std@@YAPAPAUD3DDEVICEINFO_T@Ogre@@IPAPAU12@@Z
_TEXT	SEGMENT
$T143318 = -12						; size = 12
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@PAUD3DDEVICEINFO_T@Ogre@@@std@@YAPAPAUD3DDEVICEINFO_T@Ogre@@IPAPAU12@@Z PROC ; std::_Allocate<Ogre::D3DDEVICEINFO_T *>, COMDAT

; 36   : 	{	// check for integer overflow

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 37   : 	if (_Count <= 0)

	cmp	DWORD PTR __Count$[ebp], 0
	ja	SHORT $LN3@Allocate@8

; 38   : 		_Count = 0;

	mov	DWORD PTR __Count$[ebp], 0
	jmp	SHORT $LN2@Allocate@8
$LN3@Allocate@8:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Count$[ebp]
	cmp	eax, 4
	jae	SHORT $LN2@Allocate@8

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	push	0
	lea	ecx, DWORD PTR $T143318[ebp]
	call	??0bad_alloc@std@@QAE@PBD@Z		; std::bad_alloc::bad_alloc
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	eax, DWORD PTR $T143318[ebp]
	push	eax
	call	__CxxThrowException@8
$LN2@Allocate@8:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 2
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
$LN5@Allocate@8:

; 44   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@PAUD3DDEVICEINFO_T@Ogre@@@std@@YAPAPAUD3DDEVICEINFO_T@Ogre@@IPAPAU12@@Z ENDP ; std::_Allocate<Ogre::D3DDEVICEINFO_T *>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@YAXPAPAUD3DADAPTER_T@Ogre@@0AAV?$allocator@PAUD3DADAPTER_T@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<Ogre::D3DADAPTER_T *> >
; Function compile flags: /Odtp
;	COMDAT ??$_Destroy_range@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@YAXPAPAUD3DADAPTER_T@Ogre@@0AAV?$allocator@PAUD3DADAPTER_T@Ogre@@@0@@Z
_TEXT	SEGMENT
$T143321 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@YAXPAPAUD3DADAPTER_T@Ogre@@0AAV?$allocator@PAUD3DADAPTER_T@Ogre@@@0@@Z PROC ; std::_Destroy_range<std::allocator<Ogre::D3DADAPTER_T *> >, COMDAT

; 224  : 	{	// destroy [_First, _Last)

	push	ebp
	mov	ebp, esp
	push	ecx

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Ptr_cat@PAPAUD3DADAPTER_T@Ogre@@PAPAU12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAUD3DADAPTER_T@Ogre@@0@Z ; std::_Ptr_cat<Ogre::D3DADAPTER_T * *,Ogre::D3DADAPTER_T * *>
	add	esp, 8
	mov	BYTE PTR $T143321[ebp], al
	movzx	edx, BYTE PTR $T143321[ebp]
	push	edx
	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Destroy_range@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@YAXPAPAUD3DADAPTER_T@Ogre@@0AAV?$allocator@PAUD3DADAPTER_T@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<Ogre::D3DADAPTER_T *> >
	add	esp, 16					; 00000010H

; 226  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Destroy_range@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@YAXPAPAUD3DADAPTER_T@Ogre@@0AAV?$allocator@PAUD3DADAPTER_T@Ogre@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<Ogre::D3DADAPTER_T *> >
_TEXT	ENDS
PUBLIC	??$_Unchecked_uninitialized_move@PAPAUD3DADAPTER_T@Ogre@@PAPAU12@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@stdext@@YAPAPAUD3DADAPTER_T@Ogre@@PAPAU12@00AAV?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@Z ; stdext::_Unchecked_uninitialized_move<Ogre::D3DADAPTER_T * *,Ogre::D3DADAPTER_T * *,std::allocator<Ogre::D3DADAPTER_T *> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??$_Umove@PAPAUD3DADAPTER_T@Ogre@@@?$vector@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@IAEPAPAUD3DADAPTER_T@Ogre@@PAPAU23@00@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Umove@PAPAUD3DADAPTER_T@Ogre@@@?$vector@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@IAEPAPAUD3DADAPTER_T@Ogre@@PAPAU23@00@Z PROC ; std::vector<Ogre::D3DADAPTER_T *,std::allocator<Ogre::D3DADAPTER_T *> >::_Umove<Ogre::D3DADAPTER_T * *>, COMDAT
; _this$ = ecx

; 1145 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1146 : 		{	// move initializing [_First, _Last), using allocator
; 1147 : 		return (_STDEXT _Unchecked_uninitialized_move(_First, _Last,
; 1148 : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Unchecked_uninitialized_move@PAPAUD3DADAPTER_T@Ogre@@PAPAU12@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@stdext@@YAPAPAUD3DADAPTER_T@Ogre@@PAPAU12@00AAV?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@Z ; stdext::_Unchecked_uninitialized_move<Ogre::D3DADAPTER_T * *,Ogre::D3DADAPTER_T * *,std::allocator<Ogre::D3DADAPTER_T *> >
	add	esp, 16					; 00000010H

; 1149 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??$_Umove@PAPAUD3DADAPTER_T@Ogre@@@?$vector@PAUD3DADAPTER_T@Ogre@@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@IAEPAPAUD3DADAPTER_T@Ogre@@PAPAU23@00@Z ENDP ; std::vector<Ogre::D3DADAPTER_T *,std::allocator<Ogre::D3DADAPTER_T *> >::_Umove<Ogre::D3DADAPTER_T * *>
_TEXT	ENDS
PUBLIC	??$_Fill@PAPAUD3DADAPTER_T@Ogre@@PAU12@@std@@YAXPAPAUD3DADAPTER_T@Ogre@@0ABQAU12@@Z ; std::_Fill<Ogre::D3DADAPTER_T * *,Ogre::D3DADAPTER_T *>
PUBLIC	??$_Checked_base@PAPAUD3DADAPTER_T@Ogre@@@std@@YAPAPAUD3DADAPTER_T@Ogre@@AAPAPAU12@@Z ; std::_Checked_base<Ogre::D3DADAPTER_T * *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$fill@PAPAUD3DADAPTER_T@Ogre@@PAU12@@std@@YAXPAPAUD3DADAPTER_T@Ogre@@0ABQAU12@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$fill@PAPAUD3DADAPTER_T@Ogre@@PAU12@@std@@YAXPAPAUD3DADAPTER_T@Ogre@@0ABQAU12@@Z PROC ; std::fill<Ogre::D3DADAPTER_T * *,Ogre::D3DADAPTER_T *>, COMDAT

; 3186 : 	{	// copy _Val through [_First, _Last)

	push	ebp
	mov	ebp, esp

; 3187 : 	_Fill(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@PAPAUD3DADAPTER_T@Ogre@@@std@@YAPAPAUD3DADAPTER_T@Ogre@@AAPAPAU12@@Z ; std::_Checked_base<Ogre::D3DADAPTER_T * *>
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@PAPAUD3DADAPTER_T@Ogre@@@std@@YAPAPAUD3DADAPTER_T@Ogre@@AAPAPAU12@@Z ; std::_Checked_base<Ogre::D3DADAPTER_T * *>
	add	esp, 4
	push	eax
	call	??$_Fill@PAPAUD3DADAPTER_T@Ogre@@PAU12@@std@@YAXPAPAUD3DADAPTER_T@Ogre@@0ABQAU12@@Z ; std::_Fill<Ogre::D3DADAPTER_T * *,Ogre::D3DADAPTER_T *>
	add	esp, 12					; 0000000cH

; 3188 : 	}

	pop	ebp
	ret	0
??$fill@PAPAUD3DADAPTER_T@Ogre@@PAU12@@std@@YAXPAPAUD3DADAPTER_T@Ogre@@0ABQAU12@@Z ENDP ; std::fill<Ogre::D3DADAPTER_T * *,Ogre::D3DADAPTER_T *>
_TEXT	ENDS
PUBLIC	??$_Move_backward_opt@PAPAUD3DADAPTER_T@Ogre@@PAPAU12@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@4@@std@@YAPAPAUD3DADAPTER_T@Ogre@@PAPAU12@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Move_backward_opt<Ogre::D3DADAPTER_T * *,Ogre::D3DADAPTER_T * *,std::random_access_iterator_tag,std::_Undefined_move_tag>
PUBLIC	??$_Iter_random@PAPAUD3DADAPTER_T@Ogre@@PAPAU12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAUD3DADAPTER_T@Ogre@@0@Z ; std::_Iter_random<Ogre::D3DADAPTER_T * *,Ogre::D3DADAPTER_T * *>
PUBLIC	??$_Move_cat@PAPAUD3DADAPTER_T@Ogre@@@std@@YA?AU_Undefined_move_tag@0@ABQAPAUD3DADAPTER_T@Ogre@@@Z ; std::_Move_cat<Ogre::D3DADAPTER_T * *>
; Function compile flags: /Odtp
;	COMDAT ??$_Unchecked_move_backward@PAPAUD3DADAPTER_T@Ogre@@PAPAU12@@stdext@@YAPAPAUD3DADAPTER_T@Ogre@@PAPAU12@00@Z
_TEXT	SEGMENT
$T143330 = -3						; size = 1
$T143329 = -2						; size = 1
$T143328 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Unchecked_move_backward@PAPAUD3DADAPTER_T@Ogre@@PAPAU12@@stdext@@YAPAPAUD3DADAPTER_T@Ogre@@PAPAU12@00@Z PROC ; stdext::_Unchecked_move_backward<Ogre::D3DADAPTER_T * *,Ogre::D3DADAPTER_T * *>, COMDAT

; 3694 : 	{	// move [_First, _Last) backwards to [..., _Dest)

	push	ebp
	mov	ebp, esp
	push	ecx

; 3695 : 		return (_STD _Move_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3696 : 			_STD _Iter_random(_First, _Dest), _STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T143328[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	??$_Move_cat@PAPAUD3DADAPTER_T@Ogre@@@std@@YA?AU_Undefined_move_tag@0@ABQAPAUD3DADAPTER_T@Ogre@@@Z ; std::_Move_cat<Ogre::D3DADAPTER_T * *>
	add	esp, 4
	mov	BYTE PTR $T143329[ebp], al
	movzx	edx, BYTE PTR $T143328[ebp]
	push	edx
	movzx	eax, BYTE PTR $T143329[ebp]
	push	eax
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	lea	eax, DWORD PTR $T143330[ebp]
	push	eax
	call	??$_Iter_random@PAPAUD3DADAPTER_T@Ogre@@PAPAU12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAUD3DADAPTER_T@Ogre@@0@Z ; std::_Iter_random<Ogre::D3DADAPTER_T * *,Ogre::D3DADAPTER_T * *>
	add	esp, 12					; 0000000cH
	movzx	ecx, BYTE PTR [eax]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	call	??$_Checked_base@PAPAUD3DADAPTER_T@Ogre@@@std@@YAPAPAUD3DADAPTER_T@Ogre@@AAPAPAU12@@Z ; std::_Checked_base<Ogre::D3DADAPTER_T * *>
	add	esp, 4
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Checked_base@PAPAUD3DADAPTER_T@Ogre@@@std@@YAPAPAUD3DADAPTER_T@Ogre@@AAPAPAU12@@Z ; std::_Checked_base<Ogre::D3DADAPTER_T * *>
	add	esp, 4
	push	eax
	call	??$_Move_backward_opt@PAPAUD3DADAPTER_T@Ogre@@PAPAU12@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@4@@std@@YAPAPAUD3DADAPTER_T@Ogre@@PAPAU12@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Move_backward_opt<Ogre::D3DADAPTER_T * *,Ogre::D3DADAPTER_T * *,std::random_access_iterator_tag,std::_Undefined_move_tag>
	add	esp, 24					; 00000018H

; 3697 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Unchecked_move_backward@PAPAUD3DADAPTER_T@Ogre@@PAPAU12@@stdext@@YAPAPAUD3DADAPTER_T@Ogre@@PAPAU12@00@Z ENDP ; stdext::_Unchecked_move_backward<Ogre::D3DADAPTER_T * *,Ogre::D3DADAPTER_T * *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$?0PAUD3DADAPTER_T@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@PAUD3DADAPTER_T@Ogre@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??$?0PAUD3DADAPTER_T@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@PAUD3DADAPTER_T@Ogre@@@1@@Z PROC ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::D3DADAPTER_T *>, COMDAT
; _this$ = ecx

; 128  : 		allocator(const allocator<_Other>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0PAUD3DADAPTER_T@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@PAUD3DADAPTER_T@Ogre@@@1@@Z ENDP ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::D3DADAPTER_T *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Allocate@PAUD3DADAPTER_T@Ogre@@@std@@YAPAPAUD3DADAPTER_T@Ogre@@IPAPAU12@@Z
_TEXT	SEGMENT
$T143335 = -12						; size = 12
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@PAUD3DADAPTER_T@Ogre@@@std@@YAPAPAUD3DADAPTER_T@Ogre@@IPAPAU12@@Z PROC ; std::_Allocate<Ogre::D3DADAPTER_T *>, COMDAT

; 36   : 	{	// check for integer overflow

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 37   : 	if (_Count <= 0)

	cmp	DWORD PTR __Count$[ebp], 0
	ja	SHORT $LN3@Allocate@9

; 38   : 		_Count = 0;

	mov	DWORD PTR __Count$[ebp], 0
	jmp	SHORT $LN2@Allocate@9
$LN3@Allocate@9:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Count$[ebp]
	cmp	eax, 4
	jae	SHORT $LN2@Allocate@9

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	push	0
	lea	ecx, DWORD PTR $T143335[ebp]
	call	??0bad_alloc@std@@QAE@PBD@Z		; std::bad_alloc::bad_alloc
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	eax, DWORD PTR $T143335[ebp]
	push	eax
	call	__CxxThrowException@8
$LN2@Allocate@9:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 2
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
$LN5@Allocate@9:

; 44   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@PAUD3DADAPTER_T@Ogre@@@std@@YAPAPAUD3DADAPTER_T@Ogre@@IPAPAU12@@Z ENDP ; std::_Allocate<Ogre::D3DADAPTER_T *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Allocate@V_Aux_cont@std@@@std@@YAPAV_Aux_cont@0@IPAV10@@Z
_TEXT	SEGMENT
$T143338 = -12						; size = 12
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@V_Aux_cont@std@@@std@@YAPAV_Aux_cont@0@IPAV10@@Z PROC ; std::_Allocate<std::_Aux_cont>, COMDAT

; 36   : 	{	// check for integer overflow

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 37   : 	if (_Count <= 0)

	cmp	DWORD PTR __Count$[ebp], 0
	ja	SHORT $LN3@Allocate@10

; 38   : 		_Count = 0;

	mov	DWORD PTR __Count$[ebp], 0
	jmp	SHORT $LN2@Allocate@10
$LN3@Allocate@10:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Count$[ebp]
	cmp	eax, 4
	jae	SHORT $LN2@Allocate@10

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	push	0
	lea	ecx, DWORD PTR $T143338[ebp]
	call	??0bad_alloc@std@@QAE@PBD@Z		; std::bad_alloc::bad_alloc
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	eax, DWORD PTR $T143338[ebp]
	push	eax
	call	__CxxThrowException@8
$LN2@Allocate@10:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 2
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
$LN5@Allocate@10:

; 44   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@V_Aux_cont@std@@@std@@YAPAV_Aux_cont@0@IPAV10@@Z ENDP ; std::_Allocate<std::_Aux_cont>
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0bad_alloc@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0bad_alloc@std@@QAE@ABV01@@Z$0
__ehfuncinfo$??0bad_alloc@std@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0bad_alloc@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0bad_alloc@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7bad_alloc@std@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0bad_alloc@std@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??0bad_alloc@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0bad_alloc@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??A?$vector@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@QAEAAW4VERTPROCESS_T@Ogre@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pos$ = 8						; size = 4
??A?$vector@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@QAEAAW4VERTPROCESS_T@Ogre@@I@Z PROC ; std::vector<enum Ogre::VERTPROCESS_T,std::allocator<enum Ogre::VERTPROCESS_T> >::operator[], COMDAT
; _this$ = ecx

; 774  : 		{	// subscript mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)
; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");
; 780  : 			_SCL_SECURE_OUT_OF_RANGE;
; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@QBEIXZ ; std::vector<enum Ogre::VERTPROCESS_T,std::allocator<enum Ogre::VERTPROCESS_T> >::size
	cmp	DWORD PTR __Pos$[ebp], eax
	jb	SHORT $LN1@operator@26
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN1@operator@26:

; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR __Pos$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]

; 786  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??A?$vector@W4VERTPROCESS_T@Ogre@@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@QAEAAW4VERTPROCESS_T@Ogre@@I@Z ENDP ; std::vector<enum Ogre::VERTPROCESS_T,std::allocator<enum Ogre::VERTPROCESS_T> >::operator[]
_TEXT	ENDS
PUBLIC	??0?$PtrScopeGuardImpl@UD3DDEVCOMBO_T@Ogre@@@Ogre@@IAE@PAUD3DDEVCOMBO_T@1@@Z ; Ogre::PtrScopeGuardImpl<Ogre::D3DDEVCOMBO_T>::PtrScopeGuardImpl<Ogre::D3DDEVCOMBO_T>
;	COMDAT xdata$x
; File i:\svnroot\client\ogremain\ogrescopeguard.h
xdata$x	SEGMENT
__unwindtable$?MakePtrGuard@?$PtrScopeGuardImpl@UD3DDEVCOMBO_T@Ogre@@@Ogre@@SA?AV12@PAUD3DDEVCOMBO_T@2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?MakePtrGuard@?$PtrScopeGuardImpl@UD3DDEVCOMBO_T@Ogre@@@Ogre@@SA?AV12@PAUD3DDEVCOMBO_T@2@@Z$0
__ehfuncinfo$?MakePtrGuard@?$PtrScopeGuardImpl@UD3DDEVCOMBO_T@Ogre@@@Ogre@@SA?AV12@PAUD3DDEVCOMBO_T@2@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?MakePtrGuard@?$PtrScopeGuardImpl@UD3DDEVCOMBO_T@Ogre@@@Ogre@@SA?AV12@PAUD3DDEVCOMBO_T@2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?MakePtrGuard@?$PtrScopeGuardImpl@UD3DDEVCOMBO_T@Ogre@@@Ogre@@SA?AV12@PAUD3DDEVCOMBO_T@2@@Z
_TEXT	SEGMENT
$T143353 = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_p$ = 12						; size = 4
?MakePtrGuard@?$PtrScopeGuardImpl@UD3DDEVCOMBO_T@Ogre@@@Ogre@@SA?AV12@PAUD3DDEVCOMBO_T@2@@Z PROC ; Ogre::PtrScopeGuardImpl<Ogre::D3DDEVCOMBO_T>::MakePtrGuard, COMDAT

; 285  : 		{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?MakePtrGuard@?$PtrScopeGuardImpl@UD3DDEVCOMBO_T@Ogre@@@Ogre@@SA?AV12@PAUD3DDEVCOMBO_T@2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR $T143353[ebp], 0

; 286  : 			return PtrScopeGuardImpl<T>(p);

	mov	eax, DWORD PTR _p$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$PtrScopeGuardImpl@UD3DDEVCOMBO_T@Ogre@@@Ogre@@IAE@PAUD3DDEVCOMBO_T@1@@Z ; Ogre::PtrScopeGuardImpl<Ogre::D3DDEVCOMBO_T>::PtrScopeGuardImpl<Ogre::D3DDEVCOMBO_T>
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR $T143353[ebp]
	or	ecx, 1
	mov	DWORD PTR $T143353[ebp], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 287  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?MakePtrGuard@?$PtrScopeGuardImpl@UD3DDEVCOMBO_T@Ogre@@@Ogre@@SA?AV12@PAUD3DDEVCOMBO_T@2@@Z$0:
	mov	eax, DWORD PTR $T143353[ebp]
	and	eax, 1
	je	$LN4@MakePtrGua@2
	and	DWORD PTR $T143353[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	??1?$PtrScopeGuardImpl@UD3DDEVCOMBO_T@Ogre@@@Ogre@@QAE@XZ ; Ogre::PtrScopeGuardImpl<Ogre::D3DDEVCOMBO_T>::~PtrScopeGuardImpl<Ogre::D3DDEVCOMBO_T>
$LN4@MakePtrGua@2:
	ret	0
__ehhandler$?MakePtrGuard@?$PtrScopeGuardImpl@UD3DDEVCOMBO_T@Ogre@@@Ogre@@SA?AV12@PAUD3DDEVCOMBO_T@2@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?MakePtrGuard@?$PtrScopeGuardImpl@UD3DDEVCOMBO_T@Ogre@@@Ogre@@SA?AV12@PAUD3DDEVCOMBO_T@2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?MakePtrGuard@?$PtrScopeGuardImpl@UD3DDEVCOMBO_T@Ogre@@@Ogre@@SA?AV12@PAUD3DDEVCOMBO_T@2@@Z ENDP ; Ogre::PtrScopeGuardImpl<Ogre::D3DDEVCOMBO_T>::MakePtrGuard
; Function compile flags: /Odtp
;	COMDAT ?Execute@?$PtrScopeGuardImpl@UD3DDEVCOMBO_T@Ogre@@@Ogre@@QAEXXZ
_TEXT	SEGMENT
tv69 = -16						; size = 4
_this$ = -12						; size = 4
$T143364 = -8						; size = 4
$T143363 = -4						; size = 4
?Execute@?$PtrScopeGuardImpl@UD3DDEVCOMBO_T@Ogre@@@Ogre@@QAEXXZ PROC ; Ogre::PtrScopeGuardImpl<Ogre::D3DDEVCOMBO_T>::Execute, COMDAT
; _this$ = ecx

; 293  : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 294  : 			delete m_ptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR $T143364[ebp], ecx
	mov	edx, DWORD PTR $T143364[ebp]
	mov	DWORD PTR $T143363[ebp], edx
	cmp	DWORD PTR $T143363[ebp], 0
	je	SHORT $LN3@Execute
	push	1
	mov	ecx, DWORD PTR $T143363[ebp]
	call	??_GD3DDEVCOMBO_T@Ogre@@QAEPAXI@Z
	mov	DWORD PTR tv69[ebp], eax
	jmp	SHORT $LN1@Execute
$LN3@Execute:
	mov	DWORD PTR tv69[ebp], 0
$LN1@Execute:

; 295  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?Execute@?$PtrScopeGuardImpl@UD3DDEVCOMBO_T@Ogre@@@Ogre@@QAEXXZ ENDP ; Ogre::PtrScopeGuardImpl<Ogre::D3DDEVCOMBO_T>::Execute
_TEXT	ENDS
PUBLIC	??0ScopeGuardImplBase@Ogre@@QAE@XZ		; Ogre::ScopeGuardImplBase::ScopeGuardImplBase
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$PtrScopeGuardImpl@UD3DDEVCOMBO_T@Ogre@@@Ogre@@IAE@PAUD3DDEVCOMBO_T@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$PtrScopeGuardImpl@UD3DDEVCOMBO_T@Ogre@@@Ogre@@IAE@PAUD3DDEVCOMBO_T@1@@Z$0
__ehfuncinfo$??0?$PtrScopeGuardImpl@UD3DDEVCOMBO_T@Ogre@@@Ogre@@IAE@PAUD3DDEVCOMBO_T@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$PtrScopeGuardImpl@UD3DDEVCOMBO_T@Ogre@@@Ogre@@IAE@PAUD3DDEVCOMBO_T@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$PtrScopeGuardImpl@UD3DDEVCOMBO_T@Ogre@@@Ogre@@IAE@PAUD3DDEVCOMBO_T@1@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_p$ = 8							; size = 4
??0?$PtrScopeGuardImpl@UD3DDEVCOMBO_T@Ogre@@@Ogre@@IAE@PAUD3DDEVCOMBO_T@1@@Z PROC ; Ogre::PtrScopeGuardImpl<Ogre::D3DDEVCOMBO_T>::PtrScopeGuardImpl<Ogre::D3DDEVCOMBO_T>, COMDAT
; _this$ = ecx

; 298  : 		PtrScopeGuardImpl( T *p ) : m_ptr(p) {}

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$PtrScopeGuardImpl@UD3DDEVCOMBO_T@Ogre@@@Ogre@@IAE@PAUD3DDEVCOMBO_T@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0ScopeGuardImplBase@Ogre@@QAE@XZ	; Ogre::ScopeGuardImplBase::ScopeGuardImplBase
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _p$[ebp]
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$PtrScopeGuardImpl@UD3DDEVCOMBO_T@Ogre@@@Ogre@@IAE@PAUD3DDEVCOMBO_T@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1ScopeGuardImplBase@Ogre@@IAE@XZ	; Ogre::ScopeGuardImplBase::~ScopeGuardImplBase
__ehhandler$??0?$PtrScopeGuardImpl@UD3DDEVCOMBO_T@Ogre@@@Ogre@@IAE@PAUD3DDEVCOMBO_T@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$PtrScopeGuardImpl@UD3DDEVCOMBO_T@Ogre@@@Ogre@@IAE@PAUD3DDEVCOMBO_T@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$PtrScopeGuardImpl@UD3DDEVCOMBO_T@Ogre@@@Ogre@@IAE@PAUD3DDEVCOMBO_T@1@@Z ENDP ; Ogre::PtrScopeGuardImpl<Ogre::D3DDEVCOMBO_T>::PtrScopeGuardImpl<Ogre::D3DDEVCOMBO_T>
; Function compile flags: /Odtp
;	COMDAT ??0ScopeGuardImplBase@Ogre@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0ScopeGuardImplBase@Ogre@@QAE@XZ PROC			; Ogre::ScopeGuardImplBase::ScopeGuardImplBase, COMDAT
; _this$ = ecx

; 56   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax], 0

; 57   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0ScopeGuardImplBase@Ogre@@QAE@XZ ENDP			; Ogre::ScopeGuardImplBase::ScopeGuardImplBase
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAW4_D3DFORMAT@@PAW41@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAW4_D3DFORMAT@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAW4_D3DFORMAT@@PAW41@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAW4_D3DFORMAT@@0@Z PROC ; std::_Ptr_cat<enum _D3DFORMAT *,enum _D3DFORMAT *>, COMDAT

; 1509 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 1512 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Ptr_cat@PAW4_D3DFORMAT@@PAW41@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAW4_D3DFORMAT@@0@Z ENDP ; std::_Ptr_cat<enum _D3DFORMAT *,enum _D3DFORMAT *>
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@W4_D3DFORMAT@@@std@@QAEXPAW4_D3DFORMAT@@@Z ; std::allocator<enum _D3DFORMAT>::destroy
PUBLIC	?construct@?$allocator@W4_D3DFORMAT@@@std@@QAEXPAW4_D3DFORMAT@@ABW43@@Z ; std::allocator<enum _D3DFORMAT>::construct
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	SEGMENT
__catchsym$??$_Uninit_fill_n@PAW4_D3DFORMAT@@IW41@V?$allocator@W4_D3DFORMAT@@@std@@@std@@YAXPAW4_D3DFORMAT@@IABW41@AAV?$allocator@W4_D3DFORMAT@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_fill_n@PAW4_D3DFORMAT@@IW41@V?$allocator@W4_D3DFORMAT@@@std@@@std@@YAXPAW4_D3DFORMAT@@IABW41@AAV?$allocator@W4_D3DFORMAT@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__unwindtable$??$_Uninit_fill_n@PAW4_D3DFORMAT@@IW41@V?$allocator@W4_D3DFORMAT@@@std@@@std@@YAXPAW4_D3DFORMAT@@IABW41@AAV?$allocator@W4_D3DFORMAT@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Uninit_fill_n@PAW4_D3DFORMAT@@IW41@V?$allocator@W4_D3DFORMAT@@@std@@@std@@YAXPAW4_D3DFORMAT@@IABW41@AAV?$allocator@W4_D3DFORMAT@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_fill_n@PAW4_D3DFORMAT@@IW41@V?$allocator@W4_D3DFORMAT@@@std@@@std@@YAXPAW4_D3DFORMAT@@IABW41@AAV?$allocator@W4_D3DFORMAT@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2
__ehfuncinfo$??$_Uninit_fill_n@PAW4_D3DFORMAT@@IW41@V?$allocator@W4_D3DFORMAT@@@std@@@std@@YAXPAW4_D3DFORMAT@@IABW41@AAV?$allocator@W4_D3DFORMAT@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Uninit_fill_n@PAW4_D3DFORMAT@@IW41@V?$allocator@W4_D3DFORMAT@@@std@@@std@@YAXPAW4_D3DFORMAT@@IABW41@AAV?$allocator@W4_D3DFORMAT@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_fill_n@PAW4_D3DFORMAT@@IW41@V?$allocator@W4_D3DFORMAT@@@std@@@std@@YAXPAW4_D3DFORMAT@@IABW41@AAV?$allocator@W4_D3DFORMAT@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??$_Uninit_fill_n@PAW4_D3DFORMAT@@IW41@V?$allocator@W4_D3DFORMAT@@@std@@@std@@YAXPAW4_D3DFORMAT@@IABW41@AAV?$allocator@W4_D3DFORMAT@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_fill_n@PAW4_D3DFORMAT@@IW41@V?$allocator@W4_D3DFORMAT@@@std@@@std@@YAXPAW4_D3DFORMAT@@IABW41@AAV?$allocator@W4_D3DFORMAT@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<enum _D3DFORMAT *,unsigned int,enum _D3DFORMAT,std::allocator<enum _D3DFORMAT> >, COMDAT

; 393  : 	{	// copy _Count *_Val to raw _First, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_fill_n@PAW4_D3DFORMAT@@IW41@V?$allocator@W4_D3DFORMAT@@@std@@@std@@YAXPAW4_D3DFORMAT@@IABW41@AAV?$allocator@W4_D3DFORMAT@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 394  : 
; 395  :  #if _HAS_ITERATOR_DEBUGGING
; 396  : //	if (_Count < 0)
; 397  : //		_DEBUG_ERROR("negative count in uninitialized fill");
; 398  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 399  : 
; 400  : 	_FwdIt _Next = _First;

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Next$[ebp], eax

; 401  : 
; 402  : 	_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 403  : 	for (; 0 < _Count; --_Count, ++_First)

	jmp	SHORT $LN6@Uninit_fil
$LN5@Uninit_fil:
	mov	ecx, DWORD PTR __Count$[ebp]
	sub	ecx, 1
	mov	DWORD PTR __Count$[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	add	edx, 4
	mov	DWORD PTR __First$[ebp], edx
$LN6@Uninit_fil:
	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN4@Uninit_fil

; 404  : 		_Al.construct(_First, _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?construct@?$allocator@W4_D3DFORMAT@@@std@@QAEXPAW4_D3DFORMAT@@ABW43@@Z ; std::allocator<enum _D3DFORMAT>::construct
	jmp	SHORT $LN5@Uninit_fil
$LN4@Uninit_fil:
	jmp	SHORT $LN10@Uninit_fil
__catch$??$_Uninit_fill_n@PAW4_D3DFORMAT@@IW41@V?$allocator@W4_D3DFORMAT@@@std@@@std@@YAXPAW4_D3DFORMAT@@IABW41@AAV?$allocator@W4_D3DFORMAT@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 405  : 	_CATCH_ALL
; 406  : 	for (; _Next != _First; ++_Next)

	jmp	SHORT $LN3@Uninit_fil
$LN2@Uninit_fil:
	mov	edx, DWORD PTR __Next$[ebp]
	add	edx, 4
	mov	DWORD PTR __Next$[ebp], edx
$LN3@Uninit_fil:
	mov	eax, DWORD PTR __Next$[ebp]
	cmp	eax, DWORD PTR __First$[ebp]
	je	SHORT $LN1@Uninit_fil

; 407  : 		_Al.destroy(_Next);

	mov	ecx, DWORD PTR __Next$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?destroy@?$allocator@W4_D3DFORMAT@@@std@@QAEXPAW4_D3DFORMAT@@@Z ; std::allocator<enum _D3DFORMAT>::destroy
	jmp	SHORT $LN2@Uninit_fil
$LN1@Uninit_fil:

; 408  : 	_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 409  : 	_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, $LN9@Uninit_fil
	ret	0
$LN10@Uninit_fil:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
$LN9@Uninit_fil:

; 410  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_fill_n@PAW4_D3DFORMAT@@IW41@V?$allocator@W4_D3DFORMAT@@@std@@@std@@YAXPAW4_D3DFORMAT@@IABW41@AAV?$allocator@W4_D3DFORMAT@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_fill_n@PAW4_D3DFORMAT@@IW41@V?$allocator@W4_D3DFORMAT@@@std@@@std@@YAXPAW4_D3DFORMAT@@IABW41@AAV?$allocator@W4_D3DFORMAT@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_fill_n@PAW4_D3DFORMAT@@IW41@V?$allocator@W4_D3DFORMAT@@@std@@@std@@YAXPAW4_D3DFORMAT@@IABW41@AAV?$allocator@W4_D3DFORMAT@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<enum _D3DFORMAT *,unsigned int,enum _D3DFORMAT,std::allocator<enum _D3DFORMAT> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Ptr_cat@PAW4_D3DMULTISAMPLE_TYPE@@PAW41@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAW4_D3DMULTISAMPLE_TYPE@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAW4_D3DMULTISAMPLE_TYPE@@PAW41@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAW4_D3DMULTISAMPLE_TYPE@@0@Z PROC ; std::_Ptr_cat<enum _D3DMULTISAMPLE_TYPE *,enum _D3DMULTISAMPLE_TYPE *>, COMDAT

; 1509 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 1512 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Ptr_cat@PAW4_D3DMULTISAMPLE_TYPE@@PAW41@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAW4_D3DMULTISAMPLE_TYPE@@0@Z ENDP ; std::_Ptr_cat<enum _D3DMULTISAMPLE_TYPE *,enum _D3DMULTISAMPLE_TYPE *>
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@QAEXPAW4_D3DMULTISAMPLE_TYPE@@@Z ; std::allocator<enum _D3DMULTISAMPLE_TYPE>::destroy
PUBLIC	?construct@?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@QAEXPAW4_D3DMULTISAMPLE_TYPE@@ABW43@@Z ; std::allocator<enum _D3DMULTISAMPLE_TYPE>::construct
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	SEGMENT
__catchsym$??$_Uninit_fill_n@PAW4_D3DMULTISAMPLE_TYPE@@IW41@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@YAXPAW4_D3DMULTISAMPLE_TYPE@@IABW41@AAV?$allocator@W4_D3DMULTISAMPLE_TYPE@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_fill_n@PAW4_D3DMULTISAMPLE_TYPE@@IW41@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@YAXPAW4_D3DMULTISAMPLE_TYPE@@IABW41@AAV?$allocator@W4_D3DMULTISAMPLE_TYPE@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__unwindtable$??$_Uninit_fill_n@PAW4_D3DMULTISAMPLE_TYPE@@IW41@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@YAXPAW4_D3DMULTISAMPLE_TYPE@@IABW41@AAV?$allocator@W4_D3DMULTISAMPLE_TYPE@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Uninit_fill_n@PAW4_D3DMULTISAMPLE_TYPE@@IW41@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@YAXPAW4_D3DMULTISAMPLE_TYPE@@IABW41@AAV?$allocator@W4_D3DMULTISAMPLE_TYPE@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_fill_n@PAW4_D3DMULTISAMPLE_TYPE@@IW41@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@YAXPAW4_D3DMULTISAMPLE_TYPE@@IABW41@AAV?$allocator@W4_D3DMULTISAMPLE_TYPE@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2
__ehfuncinfo$??$_Uninit_fill_n@PAW4_D3DMULTISAMPLE_TYPE@@IW41@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@YAXPAW4_D3DMULTISAMPLE_TYPE@@IABW41@AAV?$allocator@W4_D3DMULTISAMPLE_TYPE@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Uninit_fill_n@PAW4_D3DMULTISAMPLE_TYPE@@IW41@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@YAXPAW4_D3DMULTISAMPLE_TYPE@@IABW41@AAV?$allocator@W4_D3DMULTISAMPLE_TYPE@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_fill_n@PAW4_D3DMULTISAMPLE_TYPE@@IW41@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@YAXPAW4_D3DMULTISAMPLE_TYPE@@IABW41@AAV?$allocator@W4_D3DMULTISAMPLE_TYPE@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??$_Uninit_fill_n@PAW4_D3DMULTISAMPLE_TYPE@@IW41@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@YAXPAW4_D3DMULTISAMPLE_TYPE@@IABW41@AAV?$allocator@W4_D3DMULTISAMPLE_TYPE@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_fill_n@PAW4_D3DMULTISAMPLE_TYPE@@IW41@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@YAXPAW4_D3DMULTISAMPLE_TYPE@@IABW41@AAV?$allocator@W4_D3DMULTISAMPLE_TYPE@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<enum _D3DMULTISAMPLE_TYPE *,unsigned int,enum _D3DMULTISAMPLE_TYPE,std::allocator<enum _D3DMULTISAMPLE_TYPE> >, COMDAT

; 393  : 	{	// copy _Count *_Val to raw _First, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_fill_n@PAW4_D3DMULTISAMPLE_TYPE@@IW41@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@YAXPAW4_D3DMULTISAMPLE_TYPE@@IABW41@AAV?$allocator@W4_D3DMULTISAMPLE_TYPE@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 394  : 
; 395  :  #if _HAS_ITERATOR_DEBUGGING
; 396  : //	if (_Count < 0)
; 397  : //		_DEBUG_ERROR("negative count in uninitialized fill");
; 398  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 399  : 
; 400  : 	_FwdIt _Next = _First;

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Next$[ebp], eax

; 401  : 
; 402  : 	_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 403  : 	for (; 0 < _Count; --_Count, ++_First)

	jmp	SHORT $LN6@Uninit_fil@2
$LN5@Uninit_fil@2:
	mov	ecx, DWORD PTR __Count$[ebp]
	sub	ecx, 1
	mov	DWORD PTR __Count$[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	add	edx, 4
	mov	DWORD PTR __First$[ebp], edx
$LN6@Uninit_fil@2:
	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN4@Uninit_fil@2

; 404  : 		_Al.construct(_First, _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?construct@?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@QAEXPAW4_D3DMULTISAMPLE_TYPE@@ABW43@@Z ; std::allocator<enum _D3DMULTISAMPLE_TYPE>::construct
	jmp	SHORT $LN5@Uninit_fil@2
$LN4@Uninit_fil@2:
	jmp	SHORT $LN10@Uninit_fil@2
__catch$??$_Uninit_fill_n@PAW4_D3DMULTISAMPLE_TYPE@@IW41@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@YAXPAW4_D3DMULTISAMPLE_TYPE@@IABW41@AAV?$allocator@W4_D3DMULTISAMPLE_TYPE@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 405  : 	_CATCH_ALL
; 406  : 	for (; _Next != _First; ++_Next)

	jmp	SHORT $LN3@Uninit_fil@2
$LN2@Uninit_fil@2:
	mov	edx, DWORD PTR __Next$[ebp]
	add	edx, 4
	mov	DWORD PTR __Next$[ebp], edx
$LN3@Uninit_fil@2:
	mov	eax, DWORD PTR __Next$[ebp]
	cmp	eax, DWORD PTR __First$[ebp]
	je	SHORT $LN1@Uninit_fil@2

; 407  : 		_Al.destroy(_Next);

	mov	ecx, DWORD PTR __Next$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?destroy@?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@QAEXPAW4_D3DMULTISAMPLE_TYPE@@@Z ; std::allocator<enum _D3DMULTISAMPLE_TYPE>::destroy
	jmp	SHORT $LN2@Uninit_fil@2
$LN1@Uninit_fil@2:

; 408  : 	_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 409  : 	_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, $LN9@Uninit_fil@2
	ret	0
$LN10@Uninit_fil@2:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
$LN9@Uninit_fil@2:

; 410  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_fill_n@PAW4_D3DMULTISAMPLE_TYPE@@IW41@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@YAXPAW4_D3DMULTISAMPLE_TYPE@@IABW41@AAV?$allocator@W4_D3DMULTISAMPLE_TYPE@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_fill_n@PAW4_D3DMULTISAMPLE_TYPE@@IW41@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@YAXPAW4_D3DMULTISAMPLE_TYPE@@IABW41@AAV?$allocator@W4_D3DMULTISAMPLE_TYPE@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_fill_n@PAW4_D3DMULTISAMPLE_TYPE@@IW41@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@YAXPAW4_D3DMULTISAMPLE_TYPE@@IABW41@AAV?$allocator@W4_D3DMULTISAMPLE_TYPE@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<enum _D3DMULTISAMPLE_TYPE *,unsigned int,enum _D3DMULTISAMPLE_TYPE,std::allocator<enum _D3DMULTISAMPLE_TYPE> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Ptr_cat@PAIPAI@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAI0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAIPAI@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAI0@Z PROC ; std::_Ptr_cat<unsigned int *,unsigned int *>, COMDAT

; 1509 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 1512 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Ptr_cat@PAIPAI@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAI0@Z ENDP ; std::_Ptr_cat<unsigned int *,unsigned int *>
_TEXT	ENDS
PUBLIC	??$unchecked_fill_n@PAIII@stdext@@YAXPAIIABI@Z	; stdext::unchecked_fill_n<unsigned int *,unsigned int,unsigned int>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Uninit_fill_n@PAIIIV?$allocator@I@std@@@std@@YAXPAIIABIAAV?$allocator@I@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_fill_n@PAIIIV?$allocator@I@std@@@std@@YAXPAIIABIAAV?$allocator@I@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<unsigned int *,unsigned int,unsigned int,std::allocator<unsigned int> >, COMDAT

; 418  : 	{	// copy _Count *_Val to raw _First, using _Al, scalar type

	push	ebp
	mov	ebp, esp

; 419  : 		_STDEXT unchecked_fill_n(_First, _Count, _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$unchecked_fill_n@PAIII@stdext@@YAXPAIIABI@Z ; stdext::unchecked_fill_n<unsigned int *,unsigned int,unsigned int>
	add	esp, 12					; 0000000cH

; 420  : 	}

	pop	ebp
	ret	0
??$_Uninit_fill_n@PAIIIV?$allocator@I@std@@@std@@YAXPAIIABIAAV?$allocator@I@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<unsigned int *,unsigned int,unsigned int,std::allocator<unsigned int> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAUD3DSMSCONFLICT_T@Ogre@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUD3DSMSCONFLICT_T@Ogre@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAUD3DSMSCONFLICT_T@Ogre@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUD3DSMSCONFLICT_T@Ogre@@0@Z PROC ; std::_Ptr_cat<Ogre::D3DSMSCONFLICT_T *,Ogre::D3DSMSCONFLICT_T *>, COMDAT

; 1509 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 1512 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Ptr_cat@PAUD3DSMSCONFLICT_T@Ogre@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUD3DSMSCONFLICT_T@Ogre@@0@Z ENDP ; std::_Ptr_cat<Ogre::D3DSMSCONFLICT_T *,Ogre::D3DSMSCONFLICT_T *>
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@QAEXPAUD3DSMSCONFLICT_T@Ogre@@@Z ; std::allocator<Ogre::D3DSMSCONFLICT_T>::destroy
PUBLIC	?construct@?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@QAEXPAUD3DSMSCONFLICT_T@Ogre@@ABU34@@Z ; std::allocator<Ogre::D3DSMSCONFLICT_T>::construct
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	SEGMENT
__catchsym$??$_Uninit_fill_n@PAUD3DSMSCONFLICT_T@Ogre@@IU12@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@YAXPAUD3DSMSCONFLICT_T@Ogre@@IABU12@AAV?$allocator@UD3DSMSCONFLICT_T@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_fill_n@PAUD3DSMSCONFLICT_T@Ogre@@IU12@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@YAXPAUD3DSMSCONFLICT_T@Ogre@@IABU12@AAV?$allocator@UD3DSMSCONFLICT_T@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__unwindtable$??$_Uninit_fill_n@PAUD3DSMSCONFLICT_T@Ogre@@IU12@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@YAXPAUD3DSMSCONFLICT_T@Ogre@@IABU12@AAV?$allocator@UD3DSMSCONFLICT_T@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Uninit_fill_n@PAUD3DSMSCONFLICT_T@Ogre@@IU12@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@YAXPAUD3DSMSCONFLICT_T@Ogre@@IABU12@AAV?$allocator@UD3DSMSCONFLICT_T@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_fill_n@PAUD3DSMSCONFLICT_T@Ogre@@IU12@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@YAXPAUD3DSMSCONFLICT_T@Ogre@@IABU12@AAV?$allocator@UD3DSMSCONFLICT_T@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2
__ehfuncinfo$??$_Uninit_fill_n@PAUD3DSMSCONFLICT_T@Ogre@@IU12@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@YAXPAUD3DSMSCONFLICT_T@Ogre@@IABU12@AAV?$allocator@UD3DSMSCONFLICT_T@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Uninit_fill_n@PAUD3DSMSCONFLICT_T@Ogre@@IU12@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@YAXPAUD3DSMSCONFLICT_T@Ogre@@IABU12@AAV?$allocator@UD3DSMSCONFLICT_T@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_fill_n@PAUD3DSMSCONFLICT_T@Ogre@@IU12@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@YAXPAUD3DSMSCONFLICT_T@Ogre@@IABU12@AAV?$allocator@UD3DSMSCONFLICT_T@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??$_Uninit_fill_n@PAUD3DSMSCONFLICT_T@Ogre@@IU12@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@YAXPAUD3DSMSCONFLICT_T@Ogre@@IABU12@AAV?$allocator@UD3DSMSCONFLICT_T@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_fill_n@PAUD3DSMSCONFLICT_T@Ogre@@IU12@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@YAXPAUD3DSMSCONFLICT_T@Ogre@@IABU12@AAV?$allocator@UD3DSMSCONFLICT_T@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<Ogre::D3DSMSCONFLICT_T *,unsigned int,Ogre::D3DSMSCONFLICT_T,std::allocator<Ogre::D3DSMSCONFLICT_T> >, COMDAT

; 393  : 	{	// copy _Count *_Val to raw _First, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_fill_n@PAUD3DSMSCONFLICT_T@Ogre@@IU12@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@YAXPAUD3DSMSCONFLICT_T@Ogre@@IABU12@AAV?$allocator@UD3DSMSCONFLICT_T@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 394  : 
; 395  :  #if _HAS_ITERATOR_DEBUGGING
; 396  : //	if (_Count < 0)
; 397  : //		_DEBUG_ERROR("negative count in uninitialized fill");
; 398  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 399  : 
; 400  : 	_FwdIt _Next = _First;

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Next$[ebp], eax

; 401  : 
; 402  : 	_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 403  : 	for (; 0 < _Count; --_Count, ++_First)

	jmp	SHORT $LN6@Uninit_fil@3
$LN5@Uninit_fil@3:
	mov	ecx, DWORD PTR __Count$[ebp]
	sub	ecx, 1
	mov	DWORD PTR __Count$[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	add	edx, 8
	mov	DWORD PTR __First$[ebp], edx
$LN6@Uninit_fil@3:
	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN4@Uninit_fil@3

; 404  : 		_Al.construct(_First, _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?construct@?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@QAEXPAUD3DSMSCONFLICT_T@Ogre@@ABU34@@Z ; std::allocator<Ogre::D3DSMSCONFLICT_T>::construct
	jmp	SHORT $LN5@Uninit_fil@3
$LN4@Uninit_fil@3:
	jmp	SHORT $LN10@Uninit_fil@3
__catch$??$_Uninit_fill_n@PAUD3DSMSCONFLICT_T@Ogre@@IU12@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@YAXPAUD3DSMSCONFLICT_T@Ogre@@IABU12@AAV?$allocator@UD3DSMSCONFLICT_T@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 405  : 	_CATCH_ALL
; 406  : 	for (; _Next != _First; ++_Next)

	jmp	SHORT $LN3@Uninit_fil@3
$LN2@Uninit_fil@3:
	mov	edx, DWORD PTR __Next$[ebp]
	add	edx, 8
	mov	DWORD PTR __Next$[ebp], edx
$LN3@Uninit_fil@3:
	mov	eax, DWORD PTR __Next$[ebp]
	cmp	eax, DWORD PTR __First$[ebp]
	je	SHORT $LN1@Uninit_fil@3

; 407  : 		_Al.destroy(_Next);

	mov	ecx, DWORD PTR __Next$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?destroy@?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@QAEXPAUD3DSMSCONFLICT_T@Ogre@@@Z ; std::allocator<Ogre::D3DSMSCONFLICT_T>::destroy
	jmp	SHORT $LN2@Uninit_fil@3
$LN1@Uninit_fil@3:

; 408  : 	_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 409  : 	_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, $LN9@Uninit_fil@3
	ret	0
$LN10@Uninit_fil@3:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
$LN9@Uninit_fil@3:

; 410  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_fill_n@PAUD3DSMSCONFLICT_T@Ogre@@IU12@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@YAXPAUD3DSMSCONFLICT_T@Ogre@@IABU12@AAV?$allocator@UD3DSMSCONFLICT_T@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_fill_n@PAUD3DSMSCONFLICT_T@Ogre@@IU12@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@YAXPAUD3DSMSCONFLICT_T@Ogre@@IABU12@AAV?$allocator@UD3DSMSCONFLICT_T@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_fill_n@PAUD3DSMSCONFLICT_T@Ogre@@IU12@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@YAXPAUD3DSMSCONFLICT_T@Ogre@@IABU12@AAV?$allocator@UD3DSMSCONFLICT_T@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<Ogre::D3DSMSCONFLICT_T *,unsigned int,Ogre::D3DSMSCONFLICT_T,std::allocator<Ogre::D3DSMSCONFLICT_T> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Ptr_cat@PAW4VERTPROCESS_T@Ogre@@PAW412@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAW4VERTPROCESS_T@Ogre@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAW4VERTPROCESS_T@Ogre@@PAW412@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAW4VERTPROCESS_T@Ogre@@0@Z PROC ; std::_Ptr_cat<enum Ogre::VERTPROCESS_T *,enum Ogre::VERTPROCESS_T *>, COMDAT

; 1509 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 1512 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Ptr_cat@PAW4VERTPROCESS_T@Ogre@@PAW412@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAW4VERTPROCESS_T@Ogre@@0@Z ENDP ; std::_Ptr_cat<enum Ogre::VERTPROCESS_T *,enum Ogre::VERTPROCESS_T *>
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@W4VERTPROCESS_T@Ogre@@@std@@QAEXPAW4VERTPROCESS_T@Ogre@@@Z ; std::allocator<enum Ogre::VERTPROCESS_T>::destroy
PUBLIC	?construct@?$allocator@W4VERTPROCESS_T@Ogre@@@std@@QAEXPAW4VERTPROCESS_T@Ogre@@ABW434@@Z ; std::allocator<enum Ogre::VERTPROCESS_T>::construct
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	SEGMENT
__catchsym$??$_Uninit_fill_n@PAW4VERTPROCESS_T@Ogre@@IW412@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@YAXPAW4VERTPROCESS_T@Ogre@@IABW412@AAV?$allocator@W4VERTPROCESS_T@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_fill_n@PAW4VERTPROCESS_T@Ogre@@IW412@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@YAXPAW4VERTPROCESS_T@Ogre@@IABW412@AAV?$allocator@W4VERTPROCESS_T@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__unwindtable$??$_Uninit_fill_n@PAW4VERTPROCESS_T@Ogre@@IW412@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@YAXPAW4VERTPROCESS_T@Ogre@@IABW412@AAV?$allocator@W4VERTPROCESS_T@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Uninit_fill_n@PAW4VERTPROCESS_T@Ogre@@IW412@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@YAXPAW4VERTPROCESS_T@Ogre@@IABW412@AAV?$allocator@W4VERTPROCESS_T@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_fill_n@PAW4VERTPROCESS_T@Ogre@@IW412@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@YAXPAW4VERTPROCESS_T@Ogre@@IABW412@AAV?$allocator@W4VERTPROCESS_T@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2
__ehfuncinfo$??$_Uninit_fill_n@PAW4VERTPROCESS_T@Ogre@@IW412@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@YAXPAW4VERTPROCESS_T@Ogre@@IABW412@AAV?$allocator@W4VERTPROCESS_T@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Uninit_fill_n@PAW4VERTPROCESS_T@Ogre@@IW412@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@YAXPAW4VERTPROCESS_T@Ogre@@IABW412@AAV?$allocator@W4VERTPROCESS_T@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_fill_n@PAW4VERTPROCESS_T@Ogre@@IW412@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@YAXPAW4VERTPROCESS_T@Ogre@@IABW412@AAV?$allocator@W4VERTPROCESS_T@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??$_Uninit_fill_n@PAW4VERTPROCESS_T@Ogre@@IW412@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@YAXPAW4VERTPROCESS_T@Ogre@@IABW412@AAV?$allocator@W4VERTPROCESS_T@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_fill_n@PAW4VERTPROCESS_T@Ogre@@IW412@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@YAXPAW4VERTPROCESS_T@Ogre@@IABW412@AAV?$allocator@W4VERTPROCESS_T@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<enum Ogre::VERTPROCESS_T *,unsigned int,enum Ogre::VERTPROCESS_T,std::allocator<enum Ogre::VERTPROCESS_T> >, COMDAT

; 393  : 	{	// copy _Count *_Val to raw _First, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_fill_n@PAW4VERTPROCESS_T@Ogre@@IW412@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@YAXPAW4VERTPROCESS_T@Ogre@@IABW412@AAV?$allocator@W4VERTPROCESS_T@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 394  : 
; 395  :  #if _HAS_ITERATOR_DEBUGGING
; 396  : //	if (_Count < 0)
; 397  : //		_DEBUG_ERROR("negative count in uninitialized fill");
; 398  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 399  : 
; 400  : 	_FwdIt _Next = _First;

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Next$[ebp], eax

; 401  : 
; 402  : 	_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 403  : 	for (; 0 < _Count; --_Count, ++_First)

	jmp	SHORT $LN6@Uninit_fil@4
$LN5@Uninit_fil@4:
	mov	ecx, DWORD PTR __Count$[ebp]
	sub	ecx, 1
	mov	DWORD PTR __Count$[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	add	edx, 4
	mov	DWORD PTR __First$[ebp], edx
$LN6@Uninit_fil@4:
	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN4@Uninit_fil@4

; 404  : 		_Al.construct(_First, _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?construct@?$allocator@W4VERTPROCESS_T@Ogre@@@std@@QAEXPAW4VERTPROCESS_T@Ogre@@ABW434@@Z ; std::allocator<enum Ogre::VERTPROCESS_T>::construct
	jmp	SHORT $LN5@Uninit_fil@4
$LN4@Uninit_fil@4:
	jmp	SHORT $LN10@Uninit_fil@4
__catch$??$_Uninit_fill_n@PAW4VERTPROCESS_T@Ogre@@IW412@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@YAXPAW4VERTPROCESS_T@Ogre@@IABW412@AAV?$allocator@W4VERTPROCESS_T@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 405  : 	_CATCH_ALL
; 406  : 	for (; _Next != _First; ++_Next)

	jmp	SHORT $LN3@Uninit_fil@4
$LN2@Uninit_fil@4:
	mov	edx, DWORD PTR __Next$[ebp]
	add	edx, 4
	mov	DWORD PTR __Next$[ebp], edx
$LN3@Uninit_fil@4:
	mov	eax, DWORD PTR __Next$[ebp]
	cmp	eax, DWORD PTR __First$[ebp]
	je	SHORT $LN1@Uninit_fil@4

; 407  : 		_Al.destroy(_Next);

	mov	ecx, DWORD PTR __Next$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?destroy@?$allocator@W4VERTPROCESS_T@Ogre@@@std@@QAEXPAW4VERTPROCESS_T@Ogre@@@Z ; std::allocator<enum Ogre::VERTPROCESS_T>::destroy
	jmp	SHORT $LN2@Uninit_fil@4
$LN1@Uninit_fil@4:

; 408  : 	_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 409  : 	_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, $LN9@Uninit_fil@4
	ret	0
$LN10@Uninit_fil@4:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
$LN9@Uninit_fil@4:

; 410  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_fill_n@PAW4VERTPROCESS_T@Ogre@@IW412@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@YAXPAW4VERTPROCESS_T@Ogre@@IABW412@AAV?$allocator@W4VERTPROCESS_T@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_fill_n@PAW4VERTPROCESS_T@Ogre@@IW412@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@YAXPAW4VERTPROCESS_T@Ogre@@IABW412@AAV?$allocator@W4VERTPROCESS_T@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_fill_n@PAW4VERTPROCESS_T@Ogre@@IW412@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@YAXPAW4VERTPROCESS_T@Ogre@@IABW412@AAV?$allocator@W4VERTPROCESS_T@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<enum Ogre::VERTPROCESS_T *,unsigned int,enum Ogre::VERTPROCESS_T,std::allocator<enum Ogre::VERTPROCESS_T> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Ptr_cat@PAPAUD3DDEVCOMBO_T@Ogre@@PAPAU12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAUD3DDEVCOMBO_T@Ogre@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAPAUD3DDEVCOMBO_T@Ogre@@PAPAU12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAUD3DDEVCOMBO_T@Ogre@@0@Z PROC ; std::_Ptr_cat<Ogre::D3DDEVCOMBO_T * *,Ogre::D3DDEVCOMBO_T * *>, COMDAT

; 1509 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 1512 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Ptr_cat@PAPAUD3DDEVCOMBO_T@Ogre@@PAPAU12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAUD3DDEVCOMBO_T@Ogre@@0@Z ENDP ; std::_Ptr_cat<Ogre::D3DDEVCOMBO_T * *,Ogre::D3DDEVCOMBO_T * *>
_TEXT	ENDS
PUBLIC	??$unchecked_fill_n@PAPAUD3DDEVCOMBO_T@Ogre@@IPAU12@@stdext@@YAXPAPAUD3DDEVCOMBO_T@Ogre@@IABQAU12@@Z ; stdext::unchecked_fill_n<Ogre::D3DDEVCOMBO_T * *,unsigned int,Ogre::D3DDEVCOMBO_T *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Uninit_fill_n@PAPAUD3DDEVCOMBO_T@Ogre@@IPAU12@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@YAXPAPAUD3DDEVCOMBO_T@Ogre@@IABQAU12@AAV?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_fill_n@PAPAUD3DDEVCOMBO_T@Ogre@@IPAU12@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@YAXPAPAUD3DDEVCOMBO_T@Ogre@@IABQAU12@AAV?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<Ogre::D3DDEVCOMBO_T * *,unsigned int,Ogre::D3DDEVCOMBO_T *,std::allocator<Ogre::D3DDEVCOMBO_T *> >, COMDAT

; 418  : 	{	// copy _Count *_Val to raw _First, using _Al, scalar type

	push	ebp
	mov	ebp, esp

; 419  : 		_STDEXT unchecked_fill_n(_First, _Count, _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$unchecked_fill_n@PAPAUD3DDEVCOMBO_T@Ogre@@IPAU12@@stdext@@YAXPAPAUD3DDEVCOMBO_T@Ogre@@IABQAU12@@Z ; stdext::unchecked_fill_n<Ogre::D3DDEVCOMBO_T * *,unsigned int,Ogre::D3DDEVCOMBO_T *>
	add	esp, 12					; 0000000cH

; 420  : 	}

	pop	ebp
	ret	0
??$_Uninit_fill_n@PAPAUD3DDEVCOMBO_T@Ogre@@IPAU12@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@YAXPAPAUD3DDEVCOMBO_T@Ogre@@IABQAU12@AAV?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<Ogre::D3DDEVCOMBO_T * *,unsigned int,Ogre::D3DDEVCOMBO_T *,std::allocator<Ogre::D3DDEVCOMBO_T *> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAU_D3DDISPLAYMODE@@PAU1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAU_D3DDISPLAYMODE@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAU_D3DDISPLAYMODE@@PAU1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAU_D3DDISPLAYMODE@@0@Z PROC ; std::_Ptr_cat<_D3DDISPLAYMODE *,_D3DDISPLAYMODE *>, COMDAT

; 1509 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 1512 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Ptr_cat@PAU_D3DDISPLAYMODE@@PAU1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAU_D3DDISPLAYMODE@@0@Z ENDP ; std::_Ptr_cat<_D3DDISPLAYMODE *,_D3DDISPLAYMODE *>
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@U_D3DDISPLAYMODE@@@std@@QAEXPAU_D3DDISPLAYMODE@@@Z ; std::allocator<_D3DDISPLAYMODE>::destroy
PUBLIC	?construct@?$allocator@U_D3DDISPLAYMODE@@@std@@QAEXPAU_D3DDISPLAYMODE@@ABU3@@Z ; std::allocator<_D3DDISPLAYMODE>::construct
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	SEGMENT
__catchsym$??$_Uninit_fill_n@PAU_D3DDISPLAYMODE@@IU1@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@YAXPAU_D3DDISPLAYMODE@@IABU1@AAV?$allocator@U_D3DDISPLAYMODE@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_fill_n@PAU_D3DDISPLAYMODE@@IU1@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@YAXPAU_D3DDISPLAYMODE@@IABU1@AAV?$allocator@U_D3DDISPLAYMODE@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__unwindtable$??$_Uninit_fill_n@PAU_D3DDISPLAYMODE@@IU1@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@YAXPAU_D3DDISPLAYMODE@@IABU1@AAV?$allocator@U_D3DDISPLAYMODE@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Uninit_fill_n@PAU_D3DDISPLAYMODE@@IU1@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@YAXPAU_D3DDISPLAYMODE@@IABU1@AAV?$allocator@U_D3DDISPLAYMODE@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_fill_n@PAU_D3DDISPLAYMODE@@IU1@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@YAXPAU_D3DDISPLAYMODE@@IABU1@AAV?$allocator@U_D3DDISPLAYMODE@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2
__ehfuncinfo$??$_Uninit_fill_n@PAU_D3DDISPLAYMODE@@IU1@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@YAXPAU_D3DDISPLAYMODE@@IABU1@AAV?$allocator@U_D3DDISPLAYMODE@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Uninit_fill_n@PAU_D3DDISPLAYMODE@@IU1@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@YAXPAU_D3DDISPLAYMODE@@IABU1@AAV?$allocator@U_D3DDISPLAYMODE@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_fill_n@PAU_D3DDISPLAYMODE@@IU1@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@YAXPAU_D3DDISPLAYMODE@@IABU1@AAV?$allocator@U_D3DDISPLAYMODE@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??$_Uninit_fill_n@PAU_D3DDISPLAYMODE@@IU1@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@YAXPAU_D3DDISPLAYMODE@@IABU1@AAV?$allocator@U_D3DDISPLAYMODE@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_fill_n@PAU_D3DDISPLAYMODE@@IU1@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@YAXPAU_D3DDISPLAYMODE@@IABU1@AAV?$allocator@U_D3DDISPLAYMODE@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<_D3DDISPLAYMODE *,unsigned int,_D3DDISPLAYMODE,std::allocator<_D3DDISPLAYMODE> >, COMDAT

; 393  : 	{	// copy _Count *_Val to raw _First, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_fill_n@PAU_D3DDISPLAYMODE@@IU1@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@YAXPAU_D3DDISPLAYMODE@@IABU1@AAV?$allocator@U_D3DDISPLAYMODE@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 394  : 
; 395  :  #if _HAS_ITERATOR_DEBUGGING
; 396  : //	if (_Count < 0)
; 397  : //		_DEBUG_ERROR("negative count in uninitialized fill");
; 398  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 399  : 
; 400  : 	_FwdIt _Next = _First;

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Next$[ebp], eax

; 401  : 
; 402  : 	_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 403  : 	for (; 0 < _Count; --_Count, ++_First)

	jmp	SHORT $LN6@Uninit_fil@5
$LN5@Uninit_fil@5:
	mov	ecx, DWORD PTR __Count$[ebp]
	sub	ecx, 1
	mov	DWORD PTR __Count$[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	add	edx, 16					; 00000010H
	mov	DWORD PTR __First$[ebp], edx
$LN6@Uninit_fil@5:
	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN4@Uninit_fil@5

; 404  : 		_Al.construct(_First, _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?construct@?$allocator@U_D3DDISPLAYMODE@@@std@@QAEXPAU_D3DDISPLAYMODE@@ABU3@@Z ; std::allocator<_D3DDISPLAYMODE>::construct
	jmp	SHORT $LN5@Uninit_fil@5
$LN4@Uninit_fil@5:
	jmp	SHORT $LN10@Uninit_fil@5
__catch$??$_Uninit_fill_n@PAU_D3DDISPLAYMODE@@IU1@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@YAXPAU_D3DDISPLAYMODE@@IABU1@AAV?$allocator@U_D3DDISPLAYMODE@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 405  : 	_CATCH_ALL
; 406  : 	for (; _Next != _First; ++_Next)

	jmp	SHORT $LN3@Uninit_fil@5
$LN2@Uninit_fil@5:
	mov	edx, DWORD PTR __Next$[ebp]
	add	edx, 16					; 00000010H
	mov	DWORD PTR __Next$[ebp], edx
$LN3@Uninit_fil@5:
	mov	eax, DWORD PTR __Next$[ebp]
	cmp	eax, DWORD PTR __First$[ebp]
	je	SHORT $LN1@Uninit_fil@5

; 407  : 		_Al.destroy(_Next);

	mov	ecx, DWORD PTR __Next$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?destroy@?$allocator@U_D3DDISPLAYMODE@@@std@@QAEXPAU_D3DDISPLAYMODE@@@Z ; std::allocator<_D3DDISPLAYMODE>::destroy
	jmp	SHORT $LN2@Uninit_fil@5
$LN1@Uninit_fil@5:

; 408  : 	_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 409  : 	_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, $LN9@Uninit_fil@5
	ret	0
$LN10@Uninit_fil@5:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
$LN9@Uninit_fil@5:

; 410  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_fill_n@PAU_D3DDISPLAYMODE@@IU1@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@YAXPAU_D3DDISPLAYMODE@@IABU1@AAV?$allocator@U_D3DDISPLAYMODE@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_fill_n@PAU_D3DDISPLAYMODE@@IU1@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@YAXPAU_D3DDISPLAYMODE@@IABU1@AAV?$allocator@U_D3DDISPLAYMODE@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_fill_n@PAU_D3DDISPLAYMODE@@IU1@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@YAXPAU_D3DDISPLAYMODE@@IABU1@AAV?$allocator@U_D3DDISPLAYMODE@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<_D3DDISPLAYMODE *,unsigned int,_D3DDISPLAYMODE,std::allocator<_D3DDISPLAYMODE> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Ptr_cat@PAPAUD3DDEVICEINFO_T@Ogre@@PAPAU12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAUD3DDEVICEINFO_T@Ogre@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAPAUD3DDEVICEINFO_T@Ogre@@PAPAU12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAUD3DDEVICEINFO_T@Ogre@@0@Z PROC ; std::_Ptr_cat<Ogre::D3DDEVICEINFO_T * *,Ogre::D3DDEVICEINFO_T * *>, COMDAT

; 1509 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 1512 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Ptr_cat@PAPAUD3DDEVICEINFO_T@Ogre@@PAPAU12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAUD3DDEVICEINFO_T@Ogre@@0@Z ENDP ; std::_Ptr_cat<Ogre::D3DDEVICEINFO_T * *,Ogre::D3DDEVICEINFO_T * *>
_TEXT	ENDS
PUBLIC	??$unchecked_fill_n@PAPAUD3DDEVICEINFO_T@Ogre@@IPAU12@@stdext@@YAXPAPAUD3DDEVICEINFO_T@Ogre@@IABQAU12@@Z ; stdext::unchecked_fill_n<Ogre::D3DDEVICEINFO_T * *,unsigned int,Ogre::D3DDEVICEINFO_T *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Uninit_fill_n@PAPAUD3DDEVICEINFO_T@Ogre@@IPAU12@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@YAXPAPAUD3DDEVICEINFO_T@Ogre@@IABQAU12@AAV?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_fill_n@PAPAUD3DDEVICEINFO_T@Ogre@@IPAU12@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@YAXPAPAUD3DDEVICEINFO_T@Ogre@@IABQAU12@AAV?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<Ogre::D3DDEVICEINFO_T * *,unsigned int,Ogre::D3DDEVICEINFO_T *,std::allocator<Ogre::D3DDEVICEINFO_T *> >, COMDAT

; 418  : 	{	// copy _Count *_Val to raw _First, using _Al, scalar type

	push	ebp
	mov	ebp, esp

; 419  : 		_STDEXT unchecked_fill_n(_First, _Count, _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$unchecked_fill_n@PAPAUD3DDEVICEINFO_T@Ogre@@IPAU12@@stdext@@YAXPAPAUD3DDEVICEINFO_T@Ogre@@IABQAU12@@Z ; stdext::unchecked_fill_n<Ogre::D3DDEVICEINFO_T * *,unsigned int,Ogre::D3DDEVICEINFO_T *>
	add	esp, 12					; 0000000cH

; 420  : 	}

	pop	ebp
	ret	0
??$_Uninit_fill_n@PAPAUD3DDEVICEINFO_T@Ogre@@IPAU12@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@YAXPAPAUD3DDEVICEINFO_T@Ogre@@IABQAU12@AAV?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<Ogre::D3DDEVICEINFO_T * *,unsigned int,Ogre::D3DDEVICEINFO_T *,std::allocator<Ogre::D3DDEVICEINFO_T *> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAPAUD3DADAPTER_T@Ogre@@PAPAU12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAUD3DADAPTER_T@Ogre@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAPAUD3DADAPTER_T@Ogre@@PAPAU12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAUD3DADAPTER_T@Ogre@@0@Z PROC ; std::_Ptr_cat<Ogre::D3DADAPTER_T * *,Ogre::D3DADAPTER_T * *>, COMDAT

; 1509 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 1512 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Ptr_cat@PAPAUD3DADAPTER_T@Ogre@@PAPAU12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAUD3DADAPTER_T@Ogre@@0@Z ENDP ; std::_Ptr_cat<Ogre::D3DADAPTER_T * *,Ogre::D3DADAPTER_T * *>
_TEXT	ENDS
PUBLIC	??$unchecked_fill_n@PAPAUD3DADAPTER_T@Ogre@@IPAU12@@stdext@@YAXPAPAUD3DADAPTER_T@Ogre@@IABQAU12@@Z ; stdext::unchecked_fill_n<Ogre::D3DADAPTER_T * *,unsigned int,Ogre::D3DADAPTER_T *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Uninit_fill_n@PAPAUD3DADAPTER_T@Ogre@@IPAU12@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@YAXPAPAUD3DADAPTER_T@Ogre@@IABQAU12@AAV?$allocator@PAUD3DADAPTER_T@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_fill_n@PAPAUD3DADAPTER_T@Ogre@@IPAU12@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@YAXPAPAUD3DADAPTER_T@Ogre@@IABQAU12@AAV?$allocator@PAUD3DADAPTER_T@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<Ogre::D3DADAPTER_T * *,unsigned int,Ogre::D3DADAPTER_T *,std::allocator<Ogre::D3DADAPTER_T *> >, COMDAT

; 418  : 	{	// copy _Count *_Val to raw _First, using _Al, scalar type

	push	ebp
	mov	ebp, esp

; 419  : 		_STDEXT unchecked_fill_n(_First, _Count, _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$unchecked_fill_n@PAPAUD3DADAPTER_T@Ogre@@IPAU12@@stdext@@YAXPAPAUD3DADAPTER_T@Ogre@@IABQAU12@@Z ; stdext::unchecked_fill_n<Ogre::D3DADAPTER_T * *,unsigned int,Ogre::D3DADAPTER_T *>
	add	esp, 12					; 0000000cH

; 420  : 	}

	pop	ebp
	ret	0
??$_Uninit_fill_n@PAPAUD3DADAPTER_T@Ogre@@IPAU12@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@YAXPAPAUD3DADAPTER_T@Ogre@@IABQAU12@AAV?$allocator@PAUD3DADAPTER_T@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<Ogre::D3DADAPTER_T * *,unsigned int,Ogre::D3DADAPTER_T *,std::allocator<Ogre::D3DADAPTER_T *> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@V?$allocator@W4_D3DFORMAT@@@std@@@std@@YAXPAW4_D3DFORMAT@@0AAV?$allocator@W4_D3DFORMAT@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@W4_D3DFORMAT@@@std@@@std@@YAXPAW4_D3DFORMAT@@0AAV?$allocator@W4_D3DFORMAT@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<enum _D3DFORMAT> >, COMDAT

; 232  : 	{	// destroy [_First, _Last), arbitrary type

	push	ebp
	mov	ebp, esp

; 233  : 	for (; _First != _Last; ++_First)

	jmp	SHORT $LN3@Destroy_ra
$LN2@Destroy_ra:
	mov	eax, DWORD PTR __First$[ebp]
	add	eax, 4
	mov	DWORD PTR __First$[ebp], eax
$LN3@Destroy_ra:
	mov	ecx, DWORD PTR __First$[ebp]
	cmp	ecx, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Destroy_ra

; 234  : 		_Al.destroy(_First);

	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?destroy@?$allocator@W4_D3DFORMAT@@@std@@QAEXPAW4_D3DFORMAT@@@Z ; std::allocator<enum _D3DFORMAT>::destroy
	jmp	SHORT $LN2@Destroy_ra
$LN4@Destroy_ra:

; 235  : 	}

	pop	ebp
	ret	0
??$_Destroy_range@V?$allocator@W4_D3DFORMAT@@@std@@@std@@YAXPAW4_D3DFORMAT@@0AAV?$allocator@W4_D3DFORMAT@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<enum _D3DFORMAT> >
_TEXT	ENDS
PUBLIC	??$_Uninit_move@PAW4_D3DFORMAT@@PAW41@V?$allocator@W4_D3DFORMAT@@@std@@U_Undefined_move_tag@3@@std@@YAPAW4_D3DFORMAT@@PAW41@00AAV?$allocator@W4_D3DFORMAT@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<enum _D3DFORMAT *,enum _D3DFORMAT *,std::allocator<enum _D3DFORMAT>,std::_Undefined_move_tag>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Unchecked_uninitialized_move@PAW4_D3DFORMAT@@PAW41@V?$allocator@W4_D3DFORMAT@@@std@@@stdext@@YAPAW4_D3DFORMAT@@PAW41@00AAV?$allocator@W4_D3DFORMAT@@@std@@@Z
_TEXT	SEGMENT
$T143484 = -2						; size = 1
$T143483 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Unchecked_uninitialized_move@PAW4_D3DFORMAT@@PAW41@V?$allocator@W4_D3DFORMAT@@@std@@@stdext@@YAPAW4_D3DFORMAT@@PAW41@00AAV?$allocator@W4_D3DFORMAT@@@std@@@Z PROC ; stdext::_Unchecked_uninitialized_move<enum _D3DFORMAT *,enum _D3DFORMAT *,std::allocator<enum _D3DFORMAT> >, COMDAT

; 861  : 	{	// move [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 862  : 	return (_STD _Uninit_move(_CHECKED_BASE(_First),
; 863  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 864  : 		_STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T143483[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	??$_Move_cat@PAW4_D3DFORMAT@@@std@@YA?AU_Undefined_move_tag@0@ABQAW4_D3DFORMAT@@@Z ; std::_Move_cat<enum _D3DFORMAT *>
	add	esp, 4
	mov	BYTE PTR $T143484[ebp], al
	movzx	edx, BYTE PTR $T143483[ebp]
	push	edx
	movzx	eax, BYTE PTR $T143484[ebp]
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	call	??$_Checked_base@PAW4_D3DFORMAT@@@std@@YAPAW4_D3DFORMAT@@AAPAW41@@Z ; std::_Checked_base<enum _D3DFORMAT *>
	add	esp, 4
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Checked_base@PAW4_D3DFORMAT@@@std@@YAPAW4_D3DFORMAT@@AAPAW41@@Z ; std::_Checked_base<enum _D3DFORMAT *>
	add	esp, 4
	push	eax
	call	??$_Uninit_move@PAW4_D3DFORMAT@@PAW41@V?$allocator@W4_D3DFORMAT@@@std@@U_Undefined_move_tag@3@@std@@YAPAW4_D3DFORMAT@@PAW41@00AAV?$allocator@W4_D3DFORMAT@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<enum _D3DFORMAT *,enum _D3DFORMAT *,std::allocator<enum _D3DFORMAT>,std::_Undefined_move_tag>
	add	esp, 24					; 00000018H

; 865  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Unchecked_uninitialized_move@PAW4_D3DFORMAT@@PAW41@V?$allocator@W4_D3DFORMAT@@@std@@@stdext@@YAPAW4_D3DFORMAT@@PAW41@00AAV?$allocator@W4_D3DFORMAT@@@std@@@Z ENDP ; stdext::_Unchecked_uninitialized_move<enum _D3DFORMAT *,enum _D3DFORMAT *,std::allocator<enum _D3DFORMAT> >
_TEXT	ENDS
PUBLIC	??$_Checked_base@PAW4_D3DFORMAT@@@std@@YAPAW4_D3DFORMAT@@AAPAW41@U_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<enum _D3DFORMAT *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Checked_base@PAW4_D3DFORMAT@@@std@@YAPAW4_D3DFORMAT@@AAPAW41@@Z
_TEXT	SEGMENT
__Base_tag$ = -1					; size = 1
__It$ = 8						; size = 4
??$_Checked_base@PAW4_D3DFORMAT@@@std@@YAPAW4_D3DFORMAT@@AAPAW41@@Z PROC ; std::_Checked_base<enum _D3DFORMAT *>, COMDAT

; 1163 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1164 : 		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
; 1165 : 		return _Checked_base(_It, _Base_tag);

	movzx	eax, BYTE PTR __Base_tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR __It$[ebp]
	push	ecx
	call	??$_Checked_base@PAW4_D3DFORMAT@@@std@@YAPAW4_D3DFORMAT@@AAPAW41@U_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<enum _D3DFORMAT *>
	add	esp, 8

; 1166 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Checked_base@PAW4_D3DFORMAT@@@std@@YAPAW4_D3DFORMAT@@AAPAW41@@Z ENDP ; std::_Checked_base<enum _D3DFORMAT *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Fill@PAW4_D3DFORMAT@@W41@@std@@YAXPAW4_D3DFORMAT@@0ABW41@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$_Fill@PAW4_D3DFORMAT@@W41@@std@@YAXPAW4_D3DFORMAT@@0ABW41@@Z PROC ; std::_Fill<enum _D3DFORMAT *,enum _D3DFORMAT>, COMDAT

; 3156 : 	{	// copy _Val through [_First, _Last)

	push	ebp
	mov	ebp, esp

; 3157 : 	_DEBUG_RANGE(_First, _Last);
; 3158 : 	for (; _First != _Last; ++_First)

	jmp	SHORT $LN3@Fill
$LN2@Fill:
	mov	eax, DWORD PTR __First$[ebp]
	add	eax, 4
	mov	DWORD PTR __First$[ebp], eax
$LN3@Fill:
	mov	ecx, DWORD PTR __First$[ebp]
	cmp	ecx, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Fill

; 3159 : 		*_First = _Val;

	mov	edx, DWORD PTR __First$[ebp]
	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	jmp	SHORT $LN2@Fill
$LN4@Fill:

; 3160 : 	}

	pop	ebp
	ret	0
??$_Fill@PAW4_D3DFORMAT@@W41@@std@@YAXPAW4_D3DFORMAT@@0ABW41@@Z ENDP ; std::_Fill<enum _D3DFORMAT *,enum _D3DFORMAT>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Iter_random@PAW4_D3DFORMAT@@PAW41@@std@@YA?AUrandom_access_iterator_tag@0@ABQAW4_D3DFORMAT@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAW4_D3DFORMAT@@PAW41@@std@@YA?AUrandom_access_iterator_tag@0@ABQAW4_D3DFORMAT@@0@Z PROC ; std::_Iter_random<enum _D3DFORMAT *,enum _D3DFORMAT *>, COMDAT

; 993  : 	{	// return category from iterator argument

	push	ebp
	mov	ebp, esp
	push	ecx

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 998  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Iter_random@PAW4_D3DFORMAT@@PAW41@@std@@YA?AUrandom_access_iterator_tag@0@ABQAW4_D3DFORMAT@@0@Z ENDP ; std::_Iter_random<enum _D3DFORMAT *,enum _D3DFORMAT *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Move_cat@PAW4_D3DFORMAT@@@std@@YA?AU_Undefined_move_tag@0@ABQAW4_D3DFORMAT@@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
??$_Move_cat@PAW4_D3DFORMAT@@@std@@YA?AU_Undefined_move_tag@0@ABQAW4_D3DFORMAT@@@Z PROC ; std::_Move_cat<enum _D3DFORMAT *>, COMDAT

; 1200 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1201 : 		typename _Move_operation_category<typename iterator_traits<_Iter>::value_type>::_Move_cat _Cat;
; 1202 : 		return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 1203 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Move_cat@PAW4_D3DFORMAT@@@std@@YA?AU_Undefined_move_tag@0@ABQAW4_D3DFORMAT@@@Z ENDP ; std::_Move_cat<enum _D3DFORMAT *>
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@PAW4_D3DFORMAT@@PAW41@@std@@YAPAW4_D3DFORMAT@@PAW41@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<enum _D3DFORMAT *,enum _D3DFORMAT *>
; Function compile flags: /Odtp
;	COMDAT ??$_Move_backward_opt@PAW4_D3DFORMAT@@PAW41@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAW4_D3DFORMAT@@PAW41@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T143496 = -2						; size = 1
$T143495 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__First_dest_cat$ = 20					; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Move_backward_opt@PAW4_D3DFORMAT@@PAW41@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAW4_D3DFORMAT@@PAW41@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Move_backward_opt<enum _D3DFORMAT *,enum _D3DFORMAT *,std::random_access_iterator_tag,std::_Undefined_move_tag>, COMDAT

; 2752 : 	{	// move defaults to copy if there is not a more effecient way

	push	ebp
	mov	ebp, esp
	push	ecx

; 2753 : 	return _Copy_backward_opt(_First, _Last, _Dest,
; 2754 : 		_First_dest_cat, _Ptr_cat(_First, _Dest), _Range_checked_iterator_tag());

	xor	eax, eax
	mov	BYTE PTR $T143495[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAW4_D3DFORMAT@@PAW41@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAW4_D3DFORMAT@@0@Z ; std::_Ptr_cat<enum _D3DFORMAT *,enum _D3DFORMAT *>
	add	esp, 8
	mov	BYTE PTR $T143496[ebp], al
	movzx	eax, BYTE PTR $T143495[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T143496[ebp]
	push	ecx
	movzx	edx, BYTE PTR __First_dest_cat$[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Copy_backward_opt@PAW4_D3DFORMAT@@PAW41@@std@@YAPAW4_D3DFORMAT@@PAW41@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<enum _D3DFORMAT *,enum _D3DFORMAT *>
	add	esp, 24					; 00000018H

; 2755 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Move_backward_opt@PAW4_D3DFORMAT@@PAW41@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAW4_D3DFORMAT@@PAW41@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Move_backward_opt<enum _D3DFORMAT *,enum _D3DFORMAT *,std::random_access_iterator_tag,std::_Undefined_move_tag>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@YAXPAW4_D3DMULTISAMPLE_TYPE@@0AAV?$allocator@W4_D3DMULTISAMPLE_TYPE@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@YAXPAW4_D3DMULTISAMPLE_TYPE@@0AAV?$allocator@W4_D3DMULTISAMPLE_TYPE@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<enum _D3DMULTISAMPLE_TYPE> >, COMDAT

; 232  : 	{	// destroy [_First, _Last), arbitrary type

	push	ebp
	mov	ebp, esp

; 233  : 	for (; _First != _Last; ++_First)

	jmp	SHORT $LN3@Destroy_ra@2
$LN2@Destroy_ra@2:
	mov	eax, DWORD PTR __First$[ebp]
	add	eax, 4
	mov	DWORD PTR __First$[ebp], eax
$LN3@Destroy_ra@2:
	mov	ecx, DWORD PTR __First$[ebp]
	cmp	ecx, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Destroy_ra@2

; 234  : 		_Al.destroy(_First);

	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?destroy@?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@QAEXPAW4_D3DMULTISAMPLE_TYPE@@@Z ; std::allocator<enum _D3DMULTISAMPLE_TYPE>::destroy
	jmp	SHORT $LN2@Destroy_ra@2
$LN4@Destroy_ra@2:

; 235  : 	}

	pop	ebp
	ret	0
??$_Destroy_range@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@YAXPAW4_D3DMULTISAMPLE_TYPE@@0AAV?$allocator@W4_D3DMULTISAMPLE_TYPE@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<enum _D3DMULTISAMPLE_TYPE> >
_TEXT	ENDS
PUBLIC	??$_Uninit_move@PAW4_D3DMULTISAMPLE_TYPE@@PAW41@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@U_Undefined_move_tag@3@@std@@YAPAW4_D3DMULTISAMPLE_TYPE@@PAW41@00AAV?$allocator@W4_D3DMULTISAMPLE_TYPE@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<enum _D3DMULTISAMPLE_TYPE *,enum _D3DMULTISAMPLE_TYPE *,std::allocator<enum _D3DMULTISAMPLE_TYPE>,std::_Undefined_move_tag>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Unchecked_uninitialized_move@PAW4_D3DMULTISAMPLE_TYPE@@PAW41@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@stdext@@YAPAW4_D3DMULTISAMPLE_TYPE@@PAW41@00AAV?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@Z
_TEXT	SEGMENT
$T143502 = -2						; size = 1
$T143501 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Unchecked_uninitialized_move@PAW4_D3DMULTISAMPLE_TYPE@@PAW41@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@stdext@@YAPAW4_D3DMULTISAMPLE_TYPE@@PAW41@00AAV?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@Z PROC ; stdext::_Unchecked_uninitialized_move<enum _D3DMULTISAMPLE_TYPE *,enum _D3DMULTISAMPLE_TYPE *,std::allocator<enum _D3DMULTISAMPLE_TYPE> >, COMDAT

; 861  : 	{	// move [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 862  : 	return (_STD _Uninit_move(_CHECKED_BASE(_First),
; 863  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 864  : 		_STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T143501[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	??$_Move_cat@PAW4_D3DMULTISAMPLE_TYPE@@@std@@YA?AU_Undefined_move_tag@0@ABQAW4_D3DMULTISAMPLE_TYPE@@@Z ; std::_Move_cat<enum _D3DMULTISAMPLE_TYPE *>
	add	esp, 4
	mov	BYTE PTR $T143502[ebp], al
	movzx	edx, BYTE PTR $T143501[ebp]
	push	edx
	movzx	eax, BYTE PTR $T143502[ebp]
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	call	??$_Checked_base@PAW4_D3DMULTISAMPLE_TYPE@@@std@@YAPAW4_D3DMULTISAMPLE_TYPE@@AAPAW41@@Z ; std::_Checked_base<enum _D3DMULTISAMPLE_TYPE *>
	add	esp, 4
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Checked_base@PAW4_D3DMULTISAMPLE_TYPE@@@std@@YAPAW4_D3DMULTISAMPLE_TYPE@@AAPAW41@@Z ; std::_Checked_base<enum _D3DMULTISAMPLE_TYPE *>
	add	esp, 4
	push	eax
	call	??$_Uninit_move@PAW4_D3DMULTISAMPLE_TYPE@@PAW41@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@U_Undefined_move_tag@3@@std@@YAPAW4_D3DMULTISAMPLE_TYPE@@PAW41@00AAV?$allocator@W4_D3DMULTISAMPLE_TYPE@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<enum _D3DMULTISAMPLE_TYPE *,enum _D3DMULTISAMPLE_TYPE *,std::allocator<enum _D3DMULTISAMPLE_TYPE>,std::_Undefined_move_tag>
	add	esp, 24					; 00000018H

; 865  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Unchecked_uninitialized_move@PAW4_D3DMULTISAMPLE_TYPE@@PAW41@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@stdext@@YAPAW4_D3DMULTISAMPLE_TYPE@@PAW41@00AAV?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@Z ENDP ; stdext::_Unchecked_uninitialized_move<enum _D3DMULTISAMPLE_TYPE *,enum _D3DMULTISAMPLE_TYPE *,std::allocator<enum _D3DMULTISAMPLE_TYPE> >
_TEXT	ENDS
PUBLIC	??$_Checked_base@PAW4_D3DMULTISAMPLE_TYPE@@@std@@YAPAW4_D3DMULTISAMPLE_TYPE@@AAPAW41@U_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<enum _D3DMULTISAMPLE_TYPE *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Checked_base@PAW4_D3DMULTISAMPLE_TYPE@@@std@@YAPAW4_D3DMULTISAMPLE_TYPE@@AAPAW41@@Z
_TEXT	SEGMENT
__Base_tag$ = -1					; size = 1
__It$ = 8						; size = 4
??$_Checked_base@PAW4_D3DMULTISAMPLE_TYPE@@@std@@YAPAW4_D3DMULTISAMPLE_TYPE@@AAPAW41@@Z PROC ; std::_Checked_base<enum _D3DMULTISAMPLE_TYPE *>, COMDAT

; 1163 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1164 : 		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
; 1165 : 		return _Checked_base(_It, _Base_tag);

	movzx	eax, BYTE PTR __Base_tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR __It$[ebp]
	push	ecx
	call	??$_Checked_base@PAW4_D3DMULTISAMPLE_TYPE@@@std@@YAPAW4_D3DMULTISAMPLE_TYPE@@AAPAW41@U_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<enum _D3DMULTISAMPLE_TYPE *>
	add	esp, 8

; 1166 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Checked_base@PAW4_D3DMULTISAMPLE_TYPE@@@std@@YAPAW4_D3DMULTISAMPLE_TYPE@@AAPAW41@@Z ENDP ; std::_Checked_base<enum _D3DMULTISAMPLE_TYPE *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Fill@PAW4_D3DMULTISAMPLE_TYPE@@W41@@std@@YAXPAW4_D3DMULTISAMPLE_TYPE@@0ABW41@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$_Fill@PAW4_D3DMULTISAMPLE_TYPE@@W41@@std@@YAXPAW4_D3DMULTISAMPLE_TYPE@@0ABW41@@Z PROC ; std::_Fill<enum _D3DMULTISAMPLE_TYPE *,enum _D3DMULTISAMPLE_TYPE>, COMDAT

; 3156 : 	{	// copy _Val through [_First, _Last)

	push	ebp
	mov	ebp, esp

; 3157 : 	_DEBUG_RANGE(_First, _Last);
; 3158 : 	for (; _First != _Last; ++_First)

	jmp	SHORT $LN3@Fill@2
$LN2@Fill@2:
	mov	eax, DWORD PTR __First$[ebp]
	add	eax, 4
	mov	DWORD PTR __First$[ebp], eax
$LN3@Fill@2:
	mov	ecx, DWORD PTR __First$[ebp]
	cmp	ecx, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Fill@2

; 3159 : 		*_First = _Val;

	mov	edx, DWORD PTR __First$[ebp]
	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	jmp	SHORT $LN2@Fill@2
$LN4@Fill@2:

; 3160 : 	}

	pop	ebp
	ret	0
??$_Fill@PAW4_D3DMULTISAMPLE_TYPE@@W41@@std@@YAXPAW4_D3DMULTISAMPLE_TYPE@@0ABW41@@Z ENDP ; std::_Fill<enum _D3DMULTISAMPLE_TYPE *,enum _D3DMULTISAMPLE_TYPE>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Iter_random@PAW4_D3DMULTISAMPLE_TYPE@@PAW41@@std@@YA?AUrandom_access_iterator_tag@0@ABQAW4_D3DMULTISAMPLE_TYPE@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAW4_D3DMULTISAMPLE_TYPE@@PAW41@@std@@YA?AUrandom_access_iterator_tag@0@ABQAW4_D3DMULTISAMPLE_TYPE@@0@Z PROC ; std::_Iter_random<enum _D3DMULTISAMPLE_TYPE *,enum _D3DMULTISAMPLE_TYPE *>, COMDAT

; 993  : 	{	// return category from iterator argument

	push	ebp
	mov	ebp, esp
	push	ecx

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 998  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Iter_random@PAW4_D3DMULTISAMPLE_TYPE@@PAW41@@std@@YA?AUrandom_access_iterator_tag@0@ABQAW4_D3DMULTISAMPLE_TYPE@@0@Z ENDP ; std::_Iter_random<enum _D3DMULTISAMPLE_TYPE *,enum _D3DMULTISAMPLE_TYPE *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Move_cat@PAW4_D3DMULTISAMPLE_TYPE@@@std@@YA?AU_Undefined_move_tag@0@ABQAW4_D3DMULTISAMPLE_TYPE@@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
??$_Move_cat@PAW4_D3DMULTISAMPLE_TYPE@@@std@@YA?AU_Undefined_move_tag@0@ABQAW4_D3DMULTISAMPLE_TYPE@@@Z PROC ; std::_Move_cat<enum _D3DMULTISAMPLE_TYPE *>, COMDAT

; 1200 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1201 : 		typename _Move_operation_category<typename iterator_traits<_Iter>::value_type>::_Move_cat _Cat;
; 1202 : 		return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 1203 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Move_cat@PAW4_D3DMULTISAMPLE_TYPE@@@std@@YA?AU_Undefined_move_tag@0@ABQAW4_D3DMULTISAMPLE_TYPE@@@Z ENDP ; std::_Move_cat<enum _D3DMULTISAMPLE_TYPE *>
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@PAW4_D3DMULTISAMPLE_TYPE@@PAW41@@std@@YAPAW4_D3DMULTISAMPLE_TYPE@@PAW41@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<enum _D3DMULTISAMPLE_TYPE *,enum _D3DMULTISAMPLE_TYPE *>
; Function compile flags: /Odtp
;	COMDAT ??$_Move_backward_opt@PAW4_D3DMULTISAMPLE_TYPE@@PAW41@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAW4_D3DMULTISAMPLE_TYPE@@PAW41@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T143514 = -2						; size = 1
$T143513 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__First_dest_cat$ = 20					; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Move_backward_opt@PAW4_D3DMULTISAMPLE_TYPE@@PAW41@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAW4_D3DMULTISAMPLE_TYPE@@PAW41@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Move_backward_opt<enum _D3DMULTISAMPLE_TYPE *,enum _D3DMULTISAMPLE_TYPE *,std::random_access_iterator_tag,std::_Undefined_move_tag>, COMDAT

; 2752 : 	{	// move defaults to copy if there is not a more effecient way

	push	ebp
	mov	ebp, esp
	push	ecx

; 2753 : 	return _Copy_backward_opt(_First, _Last, _Dest,
; 2754 : 		_First_dest_cat, _Ptr_cat(_First, _Dest), _Range_checked_iterator_tag());

	xor	eax, eax
	mov	BYTE PTR $T143513[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAW4_D3DMULTISAMPLE_TYPE@@PAW41@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAW4_D3DMULTISAMPLE_TYPE@@0@Z ; std::_Ptr_cat<enum _D3DMULTISAMPLE_TYPE *,enum _D3DMULTISAMPLE_TYPE *>
	add	esp, 8
	mov	BYTE PTR $T143514[ebp], al
	movzx	eax, BYTE PTR $T143513[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T143514[ebp]
	push	ecx
	movzx	edx, BYTE PTR __First_dest_cat$[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Copy_backward_opt@PAW4_D3DMULTISAMPLE_TYPE@@PAW41@@std@@YAPAW4_D3DMULTISAMPLE_TYPE@@PAW41@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<enum _D3DMULTISAMPLE_TYPE *,enum _D3DMULTISAMPLE_TYPE *>
	add	esp, 24					; 00000018H

; 2755 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Move_backward_opt@PAW4_D3DMULTISAMPLE_TYPE@@PAW41@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAW4_D3DMULTISAMPLE_TYPE@@PAW41@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Move_backward_opt<enum _D3DMULTISAMPLE_TYPE *,enum _D3DMULTISAMPLE_TYPE *,std::random_access_iterator_tag,std::_Undefined_move_tag>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@V?$allocator@I@std@@@std@@YAXPAI0AAV?$allocator@I@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@I@std@@@std@@YAXPAI0AAV?$allocator@I@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<unsigned int> >, COMDAT

; 241  : 	{	// destroy [_First, _Last), scalar type (do nothing)

	push	ebp
	mov	ebp, esp

; 242  : 	}

	pop	ebp
	ret	0
??$_Destroy_range@V?$allocator@I@std@@@std@@YAXPAI0AAV?$allocator@I@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<unsigned int> >
_TEXT	ENDS
PUBLIC	??$_Uninit_move@PAIPAIV?$allocator@I@std@@U_Undefined_move_tag@2@@std@@YAPAIPAI00AAV?$allocator@I@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<unsigned int *,unsigned int *,std::allocator<unsigned int>,std::_Undefined_move_tag>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Unchecked_uninitialized_move@PAIPAIV?$allocator@I@std@@@stdext@@YAPAIPAI00AAV?$allocator@I@std@@@Z
_TEXT	SEGMENT
$T143520 = -2						; size = 1
$T143519 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Unchecked_uninitialized_move@PAIPAIV?$allocator@I@std@@@stdext@@YAPAIPAI00AAV?$allocator@I@std@@@Z PROC ; stdext::_Unchecked_uninitialized_move<unsigned int *,unsigned int *,std::allocator<unsigned int> >, COMDAT

; 861  : 	{	// move [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 862  : 	return (_STD _Uninit_move(_CHECKED_BASE(_First),
; 863  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 864  : 		_STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T143519[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	??$_Move_cat@PAI@std@@YA?AU_Undefined_move_tag@0@ABQAI@Z ; std::_Move_cat<unsigned int *>
	add	esp, 4
	mov	BYTE PTR $T143520[ebp], al
	movzx	edx, BYTE PTR $T143519[ebp]
	push	edx
	movzx	eax, BYTE PTR $T143520[ebp]
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	call	??$_Checked_base@PAI@std@@YAPAIAAPAI@Z	; std::_Checked_base<unsigned int *>
	add	esp, 4
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Checked_base@PAI@std@@YAPAIAAPAI@Z	; std::_Checked_base<unsigned int *>
	add	esp, 4
	push	eax
	call	??$_Uninit_move@PAIPAIV?$allocator@I@std@@U_Undefined_move_tag@2@@std@@YAPAIPAI00AAV?$allocator@I@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<unsigned int *,unsigned int *,std::allocator<unsigned int>,std::_Undefined_move_tag>
	add	esp, 24					; 00000018H

; 865  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Unchecked_uninitialized_move@PAIPAIV?$allocator@I@std@@@stdext@@YAPAIPAI00AAV?$allocator@I@std@@@Z ENDP ; stdext::_Unchecked_uninitialized_move<unsigned int *,unsigned int *,std::allocator<unsigned int> >
_TEXT	ENDS
PUBLIC	??$_Checked_base@PAI@std@@YAPAIAAPAIU_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<unsigned int *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Checked_base@PAI@std@@YAPAIAAPAI@Z
_TEXT	SEGMENT
__Base_tag$ = -1					; size = 1
__It$ = 8						; size = 4
??$_Checked_base@PAI@std@@YAPAIAAPAI@Z PROC		; std::_Checked_base<unsigned int *>, COMDAT

; 1163 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1164 : 		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
; 1165 : 		return _Checked_base(_It, _Base_tag);

	movzx	eax, BYTE PTR __Base_tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR __It$[ebp]
	push	ecx
	call	??$_Checked_base@PAI@std@@YAPAIAAPAIU_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<unsigned int *>
	add	esp, 8

; 1166 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Checked_base@PAI@std@@YAPAIAAPAI@Z ENDP		; std::_Checked_base<unsigned int *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Fill@PAII@std@@YAXPAI0ABI@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$_Fill@PAII@std@@YAXPAI0ABI@Z PROC			; std::_Fill<unsigned int *,unsigned int>, COMDAT

; 3156 : 	{	// copy _Val through [_First, _Last)

	push	ebp
	mov	ebp, esp

; 3157 : 	_DEBUG_RANGE(_First, _Last);
; 3158 : 	for (; _First != _Last; ++_First)

	jmp	SHORT $LN3@Fill@3
$LN2@Fill@3:
	mov	eax, DWORD PTR __First$[ebp]
	add	eax, 4
	mov	DWORD PTR __First$[ebp], eax
$LN3@Fill@3:
	mov	ecx, DWORD PTR __First$[ebp]
	cmp	ecx, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Fill@3

; 3159 : 		*_First = _Val;

	mov	edx, DWORD PTR __First$[ebp]
	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	jmp	SHORT $LN2@Fill@3
$LN4@Fill@3:

; 3160 : 	}

	pop	ebp
	ret	0
??$_Fill@PAII@std@@YAXPAI0ABI@Z ENDP			; std::_Fill<unsigned int *,unsigned int>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Iter_random@PAIPAI@std@@YA?AUrandom_access_iterator_tag@0@ABQAI0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAIPAI@std@@YA?AUrandom_access_iterator_tag@0@ABQAI0@Z PROC ; std::_Iter_random<unsigned int *,unsigned int *>, COMDAT

; 993  : 	{	// return category from iterator argument

	push	ebp
	mov	ebp, esp
	push	ecx

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 998  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Iter_random@PAIPAI@std@@YA?AUrandom_access_iterator_tag@0@ABQAI0@Z ENDP ; std::_Iter_random<unsigned int *,unsigned int *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Move_cat@PAI@std@@YA?AU_Undefined_move_tag@0@ABQAI@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
??$_Move_cat@PAI@std@@YA?AU_Undefined_move_tag@0@ABQAI@Z PROC ; std::_Move_cat<unsigned int *>, COMDAT

; 1200 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1201 : 		typename _Move_operation_category<typename iterator_traits<_Iter>::value_type>::_Move_cat _Cat;
; 1202 : 		return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 1203 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Move_cat@PAI@std@@YA?AU_Undefined_move_tag@0@ABQAI@Z ENDP ; std::_Move_cat<unsigned int *>
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@PAIPAIUrandom_access_iterator_tag@std@@@std@@YAPAIPAI00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<unsigned int *,unsigned int *,std::random_access_iterator_tag>
; Function compile flags: /Odtp
;	COMDAT ??$_Move_backward_opt@PAIPAIUrandom_access_iterator_tag@std@@U_Undefined_move_tag@2@@std@@YAPAIPAI00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T143532 = -2						; size = 1
$T143531 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__First_dest_cat$ = 20					; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Move_backward_opt@PAIPAIUrandom_access_iterator_tag@std@@U_Undefined_move_tag@2@@std@@YAPAIPAI00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Move_backward_opt<unsigned int *,unsigned int *,std::random_access_iterator_tag,std::_Undefined_move_tag>, COMDAT

; 2752 : 	{	// move defaults to copy if there is not a more effecient way

	push	ebp
	mov	ebp, esp
	push	ecx

; 2753 : 	return _Copy_backward_opt(_First, _Last, _Dest,
; 2754 : 		_First_dest_cat, _Ptr_cat(_First, _Dest), _Range_checked_iterator_tag());

	xor	eax, eax
	mov	BYTE PTR $T143531[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAIPAI@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAI0@Z ; std::_Ptr_cat<unsigned int *,unsigned int *>
	add	esp, 8
	mov	BYTE PTR $T143532[ebp], al
	movzx	eax, BYTE PTR $T143531[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T143532[ebp]
	push	ecx
	movzx	edx, BYTE PTR __First_dest_cat$[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Copy_backward_opt@PAIPAIUrandom_access_iterator_tag@std@@@std@@YAPAIPAI00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<unsigned int *,unsigned int *,std::random_access_iterator_tag>
	add	esp, 24					; 00000018H

; 2755 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Move_backward_opt@PAIPAIUrandom_access_iterator_tag@std@@U_Undefined_move_tag@2@@std@@YAPAIPAI00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Move_backward_opt<unsigned int *,unsigned int *,std::random_access_iterator_tag,std::_Undefined_move_tag>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@YAXPAUD3DSMSCONFLICT_T@Ogre@@0AAV?$allocator@UD3DSMSCONFLICT_T@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@YAXPAUD3DSMSCONFLICT_T@Ogre@@0AAV?$allocator@UD3DSMSCONFLICT_T@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<Ogre::D3DSMSCONFLICT_T> >, COMDAT

; 232  : 	{	// destroy [_First, _Last), arbitrary type

	push	ebp
	mov	ebp, esp

; 233  : 	for (; _First != _Last; ++_First)

	jmp	SHORT $LN3@Destroy_ra@3
$LN2@Destroy_ra@3:
	mov	eax, DWORD PTR __First$[ebp]
	add	eax, 8
	mov	DWORD PTR __First$[ebp], eax
$LN3@Destroy_ra@3:
	mov	ecx, DWORD PTR __First$[ebp]
	cmp	ecx, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Destroy_ra@3

; 234  : 		_Al.destroy(_First);

	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?destroy@?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@QAEXPAUD3DSMSCONFLICT_T@Ogre@@@Z ; std::allocator<Ogre::D3DSMSCONFLICT_T>::destroy
	jmp	SHORT $LN2@Destroy_ra@3
$LN4@Destroy_ra@3:

; 235  : 	}

	pop	ebp
	ret	0
??$_Destroy_range@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@YAXPAUD3DSMSCONFLICT_T@Ogre@@0AAV?$allocator@UD3DSMSCONFLICT_T@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<Ogre::D3DSMSCONFLICT_T> >
_TEXT	ENDS
PUBLIC	??$_Uninit_move@PAUD3DSMSCONFLICT_T@Ogre@@PAU12@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@U_Undefined_move_tag@4@@std@@YAPAUD3DSMSCONFLICT_T@Ogre@@PAU12@00AAV?$allocator@UD3DSMSCONFLICT_T@Ogre@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<Ogre::D3DSMSCONFLICT_T *,Ogre::D3DSMSCONFLICT_T *,std::allocator<Ogre::D3DSMSCONFLICT_T>,std::_Undefined_move_tag>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Unchecked_uninitialized_move@PAUD3DSMSCONFLICT_T@Ogre@@PAU12@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@stdext@@YAPAUD3DSMSCONFLICT_T@Ogre@@PAU12@00AAV?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@Z
_TEXT	SEGMENT
$T143538 = -2						; size = 1
$T143537 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Unchecked_uninitialized_move@PAUD3DSMSCONFLICT_T@Ogre@@PAU12@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@stdext@@YAPAUD3DSMSCONFLICT_T@Ogre@@PAU12@00AAV?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@Z PROC ; stdext::_Unchecked_uninitialized_move<Ogre::D3DSMSCONFLICT_T *,Ogre::D3DSMSCONFLICT_T *,std::allocator<Ogre::D3DSMSCONFLICT_T> >, COMDAT

; 861  : 	{	// move [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 862  : 	return (_STD _Uninit_move(_CHECKED_BASE(_First),
; 863  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 864  : 		_STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T143537[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	??$_Move_cat@PAUD3DSMSCONFLICT_T@Ogre@@@std@@YA?AU_Undefined_move_tag@0@ABQAUD3DSMSCONFLICT_T@Ogre@@@Z ; std::_Move_cat<Ogre::D3DSMSCONFLICT_T *>
	add	esp, 4
	mov	BYTE PTR $T143538[ebp], al
	movzx	edx, BYTE PTR $T143537[ebp]
	push	edx
	movzx	eax, BYTE PTR $T143538[ebp]
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	call	??$_Checked_base@PAUD3DSMSCONFLICT_T@Ogre@@@std@@YAPAUD3DSMSCONFLICT_T@Ogre@@AAPAU12@@Z ; std::_Checked_base<Ogre::D3DSMSCONFLICT_T *>
	add	esp, 4
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Checked_base@PAUD3DSMSCONFLICT_T@Ogre@@@std@@YAPAUD3DSMSCONFLICT_T@Ogre@@AAPAU12@@Z ; std::_Checked_base<Ogre::D3DSMSCONFLICT_T *>
	add	esp, 4
	push	eax
	call	??$_Uninit_move@PAUD3DSMSCONFLICT_T@Ogre@@PAU12@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@U_Undefined_move_tag@4@@std@@YAPAUD3DSMSCONFLICT_T@Ogre@@PAU12@00AAV?$allocator@UD3DSMSCONFLICT_T@Ogre@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<Ogre::D3DSMSCONFLICT_T *,Ogre::D3DSMSCONFLICT_T *,std::allocator<Ogre::D3DSMSCONFLICT_T>,std::_Undefined_move_tag>
	add	esp, 24					; 00000018H

; 865  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Unchecked_uninitialized_move@PAUD3DSMSCONFLICT_T@Ogre@@PAU12@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@stdext@@YAPAUD3DSMSCONFLICT_T@Ogre@@PAU12@00AAV?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@Z ENDP ; stdext::_Unchecked_uninitialized_move<Ogre::D3DSMSCONFLICT_T *,Ogre::D3DSMSCONFLICT_T *,std::allocator<Ogre::D3DSMSCONFLICT_T> >
_TEXT	ENDS
PUBLIC	??$_Checked_base@PAUD3DSMSCONFLICT_T@Ogre@@@std@@YAPAUD3DSMSCONFLICT_T@Ogre@@AAPAU12@U_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<Ogre::D3DSMSCONFLICT_T *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Checked_base@PAUD3DSMSCONFLICT_T@Ogre@@@std@@YAPAUD3DSMSCONFLICT_T@Ogre@@AAPAU12@@Z
_TEXT	SEGMENT
__Base_tag$ = -1					; size = 1
__It$ = 8						; size = 4
??$_Checked_base@PAUD3DSMSCONFLICT_T@Ogre@@@std@@YAPAUD3DSMSCONFLICT_T@Ogre@@AAPAU12@@Z PROC ; std::_Checked_base<Ogre::D3DSMSCONFLICT_T *>, COMDAT

; 1163 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1164 : 		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
; 1165 : 		return _Checked_base(_It, _Base_tag);

	movzx	eax, BYTE PTR __Base_tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR __It$[ebp]
	push	ecx
	call	??$_Checked_base@PAUD3DSMSCONFLICT_T@Ogre@@@std@@YAPAUD3DSMSCONFLICT_T@Ogre@@AAPAU12@U_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<Ogre::D3DSMSCONFLICT_T *>
	add	esp, 8

; 1166 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Checked_base@PAUD3DSMSCONFLICT_T@Ogre@@@std@@YAPAUD3DSMSCONFLICT_T@Ogre@@AAPAU12@@Z ENDP ; std::_Checked_base<Ogre::D3DSMSCONFLICT_T *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Fill@PAUD3DSMSCONFLICT_T@Ogre@@U12@@std@@YAXPAUD3DSMSCONFLICT_T@Ogre@@0ABU12@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$_Fill@PAUD3DSMSCONFLICT_T@Ogre@@U12@@std@@YAXPAUD3DSMSCONFLICT_T@Ogre@@0ABU12@@Z PROC ; std::_Fill<Ogre::D3DSMSCONFLICT_T *,Ogre::D3DSMSCONFLICT_T>, COMDAT

; 3156 : 	{	// copy _Val through [_First, _Last)

	push	ebp
	mov	ebp, esp

; 3157 : 	_DEBUG_RANGE(_First, _Last);
; 3158 : 	for (; _First != _Last; ++_First)

	jmp	SHORT $LN3@Fill@4
$LN2@Fill@4:
	mov	eax, DWORD PTR __First$[ebp]
	add	eax, 8
	mov	DWORD PTR __First$[ebp], eax
$LN3@Fill@4:
	mov	ecx, DWORD PTR __First$[ebp]
	cmp	ecx, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Fill@4

; 3159 : 		*_First = _Val;

	mov	edx, DWORD PTR __Val$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR [edx], eax
	mov	DWORD PTR [edx+4], ecx
	jmp	SHORT $LN2@Fill@4
$LN4@Fill@4:

; 3160 : 	}

	pop	ebp
	ret	0
??$_Fill@PAUD3DSMSCONFLICT_T@Ogre@@U12@@std@@YAXPAUD3DSMSCONFLICT_T@Ogre@@0ABU12@@Z ENDP ; std::_Fill<Ogre::D3DSMSCONFLICT_T *,Ogre::D3DSMSCONFLICT_T>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Iter_random@PAUD3DSMSCONFLICT_T@Ogre@@PAU12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUD3DSMSCONFLICT_T@Ogre@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAUD3DSMSCONFLICT_T@Ogre@@PAU12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUD3DSMSCONFLICT_T@Ogre@@0@Z PROC ; std::_Iter_random<Ogre::D3DSMSCONFLICT_T *,Ogre::D3DSMSCONFLICT_T *>, COMDAT

; 993  : 	{	// return category from iterator argument

	push	ebp
	mov	ebp, esp
	push	ecx

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 998  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Iter_random@PAUD3DSMSCONFLICT_T@Ogre@@PAU12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUD3DSMSCONFLICT_T@Ogre@@0@Z ENDP ; std::_Iter_random<Ogre::D3DSMSCONFLICT_T *,Ogre::D3DSMSCONFLICT_T *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Move_cat@PAUD3DSMSCONFLICT_T@Ogre@@@std@@YA?AU_Undefined_move_tag@0@ABQAUD3DSMSCONFLICT_T@Ogre@@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
??$_Move_cat@PAUD3DSMSCONFLICT_T@Ogre@@@std@@YA?AU_Undefined_move_tag@0@ABQAUD3DSMSCONFLICT_T@Ogre@@@Z PROC ; std::_Move_cat<Ogre::D3DSMSCONFLICT_T *>, COMDAT

; 1200 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1201 : 		typename _Move_operation_category<typename iterator_traits<_Iter>::value_type>::_Move_cat _Cat;
; 1202 : 		return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 1203 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Move_cat@PAUD3DSMSCONFLICT_T@Ogre@@@std@@YA?AU_Undefined_move_tag@0@ABQAUD3DSMSCONFLICT_T@Ogre@@@Z ENDP ; std::_Move_cat<Ogre::D3DSMSCONFLICT_T *>
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@PAUD3DSMSCONFLICT_T@Ogre@@PAU12@@std@@YAPAUD3DSMSCONFLICT_T@Ogre@@PAU12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<Ogre::D3DSMSCONFLICT_T *,Ogre::D3DSMSCONFLICT_T *>
; Function compile flags: /Odtp
;	COMDAT ??$_Move_backward_opt@PAUD3DSMSCONFLICT_T@Ogre@@PAU12@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@4@@std@@YAPAUD3DSMSCONFLICT_T@Ogre@@PAU12@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T143550 = -2						; size = 1
$T143549 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__First_dest_cat$ = 20					; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Move_backward_opt@PAUD3DSMSCONFLICT_T@Ogre@@PAU12@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@4@@std@@YAPAUD3DSMSCONFLICT_T@Ogre@@PAU12@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Move_backward_opt<Ogre::D3DSMSCONFLICT_T *,Ogre::D3DSMSCONFLICT_T *,std::random_access_iterator_tag,std::_Undefined_move_tag>, COMDAT

; 2752 : 	{	// move defaults to copy if there is not a more effecient way

	push	ebp
	mov	ebp, esp
	push	ecx

; 2753 : 	return _Copy_backward_opt(_First, _Last, _Dest,
; 2754 : 		_First_dest_cat, _Ptr_cat(_First, _Dest), _Range_checked_iterator_tag());

	xor	eax, eax
	mov	BYTE PTR $T143549[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAUD3DSMSCONFLICT_T@Ogre@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUD3DSMSCONFLICT_T@Ogre@@0@Z ; std::_Ptr_cat<Ogre::D3DSMSCONFLICT_T *,Ogre::D3DSMSCONFLICT_T *>
	add	esp, 8
	mov	BYTE PTR $T143550[ebp], al
	movzx	eax, BYTE PTR $T143549[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T143550[ebp]
	push	ecx
	movzx	edx, BYTE PTR __First_dest_cat$[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Copy_backward_opt@PAUD3DSMSCONFLICT_T@Ogre@@PAU12@@std@@YAPAUD3DSMSCONFLICT_T@Ogre@@PAU12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<Ogre::D3DSMSCONFLICT_T *,Ogre::D3DSMSCONFLICT_T *>
	add	esp, 24					; 00000018H

; 2755 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Move_backward_opt@PAUD3DSMSCONFLICT_T@Ogre@@PAU12@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@4@@std@@YAPAUD3DSMSCONFLICT_T@Ogre@@PAU12@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Move_backward_opt<Ogre::D3DSMSCONFLICT_T *,Ogre::D3DSMSCONFLICT_T *,std::random_access_iterator_tag,std::_Undefined_move_tag>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@YAXPAW4VERTPROCESS_T@Ogre@@0AAV?$allocator@W4VERTPROCESS_T@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@YAXPAW4VERTPROCESS_T@Ogre@@0AAV?$allocator@W4VERTPROCESS_T@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<enum Ogre::VERTPROCESS_T> >, COMDAT

; 232  : 	{	// destroy [_First, _Last), arbitrary type

	push	ebp
	mov	ebp, esp

; 233  : 	for (; _First != _Last; ++_First)

	jmp	SHORT $LN3@Destroy_ra@4
$LN2@Destroy_ra@4:
	mov	eax, DWORD PTR __First$[ebp]
	add	eax, 4
	mov	DWORD PTR __First$[ebp], eax
$LN3@Destroy_ra@4:
	mov	ecx, DWORD PTR __First$[ebp]
	cmp	ecx, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Destroy_ra@4

; 234  : 		_Al.destroy(_First);

	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?destroy@?$allocator@W4VERTPROCESS_T@Ogre@@@std@@QAEXPAW4VERTPROCESS_T@Ogre@@@Z ; std::allocator<enum Ogre::VERTPROCESS_T>::destroy
	jmp	SHORT $LN2@Destroy_ra@4
$LN4@Destroy_ra@4:

; 235  : 	}

	pop	ebp
	ret	0
??$_Destroy_range@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@YAXPAW4VERTPROCESS_T@Ogre@@0AAV?$allocator@W4VERTPROCESS_T@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<enum Ogre::VERTPROCESS_T> >
_TEXT	ENDS
PUBLIC	??$_Uninit_move@PAW4VERTPROCESS_T@Ogre@@PAW412@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@U_Undefined_move_tag@4@@std@@YAPAW4VERTPROCESS_T@Ogre@@PAW412@00AAV?$allocator@W4VERTPROCESS_T@Ogre@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<enum Ogre::VERTPROCESS_T *,enum Ogre::VERTPROCESS_T *,std::allocator<enum Ogre::VERTPROCESS_T>,std::_Undefined_move_tag>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Unchecked_uninitialized_move@PAW4VERTPROCESS_T@Ogre@@PAW412@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@stdext@@YAPAW4VERTPROCESS_T@Ogre@@PAW412@00AAV?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@Z
_TEXT	SEGMENT
$T143556 = -2						; size = 1
$T143555 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Unchecked_uninitialized_move@PAW4VERTPROCESS_T@Ogre@@PAW412@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@stdext@@YAPAW4VERTPROCESS_T@Ogre@@PAW412@00AAV?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@Z PROC ; stdext::_Unchecked_uninitialized_move<enum Ogre::VERTPROCESS_T *,enum Ogre::VERTPROCESS_T *,std::allocator<enum Ogre::VERTPROCESS_T> >, COMDAT

; 861  : 	{	// move [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 862  : 	return (_STD _Uninit_move(_CHECKED_BASE(_First),
; 863  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 864  : 		_STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T143555[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	??$_Move_cat@PAW4VERTPROCESS_T@Ogre@@@std@@YA?AU_Undefined_move_tag@0@ABQAW4VERTPROCESS_T@Ogre@@@Z ; std::_Move_cat<enum Ogre::VERTPROCESS_T *>
	add	esp, 4
	mov	BYTE PTR $T143556[ebp], al
	movzx	edx, BYTE PTR $T143555[ebp]
	push	edx
	movzx	eax, BYTE PTR $T143556[ebp]
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	call	??$_Checked_base@PAW4VERTPROCESS_T@Ogre@@@std@@YAPAW4VERTPROCESS_T@Ogre@@AAPAW412@@Z ; std::_Checked_base<enum Ogre::VERTPROCESS_T *>
	add	esp, 4
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Checked_base@PAW4VERTPROCESS_T@Ogre@@@std@@YAPAW4VERTPROCESS_T@Ogre@@AAPAW412@@Z ; std::_Checked_base<enum Ogre::VERTPROCESS_T *>
	add	esp, 4
	push	eax
	call	??$_Uninit_move@PAW4VERTPROCESS_T@Ogre@@PAW412@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@U_Undefined_move_tag@4@@std@@YAPAW4VERTPROCESS_T@Ogre@@PAW412@00AAV?$allocator@W4VERTPROCESS_T@Ogre@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<enum Ogre::VERTPROCESS_T *,enum Ogre::VERTPROCESS_T *,std::allocator<enum Ogre::VERTPROCESS_T>,std::_Undefined_move_tag>
	add	esp, 24					; 00000018H

; 865  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Unchecked_uninitialized_move@PAW4VERTPROCESS_T@Ogre@@PAW412@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@stdext@@YAPAW4VERTPROCESS_T@Ogre@@PAW412@00AAV?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@Z ENDP ; stdext::_Unchecked_uninitialized_move<enum Ogre::VERTPROCESS_T *,enum Ogre::VERTPROCESS_T *,std::allocator<enum Ogre::VERTPROCESS_T> >
_TEXT	ENDS
PUBLIC	??$_Checked_base@PAW4VERTPROCESS_T@Ogre@@@std@@YAPAW4VERTPROCESS_T@Ogre@@AAPAW412@U_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<enum Ogre::VERTPROCESS_T *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Checked_base@PAW4VERTPROCESS_T@Ogre@@@std@@YAPAW4VERTPROCESS_T@Ogre@@AAPAW412@@Z
_TEXT	SEGMENT
__Base_tag$ = -1					; size = 1
__It$ = 8						; size = 4
??$_Checked_base@PAW4VERTPROCESS_T@Ogre@@@std@@YAPAW4VERTPROCESS_T@Ogre@@AAPAW412@@Z PROC ; std::_Checked_base<enum Ogre::VERTPROCESS_T *>, COMDAT

; 1163 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1164 : 		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
; 1165 : 		return _Checked_base(_It, _Base_tag);

	movzx	eax, BYTE PTR __Base_tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR __It$[ebp]
	push	ecx
	call	??$_Checked_base@PAW4VERTPROCESS_T@Ogre@@@std@@YAPAW4VERTPROCESS_T@Ogre@@AAPAW412@U_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<enum Ogre::VERTPROCESS_T *>
	add	esp, 8

; 1166 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Checked_base@PAW4VERTPROCESS_T@Ogre@@@std@@YAPAW4VERTPROCESS_T@Ogre@@AAPAW412@@Z ENDP ; std::_Checked_base<enum Ogre::VERTPROCESS_T *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Fill@PAW4VERTPROCESS_T@Ogre@@W412@@std@@YAXPAW4VERTPROCESS_T@Ogre@@0ABW412@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$_Fill@PAW4VERTPROCESS_T@Ogre@@W412@@std@@YAXPAW4VERTPROCESS_T@Ogre@@0ABW412@@Z PROC ; std::_Fill<enum Ogre::VERTPROCESS_T *,enum Ogre::VERTPROCESS_T>, COMDAT

; 3156 : 	{	// copy _Val through [_First, _Last)

	push	ebp
	mov	ebp, esp

; 3157 : 	_DEBUG_RANGE(_First, _Last);
; 3158 : 	for (; _First != _Last; ++_First)

	jmp	SHORT $LN3@Fill@5
$LN2@Fill@5:
	mov	eax, DWORD PTR __First$[ebp]
	add	eax, 4
	mov	DWORD PTR __First$[ebp], eax
$LN3@Fill@5:
	mov	ecx, DWORD PTR __First$[ebp]
	cmp	ecx, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Fill@5

; 3159 : 		*_First = _Val;

	mov	edx, DWORD PTR __First$[ebp]
	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	jmp	SHORT $LN2@Fill@5
$LN4@Fill@5:

; 3160 : 	}

	pop	ebp
	ret	0
??$_Fill@PAW4VERTPROCESS_T@Ogre@@W412@@std@@YAXPAW4VERTPROCESS_T@Ogre@@0ABW412@@Z ENDP ; std::_Fill<enum Ogre::VERTPROCESS_T *,enum Ogre::VERTPROCESS_T>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Iter_random@PAW4VERTPROCESS_T@Ogre@@PAW412@@std@@YA?AUrandom_access_iterator_tag@0@ABQAW4VERTPROCESS_T@Ogre@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAW4VERTPROCESS_T@Ogre@@PAW412@@std@@YA?AUrandom_access_iterator_tag@0@ABQAW4VERTPROCESS_T@Ogre@@0@Z PROC ; std::_Iter_random<enum Ogre::VERTPROCESS_T *,enum Ogre::VERTPROCESS_T *>, COMDAT

; 993  : 	{	// return category from iterator argument

	push	ebp
	mov	ebp, esp
	push	ecx

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 998  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Iter_random@PAW4VERTPROCESS_T@Ogre@@PAW412@@std@@YA?AUrandom_access_iterator_tag@0@ABQAW4VERTPROCESS_T@Ogre@@0@Z ENDP ; std::_Iter_random<enum Ogre::VERTPROCESS_T *,enum Ogre::VERTPROCESS_T *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Move_cat@PAW4VERTPROCESS_T@Ogre@@@std@@YA?AU_Undefined_move_tag@0@ABQAW4VERTPROCESS_T@Ogre@@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
??$_Move_cat@PAW4VERTPROCESS_T@Ogre@@@std@@YA?AU_Undefined_move_tag@0@ABQAW4VERTPROCESS_T@Ogre@@@Z PROC ; std::_Move_cat<enum Ogre::VERTPROCESS_T *>, COMDAT

; 1200 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1201 : 		typename _Move_operation_category<typename iterator_traits<_Iter>::value_type>::_Move_cat _Cat;
; 1202 : 		return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 1203 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Move_cat@PAW4VERTPROCESS_T@Ogre@@@std@@YA?AU_Undefined_move_tag@0@ABQAW4VERTPROCESS_T@Ogre@@@Z ENDP ; std::_Move_cat<enum Ogre::VERTPROCESS_T *>
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@PAW4VERTPROCESS_T@Ogre@@PAW412@@std@@YAPAW4VERTPROCESS_T@Ogre@@PAW412@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<enum Ogre::VERTPROCESS_T *,enum Ogre::VERTPROCESS_T *>
; Function compile flags: /Odtp
;	COMDAT ??$_Move_backward_opt@PAW4VERTPROCESS_T@Ogre@@PAW412@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@4@@std@@YAPAW4VERTPROCESS_T@Ogre@@PAW412@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T143568 = -2						; size = 1
$T143567 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__First_dest_cat$ = 20					; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Move_backward_opt@PAW4VERTPROCESS_T@Ogre@@PAW412@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@4@@std@@YAPAW4VERTPROCESS_T@Ogre@@PAW412@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Move_backward_opt<enum Ogre::VERTPROCESS_T *,enum Ogre::VERTPROCESS_T *,std::random_access_iterator_tag,std::_Undefined_move_tag>, COMDAT

; 2752 : 	{	// move defaults to copy if there is not a more effecient way

	push	ebp
	mov	ebp, esp
	push	ecx

; 2753 : 	return _Copy_backward_opt(_First, _Last, _Dest,
; 2754 : 		_First_dest_cat, _Ptr_cat(_First, _Dest), _Range_checked_iterator_tag());

	xor	eax, eax
	mov	BYTE PTR $T143567[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAW4VERTPROCESS_T@Ogre@@PAW412@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAW4VERTPROCESS_T@Ogre@@0@Z ; std::_Ptr_cat<enum Ogre::VERTPROCESS_T *,enum Ogre::VERTPROCESS_T *>
	add	esp, 8
	mov	BYTE PTR $T143568[ebp], al
	movzx	eax, BYTE PTR $T143567[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T143568[ebp]
	push	ecx
	movzx	edx, BYTE PTR __First_dest_cat$[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Copy_backward_opt@PAW4VERTPROCESS_T@Ogre@@PAW412@@std@@YAPAW4VERTPROCESS_T@Ogre@@PAW412@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<enum Ogre::VERTPROCESS_T *,enum Ogre::VERTPROCESS_T *>
	add	esp, 24					; 00000018H

; 2755 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Move_backward_opt@PAW4VERTPROCESS_T@Ogre@@PAW412@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@4@@std@@YAPAW4VERTPROCESS_T@Ogre@@PAW412@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Move_backward_opt<enum Ogre::VERTPROCESS_T *,enum Ogre::VERTPROCESS_T *,std::random_access_iterator_tag,std::_Undefined_move_tag>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@YAXPAPAUD3DDEVCOMBO_T@Ogre@@0AAV?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@YAXPAPAUD3DDEVCOMBO_T@Ogre@@0AAV?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<Ogre::D3DDEVCOMBO_T *> >, COMDAT

; 241  : 	{	// destroy [_First, _Last), scalar type (do nothing)

	push	ebp
	mov	ebp, esp

; 242  : 	}

	pop	ebp
	ret	0
??$_Destroy_range@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@YAXPAPAUD3DDEVCOMBO_T@Ogre@@0AAV?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<Ogre::D3DDEVCOMBO_T *> >
_TEXT	ENDS
PUBLIC	??$_Uninit_move@PAPAUD3DDEVCOMBO_T@Ogre@@PAPAU12@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@U_Undefined_move_tag@4@@std@@YAPAPAUD3DDEVCOMBO_T@Ogre@@PAPAU12@00AAV?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<Ogre::D3DDEVCOMBO_T * *,Ogre::D3DDEVCOMBO_T * *,std::allocator<Ogre::D3DDEVCOMBO_T *>,std::_Undefined_move_tag>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Unchecked_uninitialized_move@PAPAUD3DDEVCOMBO_T@Ogre@@PAPAU12@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@stdext@@YAPAPAUD3DDEVCOMBO_T@Ogre@@PAPAU12@00AAV?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@Z
_TEXT	SEGMENT
$T143574 = -2						; size = 1
$T143573 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Unchecked_uninitialized_move@PAPAUD3DDEVCOMBO_T@Ogre@@PAPAU12@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@stdext@@YAPAPAUD3DDEVCOMBO_T@Ogre@@PAPAU12@00AAV?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@Z PROC ; stdext::_Unchecked_uninitialized_move<Ogre::D3DDEVCOMBO_T * *,Ogre::D3DDEVCOMBO_T * *,std::allocator<Ogre::D3DDEVCOMBO_T *> >, COMDAT

; 861  : 	{	// move [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 862  : 	return (_STD _Uninit_move(_CHECKED_BASE(_First),
; 863  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 864  : 		_STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T143573[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	??$_Move_cat@PAPAUD3DDEVCOMBO_T@Ogre@@@std@@YA?AU_Undefined_move_tag@0@ABQAPAUD3DDEVCOMBO_T@Ogre@@@Z ; std::_Move_cat<Ogre::D3DDEVCOMBO_T * *>
	add	esp, 4
	mov	BYTE PTR $T143574[ebp], al
	movzx	edx, BYTE PTR $T143573[ebp]
	push	edx
	movzx	eax, BYTE PTR $T143574[ebp]
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	call	??$_Checked_base@PAPAUD3DDEVCOMBO_T@Ogre@@@std@@YAPAPAUD3DDEVCOMBO_T@Ogre@@AAPAPAU12@@Z ; std::_Checked_base<Ogre::D3DDEVCOMBO_T * *>
	add	esp, 4
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Checked_base@PAPAUD3DDEVCOMBO_T@Ogre@@@std@@YAPAPAUD3DDEVCOMBO_T@Ogre@@AAPAPAU12@@Z ; std::_Checked_base<Ogre::D3DDEVCOMBO_T * *>
	add	esp, 4
	push	eax
	call	??$_Uninit_move@PAPAUD3DDEVCOMBO_T@Ogre@@PAPAU12@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@U_Undefined_move_tag@4@@std@@YAPAPAUD3DDEVCOMBO_T@Ogre@@PAPAU12@00AAV?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<Ogre::D3DDEVCOMBO_T * *,Ogre::D3DDEVCOMBO_T * *,std::allocator<Ogre::D3DDEVCOMBO_T *>,std::_Undefined_move_tag>
	add	esp, 24					; 00000018H

; 865  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Unchecked_uninitialized_move@PAPAUD3DDEVCOMBO_T@Ogre@@PAPAU12@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@stdext@@YAPAPAUD3DDEVCOMBO_T@Ogre@@PAPAU12@00AAV?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@Z ENDP ; stdext::_Unchecked_uninitialized_move<Ogre::D3DDEVCOMBO_T * *,Ogre::D3DDEVCOMBO_T * *,std::allocator<Ogre::D3DDEVCOMBO_T *> >
_TEXT	ENDS
PUBLIC	??$_Checked_base@PAPAUD3DDEVCOMBO_T@Ogre@@@std@@YAPAPAUD3DDEVCOMBO_T@Ogre@@AAPAPAU12@U_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<Ogre::D3DDEVCOMBO_T * *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Checked_base@PAPAUD3DDEVCOMBO_T@Ogre@@@std@@YAPAPAUD3DDEVCOMBO_T@Ogre@@AAPAPAU12@@Z
_TEXT	SEGMENT
__Base_tag$ = -1					; size = 1
__It$ = 8						; size = 4
??$_Checked_base@PAPAUD3DDEVCOMBO_T@Ogre@@@std@@YAPAPAUD3DDEVCOMBO_T@Ogre@@AAPAPAU12@@Z PROC ; std::_Checked_base<Ogre::D3DDEVCOMBO_T * *>, COMDAT

; 1163 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1164 : 		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
; 1165 : 		return _Checked_base(_It, _Base_tag);

	movzx	eax, BYTE PTR __Base_tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR __It$[ebp]
	push	ecx
	call	??$_Checked_base@PAPAUD3DDEVCOMBO_T@Ogre@@@std@@YAPAPAUD3DDEVCOMBO_T@Ogre@@AAPAPAU12@U_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<Ogre::D3DDEVCOMBO_T * *>
	add	esp, 8

; 1166 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Checked_base@PAPAUD3DDEVCOMBO_T@Ogre@@@std@@YAPAPAUD3DDEVCOMBO_T@Ogre@@AAPAPAU12@@Z ENDP ; std::_Checked_base<Ogre::D3DDEVCOMBO_T * *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Fill@PAPAUD3DDEVCOMBO_T@Ogre@@PAU12@@std@@YAXPAPAUD3DDEVCOMBO_T@Ogre@@0ABQAU12@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$_Fill@PAPAUD3DDEVCOMBO_T@Ogre@@PAU12@@std@@YAXPAPAUD3DDEVCOMBO_T@Ogre@@0ABQAU12@@Z PROC ; std::_Fill<Ogre::D3DDEVCOMBO_T * *,Ogre::D3DDEVCOMBO_T *>, COMDAT

; 3156 : 	{	// copy _Val through [_First, _Last)

	push	ebp
	mov	ebp, esp

; 3157 : 	_DEBUG_RANGE(_First, _Last);
; 3158 : 	for (; _First != _Last; ++_First)

	jmp	SHORT $LN3@Fill@6
$LN2@Fill@6:
	mov	eax, DWORD PTR __First$[ebp]
	add	eax, 4
	mov	DWORD PTR __First$[ebp], eax
$LN3@Fill@6:
	mov	ecx, DWORD PTR __First$[ebp]
	cmp	ecx, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Fill@6

; 3159 : 		*_First = _Val;

	mov	edx, DWORD PTR __First$[ebp]
	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	jmp	SHORT $LN2@Fill@6
$LN4@Fill@6:

; 3160 : 	}

	pop	ebp
	ret	0
??$_Fill@PAPAUD3DDEVCOMBO_T@Ogre@@PAU12@@std@@YAXPAPAUD3DDEVCOMBO_T@Ogre@@0ABQAU12@@Z ENDP ; std::_Fill<Ogre::D3DDEVCOMBO_T * *,Ogre::D3DDEVCOMBO_T *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Iter_random@PAPAUD3DDEVCOMBO_T@Ogre@@PAPAU12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAUD3DDEVCOMBO_T@Ogre@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAPAUD3DDEVCOMBO_T@Ogre@@PAPAU12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAUD3DDEVCOMBO_T@Ogre@@0@Z PROC ; std::_Iter_random<Ogre::D3DDEVCOMBO_T * *,Ogre::D3DDEVCOMBO_T * *>, COMDAT

; 993  : 	{	// return category from iterator argument

	push	ebp
	mov	ebp, esp
	push	ecx

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 998  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Iter_random@PAPAUD3DDEVCOMBO_T@Ogre@@PAPAU12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAUD3DDEVCOMBO_T@Ogre@@0@Z ENDP ; std::_Iter_random<Ogre::D3DDEVCOMBO_T * *,Ogre::D3DDEVCOMBO_T * *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Move_cat@PAPAUD3DDEVCOMBO_T@Ogre@@@std@@YA?AU_Undefined_move_tag@0@ABQAPAUD3DDEVCOMBO_T@Ogre@@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
??$_Move_cat@PAPAUD3DDEVCOMBO_T@Ogre@@@std@@YA?AU_Undefined_move_tag@0@ABQAPAUD3DDEVCOMBO_T@Ogre@@@Z PROC ; std::_Move_cat<Ogre::D3DDEVCOMBO_T * *>, COMDAT

; 1200 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1201 : 		typename _Move_operation_category<typename iterator_traits<_Iter>::value_type>::_Move_cat _Cat;
; 1202 : 		return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 1203 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Move_cat@PAPAUD3DDEVCOMBO_T@Ogre@@@std@@YA?AU_Undefined_move_tag@0@ABQAPAUD3DDEVCOMBO_T@Ogre@@@Z ENDP ; std::_Move_cat<Ogre::D3DDEVCOMBO_T * *>
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@PAPAUD3DDEVCOMBO_T@Ogre@@PAPAU12@Urandom_access_iterator_tag@std@@@std@@YAPAPAUD3DDEVCOMBO_T@Ogre@@PAPAU12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<Ogre::D3DDEVCOMBO_T * *,Ogre::D3DDEVCOMBO_T * *,std::random_access_iterator_tag>
; Function compile flags: /Odtp
;	COMDAT ??$_Move_backward_opt@PAPAUD3DDEVCOMBO_T@Ogre@@PAPAU12@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@4@@std@@YAPAPAUD3DDEVCOMBO_T@Ogre@@PAPAU12@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T143586 = -2						; size = 1
$T143585 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__First_dest_cat$ = 20					; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Move_backward_opt@PAPAUD3DDEVCOMBO_T@Ogre@@PAPAU12@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@4@@std@@YAPAPAUD3DDEVCOMBO_T@Ogre@@PAPAU12@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Move_backward_opt<Ogre::D3DDEVCOMBO_T * *,Ogre::D3DDEVCOMBO_T * *,std::random_access_iterator_tag,std::_Undefined_move_tag>, COMDAT

; 2752 : 	{	// move defaults to copy if there is not a more effecient way

	push	ebp
	mov	ebp, esp
	push	ecx

; 2753 : 	return _Copy_backward_opt(_First, _Last, _Dest,
; 2754 : 		_First_dest_cat, _Ptr_cat(_First, _Dest), _Range_checked_iterator_tag());

	xor	eax, eax
	mov	BYTE PTR $T143585[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAPAUD3DDEVCOMBO_T@Ogre@@PAPAU12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAUD3DDEVCOMBO_T@Ogre@@0@Z ; std::_Ptr_cat<Ogre::D3DDEVCOMBO_T * *,Ogre::D3DDEVCOMBO_T * *>
	add	esp, 8
	mov	BYTE PTR $T143586[ebp], al
	movzx	eax, BYTE PTR $T143585[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T143586[ebp]
	push	ecx
	movzx	edx, BYTE PTR __First_dest_cat$[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Copy_backward_opt@PAPAUD3DDEVCOMBO_T@Ogre@@PAPAU12@Urandom_access_iterator_tag@std@@@std@@YAPAPAUD3DDEVCOMBO_T@Ogre@@PAPAU12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<Ogre::D3DDEVCOMBO_T * *,Ogre::D3DDEVCOMBO_T * *,std::random_access_iterator_tag>
	add	esp, 24					; 00000018H

; 2755 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Move_backward_opt@PAPAUD3DDEVCOMBO_T@Ogre@@PAPAU12@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@4@@std@@YAPAPAUD3DDEVCOMBO_T@Ogre@@PAPAU12@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Move_backward_opt<Ogre::D3DDEVCOMBO_T * *,Ogre::D3DDEVCOMBO_T * *,std::random_access_iterator_tag,std::_Undefined_move_tag>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@YAXPAU_D3DDISPLAYMODE@@0AAV?$allocator@U_D3DDISPLAYMODE@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@YAXPAU_D3DDISPLAYMODE@@0AAV?$allocator@U_D3DDISPLAYMODE@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<_D3DDISPLAYMODE> >, COMDAT

; 232  : 	{	// destroy [_First, _Last), arbitrary type

	push	ebp
	mov	ebp, esp

; 233  : 	for (; _First != _Last; ++_First)

	jmp	SHORT $LN3@Destroy_ra@5
$LN2@Destroy_ra@5:
	mov	eax, DWORD PTR __First$[ebp]
	add	eax, 16					; 00000010H
	mov	DWORD PTR __First$[ebp], eax
$LN3@Destroy_ra@5:
	mov	ecx, DWORD PTR __First$[ebp]
	cmp	ecx, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Destroy_ra@5

; 234  : 		_Al.destroy(_First);

	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?destroy@?$allocator@U_D3DDISPLAYMODE@@@std@@QAEXPAU_D3DDISPLAYMODE@@@Z ; std::allocator<_D3DDISPLAYMODE>::destroy
	jmp	SHORT $LN2@Destroy_ra@5
$LN4@Destroy_ra@5:

; 235  : 	}

	pop	ebp
	ret	0
??$_Destroy_range@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@YAXPAU_D3DDISPLAYMODE@@0AAV?$allocator@U_D3DDISPLAYMODE@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<_D3DDISPLAYMODE> >
_TEXT	ENDS
PUBLIC	??$_Uninit_move@PAU_D3DDISPLAYMODE@@PAU1@V?$allocator@U_D3DDISPLAYMODE@@@std@@U_Undefined_move_tag@3@@std@@YAPAU_D3DDISPLAYMODE@@PAU1@00AAV?$allocator@U_D3DDISPLAYMODE@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<_D3DDISPLAYMODE *,_D3DDISPLAYMODE *,std::allocator<_D3DDISPLAYMODE>,std::_Undefined_move_tag>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Unchecked_uninitialized_move@PAU_D3DDISPLAYMODE@@PAU1@V?$allocator@U_D3DDISPLAYMODE@@@std@@@stdext@@YAPAU_D3DDISPLAYMODE@@PAU1@00AAV?$allocator@U_D3DDISPLAYMODE@@@std@@@Z
_TEXT	SEGMENT
$T143592 = -2						; size = 1
$T143591 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Unchecked_uninitialized_move@PAU_D3DDISPLAYMODE@@PAU1@V?$allocator@U_D3DDISPLAYMODE@@@std@@@stdext@@YAPAU_D3DDISPLAYMODE@@PAU1@00AAV?$allocator@U_D3DDISPLAYMODE@@@std@@@Z PROC ; stdext::_Unchecked_uninitialized_move<_D3DDISPLAYMODE *,_D3DDISPLAYMODE *,std::allocator<_D3DDISPLAYMODE> >, COMDAT

; 861  : 	{	// move [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 862  : 	return (_STD _Uninit_move(_CHECKED_BASE(_First),
; 863  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 864  : 		_STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T143591[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	??$_Move_cat@PAU_D3DDISPLAYMODE@@@std@@YA?AU_Undefined_move_tag@0@ABQAU_D3DDISPLAYMODE@@@Z ; std::_Move_cat<_D3DDISPLAYMODE *>
	add	esp, 4
	mov	BYTE PTR $T143592[ebp], al
	movzx	edx, BYTE PTR $T143591[ebp]
	push	edx
	movzx	eax, BYTE PTR $T143592[ebp]
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	call	??$_Checked_base@PAU_D3DDISPLAYMODE@@@std@@YAPAU_D3DDISPLAYMODE@@AAPAU1@@Z ; std::_Checked_base<_D3DDISPLAYMODE *>
	add	esp, 4
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Checked_base@PAU_D3DDISPLAYMODE@@@std@@YAPAU_D3DDISPLAYMODE@@AAPAU1@@Z ; std::_Checked_base<_D3DDISPLAYMODE *>
	add	esp, 4
	push	eax
	call	??$_Uninit_move@PAU_D3DDISPLAYMODE@@PAU1@V?$allocator@U_D3DDISPLAYMODE@@@std@@U_Undefined_move_tag@3@@std@@YAPAU_D3DDISPLAYMODE@@PAU1@00AAV?$allocator@U_D3DDISPLAYMODE@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<_D3DDISPLAYMODE *,_D3DDISPLAYMODE *,std::allocator<_D3DDISPLAYMODE>,std::_Undefined_move_tag>
	add	esp, 24					; 00000018H

; 865  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Unchecked_uninitialized_move@PAU_D3DDISPLAYMODE@@PAU1@V?$allocator@U_D3DDISPLAYMODE@@@std@@@stdext@@YAPAU_D3DDISPLAYMODE@@PAU1@00AAV?$allocator@U_D3DDISPLAYMODE@@@std@@@Z ENDP ; stdext::_Unchecked_uninitialized_move<_D3DDISPLAYMODE *,_D3DDISPLAYMODE *,std::allocator<_D3DDISPLAYMODE> >
_TEXT	ENDS
PUBLIC	??$_Checked_base@PAU_D3DDISPLAYMODE@@@std@@YAPAU_D3DDISPLAYMODE@@AAPAU1@U_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<_D3DDISPLAYMODE *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Checked_base@PAU_D3DDISPLAYMODE@@@std@@YAPAU_D3DDISPLAYMODE@@AAPAU1@@Z
_TEXT	SEGMENT
__Base_tag$ = -1					; size = 1
__It$ = 8						; size = 4
??$_Checked_base@PAU_D3DDISPLAYMODE@@@std@@YAPAU_D3DDISPLAYMODE@@AAPAU1@@Z PROC ; std::_Checked_base<_D3DDISPLAYMODE *>, COMDAT

; 1163 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1164 : 		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
; 1165 : 		return _Checked_base(_It, _Base_tag);

	movzx	eax, BYTE PTR __Base_tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR __It$[ebp]
	push	ecx
	call	??$_Checked_base@PAU_D3DDISPLAYMODE@@@std@@YAPAU_D3DDISPLAYMODE@@AAPAU1@U_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<_D3DDISPLAYMODE *>
	add	esp, 8

; 1166 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Checked_base@PAU_D3DDISPLAYMODE@@@std@@YAPAU_D3DDISPLAYMODE@@AAPAU1@@Z ENDP ; std::_Checked_base<_D3DDISPLAYMODE *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Fill@PAU_D3DDISPLAYMODE@@U1@@std@@YAXPAU_D3DDISPLAYMODE@@0ABU1@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$_Fill@PAU_D3DDISPLAYMODE@@U1@@std@@YAXPAU_D3DDISPLAYMODE@@0ABU1@@Z PROC ; std::_Fill<_D3DDISPLAYMODE *,_D3DDISPLAYMODE>, COMDAT

; 3156 : 	{	// copy _Val through [_First, _Last)

	push	ebp
	mov	ebp, esp

; 3157 : 	_DEBUG_RANGE(_First, _Last);
; 3158 : 	for (; _First != _Last; ++_First)

	jmp	SHORT $LN3@Fill@7
$LN2@Fill@7:
	mov	eax, DWORD PTR __First$[ebp]
	add	eax, 16					; 00000010H
	mov	DWORD PTR __First$[ebp], eax
$LN3@Fill@7:
	mov	ecx, DWORD PTR __First$[ebp]
	cmp	ecx, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Fill@7

; 3159 : 		*_First = _Val;

	mov	edx, DWORD PTR __Val$[ebp]
	mov	eax, DWORD PTR __First$[ebp]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR [edx+12]
	mov	DWORD PTR [eax+12], edx
	jmp	SHORT $LN2@Fill@7
$LN4@Fill@7:

; 3160 : 	}

	pop	ebp
	ret	0
??$_Fill@PAU_D3DDISPLAYMODE@@U1@@std@@YAXPAU_D3DDISPLAYMODE@@0ABU1@@Z ENDP ; std::_Fill<_D3DDISPLAYMODE *,_D3DDISPLAYMODE>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Iter_random@PAU_D3DDISPLAYMODE@@PAU1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAU_D3DDISPLAYMODE@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAU_D3DDISPLAYMODE@@PAU1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAU_D3DDISPLAYMODE@@0@Z PROC ; std::_Iter_random<_D3DDISPLAYMODE *,_D3DDISPLAYMODE *>, COMDAT

; 993  : 	{	// return category from iterator argument

	push	ebp
	mov	ebp, esp
	push	ecx

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 998  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Iter_random@PAU_D3DDISPLAYMODE@@PAU1@@std@@YA?AUrandom_access_iterator_tag@0@ABQAU_D3DDISPLAYMODE@@0@Z ENDP ; std::_Iter_random<_D3DDISPLAYMODE *,_D3DDISPLAYMODE *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Move_cat@PAU_D3DDISPLAYMODE@@@std@@YA?AU_Undefined_move_tag@0@ABQAU_D3DDISPLAYMODE@@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
??$_Move_cat@PAU_D3DDISPLAYMODE@@@std@@YA?AU_Undefined_move_tag@0@ABQAU_D3DDISPLAYMODE@@@Z PROC ; std::_Move_cat<_D3DDISPLAYMODE *>, COMDAT

; 1200 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1201 : 		typename _Move_operation_category<typename iterator_traits<_Iter>::value_type>::_Move_cat _Cat;
; 1202 : 		return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 1203 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Move_cat@PAU_D3DDISPLAYMODE@@@std@@YA?AU_Undefined_move_tag@0@ABQAU_D3DDISPLAYMODE@@@Z ENDP ; std::_Move_cat<_D3DDISPLAYMODE *>
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@PAU_D3DDISPLAYMODE@@PAU1@@std@@YAPAU_D3DDISPLAYMODE@@PAU1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<_D3DDISPLAYMODE *,_D3DDISPLAYMODE *>
; Function compile flags: /Odtp
;	COMDAT ??$_Move_backward_opt@PAU_D3DDISPLAYMODE@@PAU1@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAU_D3DDISPLAYMODE@@PAU1@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T143604 = -2						; size = 1
$T143603 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__First_dest_cat$ = 20					; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Move_backward_opt@PAU_D3DDISPLAYMODE@@PAU1@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAU_D3DDISPLAYMODE@@PAU1@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Move_backward_opt<_D3DDISPLAYMODE *,_D3DDISPLAYMODE *,std::random_access_iterator_tag,std::_Undefined_move_tag>, COMDAT

; 2752 : 	{	// move defaults to copy if there is not a more effecient way

	push	ebp
	mov	ebp, esp
	push	ecx

; 2753 : 	return _Copy_backward_opt(_First, _Last, _Dest,
; 2754 : 		_First_dest_cat, _Ptr_cat(_First, _Dest), _Range_checked_iterator_tag());

	xor	eax, eax
	mov	BYTE PTR $T143603[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAU_D3DDISPLAYMODE@@PAU1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAU_D3DDISPLAYMODE@@0@Z ; std::_Ptr_cat<_D3DDISPLAYMODE *,_D3DDISPLAYMODE *>
	add	esp, 8
	mov	BYTE PTR $T143604[ebp], al
	movzx	eax, BYTE PTR $T143603[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T143604[ebp]
	push	ecx
	movzx	edx, BYTE PTR __First_dest_cat$[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Copy_backward_opt@PAU_D3DDISPLAYMODE@@PAU1@@std@@YAPAU_D3DDISPLAYMODE@@PAU1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<_D3DDISPLAYMODE *,_D3DDISPLAYMODE *>
	add	esp, 24					; 00000018H

; 2755 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Move_backward_opt@PAU_D3DDISPLAYMODE@@PAU1@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@3@@std@@YAPAU_D3DDISPLAYMODE@@PAU1@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Move_backward_opt<_D3DDISPLAYMODE *,_D3DDISPLAYMODE *,std::random_access_iterator_tag,std::_Undefined_move_tag>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@YAXPAPAUD3DDEVICEINFO_T@Ogre@@0AAV?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@YAXPAPAUD3DDEVICEINFO_T@Ogre@@0AAV?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<Ogre::D3DDEVICEINFO_T *> >, COMDAT

; 241  : 	{	// destroy [_First, _Last), scalar type (do nothing)

	push	ebp
	mov	ebp, esp

; 242  : 	}

	pop	ebp
	ret	0
??$_Destroy_range@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@YAXPAPAUD3DDEVICEINFO_T@Ogre@@0AAV?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<Ogre::D3DDEVICEINFO_T *> >
_TEXT	ENDS
PUBLIC	??$_Uninit_move@PAPAUD3DDEVICEINFO_T@Ogre@@PAPAU12@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@U_Undefined_move_tag@4@@std@@YAPAPAUD3DDEVICEINFO_T@Ogre@@PAPAU12@00AAV?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<Ogre::D3DDEVICEINFO_T * *,Ogre::D3DDEVICEINFO_T * *,std::allocator<Ogre::D3DDEVICEINFO_T *>,std::_Undefined_move_tag>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Unchecked_uninitialized_move@PAPAUD3DDEVICEINFO_T@Ogre@@PAPAU12@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@stdext@@YAPAPAUD3DDEVICEINFO_T@Ogre@@PAPAU12@00AAV?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@Z
_TEXT	SEGMENT
$T143610 = -2						; size = 1
$T143609 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Unchecked_uninitialized_move@PAPAUD3DDEVICEINFO_T@Ogre@@PAPAU12@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@stdext@@YAPAPAUD3DDEVICEINFO_T@Ogre@@PAPAU12@00AAV?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@Z PROC ; stdext::_Unchecked_uninitialized_move<Ogre::D3DDEVICEINFO_T * *,Ogre::D3DDEVICEINFO_T * *,std::allocator<Ogre::D3DDEVICEINFO_T *> >, COMDAT

; 861  : 	{	// move [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 862  : 	return (_STD _Uninit_move(_CHECKED_BASE(_First),
; 863  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 864  : 		_STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T143609[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	??$_Move_cat@PAPAUD3DDEVICEINFO_T@Ogre@@@std@@YA?AU_Undefined_move_tag@0@ABQAPAUD3DDEVICEINFO_T@Ogre@@@Z ; std::_Move_cat<Ogre::D3DDEVICEINFO_T * *>
	add	esp, 4
	mov	BYTE PTR $T143610[ebp], al
	movzx	edx, BYTE PTR $T143609[ebp]
	push	edx
	movzx	eax, BYTE PTR $T143610[ebp]
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	call	??$_Checked_base@PAPAUD3DDEVICEINFO_T@Ogre@@@std@@YAPAPAUD3DDEVICEINFO_T@Ogre@@AAPAPAU12@@Z ; std::_Checked_base<Ogre::D3DDEVICEINFO_T * *>
	add	esp, 4
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Checked_base@PAPAUD3DDEVICEINFO_T@Ogre@@@std@@YAPAPAUD3DDEVICEINFO_T@Ogre@@AAPAPAU12@@Z ; std::_Checked_base<Ogre::D3DDEVICEINFO_T * *>
	add	esp, 4
	push	eax
	call	??$_Uninit_move@PAPAUD3DDEVICEINFO_T@Ogre@@PAPAU12@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@U_Undefined_move_tag@4@@std@@YAPAPAUD3DDEVICEINFO_T@Ogre@@PAPAU12@00AAV?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<Ogre::D3DDEVICEINFO_T * *,Ogre::D3DDEVICEINFO_T * *,std::allocator<Ogre::D3DDEVICEINFO_T *>,std::_Undefined_move_tag>
	add	esp, 24					; 00000018H

; 865  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Unchecked_uninitialized_move@PAPAUD3DDEVICEINFO_T@Ogre@@PAPAU12@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@stdext@@YAPAPAUD3DDEVICEINFO_T@Ogre@@PAPAU12@00AAV?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@Z ENDP ; stdext::_Unchecked_uninitialized_move<Ogre::D3DDEVICEINFO_T * *,Ogre::D3DDEVICEINFO_T * *,std::allocator<Ogre::D3DDEVICEINFO_T *> >
_TEXT	ENDS
PUBLIC	??$_Checked_base@PAPAUD3DDEVICEINFO_T@Ogre@@@std@@YAPAPAUD3DDEVICEINFO_T@Ogre@@AAPAPAU12@U_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<Ogre::D3DDEVICEINFO_T * *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Checked_base@PAPAUD3DDEVICEINFO_T@Ogre@@@std@@YAPAPAUD3DDEVICEINFO_T@Ogre@@AAPAPAU12@@Z
_TEXT	SEGMENT
__Base_tag$ = -1					; size = 1
__It$ = 8						; size = 4
??$_Checked_base@PAPAUD3DDEVICEINFO_T@Ogre@@@std@@YAPAPAUD3DDEVICEINFO_T@Ogre@@AAPAPAU12@@Z PROC ; std::_Checked_base<Ogre::D3DDEVICEINFO_T * *>, COMDAT

; 1163 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1164 : 		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
; 1165 : 		return _Checked_base(_It, _Base_tag);

	movzx	eax, BYTE PTR __Base_tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR __It$[ebp]
	push	ecx
	call	??$_Checked_base@PAPAUD3DDEVICEINFO_T@Ogre@@@std@@YAPAPAUD3DDEVICEINFO_T@Ogre@@AAPAPAU12@U_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<Ogre::D3DDEVICEINFO_T * *>
	add	esp, 8

; 1166 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Checked_base@PAPAUD3DDEVICEINFO_T@Ogre@@@std@@YAPAPAUD3DDEVICEINFO_T@Ogre@@AAPAPAU12@@Z ENDP ; std::_Checked_base<Ogre::D3DDEVICEINFO_T * *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Fill@PAPAUD3DDEVICEINFO_T@Ogre@@PAU12@@std@@YAXPAPAUD3DDEVICEINFO_T@Ogre@@0ABQAU12@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$_Fill@PAPAUD3DDEVICEINFO_T@Ogre@@PAU12@@std@@YAXPAPAUD3DDEVICEINFO_T@Ogre@@0ABQAU12@@Z PROC ; std::_Fill<Ogre::D3DDEVICEINFO_T * *,Ogre::D3DDEVICEINFO_T *>, COMDAT

; 3156 : 	{	// copy _Val through [_First, _Last)

	push	ebp
	mov	ebp, esp

; 3157 : 	_DEBUG_RANGE(_First, _Last);
; 3158 : 	for (; _First != _Last; ++_First)

	jmp	SHORT $LN3@Fill@8
$LN2@Fill@8:
	mov	eax, DWORD PTR __First$[ebp]
	add	eax, 4
	mov	DWORD PTR __First$[ebp], eax
$LN3@Fill@8:
	mov	ecx, DWORD PTR __First$[ebp]
	cmp	ecx, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Fill@8

; 3159 : 		*_First = _Val;

	mov	edx, DWORD PTR __First$[ebp]
	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	jmp	SHORT $LN2@Fill@8
$LN4@Fill@8:

; 3160 : 	}

	pop	ebp
	ret	0
??$_Fill@PAPAUD3DDEVICEINFO_T@Ogre@@PAU12@@std@@YAXPAPAUD3DDEVICEINFO_T@Ogre@@0ABQAU12@@Z ENDP ; std::_Fill<Ogre::D3DDEVICEINFO_T * *,Ogre::D3DDEVICEINFO_T *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Iter_random@PAPAUD3DDEVICEINFO_T@Ogre@@PAPAU12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAUD3DDEVICEINFO_T@Ogre@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAPAUD3DDEVICEINFO_T@Ogre@@PAPAU12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAUD3DDEVICEINFO_T@Ogre@@0@Z PROC ; std::_Iter_random<Ogre::D3DDEVICEINFO_T * *,Ogre::D3DDEVICEINFO_T * *>, COMDAT

; 993  : 	{	// return category from iterator argument

	push	ebp
	mov	ebp, esp
	push	ecx

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 998  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Iter_random@PAPAUD3DDEVICEINFO_T@Ogre@@PAPAU12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAUD3DDEVICEINFO_T@Ogre@@0@Z ENDP ; std::_Iter_random<Ogre::D3DDEVICEINFO_T * *,Ogre::D3DDEVICEINFO_T * *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Move_cat@PAPAUD3DDEVICEINFO_T@Ogre@@@std@@YA?AU_Undefined_move_tag@0@ABQAPAUD3DDEVICEINFO_T@Ogre@@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
??$_Move_cat@PAPAUD3DDEVICEINFO_T@Ogre@@@std@@YA?AU_Undefined_move_tag@0@ABQAPAUD3DDEVICEINFO_T@Ogre@@@Z PROC ; std::_Move_cat<Ogre::D3DDEVICEINFO_T * *>, COMDAT

; 1200 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1201 : 		typename _Move_operation_category<typename iterator_traits<_Iter>::value_type>::_Move_cat _Cat;
; 1202 : 		return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 1203 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Move_cat@PAPAUD3DDEVICEINFO_T@Ogre@@@std@@YA?AU_Undefined_move_tag@0@ABQAPAUD3DDEVICEINFO_T@Ogre@@@Z ENDP ; std::_Move_cat<Ogre::D3DDEVICEINFO_T * *>
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@PAPAUD3DDEVICEINFO_T@Ogre@@PAPAU12@Urandom_access_iterator_tag@std@@@std@@YAPAPAUD3DDEVICEINFO_T@Ogre@@PAPAU12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<Ogre::D3DDEVICEINFO_T * *,Ogre::D3DDEVICEINFO_T * *,std::random_access_iterator_tag>
; Function compile flags: /Odtp
;	COMDAT ??$_Move_backward_opt@PAPAUD3DDEVICEINFO_T@Ogre@@PAPAU12@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@4@@std@@YAPAPAUD3DDEVICEINFO_T@Ogre@@PAPAU12@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T143622 = -2						; size = 1
$T143621 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__First_dest_cat$ = 20					; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Move_backward_opt@PAPAUD3DDEVICEINFO_T@Ogre@@PAPAU12@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@4@@std@@YAPAPAUD3DDEVICEINFO_T@Ogre@@PAPAU12@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Move_backward_opt<Ogre::D3DDEVICEINFO_T * *,Ogre::D3DDEVICEINFO_T * *,std::random_access_iterator_tag,std::_Undefined_move_tag>, COMDAT

; 2752 : 	{	// move defaults to copy if there is not a more effecient way

	push	ebp
	mov	ebp, esp
	push	ecx

; 2753 : 	return _Copy_backward_opt(_First, _Last, _Dest,
; 2754 : 		_First_dest_cat, _Ptr_cat(_First, _Dest), _Range_checked_iterator_tag());

	xor	eax, eax
	mov	BYTE PTR $T143621[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAPAUD3DDEVICEINFO_T@Ogre@@PAPAU12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAUD3DDEVICEINFO_T@Ogre@@0@Z ; std::_Ptr_cat<Ogre::D3DDEVICEINFO_T * *,Ogre::D3DDEVICEINFO_T * *>
	add	esp, 8
	mov	BYTE PTR $T143622[ebp], al
	movzx	eax, BYTE PTR $T143621[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T143622[ebp]
	push	ecx
	movzx	edx, BYTE PTR __First_dest_cat$[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Copy_backward_opt@PAPAUD3DDEVICEINFO_T@Ogre@@PAPAU12@Urandom_access_iterator_tag@std@@@std@@YAPAPAUD3DDEVICEINFO_T@Ogre@@PAPAU12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<Ogre::D3DDEVICEINFO_T * *,Ogre::D3DDEVICEINFO_T * *,std::random_access_iterator_tag>
	add	esp, 24					; 00000018H

; 2755 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Move_backward_opt@PAPAUD3DDEVICEINFO_T@Ogre@@PAPAU12@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@4@@std@@YAPAPAUD3DDEVICEINFO_T@Ogre@@PAPAU12@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Move_backward_opt<Ogre::D3DDEVICEINFO_T * *,Ogre::D3DDEVICEINFO_T * *,std::random_access_iterator_tag,std::_Undefined_move_tag>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@YAXPAPAUD3DADAPTER_T@Ogre@@0AAV?$allocator@PAUD3DADAPTER_T@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@YAXPAPAUD3DADAPTER_T@Ogre@@0AAV?$allocator@PAUD3DADAPTER_T@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<Ogre::D3DADAPTER_T *> >, COMDAT

; 241  : 	{	// destroy [_First, _Last), scalar type (do nothing)

	push	ebp
	mov	ebp, esp

; 242  : 	}

	pop	ebp
	ret	0
??$_Destroy_range@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@YAXPAPAUD3DADAPTER_T@Ogre@@0AAV?$allocator@PAUD3DADAPTER_T@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<Ogre::D3DADAPTER_T *> >
_TEXT	ENDS
PUBLIC	??$_Uninit_move@PAPAUD3DADAPTER_T@Ogre@@PAPAU12@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@U_Undefined_move_tag@4@@std@@YAPAPAUD3DADAPTER_T@Ogre@@PAPAU12@00AAV?$allocator@PAUD3DADAPTER_T@Ogre@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<Ogre::D3DADAPTER_T * *,Ogre::D3DADAPTER_T * *,std::allocator<Ogre::D3DADAPTER_T *>,std::_Undefined_move_tag>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Unchecked_uninitialized_move@PAPAUD3DADAPTER_T@Ogre@@PAPAU12@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@stdext@@YAPAPAUD3DADAPTER_T@Ogre@@PAPAU12@00AAV?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@Z
_TEXT	SEGMENT
$T143628 = -2						; size = 1
$T143627 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Unchecked_uninitialized_move@PAPAUD3DADAPTER_T@Ogre@@PAPAU12@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@stdext@@YAPAPAUD3DADAPTER_T@Ogre@@PAPAU12@00AAV?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@Z PROC ; stdext::_Unchecked_uninitialized_move<Ogre::D3DADAPTER_T * *,Ogre::D3DADAPTER_T * *,std::allocator<Ogre::D3DADAPTER_T *> >, COMDAT

; 861  : 	{	// move [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 862  : 	return (_STD _Uninit_move(_CHECKED_BASE(_First),
; 863  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 864  : 		_STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T143627[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	??$_Move_cat@PAPAUD3DADAPTER_T@Ogre@@@std@@YA?AU_Undefined_move_tag@0@ABQAPAUD3DADAPTER_T@Ogre@@@Z ; std::_Move_cat<Ogre::D3DADAPTER_T * *>
	add	esp, 4
	mov	BYTE PTR $T143628[ebp], al
	movzx	edx, BYTE PTR $T143627[ebp]
	push	edx
	movzx	eax, BYTE PTR $T143628[ebp]
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	call	??$_Checked_base@PAPAUD3DADAPTER_T@Ogre@@@std@@YAPAPAUD3DADAPTER_T@Ogre@@AAPAPAU12@@Z ; std::_Checked_base<Ogre::D3DADAPTER_T * *>
	add	esp, 4
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Checked_base@PAPAUD3DADAPTER_T@Ogre@@@std@@YAPAPAUD3DADAPTER_T@Ogre@@AAPAPAU12@@Z ; std::_Checked_base<Ogre::D3DADAPTER_T * *>
	add	esp, 4
	push	eax
	call	??$_Uninit_move@PAPAUD3DADAPTER_T@Ogre@@PAPAU12@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@U_Undefined_move_tag@4@@std@@YAPAPAUD3DADAPTER_T@Ogre@@PAPAU12@00AAV?$allocator@PAUD3DADAPTER_T@Ogre@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<Ogre::D3DADAPTER_T * *,Ogre::D3DADAPTER_T * *,std::allocator<Ogre::D3DADAPTER_T *>,std::_Undefined_move_tag>
	add	esp, 24					; 00000018H

; 865  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Unchecked_uninitialized_move@PAPAUD3DADAPTER_T@Ogre@@PAPAU12@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@stdext@@YAPAPAUD3DADAPTER_T@Ogre@@PAPAU12@00AAV?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@Z ENDP ; stdext::_Unchecked_uninitialized_move<Ogre::D3DADAPTER_T * *,Ogre::D3DADAPTER_T * *,std::allocator<Ogre::D3DADAPTER_T *> >
_TEXT	ENDS
PUBLIC	??$_Checked_base@PAPAUD3DADAPTER_T@Ogre@@@std@@YAPAPAUD3DADAPTER_T@Ogre@@AAPAPAU12@U_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<Ogre::D3DADAPTER_T * *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Checked_base@PAPAUD3DADAPTER_T@Ogre@@@std@@YAPAPAUD3DADAPTER_T@Ogre@@AAPAPAU12@@Z
_TEXT	SEGMENT
__Base_tag$ = -1					; size = 1
__It$ = 8						; size = 4
??$_Checked_base@PAPAUD3DADAPTER_T@Ogre@@@std@@YAPAPAUD3DADAPTER_T@Ogre@@AAPAPAU12@@Z PROC ; std::_Checked_base<Ogre::D3DADAPTER_T * *>, COMDAT

; 1163 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1164 : 		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
; 1165 : 		return _Checked_base(_It, _Base_tag);

	movzx	eax, BYTE PTR __Base_tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR __It$[ebp]
	push	ecx
	call	??$_Checked_base@PAPAUD3DADAPTER_T@Ogre@@@std@@YAPAPAUD3DADAPTER_T@Ogre@@AAPAPAU12@U_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<Ogre::D3DADAPTER_T * *>
	add	esp, 8

; 1166 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Checked_base@PAPAUD3DADAPTER_T@Ogre@@@std@@YAPAPAUD3DADAPTER_T@Ogre@@AAPAPAU12@@Z ENDP ; std::_Checked_base<Ogre::D3DADAPTER_T * *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Fill@PAPAUD3DADAPTER_T@Ogre@@PAU12@@std@@YAXPAPAUD3DADAPTER_T@Ogre@@0ABQAU12@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$_Fill@PAPAUD3DADAPTER_T@Ogre@@PAU12@@std@@YAXPAPAUD3DADAPTER_T@Ogre@@0ABQAU12@@Z PROC ; std::_Fill<Ogre::D3DADAPTER_T * *,Ogre::D3DADAPTER_T *>, COMDAT

; 3156 : 	{	// copy _Val through [_First, _Last)

	push	ebp
	mov	ebp, esp

; 3157 : 	_DEBUG_RANGE(_First, _Last);
; 3158 : 	for (; _First != _Last; ++_First)

	jmp	SHORT $LN3@Fill@9
$LN2@Fill@9:
	mov	eax, DWORD PTR __First$[ebp]
	add	eax, 4
	mov	DWORD PTR __First$[ebp], eax
$LN3@Fill@9:
	mov	ecx, DWORD PTR __First$[ebp]
	cmp	ecx, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Fill@9

; 3159 : 		*_First = _Val;

	mov	edx, DWORD PTR __First$[ebp]
	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	jmp	SHORT $LN2@Fill@9
$LN4@Fill@9:

; 3160 : 	}

	pop	ebp
	ret	0
??$_Fill@PAPAUD3DADAPTER_T@Ogre@@PAU12@@std@@YAXPAPAUD3DADAPTER_T@Ogre@@0ABQAU12@@Z ENDP ; std::_Fill<Ogre::D3DADAPTER_T * *,Ogre::D3DADAPTER_T *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Iter_random@PAPAUD3DADAPTER_T@Ogre@@PAPAU12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAUD3DADAPTER_T@Ogre@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAPAUD3DADAPTER_T@Ogre@@PAPAU12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAUD3DADAPTER_T@Ogre@@0@Z PROC ; std::_Iter_random<Ogre::D3DADAPTER_T * *,Ogre::D3DADAPTER_T * *>, COMDAT

; 993  : 	{	// return category from iterator argument

	push	ebp
	mov	ebp, esp
	push	ecx

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 998  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Iter_random@PAPAUD3DADAPTER_T@Ogre@@PAPAU12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAUD3DADAPTER_T@Ogre@@0@Z ENDP ; std::_Iter_random<Ogre::D3DADAPTER_T * *,Ogre::D3DADAPTER_T * *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Move_cat@PAPAUD3DADAPTER_T@Ogre@@@std@@YA?AU_Undefined_move_tag@0@ABQAPAUD3DADAPTER_T@Ogre@@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
??$_Move_cat@PAPAUD3DADAPTER_T@Ogre@@@std@@YA?AU_Undefined_move_tag@0@ABQAPAUD3DADAPTER_T@Ogre@@@Z PROC ; std::_Move_cat<Ogre::D3DADAPTER_T * *>, COMDAT

; 1200 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1201 : 		typename _Move_operation_category<typename iterator_traits<_Iter>::value_type>::_Move_cat _Cat;
; 1202 : 		return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 1203 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Move_cat@PAPAUD3DADAPTER_T@Ogre@@@std@@YA?AU_Undefined_move_tag@0@ABQAPAUD3DADAPTER_T@Ogre@@@Z ENDP ; std::_Move_cat<Ogre::D3DADAPTER_T * *>
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@PAPAUD3DADAPTER_T@Ogre@@PAPAU12@Urandom_access_iterator_tag@std@@@std@@YAPAPAUD3DADAPTER_T@Ogre@@PAPAU12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<Ogre::D3DADAPTER_T * *,Ogre::D3DADAPTER_T * *,std::random_access_iterator_tag>
; Function compile flags: /Odtp
;	COMDAT ??$_Move_backward_opt@PAPAUD3DADAPTER_T@Ogre@@PAPAU12@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@4@@std@@YAPAPAUD3DADAPTER_T@Ogre@@PAPAU12@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T143640 = -2						; size = 1
$T143639 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__First_dest_cat$ = 20					; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Move_backward_opt@PAPAUD3DADAPTER_T@Ogre@@PAPAU12@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@4@@std@@YAPAPAUD3DADAPTER_T@Ogre@@PAPAU12@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Move_backward_opt<Ogre::D3DADAPTER_T * *,Ogre::D3DADAPTER_T * *,std::random_access_iterator_tag,std::_Undefined_move_tag>, COMDAT

; 2752 : 	{	// move defaults to copy if there is not a more effecient way

	push	ebp
	mov	ebp, esp
	push	ecx

; 2753 : 	return _Copy_backward_opt(_First, _Last, _Dest,
; 2754 : 		_First_dest_cat, _Ptr_cat(_First, _Dest), _Range_checked_iterator_tag());

	xor	eax, eax
	mov	BYTE PTR $T143639[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAPAUD3DADAPTER_T@Ogre@@PAPAU12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAUD3DADAPTER_T@Ogre@@0@Z ; std::_Ptr_cat<Ogre::D3DADAPTER_T * *,Ogre::D3DADAPTER_T * *>
	add	esp, 8
	mov	BYTE PTR $T143640[ebp], al
	movzx	eax, BYTE PTR $T143639[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T143640[ebp]
	push	ecx
	movzx	edx, BYTE PTR __First_dest_cat$[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Copy_backward_opt@PAPAUD3DADAPTER_T@Ogre@@PAPAU12@Urandom_access_iterator_tag@std@@@std@@YAPAPAUD3DADAPTER_T@Ogre@@PAPAU12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<Ogre::D3DADAPTER_T * *,Ogre::D3DADAPTER_T * *,std::random_access_iterator_tag>
	add	esp, 24					; 00000018H

; 2755 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Move_backward_opt@PAPAUD3DADAPTER_T@Ogre@@PAPAU12@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@4@@std@@YAPAPAUD3DADAPTER_T@Ogre@@PAPAU12@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Move_backward_opt<Ogre::D3DADAPTER_T * *,Ogre::D3DADAPTER_T * *,std::random_access_iterator_tag,std::_Undefined_move_tag>
_TEXT	ENDS
PUBLIC	??$_Construct@W4_D3DFORMAT@@W41@@std@@YAXPAW4_D3DFORMAT@@ABW41@@Z ; std::_Construct<enum _D3DFORMAT,enum _D3DFORMAT>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?construct@?$allocator@W4_D3DFORMAT@@@std@@QAEXPAW4_D3DFORMAT@@ABW43@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@W4_D3DFORMAT@@@std@@QAEXPAW4_D3DFORMAT@@ABW43@@Z PROC ; std::allocator<enum _D3DFORMAT>::construct, COMDAT
; _this$ = ecx

; 154  : 		{	// construct object at _Ptr with value _Val

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 155  : 		_Construct(_Ptr, _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	call	??$_Construct@W4_D3DFORMAT@@W41@@std@@YAXPAW4_D3DFORMAT@@ABW41@@Z ; std::_Construct<enum _D3DFORMAT,enum _D3DFORMAT>
	add	esp, 8

; 156  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?construct@?$allocator@W4_D3DFORMAT@@@std@@QAEXPAW4_D3DFORMAT@@ABW43@@Z ENDP ; std::allocator<enum _D3DFORMAT>::construct
_TEXT	ENDS
PUBLIC	??$_Destroy@W4_D3DFORMAT@@@std@@YAXPAW4_D3DFORMAT@@@Z ; std::_Destroy<enum _D3DFORMAT>
; Function compile flags: /Odtp
;	COMDAT ?destroy@?$allocator@W4_D3DFORMAT@@@std@@QAEXPAW4_D3DFORMAT@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?destroy@?$allocator@W4_D3DFORMAT@@@std@@QAEXPAW4_D3DFORMAT@@@Z PROC ; std::allocator<enum _D3DFORMAT>::destroy, COMDAT
; _this$ = ecx

; 159  : 		{	// destroy object at _Ptr

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 160  : 		_Destroy(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??$_Destroy@W4_D3DFORMAT@@@std@@YAXPAW4_D3DFORMAT@@@Z ; std::_Destroy<enum _D3DFORMAT>
	add	esp, 4

; 161  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?destroy@?$allocator@W4_D3DFORMAT@@@std@@QAEXPAW4_D3DFORMAT@@@Z ENDP ; std::allocator<enum _D3DFORMAT>::destroy
_TEXT	ENDS
PUBLIC	??$_Construct@W4_D3DMULTISAMPLE_TYPE@@W41@@std@@YAXPAW4_D3DMULTISAMPLE_TYPE@@ABW41@@Z ; std::_Construct<enum _D3DMULTISAMPLE_TYPE,enum _D3DMULTISAMPLE_TYPE>
; Function compile flags: /Odtp
;	COMDAT ?construct@?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@QAEXPAW4_D3DMULTISAMPLE_TYPE@@ABW43@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@QAEXPAW4_D3DMULTISAMPLE_TYPE@@ABW43@@Z PROC ; std::allocator<enum _D3DMULTISAMPLE_TYPE>::construct, COMDAT
; _this$ = ecx

; 154  : 		{	// construct object at _Ptr with value _Val

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 155  : 		_Construct(_Ptr, _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	call	??$_Construct@W4_D3DMULTISAMPLE_TYPE@@W41@@std@@YAXPAW4_D3DMULTISAMPLE_TYPE@@ABW41@@Z ; std::_Construct<enum _D3DMULTISAMPLE_TYPE,enum _D3DMULTISAMPLE_TYPE>
	add	esp, 8

; 156  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?construct@?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@QAEXPAW4_D3DMULTISAMPLE_TYPE@@ABW43@@Z ENDP ; std::allocator<enum _D3DMULTISAMPLE_TYPE>::construct
_TEXT	ENDS
PUBLIC	??$_Destroy@W4_D3DMULTISAMPLE_TYPE@@@std@@YAXPAW4_D3DMULTISAMPLE_TYPE@@@Z ; std::_Destroy<enum _D3DMULTISAMPLE_TYPE>
; Function compile flags: /Odtp
;	COMDAT ?destroy@?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@QAEXPAW4_D3DMULTISAMPLE_TYPE@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?destroy@?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@QAEXPAW4_D3DMULTISAMPLE_TYPE@@@Z PROC ; std::allocator<enum _D3DMULTISAMPLE_TYPE>::destroy, COMDAT
; _this$ = ecx

; 159  : 		{	// destroy object at _Ptr

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 160  : 		_Destroy(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??$_Destroy@W4_D3DMULTISAMPLE_TYPE@@@std@@YAXPAW4_D3DMULTISAMPLE_TYPE@@@Z ; std::_Destroy<enum _D3DMULTISAMPLE_TYPE>
	add	esp, 4

; 161  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?destroy@?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@QAEXPAW4_D3DMULTISAMPLE_TYPE@@@Z ENDP ; std::allocator<enum _D3DMULTISAMPLE_TYPE>::destroy
_TEXT	ENDS
PUBLIC	??$_Construct@UD3DSMSCONFLICT_T@Ogre@@U12@@std@@YAXPAUD3DSMSCONFLICT_T@Ogre@@ABU12@@Z ; std::_Construct<Ogre::D3DSMSCONFLICT_T,Ogre::D3DSMSCONFLICT_T>
; Function compile flags: /Odtp
;	COMDAT ?construct@?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@QAEXPAUD3DSMSCONFLICT_T@Ogre@@ABU34@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@QAEXPAUD3DSMSCONFLICT_T@Ogre@@ABU34@@Z PROC ; std::allocator<Ogre::D3DSMSCONFLICT_T>::construct, COMDAT
; _this$ = ecx

; 154  : 		{	// construct object at _Ptr with value _Val

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 155  : 		_Construct(_Ptr, _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	call	??$_Construct@UD3DSMSCONFLICT_T@Ogre@@U12@@std@@YAXPAUD3DSMSCONFLICT_T@Ogre@@ABU12@@Z ; std::_Construct<Ogre::D3DSMSCONFLICT_T,Ogre::D3DSMSCONFLICT_T>
	add	esp, 8

; 156  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?construct@?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@QAEXPAUD3DSMSCONFLICT_T@Ogre@@ABU34@@Z ENDP ; std::allocator<Ogre::D3DSMSCONFLICT_T>::construct
_TEXT	ENDS
PUBLIC	??$_Destroy@UD3DSMSCONFLICT_T@Ogre@@@std@@YAXPAUD3DSMSCONFLICT_T@Ogre@@@Z ; std::_Destroy<Ogre::D3DSMSCONFLICT_T>
; Function compile flags: /Odtp
;	COMDAT ?destroy@?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@QAEXPAUD3DSMSCONFLICT_T@Ogre@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?destroy@?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@QAEXPAUD3DSMSCONFLICT_T@Ogre@@@Z PROC ; std::allocator<Ogre::D3DSMSCONFLICT_T>::destroy, COMDAT
; _this$ = ecx

; 159  : 		{	// destroy object at _Ptr

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 160  : 		_Destroy(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??$_Destroy@UD3DSMSCONFLICT_T@Ogre@@@std@@YAXPAUD3DSMSCONFLICT_T@Ogre@@@Z ; std::_Destroy<Ogre::D3DSMSCONFLICT_T>
	add	esp, 4

; 161  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?destroy@?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@QAEXPAUD3DSMSCONFLICT_T@Ogre@@@Z ENDP ; std::allocator<Ogre::D3DSMSCONFLICT_T>::destroy
_TEXT	ENDS
PUBLIC	??$_Construct@W4VERTPROCESS_T@Ogre@@W412@@std@@YAXPAW4VERTPROCESS_T@Ogre@@ABW412@@Z ; std::_Construct<enum Ogre::VERTPROCESS_T,enum Ogre::VERTPROCESS_T>
; Function compile flags: /Odtp
;	COMDAT ?construct@?$allocator@W4VERTPROCESS_T@Ogre@@@std@@QAEXPAW4VERTPROCESS_T@Ogre@@ABW434@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@W4VERTPROCESS_T@Ogre@@@std@@QAEXPAW4VERTPROCESS_T@Ogre@@ABW434@@Z PROC ; std::allocator<enum Ogre::VERTPROCESS_T>::construct, COMDAT
; _this$ = ecx

; 154  : 		{	// construct object at _Ptr with value _Val

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 155  : 		_Construct(_Ptr, _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	call	??$_Construct@W4VERTPROCESS_T@Ogre@@W412@@std@@YAXPAW4VERTPROCESS_T@Ogre@@ABW412@@Z ; std::_Construct<enum Ogre::VERTPROCESS_T,enum Ogre::VERTPROCESS_T>
	add	esp, 8

; 156  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?construct@?$allocator@W4VERTPROCESS_T@Ogre@@@std@@QAEXPAW4VERTPROCESS_T@Ogre@@ABW434@@Z ENDP ; std::allocator<enum Ogre::VERTPROCESS_T>::construct
_TEXT	ENDS
PUBLIC	??$_Destroy@W4VERTPROCESS_T@Ogre@@@std@@YAXPAW4VERTPROCESS_T@Ogre@@@Z ; std::_Destroy<enum Ogre::VERTPROCESS_T>
; Function compile flags: /Odtp
;	COMDAT ?destroy@?$allocator@W4VERTPROCESS_T@Ogre@@@std@@QAEXPAW4VERTPROCESS_T@Ogre@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?destroy@?$allocator@W4VERTPROCESS_T@Ogre@@@std@@QAEXPAW4VERTPROCESS_T@Ogre@@@Z PROC ; std::allocator<enum Ogre::VERTPROCESS_T>::destroy, COMDAT
; _this$ = ecx

; 159  : 		{	// destroy object at _Ptr

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 160  : 		_Destroy(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??$_Destroy@W4VERTPROCESS_T@Ogre@@@std@@YAXPAW4VERTPROCESS_T@Ogre@@@Z ; std::_Destroy<enum Ogre::VERTPROCESS_T>
	add	esp, 4

; 161  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?destroy@?$allocator@W4VERTPROCESS_T@Ogre@@@std@@QAEXPAW4VERTPROCESS_T@Ogre@@@Z ENDP ; std::allocator<enum Ogre::VERTPROCESS_T>::destroy
_TEXT	ENDS
PUBLIC	??$_Construct@U_D3DDISPLAYMODE@@U1@@std@@YAXPAU_D3DDISPLAYMODE@@ABU1@@Z ; std::_Construct<_D3DDISPLAYMODE,_D3DDISPLAYMODE>
; Function compile flags: /Odtp
;	COMDAT ?construct@?$allocator@U_D3DDISPLAYMODE@@@std@@QAEXPAU_D3DDISPLAYMODE@@ABU3@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@U_D3DDISPLAYMODE@@@std@@QAEXPAU_D3DDISPLAYMODE@@ABU3@@Z PROC ; std::allocator<_D3DDISPLAYMODE>::construct, COMDAT
; _this$ = ecx

; 154  : 		{	// construct object at _Ptr with value _Val

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 155  : 		_Construct(_Ptr, _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	call	??$_Construct@U_D3DDISPLAYMODE@@U1@@std@@YAXPAU_D3DDISPLAYMODE@@ABU1@@Z ; std::_Construct<_D3DDISPLAYMODE,_D3DDISPLAYMODE>
	add	esp, 8

; 156  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?construct@?$allocator@U_D3DDISPLAYMODE@@@std@@QAEXPAU_D3DDISPLAYMODE@@ABU3@@Z ENDP ; std::allocator<_D3DDISPLAYMODE>::construct
_TEXT	ENDS
PUBLIC	??$_Destroy@U_D3DDISPLAYMODE@@@std@@YAXPAU_D3DDISPLAYMODE@@@Z ; std::_Destroy<_D3DDISPLAYMODE>
; Function compile flags: /Odtp
;	COMDAT ?destroy@?$allocator@U_D3DDISPLAYMODE@@@std@@QAEXPAU_D3DDISPLAYMODE@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?destroy@?$allocator@U_D3DDISPLAYMODE@@@std@@QAEXPAU_D3DDISPLAYMODE@@@Z PROC ; std::allocator<_D3DDISPLAYMODE>::destroy, COMDAT
; _this$ = ecx

; 159  : 		{	// destroy object at _Ptr

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 160  : 		_Destroy(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??$_Destroy@U_D3DDISPLAYMODE@@@std@@YAXPAU_D3DDISPLAYMODE@@@Z ; std::_Destroy<_D3DDISPLAYMODE>
	add	esp, 4

; 161  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?destroy@?$allocator@U_D3DDISPLAYMODE@@@std@@QAEXPAU_D3DDISPLAYMODE@@@Z ENDP ; std::allocator<_D3DDISPLAYMODE>::destroy
_TEXT	ENDS
PUBLIC	??$_Fill_n@PAIII@std@@YAXPAIIABIUrandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Fill_n<unsigned int *,unsigned int,unsigned int>
PUBLIC	??$_Iter_cat@PAI@std@@YA?AUrandom_access_iterator_tag@0@ABQAI@Z ; std::_Iter_cat<unsigned int *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$unchecked_fill_n@PAIII@stdext@@YAXPAIIABI@Z
_TEXT	SEGMENT
$T143664 = -2						; size = 1
$T143663 = -1						; size = 1
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
??$unchecked_fill_n@PAIII@stdext@@YAXPAIIABI@Z PROC	; stdext::unchecked_fill_n<unsigned int *,unsigned int,unsigned int>, COMDAT

; 3720 : 	{	// copy _Val _Count times through [_First, ...)

	push	ebp
	mov	ebp, esp
	push	ecx

; 3721 : 		_STD _Fill_n(_First, _Count, _Val, _STD _Iter_cat(_First), _STD _Range_checked_iterator_tag());

	xor	eax, eax
	mov	BYTE PTR $T143663[ebp], al
	movzx	ecx, BYTE PTR $T143663[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	lea	eax, DWORD PTR $T143664[ebp]
	push	eax
	call	??$_Iter_cat@PAI@std@@YA?AUrandom_access_iterator_tag@0@ABQAI@Z ; std::_Iter_cat<unsigned int *>
	add	esp, 8
	movzx	ecx, BYTE PTR [eax]
	push	ecx
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Fill_n@PAIII@std@@YAXPAIIABIUrandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Fill_n<unsigned int *,unsigned int,unsigned int>
	add	esp, 20					; 00000014H

; 3722 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_fill_n@PAIII@stdext@@YAXPAIIABI@Z ENDP	; stdext::unchecked_fill_n<unsigned int *,unsigned int,unsigned int>
_TEXT	ENDS
PUBLIC	??$_Fill_n@PAPAUD3DDEVCOMBO_T@Ogre@@IPAU12@@std@@YAXPAPAUD3DDEVCOMBO_T@Ogre@@IABQAU12@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Fill_n<Ogre::D3DDEVCOMBO_T * *,unsigned int,Ogre::D3DDEVCOMBO_T *>
PUBLIC	??$_Iter_cat@PAPAUD3DDEVCOMBO_T@Ogre@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAUD3DDEVCOMBO_T@Ogre@@@Z ; std::_Iter_cat<Ogre::D3DDEVCOMBO_T * *>
; Function compile flags: /Odtp
;	COMDAT ??$unchecked_fill_n@PAPAUD3DDEVCOMBO_T@Ogre@@IPAU12@@stdext@@YAXPAPAUD3DDEVCOMBO_T@Ogre@@IABQAU12@@Z
_TEXT	SEGMENT
$T143668 = -2						; size = 1
$T143667 = -1						; size = 1
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
??$unchecked_fill_n@PAPAUD3DDEVCOMBO_T@Ogre@@IPAU12@@stdext@@YAXPAPAUD3DDEVCOMBO_T@Ogre@@IABQAU12@@Z PROC ; stdext::unchecked_fill_n<Ogre::D3DDEVCOMBO_T * *,unsigned int,Ogre::D3DDEVCOMBO_T *>, COMDAT

; 3720 : 	{	// copy _Val _Count times through [_First, ...)

	push	ebp
	mov	ebp, esp
	push	ecx

; 3721 : 		_STD _Fill_n(_First, _Count, _Val, _STD _Iter_cat(_First), _STD _Range_checked_iterator_tag());

	xor	eax, eax
	mov	BYTE PTR $T143667[ebp], al
	movzx	ecx, BYTE PTR $T143667[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	lea	eax, DWORD PTR $T143668[ebp]
	push	eax
	call	??$_Iter_cat@PAPAUD3DDEVCOMBO_T@Ogre@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAUD3DDEVCOMBO_T@Ogre@@@Z ; std::_Iter_cat<Ogre::D3DDEVCOMBO_T * *>
	add	esp, 8
	movzx	ecx, BYTE PTR [eax]
	push	ecx
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Fill_n@PAPAUD3DDEVCOMBO_T@Ogre@@IPAU12@@std@@YAXPAPAUD3DDEVCOMBO_T@Ogre@@IABQAU12@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Fill_n<Ogre::D3DDEVCOMBO_T * *,unsigned int,Ogre::D3DDEVCOMBO_T *>
	add	esp, 20					; 00000014H

; 3722 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_fill_n@PAPAUD3DDEVCOMBO_T@Ogre@@IPAU12@@stdext@@YAXPAPAUD3DDEVCOMBO_T@Ogre@@IABQAU12@@Z ENDP ; stdext::unchecked_fill_n<Ogre::D3DDEVCOMBO_T * *,unsigned int,Ogre::D3DDEVCOMBO_T *>
_TEXT	ENDS
PUBLIC	??$_Fill_n@PAPAUD3DDEVICEINFO_T@Ogre@@IPAU12@@std@@YAXPAPAUD3DDEVICEINFO_T@Ogre@@IABQAU12@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Fill_n<Ogre::D3DDEVICEINFO_T * *,unsigned int,Ogre::D3DDEVICEINFO_T *>
PUBLIC	??$_Iter_cat@PAPAUD3DDEVICEINFO_T@Ogre@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAUD3DDEVICEINFO_T@Ogre@@@Z ; std::_Iter_cat<Ogre::D3DDEVICEINFO_T * *>
; Function compile flags: /Odtp
;	COMDAT ??$unchecked_fill_n@PAPAUD3DDEVICEINFO_T@Ogre@@IPAU12@@stdext@@YAXPAPAUD3DDEVICEINFO_T@Ogre@@IABQAU12@@Z
_TEXT	SEGMENT
$T143672 = -2						; size = 1
$T143671 = -1						; size = 1
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
??$unchecked_fill_n@PAPAUD3DDEVICEINFO_T@Ogre@@IPAU12@@stdext@@YAXPAPAUD3DDEVICEINFO_T@Ogre@@IABQAU12@@Z PROC ; stdext::unchecked_fill_n<Ogre::D3DDEVICEINFO_T * *,unsigned int,Ogre::D3DDEVICEINFO_T *>, COMDAT

; 3720 : 	{	// copy _Val _Count times through [_First, ...)

	push	ebp
	mov	ebp, esp
	push	ecx

; 3721 : 		_STD _Fill_n(_First, _Count, _Val, _STD _Iter_cat(_First), _STD _Range_checked_iterator_tag());

	xor	eax, eax
	mov	BYTE PTR $T143671[ebp], al
	movzx	ecx, BYTE PTR $T143671[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	lea	eax, DWORD PTR $T143672[ebp]
	push	eax
	call	??$_Iter_cat@PAPAUD3DDEVICEINFO_T@Ogre@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAUD3DDEVICEINFO_T@Ogre@@@Z ; std::_Iter_cat<Ogre::D3DDEVICEINFO_T * *>
	add	esp, 8
	movzx	ecx, BYTE PTR [eax]
	push	ecx
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Fill_n@PAPAUD3DDEVICEINFO_T@Ogre@@IPAU12@@std@@YAXPAPAUD3DDEVICEINFO_T@Ogre@@IABQAU12@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Fill_n<Ogre::D3DDEVICEINFO_T * *,unsigned int,Ogre::D3DDEVICEINFO_T *>
	add	esp, 20					; 00000014H

; 3722 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_fill_n@PAPAUD3DDEVICEINFO_T@Ogre@@IPAU12@@stdext@@YAXPAPAUD3DDEVICEINFO_T@Ogre@@IABQAU12@@Z ENDP ; stdext::unchecked_fill_n<Ogre::D3DDEVICEINFO_T * *,unsigned int,Ogre::D3DDEVICEINFO_T *>
_TEXT	ENDS
PUBLIC	??$_Fill_n@PAPAUD3DADAPTER_T@Ogre@@IPAU12@@std@@YAXPAPAUD3DADAPTER_T@Ogre@@IABQAU12@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Fill_n<Ogre::D3DADAPTER_T * *,unsigned int,Ogre::D3DADAPTER_T *>
PUBLIC	??$_Iter_cat@PAPAUD3DADAPTER_T@Ogre@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAUD3DADAPTER_T@Ogre@@@Z ; std::_Iter_cat<Ogre::D3DADAPTER_T * *>
; Function compile flags: /Odtp
;	COMDAT ??$unchecked_fill_n@PAPAUD3DADAPTER_T@Ogre@@IPAU12@@stdext@@YAXPAPAUD3DADAPTER_T@Ogre@@IABQAU12@@Z
_TEXT	SEGMENT
$T143676 = -2						; size = 1
$T143675 = -1						; size = 1
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
??$unchecked_fill_n@PAPAUD3DADAPTER_T@Ogre@@IPAU12@@stdext@@YAXPAPAUD3DADAPTER_T@Ogre@@IABQAU12@@Z PROC ; stdext::unchecked_fill_n<Ogre::D3DADAPTER_T * *,unsigned int,Ogre::D3DADAPTER_T *>, COMDAT

; 3720 : 	{	// copy _Val _Count times through [_First, ...)

	push	ebp
	mov	ebp, esp
	push	ecx

; 3721 : 		_STD _Fill_n(_First, _Count, _Val, _STD _Iter_cat(_First), _STD _Range_checked_iterator_tag());

	xor	eax, eax
	mov	BYTE PTR $T143675[ebp], al
	movzx	ecx, BYTE PTR $T143675[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	lea	eax, DWORD PTR $T143676[ebp]
	push	eax
	call	??$_Iter_cat@PAPAUD3DADAPTER_T@Ogre@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAUD3DADAPTER_T@Ogre@@@Z ; std::_Iter_cat<Ogre::D3DADAPTER_T * *>
	add	esp, 8
	movzx	ecx, BYTE PTR [eax]
	push	ecx
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Fill_n@PAPAUD3DADAPTER_T@Ogre@@IPAU12@@std@@YAXPAPAUD3DADAPTER_T@Ogre@@IABQAU12@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Fill_n<Ogre::D3DADAPTER_T * *,unsigned int,Ogre::D3DADAPTER_T *>
	add	esp, 20					; 00000014H

; 3722 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_fill_n@PAPAUD3DADAPTER_T@Ogre@@IPAU12@@stdext@@YAXPAPAUD3DADAPTER_T@Ogre@@IABQAU12@@Z ENDP ; stdext::unchecked_fill_n<Ogre::D3DADAPTER_T * *,unsigned int,Ogre::D3DADAPTER_T *>
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@PAW4_D3DFORMAT@@PAW41@V?$allocator@W4_D3DFORMAT@@@std@@@stdext@@YAPAW4_D3DFORMAT@@PAW41@00AAV?$allocator@W4_D3DFORMAT@@@std@@@Z ; stdext::unchecked_uninitialized_copy<enum _D3DFORMAT *,enum _D3DFORMAT *,std::allocator<enum _D3DFORMAT> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Uninit_move@PAW4_D3DFORMAT@@PAW41@V?$allocator@W4_D3DFORMAT@@@std@@U_Undefined_move_tag@3@@std@@YAPAW4_D3DFORMAT@@PAW41@00AAV?$allocator@W4_D3DFORMAT@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_move@PAW4_D3DFORMAT@@PAW41@V?$allocator@W4_D3DFORMAT@@@std@@U_Undefined_move_tag@3@@std@@YAPAW4_D3DFORMAT@@PAW41@00AAV?$allocator@W4_D3DFORMAT@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_move<enum _D3DFORMAT *,enum _D3DFORMAT *,std::allocator<enum _D3DFORMAT>,std::_Undefined_move_tag>, COMDAT

; 206  : 	{	// move defaults to copy if there is not a more effecient way

	push	ebp
	mov	ebp, esp

; 207  : 	return (_STDEXT unchecked_uninitialized_copy(_First, _Last, _Dest, _Al));

	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$unchecked_uninitialized_copy@PAW4_D3DFORMAT@@PAW41@V?$allocator@W4_D3DFORMAT@@@std@@@stdext@@YAPAW4_D3DFORMAT@@PAW41@00AAV?$allocator@W4_D3DFORMAT@@@std@@@Z ; stdext::unchecked_uninitialized_copy<enum _D3DFORMAT *,enum _D3DFORMAT *,std::allocator<enum _D3DFORMAT> >
	add	esp, 16					; 00000010H

; 208  : 	}

	pop	ebp
	ret	0
??$_Uninit_move@PAW4_D3DFORMAT@@PAW41@V?$allocator@W4_D3DFORMAT@@@std@@U_Undefined_move_tag@3@@std@@YAPAW4_D3DFORMAT@@PAW41@00AAV?$allocator@W4_D3DFORMAT@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_move<enum _D3DFORMAT *,enum _D3DFORMAT *,std::allocator<enum _D3DFORMAT>,std::_Undefined_move_tag>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Checked_base@PAW4_D3DFORMAT@@@std@@YAPAW4_D3DFORMAT@@AAPAW41@U_Unchanged_checked_iterator_base_type_tag@0@@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Checked_base@PAW4_D3DFORMAT@@@std@@YAPAW4_D3DFORMAT@@AAPAW41@U_Unchanged_checked_iterator_base_type_tag@0@@Z PROC ; std::_Checked_base<enum _D3DFORMAT *>, COMDAT

; 1146 : 	{

	push	ebp
	mov	ebp, esp

; 1147 : 		return _It;

	mov	eax, DWORD PTR __It$[ebp]
	mov	eax, DWORD PTR [eax]

; 1148 : 	}

	pop	ebp
	ret	0
??$_Checked_base@PAW4_D3DFORMAT@@@std@@YAPAW4_D3DFORMAT@@AAPAW41@U_Unchanged_checked_iterator_base_type_tag@0@@Z ENDP ; std::_Checked_base<enum _D3DFORMAT *>
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@PAW4_D3DFORMAT@@PAW41@Uforward_iterator_tag@std@@@std@@YAPAW4_D3DFORMAT@@PAW41@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<enum _D3DFORMAT *,enum _D3DFORMAT *,std::forward_iterator_tag>
; Function compile flags: /Odtp
;	COMDAT ??$_Copy_backward_opt@PAW4_D3DFORMAT@@PAW41@@std@@YAPAW4_D3DFORMAT@@PAW41@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T143685 = -7						; size = 1
$T143684 = -6						; size = 1
$T143683 = -5						; size = 1
__Result$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_backward_opt@PAW4_D3DFORMAT@@PAW41@@std@@YAPAW4_D3DFORMAT@@PAW41@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<enum _D3DFORMAT *,enum _D3DFORMAT *>, COMDAT

; 2685 : 	{	// copy [_First, _Last) backwards to [..., _Dest), arbitrary iterators

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 2686 : 	// if _OutIt is range checked, this will make sure there is enough space for the copy
; 2687 : 	_OutIt _Result = _Dest - (_Last - _First);

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 2
	shl	eax, 2
	mov	ecx, DWORD PTR __Dest$[ebp]
	sub	ecx, eax
	mov	DWORD PTR __Result$[ebp], ecx

; 2688 : 	_Copy_backward_opt(_First, _Last, _CHECKED_BASE(_Dest),
; 2689 : 		forward_iterator_tag(), _Nonscalar_ptr_iterator_tag(), _Range_checked_iterator_tag());

	xor	edx, edx
	mov	BYTE PTR $T143683[ebp], dl
	xor	eax, eax
	mov	BYTE PTR $T143684[ebp], al
	movzx	ecx, BYTE PTR $T143683[ebp]
	push	ecx
	movzx	edx, BYTE PTR $T143684[ebp]
	push	edx
	movzx	eax, BYTE PTR $T143685[ebp]
	push	eax
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	??$_Checked_base@PAW4_D3DFORMAT@@@std@@YAPAW4_D3DFORMAT@@AAPAW41@@Z ; std::_Checked_base<enum _D3DFORMAT *>
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Copy_backward_opt@PAW4_D3DFORMAT@@PAW41@Uforward_iterator_tag@std@@@std@@YAPAW4_D3DFORMAT@@PAW41@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<enum _D3DFORMAT *,enum _D3DFORMAT *,std::forward_iterator_tag>
	add	esp, 24					; 00000018H

; 2690 : 	return _Result;

	mov	eax, DWORD PTR __Result$[ebp]

; 2691 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Copy_backward_opt@PAW4_D3DFORMAT@@PAW41@@std@@YAPAW4_D3DFORMAT@@PAW41@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<enum _D3DFORMAT *,enum _D3DFORMAT *>
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@PAW4_D3DMULTISAMPLE_TYPE@@PAW41@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@stdext@@YAPAW4_D3DMULTISAMPLE_TYPE@@PAW41@00AAV?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@Z ; stdext::unchecked_uninitialized_copy<enum _D3DMULTISAMPLE_TYPE *,enum _D3DMULTISAMPLE_TYPE *,std::allocator<enum _D3DMULTISAMPLE_TYPE> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Uninit_move@PAW4_D3DMULTISAMPLE_TYPE@@PAW41@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@U_Undefined_move_tag@3@@std@@YAPAW4_D3DMULTISAMPLE_TYPE@@PAW41@00AAV?$allocator@W4_D3DMULTISAMPLE_TYPE@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_move@PAW4_D3DMULTISAMPLE_TYPE@@PAW41@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@U_Undefined_move_tag@3@@std@@YAPAW4_D3DMULTISAMPLE_TYPE@@PAW41@00AAV?$allocator@W4_D3DMULTISAMPLE_TYPE@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_move<enum _D3DMULTISAMPLE_TYPE *,enum _D3DMULTISAMPLE_TYPE *,std::allocator<enum _D3DMULTISAMPLE_TYPE>,std::_Undefined_move_tag>, COMDAT

; 206  : 	{	// move defaults to copy if there is not a more effecient way

	push	ebp
	mov	ebp, esp

; 207  : 	return (_STDEXT unchecked_uninitialized_copy(_First, _Last, _Dest, _Al));

	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$unchecked_uninitialized_copy@PAW4_D3DMULTISAMPLE_TYPE@@PAW41@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@stdext@@YAPAW4_D3DMULTISAMPLE_TYPE@@PAW41@00AAV?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@Z ; stdext::unchecked_uninitialized_copy<enum _D3DMULTISAMPLE_TYPE *,enum _D3DMULTISAMPLE_TYPE *,std::allocator<enum _D3DMULTISAMPLE_TYPE> >
	add	esp, 16					; 00000010H

; 208  : 	}

	pop	ebp
	ret	0
??$_Uninit_move@PAW4_D3DMULTISAMPLE_TYPE@@PAW41@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@U_Undefined_move_tag@3@@std@@YAPAW4_D3DMULTISAMPLE_TYPE@@PAW41@00AAV?$allocator@W4_D3DMULTISAMPLE_TYPE@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_move<enum _D3DMULTISAMPLE_TYPE *,enum _D3DMULTISAMPLE_TYPE *,std::allocator<enum _D3DMULTISAMPLE_TYPE>,std::_Undefined_move_tag>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Checked_base@PAW4_D3DMULTISAMPLE_TYPE@@@std@@YAPAW4_D3DMULTISAMPLE_TYPE@@AAPAW41@U_Unchanged_checked_iterator_base_type_tag@0@@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Checked_base@PAW4_D3DMULTISAMPLE_TYPE@@@std@@YAPAW4_D3DMULTISAMPLE_TYPE@@AAPAW41@U_Unchanged_checked_iterator_base_type_tag@0@@Z PROC ; std::_Checked_base<enum _D3DMULTISAMPLE_TYPE *>, COMDAT

; 1146 : 	{

	push	ebp
	mov	ebp, esp

; 1147 : 		return _It;

	mov	eax, DWORD PTR __It$[ebp]
	mov	eax, DWORD PTR [eax]

; 1148 : 	}

	pop	ebp
	ret	0
??$_Checked_base@PAW4_D3DMULTISAMPLE_TYPE@@@std@@YAPAW4_D3DMULTISAMPLE_TYPE@@AAPAW41@U_Unchanged_checked_iterator_base_type_tag@0@@Z ENDP ; std::_Checked_base<enum _D3DMULTISAMPLE_TYPE *>
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@PAW4_D3DMULTISAMPLE_TYPE@@PAW41@Uforward_iterator_tag@std@@@std@@YAPAW4_D3DMULTISAMPLE_TYPE@@PAW41@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<enum _D3DMULTISAMPLE_TYPE *,enum _D3DMULTISAMPLE_TYPE *,std::forward_iterator_tag>
; Function compile flags: /Odtp
;	COMDAT ??$_Copy_backward_opt@PAW4_D3DMULTISAMPLE_TYPE@@PAW41@@std@@YAPAW4_D3DMULTISAMPLE_TYPE@@PAW41@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T143694 = -7						; size = 1
$T143693 = -6						; size = 1
$T143692 = -5						; size = 1
__Result$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_backward_opt@PAW4_D3DMULTISAMPLE_TYPE@@PAW41@@std@@YAPAW4_D3DMULTISAMPLE_TYPE@@PAW41@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<enum _D3DMULTISAMPLE_TYPE *,enum _D3DMULTISAMPLE_TYPE *>, COMDAT

; 2685 : 	{	// copy [_First, _Last) backwards to [..., _Dest), arbitrary iterators

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 2686 : 	// if _OutIt is range checked, this will make sure there is enough space for the copy
; 2687 : 	_OutIt _Result = _Dest - (_Last - _First);

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 2
	shl	eax, 2
	mov	ecx, DWORD PTR __Dest$[ebp]
	sub	ecx, eax
	mov	DWORD PTR __Result$[ebp], ecx

; 2688 : 	_Copy_backward_opt(_First, _Last, _CHECKED_BASE(_Dest),
; 2689 : 		forward_iterator_tag(), _Nonscalar_ptr_iterator_tag(), _Range_checked_iterator_tag());

	xor	edx, edx
	mov	BYTE PTR $T143692[ebp], dl
	xor	eax, eax
	mov	BYTE PTR $T143693[ebp], al
	movzx	ecx, BYTE PTR $T143692[ebp]
	push	ecx
	movzx	edx, BYTE PTR $T143693[ebp]
	push	edx
	movzx	eax, BYTE PTR $T143694[ebp]
	push	eax
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	??$_Checked_base@PAW4_D3DMULTISAMPLE_TYPE@@@std@@YAPAW4_D3DMULTISAMPLE_TYPE@@AAPAW41@@Z ; std::_Checked_base<enum _D3DMULTISAMPLE_TYPE *>
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Copy_backward_opt@PAW4_D3DMULTISAMPLE_TYPE@@PAW41@Uforward_iterator_tag@std@@@std@@YAPAW4_D3DMULTISAMPLE_TYPE@@PAW41@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<enum _D3DMULTISAMPLE_TYPE *,enum _D3DMULTISAMPLE_TYPE *,std::forward_iterator_tag>
	add	esp, 24					; 00000018H

; 2690 : 	return _Result;

	mov	eax, DWORD PTR __Result$[ebp]

; 2691 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Copy_backward_opt@PAW4_D3DMULTISAMPLE_TYPE@@PAW41@@std@@YAPAW4_D3DMULTISAMPLE_TYPE@@PAW41@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<enum _D3DMULTISAMPLE_TYPE *,enum _D3DMULTISAMPLE_TYPE *>
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@PAIPAIV?$allocator@I@std@@@stdext@@YAPAIPAI00AAV?$allocator@I@std@@@Z ; stdext::unchecked_uninitialized_copy<unsigned int *,unsigned int *,std::allocator<unsigned int> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Uninit_move@PAIPAIV?$allocator@I@std@@U_Undefined_move_tag@2@@std@@YAPAIPAI00AAV?$allocator@I@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_move@PAIPAIV?$allocator@I@std@@U_Undefined_move_tag@2@@std@@YAPAIPAI00AAV?$allocator@I@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_move<unsigned int *,unsigned int *,std::allocator<unsigned int>,std::_Undefined_move_tag>, COMDAT

; 206  : 	{	// move defaults to copy if there is not a more effecient way

	push	ebp
	mov	ebp, esp

; 207  : 	return (_STDEXT unchecked_uninitialized_copy(_First, _Last, _Dest, _Al));

	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$unchecked_uninitialized_copy@PAIPAIV?$allocator@I@std@@@stdext@@YAPAIPAI00AAV?$allocator@I@std@@@Z ; stdext::unchecked_uninitialized_copy<unsigned int *,unsigned int *,std::allocator<unsigned int> >
	add	esp, 16					; 00000010H

; 208  : 	}

	pop	ebp
	ret	0
??$_Uninit_move@PAIPAIV?$allocator@I@std@@U_Undefined_move_tag@2@@std@@YAPAIPAI00AAV?$allocator@I@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_move<unsigned int *,unsigned int *,std::allocator<unsigned int>,std::_Undefined_move_tag>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Checked_base@PAI@std@@YAPAIAAPAIU_Unchanged_checked_iterator_base_type_tag@0@@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Checked_base@PAI@std@@YAPAIAAPAIU_Unchanged_checked_iterator_base_type_tag@0@@Z PROC ; std::_Checked_base<unsigned int *>, COMDAT

; 1146 : 	{

	push	ebp
	mov	ebp, esp

; 1147 : 		return _It;

	mov	eax, DWORD PTR __It$[ebp]
	mov	eax, DWORD PTR [eax]

; 1148 : 	}

	pop	ebp
	ret	0
??$_Checked_base@PAI@std@@YAPAIAAPAIU_Unchanged_checked_iterator_base_type_tag@0@@Z ENDP ; std::_Checked_base<unsigned int *>
_TEXT	ENDS
EXTRN	__imp__memmove_s:PROC
; Function compile flags: /Odtp
;	COMDAT ??$_Copy_backward_opt@PAIPAIUrandom_access_iterator_tag@std@@@std@@YAPAIPAI00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Off$ = -8						; size = 4
__Result$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_backward_opt@PAIPAIUrandom_access_iterator_tag@std@@@std@@YAPAIPAI00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<unsigned int *,unsigned int *,std::random_access_iterator_tag>, COMDAT

; 2698 : 	{	// copy [_First, _Last) backwards to [..., _Dest), pointers to scalars

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 2699 : 
; 2700 :  #if _HAS_ITERATOR_DEBUGGING
; 2701 : 	_DEBUG_RANGE(_First, _Last);
; 2702 : 	if (_First != _Last)
; 2703 : 		_DEBUG_POINTER(_Dest);
; 2704 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2705 : 
; 2706 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 2
	mov	DWORD PTR __Off$[ebp], eax

; 2707 : 	/* if _OutIt is range checked, this will make sure there is enough space for 
; 2708 : 	 * the memmove
; 2709 : 	 */
; 2710 : 	_OutIt _Result = _Dest - _Off;

	mov	ecx, DWORD PTR __Off$[ebp]
	shl	ecx, 2
	mov	edx, DWORD PTR __Dest$[ebp]
	sub	edx, ecx
	mov	DWORD PTR __Result$[ebp], edx

; 2711 : 	if (_Off > 0)

	cmp	DWORD PTR __Off$[ebp], 0
	jle	SHORT $LN1@Copy_backw

; 2712 : 		_CRT_SECURE_MEMMOVE(&*_Result, _Off * sizeof (*_First), &*_First, _Off * sizeof (*_First));

	mov	eax, DWORD PTR __Off$[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Off$[ebp]
	shl	edx, 2
	push	edx
	mov	eax, DWORD PTR __Result$[ebp]
	push	eax
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN1@Copy_backw:

; 2713 : 	return _Result;

	mov	eax, DWORD PTR __Result$[ebp]

; 2714 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Copy_backward_opt@PAIPAIUrandom_access_iterator_tag@std@@@std@@YAPAIPAI00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<unsigned int *,unsigned int *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@PAUD3DSMSCONFLICT_T@Ogre@@PAU12@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@stdext@@YAPAUD3DSMSCONFLICT_T@Ogre@@PAU12@00AAV?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@Z ; stdext::unchecked_uninitialized_copy<Ogre::D3DSMSCONFLICT_T *,Ogre::D3DSMSCONFLICT_T *,std::allocator<Ogre::D3DSMSCONFLICT_T> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Uninit_move@PAUD3DSMSCONFLICT_T@Ogre@@PAU12@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@U_Undefined_move_tag@4@@std@@YAPAUD3DSMSCONFLICT_T@Ogre@@PAU12@00AAV?$allocator@UD3DSMSCONFLICT_T@Ogre@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_move@PAUD3DSMSCONFLICT_T@Ogre@@PAU12@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@U_Undefined_move_tag@4@@std@@YAPAUD3DSMSCONFLICT_T@Ogre@@PAU12@00AAV?$allocator@UD3DSMSCONFLICT_T@Ogre@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_move<Ogre::D3DSMSCONFLICT_T *,Ogre::D3DSMSCONFLICT_T *,std::allocator<Ogre::D3DSMSCONFLICT_T>,std::_Undefined_move_tag>, COMDAT

; 206  : 	{	// move defaults to copy if there is not a more effecient way

	push	ebp
	mov	ebp, esp

; 207  : 	return (_STDEXT unchecked_uninitialized_copy(_First, _Last, _Dest, _Al));

	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$unchecked_uninitialized_copy@PAUD3DSMSCONFLICT_T@Ogre@@PAU12@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@stdext@@YAPAUD3DSMSCONFLICT_T@Ogre@@PAU12@00AAV?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@Z ; stdext::unchecked_uninitialized_copy<Ogre::D3DSMSCONFLICT_T *,Ogre::D3DSMSCONFLICT_T *,std::allocator<Ogre::D3DSMSCONFLICT_T> >
	add	esp, 16					; 00000010H

; 208  : 	}

	pop	ebp
	ret	0
??$_Uninit_move@PAUD3DSMSCONFLICT_T@Ogre@@PAU12@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@U_Undefined_move_tag@4@@std@@YAPAUD3DSMSCONFLICT_T@Ogre@@PAU12@00AAV?$allocator@UD3DSMSCONFLICT_T@Ogre@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_move<Ogre::D3DSMSCONFLICT_T *,Ogre::D3DSMSCONFLICT_T *,std::allocator<Ogre::D3DSMSCONFLICT_T>,std::_Undefined_move_tag>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Checked_base@PAUD3DSMSCONFLICT_T@Ogre@@@std@@YAPAUD3DSMSCONFLICT_T@Ogre@@AAPAU12@U_Unchanged_checked_iterator_base_type_tag@0@@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Checked_base@PAUD3DSMSCONFLICT_T@Ogre@@@std@@YAPAUD3DSMSCONFLICT_T@Ogre@@AAPAU12@U_Unchanged_checked_iterator_base_type_tag@0@@Z PROC ; std::_Checked_base<Ogre::D3DSMSCONFLICT_T *>, COMDAT

; 1146 : 	{

	push	ebp
	mov	ebp, esp

; 1147 : 		return _It;

	mov	eax, DWORD PTR __It$[ebp]
	mov	eax, DWORD PTR [eax]

; 1148 : 	}

	pop	ebp
	ret	0
??$_Checked_base@PAUD3DSMSCONFLICT_T@Ogre@@@std@@YAPAUD3DSMSCONFLICT_T@Ogre@@AAPAU12@U_Unchanged_checked_iterator_base_type_tag@0@@Z ENDP ; std::_Checked_base<Ogre::D3DSMSCONFLICT_T *>
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@PAUD3DSMSCONFLICT_T@Ogre@@PAU12@Uforward_iterator_tag@std@@@std@@YAPAUD3DSMSCONFLICT_T@Ogre@@PAU12@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<Ogre::D3DSMSCONFLICT_T *,Ogre::D3DSMSCONFLICT_T *,std::forward_iterator_tag>
; Function compile flags: /Odtp
;	COMDAT ??$_Copy_backward_opt@PAUD3DSMSCONFLICT_T@Ogre@@PAU12@@std@@YAPAUD3DSMSCONFLICT_T@Ogre@@PAU12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T143709 = -7						; size = 1
$T143708 = -6						; size = 1
$T143707 = -5						; size = 1
__Result$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_backward_opt@PAUD3DSMSCONFLICT_T@Ogre@@PAU12@@std@@YAPAUD3DSMSCONFLICT_T@Ogre@@PAU12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<Ogre::D3DSMSCONFLICT_T *,Ogre::D3DSMSCONFLICT_T *>, COMDAT

; 2685 : 	{	// copy [_First, _Last) backwards to [..., _Dest), arbitrary iterators

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 2686 : 	// if _OutIt is range checked, this will make sure there is enough space for the copy
; 2687 : 	_OutIt _Result = _Dest - (_Last - _First);

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 3
	shl	eax, 3
	mov	ecx, DWORD PTR __Dest$[ebp]
	sub	ecx, eax
	mov	DWORD PTR __Result$[ebp], ecx

; 2688 : 	_Copy_backward_opt(_First, _Last, _CHECKED_BASE(_Dest),
; 2689 : 		forward_iterator_tag(), _Nonscalar_ptr_iterator_tag(), _Range_checked_iterator_tag());

	xor	edx, edx
	mov	BYTE PTR $T143707[ebp], dl
	xor	eax, eax
	mov	BYTE PTR $T143708[ebp], al
	movzx	ecx, BYTE PTR $T143707[ebp]
	push	ecx
	movzx	edx, BYTE PTR $T143708[ebp]
	push	edx
	movzx	eax, BYTE PTR $T143709[ebp]
	push	eax
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	??$_Checked_base@PAUD3DSMSCONFLICT_T@Ogre@@@std@@YAPAUD3DSMSCONFLICT_T@Ogre@@AAPAU12@@Z ; std::_Checked_base<Ogre::D3DSMSCONFLICT_T *>
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Copy_backward_opt@PAUD3DSMSCONFLICT_T@Ogre@@PAU12@Uforward_iterator_tag@std@@@std@@YAPAUD3DSMSCONFLICT_T@Ogre@@PAU12@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<Ogre::D3DSMSCONFLICT_T *,Ogre::D3DSMSCONFLICT_T *,std::forward_iterator_tag>
	add	esp, 24					; 00000018H

; 2690 : 	return _Result;

	mov	eax, DWORD PTR __Result$[ebp]

; 2691 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Copy_backward_opt@PAUD3DSMSCONFLICT_T@Ogre@@PAU12@@std@@YAPAUD3DSMSCONFLICT_T@Ogre@@PAU12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<Ogre::D3DSMSCONFLICT_T *,Ogre::D3DSMSCONFLICT_T *>
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@PAW4VERTPROCESS_T@Ogre@@PAW412@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@stdext@@YAPAW4VERTPROCESS_T@Ogre@@PAW412@00AAV?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@Z ; stdext::unchecked_uninitialized_copy<enum Ogre::VERTPROCESS_T *,enum Ogre::VERTPROCESS_T *,std::allocator<enum Ogre::VERTPROCESS_T> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Uninit_move@PAW4VERTPROCESS_T@Ogre@@PAW412@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@U_Undefined_move_tag@4@@std@@YAPAW4VERTPROCESS_T@Ogre@@PAW412@00AAV?$allocator@W4VERTPROCESS_T@Ogre@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_move@PAW4VERTPROCESS_T@Ogre@@PAW412@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@U_Undefined_move_tag@4@@std@@YAPAW4VERTPROCESS_T@Ogre@@PAW412@00AAV?$allocator@W4VERTPROCESS_T@Ogre@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_move<enum Ogre::VERTPROCESS_T *,enum Ogre::VERTPROCESS_T *,std::allocator<enum Ogre::VERTPROCESS_T>,std::_Undefined_move_tag>, COMDAT

; 206  : 	{	// move defaults to copy if there is not a more effecient way

	push	ebp
	mov	ebp, esp

; 207  : 	return (_STDEXT unchecked_uninitialized_copy(_First, _Last, _Dest, _Al));

	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$unchecked_uninitialized_copy@PAW4VERTPROCESS_T@Ogre@@PAW412@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@stdext@@YAPAW4VERTPROCESS_T@Ogre@@PAW412@00AAV?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@Z ; stdext::unchecked_uninitialized_copy<enum Ogre::VERTPROCESS_T *,enum Ogre::VERTPROCESS_T *,std::allocator<enum Ogre::VERTPROCESS_T> >
	add	esp, 16					; 00000010H

; 208  : 	}

	pop	ebp
	ret	0
??$_Uninit_move@PAW4VERTPROCESS_T@Ogre@@PAW412@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@U_Undefined_move_tag@4@@std@@YAPAW4VERTPROCESS_T@Ogre@@PAW412@00AAV?$allocator@W4VERTPROCESS_T@Ogre@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_move<enum Ogre::VERTPROCESS_T *,enum Ogre::VERTPROCESS_T *,std::allocator<enum Ogre::VERTPROCESS_T>,std::_Undefined_move_tag>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Checked_base@PAW4VERTPROCESS_T@Ogre@@@std@@YAPAW4VERTPROCESS_T@Ogre@@AAPAW412@U_Unchanged_checked_iterator_base_type_tag@0@@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Checked_base@PAW4VERTPROCESS_T@Ogre@@@std@@YAPAW4VERTPROCESS_T@Ogre@@AAPAW412@U_Unchanged_checked_iterator_base_type_tag@0@@Z PROC ; std::_Checked_base<enum Ogre::VERTPROCESS_T *>, COMDAT

; 1146 : 	{

	push	ebp
	mov	ebp, esp

; 1147 : 		return _It;

	mov	eax, DWORD PTR __It$[ebp]
	mov	eax, DWORD PTR [eax]

; 1148 : 	}

	pop	ebp
	ret	0
??$_Checked_base@PAW4VERTPROCESS_T@Ogre@@@std@@YAPAW4VERTPROCESS_T@Ogre@@AAPAW412@U_Unchanged_checked_iterator_base_type_tag@0@@Z ENDP ; std::_Checked_base<enum Ogre::VERTPROCESS_T *>
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@PAW4VERTPROCESS_T@Ogre@@PAW412@Uforward_iterator_tag@std@@@std@@YAPAW4VERTPROCESS_T@Ogre@@PAW412@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<enum Ogre::VERTPROCESS_T *,enum Ogre::VERTPROCESS_T *,std::forward_iterator_tag>
; Function compile flags: /Odtp
;	COMDAT ??$_Copy_backward_opt@PAW4VERTPROCESS_T@Ogre@@PAW412@@std@@YAPAW4VERTPROCESS_T@Ogre@@PAW412@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T143718 = -7						; size = 1
$T143717 = -6						; size = 1
$T143716 = -5						; size = 1
__Result$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_backward_opt@PAW4VERTPROCESS_T@Ogre@@PAW412@@std@@YAPAW4VERTPROCESS_T@Ogre@@PAW412@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<enum Ogre::VERTPROCESS_T *,enum Ogre::VERTPROCESS_T *>, COMDAT

; 2685 : 	{	// copy [_First, _Last) backwards to [..., _Dest), arbitrary iterators

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 2686 : 	// if _OutIt is range checked, this will make sure there is enough space for the copy
; 2687 : 	_OutIt _Result = _Dest - (_Last - _First);

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 2
	shl	eax, 2
	mov	ecx, DWORD PTR __Dest$[ebp]
	sub	ecx, eax
	mov	DWORD PTR __Result$[ebp], ecx

; 2688 : 	_Copy_backward_opt(_First, _Last, _CHECKED_BASE(_Dest),
; 2689 : 		forward_iterator_tag(), _Nonscalar_ptr_iterator_tag(), _Range_checked_iterator_tag());

	xor	edx, edx
	mov	BYTE PTR $T143716[ebp], dl
	xor	eax, eax
	mov	BYTE PTR $T143717[ebp], al
	movzx	ecx, BYTE PTR $T143716[ebp]
	push	ecx
	movzx	edx, BYTE PTR $T143717[ebp]
	push	edx
	movzx	eax, BYTE PTR $T143718[ebp]
	push	eax
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	??$_Checked_base@PAW4VERTPROCESS_T@Ogre@@@std@@YAPAW4VERTPROCESS_T@Ogre@@AAPAW412@@Z ; std::_Checked_base<enum Ogre::VERTPROCESS_T *>
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Copy_backward_opt@PAW4VERTPROCESS_T@Ogre@@PAW412@Uforward_iterator_tag@std@@@std@@YAPAW4VERTPROCESS_T@Ogre@@PAW412@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<enum Ogre::VERTPROCESS_T *,enum Ogre::VERTPROCESS_T *,std::forward_iterator_tag>
	add	esp, 24					; 00000018H

; 2690 : 	return _Result;

	mov	eax, DWORD PTR __Result$[ebp]

; 2691 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Copy_backward_opt@PAW4VERTPROCESS_T@Ogre@@PAW412@@std@@YAPAW4VERTPROCESS_T@Ogre@@PAW412@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<enum Ogre::VERTPROCESS_T *,enum Ogre::VERTPROCESS_T *>
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@PAPAUD3DDEVCOMBO_T@Ogre@@PAPAU12@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@stdext@@YAPAPAUD3DDEVCOMBO_T@Ogre@@PAPAU12@00AAV?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@Z ; stdext::unchecked_uninitialized_copy<Ogre::D3DDEVCOMBO_T * *,Ogre::D3DDEVCOMBO_T * *,std::allocator<Ogre::D3DDEVCOMBO_T *> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Uninit_move@PAPAUD3DDEVCOMBO_T@Ogre@@PAPAU12@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@U_Undefined_move_tag@4@@std@@YAPAPAUD3DDEVCOMBO_T@Ogre@@PAPAU12@00AAV?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_move@PAPAUD3DDEVCOMBO_T@Ogre@@PAPAU12@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@U_Undefined_move_tag@4@@std@@YAPAPAUD3DDEVCOMBO_T@Ogre@@PAPAU12@00AAV?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_move<Ogre::D3DDEVCOMBO_T * *,Ogre::D3DDEVCOMBO_T * *,std::allocator<Ogre::D3DDEVCOMBO_T *>,std::_Undefined_move_tag>, COMDAT

; 206  : 	{	// move defaults to copy if there is not a more effecient way

	push	ebp
	mov	ebp, esp

; 207  : 	return (_STDEXT unchecked_uninitialized_copy(_First, _Last, _Dest, _Al));

	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$unchecked_uninitialized_copy@PAPAUD3DDEVCOMBO_T@Ogre@@PAPAU12@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@stdext@@YAPAPAUD3DDEVCOMBO_T@Ogre@@PAPAU12@00AAV?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@Z ; stdext::unchecked_uninitialized_copy<Ogre::D3DDEVCOMBO_T * *,Ogre::D3DDEVCOMBO_T * *,std::allocator<Ogre::D3DDEVCOMBO_T *> >
	add	esp, 16					; 00000010H

; 208  : 	}

	pop	ebp
	ret	0
??$_Uninit_move@PAPAUD3DDEVCOMBO_T@Ogre@@PAPAU12@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@U_Undefined_move_tag@4@@std@@YAPAPAUD3DDEVCOMBO_T@Ogre@@PAPAU12@00AAV?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_move<Ogre::D3DDEVCOMBO_T * *,Ogre::D3DDEVCOMBO_T * *,std::allocator<Ogre::D3DDEVCOMBO_T *>,std::_Undefined_move_tag>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Checked_base@PAPAUD3DDEVCOMBO_T@Ogre@@@std@@YAPAPAUD3DDEVCOMBO_T@Ogre@@AAPAPAU12@U_Unchanged_checked_iterator_base_type_tag@0@@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Checked_base@PAPAUD3DDEVCOMBO_T@Ogre@@@std@@YAPAPAUD3DDEVCOMBO_T@Ogre@@AAPAPAU12@U_Unchanged_checked_iterator_base_type_tag@0@@Z PROC ; std::_Checked_base<Ogre::D3DDEVCOMBO_T * *>, COMDAT

; 1146 : 	{

	push	ebp
	mov	ebp, esp

; 1147 : 		return _It;

	mov	eax, DWORD PTR __It$[ebp]
	mov	eax, DWORD PTR [eax]

; 1148 : 	}

	pop	ebp
	ret	0
??$_Checked_base@PAPAUD3DDEVCOMBO_T@Ogre@@@std@@YAPAPAUD3DDEVCOMBO_T@Ogre@@AAPAPAU12@U_Unchanged_checked_iterator_base_type_tag@0@@Z ENDP ; std::_Checked_base<Ogre::D3DDEVCOMBO_T * *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Copy_backward_opt@PAPAUD3DDEVCOMBO_T@Ogre@@PAPAU12@Urandom_access_iterator_tag@std@@@std@@YAPAPAUD3DDEVCOMBO_T@Ogre@@PAPAU12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Off$ = -8						; size = 4
__Result$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_backward_opt@PAPAUD3DDEVCOMBO_T@Ogre@@PAPAU12@Urandom_access_iterator_tag@std@@@std@@YAPAPAUD3DDEVCOMBO_T@Ogre@@PAPAU12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<Ogre::D3DDEVCOMBO_T * *,Ogre::D3DDEVCOMBO_T * *,std::random_access_iterator_tag>, COMDAT

; 2698 : 	{	// copy [_First, _Last) backwards to [..., _Dest), pointers to scalars

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 2699 : 
; 2700 :  #if _HAS_ITERATOR_DEBUGGING
; 2701 : 	_DEBUG_RANGE(_First, _Last);
; 2702 : 	if (_First != _Last)
; 2703 : 		_DEBUG_POINTER(_Dest);
; 2704 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2705 : 
; 2706 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 2
	mov	DWORD PTR __Off$[ebp], eax

; 2707 : 	/* if _OutIt is range checked, this will make sure there is enough space for 
; 2708 : 	 * the memmove
; 2709 : 	 */
; 2710 : 	_OutIt _Result = _Dest - _Off;

	mov	ecx, DWORD PTR __Off$[ebp]
	shl	ecx, 2
	mov	edx, DWORD PTR __Dest$[ebp]
	sub	edx, ecx
	mov	DWORD PTR __Result$[ebp], edx

; 2711 : 	if (_Off > 0)

	cmp	DWORD PTR __Off$[ebp], 0
	jle	SHORT $LN1@Copy_backw@2

; 2712 : 		_CRT_SECURE_MEMMOVE(&*_Result, _Off * sizeof (*_First), &*_First, _Off * sizeof (*_First));

	mov	eax, DWORD PTR __Off$[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Off$[ebp]
	shl	edx, 2
	push	edx
	mov	eax, DWORD PTR __Result$[ebp]
	push	eax
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN1@Copy_backw@2:

; 2713 : 	return _Result;

	mov	eax, DWORD PTR __Result$[ebp]

; 2714 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Copy_backward_opt@PAPAUD3DDEVCOMBO_T@Ogre@@PAPAU12@Urandom_access_iterator_tag@std@@@std@@YAPAPAUD3DDEVCOMBO_T@Ogre@@PAPAU12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<Ogre::D3DDEVCOMBO_T * *,Ogre::D3DDEVCOMBO_T * *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@PAU_D3DDISPLAYMODE@@PAU1@V?$allocator@U_D3DDISPLAYMODE@@@std@@@stdext@@YAPAU_D3DDISPLAYMODE@@PAU1@00AAV?$allocator@U_D3DDISPLAYMODE@@@std@@@Z ; stdext::unchecked_uninitialized_copy<_D3DDISPLAYMODE *,_D3DDISPLAYMODE *,std::allocator<_D3DDISPLAYMODE> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Uninit_move@PAU_D3DDISPLAYMODE@@PAU1@V?$allocator@U_D3DDISPLAYMODE@@@std@@U_Undefined_move_tag@3@@std@@YAPAU_D3DDISPLAYMODE@@PAU1@00AAV?$allocator@U_D3DDISPLAYMODE@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_move@PAU_D3DDISPLAYMODE@@PAU1@V?$allocator@U_D3DDISPLAYMODE@@@std@@U_Undefined_move_tag@3@@std@@YAPAU_D3DDISPLAYMODE@@PAU1@00AAV?$allocator@U_D3DDISPLAYMODE@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_move<_D3DDISPLAYMODE *,_D3DDISPLAYMODE *,std::allocator<_D3DDISPLAYMODE>,std::_Undefined_move_tag>, COMDAT

; 206  : 	{	// move defaults to copy if there is not a more effecient way

	push	ebp
	mov	ebp, esp

; 207  : 	return (_STDEXT unchecked_uninitialized_copy(_First, _Last, _Dest, _Al));

	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$unchecked_uninitialized_copy@PAU_D3DDISPLAYMODE@@PAU1@V?$allocator@U_D3DDISPLAYMODE@@@std@@@stdext@@YAPAU_D3DDISPLAYMODE@@PAU1@00AAV?$allocator@U_D3DDISPLAYMODE@@@std@@@Z ; stdext::unchecked_uninitialized_copy<_D3DDISPLAYMODE *,_D3DDISPLAYMODE *,std::allocator<_D3DDISPLAYMODE> >
	add	esp, 16					; 00000010H

; 208  : 	}

	pop	ebp
	ret	0
??$_Uninit_move@PAU_D3DDISPLAYMODE@@PAU1@V?$allocator@U_D3DDISPLAYMODE@@@std@@U_Undefined_move_tag@3@@std@@YAPAU_D3DDISPLAYMODE@@PAU1@00AAV?$allocator@U_D3DDISPLAYMODE@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_move<_D3DDISPLAYMODE *,_D3DDISPLAYMODE *,std::allocator<_D3DDISPLAYMODE>,std::_Undefined_move_tag>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Checked_base@PAU_D3DDISPLAYMODE@@@std@@YAPAU_D3DDISPLAYMODE@@AAPAU1@U_Unchanged_checked_iterator_base_type_tag@0@@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Checked_base@PAU_D3DDISPLAYMODE@@@std@@YAPAU_D3DDISPLAYMODE@@AAPAU1@U_Unchanged_checked_iterator_base_type_tag@0@@Z PROC ; std::_Checked_base<_D3DDISPLAYMODE *>, COMDAT

; 1146 : 	{

	push	ebp
	mov	ebp, esp

; 1147 : 		return _It;

	mov	eax, DWORD PTR __It$[ebp]
	mov	eax, DWORD PTR [eax]

; 1148 : 	}

	pop	ebp
	ret	0
??$_Checked_base@PAU_D3DDISPLAYMODE@@@std@@YAPAU_D3DDISPLAYMODE@@AAPAU1@U_Unchanged_checked_iterator_base_type_tag@0@@Z ENDP ; std::_Checked_base<_D3DDISPLAYMODE *>
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@PAU_D3DDISPLAYMODE@@PAU1@Uforward_iterator_tag@std@@@std@@YAPAU_D3DDISPLAYMODE@@PAU1@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<_D3DDISPLAYMODE *,_D3DDISPLAYMODE *,std::forward_iterator_tag>
; Function compile flags: /Odtp
;	COMDAT ??$_Copy_backward_opt@PAU_D3DDISPLAYMODE@@PAU1@@std@@YAPAU_D3DDISPLAYMODE@@PAU1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T143733 = -7						; size = 1
$T143732 = -6						; size = 1
$T143731 = -5						; size = 1
__Result$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_backward_opt@PAU_D3DDISPLAYMODE@@PAU1@@std@@YAPAU_D3DDISPLAYMODE@@PAU1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<_D3DDISPLAYMODE *,_D3DDISPLAYMODE *>, COMDAT

; 2685 : 	{	// copy [_First, _Last) backwards to [..., _Dest), arbitrary iterators

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 2686 : 	// if _OutIt is range checked, this will make sure there is enough space for the copy
; 2687 : 	_OutIt _Result = _Dest - (_Last - _First);

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 4
	shl	eax, 4
	mov	ecx, DWORD PTR __Dest$[ebp]
	sub	ecx, eax
	mov	DWORD PTR __Result$[ebp], ecx

; 2688 : 	_Copy_backward_opt(_First, _Last, _CHECKED_BASE(_Dest),
; 2689 : 		forward_iterator_tag(), _Nonscalar_ptr_iterator_tag(), _Range_checked_iterator_tag());

	xor	edx, edx
	mov	BYTE PTR $T143731[ebp], dl
	xor	eax, eax
	mov	BYTE PTR $T143732[ebp], al
	movzx	ecx, BYTE PTR $T143731[ebp]
	push	ecx
	movzx	edx, BYTE PTR $T143732[ebp]
	push	edx
	movzx	eax, BYTE PTR $T143733[ebp]
	push	eax
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	??$_Checked_base@PAU_D3DDISPLAYMODE@@@std@@YAPAU_D3DDISPLAYMODE@@AAPAU1@@Z ; std::_Checked_base<_D3DDISPLAYMODE *>
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Copy_backward_opt@PAU_D3DDISPLAYMODE@@PAU1@Uforward_iterator_tag@std@@@std@@YAPAU_D3DDISPLAYMODE@@PAU1@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<_D3DDISPLAYMODE *,_D3DDISPLAYMODE *,std::forward_iterator_tag>
	add	esp, 24					; 00000018H

; 2690 : 	return _Result;

	mov	eax, DWORD PTR __Result$[ebp]

; 2691 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Copy_backward_opt@PAU_D3DDISPLAYMODE@@PAU1@@std@@YAPAU_D3DDISPLAYMODE@@PAU1@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<_D3DDISPLAYMODE *,_D3DDISPLAYMODE *>
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@PAPAUD3DDEVICEINFO_T@Ogre@@PAPAU12@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@stdext@@YAPAPAUD3DDEVICEINFO_T@Ogre@@PAPAU12@00AAV?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@Z ; stdext::unchecked_uninitialized_copy<Ogre::D3DDEVICEINFO_T * *,Ogre::D3DDEVICEINFO_T * *,std::allocator<Ogre::D3DDEVICEINFO_T *> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Uninit_move@PAPAUD3DDEVICEINFO_T@Ogre@@PAPAU12@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@U_Undefined_move_tag@4@@std@@YAPAPAUD3DDEVICEINFO_T@Ogre@@PAPAU12@00AAV?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_move@PAPAUD3DDEVICEINFO_T@Ogre@@PAPAU12@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@U_Undefined_move_tag@4@@std@@YAPAPAUD3DDEVICEINFO_T@Ogre@@PAPAU12@00AAV?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_move<Ogre::D3DDEVICEINFO_T * *,Ogre::D3DDEVICEINFO_T * *,std::allocator<Ogre::D3DDEVICEINFO_T *>,std::_Undefined_move_tag>, COMDAT

; 206  : 	{	// move defaults to copy if there is not a more effecient way

	push	ebp
	mov	ebp, esp

; 207  : 	return (_STDEXT unchecked_uninitialized_copy(_First, _Last, _Dest, _Al));

	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$unchecked_uninitialized_copy@PAPAUD3DDEVICEINFO_T@Ogre@@PAPAU12@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@stdext@@YAPAPAUD3DDEVICEINFO_T@Ogre@@PAPAU12@00AAV?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@Z ; stdext::unchecked_uninitialized_copy<Ogre::D3DDEVICEINFO_T * *,Ogre::D3DDEVICEINFO_T * *,std::allocator<Ogre::D3DDEVICEINFO_T *> >
	add	esp, 16					; 00000010H

; 208  : 	}

	pop	ebp
	ret	0
??$_Uninit_move@PAPAUD3DDEVICEINFO_T@Ogre@@PAPAU12@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@U_Undefined_move_tag@4@@std@@YAPAPAUD3DDEVICEINFO_T@Ogre@@PAPAU12@00AAV?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_move<Ogre::D3DDEVICEINFO_T * *,Ogre::D3DDEVICEINFO_T * *,std::allocator<Ogre::D3DDEVICEINFO_T *>,std::_Undefined_move_tag>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Checked_base@PAPAUD3DDEVICEINFO_T@Ogre@@@std@@YAPAPAUD3DDEVICEINFO_T@Ogre@@AAPAPAU12@U_Unchanged_checked_iterator_base_type_tag@0@@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Checked_base@PAPAUD3DDEVICEINFO_T@Ogre@@@std@@YAPAPAUD3DDEVICEINFO_T@Ogre@@AAPAPAU12@U_Unchanged_checked_iterator_base_type_tag@0@@Z PROC ; std::_Checked_base<Ogre::D3DDEVICEINFO_T * *>, COMDAT

; 1146 : 	{

	push	ebp
	mov	ebp, esp

; 1147 : 		return _It;

	mov	eax, DWORD PTR __It$[ebp]
	mov	eax, DWORD PTR [eax]

; 1148 : 	}

	pop	ebp
	ret	0
??$_Checked_base@PAPAUD3DDEVICEINFO_T@Ogre@@@std@@YAPAPAUD3DDEVICEINFO_T@Ogre@@AAPAPAU12@U_Unchanged_checked_iterator_base_type_tag@0@@Z ENDP ; std::_Checked_base<Ogre::D3DDEVICEINFO_T * *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Copy_backward_opt@PAPAUD3DDEVICEINFO_T@Ogre@@PAPAU12@Urandom_access_iterator_tag@std@@@std@@YAPAPAUD3DDEVICEINFO_T@Ogre@@PAPAU12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Off$ = -8						; size = 4
__Result$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_backward_opt@PAPAUD3DDEVICEINFO_T@Ogre@@PAPAU12@Urandom_access_iterator_tag@std@@@std@@YAPAPAUD3DDEVICEINFO_T@Ogre@@PAPAU12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<Ogre::D3DDEVICEINFO_T * *,Ogre::D3DDEVICEINFO_T * *,std::random_access_iterator_tag>, COMDAT

; 2698 : 	{	// copy [_First, _Last) backwards to [..., _Dest), pointers to scalars

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 2699 : 
; 2700 :  #if _HAS_ITERATOR_DEBUGGING
; 2701 : 	_DEBUG_RANGE(_First, _Last);
; 2702 : 	if (_First != _Last)
; 2703 : 		_DEBUG_POINTER(_Dest);
; 2704 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2705 : 
; 2706 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 2
	mov	DWORD PTR __Off$[ebp], eax

; 2707 : 	/* if _OutIt is range checked, this will make sure there is enough space for 
; 2708 : 	 * the memmove
; 2709 : 	 */
; 2710 : 	_OutIt _Result = _Dest - _Off;

	mov	ecx, DWORD PTR __Off$[ebp]
	shl	ecx, 2
	mov	edx, DWORD PTR __Dest$[ebp]
	sub	edx, ecx
	mov	DWORD PTR __Result$[ebp], edx

; 2711 : 	if (_Off > 0)

	cmp	DWORD PTR __Off$[ebp], 0
	jle	SHORT $LN1@Copy_backw@3

; 2712 : 		_CRT_SECURE_MEMMOVE(&*_Result, _Off * sizeof (*_First), &*_First, _Off * sizeof (*_First));

	mov	eax, DWORD PTR __Off$[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Off$[ebp]
	shl	edx, 2
	push	edx
	mov	eax, DWORD PTR __Result$[ebp]
	push	eax
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN1@Copy_backw@3:

; 2713 : 	return _Result;

	mov	eax, DWORD PTR __Result$[ebp]

; 2714 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Copy_backward_opt@PAPAUD3DDEVICEINFO_T@Ogre@@PAPAU12@Urandom_access_iterator_tag@std@@@std@@YAPAPAUD3DDEVICEINFO_T@Ogre@@PAPAU12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<Ogre::D3DDEVICEINFO_T * *,Ogre::D3DDEVICEINFO_T * *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@PAPAUD3DADAPTER_T@Ogre@@PAPAU12@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@stdext@@YAPAPAUD3DADAPTER_T@Ogre@@PAPAU12@00AAV?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@Z ; stdext::unchecked_uninitialized_copy<Ogre::D3DADAPTER_T * *,Ogre::D3DADAPTER_T * *,std::allocator<Ogre::D3DADAPTER_T *> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Uninit_move@PAPAUD3DADAPTER_T@Ogre@@PAPAU12@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@U_Undefined_move_tag@4@@std@@YAPAPAUD3DADAPTER_T@Ogre@@PAPAU12@00AAV?$allocator@PAUD3DADAPTER_T@Ogre@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_move@PAPAUD3DADAPTER_T@Ogre@@PAPAU12@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@U_Undefined_move_tag@4@@std@@YAPAPAUD3DADAPTER_T@Ogre@@PAPAU12@00AAV?$allocator@PAUD3DADAPTER_T@Ogre@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_move<Ogre::D3DADAPTER_T * *,Ogre::D3DADAPTER_T * *,std::allocator<Ogre::D3DADAPTER_T *>,std::_Undefined_move_tag>, COMDAT

; 206  : 	{	// move defaults to copy if there is not a more effecient way

	push	ebp
	mov	ebp, esp

; 207  : 	return (_STDEXT unchecked_uninitialized_copy(_First, _Last, _Dest, _Al));

	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$unchecked_uninitialized_copy@PAPAUD3DADAPTER_T@Ogre@@PAPAU12@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@stdext@@YAPAPAUD3DADAPTER_T@Ogre@@PAPAU12@00AAV?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@Z ; stdext::unchecked_uninitialized_copy<Ogre::D3DADAPTER_T * *,Ogre::D3DADAPTER_T * *,std::allocator<Ogre::D3DADAPTER_T *> >
	add	esp, 16					; 00000010H

; 208  : 	}

	pop	ebp
	ret	0
??$_Uninit_move@PAPAUD3DADAPTER_T@Ogre@@PAPAU12@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@U_Undefined_move_tag@4@@std@@YAPAPAUD3DADAPTER_T@Ogre@@PAPAU12@00AAV?$allocator@PAUD3DADAPTER_T@Ogre@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_move<Ogre::D3DADAPTER_T * *,Ogre::D3DADAPTER_T * *,std::allocator<Ogre::D3DADAPTER_T *>,std::_Undefined_move_tag>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Checked_base@PAPAUD3DADAPTER_T@Ogre@@@std@@YAPAPAUD3DADAPTER_T@Ogre@@AAPAPAU12@U_Unchanged_checked_iterator_base_type_tag@0@@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Checked_base@PAPAUD3DADAPTER_T@Ogre@@@std@@YAPAPAUD3DADAPTER_T@Ogre@@AAPAPAU12@U_Unchanged_checked_iterator_base_type_tag@0@@Z PROC ; std::_Checked_base<Ogre::D3DADAPTER_T * *>, COMDAT

; 1146 : 	{

	push	ebp
	mov	ebp, esp

; 1147 : 		return _It;

	mov	eax, DWORD PTR __It$[ebp]
	mov	eax, DWORD PTR [eax]

; 1148 : 	}

	pop	ebp
	ret	0
??$_Checked_base@PAPAUD3DADAPTER_T@Ogre@@@std@@YAPAPAUD3DADAPTER_T@Ogre@@AAPAPAU12@U_Unchanged_checked_iterator_base_type_tag@0@@Z ENDP ; std::_Checked_base<Ogre::D3DADAPTER_T * *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Copy_backward_opt@PAPAUD3DADAPTER_T@Ogre@@PAPAU12@Urandom_access_iterator_tag@std@@@std@@YAPAPAUD3DADAPTER_T@Ogre@@PAPAU12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Off$ = -8						; size = 4
__Result$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_backward_opt@PAPAUD3DADAPTER_T@Ogre@@PAPAU12@Urandom_access_iterator_tag@std@@@std@@YAPAPAUD3DADAPTER_T@Ogre@@PAPAU12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<Ogre::D3DADAPTER_T * *,Ogre::D3DADAPTER_T * *,std::random_access_iterator_tag>, COMDAT

; 2698 : 	{	// copy [_First, _Last) backwards to [..., _Dest), pointers to scalars

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 2699 : 
; 2700 :  #if _HAS_ITERATOR_DEBUGGING
; 2701 : 	_DEBUG_RANGE(_First, _Last);
; 2702 : 	if (_First != _Last)
; 2703 : 		_DEBUG_POINTER(_Dest);
; 2704 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2705 : 
; 2706 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 2
	mov	DWORD PTR __Off$[ebp], eax

; 2707 : 	/* if _OutIt is range checked, this will make sure there is enough space for 
; 2708 : 	 * the memmove
; 2709 : 	 */
; 2710 : 	_OutIt _Result = _Dest - _Off;

	mov	ecx, DWORD PTR __Off$[ebp]
	shl	ecx, 2
	mov	edx, DWORD PTR __Dest$[ebp]
	sub	edx, ecx
	mov	DWORD PTR __Result$[ebp], edx

; 2711 : 	if (_Off > 0)

	cmp	DWORD PTR __Off$[ebp], 0
	jle	SHORT $LN1@Copy_backw@4

; 2712 : 		_CRT_SECURE_MEMMOVE(&*_Result, _Off * sizeof (*_First), &*_First, _Off * sizeof (*_First));

	mov	eax, DWORD PTR __Off$[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Off$[ebp]
	shl	edx, 2
	push	edx
	mov	eax, DWORD PTR __Result$[ebp]
	push	eax
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN1@Copy_backw@4:

; 2713 : 	return _Result;

	mov	eax, DWORD PTR __Result$[ebp]

; 2714 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Copy_backward_opt@PAPAUD3DADAPTER_T@Ogre@@PAPAU12@Urandom_access_iterator_tag@std@@@std@@YAPAPAUD3DADAPTER_T@Ogre@@PAPAU12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<Ogre::D3DADAPTER_T * *,Ogre::D3DADAPTER_T * *,std::random_access_iterator_tag>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Construct@W4_D3DFORMAT@@W41@@std@@YAXPAW4_D3DFORMAT@@ABW41@@Z
_TEXT	SEGMENT
tv68 = -12						; size = 4
$T143748 = -8						; size = 4
__Vptr$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@W4_D3DFORMAT@@W41@@std@@YAXPAW4_D3DFORMAT@@ABW41@@Z PROC ; std::_Construct<enum _D3DFORMAT,enum _D3DFORMAT>, COMDAT

; 50   : 	{	// construct object at _Ptr with value _Val

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 51   : 	void _FARQ *_Vptr = _Ptr;

	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR __Vptr$[ebp], eax

; 52   : 	::new (_Vptr) _T1(_Val);

	mov	ecx, DWORD PTR __Vptr$[ebp]
	push	ecx
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T143748[ebp], eax
	cmp	DWORD PTR $T143748[ebp], 0
	je	SHORT $LN3@Construct
	mov	edx, DWORD PTR $T143748[ebp]
	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR $T143748[ebp]
	mov	DWORD PTR tv68[ebp], edx
	jmp	SHORT $LN1@Construct
$LN3@Construct:
	mov	DWORD PTR tv68[ebp], 0
$LN1@Construct:

; 53   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Construct@W4_D3DFORMAT@@W41@@std@@YAXPAW4_D3DFORMAT@@ABW41@@Z ENDP ; std::_Construct<enum _D3DFORMAT,enum _D3DFORMAT>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Destroy@W4_D3DFORMAT@@@std@@YAXPAW4_D3DFORMAT@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@W4_D3DFORMAT@@@std@@YAXPAW4_D3DFORMAT@@@Z PROC ; std::_Destroy<enum _D3DFORMAT>, COMDAT

; 58   : 	{	// destroy object at _Ptr

	push	ebp
	mov	ebp, esp

; 59   : 	_DESTRUCTOR(_Ty, _Ptr);
; 60   : 	}

	pop	ebp
	ret	0
??$_Destroy@W4_D3DFORMAT@@@std@@YAXPAW4_D3DFORMAT@@@Z ENDP ; std::_Destroy<enum _D3DFORMAT>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Construct@W4_D3DMULTISAMPLE_TYPE@@W41@@std@@YAXPAW4_D3DMULTISAMPLE_TYPE@@ABW41@@Z
_TEXT	SEGMENT
tv68 = -12						; size = 4
$T143755 = -8						; size = 4
__Vptr$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@W4_D3DMULTISAMPLE_TYPE@@W41@@std@@YAXPAW4_D3DMULTISAMPLE_TYPE@@ABW41@@Z PROC ; std::_Construct<enum _D3DMULTISAMPLE_TYPE,enum _D3DMULTISAMPLE_TYPE>, COMDAT

; 50   : 	{	// construct object at _Ptr with value _Val

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 51   : 	void _FARQ *_Vptr = _Ptr;

	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR __Vptr$[ebp], eax

; 52   : 	::new (_Vptr) _T1(_Val);

	mov	ecx, DWORD PTR __Vptr$[ebp]
	push	ecx
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T143755[ebp], eax
	cmp	DWORD PTR $T143755[ebp], 0
	je	SHORT $LN3@Construct@2
	mov	edx, DWORD PTR $T143755[ebp]
	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR $T143755[ebp]
	mov	DWORD PTR tv68[ebp], edx
	jmp	SHORT $LN1@Construct@2
$LN3@Construct@2:
	mov	DWORD PTR tv68[ebp], 0
$LN1@Construct@2:

; 53   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Construct@W4_D3DMULTISAMPLE_TYPE@@W41@@std@@YAXPAW4_D3DMULTISAMPLE_TYPE@@ABW41@@Z ENDP ; std::_Construct<enum _D3DMULTISAMPLE_TYPE,enum _D3DMULTISAMPLE_TYPE>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Destroy@W4_D3DMULTISAMPLE_TYPE@@@std@@YAXPAW4_D3DMULTISAMPLE_TYPE@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@W4_D3DMULTISAMPLE_TYPE@@@std@@YAXPAW4_D3DMULTISAMPLE_TYPE@@@Z PROC ; std::_Destroy<enum _D3DMULTISAMPLE_TYPE>, COMDAT

; 58   : 	{	// destroy object at _Ptr

	push	ebp
	mov	ebp, esp

; 59   : 	_DESTRUCTOR(_Ty, _Ptr);
; 60   : 	}

	pop	ebp
	ret	0
??$_Destroy@W4_D3DMULTISAMPLE_TYPE@@@std@@YAXPAW4_D3DMULTISAMPLE_TYPE@@@Z ENDP ; std::_Destroy<enum _D3DMULTISAMPLE_TYPE>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Construct@UD3DSMSCONFLICT_T@Ogre@@U12@@std@@YAXPAUD3DSMSCONFLICT_T@Ogre@@ABU12@@Z
_TEXT	SEGMENT
tv69 = -12						; size = 4
$T143762 = -8						; size = 4
__Vptr$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@UD3DSMSCONFLICT_T@Ogre@@U12@@std@@YAXPAUD3DSMSCONFLICT_T@Ogre@@ABU12@@Z PROC ; std::_Construct<Ogre::D3DSMSCONFLICT_T,Ogre::D3DSMSCONFLICT_T>, COMDAT

; 50   : 	{	// construct object at _Ptr with value _Val

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 51   : 	void _FARQ *_Vptr = _Ptr;

	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR __Vptr$[ebp], eax

; 52   : 	::new (_Vptr) _T1(_Val);

	mov	ecx, DWORD PTR __Vptr$[ebp]
	push	ecx
	push	8
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T143762[ebp], eax
	cmp	DWORD PTR $T143762[ebp], 0
	je	SHORT $LN3@Construct@3
	mov	edx, DWORD PTR __Val$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR $T143762[ebp]
	mov	DWORD PTR [edx], eax
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR $T143762[ebp]
	mov	DWORD PTR tv69[ebp], eax
	jmp	SHORT $LN1@Construct@3
$LN3@Construct@3:
	mov	DWORD PTR tv69[ebp], 0
$LN1@Construct@3:

; 53   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Construct@UD3DSMSCONFLICT_T@Ogre@@U12@@std@@YAXPAUD3DSMSCONFLICT_T@Ogre@@ABU12@@Z ENDP ; std::_Construct<Ogre::D3DSMSCONFLICT_T,Ogre::D3DSMSCONFLICT_T>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Destroy@UD3DSMSCONFLICT_T@Ogre@@@std@@YAXPAUD3DSMSCONFLICT_T@Ogre@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@UD3DSMSCONFLICT_T@Ogre@@@std@@YAXPAUD3DSMSCONFLICT_T@Ogre@@@Z PROC ; std::_Destroy<Ogre::D3DSMSCONFLICT_T>, COMDAT

; 58   : 	{	// destroy object at _Ptr

	push	ebp
	mov	ebp, esp

; 59   : 	_DESTRUCTOR(_Ty, _Ptr);
; 60   : 	}

	pop	ebp
	ret	0
??$_Destroy@UD3DSMSCONFLICT_T@Ogre@@@std@@YAXPAUD3DSMSCONFLICT_T@Ogre@@@Z ENDP ; std::_Destroy<Ogre::D3DSMSCONFLICT_T>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Construct@W4VERTPROCESS_T@Ogre@@W412@@std@@YAXPAW4VERTPROCESS_T@Ogre@@ABW412@@Z
_TEXT	SEGMENT
tv68 = -12						; size = 4
$T143769 = -8						; size = 4
__Vptr$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@W4VERTPROCESS_T@Ogre@@W412@@std@@YAXPAW4VERTPROCESS_T@Ogre@@ABW412@@Z PROC ; std::_Construct<enum Ogre::VERTPROCESS_T,enum Ogre::VERTPROCESS_T>, COMDAT

; 50   : 	{	// construct object at _Ptr with value _Val

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 51   : 	void _FARQ *_Vptr = _Ptr;

	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR __Vptr$[ebp], eax

; 52   : 	::new (_Vptr) _T1(_Val);

	mov	ecx, DWORD PTR __Vptr$[ebp]
	push	ecx
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T143769[ebp], eax
	cmp	DWORD PTR $T143769[ebp], 0
	je	SHORT $LN3@Construct@4
	mov	edx, DWORD PTR $T143769[ebp]
	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR $T143769[ebp]
	mov	DWORD PTR tv68[ebp], edx
	jmp	SHORT $LN1@Construct@4
$LN3@Construct@4:
	mov	DWORD PTR tv68[ebp], 0
$LN1@Construct@4:

; 53   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Construct@W4VERTPROCESS_T@Ogre@@W412@@std@@YAXPAW4VERTPROCESS_T@Ogre@@ABW412@@Z ENDP ; std::_Construct<enum Ogre::VERTPROCESS_T,enum Ogre::VERTPROCESS_T>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Destroy@W4VERTPROCESS_T@Ogre@@@std@@YAXPAW4VERTPROCESS_T@Ogre@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@W4VERTPROCESS_T@Ogre@@@std@@YAXPAW4VERTPROCESS_T@Ogre@@@Z PROC ; std::_Destroy<enum Ogre::VERTPROCESS_T>, COMDAT

; 58   : 	{	// destroy object at _Ptr

	push	ebp
	mov	ebp, esp

; 59   : 	_DESTRUCTOR(_Ty, _Ptr);
; 60   : 	}

	pop	ebp
	ret	0
??$_Destroy@W4VERTPROCESS_T@Ogre@@@std@@YAXPAW4VERTPROCESS_T@Ogre@@@Z ENDP ; std::_Destroy<enum Ogre::VERTPROCESS_T>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Construct@U_D3DDISPLAYMODE@@U1@@std@@YAXPAU_D3DDISPLAYMODE@@ABU1@@Z
_TEXT	SEGMENT
tv69 = -12						; size = 4
$T143776 = -8						; size = 4
__Vptr$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@U_D3DDISPLAYMODE@@U1@@std@@YAXPAU_D3DDISPLAYMODE@@ABU1@@Z PROC ; std::_Construct<_D3DDISPLAYMODE,_D3DDISPLAYMODE>, COMDAT

; 50   : 	{	// construct object at _Ptr with value _Val

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 51   : 	void _FARQ *_Vptr = _Ptr;

	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR __Vptr$[ebp], eax

; 52   : 	::new (_Vptr) _T1(_Val);

	mov	ecx, DWORD PTR __Vptr$[ebp]
	push	ecx
	push	16					; 00000010H
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T143776[ebp], eax
	cmp	DWORD PTR $T143776[ebp], 0
	je	SHORT $LN3@Construct@5
	mov	edx, DWORD PTR __Val$[ebp]
	mov	eax, DWORD PTR $T143776[ebp]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR [edx+12]
	mov	DWORD PTR [eax+12], edx
	mov	eax, DWORD PTR $T143776[ebp]
	mov	DWORD PTR tv69[ebp], eax
	jmp	SHORT $LN1@Construct@5
$LN3@Construct@5:
	mov	DWORD PTR tv69[ebp], 0
$LN1@Construct@5:

; 53   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Construct@U_D3DDISPLAYMODE@@U1@@std@@YAXPAU_D3DDISPLAYMODE@@ABU1@@Z ENDP ; std::_Construct<_D3DDISPLAYMODE,_D3DDISPLAYMODE>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Destroy@U_D3DDISPLAYMODE@@@std@@YAXPAU_D3DDISPLAYMODE@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@U_D3DDISPLAYMODE@@@std@@YAXPAU_D3DDISPLAYMODE@@@Z PROC ; std::_Destroy<_D3DDISPLAYMODE>, COMDAT

; 58   : 	{	// destroy object at _Ptr

	push	ebp
	mov	ebp, esp

; 59   : 	_DESTRUCTOR(_Ty, _Ptr);
; 60   : 	}

	pop	ebp
	ret	0
??$_Destroy@U_D3DDISPLAYMODE@@@std@@YAXPAU_D3DDISPLAYMODE@@@Z ENDP ; std::_Destroy<_D3DDISPLAYMODE>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Iter_cat@PAI@std@@YA?AUrandom_access_iterator_tag@0@ABQAI@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??$_Iter_cat@PAI@std@@YA?AUrandom_access_iterator_tag@0@ABQAI@Z PROC ; std::_Iter_cat<unsigned int *>, COMDAT

; 952  : 	{	// return category from iterator argument

	push	ebp
	mov	ebp, esp
	push	ecx

; 953  : 	typename iterator_traits<_Iter>::iterator_category _Cat;
; 954  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 955  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Iter_cat@PAI@std@@YA?AUrandom_access_iterator_tag@0@ABQAI@Z ENDP ; std::_Iter_cat<unsigned int *>
_TEXT	ENDS
PUBLIC	??$_Fill_n@PAIII@std@@YAXPAIIABIU_Range_checked_iterator_tag@0@@Z ; std::_Fill_n<unsigned int *,unsigned int,unsigned int>
; Function compile flags: /Odtp
;	COMDAT ??$_Fill_n@PAIII@std@@YAXPAIIABIUrandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T143785 = -5						; size = 1
__Last$ = -4						; size = 4
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
??$_Fill_n@PAIII@std@@YAXPAIIABIUrandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Fill_n<unsigned int *,unsigned int,unsigned int>, COMDAT

; 3250 : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 3251 : 		// if _OutIt is checked, this will ensure we have enough space
; 3252 : 		_OutIt _Last = _First + _Count; (_Last);

	mov	eax, DWORD PTR __Count$[ebp]
	mov	ecx, DWORD PTR __First$[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR __Last$[ebp], edx

; 3253 : 		_Fill_n(_CHECKED_BASE(_First), _Count, _Val,
; 3254 : 			_Range_checked_iterator_tag());

	xor	eax, eax
	mov	BYTE PTR $T143785[ebp], al
	movzx	ecx, BYTE PTR $T143785[ebp]
	push	ecx
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Checked_base@PAI@std@@YAPAIAAPAI@Z	; std::_Checked_base<unsigned int *>
	add	esp, 4
	push	eax
	call	??$_Fill_n@PAIII@std@@YAXPAIIABIU_Range_checked_iterator_tag@0@@Z ; std::_Fill_n<unsigned int *,unsigned int,unsigned int>
	add	esp, 16					; 00000010H

; 3255 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Fill_n@PAIII@std@@YAXPAIIABIUrandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Fill_n<unsigned int *,unsigned int,unsigned int>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Iter_cat@PAPAUD3DDEVCOMBO_T@Ogre@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAUD3DDEVCOMBO_T@Ogre@@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??$_Iter_cat@PAPAUD3DDEVCOMBO_T@Ogre@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAUD3DDEVCOMBO_T@Ogre@@@Z PROC ; std::_Iter_cat<Ogre::D3DDEVCOMBO_T * *>, COMDAT

; 952  : 	{	// return category from iterator argument

	push	ebp
	mov	ebp, esp
	push	ecx

; 953  : 	typename iterator_traits<_Iter>::iterator_category _Cat;
; 954  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 955  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Iter_cat@PAPAUD3DDEVCOMBO_T@Ogre@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAUD3DDEVCOMBO_T@Ogre@@@Z ENDP ; std::_Iter_cat<Ogre::D3DDEVCOMBO_T * *>
_TEXT	ENDS
PUBLIC	??$_Fill_n@PAPAUD3DDEVCOMBO_T@Ogre@@IPAU12@@std@@YAXPAPAUD3DDEVCOMBO_T@Ogre@@IABQAU12@U_Range_checked_iterator_tag@0@@Z ; std::_Fill_n<Ogre::D3DDEVCOMBO_T * *,unsigned int,Ogre::D3DDEVCOMBO_T *>
; Function compile flags: /Odtp
;	COMDAT ??$_Fill_n@PAPAUD3DDEVCOMBO_T@Ogre@@IPAU12@@std@@YAXPAPAUD3DDEVCOMBO_T@Ogre@@IABQAU12@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T143790 = -5						; size = 1
__Last$ = -4						; size = 4
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
??$_Fill_n@PAPAUD3DDEVCOMBO_T@Ogre@@IPAU12@@std@@YAXPAPAUD3DDEVCOMBO_T@Ogre@@IABQAU12@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Fill_n<Ogre::D3DDEVCOMBO_T * *,unsigned int,Ogre::D3DDEVCOMBO_T *>, COMDAT

; 3250 : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 3251 : 		// if _OutIt is checked, this will ensure we have enough space
; 3252 : 		_OutIt _Last = _First + _Count; (_Last);

	mov	eax, DWORD PTR __Count$[ebp]
	mov	ecx, DWORD PTR __First$[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR __Last$[ebp], edx

; 3253 : 		_Fill_n(_CHECKED_BASE(_First), _Count, _Val,
; 3254 : 			_Range_checked_iterator_tag());

	xor	eax, eax
	mov	BYTE PTR $T143790[ebp], al
	movzx	ecx, BYTE PTR $T143790[ebp]
	push	ecx
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Checked_base@PAPAUD3DDEVCOMBO_T@Ogre@@@std@@YAPAPAUD3DDEVCOMBO_T@Ogre@@AAPAPAU12@@Z ; std::_Checked_base<Ogre::D3DDEVCOMBO_T * *>
	add	esp, 4
	push	eax
	call	??$_Fill_n@PAPAUD3DDEVCOMBO_T@Ogre@@IPAU12@@std@@YAXPAPAUD3DDEVCOMBO_T@Ogre@@IABQAU12@U_Range_checked_iterator_tag@0@@Z ; std::_Fill_n<Ogre::D3DDEVCOMBO_T * *,unsigned int,Ogre::D3DDEVCOMBO_T *>
	add	esp, 16					; 00000010H

; 3255 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Fill_n@PAPAUD3DDEVCOMBO_T@Ogre@@IPAU12@@std@@YAXPAPAUD3DDEVCOMBO_T@Ogre@@IABQAU12@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Fill_n<Ogre::D3DDEVCOMBO_T * *,unsigned int,Ogre::D3DDEVCOMBO_T *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Iter_cat@PAPAUD3DDEVICEINFO_T@Ogre@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAUD3DDEVICEINFO_T@Ogre@@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??$_Iter_cat@PAPAUD3DDEVICEINFO_T@Ogre@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAUD3DDEVICEINFO_T@Ogre@@@Z PROC ; std::_Iter_cat<Ogre::D3DDEVICEINFO_T * *>, COMDAT

; 952  : 	{	// return category from iterator argument

	push	ebp
	mov	ebp, esp
	push	ecx

; 953  : 	typename iterator_traits<_Iter>::iterator_category _Cat;
; 954  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 955  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Iter_cat@PAPAUD3DDEVICEINFO_T@Ogre@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAUD3DDEVICEINFO_T@Ogre@@@Z ENDP ; std::_Iter_cat<Ogre::D3DDEVICEINFO_T * *>
_TEXT	ENDS
PUBLIC	??$_Fill_n@PAPAUD3DDEVICEINFO_T@Ogre@@IPAU12@@std@@YAXPAPAUD3DDEVICEINFO_T@Ogre@@IABQAU12@U_Range_checked_iterator_tag@0@@Z ; std::_Fill_n<Ogre::D3DDEVICEINFO_T * *,unsigned int,Ogre::D3DDEVICEINFO_T *>
; Function compile flags: /Odtp
;	COMDAT ??$_Fill_n@PAPAUD3DDEVICEINFO_T@Ogre@@IPAU12@@std@@YAXPAPAUD3DDEVICEINFO_T@Ogre@@IABQAU12@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T143795 = -5						; size = 1
__Last$ = -4						; size = 4
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
??$_Fill_n@PAPAUD3DDEVICEINFO_T@Ogre@@IPAU12@@std@@YAXPAPAUD3DDEVICEINFO_T@Ogre@@IABQAU12@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Fill_n<Ogre::D3DDEVICEINFO_T * *,unsigned int,Ogre::D3DDEVICEINFO_T *>, COMDAT

; 3250 : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 3251 : 		// if _OutIt is checked, this will ensure we have enough space
; 3252 : 		_OutIt _Last = _First + _Count; (_Last);

	mov	eax, DWORD PTR __Count$[ebp]
	mov	ecx, DWORD PTR __First$[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR __Last$[ebp], edx

; 3253 : 		_Fill_n(_CHECKED_BASE(_First), _Count, _Val,
; 3254 : 			_Range_checked_iterator_tag());

	xor	eax, eax
	mov	BYTE PTR $T143795[ebp], al
	movzx	ecx, BYTE PTR $T143795[ebp]
	push	ecx
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Checked_base@PAPAUD3DDEVICEINFO_T@Ogre@@@std@@YAPAPAUD3DDEVICEINFO_T@Ogre@@AAPAPAU12@@Z ; std::_Checked_base<Ogre::D3DDEVICEINFO_T * *>
	add	esp, 4
	push	eax
	call	??$_Fill_n@PAPAUD3DDEVICEINFO_T@Ogre@@IPAU12@@std@@YAXPAPAUD3DDEVICEINFO_T@Ogre@@IABQAU12@U_Range_checked_iterator_tag@0@@Z ; std::_Fill_n<Ogre::D3DDEVICEINFO_T * *,unsigned int,Ogre::D3DDEVICEINFO_T *>
	add	esp, 16					; 00000010H

; 3255 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Fill_n@PAPAUD3DDEVICEINFO_T@Ogre@@IPAU12@@std@@YAXPAPAUD3DDEVICEINFO_T@Ogre@@IABQAU12@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Fill_n<Ogre::D3DDEVICEINFO_T * *,unsigned int,Ogre::D3DDEVICEINFO_T *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Iter_cat@PAPAUD3DADAPTER_T@Ogre@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAUD3DADAPTER_T@Ogre@@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??$_Iter_cat@PAPAUD3DADAPTER_T@Ogre@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAUD3DADAPTER_T@Ogre@@@Z PROC ; std::_Iter_cat<Ogre::D3DADAPTER_T * *>, COMDAT

; 952  : 	{	// return category from iterator argument

	push	ebp
	mov	ebp, esp
	push	ecx

; 953  : 	typename iterator_traits<_Iter>::iterator_category _Cat;
; 954  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 955  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Iter_cat@PAPAUD3DADAPTER_T@Ogre@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAUD3DADAPTER_T@Ogre@@@Z ENDP ; std::_Iter_cat<Ogre::D3DADAPTER_T * *>
_TEXT	ENDS
PUBLIC	??$_Fill_n@PAPAUD3DADAPTER_T@Ogre@@IPAU12@@std@@YAXPAPAUD3DADAPTER_T@Ogre@@IABQAU12@U_Range_checked_iterator_tag@0@@Z ; std::_Fill_n<Ogre::D3DADAPTER_T * *,unsigned int,Ogre::D3DADAPTER_T *>
; Function compile flags: /Odtp
;	COMDAT ??$_Fill_n@PAPAUD3DADAPTER_T@Ogre@@IPAU12@@std@@YAXPAPAUD3DADAPTER_T@Ogre@@IABQAU12@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T143800 = -5						; size = 1
__Last$ = -4						; size = 4
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
??$_Fill_n@PAPAUD3DADAPTER_T@Ogre@@IPAU12@@std@@YAXPAPAUD3DADAPTER_T@Ogre@@IABQAU12@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Fill_n<Ogre::D3DADAPTER_T * *,unsigned int,Ogre::D3DADAPTER_T *>, COMDAT

; 3250 : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 3251 : 		// if _OutIt is checked, this will ensure we have enough space
; 3252 : 		_OutIt _Last = _First + _Count; (_Last);

	mov	eax, DWORD PTR __Count$[ebp]
	mov	ecx, DWORD PTR __First$[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR __Last$[ebp], edx

; 3253 : 		_Fill_n(_CHECKED_BASE(_First), _Count, _Val,
; 3254 : 			_Range_checked_iterator_tag());

	xor	eax, eax
	mov	BYTE PTR $T143800[ebp], al
	movzx	ecx, BYTE PTR $T143800[ebp]
	push	ecx
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Checked_base@PAPAUD3DADAPTER_T@Ogre@@@std@@YAPAPAUD3DADAPTER_T@Ogre@@AAPAPAU12@@Z ; std::_Checked_base<Ogre::D3DADAPTER_T * *>
	add	esp, 4
	push	eax
	call	??$_Fill_n@PAPAUD3DADAPTER_T@Ogre@@IPAU12@@std@@YAXPAPAUD3DADAPTER_T@Ogre@@IABQAU12@U_Range_checked_iterator_tag@0@@Z ; std::_Fill_n<Ogre::D3DADAPTER_T * *,unsigned int,Ogre::D3DADAPTER_T *>
	add	esp, 16					; 00000010H

; 3255 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Fill_n@PAPAUD3DADAPTER_T@Ogre@@IPAU12@@std@@YAXPAPAUD3DADAPTER_T@Ogre@@IABQAU12@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Fill_n<Ogre::D3DADAPTER_T * *,unsigned int,Ogre::D3DADAPTER_T *>
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PAW4_D3DFORMAT@@PAW41@V?$allocator@W4_D3DFORMAT@@@std@@@std@@YAPAW4_D3DFORMAT@@PAW41@00AAV?$allocator@W4_D3DFORMAT@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<enum _D3DFORMAT *,enum _D3DFORMAT *,std::allocator<enum _D3DFORMAT> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_copy@PAW4_D3DFORMAT@@PAW41@V?$allocator@W4_D3DFORMAT@@@std@@@stdext@@YAPAW4_D3DFORMAT@@PAW41@00AAV?$allocator@W4_D3DFORMAT@@@std@@@Z
_TEXT	SEGMENT
$T143804 = -2						; size = 1
$T143803 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@PAW4_D3DFORMAT@@PAW41@V?$allocator@W4_D3DFORMAT@@@std@@@stdext@@YAPAW4_D3DFORMAT@@PAW41@00AAV?$allocator@W4_D3DFORMAT@@@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<enum _D3DFORMAT *,enum _D3DFORMAT *,std::allocator<enum _D3DFORMAT> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T143803[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAW4_D3DFORMAT@@PAW41@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAW4_D3DFORMAT@@0@Z ; std::_Ptr_cat<enum _D3DFORMAT *,enum _D3DFORMAT *>
	add	esp, 8
	mov	BYTE PTR $T143804[ebp], al
	movzx	eax, BYTE PTR $T143803[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T143804[ebp]
	push	ecx
	mov	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@PAW4_D3DFORMAT@@@std@@YAPAW4_D3DFORMAT@@AAPAW41@@Z ; std::_Checked_base<enum _D3DFORMAT *>
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@PAW4_D3DFORMAT@@@std@@YAPAW4_D3DFORMAT@@AAPAW41@@Z ; std::_Checked_base<enum _D3DFORMAT *>
	add	esp, 4
	push	eax
	call	??$_Uninit_copy@PAW4_D3DFORMAT@@PAW41@V?$allocator@W4_D3DFORMAT@@@std@@@std@@YAPAW4_D3DFORMAT@@PAW41@00AAV?$allocator@W4_D3DFORMAT@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<enum _D3DFORMAT *,enum _D3DFORMAT *,std::allocator<enum _D3DFORMAT> >
	add	esp, 24					; 00000018H

; 823  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_copy@PAW4_D3DFORMAT@@PAW41@V?$allocator@W4_D3DFORMAT@@@std@@@stdext@@YAPAW4_D3DFORMAT@@PAW41@00AAV?$allocator@W4_D3DFORMAT@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<enum _D3DFORMAT *,enum _D3DFORMAT *,std::allocator<enum _D3DFORMAT> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Copy_backward_opt@PAW4_D3DFORMAT@@PAW41@Uforward_iterator_tag@std@@@std@@YAPAW4_D3DFORMAT@@PAW41@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_backward_opt@PAW4_D3DFORMAT@@PAW41@Uforward_iterator_tag@std@@@std@@YAPAW4_D3DFORMAT@@PAW41@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<enum _D3DFORMAT *,enum _D3DFORMAT *,std::forward_iterator_tag>, COMDAT

; 2673 : 	{	// copy [_First, _Last) backwards to [..., _Dest), arbitrary iterators

	push	ebp
	mov	ebp, esp
$LN2@Copy_backw@5:

; 2674 : 	_DEBUG_RANGE(_First, _Last);
; 2675 : 	while (_First != _Last)

	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	SHORT $LN1@Copy_backw@5

; 2676 : 		*--_Dest = *--_Last;

	mov	ecx, DWORD PTR __Last$[ebp]
	sub	ecx, 4
	mov	DWORD PTR __Last$[ebp], ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	sub	edx, 4
	mov	DWORD PTR __Dest$[ebp], edx
	mov	eax, DWORD PTR __Dest$[ebp]
	mov	ecx, DWORD PTR __Last$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	jmp	SHORT $LN2@Copy_backw@5
$LN1@Copy_backw@5:

; 2677 : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[ebp]

; 2678 : 	}

	pop	ebp
	ret	0
??$_Copy_backward_opt@PAW4_D3DFORMAT@@PAW41@Uforward_iterator_tag@std@@@std@@YAPAW4_D3DFORMAT@@PAW41@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<enum _D3DFORMAT *,enum _D3DFORMAT *,std::forward_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PAW4_D3DMULTISAMPLE_TYPE@@PAW41@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@YAPAW4_D3DMULTISAMPLE_TYPE@@PAW41@00AAV?$allocator@W4_D3DMULTISAMPLE_TYPE@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<enum _D3DMULTISAMPLE_TYPE *,enum _D3DMULTISAMPLE_TYPE *,std::allocator<enum _D3DMULTISAMPLE_TYPE> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_copy@PAW4_D3DMULTISAMPLE_TYPE@@PAW41@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@stdext@@YAPAW4_D3DMULTISAMPLE_TYPE@@PAW41@00AAV?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@Z
_TEXT	SEGMENT
$T143810 = -2						; size = 1
$T143809 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@PAW4_D3DMULTISAMPLE_TYPE@@PAW41@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@stdext@@YAPAW4_D3DMULTISAMPLE_TYPE@@PAW41@00AAV?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<enum _D3DMULTISAMPLE_TYPE *,enum _D3DMULTISAMPLE_TYPE *,std::allocator<enum _D3DMULTISAMPLE_TYPE> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T143809[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAW4_D3DMULTISAMPLE_TYPE@@PAW41@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAW4_D3DMULTISAMPLE_TYPE@@0@Z ; std::_Ptr_cat<enum _D3DMULTISAMPLE_TYPE *,enum _D3DMULTISAMPLE_TYPE *>
	add	esp, 8
	mov	BYTE PTR $T143810[ebp], al
	movzx	eax, BYTE PTR $T143809[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T143810[ebp]
	push	ecx
	mov	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@PAW4_D3DMULTISAMPLE_TYPE@@@std@@YAPAW4_D3DMULTISAMPLE_TYPE@@AAPAW41@@Z ; std::_Checked_base<enum _D3DMULTISAMPLE_TYPE *>
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@PAW4_D3DMULTISAMPLE_TYPE@@@std@@YAPAW4_D3DMULTISAMPLE_TYPE@@AAPAW41@@Z ; std::_Checked_base<enum _D3DMULTISAMPLE_TYPE *>
	add	esp, 4
	push	eax
	call	??$_Uninit_copy@PAW4_D3DMULTISAMPLE_TYPE@@PAW41@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@YAPAW4_D3DMULTISAMPLE_TYPE@@PAW41@00AAV?$allocator@W4_D3DMULTISAMPLE_TYPE@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<enum _D3DMULTISAMPLE_TYPE *,enum _D3DMULTISAMPLE_TYPE *,std::allocator<enum _D3DMULTISAMPLE_TYPE> >
	add	esp, 24					; 00000018H

; 823  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_copy@PAW4_D3DMULTISAMPLE_TYPE@@PAW41@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@stdext@@YAPAW4_D3DMULTISAMPLE_TYPE@@PAW41@00AAV?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<enum _D3DMULTISAMPLE_TYPE *,enum _D3DMULTISAMPLE_TYPE *,std::allocator<enum _D3DMULTISAMPLE_TYPE> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Copy_backward_opt@PAW4_D3DMULTISAMPLE_TYPE@@PAW41@Uforward_iterator_tag@std@@@std@@YAPAW4_D3DMULTISAMPLE_TYPE@@PAW41@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_backward_opt@PAW4_D3DMULTISAMPLE_TYPE@@PAW41@Uforward_iterator_tag@std@@@std@@YAPAW4_D3DMULTISAMPLE_TYPE@@PAW41@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<enum _D3DMULTISAMPLE_TYPE *,enum _D3DMULTISAMPLE_TYPE *,std::forward_iterator_tag>, COMDAT

; 2673 : 	{	// copy [_First, _Last) backwards to [..., _Dest), arbitrary iterators

	push	ebp
	mov	ebp, esp
$LN2@Copy_backw@6:

; 2674 : 	_DEBUG_RANGE(_First, _Last);
; 2675 : 	while (_First != _Last)

	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	SHORT $LN1@Copy_backw@6

; 2676 : 		*--_Dest = *--_Last;

	mov	ecx, DWORD PTR __Last$[ebp]
	sub	ecx, 4
	mov	DWORD PTR __Last$[ebp], ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	sub	edx, 4
	mov	DWORD PTR __Dest$[ebp], edx
	mov	eax, DWORD PTR __Dest$[ebp]
	mov	ecx, DWORD PTR __Last$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	jmp	SHORT $LN2@Copy_backw@6
$LN1@Copy_backw@6:

; 2677 : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[ebp]

; 2678 : 	}

	pop	ebp
	ret	0
??$_Copy_backward_opt@PAW4_D3DMULTISAMPLE_TYPE@@PAW41@Uforward_iterator_tag@std@@@std@@YAPAW4_D3DMULTISAMPLE_TYPE@@PAW41@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<enum _D3DMULTISAMPLE_TYPE *,enum _D3DMULTISAMPLE_TYPE *,std::forward_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PAIPAIV?$allocator@I@std@@@std@@YAPAIPAI00AAV?$allocator@I@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<unsigned int *,unsigned int *,std::allocator<unsigned int> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_copy@PAIPAIV?$allocator@I@std@@@stdext@@YAPAIPAI00AAV?$allocator@I@std@@@Z
_TEXT	SEGMENT
$T143816 = -2						; size = 1
$T143815 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@PAIPAIV?$allocator@I@std@@@stdext@@YAPAIPAI00AAV?$allocator@I@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<unsigned int *,unsigned int *,std::allocator<unsigned int> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T143815[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAIPAI@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAI0@Z ; std::_Ptr_cat<unsigned int *,unsigned int *>
	add	esp, 8
	mov	BYTE PTR $T143816[ebp], al
	movzx	eax, BYTE PTR $T143815[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T143816[ebp]
	push	ecx
	mov	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@PAI@std@@YAPAIAAPAI@Z	; std::_Checked_base<unsigned int *>
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@PAI@std@@YAPAIAAPAI@Z	; std::_Checked_base<unsigned int *>
	add	esp, 4
	push	eax
	call	??$_Uninit_copy@PAIPAIV?$allocator@I@std@@@std@@YAPAIPAI00AAV?$allocator@I@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<unsigned int *,unsigned int *,std::allocator<unsigned int> >
	add	esp, 24					; 00000018H

; 823  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_copy@PAIPAIV?$allocator@I@std@@@stdext@@YAPAIPAI00AAV?$allocator@I@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<unsigned int *,unsigned int *,std::allocator<unsigned int> >
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PAUD3DSMSCONFLICT_T@Ogre@@PAU12@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@YAPAUD3DSMSCONFLICT_T@Ogre@@PAU12@00AAV?$allocator@UD3DSMSCONFLICT_T@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Ogre::D3DSMSCONFLICT_T *,Ogre::D3DSMSCONFLICT_T *,std::allocator<Ogre::D3DSMSCONFLICT_T> >
; Function compile flags: /Odtp
;	COMDAT ??$unchecked_uninitialized_copy@PAUD3DSMSCONFLICT_T@Ogre@@PAU12@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@stdext@@YAPAUD3DSMSCONFLICT_T@Ogre@@PAU12@00AAV?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@Z
_TEXT	SEGMENT
$T143820 = -2						; size = 1
$T143819 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@PAUD3DSMSCONFLICT_T@Ogre@@PAU12@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@stdext@@YAPAUD3DSMSCONFLICT_T@Ogre@@PAU12@00AAV?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<Ogre::D3DSMSCONFLICT_T *,Ogre::D3DSMSCONFLICT_T *,std::allocator<Ogre::D3DSMSCONFLICT_T> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T143819[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAUD3DSMSCONFLICT_T@Ogre@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUD3DSMSCONFLICT_T@Ogre@@0@Z ; std::_Ptr_cat<Ogre::D3DSMSCONFLICT_T *,Ogre::D3DSMSCONFLICT_T *>
	add	esp, 8
	mov	BYTE PTR $T143820[ebp], al
	movzx	eax, BYTE PTR $T143819[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T143820[ebp]
	push	ecx
	mov	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@PAUD3DSMSCONFLICT_T@Ogre@@@std@@YAPAUD3DSMSCONFLICT_T@Ogre@@AAPAU12@@Z ; std::_Checked_base<Ogre::D3DSMSCONFLICT_T *>
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@PAUD3DSMSCONFLICT_T@Ogre@@@std@@YAPAUD3DSMSCONFLICT_T@Ogre@@AAPAU12@@Z ; std::_Checked_base<Ogre::D3DSMSCONFLICT_T *>
	add	esp, 4
	push	eax
	call	??$_Uninit_copy@PAUD3DSMSCONFLICT_T@Ogre@@PAU12@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@YAPAUD3DSMSCONFLICT_T@Ogre@@PAU12@00AAV?$allocator@UD3DSMSCONFLICT_T@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Ogre::D3DSMSCONFLICT_T *,Ogre::D3DSMSCONFLICT_T *,std::allocator<Ogre::D3DSMSCONFLICT_T> >
	add	esp, 24					; 00000018H

; 823  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_copy@PAUD3DSMSCONFLICT_T@Ogre@@PAU12@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@stdext@@YAPAUD3DSMSCONFLICT_T@Ogre@@PAU12@00AAV?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<Ogre::D3DSMSCONFLICT_T *,Ogre::D3DSMSCONFLICT_T *,std::allocator<Ogre::D3DSMSCONFLICT_T> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Copy_backward_opt@PAUD3DSMSCONFLICT_T@Ogre@@PAU12@Uforward_iterator_tag@std@@@std@@YAPAUD3DSMSCONFLICT_T@Ogre@@PAU12@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_backward_opt@PAUD3DSMSCONFLICT_T@Ogre@@PAU12@Uforward_iterator_tag@std@@@std@@YAPAUD3DSMSCONFLICT_T@Ogre@@PAU12@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<Ogre::D3DSMSCONFLICT_T *,Ogre::D3DSMSCONFLICT_T *,std::forward_iterator_tag>, COMDAT

; 2673 : 	{	// copy [_First, _Last) backwards to [..., _Dest), arbitrary iterators

	push	ebp
	mov	ebp, esp
$LN2@Copy_backw@7:

; 2674 : 	_DEBUG_RANGE(_First, _Last);
; 2675 : 	while (_First != _Last)

	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	SHORT $LN1@Copy_backw@7

; 2676 : 		*--_Dest = *--_Last;

	mov	ecx, DWORD PTR __Last$[ebp]
	sub	ecx, 8
	mov	DWORD PTR __Last$[ebp], ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	sub	edx, 8
	mov	DWORD PTR __Dest$[ebp], edx
	mov	eax, DWORD PTR __Last$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	jmp	SHORT $LN2@Copy_backw@7
$LN1@Copy_backw@7:

; 2677 : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[ebp]

; 2678 : 	}

	pop	ebp
	ret	0
??$_Copy_backward_opt@PAUD3DSMSCONFLICT_T@Ogre@@PAU12@Uforward_iterator_tag@std@@@std@@YAPAUD3DSMSCONFLICT_T@Ogre@@PAU12@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<Ogre::D3DSMSCONFLICT_T *,Ogre::D3DSMSCONFLICT_T *,std::forward_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PAW4VERTPROCESS_T@Ogre@@PAW412@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@YAPAW4VERTPROCESS_T@Ogre@@PAW412@00AAV?$allocator@W4VERTPROCESS_T@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<enum Ogre::VERTPROCESS_T *,enum Ogre::VERTPROCESS_T *,std::allocator<enum Ogre::VERTPROCESS_T> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_copy@PAW4VERTPROCESS_T@Ogre@@PAW412@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@stdext@@YAPAW4VERTPROCESS_T@Ogre@@PAW412@00AAV?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@Z
_TEXT	SEGMENT
$T143826 = -2						; size = 1
$T143825 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@PAW4VERTPROCESS_T@Ogre@@PAW412@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@stdext@@YAPAW4VERTPROCESS_T@Ogre@@PAW412@00AAV?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<enum Ogre::VERTPROCESS_T *,enum Ogre::VERTPROCESS_T *,std::allocator<enum Ogre::VERTPROCESS_T> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T143825[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAW4VERTPROCESS_T@Ogre@@PAW412@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAW4VERTPROCESS_T@Ogre@@0@Z ; std::_Ptr_cat<enum Ogre::VERTPROCESS_T *,enum Ogre::VERTPROCESS_T *>
	add	esp, 8
	mov	BYTE PTR $T143826[ebp], al
	movzx	eax, BYTE PTR $T143825[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T143826[ebp]
	push	ecx
	mov	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@PAW4VERTPROCESS_T@Ogre@@@std@@YAPAW4VERTPROCESS_T@Ogre@@AAPAW412@@Z ; std::_Checked_base<enum Ogre::VERTPROCESS_T *>
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@PAW4VERTPROCESS_T@Ogre@@@std@@YAPAW4VERTPROCESS_T@Ogre@@AAPAW412@@Z ; std::_Checked_base<enum Ogre::VERTPROCESS_T *>
	add	esp, 4
	push	eax
	call	??$_Uninit_copy@PAW4VERTPROCESS_T@Ogre@@PAW412@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@YAPAW4VERTPROCESS_T@Ogre@@PAW412@00AAV?$allocator@W4VERTPROCESS_T@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<enum Ogre::VERTPROCESS_T *,enum Ogre::VERTPROCESS_T *,std::allocator<enum Ogre::VERTPROCESS_T> >
	add	esp, 24					; 00000018H

; 823  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_copy@PAW4VERTPROCESS_T@Ogre@@PAW412@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@stdext@@YAPAW4VERTPROCESS_T@Ogre@@PAW412@00AAV?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<enum Ogre::VERTPROCESS_T *,enum Ogre::VERTPROCESS_T *,std::allocator<enum Ogre::VERTPROCESS_T> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Copy_backward_opt@PAW4VERTPROCESS_T@Ogre@@PAW412@Uforward_iterator_tag@std@@@std@@YAPAW4VERTPROCESS_T@Ogre@@PAW412@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_backward_opt@PAW4VERTPROCESS_T@Ogre@@PAW412@Uforward_iterator_tag@std@@@std@@YAPAW4VERTPROCESS_T@Ogre@@PAW412@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<enum Ogre::VERTPROCESS_T *,enum Ogre::VERTPROCESS_T *,std::forward_iterator_tag>, COMDAT

; 2673 : 	{	// copy [_First, _Last) backwards to [..., _Dest), arbitrary iterators

	push	ebp
	mov	ebp, esp
$LN2@Copy_backw@8:

; 2674 : 	_DEBUG_RANGE(_First, _Last);
; 2675 : 	while (_First != _Last)

	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	SHORT $LN1@Copy_backw@8

; 2676 : 		*--_Dest = *--_Last;

	mov	ecx, DWORD PTR __Last$[ebp]
	sub	ecx, 4
	mov	DWORD PTR __Last$[ebp], ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	sub	edx, 4
	mov	DWORD PTR __Dest$[ebp], edx
	mov	eax, DWORD PTR __Dest$[ebp]
	mov	ecx, DWORD PTR __Last$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	jmp	SHORT $LN2@Copy_backw@8
$LN1@Copy_backw@8:

; 2677 : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[ebp]

; 2678 : 	}

	pop	ebp
	ret	0
??$_Copy_backward_opt@PAW4VERTPROCESS_T@Ogre@@PAW412@Uforward_iterator_tag@std@@@std@@YAPAW4VERTPROCESS_T@Ogre@@PAW412@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<enum Ogre::VERTPROCESS_T *,enum Ogre::VERTPROCESS_T *,std::forward_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PAPAUD3DDEVCOMBO_T@Ogre@@PAPAU12@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@YAPAPAUD3DDEVCOMBO_T@Ogre@@PAPAU12@00AAV?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Ogre::D3DDEVCOMBO_T * *,Ogre::D3DDEVCOMBO_T * *,std::allocator<Ogre::D3DDEVCOMBO_T *> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_copy@PAPAUD3DDEVCOMBO_T@Ogre@@PAPAU12@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@stdext@@YAPAPAUD3DDEVCOMBO_T@Ogre@@PAPAU12@00AAV?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@Z
_TEXT	SEGMENT
$T143832 = -2						; size = 1
$T143831 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@PAPAUD3DDEVCOMBO_T@Ogre@@PAPAU12@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@stdext@@YAPAPAUD3DDEVCOMBO_T@Ogre@@PAPAU12@00AAV?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<Ogre::D3DDEVCOMBO_T * *,Ogre::D3DDEVCOMBO_T * *,std::allocator<Ogre::D3DDEVCOMBO_T *> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T143831[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAPAUD3DDEVCOMBO_T@Ogre@@PAPAU12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAUD3DDEVCOMBO_T@Ogre@@0@Z ; std::_Ptr_cat<Ogre::D3DDEVCOMBO_T * *,Ogre::D3DDEVCOMBO_T * *>
	add	esp, 8
	mov	BYTE PTR $T143832[ebp], al
	movzx	eax, BYTE PTR $T143831[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T143832[ebp]
	push	ecx
	mov	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@PAPAUD3DDEVCOMBO_T@Ogre@@@std@@YAPAPAUD3DDEVCOMBO_T@Ogre@@AAPAPAU12@@Z ; std::_Checked_base<Ogre::D3DDEVCOMBO_T * *>
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@PAPAUD3DDEVCOMBO_T@Ogre@@@std@@YAPAPAUD3DDEVCOMBO_T@Ogre@@AAPAPAU12@@Z ; std::_Checked_base<Ogre::D3DDEVCOMBO_T * *>
	add	esp, 4
	push	eax
	call	??$_Uninit_copy@PAPAUD3DDEVCOMBO_T@Ogre@@PAPAU12@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@YAPAPAUD3DDEVCOMBO_T@Ogre@@PAPAU12@00AAV?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Ogre::D3DDEVCOMBO_T * *,Ogre::D3DDEVCOMBO_T * *,std::allocator<Ogre::D3DDEVCOMBO_T *> >
	add	esp, 24					; 00000018H

; 823  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_copy@PAPAUD3DDEVCOMBO_T@Ogre@@PAPAU12@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@stdext@@YAPAPAUD3DDEVCOMBO_T@Ogre@@PAPAU12@00AAV?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<Ogre::D3DDEVCOMBO_T * *,Ogre::D3DDEVCOMBO_T * *,std::allocator<Ogre::D3DDEVCOMBO_T *> >
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PAU_D3DDISPLAYMODE@@PAU1@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@YAPAU_D3DDISPLAYMODE@@PAU1@00AAV?$allocator@U_D3DDISPLAYMODE@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<_D3DDISPLAYMODE *,_D3DDISPLAYMODE *,std::allocator<_D3DDISPLAYMODE> >
; Function compile flags: /Odtp
;	COMDAT ??$unchecked_uninitialized_copy@PAU_D3DDISPLAYMODE@@PAU1@V?$allocator@U_D3DDISPLAYMODE@@@std@@@stdext@@YAPAU_D3DDISPLAYMODE@@PAU1@00AAV?$allocator@U_D3DDISPLAYMODE@@@std@@@Z
_TEXT	SEGMENT
$T143836 = -2						; size = 1
$T143835 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@PAU_D3DDISPLAYMODE@@PAU1@V?$allocator@U_D3DDISPLAYMODE@@@std@@@stdext@@YAPAU_D3DDISPLAYMODE@@PAU1@00AAV?$allocator@U_D3DDISPLAYMODE@@@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<_D3DDISPLAYMODE *,_D3DDISPLAYMODE *,std::allocator<_D3DDISPLAYMODE> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T143835[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAU_D3DDISPLAYMODE@@PAU1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAU_D3DDISPLAYMODE@@0@Z ; std::_Ptr_cat<_D3DDISPLAYMODE *,_D3DDISPLAYMODE *>
	add	esp, 8
	mov	BYTE PTR $T143836[ebp], al
	movzx	eax, BYTE PTR $T143835[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T143836[ebp]
	push	ecx
	mov	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@PAU_D3DDISPLAYMODE@@@std@@YAPAU_D3DDISPLAYMODE@@AAPAU1@@Z ; std::_Checked_base<_D3DDISPLAYMODE *>
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@PAU_D3DDISPLAYMODE@@@std@@YAPAU_D3DDISPLAYMODE@@AAPAU1@@Z ; std::_Checked_base<_D3DDISPLAYMODE *>
	add	esp, 4
	push	eax
	call	??$_Uninit_copy@PAU_D3DDISPLAYMODE@@PAU1@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@YAPAU_D3DDISPLAYMODE@@PAU1@00AAV?$allocator@U_D3DDISPLAYMODE@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<_D3DDISPLAYMODE *,_D3DDISPLAYMODE *,std::allocator<_D3DDISPLAYMODE> >
	add	esp, 24					; 00000018H

; 823  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_copy@PAU_D3DDISPLAYMODE@@PAU1@V?$allocator@U_D3DDISPLAYMODE@@@std@@@stdext@@YAPAU_D3DDISPLAYMODE@@PAU1@00AAV?$allocator@U_D3DDISPLAYMODE@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<_D3DDISPLAYMODE *,_D3DDISPLAYMODE *,std::allocator<_D3DDISPLAYMODE> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Copy_backward_opt@PAU_D3DDISPLAYMODE@@PAU1@Uforward_iterator_tag@std@@@std@@YAPAU_D3DDISPLAYMODE@@PAU1@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_backward_opt@PAU_D3DDISPLAYMODE@@PAU1@Uforward_iterator_tag@std@@@std@@YAPAU_D3DDISPLAYMODE@@PAU1@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<_D3DDISPLAYMODE *,_D3DDISPLAYMODE *,std::forward_iterator_tag>, COMDAT

; 2673 : 	{	// copy [_First, _Last) backwards to [..., _Dest), arbitrary iterators

	push	ebp
	mov	ebp, esp
$LN2@Copy_backw@9:

; 2674 : 	_DEBUG_RANGE(_First, _Last);
; 2675 : 	while (_First != _Last)

	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	SHORT $LN1@Copy_backw@9

; 2676 : 		*--_Dest = *--_Last;

	mov	ecx, DWORD PTR __Last$[ebp]
	sub	ecx, 16					; 00000010H
	mov	DWORD PTR __Last$[ebp], ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	sub	edx, 16					; 00000010H
	mov	DWORD PTR __Dest$[ebp], edx
	mov	eax, DWORD PTR __Last$[ebp]
	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], eax
	jmp	SHORT $LN2@Copy_backw@9
$LN1@Copy_backw@9:

; 2677 : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[ebp]

; 2678 : 	}

	pop	ebp
	ret	0
??$_Copy_backward_opt@PAU_D3DDISPLAYMODE@@PAU1@Uforward_iterator_tag@std@@@std@@YAPAU_D3DDISPLAYMODE@@PAU1@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<_D3DDISPLAYMODE *,_D3DDISPLAYMODE *,std::forward_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PAPAUD3DDEVICEINFO_T@Ogre@@PAPAU12@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@YAPAPAUD3DDEVICEINFO_T@Ogre@@PAPAU12@00AAV?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Ogre::D3DDEVICEINFO_T * *,Ogre::D3DDEVICEINFO_T * *,std::allocator<Ogre::D3DDEVICEINFO_T *> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_copy@PAPAUD3DDEVICEINFO_T@Ogre@@PAPAU12@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@stdext@@YAPAPAUD3DDEVICEINFO_T@Ogre@@PAPAU12@00AAV?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@Z
_TEXT	SEGMENT
$T143842 = -2						; size = 1
$T143841 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@PAPAUD3DDEVICEINFO_T@Ogre@@PAPAU12@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@stdext@@YAPAPAUD3DDEVICEINFO_T@Ogre@@PAPAU12@00AAV?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<Ogre::D3DDEVICEINFO_T * *,Ogre::D3DDEVICEINFO_T * *,std::allocator<Ogre::D3DDEVICEINFO_T *> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T143841[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAPAUD3DDEVICEINFO_T@Ogre@@PAPAU12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAUD3DDEVICEINFO_T@Ogre@@0@Z ; std::_Ptr_cat<Ogre::D3DDEVICEINFO_T * *,Ogre::D3DDEVICEINFO_T * *>
	add	esp, 8
	mov	BYTE PTR $T143842[ebp], al
	movzx	eax, BYTE PTR $T143841[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T143842[ebp]
	push	ecx
	mov	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@PAPAUD3DDEVICEINFO_T@Ogre@@@std@@YAPAPAUD3DDEVICEINFO_T@Ogre@@AAPAPAU12@@Z ; std::_Checked_base<Ogre::D3DDEVICEINFO_T * *>
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@PAPAUD3DDEVICEINFO_T@Ogre@@@std@@YAPAPAUD3DDEVICEINFO_T@Ogre@@AAPAPAU12@@Z ; std::_Checked_base<Ogre::D3DDEVICEINFO_T * *>
	add	esp, 4
	push	eax
	call	??$_Uninit_copy@PAPAUD3DDEVICEINFO_T@Ogre@@PAPAU12@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@YAPAPAUD3DDEVICEINFO_T@Ogre@@PAPAU12@00AAV?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Ogre::D3DDEVICEINFO_T * *,Ogre::D3DDEVICEINFO_T * *,std::allocator<Ogre::D3DDEVICEINFO_T *> >
	add	esp, 24					; 00000018H

; 823  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_copy@PAPAUD3DDEVICEINFO_T@Ogre@@PAPAU12@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@stdext@@YAPAPAUD3DDEVICEINFO_T@Ogre@@PAPAU12@00AAV?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<Ogre::D3DDEVICEINFO_T * *,Ogre::D3DDEVICEINFO_T * *,std::allocator<Ogre::D3DDEVICEINFO_T *> >
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PAPAUD3DADAPTER_T@Ogre@@PAPAU12@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@YAPAPAUD3DADAPTER_T@Ogre@@PAPAU12@00AAV?$allocator@PAUD3DADAPTER_T@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Ogre::D3DADAPTER_T * *,Ogre::D3DADAPTER_T * *,std::allocator<Ogre::D3DADAPTER_T *> >
; Function compile flags: /Odtp
;	COMDAT ??$unchecked_uninitialized_copy@PAPAUD3DADAPTER_T@Ogre@@PAPAU12@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@stdext@@YAPAPAUD3DADAPTER_T@Ogre@@PAPAU12@00AAV?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@Z
_TEXT	SEGMENT
$T143846 = -2						; size = 1
$T143845 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@PAPAUD3DADAPTER_T@Ogre@@PAPAU12@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@stdext@@YAPAPAUD3DADAPTER_T@Ogre@@PAPAU12@00AAV?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<Ogre::D3DADAPTER_T * *,Ogre::D3DADAPTER_T * *,std::allocator<Ogre::D3DADAPTER_T *> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T143845[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAPAUD3DADAPTER_T@Ogre@@PAPAU12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAUD3DADAPTER_T@Ogre@@0@Z ; std::_Ptr_cat<Ogre::D3DADAPTER_T * *,Ogre::D3DADAPTER_T * *>
	add	esp, 8
	mov	BYTE PTR $T143846[ebp], al
	movzx	eax, BYTE PTR $T143845[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T143846[ebp]
	push	ecx
	mov	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@PAPAUD3DADAPTER_T@Ogre@@@std@@YAPAPAUD3DADAPTER_T@Ogre@@AAPAPAU12@@Z ; std::_Checked_base<Ogre::D3DADAPTER_T * *>
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@PAPAUD3DADAPTER_T@Ogre@@@std@@YAPAPAUD3DADAPTER_T@Ogre@@AAPAPAU12@@Z ; std::_Checked_base<Ogre::D3DADAPTER_T * *>
	add	esp, 4
	push	eax
	call	??$_Uninit_copy@PAPAUD3DADAPTER_T@Ogre@@PAPAU12@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@YAPAPAUD3DADAPTER_T@Ogre@@PAPAU12@00AAV?$allocator@PAUD3DADAPTER_T@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Ogre::D3DADAPTER_T * *,Ogre::D3DADAPTER_T * *,std::allocator<Ogre::D3DADAPTER_T *> >
	add	esp, 24					; 00000018H

; 823  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_copy@PAPAUD3DADAPTER_T@Ogre@@PAPAU12@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@stdext@@YAPAPAUD3DADAPTER_T@Ogre@@PAPAU12@00AAV?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<Ogre::D3DADAPTER_T * *,Ogre::D3DADAPTER_T * *,std::allocator<Ogre::D3DADAPTER_T *> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Fill_n@PAIII@std@@YAXPAIIABIU_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Fill_n@PAIII@std@@YAXPAIIABIU_Range_checked_iterator_tag@0@@Z PROC ; std::_Fill_n<unsigned int *,unsigned int,unsigned int>, COMDAT

; 3196 : 	{	// copy _Val _Count times through [_First, ...)

	push	ebp
	mov	ebp, esp

; 3197 : 	for (; 0 < _Count; --_Count, ++_First)

	jmp	SHORT $LN3@Fill_n
$LN2@Fill_n:
	mov	eax, DWORD PTR __Count$[ebp]
	sub	eax, 1
	mov	DWORD PTR __Count$[ebp], eax
	mov	ecx, DWORD PTR __First$[ebp]
	add	ecx, 4
	mov	DWORD PTR __First$[ebp], ecx
$LN3@Fill_n:
	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN4@Fill_n

; 3198 : 		*_First = _Val;

	mov	edx, DWORD PTR __First$[ebp]
	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	jmp	SHORT $LN2@Fill_n
$LN4@Fill_n:

; 3199 : 	}

	pop	ebp
	ret	0
??$_Fill_n@PAIII@std@@YAXPAIIABIU_Range_checked_iterator_tag@0@@Z ENDP ; std::_Fill_n<unsigned int *,unsigned int,unsigned int>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Fill_n@PAPAUD3DDEVCOMBO_T@Ogre@@IPAU12@@std@@YAXPAPAUD3DDEVCOMBO_T@Ogre@@IABQAU12@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Fill_n@PAPAUD3DDEVCOMBO_T@Ogre@@IPAU12@@std@@YAXPAPAUD3DDEVCOMBO_T@Ogre@@IABQAU12@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Fill_n<Ogre::D3DDEVCOMBO_T * *,unsigned int,Ogre::D3DDEVCOMBO_T *>, COMDAT

; 3196 : 	{	// copy _Val _Count times through [_First, ...)

	push	ebp
	mov	ebp, esp

; 3197 : 	for (; 0 < _Count; --_Count, ++_First)

	jmp	SHORT $LN3@Fill_n@2
$LN2@Fill_n@2:
	mov	eax, DWORD PTR __Count$[ebp]
	sub	eax, 1
	mov	DWORD PTR __Count$[ebp], eax
	mov	ecx, DWORD PTR __First$[ebp]
	add	ecx, 4
	mov	DWORD PTR __First$[ebp], ecx
$LN3@Fill_n@2:
	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN4@Fill_n@2

; 3198 : 		*_First = _Val;

	mov	edx, DWORD PTR __First$[ebp]
	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	jmp	SHORT $LN2@Fill_n@2
$LN4@Fill_n@2:

; 3199 : 	}

	pop	ebp
	ret	0
??$_Fill_n@PAPAUD3DDEVCOMBO_T@Ogre@@IPAU12@@std@@YAXPAPAUD3DDEVCOMBO_T@Ogre@@IABQAU12@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Fill_n<Ogre::D3DDEVCOMBO_T * *,unsigned int,Ogre::D3DDEVCOMBO_T *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Fill_n@PAPAUD3DDEVICEINFO_T@Ogre@@IPAU12@@std@@YAXPAPAUD3DDEVICEINFO_T@Ogre@@IABQAU12@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Fill_n@PAPAUD3DDEVICEINFO_T@Ogre@@IPAU12@@std@@YAXPAPAUD3DDEVICEINFO_T@Ogre@@IABQAU12@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Fill_n<Ogre::D3DDEVICEINFO_T * *,unsigned int,Ogre::D3DDEVICEINFO_T *>, COMDAT

; 3196 : 	{	// copy _Val _Count times through [_First, ...)

	push	ebp
	mov	ebp, esp

; 3197 : 	for (; 0 < _Count; --_Count, ++_First)

	jmp	SHORT $LN3@Fill_n@3
$LN2@Fill_n@3:
	mov	eax, DWORD PTR __Count$[ebp]
	sub	eax, 1
	mov	DWORD PTR __Count$[ebp], eax
	mov	ecx, DWORD PTR __First$[ebp]
	add	ecx, 4
	mov	DWORD PTR __First$[ebp], ecx
$LN3@Fill_n@3:
	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN4@Fill_n@3

; 3198 : 		*_First = _Val;

	mov	edx, DWORD PTR __First$[ebp]
	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	jmp	SHORT $LN2@Fill_n@3
$LN4@Fill_n@3:

; 3199 : 	}

	pop	ebp
	ret	0
??$_Fill_n@PAPAUD3DDEVICEINFO_T@Ogre@@IPAU12@@std@@YAXPAPAUD3DDEVICEINFO_T@Ogre@@IABQAU12@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Fill_n<Ogre::D3DDEVICEINFO_T * *,unsigned int,Ogre::D3DDEVICEINFO_T *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Fill_n@PAPAUD3DADAPTER_T@Ogre@@IPAU12@@std@@YAXPAPAUD3DADAPTER_T@Ogre@@IABQAU12@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Fill_n@PAPAUD3DADAPTER_T@Ogre@@IPAU12@@std@@YAXPAPAUD3DADAPTER_T@Ogre@@IABQAU12@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Fill_n<Ogre::D3DADAPTER_T * *,unsigned int,Ogre::D3DADAPTER_T *>, COMDAT

; 3196 : 	{	// copy _Val _Count times through [_First, ...)

	push	ebp
	mov	ebp, esp

; 3197 : 	for (; 0 < _Count; --_Count, ++_First)

	jmp	SHORT $LN3@Fill_n@4
$LN2@Fill_n@4:
	mov	eax, DWORD PTR __Count$[ebp]
	sub	eax, 1
	mov	DWORD PTR __Count$[ebp], eax
	mov	ecx, DWORD PTR __First$[ebp]
	add	ecx, 4
	mov	DWORD PTR __First$[ebp], ecx
$LN3@Fill_n@4:
	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN4@Fill_n@4

; 3198 : 		*_First = _Val;

	mov	edx, DWORD PTR __First$[ebp]
	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	jmp	SHORT $LN2@Fill_n@4
$LN4@Fill_n@4:

; 3199 : 	}

	pop	ebp
	ret	0
??$_Fill_n@PAPAUD3DADAPTER_T@Ogre@@IPAU12@@std@@YAXPAPAUD3DADAPTER_T@Ogre@@IABQAU12@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Fill_n<Ogre::D3DADAPTER_T * *,unsigned int,Ogre::D3DADAPTER_T *>
_TEXT	ENDS
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	SEGMENT
__catchsym$??$_Uninit_copy@PAW4_D3DFORMAT@@PAW41@V?$allocator@W4_D3DFORMAT@@@std@@@std@@YAPAW4_D3DFORMAT@@PAW41@00AAV?$allocator@W4_D3DFORMAT@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_copy@PAW4_D3DFORMAT@@PAW41@V?$allocator@W4_D3DFORMAT@@@std@@@std@@YAPAW4_D3DFORMAT@@PAW41@00AAV?$allocator@W4_D3DFORMAT@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__unwindtable$??$_Uninit_copy@PAW4_D3DFORMAT@@PAW41@V?$allocator@W4_D3DFORMAT@@@std@@@std@@YAPAW4_D3DFORMAT@@PAW41@00AAV?$allocator@W4_D3DFORMAT@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Uninit_copy@PAW4_D3DFORMAT@@PAW41@V?$allocator@W4_D3DFORMAT@@@std@@@std@@YAPAW4_D3DFORMAT@@PAW41@00AAV?$allocator@W4_D3DFORMAT@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_copy@PAW4_D3DFORMAT@@PAW41@V?$allocator@W4_D3DFORMAT@@@std@@@std@@YAPAW4_D3DFORMAT@@PAW41@00AAV?$allocator@W4_D3DFORMAT@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2
__ehfuncinfo$??$_Uninit_copy@PAW4_D3DFORMAT@@PAW41@V?$allocator@W4_D3DFORMAT@@@std@@@std@@YAPAW4_D3DFORMAT@@PAW41@00AAV?$allocator@W4_D3DFORMAT@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Uninit_copy@PAW4_D3DFORMAT@@PAW41@V?$allocator@W4_D3DFORMAT@@@std@@@std@@YAPAW4_D3DFORMAT@@PAW41@00AAV?$allocator@W4_D3DFORMAT@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_copy@PAW4_D3DFORMAT@@PAW41@V?$allocator@W4_D3DFORMAT@@@std@@@std@@YAPAW4_D3DFORMAT@@PAW41@00AAV?$allocator@W4_D3DFORMAT@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??$_Uninit_copy@PAW4_D3DFORMAT@@PAW41@V?$allocator@W4_D3DFORMAT@@@std@@@std@@YAPAW4_D3DFORMAT@@PAW41@00AAV?$allocator@W4_D3DFORMAT@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PAW4_D3DFORMAT@@PAW41@V?$allocator@W4_D3DFORMAT@@@std@@@std@@YAPAW4_D3DFORMAT@@PAW41@00AAV?$allocator@W4_D3DFORMAT@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<enum _D3DFORMAT *,enum _D3DFORMAT *,std::allocator<enum _D3DFORMAT> >, COMDAT

; 124  : 	{	// copy [_First, _Last) to raw _Dest, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_copy@PAW4_D3DFORMAT@@PAW41@V?$allocator@W4_D3DFORMAT@@@std@@@std@@YAPAW4_D3DFORMAT@@PAW41@00AAV?$allocator@W4_D3DFORMAT@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 125  : 	_DEBUG_RANGE(_First, _Last);
; 126  : 	_DEBUG_POINTER(_Dest);
; 127  : 	_FwdIt _Next = _Dest;

	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Next$[ebp], eax

; 128  : 
; 129  : 	_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 130  : 	for (; _First != _Last; ++_Dest, ++_First)

	jmp	SHORT $LN6@Uninit_cop
$LN5@Uninit_cop:
	mov	ecx, DWORD PTR __Dest$[ebp]
	add	ecx, 4
	mov	DWORD PTR __Dest$[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	add	edx, 4
	mov	DWORD PTR __First$[ebp], edx
$LN6@Uninit_cop:
	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Uninit_cop

; 131  : 		_Al.construct(_Dest, *_First);

	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?construct@?$allocator@W4_D3DFORMAT@@@std@@QAEXPAW4_D3DFORMAT@@ABW43@@Z ; std::allocator<enum _D3DFORMAT>::construct
	jmp	SHORT $LN5@Uninit_cop
$LN4@Uninit_cop:
	jmp	SHORT $LN10@Uninit_cop
__catch$??$_Uninit_copy@PAW4_D3DFORMAT@@PAW41@V?$allocator@W4_D3DFORMAT@@@std@@@std@@YAPAW4_D3DFORMAT@@PAW41@00AAV?$allocator@W4_D3DFORMAT@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 132  : 	_CATCH_ALL
; 133  : 	for (; _Next != _Dest; ++_Next)

	jmp	SHORT $LN3@Uninit_cop
$LN2@Uninit_cop:
	mov	eax, DWORD PTR __Next$[ebp]
	add	eax, 4
	mov	DWORD PTR __Next$[ebp], eax
$LN3@Uninit_cop:
	mov	ecx, DWORD PTR __Next$[ebp]
	cmp	ecx, DWORD PTR __Dest$[ebp]
	je	SHORT $LN1@Uninit_cop

; 134  : 		_Al.destroy(_Next);

	mov	edx, DWORD PTR __Next$[ebp]
	push	edx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?destroy@?$allocator@W4_D3DFORMAT@@@std@@QAEXPAW4_D3DFORMAT@@@Z ; std::allocator<enum _D3DFORMAT>::destroy
	jmp	SHORT $LN2@Uninit_cop
$LN1@Uninit_cop:

; 135  : 	_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 136  : 	_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$??$_Uninit_copy@PAW4_D3DFORMAT@@PAW41@V?$allocator@W4_D3DFORMAT@@@std@@@std@@YAPAW4_D3DFORMAT@@PAW41@00AAV?$allocator@W4_D3DFORMAT@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1
	ret	0
$LN10@Uninit_cop:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Uninit_copy@PAW4_D3DFORMAT@@PAW41@V?$allocator@W4_D3DFORMAT@@@std@@@std@@YAPAW4_D3DFORMAT@@PAW41@00AAV?$allocator@W4_D3DFORMAT@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1:

; 137  : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[ebp]
$LN9@Uninit_cop:

; 138  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_copy@PAW4_D3DFORMAT@@PAW41@V?$allocator@W4_D3DFORMAT@@@std@@@std@@YAPAW4_D3DFORMAT@@PAW41@00AAV?$allocator@W4_D3DFORMAT@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_copy@PAW4_D3DFORMAT@@PAW41@V?$allocator@W4_D3DFORMAT@@@std@@@std@@YAPAW4_D3DFORMAT@@PAW41@00AAV?$allocator@W4_D3DFORMAT@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_copy@PAW4_D3DFORMAT@@PAW41@V?$allocator@W4_D3DFORMAT@@@std@@@std@@YAPAW4_D3DFORMAT@@PAW41@00AAV?$allocator@W4_D3DFORMAT@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<enum _D3DFORMAT *,enum _D3DFORMAT *,std::allocator<enum _D3DFORMAT> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$_Uninit_copy@PAW4_D3DMULTISAMPLE_TYPE@@PAW41@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@YAPAW4_D3DMULTISAMPLE_TYPE@@PAW41@00AAV?$allocator@W4_D3DMULTISAMPLE_TYPE@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_copy@PAW4_D3DMULTISAMPLE_TYPE@@PAW41@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@YAPAW4_D3DMULTISAMPLE_TYPE@@PAW41@00AAV?$allocator@W4_D3DMULTISAMPLE_TYPE@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__unwindtable$??$_Uninit_copy@PAW4_D3DMULTISAMPLE_TYPE@@PAW41@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@YAPAW4_D3DMULTISAMPLE_TYPE@@PAW41@00AAV?$allocator@W4_D3DMULTISAMPLE_TYPE@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Uninit_copy@PAW4_D3DMULTISAMPLE_TYPE@@PAW41@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@YAPAW4_D3DMULTISAMPLE_TYPE@@PAW41@00AAV?$allocator@W4_D3DMULTISAMPLE_TYPE@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_copy@PAW4_D3DMULTISAMPLE_TYPE@@PAW41@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@YAPAW4_D3DMULTISAMPLE_TYPE@@PAW41@00AAV?$allocator@W4_D3DMULTISAMPLE_TYPE@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2
__ehfuncinfo$??$_Uninit_copy@PAW4_D3DMULTISAMPLE_TYPE@@PAW41@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@YAPAW4_D3DMULTISAMPLE_TYPE@@PAW41@00AAV?$allocator@W4_D3DMULTISAMPLE_TYPE@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Uninit_copy@PAW4_D3DMULTISAMPLE_TYPE@@PAW41@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@YAPAW4_D3DMULTISAMPLE_TYPE@@PAW41@00AAV?$allocator@W4_D3DMULTISAMPLE_TYPE@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_copy@PAW4_D3DMULTISAMPLE_TYPE@@PAW41@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@YAPAW4_D3DMULTISAMPLE_TYPE@@PAW41@00AAV?$allocator@W4_D3DMULTISAMPLE_TYPE@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??$_Uninit_copy@PAW4_D3DMULTISAMPLE_TYPE@@PAW41@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@YAPAW4_D3DMULTISAMPLE_TYPE@@PAW41@00AAV?$allocator@W4_D3DMULTISAMPLE_TYPE@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PAW4_D3DMULTISAMPLE_TYPE@@PAW41@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@YAPAW4_D3DMULTISAMPLE_TYPE@@PAW41@00AAV?$allocator@W4_D3DMULTISAMPLE_TYPE@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<enum _D3DMULTISAMPLE_TYPE *,enum _D3DMULTISAMPLE_TYPE *,std::allocator<enum _D3DMULTISAMPLE_TYPE> >, COMDAT

; 124  : 	{	// copy [_First, _Last) to raw _Dest, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_copy@PAW4_D3DMULTISAMPLE_TYPE@@PAW41@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@YAPAW4_D3DMULTISAMPLE_TYPE@@PAW41@00AAV?$allocator@W4_D3DMULTISAMPLE_TYPE@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 125  : 	_DEBUG_RANGE(_First, _Last);
; 126  : 	_DEBUG_POINTER(_Dest);
; 127  : 	_FwdIt _Next = _Dest;

	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Next$[ebp], eax

; 128  : 
; 129  : 	_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 130  : 	for (; _First != _Last; ++_Dest, ++_First)

	jmp	SHORT $LN6@Uninit_cop@2
$LN5@Uninit_cop@2:
	mov	ecx, DWORD PTR __Dest$[ebp]
	add	ecx, 4
	mov	DWORD PTR __Dest$[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	add	edx, 4
	mov	DWORD PTR __First$[ebp], edx
$LN6@Uninit_cop@2:
	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Uninit_cop@2

; 131  : 		_Al.construct(_Dest, *_First);

	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?construct@?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@QAEXPAW4_D3DMULTISAMPLE_TYPE@@ABW43@@Z ; std::allocator<enum _D3DMULTISAMPLE_TYPE>::construct
	jmp	SHORT $LN5@Uninit_cop@2
$LN4@Uninit_cop@2:
	jmp	SHORT $LN10@Uninit_cop@2
__catch$??$_Uninit_copy@PAW4_D3DMULTISAMPLE_TYPE@@PAW41@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@YAPAW4_D3DMULTISAMPLE_TYPE@@PAW41@00AAV?$allocator@W4_D3DMULTISAMPLE_TYPE@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 132  : 	_CATCH_ALL
; 133  : 	for (; _Next != _Dest; ++_Next)

	jmp	SHORT $LN3@Uninit_cop@2
$LN2@Uninit_cop@2:
	mov	eax, DWORD PTR __Next$[ebp]
	add	eax, 4
	mov	DWORD PTR __Next$[ebp], eax
$LN3@Uninit_cop@2:
	mov	ecx, DWORD PTR __Next$[ebp]
	cmp	ecx, DWORD PTR __Dest$[ebp]
	je	SHORT $LN1@Uninit_cop@2

; 134  : 		_Al.destroy(_Next);

	mov	edx, DWORD PTR __Next$[ebp]
	push	edx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?destroy@?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@QAEXPAW4_D3DMULTISAMPLE_TYPE@@@Z ; std::allocator<enum _D3DMULTISAMPLE_TYPE>::destroy
	jmp	SHORT $LN2@Uninit_cop@2
$LN1@Uninit_cop@2:

; 135  : 	_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 136  : 	_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$??$_Uninit_copy@PAW4_D3DMULTISAMPLE_TYPE@@PAW41@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@YAPAW4_D3DMULTISAMPLE_TYPE@@PAW41@00AAV?$allocator@W4_D3DMULTISAMPLE_TYPE@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1
	ret	0
$LN10@Uninit_cop@2:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Uninit_copy@PAW4_D3DMULTISAMPLE_TYPE@@PAW41@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@YAPAW4_D3DMULTISAMPLE_TYPE@@PAW41@00AAV?$allocator@W4_D3DMULTISAMPLE_TYPE@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1:

; 137  : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[ebp]
$LN9@Uninit_cop@2:

; 138  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_copy@PAW4_D3DMULTISAMPLE_TYPE@@PAW41@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@YAPAW4_D3DMULTISAMPLE_TYPE@@PAW41@00AAV?$allocator@W4_D3DMULTISAMPLE_TYPE@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_copy@PAW4_D3DMULTISAMPLE_TYPE@@PAW41@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@YAPAW4_D3DMULTISAMPLE_TYPE@@PAW41@00AAV?$allocator@W4_D3DMULTISAMPLE_TYPE@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_copy@PAW4_D3DMULTISAMPLE_TYPE@@PAW41@V?$allocator@W4_D3DMULTISAMPLE_TYPE@@@std@@@std@@YAPAW4_D3DMULTISAMPLE_TYPE@@PAW41@00AAV?$allocator@W4_D3DMULTISAMPLE_TYPE@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<enum _D3DMULTISAMPLE_TYPE *,enum _D3DMULTISAMPLE_TYPE *,std::allocator<enum _D3DMULTISAMPLE_TYPE> >
; Function compile flags: /Odtp
;	COMDAT ??$_Uninit_copy@PAIPAIV?$allocator@I@std@@@std@@YAPAIPAI00AAV?$allocator@I@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Result$ = -8						; size = 4
__Count$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PAIPAIV?$allocator@I@std@@@std@@YAPAIPAI00AAV?$allocator@I@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<unsigned int *,unsigned int *,std::allocator<unsigned int> >, COMDAT

; 145  : 	{	// copy [_First, _Last) to raw _Dest, scalar type

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 146  : 	_DEBUG_RANGE(_First, _Last);
; 147  : 	_DEBUG_POINTER(_Dest);
; 148  : 	size_t _Count = (size_t)(_Last - _First);

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 2
	mov	DWORD PTR __Count$[ebp], eax

; 149  : 	_FwdIt _Result = _Dest + _Count;

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Dest$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR __Result$[ebp], eax

; 150  : 	if (_Count > 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN1@Uninit_cop@3

; 151  : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Count * sizeof (*_First), &*_First, _Count * sizeof (*_First));	// NB: non-overlapping move

	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN1@Uninit_cop@3:

; 152  : 	return (_Result);

	mov	eax, DWORD PTR __Result$[ebp]

; 153  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Uninit_copy@PAIPAIV?$allocator@I@std@@@std@@YAPAIPAI00AAV?$allocator@I@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<unsigned int *,unsigned int *,std::allocator<unsigned int> >
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$_Uninit_copy@PAUD3DSMSCONFLICT_T@Ogre@@PAU12@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@YAPAUD3DSMSCONFLICT_T@Ogre@@PAU12@00AAV?$allocator@UD3DSMSCONFLICT_T@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_copy@PAUD3DSMSCONFLICT_T@Ogre@@PAU12@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@YAPAUD3DSMSCONFLICT_T@Ogre@@PAU12@00AAV?$allocator@UD3DSMSCONFLICT_T@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__unwindtable$??$_Uninit_copy@PAUD3DSMSCONFLICT_T@Ogre@@PAU12@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@YAPAUD3DSMSCONFLICT_T@Ogre@@PAU12@00AAV?$allocator@UD3DSMSCONFLICT_T@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Uninit_copy@PAUD3DSMSCONFLICT_T@Ogre@@PAU12@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@YAPAUD3DSMSCONFLICT_T@Ogre@@PAU12@00AAV?$allocator@UD3DSMSCONFLICT_T@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_copy@PAUD3DSMSCONFLICT_T@Ogre@@PAU12@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@YAPAUD3DSMSCONFLICT_T@Ogre@@PAU12@00AAV?$allocator@UD3DSMSCONFLICT_T@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2
__ehfuncinfo$??$_Uninit_copy@PAUD3DSMSCONFLICT_T@Ogre@@PAU12@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@YAPAUD3DSMSCONFLICT_T@Ogre@@PAU12@00AAV?$allocator@UD3DSMSCONFLICT_T@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Uninit_copy@PAUD3DSMSCONFLICT_T@Ogre@@PAU12@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@YAPAUD3DSMSCONFLICT_T@Ogre@@PAU12@00AAV?$allocator@UD3DSMSCONFLICT_T@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_copy@PAUD3DSMSCONFLICT_T@Ogre@@PAU12@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@YAPAUD3DSMSCONFLICT_T@Ogre@@PAU12@00AAV?$allocator@UD3DSMSCONFLICT_T@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??$_Uninit_copy@PAUD3DSMSCONFLICT_T@Ogre@@PAU12@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@YAPAUD3DSMSCONFLICT_T@Ogre@@PAU12@00AAV?$allocator@UD3DSMSCONFLICT_T@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PAUD3DSMSCONFLICT_T@Ogre@@PAU12@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@YAPAUD3DSMSCONFLICT_T@Ogre@@PAU12@00AAV?$allocator@UD3DSMSCONFLICT_T@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<Ogre::D3DSMSCONFLICT_T *,Ogre::D3DSMSCONFLICT_T *,std::allocator<Ogre::D3DSMSCONFLICT_T> >, COMDAT

; 124  : 	{	// copy [_First, _Last) to raw _Dest, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_copy@PAUD3DSMSCONFLICT_T@Ogre@@PAU12@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@YAPAUD3DSMSCONFLICT_T@Ogre@@PAU12@00AAV?$allocator@UD3DSMSCONFLICT_T@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 125  : 	_DEBUG_RANGE(_First, _Last);
; 126  : 	_DEBUG_POINTER(_Dest);
; 127  : 	_FwdIt _Next = _Dest;

	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Next$[ebp], eax

; 128  : 
; 129  : 	_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 130  : 	for (; _First != _Last; ++_Dest, ++_First)

	jmp	SHORT $LN6@Uninit_cop@4
$LN5@Uninit_cop@4:
	mov	ecx, DWORD PTR __Dest$[ebp]
	add	ecx, 8
	mov	DWORD PTR __Dest$[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	add	edx, 8
	mov	DWORD PTR __First$[ebp], edx
$LN6@Uninit_cop@4:
	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Uninit_cop@4

; 131  : 		_Al.construct(_Dest, *_First);

	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?construct@?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@QAEXPAUD3DSMSCONFLICT_T@Ogre@@ABU34@@Z ; std::allocator<Ogre::D3DSMSCONFLICT_T>::construct
	jmp	SHORT $LN5@Uninit_cop@4
$LN4@Uninit_cop@4:
	jmp	SHORT $LN10@Uninit_cop@4
__catch$??$_Uninit_copy@PAUD3DSMSCONFLICT_T@Ogre@@PAU12@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@YAPAUD3DSMSCONFLICT_T@Ogre@@PAU12@00AAV?$allocator@UD3DSMSCONFLICT_T@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 132  : 	_CATCH_ALL
; 133  : 	for (; _Next != _Dest; ++_Next)

	jmp	SHORT $LN3@Uninit_cop@4
$LN2@Uninit_cop@4:
	mov	eax, DWORD PTR __Next$[ebp]
	add	eax, 8
	mov	DWORD PTR __Next$[ebp], eax
$LN3@Uninit_cop@4:
	mov	ecx, DWORD PTR __Next$[ebp]
	cmp	ecx, DWORD PTR __Dest$[ebp]
	je	SHORT $LN1@Uninit_cop@4

; 134  : 		_Al.destroy(_Next);

	mov	edx, DWORD PTR __Next$[ebp]
	push	edx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?destroy@?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@QAEXPAUD3DSMSCONFLICT_T@Ogre@@@Z ; std::allocator<Ogre::D3DSMSCONFLICT_T>::destroy
	jmp	SHORT $LN2@Uninit_cop@4
$LN1@Uninit_cop@4:

; 135  : 	_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 136  : 	_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$??$_Uninit_copy@PAUD3DSMSCONFLICT_T@Ogre@@PAU12@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@YAPAUD3DSMSCONFLICT_T@Ogre@@PAU12@00AAV?$allocator@UD3DSMSCONFLICT_T@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1
	ret	0
$LN10@Uninit_cop@4:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Uninit_copy@PAUD3DSMSCONFLICT_T@Ogre@@PAU12@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@YAPAUD3DSMSCONFLICT_T@Ogre@@PAU12@00AAV?$allocator@UD3DSMSCONFLICT_T@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1:

; 137  : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[ebp]
$LN9@Uninit_cop@4:

; 138  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_copy@PAUD3DSMSCONFLICT_T@Ogre@@PAU12@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@YAPAUD3DSMSCONFLICT_T@Ogre@@PAU12@00AAV?$allocator@UD3DSMSCONFLICT_T@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_copy@PAUD3DSMSCONFLICT_T@Ogre@@PAU12@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@YAPAUD3DSMSCONFLICT_T@Ogre@@PAU12@00AAV?$allocator@UD3DSMSCONFLICT_T@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_copy@PAUD3DSMSCONFLICT_T@Ogre@@PAU12@V?$allocator@UD3DSMSCONFLICT_T@Ogre@@@std@@@std@@YAPAUD3DSMSCONFLICT_T@Ogre@@PAU12@00AAV?$allocator@UD3DSMSCONFLICT_T@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<Ogre::D3DSMSCONFLICT_T *,Ogre::D3DSMSCONFLICT_T *,std::allocator<Ogre::D3DSMSCONFLICT_T> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$_Uninit_copy@PAW4VERTPROCESS_T@Ogre@@PAW412@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@YAPAW4VERTPROCESS_T@Ogre@@PAW412@00AAV?$allocator@W4VERTPROCESS_T@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_copy@PAW4VERTPROCESS_T@Ogre@@PAW412@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@YAPAW4VERTPROCESS_T@Ogre@@PAW412@00AAV?$allocator@W4VERTPROCESS_T@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__unwindtable$??$_Uninit_copy@PAW4VERTPROCESS_T@Ogre@@PAW412@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@YAPAW4VERTPROCESS_T@Ogre@@PAW412@00AAV?$allocator@W4VERTPROCESS_T@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Uninit_copy@PAW4VERTPROCESS_T@Ogre@@PAW412@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@YAPAW4VERTPROCESS_T@Ogre@@PAW412@00AAV?$allocator@W4VERTPROCESS_T@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_copy@PAW4VERTPROCESS_T@Ogre@@PAW412@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@YAPAW4VERTPROCESS_T@Ogre@@PAW412@00AAV?$allocator@W4VERTPROCESS_T@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2
__ehfuncinfo$??$_Uninit_copy@PAW4VERTPROCESS_T@Ogre@@PAW412@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@YAPAW4VERTPROCESS_T@Ogre@@PAW412@00AAV?$allocator@W4VERTPROCESS_T@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Uninit_copy@PAW4VERTPROCESS_T@Ogre@@PAW412@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@YAPAW4VERTPROCESS_T@Ogre@@PAW412@00AAV?$allocator@W4VERTPROCESS_T@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_copy@PAW4VERTPROCESS_T@Ogre@@PAW412@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@YAPAW4VERTPROCESS_T@Ogre@@PAW412@00AAV?$allocator@W4VERTPROCESS_T@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??$_Uninit_copy@PAW4VERTPROCESS_T@Ogre@@PAW412@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@YAPAW4VERTPROCESS_T@Ogre@@PAW412@00AAV?$allocator@W4VERTPROCESS_T@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PAW4VERTPROCESS_T@Ogre@@PAW412@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@YAPAW4VERTPROCESS_T@Ogre@@PAW412@00AAV?$allocator@W4VERTPROCESS_T@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<enum Ogre::VERTPROCESS_T *,enum Ogre::VERTPROCESS_T *,std::allocator<enum Ogre::VERTPROCESS_T> >, COMDAT

; 124  : 	{	// copy [_First, _Last) to raw _Dest, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_copy@PAW4VERTPROCESS_T@Ogre@@PAW412@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@YAPAW4VERTPROCESS_T@Ogre@@PAW412@00AAV?$allocator@W4VERTPROCESS_T@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 125  : 	_DEBUG_RANGE(_First, _Last);
; 126  : 	_DEBUG_POINTER(_Dest);
; 127  : 	_FwdIt _Next = _Dest;

	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Next$[ebp], eax

; 128  : 
; 129  : 	_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 130  : 	for (; _First != _Last; ++_Dest, ++_First)

	jmp	SHORT $LN6@Uninit_cop@5
$LN5@Uninit_cop@5:
	mov	ecx, DWORD PTR __Dest$[ebp]
	add	ecx, 4
	mov	DWORD PTR __Dest$[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	add	edx, 4
	mov	DWORD PTR __First$[ebp], edx
$LN6@Uninit_cop@5:
	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Uninit_cop@5

; 131  : 		_Al.construct(_Dest, *_First);

	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?construct@?$allocator@W4VERTPROCESS_T@Ogre@@@std@@QAEXPAW4VERTPROCESS_T@Ogre@@ABW434@@Z ; std::allocator<enum Ogre::VERTPROCESS_T>::construct
	jmp	SHORT $LN5@Uninit_cop@5
$LN4@Uninit_cop@5:
	jmp	SHORT $LN10@Uninit_cop@5
__catch$??$_Uninit_copy@PAW4VERTPROCESS_T@Ogre@@PAW412@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@YAPAW4VERTPROCESS_T@Ogre@@PAW412@00AAV?$allocator@W4VERTPROCESS_T@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 132  : 	_CATCH_ALL
; 133  : 	for (; _Next != _Dest; ++_Next)

	jmp	SHORT $LN3@Uninit_cop@5
$LN2@Uninit_cop@5:
	mov	eax, DWORD PTR __Next$[ebp]
	add	eax, 4
	mov	DWORD PTR __Next$[ebp], eax
$LN3@Uninit_cop@5:
	mov	ecx, DWORD PTR __Next$[ebp]
	cmp	ecx, DWORD PTR __Dest$[ebp]
	je	SHORT $LN1@Uninit_cop@5

; 134  : 		_Al.destroy(_Next);

	mov	edx, DWORD PTR __Next$[ebp]
	push	edx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?destroy@?$allocator@W4VERTPROCESS_T@Ogre@@@std@@QAEXPAW4VERTPROCESS_T@Ogre@@@Z ; std::allocator<enum Ogre::VERTPROCESS_T>::destroy
	jmp	SHORT $LN2@Uninit_cop@5
$LN1@Uninit_cop@5:

; 135  : 	_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 136  : 	_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$??$_Uninit_copy@PAW4VERTPROCESS_T@Ogre@@PAW412@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@YAPAW4VERTPROCESS_T@Ogre@@PAW412@00AAV?$allocator@W4VERTPROCESS_T@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1
	ret	0
$LN10@Uninit_cop@5:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Uninit_copy@PAW4VERTPROCESS_T@Ogre@@PAW412@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@YAPAW4VERTPROCESS_T@Ogre@@PAW412@00AAV?$allocator@W4VERTPROCESS_T@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1:

; 137  : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[ebp]
$LN9@Uninit_cop@5:

; 138  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_copy@PAW4VERTPROCESS_T@Ogre@@PAW412@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@YAPAW4VERTPROCESS_T@Ogre@@PAW412@00AAV?$allocator@W4VERTPROCESS_T@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_copy@PAW4VERTPROCESS_T@Ogre@@PAW412@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@YAPAW4VERTPROCESS_T@Ogre@@PAW412@00AAV?$allocator@W4VERTPROCESS_T@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_copy@PAW4VERTPROCESS_T@Ogre@@PAW412@V?$allocator@W4VERTPROCESS_T@Ogre@@@std@@@std@@YAPAW4VERTPROCESS_T@Ogre@@PAW412@00AAV?$allocator@W4VERTPROCESS_T@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<enum Ogre::VERTPROCESS_T *,enum Ogre::VERTPROCESS_T *,std::allocator<enum Ogre::VERTPROCESS_T> >
; Function compile flags: /Odtp
;	COMDAT ??$_Uninit_copy@PAPAUD3DDEVCOMBO_T@Ogre@@PAPAU12@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@YAPAPAUD3DDEVCOMBO_T@Ogre@@PAPAU12@00AAV?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Result$ = -8						; size = 4
__Count$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PAPAUD3DDEVCOMBO_T@Ogre@@PAPAU12@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@YAPAPAUD3DDEVCOMBO_T@Ogre@@PAPAU12@00AAV?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<Ogre::D3DDEVCOMBO_T * *,Ogre::D3DDEVCOMBO_T * *,std::allocator<Ogre::D3DDEVCOMBO_T *> >, COMDAT

; 145  : 	{	// copy [_First, _Last) to raw _Dest, scalar type

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 146  : 	_DEBUG_RANGE(_First, _Last);
; 147  : 	_DEBUG_POINTER(_Dest);
; 148  : 	size_t _Count = (size_t)(_Last - _First);

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 2
	mov	DWORD PTR __Count$[ebp], eax

; 149  : 	_FwdIt _Result = _Dest + _Count;

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Dest$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR __Result$[ebp], eax

; 150  : 	if (_Count > 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN1@Uninit_cop@6

; 151  : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Count * sizeof (*_First), &*_First, _Count * sizeof (*_First));	// NB: non-overlapping move

	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN1@Uninit_cop@6:

; 152  : 	return (_Result);

	mov	eax, DWORD PTR __Result$[ebp]

; 153  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Uninit_copy@PAPAUD3DDEVCOMBO_T@Ogre@@PAPAU12@V?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@std@@@std@@YAPAPAUD3DDEVCOMBO_T@Ogre@@PAPAU12@00AAV?$allocator@PAUD3DDEVCOMBO_T@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<Ogre::D3DDEVCOMBO_T * *,Ogre::D3DDEVCOMBO_T * *,std::allocator<Ogre::D3DDEVCOMBO_T *> >
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$_Uninit_copy@PAU_D3DDISPLAYMODE@@PAU1@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@YAPAU_D3DDISPLAYMODE@@PAU1@00AAV?$allocator@U_D3DDISPLAYMODE@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_copy@PAU_D3DDISPLAYMODE@@PAU1@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@YAPAU_D3DDISPLAYMODE@@PAU1@00AAV?$allocator@U_D3DDISPLAYMODE@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__unwindtable$??$_Uninit_copy@PAU_D3DDISPLAYMODE@@PAU1@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@YAPAU_D3DDISPLAYMODE@@PAU1@00AAV?$allocator@U_D3DDISPLAYMODE@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Uninit_copy@PAU_D3DDISPLAYMODE@@PAU1@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@YAPAU_D3DDISPLAYMODE@@PAU1@00AAV?$allocator@U_D3DDISPLAYMODE@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_copy@PAU_D3DDISPLAYMODE@@PAU1@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@YAPAU_D3DDISPLAYMODE@@PAU1@00AAV?$allocator@U_D3DDISPLAYMODE@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2
__ehfuncinfo$??$_Uninit_copy@PAU_D3DDISPLAYMODE@@PAU1@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@YAPAU_D3DDISPLAYMODE@@PAU1@00AAV?$allocator@U_D3DDISPLAYMODE@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Uninit_copy@PAU_D3DDISPLAYMODE@@PAU1@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@YAPAU_D3DDISPLAYMODE@@PAU1@00AAV?$allocator@U_D3DDISPLAYMODE@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_copy@PAU_D3DDISPLAYMODE@@PAU1@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@YAPAU_D3DDISPLAYMODE@@PAU1@00AAV?$allocator@U_D3DDISPLAYMODE@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??$_Uninit_copy@PAU_D3DDISPLAYMODE@@PAU1@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@YAPAU_D3DDISPLAYMODE@@PAU1@00AAV?$allocator@U_D3DDISPLAYMODE@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PAU_D3DDISPLAYMODE@@PAU1@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@YAPAU_D3DDISPLAYMODE@@PAU1@00AAV?$allocator@U_D3DDISPLAYMODE@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<_D3DDISPLAYMODE *,_D3DDISPLAYMODE *,std::allocator<_D3DDISPLAYMODE> >, COMDAT

; 124  : 	{	// copy [_First, _Last) to raw _Dest, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_copy@PAU_D3DDISPLAYMODE@@PAU1@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@YAPAU_D3DDISPLAYMODE@@PAU1@00AAV?$allocator@U_D3DDISPLAYMODE@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 125  : 	_DEBUG_RANGE(_First, _Last);
; 126  : 	_DEBUG_POINTER(_Dest);
; 127  : 	_FwdIt _Next = _Dest;

	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Next$[ebp], eax

; 128  : 
; 129  : 	_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 130  : 	for (; _First != _Last; ++_Dest, ++_First)

	jmp	SHORT $LN6@Uninit_cop@7
$LN5@Uninit_cop@7:
	mov	ecx, DWORD PTR __Dest$[ebp]
	add	ecx, 16					; 00000010H
	mov	DWORD PTR __Dest$[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	add	edx, 16					; 00000010H
	mov	DWORD PTR __First$[ebp], edx
$LN6@Uninit_cop@7:
	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Uninit_cop@7

; 131  : 		_Al.construct(_Dest, *_First);

	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?construct@?$allocator@U_D3DDISPLAYMODE@@@std@@QAEXPAU_D3DDISPLAYMODE@@ABU3@@Z ; std::allocator<_D3DDISPLAYMODE>::construct
	jmp	SHORT $LN5@Uninit_cop@7
$LN4@Uninit_cop@7:
	jmp	SHORT $LN10@Uninit_cop@7
__catch$??$_Uninit_copy@PAU_D3DDISPLAYMODE@@PAU1@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@YAPAU_D3DDISPLAYMODE@@PAU1@00AAV?$allocator@U_D3DDISPLAYMODE@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 132  : 	_CATCH_ALL
; 133  : 	for (; _Next != _Dest; ++_Next)

	jmp	SHORT $LN3@Uninit_cop@7
$LN2@Uninit_cop@7:
	mov	eax, DWORD PTR __Next$[ebp]
	add	eax, 16					; 00000010H
	mov	DWORD PTR __Next$[ebp], eax
$LN3@Uninit_cop@7:
	mov	ecx, DWORD PTR __Next$[ebp]
	cmp	ecx, DWORD PTR __Dest$[ebp]
	je	SHORT $LN1@Uninit_cop@7

; 134  : 		_Al.destroy(_Next);

	mov	edx, DWORD PTR __Next$[ebp]
	push	edx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?destroy@?$allocator@U_D3DDISPLAYMODE@@@std@@QAEXPAU_D3DDISPLAYMODE@@@Z ; std::allocator<_D3DDISPLAYMODE>::destroy
	jmp	SHORT $LN2@Uninit_cop@7
$LN1@Uninit_cop@7:

; 135  : 	_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 136  : 	_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$??$_Uninit_copy@PAU_D3DDISPLAYMODE@@PAU1@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@YAPAU_D3DDISPLAYMODE@@PAU1@00AAV?$allocator@U_D3DDISPLAYMODE@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1
	ret	0
$LN10@Uninit_cop@7:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Uninit_copy@PAU_D3DDISPLAYMODE@@PAU1@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@YAPAU_D3DDISPLAYMODE@@PAU1@00AAV?$allocator@U_D3DDISPLAYMODE@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1:

; 137  : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[ebp]
$LN9@Uninit_cop@7:

; 138  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_copy@PAU_D3DDISPLAYMODE@@PAU1@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@YAPAU_D3DDISPLAYMODE@@PAU1@00AAV?$allocator@U_D3DDISPLAYMODE@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_copy@PAU_D3DDISPLAYMODE@@PAU1@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@YAPAU_D3DDISPLAYMODE@@PAU1@00AAV?$allocator@U_D3DDISPLAYMODE@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_copy@PAU_D3DDISPLAYMODE@@PAU1@V?$allocator@U_D3DDISPLAYMODE@@@std@@@std@@YAPAU_D3DDISPLAYMODE@@PAU1@00AAV?$allocator@U_D3DDISPLAYMODE@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<_D3DDISPLAYMODE *,_D3DDISPLAYMODE *,std::allocator<_D3DDISPLAYMODE> >
; Function compile flags: /Odtp
;	COMDAT ??$_Uninit_copy@PAPAUD3DDEVICEINFO_T@Ogre@@PAPAU12@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@YAPAPAUD3DDEVICEINFO_T@Ogre@@PAPAU12@00AAV?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Result$ = -8						; size = 4
__Count$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PAPAUD3DDEVICEINFO_T@Ogre@@PAPAU12@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@YAPAPAUD3DDEVICEINFO_T@Ogre@@PAPAU12@00AAV?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<Ogre::D3DDEVICEINFO_T * *,Ogre::D3DDEVICEINFO_T * *,std::allocator<Ogre::D3DDEVICEINFO_T *> >, COMDAT

; 145  : 	{	// copy [_First, _Last) to raw _Dest, scalar type

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 146  : 	_DEBUG_RANGE(_First, _Last);
; 147  : 	_DEBUG_POINTER(_Dest);
; 148  : 	size_t _Count = (size_t)(_Last - _First);

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 2
	mov	DWORD PTR __Count$[ebp], eax

; 149  : 	_FwdIt _Result = _Dest + _Count;

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Dest$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR __Result$[ebp], eax

; 150  : 	if (_Count > 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN1@Uninit_cop@8

; 151  : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Count * sizeof (*_First), &*_First, _Count * sizeof (*_First));	// NB: non-overlapping move

	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN1@Uninit_cop@8:

; 152  : 	return (_Result);

	mov	eax, DWORD PTR __Result$[ebp]

; 153  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Uninit_copy@PAPAUD3DDEVICEINFO_T@Ogre@@PAPAU12@V?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@std@@@std@@YAPAPAUD3DDEVICEINFO_T@Ogre@@PAPAU12@00AAV?$allocator@PAUD3DDEVICEINFO_T@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<Ogre::D3DDEVICEINFO_T * *,Ogre::D3DDEVICEINFO_T * *,std::allocator<Ogre::D3DDEVICEINFO_T *> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@PAPAUD3DADAPTER_T@Ogre@@PAPAU12@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@YAPAPAUD3DADAPTER_T@Ogre@@PAPAU12@00AAV?$allocator@PAUD3DADAPTER_T@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Result$ = -8						; size = 4
__Count$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PAPAUD3DADAPTER_T@Ogre@@PAPAU12@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@YAPAPAUD3DADAPTER_T@Ogre@@PAPAU12@00AAV?$allocator@PAUD3DADAPTER_T@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<Ogre::D3DADAPTER_T * *,Ogre::D3DADAPTER_T * *,std::allocator<Ogre::D3DADAPTER_T *> >, COMDAT

; 145  : 	{	// copy [_First, _Last) to raw _Dest, scalar type

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 146  : 	_DEBUG_RANGE(_First, _Last);
; 147  : 	_DEBUG_POINTER(_Dest);
; 148  : 	size_t _Count = (size_t)(_Last - _First);

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 2
	mov	DWORD PTR __Count$[ebp], eax

; 149  : 	_FwdIt _Result = _Dest + _Count;

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Dest$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR __Result$[ebp], eax

; 150  : 	if (_Count > 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN1@Uninit_cop@9

; 151  : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Count * sizeof (*_First), &*_First, _Count * sizeof (*_First));	// NB: non-overlapping move

	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN1@Uninit_cop@9:

; 152  : 	return (_Result);

	mov	eax, DWORD PTR __Result$[ebp]

; 153  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Uninit_copy@PAPAUD3DADAPTER_T@Ogre@@PAPAU12@V?$allocator@PAUD3DADAPTER_T@Ogre@@@std@@@std@@YAPAPAUD3DADAPTER_T@Ogre@@PAPAU12@00AAV?$allocator@PAUD3DADAPTER_T@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<Ogre::D3DADAPTER_T * *,Ogre::D3DADAPTER_T * *,std::allocator<Ogre::D3DADAPTER_T *> >
_TEXT	ENDS
END

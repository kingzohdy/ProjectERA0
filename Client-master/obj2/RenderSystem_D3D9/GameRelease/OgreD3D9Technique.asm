; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	i:\svnroot\client\Plugins\RenderSystem_D3D9\OgreD3D9Technique.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	?_Value@?$_Is_swap_move@U_Swap_move_tag@std@@@std@@2_NB ; std::_Is_swap_move<std::_Swap_move_tag>::_Value
PUBLIC	?collate@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::collate
PUBLIC	?ctype@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::ctype
PUBLIC	?monetary@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::monetary
PUBLIC	?numeric@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::numeric
PUBLIC	?time@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::time
PUBLIC	?messages@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::messages
PUBLIC	?all@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::all
PUBLIC	?none@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::none
PUBLIC	?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::skipws
PUBLIC	?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::unitbuf
PUBLIC	?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::uppercase
PUBLIC	?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showbase
PUBLIC	?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpoint
PUBLIC	?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpos
PUBLIC	?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::left
PUBLIC	?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::right
PUBLIC	?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::internal
PUBLIC	?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::dec
PUBLIC	?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::oct
PUBLIC	?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::hex
PUBLIC	?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::scientific
PUBLIC	?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::fixed
PUBLIC	?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::hexfloat
PUBLIC	?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::boolalpha
PUBLIC	?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::_Stdio
PUBLIC	?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::adjustfield
PUBLIC	?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::basefield
PUBLIC	?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::floatfield
PUBLIC	?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::goodbit
PUBLIC	?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::eofbit
PUBLIC	?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::failbit
PUBLIC	?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::badbit
PUBLIC	?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::_Hardfail
PUBLIC	?in@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::in
PUBLIC	?out@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::out
PUBLIC	?ate@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::ate
PUBLIC	?app@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::app
PUBLIC	?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::trunc
PUBLIC	?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Nocreate
PUBLIC	?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Noreplace
PUBLIC	?binary@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::binary
PUBLIC	?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::beg
PUBLIC	?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::cur
PUBLIC	?end@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::end
PUBLIC	?value@?$integral_constant@_N$0A@@tr1@std@@2_NB	; std::tr1::integral_constant<bool,0>::value
PUBLIC	?value@?$integral_constant@_N$00@tr1@std@@2_NB	; std::tr1::integral_constant<bool,1>::value
PUBLIC	?m_pDevice@D3DTech@Ogre@@2PAUIDirect3DDevice9@@A ; Ogre::D3DTech::m_pDevice
PUBLIC	?m_pEffect@D3DTech@Ogre@@2PAUID3DXEffect@@A	; Ogre::D3DTech::m_pEffect
PUBLIC	?ms_pCurVS@D3DTech@Ogre@@2PAUIDirect3DVertexShader9@@A ; Ogre::D3DTech::ms_pCurVS
PUBLIC	?ms_pCurPS@D3DTech@Ogre@@2PAUIDirect3DPixelShader9@@A ; Ogre::D3DTech::ms_pCurPS
_BSS	SEGMENT
?m_pDevice@D3DTech@Ogre@@2PAUIDirect3DDevice9@@A DD 01H DUP (?) ; Ogre::D3DTech::m_pDevice
?m_pEffect@D3DTech@Ogre@@2PAUID3DXEffect@@A DD 01H DUP (?) ; Ogre::D3DTech::m_pEffect
?ms_pCurVS@D3DTech@Ogre@@2PAUIDirect3DVertexShader9@@A DD 01H DUP (?) ; Ogre::D3DTech::ms_pCurVS
?ms_pCurPS@D3DTech@Ogre@@2PAUIDirect3DPixelShader9@@A DD 01H DUP (?) ; Ogre::D3DTech::ms_pCurPS
_BSS	ENDS
;	COMDAT ?value@?$integral_constant@_N$00@tr1@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$00@tr1@std@@2_NB DB 01H	; std::tr1::integral_constant<bool,1>::value
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$0A@@tr1@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$0A@@tr1@std@@2_NB DB 00H	; std::tr1::integral_constant<bool,0>::value
CONST	ENDS
;	COMDAT ?end@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?end@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 02H		; std::_Iosb<int>::end
CONST	ENDS
;	COMDAT ?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 01H		; std::_Iosb<int>::cur
CONST	ENDS
;	COMDAT ?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 00H		; std::_Iosb<int>::beg
CONST	ENDS
;	COMDAT ?binary@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?binary@?$_Iosb@H@std@@2W4_Openmode@12@B DD 020H	; std::_Iosb<int>::binary
CONST	ENDS
;	COMDAT ?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B DD 080H	; std::_Iosb<int>::_Noreplace
CONST	ENDS
;	COMDAT ?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 040H	; std::_Iosb<int>::_Nocreate
CONST	ENDS
;	COMDAT ?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B DD 010H		; std::_Iosb<int>::trunc
CONST	ENDS
;	COMDAT ?app@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?app@?$_Iosb@H@std@@2W4_Openmode@12@B DD 08H		; std::_Iosb<int>::app
CONST	ENDS
;	COMDAT ?ate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?ate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 04H		; std::_Iosb<int>::ate
CONST	ENDS
;	COMDAT ?out@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?out@?$_Iosb@H@std@@2W4_Openmode@12@B DD 02H		; std::_Iosb<int>::out
CONST	ENDS
;	COMDAT ?in@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?in@?$_Iosb@H@std@@2W4_Openmode@12@B DD 01H		; std::_Iosb<int>::in
CONST	ENDS
;	COMDAT ?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B DD 010H	; std::_Iosb<int>::_Hardfail
CONST	ENDS
;	COMDAT ?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 04H		; std::_Iosb<int>::badbit
CONST	ENDS
;	COMDAT ?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 02H		; std::_Iosb<int>::failbit
CONST	ENDS
;	COMDAT ?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 01H		; std::_Iosb<int>::eofbit
CONST	ENDS
;	COMDAT ?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 00H		; std::_Iosb<int>::goodbit
CONST	ENDS
;	COMDAT ?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 03000H	; std::_Iosb<int>::floatfield
CONST	ENDS
;	COMDAT ?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0e00H	; std::_Iosb<int>::basefield
CONST	ENDS
;	COMDAT ?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01c0H	; std::_Iosb<int>::adjustfield
CONST	ENDS
;	COMDAT ?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08000H	; std::_Iosb<int>::_Stdio
CONST	ENDS
;	COMDAT ?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04000H	; std::_Iosb<int>::boolalpha
CONST	ENDS
;	COMDAT ?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 03000H	; std::_Iosb<int>::hexfloat
CONST	ENDS
;	COMDAT ?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02000H	; std::_Iosb<int>::fixed
CONST	ENDS
;	COMDAT ?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01000H	; std::_Iosb<int>::scientific
CONST	ENDS
;	COMDAT ?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0800H		; std::_Iosb<int>::hex
CONST	ENDS
;	COMDAT ?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0400H		; std::_Iosb<int>::oct
CONST	ENDS
;	COMDAT ?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0200H		; std::_Iosb<int>::dec
CONST	ENDS
;	COMDAT ?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0100H	; std::_Iosb<int>::internal
CONST	ENDS
;	COMDAT ?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 080H		; std::_Iosb<int>::right
CONST	ENDS
;	COMDAT ?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 040H		; std::_Iosb<int>::left
CONST	ENDS
;	COMDAT ?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 020H	; std::_Iosb<int>::showpos
CONST	ENDS
;	COMDAT ?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 010H	; std::_Iosb<int>::showpoint
CONST	ENDS
;	COMDAT ?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08H	; std::_Iosb<int>::showbase
CONST	ENDS
;	COMDAT ?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04H	; std::_Iosb<int>::uppercase
CONST	ENDS
;	COMDAT ?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02H	; std::_Iosb<int>::unitbuf
CONST	ENDS
;	COMDAT ?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01H		; std::_Iosb<int>::skipws
CONST	ENDS
;	COMDAT ?none@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?none@?$_Locbase@H@std@@2HB DD 00H			; std::_Locbase<int>::none
CONST	ENDS
;	COMDAT ?all@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?all@?$_Locbase@H@std@@2HB DD 03fH			; std::_Locbase<int>::all
CONST	ENDS
;	COMDAT ?messages@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?messages@?$_Locbase@H@std@@2HB DD 020H			; std::_Locbase<int>::messages
CONST	ENDS
;	COMDAT ?time@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?time@?$_Locbase@H@std@@2HB DD 010H			; std::_Locbase<int>::time
CONST	ENDS
;	COMDAT ?numeric@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?numeric@?$_Locbase@H@std@@2HB DD 08H			; std::_Locbase<int>::numeric
CONST	ENDS
;	COMDAT ?monetary@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?monetary@?$_Locbase@H@std@@2HB DD 04H			; std::_Locbase<int>::monetary
CONST	ENDS
;	COMDAT ?ctype@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?ctype@?$_Locbase@H@std@@2HB DD 02H			; std::_Locbase<int>::ctype
CONST	ENDS
;	COMDAT ?collate@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?collate@?$_Locbase@H@std@@2HB DD 01H			; std::_Locbase<int>::collate
CONST	ENDS
;	COMDAT ?_Value@?$_Is_swap_move@U_Swap_move_tag@std@@@std@@2_NB
CONST	SEGMENT
?_Value@?$_Is_swap_move@U_Swap_move_tag@std@@@std@@2_NB DB 01H ; std::_Is_swap_move<std::_Swap_move_tag>::_Value
CONST	ENDS
_DATA	SEGMENT
__bad_alloc_Message DD FLAT:$SG5714
_DATA	ENDS
CONST	SEGMENT
$SG5714	DB	'bad allocation', 00H
	ORG $+1
_MAX_FLOAT DD	07f7fffffr			; 3.40282e+038
_ONE_PI	DD	040490fd0r			; 3.14159
_EPSILON DD	03727c5acr			; 1e-005
_RADS_PER_DEG DD 03c8efa35r			; 0.0174533
_DEGS_PER_RAD DD 042652ee1r			; 57.2958
CONST	ENDS
PUBLIC	??1ShaderTechnique@Ogre@@MAE@XZ			; Ogre::ShaderTechnique::~ShaderTechnique
PUBLIC	??_7D3DTech@Ogre@@6B@				; Ogre::D3DTech::`vftable'
PUBLIC	??0ShaderTechnique@Ogre@@QAE@XZ			; Ogre::ShaderTechnique::ShaderTechnique
PUBLIC	??0D3DTech@Ogre@@QAE@XZ				; Ogre::D3DTech::D3DTech
PUBLIC	??_R4D3DTech@Ogre@@6B@				; Ogre::D3DTech::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVD3DTech@Ogre@@@8			; Ogre::D3DTech `RTTI Type Descriptor'
PUBLIC	??_R3D3DTech@Ogre@@8				; Ogre::D3DTech::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2D3DTech@Ogre@@8				; Ogre::D3DTech::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@D3DTech@Ogre@@8			; Ogre::D3DTech::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@ShaderTechnique@Ogre@@8		; Ogre::ShaderTechnique::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVShaderTechnique@Ogre@@@8		; Ogre::ShaderTechnique `RTTI Type Descriptor'
PUBLIC	??_R3ShaderTechnique@Ogre@@8			; Ogre::ShaderTechnique::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2ShaderTechnique@Ogre@@8			; Ogre::ShaderTechnique::`RTTI Base Class Array'
PUBLIC	?begin@D3DTech@Ogre@@UAEIXZ			; Ogre::D3DTech::begin
PUBLIC	?end@D3DTech@Ogre@@UAEXXZ			; Ogre::D3DTech::end
PUBLIC	?setConstant@D3DTech@Ogre@@UAEXW4ShaderParamUsage@2@PBXI@Z ; Ogre::D3DTech::setConstant
PUBLIC	?setConstant@D3DTech@Ogre@@UAEXPBDPBXI@Z	; Ogre::D3DTech::setConstant
PUBLIC	?setTexture@D3DTech@Ogre@@UAEXW4ShaderParamUsage@2@PAVHardwarePixelBuffer@2@@Z ; Ogre::D3DTech::setTexture
PUBLIC	?setTexture@D3DTech@Ogre@@UAEXPBDPAVHardwarePixelBuffer@2@@Z ; Ogre::D3DTech::setTexture
PUBLIC	?setStreamInput@D3DTech@Ogre@@UAEXIPAPAVHardwareVertexBuffer@2@HPAI@Z ; Ogre::D3DTech::setStreamInput
PUBLIC	?setStreamInput@D3DTech@Ogre@@UAEXIPAVHardwareVertexBuffer@2@I@Z ; Ogre::D3DTech::setStreamInput
PUBLIC	?setStreamInput@D3DTech@Ogre@@UAEXIPAPAVHardwareVertexBuffer@2@PAI@Z ; Ogre::D3DTech::setStreamInput
PUBLIC	?commitChanges@D3DTech@Ogre@@UAEXXZ		; Ogre::D3DTech::commitChanges
PUBLIC	?draw@D3DTech@Ogre@@UAEXW4PrimitiveType@2@IIPAVHardwareIndexBuffer@2@II@Z ; Ogre::D3DTech::draw
PUBLIC	?draw@D3DTech@Ogre@@UAEXW4PrimitiveType@2@II@Z	; Ogre::D3DTech::draw
PUBLIC	?getRequiredParams@D3DTech@Ogre@@UAEIPAW4ShaderParamUsage@2@I@Z ; Ogre::D3DTech::getRequiredParams
EXTRN	_memset:PROC
EXTRN	___security_cookie:DWORD
EXTRN	___CxxFrameHandler3:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	__purecall:PROC
EXTRN	??_ED3DTech@Ogre@@UAEPAXI@Z:PROC		; Ogre::D3DTech::`vector deleting destructor'
;	COMDAT ??_R2ShaderTechnique@Ogre@@8
; File i:\svnroot\client\plugins\rendersystem_d3d9\ogred3d9technique.cpp
rdata$r	SEGMENT
??_R2ShaderTechnique@Ogre@@8 DD FLAT:??_R1A@?0A@EA@ShaderTechnique@Ogre@@8 ; Ogre::ShaderTechnique::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3ShaderTechnique@Ogre@@8
rdata$r	SEGMENT
??_R3ShaderTechnique@Ogre@@8 DD 00H			; Ogre::ShaderTechnique::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2ShaderTechnique@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVShaderTechnique@Ogre@@@8
_DATA	SEGMENT
??_R0?AVShaderTechnique@Ogre@@@8 DD FLAT:??_7type_info@@6B@ ; Ogre::ShaderTechnique `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVShaderTechnique@Ogre@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@ShaderTechnique@Ogre@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@ShaderTechnique@Ogre@@8 DD FLAT:??_R0?AVShaderTechnique@Ogre@@@8 ; Ogre::ShaderTechnique::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3ShaderTechnique@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@D3DTech@Ogre@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@D3DTech@Ogre@@8 DD FLAT:??_R0?AVD3DTech@Ogre@@@8 ; Ogre::D3DTech::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3D3DTech@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R2D3DTech@Ogre@@8
rdata$r	SEGMENT
??_R2D3DTech@Ogre@@8 DD FLAT:??_R1A@?0A@EA@D3DTech@Ogre@@8 ; Ogre::D3DTech::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@ShaderTechnique@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R3D3DTech@Ogre@@8
rdata$r	SEGMENT
??_R3D3DTech@Ogre@@8 DD 00H				; Ogre::D3DTech::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2D3DTech@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVD3DTech@Ogre@@@8
_DATA	SEGMENT
??_R0?AVD3DTech@Ogre@@@8 DD FLAT:??_7type_info@@6B@	; Ogre::D3DTech `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVD3DTech@Ogre@@', 00H
_DATA	ENDS
;	COMDAT ??_R4D3DTech@Ogre@@6B@
rdata$r	SEGMENT
??_R4D3DTech@Ogre@@6B@ DD 00H				; Ogre::D3DTech::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVD3DTech@Ogre@@@8
	DD	FLAT:??_R3D3DTech@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_7D3DTech@Ogre@@6B@
CONST	SEGMENT
??_7D3DTech@Ogre@@6B@ DD FLAT:??_R4D3DTech@Ogre@@6B@	; Ogre::D3DTech::`vftable'
	DD	FLAT:?begin@D3DTech@Ogre@@UAEIXZ
	DD	FLAT:?end@D3DTech@Ogre@@UAEXXZ
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:?setConstant@D3DTech@Ogre@@UAEXW4ShaderParamUsage@2@PBXI@Z
	DD	FLAT:?setConstant@D3DTech@Ogre@@UAEXPBDPBXI@Z
	DD	FLAT:?setTexture@D3DTech@Ogre@@UAEXW4ShaderParamUsage@2@PAVHardwarePixelBuffer@2@@Z
	DD	FLAT:?setTexture@D3DTech@Ogre@@UAEXPBDPAVHardwarePixelBuffer@2@@Z
	DD	FLAT:?setStreamInput@D3DTech@Ogre@@UAEXIPAPAVHardwareVertexBuffer@2@HPAI@Z
	DD	FLAT:?setStreamInput@D3DTech@Ogre@@UAEXIPAVHardwareVertexBuffer@2@I@Z
	DD	FLAT:?setStreamInput@D3DTech@Ogre@@UAEXIPAPAVHardwareVertexBuffer@2@PAI@Z
	DD	FLAT:?commitChanges@D3DTech@Ogre@@UAEXXZ
	DD	FLAT:?draw@D3DTech@Ogre@@UAEXW4PrimitiveType@2@IIPAVHardwareIndexBuffer@2@II@Z
	DD	FLAT:?draw@D3DTech@Ogre@@UAEXW4PrimitiveType@2@II@Z
	DD	FLAT:?getRequiredParams@D3DTech@Ogre@@UAEIPAW4ShaderParamUsage@2@I@Z
	DD	FLAT:??_ED3DTech@Ogre@@UAEPAXI@Z
	DD	FLAT:__purecall
	DD	FLAT:__purecall
CONST	ENDS
xdata$x	SEGMENT
__unwindtable$??0D3DTech@Ogre@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0D3DTech@Ogre@@QAE@XZ$0
__ehfuncinfo$??0D3DTech@Ogre@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0D3DTech@Ogre@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0D3DTech@Ogre@@QAE@XZ PROC				; Ogre::D3DTech::D3DTech
; _this$ = ecx

; 19   : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0D3DTech@Ogre@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0ShaderTechnique@Ogre@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7D3DTech@Ogre@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+188], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+388], 0

; 20   : 		memset(m_AllPass, 0, sizeof(m_AllPass));

	push	176					; 000000b0H
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 21   : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$??0D3DTech@Ogre@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1ShaderTechnique@Ogre@@MAE@XZ		; Ogre::ShaderTechnique::~ShaderTechnique
__ehhandler$??0D3DTech@Ogre@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0D3DTech@Ogre@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0D3DTech@Ogre@@QAE@XZ ENDP				; Ogre::D3DTech::D3DTech
PUBLIC	??_7ShaderTechnique@Ogre@@6B@			; Ogre::ShaderTechnique::`vftable'
PUBLIC	??_R4ShaderTechnique@Ogre@@6B@			; Ogre::ShaderTechnique::`RTTI Complete Object Locator'
EXTRN	??_EShaderTechnique@Ogre@@MAEPAXI@Z:PROC	; Ogre::ShaderTechnique::`vector deleting destructor'
;	COMDAT ??_R4ShaderTechnique@Ogre@@6B@
; File i:\svnroot\client\ogremain\ogreshader.h
rdata$r	SEGMENT
??_R4ShaderTechnique@Ogre@@6B@ DD 00H			; Ogre::ShaderTechnique::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVShaderTechnique@Ogre@@@8
	DD	FLAT:??_R3ShaderTechnique@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_7ShaderTechnique@Ogre@@6B@
CONST	SEGMENT
??_7ShaderTechnique@Ogre@@6B@ DD FLAT:??_R4ShaderTechnique@Ogre@@6B@ ; Ogre::ShaderTechnique::`vftable'
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:??_EShaderTechnique@Ogre@@MAEPAXI@Z
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ??1ShaderTechnique@Ogre@@MAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1ShaderTechnique@Ogre@@MAE@XZ PROC			; Ogre::ShaderTechnique::~ShaderTechnique, COMDAT
; _this$ = ecx

; 195  : 		virtual ~ShaderTechnique(){}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7ShaderTechnique@Ogre@@6B@
	mov	esp, ebp
	pop	ebp
	ret	0
??1ShaderTechnique@Ogre@@MAE@XZ ENDP			; Ogre::ShaderTechnique::~ShaderTechnique
_TEXT	ENDS
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
; Function compile flags: /Odtp
;	COMDAT ??_GShaderTechnique@Ogre@@MAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GShaderTechnique@Ogre@@MAEPAXI@Z PROC		; Ogre::ShaderTechnique::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1ShaderTechnique@Ogre@@MAE@XZ		; Ogre::ShaderTechnique::~ShaderTechnique
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GShaderTechnique@Ogre@@MAEPAXI@Z ENDP		; Ogre::ShaderTechnique::`scalar deleting destructor'
; Function compile flags: /Odtp
; File i:\svnroot\client\plugins\rendersystem_d3d9\ogred3d9technique.h
_TEXT	ENDS
;	COMDAT ?begin@D3DTech@Ogre@@UAEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?begin@D3DTech@Ogre@@UAEIXZ PROC			; Ogre::D3DTech::begin, COMDAT
; _this$ = ecx

; 20   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 21   : 			return m_nPass;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+188]

; 22   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?begin@D3DTech@Ogre@@UAEIXZ ENDP			; Ogre::D3DTech::begin
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?end@D3DTech@Ogre@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?end@D3DTech@Ogre@@UAEXXZ PROC				; Ogre::D3DTech::end, COMDAT
; _this$ = ecx

; 25   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 26   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?end@D3DTech@Ogre@@UAEXXZ ENDP				; Ogre::D3DTech::end
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?setConstant@D3DTech@Ogre@@UAEXPBDPBXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pname$ = 8						; size = 4
_pdata$ = 12						; size = 4
_nbytes$ = 16						; size = 4
?setConstant@D3DTech@Ogre@@UAEXPBDPBXI@Z PROC		; Ogre::D3DTech::setConstant, COMDAT
; _this$ = ecx

; 35   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 36   : 			assert(0);
; 37   : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?setConstant@D3DTech@Ogre@@UAEXPBDPBXI@Z ENDP		; Ogre::D3DTech::setConstant
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?setTexture@D3DTech@Ogre@@UAEXPBDPAVHardwarePixelBuffer@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pname$ = 8						; size = 4
_ptexture$ = 12						; size = 4
?setTexture@D3DTech@Ogre@@UAEXPBDPAVHardwarePixelBuffer@2@@Z PROC ; Ogre::D3DTech::setTexture, COMDAT
; _this$ = ecx

; 39   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 40   : 			assert(0);
; 41   : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?setTexture@D3DTech@Ogre@@UAEXPBDPAVHardwarePixelBuffer@2@@Z ENDP ; Ogre::D3DTech::setTexture
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?commitChanges@D3DTech@Ogre@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?commitChanges@D3DTech@Ogre@@UAEXXZ PROC		; Ogre::D3DTech::commitChanges, COMDAT
; _this$ = ecx

; 46   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 47   : 			assert(0);
; 48   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?commitChanges@D3DTech@Ogre@@UAEXXZ ENDP		; Ogre::D3DTech::commitChanges
_TEXT	ENDS
PUBLIC	??1D3DTech@Ogre@@UAE@XZ				; Ogre::D3DTech::~D3DTech
; Function compile flags: /Odtp
;	COMDAT ??_GD3DTech@Ogre@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GD3DTech@Ogre@@UAEPAXI@Z PROC			; Ogre::D3DTech::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1D3DTech@Ogre@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@2
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@2:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GD3DTech@Ogre@@UAEPAXI@Z ENDP			; Ogre::D3DTech::`scalar deleting destructor'
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0ShaderTechnique@Ogre@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0ShaderTechnique@Ogre@@QAE@XZ PROC			; Ogre::ShaderTechnique::ShaderTechnique, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7ShaderTechnique@Ogre@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0ShaderTechnique@Ogre@@QAE@XZ ENDP			; Ogre::ShaderTechnique::ShaderTechnique
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1D3DTech@Ogre@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1D3DTech@Ogre@@UAE@XZ$0
__ehfuncinfo$??1D3DTech@Ogre@@UAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1D3DTech@Ogre@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1D3DTech@Ogre@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1D3DTech@Ogre@@UAE@XZ PROC				; Ogre::D3DTech::~D3DTech, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1D3DTech@Ogre@@UAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1ShaderTechnique@Ogre@@MAE@XZ		; Ogre::ShaderTechnique::~ShaderTechnique
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1D3DTech@Ogre@@UAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1ShaderTechnique@Ogre@@MAE@XZ		; Ogre::ShaderTechnique::~ShaderTechnique
__ehhandler$??1D3DTech@Ogre@@UAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1D3DTech@Ogre@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1D3DTech@Ogre@@UAE@XZ ENDP				; Ogre::D3DTech::~D3DTech
PUBLIC	?isEqual@D3DTech@Ogre@@QAE_NPAV12@@Z		; Ogre::D3DTech::isEqual
; Function compile flags: /Odtp
; File i:\svnroot\client\plugins\rendersystem_d3d9\ogred3d9technique.cpp
_TEXT	SEGMENT
_this$ = -8						; size = 4
_i$142757 = -4						; size = 4
_ptech$ = 8						; size = 4
?isEqual@D3DTech@Ogre@@QAE_NPAV12@@Z PROC		; Ogre::D3DTech::isEqual
; _this$ = ecx

; 24   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 25   : 		if(m_UsedMacroMask != ptech->m_UsedMacroMask) return false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _ptech$[ebp]
	mov	edx, DWORD PTR [eax+4]
	cmp	edx, DWORD PTR [ecx+4]
	je	SHORT $LN7@isEqual
	xor	al, al
	jmp	SHORT $LN8@isEqual
$LN7@isEqual:

; 26   : 		if(m_nPass != ptech->m_nPass) return false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _ptech$[ebp]
	mov	edx, DWORD PTR [eax+188]
	cmp	edx, DWORD PTR [ecx+188]
	je	SHORT $LN6@isEqual
	xor	al, al
	jmp	SHORT $LN8@isEqual
$LN6@isEqual:

; 27   : 		for(size_t i=0; i<m_nPass; i++)

	mov	DWORD PTR _i$142757[ebp], 0
	jmp	SHORT $LN5@isEqual
$LN4@isEqual:
	mov	eax, DWORD PTR _i$142757[ebp]
	add	eax, 1
	mov	DWORD PTR _i$142757[ebp], eax
$LN5@isEqual:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _i$142757[ebp]
	cmp	edx, DWORD PTR [ecx+188]
	jae	SHORT $LN3@isEqual

; 28   : 		{
; 29   : 			if(m_AllPass[i].vs!=ptech->m_AllPass[i].vs || m_AllPass[i].ps!=ptech->m_AllPass[i].ps) return false;

	mov	eax, DWORD PTR _i$142757[ebp]
	imul	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR _i$142757[ebp]
	imul	ecx, 44					; 0000002cH
	mov	edx, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR _ptech$[ebp]
	mov	eax, DWORD PTR [edx+eax+12]
	cmp	eax, DWORD PTR [esi+ecx+12]
	jne	SHORT $LN1@isEqual
	mov	ecx, DWORD PTR _i$142757[ebp]
	imul	ecx, 44					; 0000002cH
	mov	edx, DWORD PTR _i$142757[ebp]
	imul	edx, 44					; 0000002cH
	mov	eax, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR _ptech$[ebp]
	mov	ecx, DWORD PTR [eax+ecx+16]
	cmp	ecx, DWORD PTR [esi+edx+16]
	je	SHORT $LN2@isEqual
$LN1@isEqual:
	xor	al, al
	jmp	SHORT $LN8@isEqual
$LN2@isEqual:

; 30   : 		}

	jmp	SHORT $LN4@isEqual
$LN3@isEqual:

; 31   : 		return true;

	mov	al, 1
$LN8@isEqual:

; 32   : 	}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?isEqual@D3DTech@Ogre@@QAE_NPAV12@@Z ENDP		; Ogre::D3DTech::isEqual
_TEXT	ENDS
PUBLIC	?getSysTexture@D3D9HardwarePixelBuffer@Ogre@@QAEPAUIDirect3DBaseTexture9@@XZ ; Ogre::D3D9HardwarePixelBuffer::getSysTexture
; Function compile flags: /Odtp
_TEXT	SEGMENT
_this$ = -12						; size = 4
_i$142769 = -8						; size = 4
_pd$ = -4						; size = 4
_type$ = 8						; size = 4
_ptexture$ = 12						; size = 4
?setTexture@D3DTech@Ogre@@UAEXW4ShaderParamUsage@2@PAVHardwarePixelBuffer@2@@Z PROC ; Ogre::D3DTech::setTexture
; _this$ = ecx

; 35   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 36   : 		const D3DTech::PassData &pd = m_AllPass[m_CurPass];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+192]
	imul	ecx, 44					; 0000002cH
	mov	edx, DWORD PTR _this$[ebp]
	lea	eax, DWORD PTR [edx+ecx+12]
	mov	DWORD PTR _pd$[ebp], eax

; 37   : 		for(int i=0; i<pd.ntex; i++)

	mov	DWORD PTR _i$142769[ebp], 0
	jmp	SHORT $LN6@setTexture
$LN5@setTexture:
	mov	ecx, DWORD PTR _i$142769[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$142769[ebp], ecx
$LN6@setTexture:
	mov	edx, DWORD PTR _pd$[ebp]
	mov	eax, DWORD PTR _i$142769[ebp]
	cmp	eax, DWORD PTR [edx+8]
	jge	SHORT $LN7@setTexture

; 38   : 		{
; 39   : 			if(pd.texstage[i] == type)

	mov	ecx, DWORD PTR _i$142769[ebp]
	mov	edx, DWORD PTR _pd$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4+12]
	cmp	eax, DWORD PTR _type$[ebp]
	jne	SHORT $LN3@setTexture

; 40   : 			{
; 41   : 				if(ptexture == NULL) m_pDevice->SetTexture(i, NULL);

	cmp	DWORD PTR _ptexture$[ebp], 0
	jne	SHORT $LN2@setTexture
	push	0
	mov	ecx, DWORD PTR _i$142769[ebp]
	push	ecx
	mov	edx, DWORD PTR ?m_pDevice@D3DTech@Ogre@@2PAUIDirect3DDevice9@@A ; Ogre::D3DTech::m_pDevice
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR ?m_pDevice@D3DTech@Ogre@@2PAUIDirect3DDevice9@@A ; Ogre::D3DTech::m_pDevice
	push	ecx
	mov	edx, DWORD PTR [eax+260]
	call	edx
	jmp	SHORT $LN3@setTexture
$LN2@setTexture:

; 42   : 				else m_pDevice->SetTexture(i, static_cast<D3D9HardwarePixelBuffer *>(ptexture)->getSysTexture());

	mov	ecx, DWORD PTR _ptexture$[ebp]
	call	?getSysTexture@D3D9HardwarePixelBuffer@Ogre@@QAEPAUIDirect3DBaseTexture9@@XZ ; Ogre::D3D9HardwarePixelBuffer::getSysTexture
	push	eax
	mov	eax, DWORD PTR _i$142769[ebp]
	push	eax
	mov	ecx, DWORD PTR ?m_pDevice@D3DTech@Ogre@@2PAUIDirect3DDevice9@@A ; Ogre::D3DTech::m_pDevice
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR ?m_pDevice@D3DTech@Ogre@@2PAUIDirect3DDevice9@@A ; Ogre::D3DTech::m_pDevice
	push	eax
	mov	ecx, DWORD PTR [edx+260]
	call	ecx
$LN3@setTexture:

; 43   : 			}

	jmp	SHORT $LN5@setTexture
$LN7@setTexture:

; 44   : 		}
; 45   : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?setTexture@D3DTech@Ogre@@UAEXW4ShaderParamUsage@2@PAVHardwarePixelBuffer@2@@Z ENDP ; Ogre::D3DTech::setTexture
; Function compile flags: /Odtp
; File i:\svnroot\client\plugins\rendersystem_d3d9\ogred3d9hardwarepixelbuffer.h
_TEXT	ENDS
;	COMDAT ?getSysTexture@D3D9HardwarePixelBuffer@Ogre@@QAEPAUIDirect3DBaseTexture9@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getSysTexture@D3D9HardwarePixelBuffer@Ogre@@QAEPAUIDirect3DBaseTexture9@@XZ PROC ; Ogre::D3D9HardwarePixelBuffer::getSysTexture, COMDAT
; _this$ = ecx

; 76   : 		IDirect3DBaseTexture9 *getSysTexture(){ return m_pSysTex; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+20]
	mov	esp, ebp
	pop	ebp
	ret	0
?getSysTexture@D3D9HardwarePixelBuffer@Ogre@@QAEPAUIDirect3DBaseTexture9@@XZ ENDP ; Ogre::D3D9HardwarePixelBuffer::getSysTexture
_TEXT	ENDS
EXTRN	?setConstant@CompiledShader@Ogre@@QAEXW4ShaderParamUsage@2@PBXI@Z:PROC ; Ogre::CompiledShader::setConstant
; Function compile flags: /Odtp
; File i:\svnroot\client\plugins\rendersystem_d3d9\ogred3d9technique.cpp
_TEXT	SEGMENT
_this$ = -8						; size = 4
_pd$ = -4						; size = 4
_type$ = 8						; size = 4
_pdata$ = 12						; size = 4
_nbytes$ = 16						; size = 4
?setConstant@D3DTech@Ogre@@UAEXW4ShaderParamUsage@2@PBXI@Z PROC ; Ogre::D3DTech::setConstant
; _this$ = ecx

; 48   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 49   : 		const D3DTech::PassData &pd = m_AllPass[m_CurPass];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+192]
	imul	ecx, 44					; 0000002cH
	mov	edx, DWORD PTR _this$[ebp]
	lea	eax, DWORD PTR [edx+ecx+12]
	mov	DWORD PTR _pd$[ebp], eax

; 50   : 		if(pd.vs) pd.vs->setConstant(type, pdata, nbytes);

	mov	ecx, DWORD PTR _pd$[ebp]
	cmp	DWORD PTR [ecx], 0
	je	SHORT $LN2@setConstan
	mov	edx, DWORD PTR _nbytes$[ebp]
	push	edx
	mov	eax, DWORD PTR _pdata$[ebp]
	push	eax
	mov	ecx, DWORD PTR _type$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pd$[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?setConstant@CompiledShader@Ogre@@QAEXW4ShaderParamUsage@2@PBXI@Z ; Ogre::CompiledShader::setConstant
$LN2@setConstan:

; 51   : 		if(pd.ps) pd.ps->setConstant(type, pdata, nbytes);

	mov	eax, DWORD PTR _pd$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN3@setConstan
	mov	ecx, DWORD PTR _nbytes$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pdata$[ebp]
	push	edx
	mov	eax, DWORD PTR _type$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pd$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	call	?setConstant@CompiledShader@Ogre@@QAEXW4ShaderParamUsage@2@PBXI@Z ; Ogre::CompiledShader::setConstant
$LN3@setConstan:

; 52   : 	}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?setConstant@D3DTech@Ogre@@UAEXW4ShaderParamUsage@2@PBXI@Z ENDP ; Ogre::D3DTech::setConstant
_TEXT	ENDS
EXTRN	_memcpy:PROC
; Function compile flags: /Odtp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pbuf$ = 8						; size = 4
_maxbuf$ = 12						; size = 4
?getRequiredParams@D3DTech@Ogre@@UAEIPAW4ShaderParamUsage@2@I@Z PROC ; Ogre::D3DTech::getRequiredParams
; _this$ = ecx

; 55   : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 56   : 		assert(m_NumUsedParams < maxbuf);
; 57   : 
; 58   : 		memcpy(pbuf, m_UsedParams, m_NumUsedParams*sizeof(ShaderParamUsage));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+388]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 196				; 000000c4H
	push	edx
	mov	eax, DWORD PTR _pbuf$[ebp]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 59   : 		return m_NumUsedParams;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+388]

; 60   : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?getRequiredParams@D3DTech@Ogre@@UAEIPAW4ShaderParamUsage@2@I@Z ENDP ; Ogre::D3DTech::getRequiredParams
_TEXT	ENDS
PUBLIC	?applyVSPS@D3DTech@Ogre@@IAEXI@Z		; Ogre::D3DTech::applyVSPS
; Function compile flags: /Odtp
_TEXT	SEGMENT
_this$ = -8						; size = 4
_pd$ = -4						; size = 4
_ipass$ = 8						; size = 4
?applyVSPS@D3DTech@Ogre@@IAEXI@Z PROC			; Ogre::D3DTech::applyVSPS
; _this$ = ecx

; 63   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 64   : 		const PassData &pd = m_AllPass[ipass];

	mov	eax, DWORD PTR _ipass$[ebp]
	imul	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR _this$[ebp]
	lea	edx, DWORD PTR [ecx+eax+12]
	mov	DWORD PTR _pd$[ebp], edx

; 65   : 
; 66   : 		if(pd.vs == NULL )

	mov	eax, DWORD PTR _pd$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN8@applyVSPS

; 67   : 		{
; 68   : 			if (ms_pCurVS != NULL)

	cmp	DWORD PTR ?ms_pCurVS@D3DTech@Ogre@@2PAUIDirect3DVertexShader9@@A, 0 ; Ogre::D3DTech::ms_pCurVS
	je	SHORT $LN7@applyVSPS

; 69   : 			{
; 70   : 				m_pDevice->SetVertexShader(NULL);

	push	0
	mov	ecx, DWORD PTR ?m_pDevice@D3DTech@Ogre@@2PAUIDirect3DDevice9@@A ; Ogre::D3DTech::m_pDevice
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR ?m_pDevice@D3DTech@Ogre@@2PAUIDirect3DDevice9@@A ; Ogre::D3DTech::m_pDevice
	push	eax
	mov	ecx, DWORD PTR [edx+368]
	call	ecx

; 71   : 				ms_pCurVS = NULL;

	mov	DWORD PTR ?ms_pCurVS@D3DTech@Ogre@@2PAUIDirect3DVertexShader9@@A, 0 ; Ogre::D3DTech::ms_pCurVS
$LN7@applyVSPS:

; 72   : 			}
; 73   : 		}
; 74   : 		else 

	jmp	SHORT $LN6@applyVSPS
$LN8@applyVSPS:

; 75   : 		{
; 76   : 			if (ms_pCurVS != pd.vs->m_pVS)

	mov	edx, DWORD PTR _pd$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR ?ms_pCurVS@D3DTech@Ogre@@2PAUIDirect3DVertexShader9@@A ; Ogre::D3DTech::ms_pCurVS
	cmp	ecx, DWORD PTR [eax+48]
	je	SHORT $LN6@applyVSPS

; 77   : 			{
; 78   : 				m_pDevice->SetVertexShader(pd.vs->m_pVS);

	mov	edx, DWORD PTR _pd$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+48]
	push	ecx
	mov	edx, DWORD PTR ?m_pDevice@D3DTech@Ogre@@2PAUIDirect3DDevice9@@A ; Ogre::D3DTech::m_pDevice
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR ?m_pDevice@D3DTech@Ogre@@2PAUIDirect3DDevice9@@A ; Ogre::D3DTech::m_pDevice
	push	ecx
	mov	edx, DWORD PTR [eax+368]
	call	edx

; 79   : 				ms_pCurVS = pd.vs->m_pVS;

	mov	eax, DWORD PTR _pd$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+48]
	mov	DWORD PTR ?ms_pCurVS@D3DTech@Ogre@@2PAUIDirect3DVertexShader9@@A, edx ; Ogre::D3DTech::ms_pCurVS
$LN6@applyVSPS:

; 80   : 			}
; 81   : 		}
; 82   : 
; 83   : 		if(pd.ps == NULL)

	mov	eax, DWORD PTR _pd$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN4@applyVSPS

; 84   : 		{
; 85   : 			if (ms_pCurPS != NULL)

	cmp	DWORD PTR ?ms_pCurPS@D3DTech@Ogre@@2PAUIDirect3DPixelShader9@@A, 0 ; Ogre::D3DTech::ms_pCurPS
	je	SHORT $LN3@applyVSPS

; 86   : 			{
; 87   : 				m_pDevice->SetPixelShader(NULL);

	push	0
	mov	ecx, DWORD PTR ?m_pDevice@D3DTech@Ogre@@2PAUIDirect3DDevice9@@A ; Ogre::D3DTech::m_pDevice
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR ?m_pDevice@D3DTech@Ogre@@2PAUIDirect3DDevice9@@A ; Ogre::D3DTech::m_pDevice
	push	eax
	mov	ecx, DWORD PTR [edx+428]
	call	ecx

; 88   : 				ms_pCurPS = NULL;

	mov	DWORD PTR ?ms_pCurPS@D3DTech@Ogre@@2PAUIDirect3DPixelShader9@@A, 0 ; Ogre::D3DTech::ms_pCurPS
$LN3@applyVSPS:

; 89   : 			}
; 90   : 		}
; 91   : 		else

	jmp	SHORT $LN9@applyVSPS
$LN4@applyVSPS:

; 92   : 		{
; 93   : 			if (ms_pCurPS != pd.ps->m_pPS)

	mov	edx, DWORD PTR _pd$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR ?ms_pCurPS@D3DTech@Ogre@@2PAUIDirect3DPixelShader9@@A ; Ogre::D3DTech::ms_pCurPS
	cmp	ecx, DWORD PTR [eax+52]
	je	SHORT $LN9@applyVSPS

; 94   : 			{
; 95   : 				m_pDevice->SetPixelShader(pd.ps->m_pPS);

	mov	edx, DWORD PTR _pd$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [eax+52]
	push	ecx
	mov	edx, DWORD PTR ?m_pDevice@D3DTech@Ogre@@2PAUIDirect3DDevice9@@A ; Ogre::D3DTech::m_pDevice
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR ?m_pDevice@D3DTech@Ogre@@2PAUIDirect3DDevice9@@A ; Ogre::D3DTech::m_pDevice
	push	ecx
	mov	edx, DWORD PTR [eax+428]
	call	edx

; 96   : 				ms_pCurPS = pd.ps->m_pPS;

	mov	eax, DWORD PTR _pd$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+52]
	mov	DWORD PTR ?ms_pCurPS@D3DTech@Ogre@@2PAUIDirect3DPixelShader9@@A, edx ; Ogre::D3DTech::ms_pCurPS
$LN9@applyVSPS:

; 97   : 			}
; 98   : 		}
; 99   : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
?applyVSPS@D3DTech@Ogre@@IAEXI@Z ENDP			; Ogre::D3DTech::applyVSPS
_TEXT	ENDS
PUBLIC	?isParamUsed@D3DTech@Ogre@@IAE_NW4ShaderParamUsage@2@@Z ; Ogre::D3DTech::isParamUsed
EXTRN	?hasConstant@CompiledShader@Ogre@@QAE_NW4ShaderParamUsage@2@PBD@Z:PROC ; Ogre::CompiledShader::hasConstant
; Function compile flags: /Odtp
_TEXT	SEGMENT
_this$ = -16						; size = 4
_itex$142815 = -12					; size = 4
_pd$142814 = -8						; size = 4
_ipass$142810 = -4					; size = 4
_usage$ = 8						; size = 4
?isParamUsed@D3DTech@Ogre@@IAE_NW4ShaderParamUsage@2@@Z PROC ; Ogre::D3DTech::isParamUsed
; _this$ = ecx

; 102  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 103  : 		for(size_t ipass=0; ipass<m_nPass; ipass++)

	mov	DWORD PTR _ipass$142810[ebp], 0
	jmp	SHORT $LN9@isParamUse
$LN8@isParamUse:
	mov	eax, DWORD PTR _ipass$142810[ebp]
	add	eax, 1
	mov	DWORD PTR _ipass$142810[ebp], eax
$LN9@isParamUse:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _ipass$142810[ebp]
	cmp	edx, DWORD PTR [ecx+188]
	jae	$LN7@isParamUse

; 104  : 		{
; 105  : 			const PassData &pd = m_AllPass[ipass];

	mov	eax, DWORD PTR _ipass$142810[ebp]
	imul	eax, 44					; 0000002cH
	mov	ecx, DWORD PTR _this$[ebp]
	lea	edx, DWORD PTR [ecx+eax+12]
	mov	DWORD PTR _pd$142814[ebp], edx

; 106  : 			for(int itex=0; itex<pd.ntex; itex++)

	mov	DWORD PTR _itex$142815[ebp], 0
	jmp	SHORT $LN6@isParamUse
$LN5@isParamUse:
	mov	eax, DWORD PTR _itex$142815[ebp]
	add	eax, 1
	mov	DWORD PTR _itex$142815[ebp], eax
$LN6@isParamUse:
	mov	ecx, DWORD PTR _pd$142814[ebp]
	mov	edx, DWORD PTR _itex$142815[ebp]
	cmp	edx, DWORD PTR [ecx+8]
	jge	SHORT $LN4@isParamUse

; 107  : 			{
; 108  : 				if(pd.texstage[itex] == usage) return true;

	mov	eax, DWORD PTR _itex$142815[ebp]
	mov	ecx, DWORD PTR _pd$142814[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+12]
	cmp	edx, DWORD PTR _usage$[ebp]
	jne	SHORT $LN3@isParamUse
	mov	al, 1
	jmp	SHORT $LN10@isParamUse
$LN3@isParamUse:

; 109  : 			}

	jmp	SHORT $LN5@isParamUse
$LN4@isParamUse:

; 110  : 
; 111  : 			if(pd.vs && pd.vs->hasConstant(usage,NULL)) return true;

	mov	eax, DWORD PTR _pd$142814[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN2@isParamUse
	push	0
	mov	ecx, DWORD PTR _usage$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pd$142814[ebp]
	mov	ecx, DWORD PTR [edx]
	call	?hasConstant@CompiledShader@Ogre@@QAE_NW4ShaderParamUsage@2@PBD@Z ; Ogre::CompiledShader::hasConstant
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@isParamUse
	mov	al, 1
	jmp	SHORT $LN10@isParamUse
$LN2@isParamUse:

; 112  : 			if(pd.ps && pd.ps->hasConstant(usage,NULL)) return true;

	mov	ecx, DWORD PTR _pd$142814[ebp]
	cmp	DWORD PTR [ecx+4], 0
	je	SHORT $LN1@isParamUse
	push	0
	mov	edx, DWORD PTR _usage$[ebp]
	push	edx
	mov	eax, DWORD PTR _pd$142814[ebp]
	mov	ecx, DWORD PTR [eax+4]
	call	?hasConstant@CompiledShader@Ogre@@QAE_NW4ShaderParamUsage@2@PBD@Z ; Ogre::CompiledShader::hasConstant
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@isParamUse
	mov	al, 1
	jmp	SHORT $LN10@isParamUse
$LN1@isParamUse:

; 113  : 		}

	jmp	$LN8@isParamUse
$LN7@isParamUse:

; 114  : 		return false;

	xor	al, al
$LN10@isParamUse:

; 115  : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
?isParamUsed@D3DTech@Ogre@@IAE_NW4ShaderParamUsage@2@@Z ENDP ; Ogre::D3DTech::isParamUsed
_TEXT	ENDS
PUBLIC	?initParams@D3DTech@Ogre@@IAEXXZ		; Ogre::D3DTech::initParams
; Function compile flags: /Odtp
_TEXT	SEGMENT
_this$ = -8						; size = 4
_usage$142825 = -4					; size = 4
?initParams@D3DTech@Ogre@@IAEXXZ PROC			; Ogre::D3DTech::initParams
; _this$ = ecx

; 118  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 119  : 		m_NumUsedParams = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+388], 0

; 120  : 		for(ShaderParamUsage usage=SPU_INSTANCE_PARAM; usage<SPU_ENV_PARAM_END; usage=(ShaderParamUsage)(usage+1))

	mov	DWORD PTR _usage$142825[ebp], 0
	jmp	SHORT $LN4@initParams
$LN3@initParams:
	mov	ecx, DWORD PTR _usage$142825[ebp]
	add	ecx, 1
	mov	DWORD PTR _usage$142825[ebp], ecx
$LN4@initParams:
	cmp	DWORD PTR _usage$142825[ebp], 48	; 00000030H
	jge	SHORT $LN5@initParams

; 121  : 		{
; 122  : 			if(isParamUsed(usage)) m_UsedParams[m_NumUsedParams++] = usage;

	mov	edx, DWORD PTR _usage$142825[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?isParamUsed@D3DTech@Ogre@@IAE_NW4ShaderParamUsage@2@@Z ; Ogre::D3DTech::isParamUsed
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@initParams
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+388]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _usage$142825[ebp]
	mov	DWORD PTR [eax+edx*4+196], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+388]
	add	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+388], eax
$LN1@initParams:

; 123  : 		}

	jmp	SHORT $LN3@initParams
$LN5@initParams:

; 124  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?initParams@D3DTech@Ogre@@IAEXXZ ENDP			; Ogre::D3DTech::initParams
_TEXT	ENDS
PUBLIC	?getSysBuf@D3DVertexBufferPool@Ogre@@QAEPAUIDirect3DVertexBuffer9@@XZ ; Ogre::D3DVertexBufferPool::getSysBuf
EXTRN	__imp_?getStart@HardwareBuffer@Ogre@@QAEIXZ:PROC
EXTRN	__imp_?getPool@HardwareBuffer@Ogre@@QAEPAVHardwareBufferPool@2@XZ:PROC
; Function compile flags: /Odtp
_TEXT	SEGMENT
tv91 = -28						; size = 4
_this$ = -24						; size = 4
_pool$142845 = -20					; size = 4
_offset$142847 = -16					; size = 4
_pvb$142844 = -12					; size = 4
_i$142839 = -8						; size = 4
_pdevice$ = -4						; size = 4
_vertdecl$ = 8						; size = 4
_ppvb$ = 12						; size = 4
_poffsetbytes$ = 16					; size = 4
?setStreamInput@D3DTech@Ogre@@UAEXIPAPAVHardwareVertexBuffer@2@PAI@Z PROC ; Ogre::D3DTech::setStreamInput
; _this$ = ecx

; 127  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR _this$[ebp], ecx

; 128  : 		assert(ppvb!=NULL);
; 129  : 		IDirect3DDevice9 *pdevice = m_pDevice;

	mov	eax, DWORD PTR ?m_pDevice@D3DTech@Ogre@@2PAUIDirect3DDevice9@@A ; Ogre::D3DTech::m_pDevice
	mov	DWORD PTR _pdevice$[ebp], eax

; 130  : 
; 131  : 		for(int i=0; i<8; i++)

	mov	DWORD PTR _i$142839[ebp], 0
	jmp	SHORT $LN4@setStreamI
$LN3@setStreamI:
	mov	ecx, DWORD PTR _i$142839[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$142839[ebp], ecx
$LN4@setStreamI:
	cmp	DWORD PTR _i$142839[ebp], 8
	jge	$LN2@setStreamI

; 132  : 		{
; 133  : 			if(ppvb[i] == NULL)

	mov	edx, DWORD PTR _i$142839[ebp]
	mov	eax, DWORD PTR _ppvb$[ebp]
	cmp	DWORD PTR [eax+edx*4], 0
	jne	SHORT $LN1@setStreamI

; 134  : 			{
; 135  : 				pdevice->SetStreamSource(i, NULL, 0, 0);

	push	0
	push	0
	push	0
	mov	ecx, DWORD PTR _i$142839[ebp]
	push	ecx
	mov	edx, DWORD PTR _pdevice$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _pdevice$[ebp]
	push	ecx
	mov	edx, DWORD PTR [eax+400]
	call	edx

; 136  : 				break;

	jmp	SHORT $LN2@setStreamI
$LN1@setStreamI:

; 137  : 			}
; 138  : 
; 139  : 			HardwareVertexBuffer *pvb = ppvb[i];

	mov	eax, DWORD PTR _i$142839[ebp]
	mov	ecx, DWORD PTR _ppvb$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR _pvb$142844[ebp], edx

; 140  : 			D3DVertexBufferPool *pool = static_cast<D3DVertexBufferPool *>(pvb->getPool());

	mov	ecx, DWORD PTR _pvb$142844[ebp]
	call	DWORD PTR __imp_?getPool@HardwareBuffer@Ogre@@QAEPAVHardwareBufferPool@2@XZ
	mov	DWORD PTR _pool$142845[ebp], eax

; 141  : 
; 142  : 			size_t offset = poffsetbytes==NULL?0:poffsetbytes[i];

	cmp	DWORD PTR _poffsetbytes$[ebp], 0
	jne	SHORT $LN7@setStreamI
	mov	DWORD PTR tv91[ebp], 0
	jmp	SHORT $LN8@setStreamI
$LN7@setStreamI:
	mov	eax, DWORD PTR _i$142839[ebp]
	mov	ecx, DWORD PTR _poffsetbytes$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR tv91[ebp], edx
$LN8@setStreamI:
	mov	eax, DWORD PTR tv91[ebp]
	mov	DWORD PTR _offset$142847[ebp], eax

; 143  : 
; 144  : 			assert(pvb->m_Stride > 0);
; 145  : 			pdevice->SetStreamSource(i, pool->getSysBuf(), (UINT)(pvb->getStart()+offset), (UINT)pvb->m_Stride);

	mov	ecx, DWORD PTR _pvb$142844[ebp]
	mov	edx, DWORD PTR [ecx+32]
	push	edx
	mov	ecx, DWORD PTR _pvb$142844[ebp]
	call	DWORD PTR __imp_?getStart@HardwareBuffer@Ogre@@QAEIXZ
	add	eax, DWORD PTR _offset$142847[ebp]
	push	eax
	mov	ecx, DWORD PTR _pool$142845[ebp]
	call	?getSysBuf@D3DVertexBufferPool@Ogre@@QAEPAUIDirect3DVertexBuffer9@@XZ ; Ogre::D3DVertexBufferPool::getSysBuf
	push	eax
	mov	eax, DWORD PTR _i$142839[ebp]
	push	eax
	mov	ecx, DWORD PTR _pdevice$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _pdevice$[ebp]
	push	eax
	mov	ecx, DWORD PTR [edx+400]
	call	ecx

; 146  : 		}

	jmp	$LN3@setStreamI
$LN2@setStreamI:

; 147  : 
; 148  : 		pdevice->SetVertexDeclaration(((D3D9VertexDecl *)vertdecl)->m_pVertDecl);

	mov	edx, DWORD PTR _vertdecl$[ebp]
	mov	eax, DWORD PTR [edx+28]
	push	eax
	mov	ecx, DWORD PTR _pdevice$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _pdevice$[ebp]
	push	eax
	mov	ecx, DWORD PTR [edx+348]
	call	ecx

; 149  : 	}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?setStreamInput@D3DTech@Ogre@@UAEXIPAPAVHardwareVertexBuffer@2@PAI@Z ENDP ; Ogre::D3DTech::setStreamInput
; Function compile flags: /Odtp
; File i:\svnroot\client\plugins\rendersystem_d3d9\ogred3d9hardwarebuffer.h
_TEXT	ENDS
;	COMDAT ?getSysBuf@D3DVertexBufferPool@Ogre@@QAEPAUIDirect3DVertexBuffer9@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getSysBuf@D3DVertexBufferPool@Ogre@@QAEPAUIDirect3DVertexBuffer9@@XZ PROC ; Ogre::D3DVertexBufferPool::getSysBuf, COMDAT
; _this$ = ecx

; 37   : 		IDirect3DVertexBuffer9 *getSysBuf(){ return m_pSysBuf; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+52]
	mov	esp, ebp
	pop	ebp
	ret	0
?getSysBuf@D3DVertexBufferPool@Ogre@@QAEPAUIDirect3DVertexBuffer9@@XZ ENDP ; Ogre::D3DVertexBufferPool::getSysBuf
; Function compile flags: /Odtp
; File i:\svnroot\client\plugins\rendersystem_d3d9\ogred3d9technique.cpp
_TEXT	ENDS
_TEXT	SEGMENT
tv81 = -28						; size = 4
_this$ = -24						; size = 4
_pool$142866 = -20					; size = 4
_offset$142868 = -16					; size = 4
_pvb$142865 = -12					; size = 4
_i$142861 = -8						; size = 4
_pdevice$ = -4						; size = 4
_vertdecl$ = 8						; size = 4
_ppvb$ = 12						; size = 4
_nNumInstance$ = 16					; size = 4
_poffsetbytes$ = 20					; size = 4
?setStreamInput@D3DTech@Ogre@@UAEXIPAPAVHardwareVertexBuffer@2@HPAI@Z PROC ; Ogre::D3DTech::setStreamInput
; _this$ = ecx

; 152  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR _this$[ebp], ecx

; 153  : 		assert(ppvb!=NULL);
; 154  : 		IDirect3DDevice9 *pdevice = m_pDevice;

	mov	eax, DWORD PTR ?m_pDevice@D3DTech@Ogre@@2PAUIDirect3DDevice9@@A ; Ogre::D3DTech::m_pDevice
	mov	DWORD PTR _pdevice$[ebp], eax

; 155  : 
; 156  : 		for(int i=0; i<2; i++)

	mov	DWORD PTR _i$142861[ebp], 0
	jmp	SHORT $LN3@setStreamI@2
$LN2@setStreamI@2:
	mov	ecx, DWORD PTR _i$142861[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$142861[ebp], ecx
$LN3@setStreamI@2:
	cmp	DWORD PTR _i$142861[ebp], 2
	jge	SHORT $LN1@setStreamI@2

; 157  : 		{
; 158  : 			HardwareVertexBuffer *pvb = ppvb[i];

	mov	edx, DWORD PTR _i$142861[ebp]
	mov	eax, DWORD PTR _ppvb$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR _pvb$142865[ebp], ecx

; 159  : 			D3DVertexBufferPool *pool = static_cast<D3DVertexBufferPool *>(pvb->getPool());

	mov	ecx, DWORD PTR _pvb$142865[ebp]
	call	DWORD PTR __imp_?getPool@HardwareBuffer@Ogre@@QAEPAVHardwareBufferPool@2@XZ
	mov	DWORD PTR _pool$142866[ebp], eax

; 160  : 
; 161  : 			size_t offset = poffsetbytes==NULL?0:poffsetbytes[i];

	cmp	DWORD PTR _poffsetbytes$[ebp], 0
	jne	SHORT $LN6@setStreamI@2
	mov	DWORD PTR tv81[ebp], 0
	jmp	SHORT $LN7@setStreamI@2
$LN6@setStreamI@2:
	mov	edx, DWORD PTR _i$142861[ebp]
	mov	eax, DWORD PTR _poffsetbytes$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR tv81[ebp], ecx
$LN7@setStreamI@2:
	mov	edx, DWORD PTR tv81[ebp]
	mov	DWORD PTR _offset$142868[ebp], edx

; 162  : 
; 163  : 			assert(pvb->m_Stride > 0);
; 164  : 			pdevice->SetStreamSource(i, pool->getSysBuf(), (UINT)(pvb->getStart()+offset), (UINT)pvb->m_Stride);

	mov	eax, DWORD PTR _pvb$142865[ebp]
	mov	ecx, DWORD PTR [eax+32]
	push	ecx
	mov	ecx, DWORD PTR _pvb$142865[ebp]
	call	DWORD PTR __imp_?getStart@HardwareBuffer@Ogre@@QAEIXZ
	add	eax, DWORD PTR _offset$142868[ebp]
	push	eax
	mov	ecx, DWORD PTR _pool$142866[ebp]
	call	?getSysBuf@D3DVertexBufferPool@Ogre@@QAEPAUIDirect3DVertexBuffer9@@XZ ; Ogre::D3DVertexBufferPool::getSysBuf
	push	eax
	mov	edx, DWORD PTR _i$142861[ebp]
	push	edx
	mov	eax, DWORD PTR _pdevice$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _pdevice$[ebp]
	push	edx
	mov	eax, DWORD PTR [ecx+400]
	call	eax

; 165  : 		}

	jmp	SHORT $LN2@setStreamI@2
$LN1@setStreamI@2:

; 166  : 
; 167  : 		pdevice->SetStreamSourceFreq(0,D3DSTREAMSOURCE_INDEXEDDATA | nNumInstance);

	mov	ecx, DWORD PTR _nNumInstance$[ebp]
	or	ecx, 1073741824				; 40000000H
	push	ecx
	push	0
	mov	edx, DWORD PTR _pdevice$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _pdevice$[ebp]
	push	ecx
	mov	edx, DWORD PTR [eax+408]
	call	edx

; 168  : 
; 169  : 		pdevice->SetStreamSourceFreq(1,D3DSTREAMSOURCE_INSTANCEDATA | 1ul);

	push	-2147483647				; 80000001H
	push	1
	mov	eax, DWORD PTR _pdevice$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _pdevice$[ebp]
	push	edx
	mov	eax, DWORD PTR [ecx+408]
	call	eax

; 170  : 
; 171  : 		pdevice->SetVertexDeclaration(((D3D9VertexDecl *)vertdecl)->m_pVertDecl);

	mov	ecx, DWORD PTR _vertdecl$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	push	edx
	mov	eax, DWORD PTR _pdevice$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _pdevice$[ebp]
	push	edx
	mov	eax, DWORD PTR [ecx+348]
	call	eax

; 172  : 	}

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?setStreamInput@D3DTech@Ogre@@UAEXIPAPAVHardwareVertexBuffer@2@HPAI@Z ENDP ; Ogre::D3DTech::setStreamInput
; Function compile flags: /Odtp
_this$ = -12						; size = 4
_pool$ = -8						; size = 4
_pdevice$ = -4						; size = 4
_vertdecl$ = 8						; size = 4
_pvb$ = 12						; size = 4
_offset$ = 16						; size = 4
?setStreamInput@D3DTech@Ogre@@UAEXIPAVHardwareVertexBuffer@2@I@Z PROC ; Ogre::D3DTech::setStreamInput
; _this$ = ecx

; 175  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 176  : 		assert(pvb!=NULL);
; 177  : 		IDirect3DDevice9 *pdevice = m_pDevice;

	mov	eax, DWORD PTR ?m_pDevice@D3DTech@Ogre@@2PAUIDirect3DDevice9@@A ; Ogre::D3DTech::m_pDevice
	mov	DWORD PTR _pdevice$[ebp], eax

; 178  : 		D3DVertexBufferPool *pool = static_cast<D3DVertexBufferPool *>(pvb->getPool());

	mov	ecx, DWORD PTR _pvb$[ebp]
	call	DWORD PTR __imp_?getPool@HardwareBuffer@Ogre@@QAEPAVHardwareBufferPool@2@XZ
	mov	DWORD PTR _pool$[ebp], eax

; 179  : 
; 180  : 		assert(pvb->m_Stride > 0);
; 181  : 		pdevice->SetStreamSource(0, pool->getSysBuf(), (UINT)(pvb->getStart()+offset), (UINT)pvb->m_Stride);

	mov	ecx, DWORD PTR _pvb$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	push	edx
	mov	ecx, DWORD PTR _pvb$[ebp]
	call	DWORD PTR __imp_?getStart@HardwareBuffer@Ogre@@QAEIXZ
	add	eax, DWORD PTR _offset$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pool$[ebp]
	call	?getSysBuf@D3DVertexBufferPool@Ogre@@QAEPAUIDirect3DVertexBuffer9@@XZ ; Ogre::D3DVertexBufferPool::getSysBuf
	push	eax
	push	0
	mov	eax, DWORD PTR _pdevice$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _pdevice$[ebp]
	push	edx
	mov	eax, DWORD PTR [ecx+400]
	call	eax

; 182  : 		pdevice->SetStreamSource(1, NULL, 0, 0);

	push	0
	push	0
	push	0
	push	1
	mov	ecx, DWORD PTR _pdevice$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _pdevice$[ebp]
	push	eax
	mov	ecx, DWORD PTR [edx+400]
	call	ecx

; 183  : 
; 184  : 		pdevice->SetVertexDeclaration(((D3D9VertexDecl *)vertdecl)->m_pVertDecl);

	mov	edx, DWORD PTR _vertdecl$[ebp]
	mov	eax, DWORD PTR [edx+28]
	push	eax
	mov	ecx, DWORD PTR _pdevice$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _pdevice$[ebp]
	push	eax
	mov	ecx, DWORD PTR [edx+348]
	call	ecx

; 185  : 	}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?setStreamInput@D3DTech@Ogre@@UAEXIPAVHardwareVertexBuffer@2@I@Z ENDP ; Ogre::D3DTech::setStreamInput
_TEXT	ENDS
EXTRN	__imp_?getSingletonPtr@?$Singleton@VRenderSystem@Ogre@@@Ogre@@SAPAVRenderSystem@2@XZ:PROC
; Function compile flags: /Odtp
_TEXT	SEGMENT
_this$ = -16						; size = 4
_pdevice$ = -12						; size = 4
_d3dprimtype$ = -8					; size = 4
_stats$ = -4						; size = 4
_primtype$ = 8						; size = 4
_start_vert$ = 12					; size = 4
_nprimitive$ = 16					; size = 4
?draw@D3DTech@Ogre@@UAEXW4PrimitiveType@2@II@Z PROC	; Ogre::D3DTech::draw
; _this$ = ecx

; 210  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 211  : 		D3DPRIMITIVETYPE d3dprimtype = Topo2D3DPrim(primtype);

	mov	eax, DWORD PTR _primtype$[ebp]
	push	eax
	call	?Topo2D3DPrim@Ogre@@YA?AW4_D3DPRIMITIVETYPE@@W4PrimitiveType@1@@Z ; Ogre::Topo2D3DPrim
	add	esp, 4
	mov	DWORD PTR _d3dprimtype$[ebp], eax

; 212  : 		IDirect3DDevice9 *pdevice = m_pDevice;

	mov	ecx, DWORD PTR ?m_pDevice@D3DTech@Ogre@@2PAUIDirect3DDevice9@@A ; Ogre::D3DTech::m_pDevice
	mov	DWORD PTR _pdevice$[ebp], ecx

; 213  : 
; 214  : 		pdevice->DrawPrimitive(d3dprimtype, (UINT)start_vert, (UINT)nprimitive);

	mov	edx, DWORD PTR _nprimitive$[ebp]
	push	edx
	mov	eax, DWORD PTR _start_vert$[ebp]
	push	eax
	mov	ecx, DWORD PTR _d3dprimtype$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pdevice$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _pdevice$[ebp]
	push	ecx
	mov	edx, DWORD PTR [eax+324]
	call	edx

; 215  : 
; 216  : 		RenderSystem::RenderStats &stats = static_cast<D3D9RenderSystem *>(RenderSystem::getSingletonPtr())->m_RenderStats;

	call	DWORD PTR __imp_?getSingletonPtr@?$Singleton@VRenderSystem@Ogre@@@Ogre@@SAPAVRenderSystem@2@XZ
	add	eax, 4
	mov	DWORD PTR _stats$[ebp], eax

; 217  : 		stats.ndraw_d++;

	mov	eax, DWORD PTR _stats$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	add	ecx, 1
	mov	edx, DWORD PTR _stats$[ebp]
	mov	DWORD PTR [edx+28], ecx

; 218  : 		stats.nprimitive_d += nprimitive;

	mov	eax, DWORD PTR _stats$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	add	ecx, DWORD PTR _nprimitive$[ebp]
	mov	edx, DWORD PTR _stats$[ebp]
	mov	DWORD PTR [edx+24], ecx

; 219  : 	}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?draw@D3DTech@Ogre@@UAEXW4PrimitiveType@2@II@Z ENDP	; Ogre::D3DTech::draw
; Function compile flags: /Odtp
tv64 = -4						; size = 4
_topo$ = 8						; size = 4
?Topo2D3DPrim@Ogre@@YA?AW4_D3DPRIMITIVETYPE@@W4PrimitiveType@1@@Z PROC ; Ogre::Topo2D3DPrim

; 188  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 189  : 		switch(topo)

	mov	eax, DWORD PTR _topo$[ebp]
	mov	DWORD PTR tv64[ebp], eax
	mov	ecx, DWORD PTR tv64[ebp]
	sub	ecx, 1
	mov	DWORD PTR tv64[ebp], ecx
	cmp	DWORD PTR tv64[ebp], 5
	ja	SHORT $LN1@Topo2D3DPr
	mov	edx, DWORD PTR tv64[ebp]
	jmp	DWORD PTR $LN12@Topo2D3DPr[edx*4]
$LN7@Topo2D3DPr:

; 190  : 		{
; 191  : 		case PRIM_POINTLIST:
; 192  : 			return D3DPT_POINTLIST;

	mov	eax, 1
	jmp	SHORT $LN10@Topo2D3DPr
$LN6@Topo2D3DPr:

; 193  : 		case PRIM_LINELIST:
; 194  : 			return D3DPT_LINELIST;

	mov	eax, 2
	jmp	SHORT $LN10@Topo2D3DPr
$LN5@Topo2D3DPr:

; 195  : 		case PRIM_LINESTRIP:
; 196  : 			return D3DPT_LINESTRIP;

	mov	eax, 3
	jmp	SHORT $LN10@Topo2D3DPr
$LN4@Topo2D3DPr:

; 197  : 		case PRIM_TRIANGLELIST:
; 198  : 			return D3DPT_TRIANGLELIST;

	mov	eax, 4
	jmp	SHORT $LN10@Topo2D3DPr
$LN3@Topo2D3DPr:

; 199  : 		case PRIM_TRIANGLESTRIP:
; 200  : 			return D3DPT_TRIANGLESTRIP;

	mov	eax, 5
	jmp	SHORT $LN10@Topo2D3DPr
$LN2@Topo2D3DPr:

; 201  : 		case PRIM_TRIANGLEFAN:
; 202  : 			return D3DPT_TRIANGLEFAN;

	mov	eax, 6
	jmp	SHORT $LN10@Topo2D3DPr
$LN1@Topo2D3DPr:

; 203  : 		default:
; 204  : 			assert(0);
; 205  : 			return D3DPT_POINTLIST;

	mov	eax, 1
$LN10@Topo2D3DPr:

; 206  : 		}
; 207  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
	npad	2
$LN12@Topo2D3DPr:
	DD	$LN7@Topo2D3DPr
	DD	$LN6@Topo2D3DPr
	DD	$LN5@Topo2D3DPr
	DD	$LN4@Topo2D3DPr
	DD	$LN3@Topo2D3DPr
	DD	$LN2@Topo2D3DPr
?Topo2D3DPrim@Ogre@@YA?AW4_D3DPRIMITIVETYPE@@W4PrimitiveType@1@@Z ENDP ; Ogre::Topo2D3DPrim
_TEXT	ENDS
PUBLIC	?getSysBuf@D3DIndexBufferPool@Ogre@@QAEPAUIDirect3DIndexBuffer9@@XZ ; Ogre::D3DIndexBufferPool::getSysBuf
EXTRN	__imp_?getStartIndex@HardwareIndexBuffer@Ogre@@QAEIXZ:PROC
; Function compile flags: /Odtp
_TEXT	SEGMENT
_this$ = -16						; size = 4
_pdevice$ = -12						; size = 4
_d3dprimtype$ = -8					; size = 4
_stats$ = -4						; size = 4
_primtype$ = 8						; size = 4
_start_vert$ = 12					; size = 4
_nprimitive$ = 16					; size = 4
_pib$ = 20						; size = 4
_refvert_start$ = 24					; size = 4
_refvert_num$ = 28					; size = 4
?draw@D3DTech@Ogre@@UAEXW4PrimitiveType@2@IIPAVHardwareIndexBuffer@2@II@Z PROC ; Ogre::D3DTech::draw
; _this$ = ecx

; 222  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 223  : 		D3DPRIMITIVETYPE d3dprimtype = Topo2D3DPrim(primtype);

	mov	eax, DWORD PTR _primtype$[ebp]
	push	eax
	call	?Topo2D3DPrim@Ogre@@YA?AW4_D3DPRIMITIVETYPE@@W4PrimitiveType@1@@Z ; Ogre::Topo2D3DPrim
	add	esp, 4
	mov	DWORD PTR _d3dprimtype$[ebp], eax

; 224  : 		IDirect3DDevice9 *pdevice = m_pDevice;

	mov	ecx, DWORD PTR ?m_pDevice@D3DTech@Ogre@@2PAUIDirect3DDevice9@@A ; Ogre::D3DTech::m_pDevice
	mov	DWORD PTR _pdevice$[ebp], ecx

; 225  : 
; 226  : 		pdevice->SetIndices(static_cast<D3DIndexBufferPool *>(pib->getPool())->getSysBuf());

	mov	ecx, DWORD PTR _pib$[ebp]
	call	DWORD PTR __imp_?getPool@HardwareBuffer@Ogre@@QAEPAVHardwareBufferPool@2@XZ
	mov	ecx, eax
	call	?getSysBuf@D3DIndexBufferPool@Ogre@@QAEPAUIDirect3DIndexBuffer9@@XZ ; Ogre::D3DIndexBufferPool::getSysBuf
	push	eax
	mov	edx, DWORD PTR _pdevice$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _pdevice$[ebp]
	push	ecx
	mov	edx, DWORD PTR [eax+416]
	call	edx

; 227  : 		pdevice->DrawIndexedPrimitive(d3dprimtype, 0, (UINT)refvert_start, (UINT)refvert_num, (UINT)(pib->getStartIndex()+start_vert), (UINT)nprimitive);

	mov	eax, DWORD PTR _nprimitive$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pib$[ebp]
	call	DWORD PTR __imp_?getStartIndex@HardwareIndexBuffer@Ogre@@QAEIXZ
	add	eax, DWORD PTR _start_vert$[ebp]
	push	eax
	mov	ecx, DWORD PTR _refvert_num$[ebp]
	push	ecx
	mov	edx, DWORD PTR _refvert_start$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _d3dprimtype$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pdevice$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _pdevice$[ebp]
	push	eax
	mov	ecx, DWORD PTR [edx+328]
	call	ecx

; 228  : 
; 229  : 		RenderSystem::RenderStats &stats = static_cast<D3D9RenderSystem *>(RenderSystem::getSingletonPtr())->m_RenderStats;

	call	DWORD PTR __imp_?getSingletonPtr@?$Singleton@VRenderSystem@Ogre@@@Ogre@@SAPAVRenderSystem@2@XZ
	add	eax, 4
	mov	DWORD PTR _stats$[ebp], eax

; 230  : 		stats.ndraw_d++;

	mov	edx, DWORD PTR _stats$[ebp]
	mov	eax, DWORD PTR [edx+28]
	add	eax, 1
	mov	ecx, DWORD PTR _stats$[ebp]
	mov	DWORD PTR [ecx+28], eax

; 231  : 		stats.nprimitive_d += nprimitive;

	mov	edx, DWORD PTR _stats$[ebp]
	mov	eax, DWORD PTR [edx+24]
	add	eax, DWORD PTR _nprimitive$[ebp]
	mov	ecx, DWORD PTR _stats$[ebp]
	mov	DWORD PTR [ecx+24], eax

; 232  : 	}

	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
?draw@D3DTech@Ogre@@UAEXW4PrimitiveType@2@IIPAVHardwareIndexBuffer@2@II@Z ENDP ; Ogre::D3DTech::draw
; Function compile flags: /Odtp
; File i:\svnroot\client\plugins\rendersystem_d3d9\ogred3d9hardwarebuffer.h
_TEXT	ENDS
;	COMDAT ?getSysBuf@D3DIndexBufferPool@Ogre@@QAEPAUIDirect3DIndexBuffer9@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getSysBuf@D3DIndexBufferPool@Ogre@@QAEPAUIDirect3DIndexBuffer9@@XZ PROC ; Ogre::D3DIndexBufferPool::getSysBuf, COMDAT
; _this$ = ecx

; 59   : 		IDirect3DIndexBuffer9 *getSysBuf(){ return m_pSysBuf; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+52]
	mov	esp, ebp
	pop	ebp
	ret	0
?getSysBuf@D3DIndexBufferPool@Ogre@@QAEPAUIDirect3DIndexBuffer9@@XZ ENDP ; Ogre::D3DIndexBufferPool::getSysBuf
_TEXT	ENDS
EXTRN	__fltused:DWORD
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogremath.h
;	COMDAT ??__ETWO_PI@Ogre@@YAXXZ
text$yc	SEGMENT
??__ETWO_PI@Ogre@@YAXXZ PROC				; Ogre::`dynamic initializer for 'TWO_PI'', COMDAT

; 10   : 	const float TWO_PI = ONE_PI*2;

	push	ebp
	mov	ebp, esp
	fld	DWORD PTR _ONE_PI
	fadd	ST(0), ST(0)
	fstp	DWORD PTR _TWO_PI
	pop	ebp
	ret	0
??__ETWO_PI@Ogre@@YAXXZ ENDP				; Ogre::`dynamic initializer for 'TWO_PI''
text$yc	ENDS
PUBLIC	__real@3fe0000000000000
;	COMDAT __real@3fe0000000000000
CONST	SEGMENT
__real@3fe0000000000000 DQ 03fe0000000000000r	; 0.5
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ??__EHALF_PI@Ogre@@YAXXZ
text$yc	SEGMENT
??__EHALF_PI@Ogre@@YAXXZ PROC				; Ogre::`dynamic initializer for 'HALF_PI'', COMDAT

; 11   : 	const float	HALF_PI = ONE_PI*0.5f;

	push	ebp
	mov	ebp, esp
	fld	DWORD PTR _ONE_PI
	fmul	QWORD PTR __real@3fe0000000000000
	fstp	DWORD PTR _HALF_PI
	pop	ebp
	ret	0
??__EHALF_PI@Ogre@@YAXXZ ENDP				; Ogre::`dynamic initializer for 'HALF_PI''
text$yc	ENDS
_BSS	SEGMENT
_TWO_PI	DD	01H DUP (?)
_HALF_PI DD	01H DUP (?)
_BSS	ENDS
CRT$XCU	SEGMENT
_TWO_PI$initializer$ DD FLAT:??__ETWO_PI@Ogre@@YAXXZ
_HALF_PI$initializer$ DD FLAT:??__EHALF_PI@Ogre@@YAXXZ
CRT$XCU	ENDS
END

; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	i:\svnroot\client\Plugins\RenderSystem_D3D9\OgreD3DHardwareBuffer.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	?_Value@?$_Is_swap_move@U_Swap_move_tag@std@@@std@@2_NB ; std::_Is_swap_move<std::_Swap_move_tag>::_Value
PUBLIC	?collate@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::collate
PUBLIC	?ctype@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::ctype
PUBLIC	?monetary@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::monetary
PUBLIC	?numeric@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::numeric
PUBLIC	?time@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::time
PUBLIC	?messages@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::messages
PUBLIC	?all@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::all
PUBLIC	?none@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::none
PUBLIC	?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::skipws
PUBLIC	?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::unitbuf
PUBLIC	?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::uppercase
PUBLIC	?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showbase
PUBLIC	?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpoint
PUBLIC	?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpos
PUBLIC	?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::left
PUBLIC	?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::right
PUBLIC	?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::internal
PUBLIC	?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::dec
PUBLIC	?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::oct
PUBLIC	?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::hex
PUBLIC	?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::scientific
PUBLIC	?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::fixed
PUBLIC	?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::hexfloat
PUBLIC	?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::boolalpha
PUBLIC	?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::_Stdio
PUBLIC	?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::adjustfield
PUBLIC	?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::basefield
PUBLIC	?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::floatfield
PUBLIC	?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::goodbit
PUBLIC	?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::eofbit
PUBLIC	?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::failbit
PUBLIC	?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::badbit
PUBLIC	?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::_Hardfail
PUBLIC	?in@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::in
PUBLIC	?out@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::out
PUBLIC	?ate@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::ate
PUBLIC	?app@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::app
PUBLIC	?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::trunc
PUBLIC	?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Nocreate
PUBLIC	?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Noreplace
PUBLIC	?binary@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::binary
PUBLIC	?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::beg
PUBLIC	?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::cur
PUBLIC	?end@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::end
PUBLIC	?value@?$integral_constant@_N$0A@@tr1@std@@2_NB	; std::tr1::integral_constant<bool,0>::value
PUBLIC	?value@?$integral_constant@_N$00@tr1@std@@2_NB	; std::tr1::integral_constant<bool,1>::value
;	COMDAT ?value@?$integral_constant@_N$00@tr1@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$00@tr1@std@@2_NB DB 01H	; std::tr1::integral_constant<bool,1>::value
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$0A@@tr1@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$0A@@tr1@std@@2_NB DB 00H	; std::tr1::integral_constant<bool,0>::value
CONST	ENDS
;	COMDAT ?end@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?end@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 02H		; std::_Iosb<int>::end
CONST	ENDS
;	COMDAT ?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 01H		; std::_Iosb<int>::cur
CONST	ENDS
;	COMDAT ?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 00H		; std::_Iosb<int>::beg
CONST	ENDS
;	COMDAT ?binary@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?binary@?$_Iosb@H@std@@2W4_Openmode@12@B DD 020H	; std::_Iosb<int>::binary
CONST	ENDS
;	COMDAT ?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B DD 080H	; std::_Iosb<int>::_Noreplace
CONST	ENDS
;	COMDAT ?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 040H	; std::_Iosb<int>::_Nocreate
CONST	ENDS
;	COMDAT ?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B DD 010H		; std::_Iosb<int>::trunc
CONST	ENDS
;	COMDAT ?app@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?app@?$_Iosb@H@std@@2W4_Openmode@12@B DD 08H		; std::_Iosb<int>::app
CONST	ENDS
;	COMDAT ?ate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?ate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 04H		; std::_Iosb<int>::ate
CONST	ENDS
;	COMDAT ?out@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?out@?$_Iosb@H@std@@2W4_Openmode@12@B DD 02H		; std::_Iosb<int>::out
CONST	ENDS
;	COMDAT ?in@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?in@?$_Iosb@H@std@@2W4_Openmode@12@B DD 01H		; std::_Iosb<int>::in
CONST	ENDS
;	COMDAT ?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B DD 010H	; std::_Iosb<int>::_Hardfail
CONST	ENDS
;	COMDAT ?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 04H		; std::_Iosb<int>::badbit
CONST	ENDS
;	COMDAT ?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 02H		; std::_Iosb<int>::failbit
CONST	ENDS
;	COMDAT ?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 01H		; std::_Iosb<int>::eofbit
CONST	ENDS
;	COMDAT ?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 00H		; std::_Iosb<int>::goodbit
CONST	ENDS
;	COMDAT ?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 03000H	; std::_Iosb<int>::floatfield
CONST	ENDS
;	COMDAT ?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0e00H	; std::_Iosb<int>::basefield
CONST	ENDS
;	COMDAT ?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01c0H	; std::_Iosb<int>::adjustfield
CONST	ENDS
;	COMDAT ?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08000H	; std::_Iosb<int>::_Stdio
CONST	ENDS
;	COMDAT ?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04000H	; std::_Iosb<int>::boolalpha
CONST	ENDS
;	COMDAT ?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 03000H	; std::_Iosb<int>::hexfloat
CONST	ENDS
;	COMDAT ?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02000H	; std::_Iosb<int>::fixed
CONST	ENDS
;	COMDAT ?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01000H	; std::_Iosb<int>::scientific
CONST	ENDS
;	COMDAT ?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0800H		; std::_Iosb<int>::hex
CONST	ENDS
;	COMDAT ?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0400H		; std::_Iosb<int>::oct
CONST	ENDS
;	COMDAT ?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0200H		; std::_Iosb<int>::dec
CONST	ENDS
;	COMDAT ?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0100H	; std::_Iosb<int>::internal
CONST	ENDS
;	COMDAT ?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 080H		; std::_Iosb<int>::right
CONST	ENDS
;	COMDAT ?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 040H		; std::_Iosb<int>::left
CONST	ENDS
;	COMDAT ?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 020H	; std::_Iosb<int>::showpos
CONST	ENDS
;	COMDAT ?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 010H	; std::_Iosb<int>::showpoint
CONST	ENDS
;	COMDAT ?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08H	; std::_Iosb<int>::showbase
CONST	ENDS
;	COMDAT ?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04H	; std::_Iosb<int>::uppercase
CONST	ENDS
;	COMDAT ?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02H	; std::_Iosb<int>::unitbuf
CONST	ENDS
;	COMDAT ?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01H		; std::_Iosb<int>::skipws
CONST	ENDS
;	COMDAT ?none@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?none@?$_Locbase@H@std@@2HB DD 00H			; std::_Locbase<int>::none
CONST	ENDS
;	COMDAT ?all@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?all@?$_Locbase@H@std@@2HB DD 03fH			; std::_Locbase<int>::all
CONST	ENDS
;	COMDAT ?messages@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?messages@?$_Locbase@H@std@@2HB DD 020H			; std::_Locbase<int>::messages
CONST	ENDS
;	COMDAT ?time@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?time@?$_Locbase@H@std@@2HB DD 010H			; std::_Locbase<int>::time
CONST	ENDS
;	COMDAT ?numeric@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?numeric@?$_Locbase@H@std@@2HB DD 08H			; std::_Locbase<int>::numeric
CONST	ENDS
;	COMDAT ?monetary@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?monetary@?$_Locbase@H@std@@2HB DD 04H			; std::_Locbase<int>::monetary
CONST	ENDS
;	COMDAT ?ctype@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?ctype@?$_Locbase@H@std@@2HB DD 02H			; std::_Locbase<int>::ctype
CONST	ENDS
;	COMDAT ?collate@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?collate@?$_Locbase@H@std@@2HB DD 01H			; std::_Locbase<int>::collate
CONST	ENDS
;	COMDAT ?_Value@?$_Is_swap_move@U_Swap_move_tag@std@@@std@@2_NB
CONST	SEGMENT
?_Value@?$_Is_swap_move@U_Swap_move_tag@std@@@std@@2_NB DB 01H ; std::_Is_swap_move<std::_Swap_move_tag>::_Value
CONST	ENDS
_DATA	SEGMENT
__bad_alloc_Message DD FLAT:$SG5714
_DATA	ENDS
CONST	SEGMENT
$SG5714	DB	'bad allocation', 00H
	ORG $+1
$SG128295 DB	'.\OgreD3DHardwareBuffer.cpp', 00H
$SG128296 DB	'D3DVertexBufferPool::onLostDevice--49', 00H
	ORG $+2
$SG128362 DB	'.\OgreD3DHardwareBuffer.cpp', 00H
$SG128363 DB	'D3DIndexBufferPool::onLostDevice--140', 00H
CONST	ENDS
PUBLIC	??1D3D9BufferPool@Ogre@@UAE@XZ			; Ogre::D3D9BufferPool::~D3D9BufferPool
PUBLIC	?getCreateFlags@D3D9RenderSystem@Ogre@@QAEKXZ	; Ogre::D3D9RenderSystem::getCreateFlags
PUBLIC	??_7D3DVertexBufferPool@Ogre@@6B@		; Ogre::D3DVertexBufferPool::`vftable'
PUBLIC	??0D3D9BufferPool@Ogre@@QAE@_NI0@Z		; Ogre::D3D9BufferPool::D3D9BufferPool
PUBLIC	??0D3DVertexBufferPool@Ogre@@QAE@PAVD3D9RenderSystem@1@W4HardwareBufferUsage@1@I@Z ; Ogre::D3DVertexBufferPool::D3DVertexBufferPool
PUBLIC	??_R4D3DVertexBufferPool@Ogre@@6B@		; Ogre::D3DVertexBufferPool::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVD3DVertexBufferPool@Ogre@@@8		; Ogre::D3DVertexBufferPool `RTTI Type Descriptor'
PUBLIC	??_R3D3DVertexBufferPool@Ogre@@8		; Ogre::D3DVertexBufferPool::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2D3DVertexBufferPool@Ogre@@8		; Ogre::D3DVertexBufferPool::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@D3DVertexBufferPool@Ogre@@8	; Ogre::D3DVertexBufferPool::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@D3D9BufferPool@Ogre@@8		; Ogre::D3D9BufferPool::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVD3D9BufferPool@Ogre@@@8			; Ogre::D3D9BufferPool `RTTI Type Descriptor'
PUBLIC	??_R3D3D9BufferPool@Ogre@@8			; Ogre::D3D9BufferPool::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2D3D9BufferPool@Ogre@@8			; Ogre::D3D9BufferPool::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@HardwareBufferPool@Ogre@@8	; Ogre::HardwareBufferPool::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVHardwareBufferPool@Ogre@@@8		; Ogre::HardwareBufferPool `RTTI Type Descriptor'
PUBLIC	??_R3HardwareBufferPool@Ogre@@8			; Ogre::HardwareBufferPool::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2HardwareBufferPool@Ogre@@8			; Ogre::HardwareBufferPool::`RTTI Base Class Array'
PUBLIC	?lock@D3DVertexBufferPool@Ogre@@UAEPAXIIW4HardwareBufferLockOpt@2@@Z ; Ogre::D3DVertexBufferPool::lock
PUBLIC	?unlock@D3DVertexBufferPool@Ogre@@UAEXXZ	; Ogre::D3DVertexBufferPool::unlock
PUBLIC	?create@D3DVertexBufferPool@Ogre@@UAE_NXZ	; Ogre::D3DVertexBufferPool::create
PUBLIC	?onLostDevice@D3DVertexBufferPool@Ogre@@UAEXXZ	; Ogre::D3DVertexBufferPool::onLostDevice
PUBLIC	?onResetDevice@D3DVertexBufferPool@Ogre@@UAE_NXZ ; Ogre::D3DVertexBufferPool::onResetDevice
EXTRN	?hbu2PoolUsage@D3D9RenderSystem@Ogre@@QAEXAAKAAW4_D3DPOOL@@W4HardwareBufferUsage@2@@Z:PROC ; Ogre::D3D9RenderSystem::hbu2PoolUsage
EXTRN	___security_cookie:DWORD
EXTRN	___CxxFrameHandler3:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	??_ED3DVertexBufferPool@Ogre@@UAEPAXI@Z:PROC	; Ogre::D3DVertexBufferPool::`vector deleting destructor'
;	COMDAT ??_R2HardwareBufferPool@Ogre@@8
; File i:\svnroot\client\plugins\rendersystem_d3d9\ogred3dhardwarebuffer.cpp
rdata$r	SEGMENT
??_R2HardwareBufferPool@Ogre@@8 DD FLAT:??_R1A@?0A@EA@HardwareBufferPool@Ogre@@8 ; Ogre::HardwareBufferPool::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3HardwareBufferPool@Ogre@@8
rdata$r	SEGMENT
??_R3HardwareBufferPool@Ogre@@8 DD 00H			; Ogre::HardwareBufferPool::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2HardwareBufferPool@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVHardwareBufferPool@Ogre@@@8
_DATA	SEGMENT
??_R0?AVHardwareBufferPool@Ogre@@@8 DD FLAT:??_7type_info@@6B@ ; Ogre::HardwareBufferPool `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVHardwareBufferPool@Ogre@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@HardwareBufferPool@Ogre@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@HardwareBufferPool@Ogre@@8 DD FLAT:??_R0?AVHardwareBufferPool@Ogre@@@8 ; Ogre::HardwareBufferPool::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3HardwareBufferPool@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R2D3D9BufferPool@Ogre@@8
rdata$r	SEGMENT
??_R2D3D9BufferPool@Ogre@@8 DD FLAT:??_R1A@?0A@EA@D3D9BufferPool@Ogre@@8 ; Ogre::D3D9BufferPool::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@HardwareBufferPool@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R3D3D9BufferPool@Ogre@@8
rdata$r	SEGMENT
??_R3D3D9BufferPool@Ogre@@8 DD 00H			; Ogre::D3D9BufferPool::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2D3D9BufferPool@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVD3D9BufferPool@Ogre@@@8
_DATA	SEGMENT
??_R0?AVD3D9BufferPool@Ogre@@@8 DD FLAT:??_7type_info@@6B@ ; Ogre::D3D9BufferPool `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVD3D9BufferPool@Ogre@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@D3D9BufferPool@Ogre@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@D3D9BufferPool@Ogre@@8 DD FLAT:??_R0?AVD3D9BufferPool@Ogre@@@8 ; Ogre::D3D9BufferPool::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3D3D9BufferPool@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@D3DVertexBufferPool@Ogre@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@D3DVertexBufferPool@Ogre@@8 DD FLAT:??_R0?AVD3DVertexBufferPool@Ogre@@@8 ; Ogre::D3DVertexBufferPool::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3D3DVertexBufferPool@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R2D3DVertexBufferPool@Ogre@@8
rdata$r	SEGMENT
??_R2D3DVertexBufferPool@Ogre@@8 DD FLAT:??_R1A@?0A@EA@D3DVertexBufferPool@Ogre@@8 ; Ogre::D3DVertexBufferPool::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@D3D9BufferPool@Ogre@@8
	DD	FLAT:??_R1A@?0A@EA@HardwareBufferPool@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R3D3DVertexBufferPool@Ogre@@8
rdata$r	SEGMENT
??_R3D3DVertexBufferPool@Ogre@@8 DD 00H			; Ogre::D3DVertexBufferPool::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2D3DVertexBufferPool@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVD3DVertexBufferPool@Ogre@@@8
_DATA	SEGMENT
??_R0?AVD3DVertexBufferPool@Ogre@@@8 DD FLAT:??_7type_info@@6B@ ; Ogre::D3DVertexBufferPool `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVD3DVertexBufferPool@Ogre@@', 00H
_DATA	ENDS
;	COMDAT ??_R4D3DVertexBufferPool@Ogre@@6B@
rdata$r	SEGMENT
??_R4D3DVertexBufferPool@Ogre@@6B@ DD 00H		; Ogre::D3DVertexBufferPool::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVD3DVertexBufferPool@Ogre@@@8
	DD	FLAT:??_R3D3DVertexBufferPool@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_7D3DVertexBufferPool@Ogre@@6B@
CONST	SEGMENT
??_7D3DVertexBufferPool@Ogre@@6B@ DD FLAT:??_R4D3DVertexBufferPool@Ogre@@6B@ ; Ogre::D3DVertexBufferPool::`vftable'
	DD	FLAT:??_ED3DVertexBufferPool@Ogre@@UAEPAXI@Z
	DD	FLAT:?lock@D3DVertexBufferPool@Ogre@@UAEPAXIIW4HardwareBufferLockOpt@2@@Z
	DD	FLAT:?unlock@D3DVertexBufferPool@Ogre@@UAEXXZ
	DD	FLAT:?create@D3DVertexBufferPool@Ogre@@UAE_NXZ
	DD	FLAT:?onLostDevice@D3DVertexBufferPool@Ogre@@UAEXXZ
	DD	FLAT:?onResetDevice@D3DVertexBufferPool@Ogre@@UAE_NXZ
CONST	ENDS
xdata$x	SEGMENT
__unwindtable$??0D3DVertexBufferPool@Ogre@@QAE@PAVD3D9RenderSystem@1@W4HardwareBufferUsage@1@I@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0D3DVertexBufferPool@Ogre@@QAE@PAVD3D9RenderSystem@1@W4HardwareBufferUsage@1@I@Z$0
__ehfuncinfo$??0D3DVertexBufferPool@Ogre@@QAE@PAVD3D9RenderSystem@1@W4HardwareBufferUsage@1@I@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0D3DVertexBufferPool@Ogre@@QAE@PAVD3D9RenderSystem@1@W4HardwareBufferUsage@1@I@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_prs$ = 8						; size = 4
_usage$ = 12						; size = 4
_nbytes$ = 16						; size = 4
??0D3DVertexBufferPool@Ogre@@QAE@PAVD3D9RenderSystem@1@W4HardwareBufferUsage@1@I@Z PROC ; Ogre::D3DVertexBufferPool::D3DVertexBufferPool
; _this$ = ecx

; 10   : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0D3DVertexBufferPool@Ogre@@QAE@PAVD3D9RenderSystem@1@W4HardwareBufferUsage@1@I@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	cmp	DWORD PTR _usage$[ebp], 2
	sete	al
	movzx	ecx, al
	push	ecx
	mov	edx, DWORD PTR _nbytes$[ebp]
	push	edx
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0D3D9BufferPool@Ogre@@QAE@_NI0@Z	; Ogre::D3D9BufferPool::D3D9BufferPool
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7D3DVertexBufferPool@Ogre@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _prs$[ebp]
	mov	DWORD PTR [ecx+48], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+52], 0

; 11   : 		m_pRS->hbu2PoolUsage(m_Usage, m_Pool, usage);

	mov	ecx, DWORD PTR _usage$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 56					; 00000038H
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 60					; 0000003cH
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+48]
	call	?hbu2PoolUsage@D3D9RenderSystem@Ogre@@QAEXAAKAAW4_D3DPOOL@@W4HardwareBufferUsage@2@@Z ; Ogre::D3D9RenderSystem::hbu2PoolUsage

; 12   : 
; 13   : 		if(m_Pool == D3DPOOL_DEFAULT) m_Usage |= D3DUSAGE_WRITEONLY;

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+56], 0
	jne	SHORT $LN2@D3DVertexB
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	or	ecx, 8
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+60], ecx
$LN2@D3DVertexB:

; 14   : 		if((m_pRS->getCreateFlags()&D3DCREATE_HARDWARE_VERTEXPROCESSING) == 0)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	call	?getCreateFlags@D3D9RenderSystem@Ogre@@QAEKXZ ; Ogre::D3D9RenderSystem::getCreateFlags
	and	eax, 64					; 00000040H
	jne	SHORT $LN3@D3DVertexB

; 15   : 		{
; 16   : 			m_Usage |= D3DUSAGE_SOFTWAREPROCESSING;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+60]
	or	edx, 16					; 00000010H
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+60], edx
$LN3@D3DVertexB:

; 17   : 		}
; 18   : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$??0D3DVertexBufferPool@Ogre@@QAE@PAVD3D9RenderSystem@1@W4HardwareBufferUsage@1@I@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1D3D9BufferPool@Ogre@@UAE@XZ		; Ogre::D3D9BufferPool::~D3D9BufferPool
__ehhandler$??0D3DVertexBufferPool@Ogre@@QAE@PAVD3D9RenderSystem@1@W4HardwareBufferUsage@1@I@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0D3DVertexBufferPool@Ogre@@QAE@PAVD3D9RenderSystem@1@W4HardwareBufferUsage@1@I@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0D3DVertexBufferPool@Ogre@@QAE@PAVD3D9RenderSystem@1@W4HardwareBufferUsage@1@I@Z ENDP ; Ogre::D3DVertexBufferPool::D3DVertexBufferPool
PUBLIC	??_7D3D9BufferPool@Ogre@@6B@			; Ogre::D3D9BufferPool::`vftable'
PUBLIC	??_R4D3D9BufferPool@Ogre@@6B@			; Ogre::D3D9BufferPool::`RTTI Complete Object Locator'
EXTRN	__imp_??1HardwareBufferPool@Ogre@@UAE@XZ:PROC
EXTRN	__imp_??0HardwareBufferPool@Ogre@@QAE@_NI0@Z:PROC
EXTRN	??_ED3D9BufferPool@Ogre@@UAEPAXI@Z:PROC		; Ogre::D3D9BufferPool::`vector deleting destructor'
EXTRN	__purecall:PROC
;	COMDAT ??_R4D3D9BufferPool@Ogre@@6B@
; File i:\svnroot\client\plugins\rendersystem_d3d9\ogred3d9hardwarebuffer.h
rdata$r	SEGMENT
??_R4D3D9BufferPool@Ogre@@6B@ DD 00H			; Ogre::D3D9BufferPool::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVD3D9BufferPool@Ogre@@@8
	DD	FLAT:??_R3D3D9BufferPool@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_7D3D9BufferPool@Ogre@@6B@
CONST	SEGMENT
??_7D3D9BufferPool@Ogre@@6B@ DD FLAT:??_R4D3D9BufferPool@Ogre@@6B@ ; Ogre::D3D9BufferPool::`vftable'
	DD	FLAT:??_ED3D9BufferPool@Ogre@@UAEPAXI@Z
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0D3D9BufferPool@Ogre@@QAE@_NI0@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0D3D9BufferPool@Ogre@@QAE@_NI0@Z$0
__ehfuncinfo$??0D3D9BufferPool@Ogre@@QAE@_NI0@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0D3D9BufferPool@Ogre@@QAE@_NI0@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0D3D9BufferPool@Ogre@@QAE@_NI0@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_is_vbuffer$ = 8					; size = 1
_poolsize$ = 12						; size = 4
_bdynamic$ = 16						; size = 1
??0D3D9BufferPool@Ogre@@QAE@_NI0@Z PROC			; Ogre::D3D9BufferPool::D3D9BufferPool, COMDAT
; _this$ = ecx

; 14   : 		{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0D3D9BufferPool@Ogre@@QAE@_NI0@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	movzx	eax, BYTE PTR _bdynamic$[ebp]
	push	eax
	mov	ecx, DWORD PTR _poolsize$[ebp]
	push	ecx
	movzx	edx, BYTE PTR _is_vbuffer$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0HardwareBufferPool@Ogre@@QAE@_NI0@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7D3D9BufferPool@Ogre@@6B@

; 15   : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0D3D9BufferPool@Ogre@@QAE@_NI0@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1HardwareBufferPool@Ogre@@UAE@XZ
__ehhandler$??0D3D9BufferPool@Ogre@@QAE@_NI0@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0D3D9BufferPool@Ogre@@QAE@_NI0@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0D3D9BufferPool@Ogre@@QAE@_NI0@Z ENDP			; Ogre::D3D9BufferPool::D3D9BufferPool
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1D3D9BufferPool@Ogre@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1D3D9BufferPool@Ogre@@UAE@XZ$0
__ehfuncinfo$??1D3D9BufferPool@Ogre@@UAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1D3D9BufferPool@Ogre@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1D3D9BufferPool@Ogre@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1D3D9BufferPool@Ogre@@UAE@XZ PROC			; Ogre::D3D9BufferPool::~D3D9BufferPool, COMDAT
; _this$ = ecx

; 17   : 		virtual ~D3D9BufferPool(){}

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1D3D9BufferPool@Ogre@@UAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7D3D9BufferPool@Ogre@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1HardwareBufferPool@Ogre@@UAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1D3D9BufferPool@Ogre@@UAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1HardwareBufferPool@Ogre@@UAE@XZ
__ehhandler$??1D3D9BufferPool@Ogre@@UAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1D3D9BufferPool@Ogre@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1D3D9BufferPool@Ogre@@UAE@XZ ENDP			; Ogre::D3D9BufferPool::~D3D9BufferPool
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
; Function compile flags: /Odtp
;	COMDAT ??_GD3D9BufferPool@Ogre@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GD3D9BufferPool@Ogre@@UAEPAXI@Z PROC			; Ogre::D3D9BufferPool::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1D3D9BufferPool@Ogre@@UAE@XZ		; Ogre::D3D9BufferPool::~D3D9BufferPool
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GD3D9BufferPool@Ogre@@UAEPAXI@Z ENDP			; Ogre::D3D9BufferPool::`scalar deleting destructor'
; Function compile flags: /Odtp
; File i:\svnroot\client\plugins\rendersystem_d3d9\ogred3d9rendersystem.h
_TEXT	ENDS
;	COMDAT ?getCreateFlags@D3D9RenderSystem@Ogre@@QAEKXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getCreateFlags@D3D9RenderSystem@Ogre@@QAEKXZ PROC	; Ogre::D3D9RenderSystem::getCreateFlags, COMDAT
; _this$ = ecx

; 69   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 70   : 			return m_dwCreateFlags;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+412]

; 71   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?getCreateFlags@D3D9RenderSystem@Ogre@@QAEKXZ ENDP	; Ogre::D3D9RenderSystem::getCreateFlags
_TEXT	ENDS
PUBLIC	??1D3DVertexBufferPool@Ogre@@UAE@XZ		; Ogre::D3DVertexBufferPool::~D3DVertexBufferPool
; Function compile flags: /Odtp
;	COMDAT ??_GD3DVertexBufferPool@Ogre@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GD3DVertexBufferPool@Ogre@@UAEPAXI@Z PROC		; Ogre::D3DVertexBufferPool::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1D3DVertexBufferPool@Ogre@@UAE@XZ	; Ogre::D3DVertexBufferPool::~D3DVertexBufferPool
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@2
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@2:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GD3DVertexBufferPool@Ogre@@UAEPAXI@Z ENDP		; Ogre::D3DVertexBufferPool::`scalar deleting destructor'
_TEXT	ENDS
xdata$x	SEGMENT
__unwindtable$??1D3DVertexBufferPool@Ogre@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1D3DVertexBufferPool@Ogre@@UAE@XZ$0
__ehfuncinfo$??1D3DVertexBufferPool@Ogre@@UAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1D3DVertexBufferPool@Ogre@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
; File i:\svnroot\client\plugins\rendersystem_d3d9\ogred3dhardwarebuffer.cpp
xdata$x	ENDS
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1D3DVertexBufferPool@Ogre@@UAE@XZ PROC		; Ogre::D3DVertexBufferPool::~D3DVertexBufferPool
; _this$ = ecx

; 21   : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1D3DVertexBufferPool@Ogre@@UAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7D3DVertexBufferPool@Ogre@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 22   : 		SAFE_RELEASE(m_pSysBuf);

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+52], 0
	je	SHORT $LN2@D3DVertexB@2
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+52]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+52]
	mov	eax, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR [eax+8]
	call	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+52], 0
$LN2@D3DVertexB@2:

; 23   : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1D3D9BufferPool@Ogre@@UAE@XZ		; Ogre::D3D9BufferPool::~D3D9BufferPool
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$??1D3DVertexBufferPool@Ogre@@UAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1D3D9BufferPool@Ogre@@UAE@XZ		; Ogre::D3D9BufferPool::~D3D9BufferPool
__ehhandler$??1D3DVertexBufferPool@Ogre@@UAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1D3DVertexBufferPool@Ogre@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1D3DVertexBufferPool@Ogre@@UAE@XZ ENDP		; Ogre::D3DVertexBufferPool::~D3DVertexBufferPool
PUBLIC	?getD3DDevice@D3D9RenderSystem@Ogre@@QAEPAUIDirect3DDevice9@@XZ ; Ogre::D3D9RenderSystem::getD3DDevice
PUBLIC	?isDeviceLost@D3D9RenderSystem@Ogre@@QAE_NXZ	; Ogre::D3D9RenderSystem::isDeviceLost
; Function compile flags: /Odtp
_TEXT	SEGMENT
tv75 = -12						; size = 4
_this$ = -8						; size = 4
_hr$ = -4						; size = 4
?create@D3DVertexBufferPool@Ogre@@UAE_NXZ PROC		; Ogre::D3DVertexBufferPool::create
; _this$ = ecx

; 26   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 27   : 		if( m_Pool==D3DPOOL_DEFAULT && m_pRS->isDeviceLost() )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+56], 0
	jne	SHORT $LN3@create
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+48]
	call	?isDeviceLost@D3D9RenderSystem@Ogre@@QAE_NXZ ; Ogre::D3D9RenderSystem::isDeviceLost
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN3@create

; 28   : 		{
; 29   : 			return true;

	mov	al, 1
	jmp	SHORT $LN4@create
$LN3@create:

; 30   : 		}
; 31   : 
; 32   : 		HRESULT hr = m_pRS->getD3DDevice()->CreateVertexBuffer( (UINT)m_PoolSize, m_Usage, 0, m_Pool, &m_pSysBuf, NULL );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	call	?getD3DDevice@D3D9RenderSystem@Ogre@@QAEPAUIDirect3DDevice9@@XZ ; Ogre::D3D9RenderSystem::getD3DDevice
	mov	DWORD PTR tv75[ebp], eax
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 52					; 00000034H
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	push	eax
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+60]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	edx, DWORD PTR tv75[ebp]
	push	edx
	mov	eax, DWORD PTR tv75[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+104]
	call	edx
	mov	DWORD PTR _hr$[ebp], eax

; 33   : 		if( FAILED(hr) )

	cmp	DWORD PTR _hr$[ebp], 0
	jge	SHORT $LN2@create

; 34   : 		{
; 35   : 			m_pSysBuf = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+52], 0

; 36   : 			return false;

	xor	al, al
	jmp	SHORT $LN4@create
	jmp	SHORT $LN4@create
$LN2@create:

; 37   : 		}
; 38   : 		else return true;

	mov	al, 1
$LN4@create:

; 39   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?create@D3DVertexBufferPool@Ogre@@UAE_NXZ ENDP		; Ogre::D3DVertexBufferPool::create
; Function compile flags: /Odtp
; File i:\svnroot\client\plugins\rendersystem_d3d9\ogred3d9rendersystem.h
_TEXT	ENDS
;	COMDAT ?getD3DDevice@D3D9RenderSystem@Ogre@@QAEPAUIDirect3DDevice9@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getD3DDevice@D3D9RenderSystem@Ogre@@QAEPAUIDirect3DDevice9@@XZ PROC ; Ogre::D3D9RenderSystem::getD3DDevice, COMDAT
; _this$ = ecx

; 44   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 45   : 			return m_pd3dDevice;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+104]

; 46   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?getD3DDevice@D3D9RenderSystem@Ogre@@QAEPAUIDirect3DDevice9@@XZ ENDP ; Ogre::D3D9RenderSystem::getD3DDevice
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?isDeviceLost@D3D9RenderSystem@Ogre@@QAE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?isDeviceLost@D3D9RenderSystem@Ogre@@QAE_NXZ PROC	; Ogre::D3D9RenderSystem::isDeviceLost, COMDAT
; _this$ = ecx

; 59   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 60   : 			return m_bDeviceLost;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+417]

; 61   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?isDeviceLost@D3D9RenderSystem@Ogre@@QAE_NXZ ENDP	; Ogre::D3D9RenderSystem::isDeviceLost
_TEXT	ENDS
EXTRN	__imp_?LogMessage@Ogre@@YAXPBDZZ:PROC
EXTRN	__imp_?LogSetCurParam@Ogre@@YAXPBDHI@Z:PROC
; Function compile flags: /Odtp
; File i:\svnroot\client\plugins\rendersystem_d3d9\ogred3dhardwarebuffer.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?onLostDevice@D3DVertexBufferPool@Ogre@@UAEXXZ PROC	; Ogre::D3DVertexBufferPool::onLostDevice
; _this$ = ecx

; 42   : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 43   : 		if( m_Pool == D3DPOOL_DEFAULT )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+56], 0
	jne	SHORT $LN4@onLostDevi

; 44   : 		{
; 45   : 			//SAFE_RELEASE(m_pSysBuf);
; 46   : 			if ( m_pSysBuf != NULL )

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+52], 0
	je	SHORT $LN4@onLostDevi

; 47   : 			{
; 48   : 				if ( FAILED( m_pSysBuf->Release() ) )

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+52]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+52]
	mov	eax, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR [eax+8]
	call	ecx
	test	eax, eax
	jge	SHORT $LN1@onLostDevi

; 49   : 				{
; 50   : 					LOG_PRIVATE( "D3DVertexBufferPool::onLostDevice--49" );

	push	64					; 00000040H
	push	50					; 00000032H
	push	OFFSET $SG128295
	call	DWORD PTR __imp_?LogSetCurParam@Ogre@@YAXPBDHI@Z
	add	esp, 12					; 0000000cH
	push	OFFSET $SG128296
	call	DWORD PTR __imp_?LogMessage@Ogre@@YAXPBDZZ
	add	esp, 4
$LN1@onLostDevi:

; 51   : 				}
; 52   : 
; 53   : 				m_pSysBuf = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+52], 0
$LN4@onLostDevi:

; 54   : 			}
; 55   : 		}
; 56   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?onLostDevice@D3DVertexBufferPool@Ogre@@UAEXXZ ENDP	; Ogre::D3DVertexBufferPool::onLostDevice
; Function compile flags: /Odtp
_this$ = -4						; size = 4
?onResetDevice@D3DVertexBufferPool@Ogre@@UAE_NXZ PROC	; Ogre::D3DVertexBufferPool::onResetDevice
; _this$ = ecx

; 59   : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 60   : 		if( m_Pool == D3DPOOL_DEFAULT )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+56], 0
	jne	SHORT $LN2@onResetDev

; 61   : 		{
; 62   : 			return create();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	call	eax
	jmp	SHORT $LN3@onResetDev
	jmp	SHORT $LN3@onResetDev
$LN2@onResetDev:

; 63   : 		}
; 64   : 		else return true;

	mov	al, 1
$LN3@onResetDev:

; 65   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?onResetDevice@D3DVertexBufferPool@Ogre@@UAE_NXZ ENDP	; Ogre::D3DVertexBufferPool::onResetDevice
; Function compile flags: /Odtp
_this$ = -12						; size = 4
_pdata$ = -8						; size = 4
_d3dflags$ = -4						; size = 4
_start$ = 8						; size = 4
_nbytes$ = 12						; size = 4
_lockopt$ = 16						; size = 4
?lock@D3DVertexBufferPool@Ogre@@UAEPAXIIW4HardwareBufferLockOpt@2@@Z PROC ; Ogre::D3DVertexBufferPool::lock
; _this$ = ecx

; 83   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 84   : 		DWORD d3dflags = GetLockFlags(lockopt, m_Usage, start);

	mov	eax, DWORD PTR _start$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+60]
	push	edx
	mov	eax, DWORD PTR _lockopt$[ebp]
	push	eax
	call	?GetLockFlags@Ogre@@YAKW4HardwareBufferLockOpt@1@KI@Z ; Ogre::GetLockFlags
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _d3dflags$[ebp], eax

; 85   : 		void *pdata;
; 86   : 		if( SUCCEEDED(m_pSysBuf->Lock((UINT)(start), (UINT)(nbytes), &pdata, d3dflags)) )

	mov	ecx, DWORD PTR _d3dflags$[ebp]
	push	ecx
	lea	edx, DWORD PTR _pdata$[ebp]
	push	edx
	mov	eax, DWORD PTR _nbytes$[ebp]
	push	eax
	mov	ecx, DWORD PTR _start$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+52]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+52]
	mov	eax, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR [eax+44]
	call	ecx
	test	eax, eax
	jl	SHORT $LN2@lock

; 87   : 		{
; 88   : 			return pdata;

	mov	eax, DWORD PTR _pdata$[ebp]
	jmp	SHORT $LN3@lock
	jmp	SHORT $LN3@lock
$LN2@lock:

; 89   : 		}
; 90   : 		else return NULL;

	xor	eax, eax
$LN3@lock:

; 91   : 	}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?lock@D3DVertexBufferPool@Ogre@@UAEPAXIIW4HardwareBufferLockOpt@2@@Z ENDP ; Ogre::D3DVertexBufferPool::lock
; Function compile flags: /Odtp
_d3dflags$ = -4					; size = 4
_lockopt$ = 8						; size = 4
_d3dusage$ = 12						; size = 4
_lock_start$ = 16					; size = 4
?GetLockFlags@Ogre@@YAKW4HardwareBufferLockOpt@1@KI@Z PROC ; Ogre::GetLockFlags

; 68   : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 69   : 		DWORD d3dflags = 0;

	mov	DWORD PTR _d3dflags$[ebp], 0

; 70   : 		if(lockopt == HBL_READ_ONLY) d3dflags |= D3DLOCK_READONLY;

	cmp	DWORD PTR _lockopt$[ebp], 2
	jne	SHORT $LN5@GetLockFla
	mov	eax, DWORD PTR _d3dflags$[ebp]
	or	eax, 16					; 00000010H
	mov	DWORD PTR _d3dflags$[ebp], eax
	jmp	SHORT $LN4@GetLockFla
$LN5@GetLockFla:

; 71   : 		else if(d3dusage & D3DUSAGE_DYNAMIC)

	mov	ecx, DWORD PTR _d3dusage$[ebp]
	and	ecx, 512				; 00000200H
	je	SHORT $LN4@GetLockFla

; 72   : 		{
; 73   : 			if(lock_start == 0) 

	cmp	DWORD PTR _lock_start$[ebp], 0
	jne	SHORT $LN2@GetLockFla

; 74   : 				d3dflags |= D3DLOCK_DISCARD;

	mov	edx, DWORD PTR _d3dflags$[ebp]
	or	edx, 8192				; 00002000H
	mov	DWORD PTR _d3dflags$[ebp], edx

; 75   : 			else 

	jmp	SHORT $LN4@GetLockFla
$LN2@GetLockFla:

; 76   : 				d3dflags |= D3DLOCK_NOOVERWRITE;

	mov	eax, DWORD PTR _d3dflags$[ebp]
	or	eax, 4096				; 00001000H
	mov	DWORD PTR _d3dflags$[ebp], eax
$LN4@GetLockFla:

; 77   : 		}
; 78   : 
; 79   : 		return d3dflags;

	mov	eax, DWORD PTR _d3dflags$[ebp]

; 80   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?GetLockFlags@Ogre@@YAKW4HardwareBufferLockOpt@1@KI@Z ENDP ; Ogre::GetLockFlags
; Function compile flags: /Odtp
_this$ = -4						; size = 4
?unlock@D3DVertexBufferPool@Ogre@@UAEXXZ PROC		; Ogre::D3DVertexBufferPool::unlock
; _this$ = ecx

; 94   : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 95   : 		m_pSysBuf->Unlock();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+52]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	mov	edx, DWORD PTR [ecx+48]
	call	edx

; 96   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?unlock@D3DVertexBufferPool@Ogre@@UAEXXZ ENDP		; Ogre::D3DVertexBufferPool::unlock
_TEXT	ENDS
PUBLIC	??_7D3DIndexBufferPool@Ogre@@6B@		; Ogre::D3DIndexBufferPool::`vftable'
PUBLIC	??0D3DIndexBufferPool@Ogre@@QAE@PAVD3D9RenderSystem@1@W4HardwareBufferUsage@1@II@Z ; Ogre::D3DIndexBufferPool::D3DIndexBufferPool
PUBLIC	??_R4D3DIndexBufferPool@Ogre@@6B@		; Ogre::D3DIndexBufferPool::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVD3DIndexBufferPool@Ogre@@@8		; Ogre::D3DIndexBufferPool `RTTI Type Descriptor'
PUBLIC	??_R3D3DIndexBufferPool@Ogre@@8			; Ogre::D3DIndexBufferPool::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2D3DIndexBufferPool@Ogre@@8			; Ogre::D3DIndexBufferPool::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@D3DIndexBufferPool@Ogre@@8	; Ogre::D3DIndexBufferPool::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?lock@D3DIndexBufferPool@Ogre@@UAEPAXIIW4HardwareBufferLockOpt@2@@Z ; Ogre::D3DIndexBufferPool::lock
PUBLIC	?unlock@D3DIndexBufferPool@Ogre@@UAEXXZ		; Ogre::D3DIndexBufferPool::unlock
PUBLIC	?create@D3DIndexBufferPool@Ogre@@UAE_NXZ	; Ogre::D3DIndexBufferPool::create
PUBLIC	?onLostDevice@D3DIndexBufferPool@Ogre@@UAEXXZ	; Ogre::D3DIndexBufferPool::onLostDevice
PUBLIC	?onResetDevice@D3DIndexBufferPool@Ogre@@UAE_NXZ	; Ogre::D3DIndexBufferPool::onResetDevice
EXTRN	??_ED3DIndexBufferPool@Ogre@@UAEPAXI@Z:PROC	; Ogre::D3DIndexBufferPool::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@D3DIndexBufferPool@Ogre@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@D3DIndexBufferPool@Ogre@@8 DD FLAT:??_R0?AVD3DIndexBufferPool@Ogre@@@8 ; Ogre::D3DIndexBufferPool::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3D3DIndexBufferPool@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R2D3DIndexBufferPool@Ogre@@8
rdata$r	SEGMENT
??_R2D3DIndexBufferPool@Ogre@@8 DD FLAT:??_R1A@?0A@EA@D3DIndexBufferPool@Ogre@@8 ; Ogre::D3DIndexBufferPool::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@D3D9BufferPool@Ogre@@8
	DD	FLAT:??_R1A@?0A@EA@HardwareBufferPool@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R3D3DIndexBufferPool@Ogre@@8
rdata$r	SEGMENT
??_R3D3DIndexBufferPool@Ogre@@8 DD 00H			; Ogre::D3DIndexBufferPool::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2D3DIndexBufferPool@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVD3DIndexBufferPool@Ogre@@@8
_DATA	SEGMENT
??_R0?AVD3DIndexBufferPool@Ogre@@@8 DD FLAT:??_7type_info@@6B@ ; Ogre::D3DIndexBufferPool `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVD3DIndexBufferPool@Ogre@@', 00H
_DATA	ENDS
;	COMDAT ??_R4D3DIndexBufferPool@Ogre@@6B@
rdata$r	SEGMENT
??_R4D3DIndexBufferPool@Ogre@@6B@ DD 00H		; Ogre::D3DIndexBufferPool::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVD3DIndexBufferPool@Ogre@@@8
	DD	FLAT:??_R3D3DIndexBufferPool@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_7D3DIndexBufferPool@Ogre@@6B@
CONST	SEGMENT
??_7D3DIndexBufferPool@Ogre@@6B@ DD FLAT:??_R4D3DIndexBufferPool@Ogre@@6B@ ; Ogre::D3DIndexBufferPool::`vftable'
	DD	FLAT:??_ED3DIndexBufferPool@Ogre@@UAEPAXI@Z
	DD	FLAT:?lock@D3DIndexBufferPool@Ogre@@UAEPAXIIW4HardwareBufferLockOpt@2@@Z
	DD	FLAT:?unlock@D3DIndexBufferPool@Ogre@@UAEXXZ
	DD	FLAT:?create@D3DIndexBufferPool@Ogre@@UAE_NXZ
	DD	FLAT:?onLostDevice@D3DIndexBufferPool@Ogre@@UAEXXZ
	DD	FLAT:?onResetDevice@D3DIndexBufferPool@Ogre@@UAE_NXZ
CONST	ENDS
xdata$x	SEGMENT
__unwindtable$??0D3DIndexBufferPool@Ogre@@QAE@PAVD3D9RenderSystem@1@W4HardwareBufferUsage@1@II@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0D3DIndexBufferPool@Ogre@@QAE@PAVD3D9RenderSystem@1@W4HardwareBufferUsage@1@II@Z$0
__ehfuncinfo$??0D3DIndexBufferPool@Ogre@@QAE@PAVD3D9RenderSystem@1@W4HardwareBufferUsage@1@II@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0D3DIndexBufferPool@Ogre@@QAE@PAVD3D9RenderSystem@1@W4HardwareBufferUsage@1@II@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_prs$ = 8						; size = 4
_usage$ = 12						; size = 4
_nbytes$ = 16						; size = 4
_stride$ = 20						; size = 4
??0D3DIndexBufferPool@Ogre@@QAE@PAVD3D9RenderSystem@1@W4HardwareBufferUsage@1@II@Z PROC ; Ogre::D3DIndexBufferPool::D3DIndexBufferPool
; _this$ = ecx

; 100  : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0D3DIndexBufferPool@Ogre@@QAE@PAVD3D9RenderSystem@1@W4HardwareBufferUsage@1@II@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	cmp	DWORD PTR _usage$[ebp], 2
	sete	al
	movzx	ecx, al
	push	ecx
	mov	edx, DWORD PTR _nbytes$[ebp]
	push	edx
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0D3D9BufferPool@Ogre@@QAE@_NI0@Z	; Ogre::D3D9BufferPool::D3D9BufferPool
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7D3DIndexBufferPool@Ogre@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _prs$[ebp]
	mov	DWORD PTR [ecx+48], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+52], 0

; 101  : 		m_pRS->hbu2PoolUsage(m_Usage, m_Pool, usage);

	mov	ecx, DWORD PTR _usage$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 56					; 00000038H
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 60					; 0000003cH
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+48]
	call	?hbu2PoolUsage@D3D9RenderSystem@Ogre@@QAEXAAKAAW4_D3DPOOL@@W4HardwareBufferUsage@2@@Z ; Ogre::D3D9RenderSystem::hbu2PoolUsage

; 102  : 		if(m_Pool == D3DPOOL_DEFAULT) m_Usage |= D3DUSAGE_WRITEONLY;

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+56], 0
	jne	SHORT $LN2@D3DIndexBu
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	or	ecx, 8
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+60], ecx
$LN2@D3DIndexBu:

; 103  : 		if((m_pRS->getCreateFlags()&D3DCREATE_HARDWARE_VERTEXPROCESSING) == 0)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	call	?getCreateFlags@D3D9RenderSystem@Ogre@@QAEKXZ ; Ogre::D3D9RenderSystem::getCreateFlags
	and	eax, 64					; 00000040H
	jne	SHORT $LN1@D3DIndexBu

; 104  : 		{
; 105  : 			m_Usage |= D3DUSAGE_SOFTWAREPROCESSING;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+60]
	or	edx, 16					; 00000010H
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+60], edx
$LN1@D3DIndexBu:

; 106  : 		}
; 107  : 
; 108  : 		m_IndexFormat = stride==2 ? D3DFMT_INDEX16 : D3DFMT_INDEX32;

	xor	ecx, ecx
	cmp	DWORD PTR _stride$[ebp], 2
	setne	cl
	add	ecx, 101				; 00000065H
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+64], ecx

; 109  : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$??0D3DIndexBufferPool@Ogre@@QAE@PAVD3D9RenderSystem@1@W4HardwareBufferUsage@1@II@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1D3D9BufferPool@Ogre@@UAE@XZ		; Ogre::D3D9BufferPool::~D3D9BufferPool
__ehhandler$??0D3DIndexBufferPool@Ogre@@QAE@PAVD3D9RenderSystem@1@W4HardwareBufferUsage@1@II@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0D3DIndexBufferPool@Ogre@@QAE@PAVD3D9RenderSystem@1@W4HardwareBufferUsage@1@II@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0D3DIndexBufferPool@Ogre@@QAE@PAVD3D9RenderSystem@1@W4HardwareBufferUsage@1@II@Z ENDP ; Ogre::D3DIndexBufferPool::D3DIndexBufferPool
PUBLIC	??1D3DIndexBufferPool@Ogre@@UAE@XZ		; Ogre::D3DIndexBufferPool::~D3DIndexBufferPool
; Function compile flags: /Odtp
;	COMDAT ??_GD3DIndexBufferPool@Ogre@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GD3DIndexBufferPool@Ogre@@UAEPAXI@Z PROC		; Ogre::D3DIndexBufferPool::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1D3DIndexBufferPool@Ogre@@UAE@XZ	; Ogre::D3DIndexBufferPool::~D3DIndexBufferPool
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@3
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@3:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GD3DIndexBufferPool@Ogre@@UAEPAXI@Z ENDP		; Ogre::D3DIndexBufferPool::`scalar deleting destructor'
_TEXT	ENDS
xdata$x	SEGMENT
__unwindtable$??1D3DIndexBufferPool@Ogre@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1D3DIndexBufferPool@Ogre@@UAE@XZ$0
__ehfuncinfo$??1D3DIndexBufferPool@Ogre@@UAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1D3DIndexBufferPool@Ogre@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1D3DIndexBufferPool@Ogre@@UAE@XZ PROC			; Ogre::D3DIndexBufferPool::~D3DIndexBufferPool
; _this$ = ecx

; 112  : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1D3DIndexBufferPool@Ogre@@UAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7D3DIndexBufferPool@Ogre@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 113  : 		SAFE_RELEASE(m_pSysBuf);

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+52], 0
	je	SHORT $LN2@D3DIndexBu@2
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+52]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+52]
	mov	eax, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR [eax+8]
	call	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+52], 0
$LN2@D3DIndexBu@2:

; 114  : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1D3D9BufferPool@Ogre@@UAE@XZ		; Ogre::D3D9BufferPool::~D3D9BufferPool
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$??1D3DIndexBufferPool@Ogre@@UAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1D3D9BufferPool@Ogre@@UAE@XZ		; Ogre::D3D9BufferPool::~D3D9BufferPool
__ehhandler$??1D3DIndexBufferPool@Ogre@@UAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1D3DIndexBufferPool@Ogre@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1D3DIndexBufferPool@Ogre@@UAE@XZ ENDP			; Ogre::D3DIndexBufferPool::~D3DIndexBufferPool
; Function compile flags: /Odtp
_TEXT	SEGMENT
tv75 = -12						; size = 4
_this$ = -8						; size = 4
_hr$ = -4						; size = 4
?create@D3DIndexBufferPool@Ogre@@UAE_NXZ PROC		; Ogre::D3DIndexBufferPool::create
; _this$ = ecx

; 117  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 118  : 		if( m_Pool==D3DPOOL_DEFAULT && m_pRS->isDeviceLost() )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+56], 0
	jne	SHORT $LN3@create@2
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+48]
	call	?isDeviceLost@D3D9RenderSystem@Ogre@@QAE_NXZ ; Ogre::D3D9RenderSystem::isDeviceLost
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN3@create@2

; 119  : 		{
; 120  : 			return true;

	mov	al, 1
	jmp	SHORT $LN4@create@2
$LN3@create@2:

; 121  : 		}
; 122  : 
; 123  : 		HRESULT hr = m_pRS->getD3DDevice()->CreateIndexBuffer( (UINT)m_PoolSize, m_Usage, m_IndexFormat, m_Pool, &m_pSysBuf, NULL );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	call	?getD3DDevice@D3D9RenderSystem@Ogre@@QAEPAUIDirect3DDevice9@@XZ ; Ogre::D3D9RenderSystem::getD3DDevice
	mov	DWORD PTR tv75[ebp], eax
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 52					; 00000034H
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+56]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+64]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+60]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR tv75[ebp]
	push	ecx
	mov	edx, DWORD PTR tv75[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+108]
	call	ecx
	mov	DWORD PTR _hr$[ebp], eax

; 124  : 		if( FAILED(hr) )

	cmp	DWORD PTR _hr$[ebp], 0
	jge	SHORT $LN2@create@2

; 125  : 		{
; 126  : 			m_pSysBuf = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+52], 0

; 127  : 			return false;

	xor	al, al
	jmp	SHORT $LN4@create@2
	jmp	SHORT $LN4@create@2
$LN2@create@2:

; 128  : 		}
; 129  : 		else return true;

	mov	al, 1
$LN4@create@2:

; 130  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?create@D3DIndexBufferPool@Ogre@@UAE_NXZ ENDP		; Ogre::D3DIndexBufferPool::create
; Function compile flags: /Odtp
_this$ = -4						; size = 4
?onLostDevice@D3DIndexBufferPool@Ogre@@UAEXXZ PROC	; Ogre::D3DIndexBufferPool::onLostDevice
; _this$ = ecx

; 133  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 134  : 		if( m_Pool == D3DPOOL_DEFAULT )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+56], 0
	jne	SHORT $LN4@onLostDevi@2

; 135  : 		{
; 136  : 			//SAFE_RELEASE(m_pSysBuf);
; 137  : 			if ( m_pSysBuf != NULL )

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+52], 0
	je	SHORT $LN4@onLostDevi@2

; 138  : 			{
; 139  : 				if ( FAILED( m_pSysBuf->Release() ) )

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+52]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+52]
	mov	eax, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR [eax+8]
	call	ecx
	test	eax, eax
	jge	SHORT $LN1@onLostDevi@2

; 140  : 				{
; 141  : 					LOG_PRIVATE( "D3DIndexBufferPool::onLostDevice--140" );

	push	64					; 00000040H
	push	141					; 0000008dH
	push	OFFSET $SG128362
	call	DWORD PTR __imp_?LogSetCurParam@Ogre@@YAXPBDHI@Z
	add	esp, 12					; 0000000cH
	push	OFFSET $SG128363
	call	DWORD PTR __imp_?LogMessage@Ogre@@YAXPBDZZ
	add	esp, 4
$LN1@onLostDevi@2:

; 142  : 				}
; 143  : 
; 144  : 				m_pSysBuf = NULL;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+52], 0
$LN4@onLostDevi@2:

; 145  : 			}
; 146  : 		}
; 147  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?onLostDevice@D3DIndexBufferPool@Ogre@@UAEXXZ ENDP	; Ogre::D3DIndexBufferPool::onLostDevice
; Function compile flags: /Odtp
_this$ = -4						; size = 4
?onResetDevice@D3DIndexBufferPool@Ogre@@UAE_NXZ PROC	; Ogre::D3DIndexBufferPool::onResetDevice
; _this$ = ecx

; 150  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 151  : 		if( m_Pool == D3DPOOL_DEFAULT )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+56], 0
	jne	SHORT $LN2@onResetDev@2

; 152  : 		{
; 153  : 			return create();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	call	eax
	jmp	SHORT $LN3@onResetDev@2
	jmp	SHORT $LN3@onResetDev@2
$LN2@onResetDev@2:

; 154  : 		}
; 155  : 		else return true;

	mov	al, 1
$LN3@onResetDev@2:

; 156  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?onResetDevice@D3DIndexBufferPool@Ogre@@UAE_NXZ ENDP	; Ogre::D3DIndexBufferPool::onResetDevice
; Function compile flags: /Odtp
_this$ = -12						; size = 4
_pdata$ = -8						; size = 4
_d3dflags$ = -4						; size = 4
_start$ = 8						; size = 4
_nbytes$ = 12						; size = 4
_lockopt$ = 16						; size = 4
?lock@D3DIndexBufferPool@Ogre@@UAEPAXIIW4HardwareBufferLockOpt@2@@Z PROC ; Ogre::D3DIndexBufferPool::lock
; _this$ = ecx

; 159  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 160  : 		DWORD d3dflags = GetLockFlags(lockopt, m_Usage, start);

	mov	eax, DWORD PTR _start$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+60]
	push	edx
	mov	eax, DWORD PTR _lockopt$[ebp]
	push	eax
	call	?GetLockFlags@Ogre@@YAKW4HardwareBufferLockOpt@1@KI@Z ; Ogre::GetLockFlags
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _d3dflags$[ebp], eax

; 161  : 
; 162  : 		void *pdata;
; 163  : 		if( SUCCEEDED(m_pSysBuf->Lock((UINT)(start), (UINT)(nbytes), &pdata, d3dflags)) )

	mov	ecx, DWORD PTR _d3dflags$[ebp]
	push	ecx
	lea	edx, DWORD PTR _pdata$[ebp]
	push	edx
	mov	eax, DWORD PTR _nbytes$[ebp]
	push	eax
	mov	ecx, DWORD PTR _start$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+52]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+52]
	mov	eax, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR [eax+44]
	call	ecx
	test	eax, eax
	jl	SHORT $LN2@lock@2

; 164  : 		{
; 165  : 			return pdata;

	mov	eax, DWORD PTR _pdata$[ebp]
	jmp	SHORT $LN3@lock@2
	jmp	SHORT $LN3@lock@2
$LN2@lock@2:

; 166  : 		}
; 167  : 		else return NULL;

	xor	eax, eax
$LN3@lock@2:

; 168  : 	}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?lock@D3DIndexBufferPool@Ogre@@UAEPAXIIW4HardwareBufferLockOpt@2@@Z ENDP ; Ogre::D3DIndexBufferPool::lock
; Function compile flags: /Odtp
_this$ = -4						; size = 4
?unlock@D3DIndexBufferPool@Ogre@@UAEXXZ PROC		; Ogre::D3DIndexBufferPool::unlock
; _this$ = ecx

; 171  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 172  : 		m_pSysBuf->Unlock();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+52]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	mov	edx, DWORD PTR [ecx+48]
	call	edx

; 173  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?unlock@D3DIndexBufferPool@Ogre@@UAEXXZ ENDP		; Ogre::D3DIndexBufferPool::unlock
_TEXT	ENDS
PUBLIC	?newPool@D3D9HardwareBufferManager@Ogre@@UAEPAVHardwareBufferPool@2@_NW4HardwareBufferUsage@2@II@Z ; Ogre::D3D9HardwareBufferManager::newPool
EXTRN	??2@YAPAXI@Z:PROC				; operator new
xdata$x	SEGMENT
__unwindtable$?newPool@D3D9HardwareBufferManager@Ogre@@UAEPAVHardwareBufferPool@2@_NW4HardwareBufferUsage@2@II@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?newPool@D3D9HardwareBufferManager@Ogre@@UAEPAVHardwareBufferPool@2@_NW4HardwareBufferUsage@2@II@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?newPool@D3D9HardwareBufferManager@Ogre@@UAEPAVHardwareBufferPool@2@_NW4HardwareBufferUsage@2@II@Z$1
__ehfuncinfo$?newPool@D3D9HardwareBufferManager@Ogre@@UAEPAVHardwareBufferPool@2@_NW4HardwareBufferUsage@2@II@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?newPool@D3D9HardwareBufferManager@Ogre@@UAEPAVHardwareBufferPool@2@_NW4HardwareBufferUsage@2@II@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
_TEXT	SEGMENT
tv166 = -72						; size = 4
tv146 = -68						; size = 4
tv129 = -64						; size = 4
tv77 = -60						; size = 4
_this$ = -56						; size = 4
$T133226 = -52						; size = 4
$T133225 = -48						; size = 4
$T133222 = -44						; size = 4
$T133221 = -40						; size = 4
$T133218 = -36						; size = 4
$T133217 = -32						; size = 4
$T133214 = -28						; size = 4
$T133213 = -24						; size = 4
_pool$128403 = -20					; size = 4
_pool$128393 = -16					; size = 4
__$EHRec$ = -12						; size = 12
_is_vbuffer$ = 8					; size = 1
_usage$ = 12						; size = 4
_nbytes$ = 16						; size = 4
_stride$ = 20						; size = 4
?newPool@D3D9HardwareBufferManager@Ogre@@UAEPAVHardwareBufferPool@2@_NW4HardwareBufferUsage@2@II@Z PROC ; Ogre::D3D9HardwareBufferManager::newPool
; _this$ = ecx

; 176  : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?newPool@D3D9HardwareBufferManager@Ogre@@UAEPAVHardwareBufferPool@2@_NW4HardwareBufferUsage@2@II@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 60					; 0000003cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 177  : 		if(is_vbuffer)

	movzx	eax, BYTE PTR _is_vbuffer$[ebp]
	test	eax, eax
	je	$LN6@newPool

; 178  : 		{
; 179  : 			D3DVertexBufferPool *pool = new D3DVertexBufferPool(m_pRS, usage, nbytes);

	push	64					; 00000040H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T133214[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T133214[ebp], 0
	je	SHORT $LN9@newPool
	mov	ecx, DWORD PTR _nbytes$[ebp]
	push	ecx
	mov	edx, DWORD PTR _usage$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	push	ecx
	mov	ecx, DWORD PTR $T133214[ebp]
	call	??0D3DVertexBufferPool@Ogre@@QAE@PAVD3D9RenderSystem@1@W4HardwareBufferUsage@1@I@Z ; Ogre::D3DVertexBufferPool::D3DVertexBufferPool
	mov	DWORD PTR tv77[ebp], eax
	jmp	SHORT $LN10@newPool
$LN9@newPool:
	mov	DWORD PTR tv77[ebp], 0
$LN10@newPool:
	mov	edx, DWORD PTR tv77[ebp]
	mov	DWORD PTR $T133213[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR $T133213[ebp]
	mov	DWORD PTR _pool$128393[ebp], eax

; 180  : 			if(!pool->create())

	mov	ecx, DWORD PTR _pool$128393[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _pool$128393[ebp]
	mov	eax, DWORD PTR [edx+12]
	call	eax
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN5@newPool

; 181  : 			{
; 182  : 				delete pool;

	mov	edx, DWORD PTR _pool$128393[ebp]
	mov	DWORD PTR $T133218[ebp], edx
	mov	eax, DWORD PTR $T133218[ebp]
	mov	DWORD PTR $T133217[ebp], eax
	cmp	DWORD PTR $T133217[ebp], 0
	je	SHORT $LN11@newPool
	push	1
	mov	ecx, DWORD PTR $T133217[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR $T133217[ebp]
	mov	eax, DWORD PTR [edx]
	call	eax
	mov	DWORD PTR tv129[ebp], eax
	jmp	SHORT $LN12@newPool
$LN11@newPool:
	mov	DWORD PTR tv129[ebp], 0
$LN12@newPool:

; 183  : 				return NULL;

	xor	eax, eax
	jmp	$LN7@newPool
	jmp	SHORT $LN4@newPool
$LN5@newPool:

; 184  : 			}
; 185  : 			else return pool;

	mov	eax, DWORD PTR _pool$128393[ebp]
	jmp	$LN7@newPool
$LN4@newPool:

; 186  : 		}
; 187  : 		else

	jmp	$LN7@newPool
$LN6@newPool:

; 188  : 		{
; 189  : 			D3DIndexBufferPool *pool = new D3DIndexBufferPool(m_pRS, usage, nbytes, stride);

	push	68					; 00000044H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T133222[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	cmp	DWORD PTR $T133222[ebp], 0
	je	SHORT $LN13@newPool
	mov	ecx, DWORD PTR _stride$[ebp]
	push	ecx
	mov	edx, DWORD PTR _nbytes$[ebp]
	push	edx
	mov	eax, DWORD PTR _usage$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	push	edx
	mov	ecx, DWORD PTR $T133222[ebp]
	call	??0D3DIndexBufferPool@Ogre@@QAE@PAVD3D9RenderSystem@1@W4HardwareBufferUsage@1@II@Z ; Ogre::D3DIndexBufferPool::D3DIndexBufferPool
	mov	DWORD PTR tv146[ebp], eax
	jmp	SHORT $LN14@newPool
$LN13@newPool:
	mov	DWORD PTR tv146[ebp], 0
$LN14@newPool:
	mov	eax, DWORD PTR tv146[ebp]
	mov	DWORD PTR $T133221[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR $T133221[ebp]
	mov	DWORD PTR _pool$128403[ebp], ecx

; 190  : 			if(!pool->create())

	mov	edx, DWORD PTR _pool$128403[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _pool$128403[ebp]
	mov	edx, DWORD PTR [eax+12]
	call	edx
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN2@newPool

; 191  : 			{
; 192  : 				delete pool;

	mov	ecx, DWORD PTR _pool$128403[ebp]
	mov	DWORD PTR $T133226[ebp], ecx
	mov	edx, DWORD PTR $T133226[ebp]
	mov	DWORD PTR $T133225[ebp], edx
	cmp	DWORD PTR $T133225[ebp], 0
	je	SHORT $LN15@newPool
	push	1
	mov	eax, DWORD PTR $T133225[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR $T133225[ebp]
	mov	eax, DWORD PTR [edx]
	call	eax
	mov	DWORD PTR tv166[ebp], eax
	jmp	SHORT $LN16@newPool
$LN15@newPool:
	mov	DWORD PTR tv166[ebp], 0
$LN16@newPool:

; 193  : 				return NULL;

	xor	eax, eax
	jmp	SHORT $LN7@newPool
	jmp	SHORT $LN7@newPool
$LN2@newPool:

; 194  : 			}
; 195  : 			else return pool;

	mov	eax, DWORD PTR _pool$128403[ebp]
$LN7@newPool:

; 196  : 		}
; 197  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?newPool@D3D9HardwareBufferManager@Ogre@@UAEPAVHardwareBufferPool@2@_NW4HardwareBufferUsage@2@II@Z$0:
	mov	eax, DWORD PTR $T133214[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?newPool@D3D9HardwareBufferManager@Ogre@@UAEPAVHardwareBufferPool@2@_NW4HardwareBufferUsage@2@II@Z$1:
	mov	eax, DWORD PTR $T133222[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?newPool@D3D9HardwareBufferManager@Ogre@@UAEPAVHardwareBufferPool@2@_NW4HardwareBufferUsage@2@II@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-64]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?newPool@D3D9HardwareBufferManager@Ogre@@UAEPAVHardwareBufferPool@2@_NW4HardwareBufferUsage@2@II@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?newPool@D3D9HardwareBufferManager@Ogre@@UAEPAVHardwareBufferPool@2@_NW4HardwareBufferUsage@2@II@Z ENDP ; Ogre::D3D9HardwareBufferManager::newPool
PUBLIC	??Citerator@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QBEPAU?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::iterator::operator->
PUBLIC	??9const_iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::const_iterator::operator!=
PUBLIC	?end@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::end
PUBLIC	??Eiterator@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AV012@H@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::iterator::operator++
PUBLIC	?begin@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::begin
PUBLIC	?onLostDevice@D3D9HardwareBufferManager@Ogre@@QAEXXZ ; Ogre::D3D9HardwareBufferManager::onLostDevice
EXTRN	__imp_?onDataInvalidate@HardwareBufferPool@Ogre@@QAEXXZ:PROC
; Function compile flags: /Odtp
_TEXT	SEGMENT
_this$ = -32						; size = 4
$T133237 = -28						; size = 8
$T133236 = -20						; size = 8
_pool$128519 = -12					; size = 4
_iter$ = -8						; size = 8
?onLostDevice@D3D9HardwareBufferManager@Ogre@@QAEXXZ PROC ; Ogre::D3D9HardwareBufferManager::onLostDevice
; _this$ = ecx

; 200  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	DWORD PTR _this$[ebp], ecx

; 201  : 		PoolTableIter iter = m_Pools.begin();

	lea	eax, DWORD PTR _iter$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?begin@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::begin
	jmp	SHORT $LN5@onLostDevi@3
$LN4@onLostDevi@3:

; 202  : 		for(; iter!=m_Pools.end(); iter++)

	push	0
	lea	ecx, DWORD PTR $T133236[ebp]
	push	ecx
	lea	ecx, DWORD PTR _iter$[ebp]
	call	??Eiterator@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AV012@H@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::iterator::operator++
$LN5@onLostDevi@3:
	lea	edx, DWORD PTR $T133237[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?end@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::end
	push	eax
	lea	ecx, DWORD PTR _iter$[ebp]
	call	??9const_iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::const_iterator::operator!=
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN6@onLostDevi@3

; 203  : 		{
; 204  : 			HardwareBufferPool *pool = iter->second;

	lea	ecx, DWORD PTR _iter$[ebp]
	call	??Citerator@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QBEPAU?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::iterator::operator->
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _pool$128519[ebp], ecx
$LN2@onLostDevi@3:

; 205  : 			while(pool != NULL)

	cmp	DWORD PTR _pool$128519[ebp], 0
	je	SHORT $LN1@onLostDevi@3

; 206  : 			{
; 207  : 				pool->onDataInvalidate();

	mov	ecx, DWORD PTR _pool$128519[ebp]
	call	DWORD PTR __imp_?onDataInvalidate@HardwareBufferPool@Ogre@@QAEXXZ

; 208  : 				static_cast<D3D9BufferPool *>(pool)->onLostDevice();

	mov	edx, DWORD PTR _pool$128519[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _pool$128519[ebp]
	mov	edx, DWORD PTR [eax+16]
	call	edx

; 209  : 				pool = pool->m_pNextPool;

	mov	eax, DWORD PTR _pool$128519[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	DWORD PTR _pool$128519[ebp], ecx

; 210  : 			}

	jmp	SHORT $LN2@onLostDevi@3
$LN1@onLostDevi@3:

; 211  : 		}

	jmp	SHORT $LN4@onLostDevi@3
$LN6@onLostDevi@3:

; 212  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?onLostDevice@D3D9HardwareBufferManager@Ogre@@QAEXXZ ENDP ; Ogre::D3D9HardwareBufferManager::onLostDevice
_TEXT	ENDS
PUBLIC	?onResetDevice@D3D9HardwareBufferManager@Ogre@@QAE_NXZ ; Ogre::D3D9HardwareBufferManager::onResetDevice
; Function compile flags: /Odtp
_TEXT	SEGMENT
_this$ = -32						; size = 4
$T133240 = -28						; size = 8
$T133239 = -20						; size = 8
_pool$128558 = -12					; size = 4
_iter$ = -8						; size = 8
?onResetDevice@D3D9HardwareBufferManager@Ogre@@QAE_NXZ PROC ; Ogre::D3D9HardwareBufferManager::onResetDevice
; _this$ = ecx

; 215  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	DWORD PTR _this$[ebp], ecx

; 216  : 		PoolTableIter iter = m_Pools.begin();

	lea	eax, DWORD PTR _iter$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?begin@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::begin
	jmp	SHORT $LN6@onResetDev@3
$LN5@onResetDev@3:

; 217  : 		for(; iter!=m_Pools.end(); iter++)

	push	0
	lea	ecx, DWORD PTR $T133239[ebp]
	push	ecx
	lea	ecx, DWORD PTR _iter$[ebp]
	call	??Eiterator@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AV012@H@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::iterator::operator++
$LN6@onResetDev@3:
	lea	edx, DWORD PTR $T133240[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?end@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::end
	push	eax
	lea	ecx, DWORD PTR _iter$[ebp]
	call	??9const_iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::const_iterator::operator!=
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN4@onResetDev@3

; 218  : 		{
; 219  : 			HardwareBufferPool *pool = iter->second;

	lea	ecx, DWORD PTR _iter$[ebp]
	call	??Citerator@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QBEPAU?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::iterator::operator->
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _pool$128558[ebp], ecx
$LN3@onResetDev@3:

; 220  : 			while(pool != NULL)

	cmp	DWORD PTR _pool$128558[ebp], 0
	je	SHORT $LN2@onResetDev@3

; 221  : 			{
; 222  : 				if(!static_cast<D3D9BufferPool *>(pool)->onResetDevice()) return false;

	mov	edx, DWORD PTR _pool$128558[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _pool$128558[ebp]
	mov	edx, DWORD PTR [eax+20]
	call	edx
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN1@onResetDev@3
	xor	al, al
	jmp	SHORT $LN7@onResetDev@3
$LN1@onResetDev@3:

; 223  : 				pool = pool->m_pNextPool;

	mov	ecx, DWORD PTR _pool$128558[ebp]
	mov	edx, DWORD PTR [ecx+40]
	mov	DWORD PTR _pool$128558[ebp], edx

; 224  : 			}

	jmp	SHORT $LN3@onResetDev@3
$LN2@onResetDev@3:

; 225  : 		}

	jmp	SHORT $LN5@onResetDev@3
$LN4@onResetDev@3:

; 226  : 
; 227  : 		return true;

	mov	al, 1
$LN7@onResetDev@3:

; 228  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?onResetDevice@D3D9HardwareBufferManager@Ogre@@QAE_NXZ ENDP ; Ogre::D3D9HardwareBufferManager::onResetDevice
_TEXT	ENDS
PUBLIC	??0iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PBV12@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::iterator::iterator
PUBLIC	?_Lmost@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Lmost
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?begin@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::begin, COMDAT
; _this$ = ecx

; 555  : 		{	// return iterator for beginning of mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 556  : 		return (_TREE_ITERATOR(_Lmost()));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lmost@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Lmost
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PBV12@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::iterator::iterator
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 557  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?begin@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::begin
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?end@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::end, COMDAT
; _this$ = ecx

; 565  : 		{	// return iterator for end of mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 566  : 		return (_TREE_ITERATOR(_Myhead));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PBV12@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::iterator::iterator
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 567  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?end@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::end
_TEXT	ENDS
PUBLIC	??Diterator@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QBEAAU?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::iterator::operator*
; Function compile flags: /Odtp
;	COMDAT ??Citerator@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QBEPAU?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??Citerator@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QBEPAU?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::iterator::operator->, COMDAT
; _this$ = ecx

; 469  : 			{	// return pointer to class object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 470  : 			return (&**this);

	mov	ecx, DWORD PTR _this$[ebp]
	call	??Diterator@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QBEAAU?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::iterator::operator*

; 471  : 			}

	mov	esp, ebp
	pop	ebp
	ret	0
??Citerator@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QBEPAU?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::iterator::operator->
_TEXT	ENDS
PUBLIC	??Eiterator@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::iterator::operator++
; Function compile flags: /Odtp
;	COMDAT ??Eiterator@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AV012@H@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
__Tmp$ = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??Eiterator@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AV012@H@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::iterator::operator++, COMDAT
; _this$ = ecx

; 480  : 			{	// postincrement

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 481  : 			iterator _Tmp = *this;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR __Tmp$[ebp], ecx
	mov	DWORD PTR __Tmp$[ebp+4], edx

; 482  : 			++*this;

	mov	ecx, DWORD PTR _this$[ebp]
	call	??Eiterator@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::iterator::operator++

; 483  : 			return (_Tmp);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR __Tmp$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR __Tmp$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 484  : 			}

	mov	esp, ebp
	pop	ebp
	ret	8
??Eiterator@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AV012@H@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::iterator::operator++
_TEXT	ENDS
PUBLIC	??8const_iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::const_iterator::operator==
; Function compile flags: /Odtp
;	COMDAT ??9const_iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??9const_iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QBE_NABV012@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::const_iterator::operator!=, COMDAT
; _this$ = ecx

; 315  : 			{	// test for iterator inequality

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 316  : 			return (!(*this == _Right));

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??8const_iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::const_iterator::operator==
	movzx	eax, al
	neg	eax
	sbb	eax, eax
	add	eax, 1

; 317  : 			}

	mov	esp, ebp
	pop	ebp
	ret	4
??9const_iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QBE_NABV012@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::const_iterator::operator!=
_TEXT	ENDS
PUBLIC	?_Left@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Left
; Function compile flags: /Odtp
;	COMDAT ?_Lmost@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Lmost@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Lmost, COMDAT
; _this$ = ecx

; 1280 : 		{	// return leftmost node in nonmutable tree

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1281 : 		return (_Left(_Myhead));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	push	ecx
	call	?_Left@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Left
	add	esp, 4

; 1282 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Lmost@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Lmost
_TEXT	ENDS
PUBLIC	??0const_iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PBV12@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::const_iterator::const_iterator
; Function compile flags: /Odtp
;	COMDAT ??0iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PBV12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PBV12@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::iterator::iterator, COMDAT
; _this$ = ecx

; 451  : 			{	// construct with node pointer _Pnode

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Plist$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0const_iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PBV12@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::const_iterator::const_iterator

; 452  : 			}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PBV12@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::iterator::iterator
_TEXT	ENDS
PUBLIC	??Dconst_iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QBEABU?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::const_iterator::operator*
; Function compile flags: /Odtp
;	COMDAT ??Diterator@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QBEAAU?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??Diterator@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QBEAAU?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::iterator::operator*, COMDAT
; _this$ = ecx

; 464  : 			{	// return designated value

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 465  : 			return ((reference)**(const_iterator *)this);

	mov	ecx, DWORD PTR _this$[ebp]
	call	??Dconst_iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QBEABU?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::const_iterator::operator*

; 466  : 			}

	mov	esp, ebp
	pop	ebp
	ret	0
??Diterator@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QBEAAU?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::iterator::operator*
_TEXT	ENDS
PUBLIC	??Econst_iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::const_iterator::operator++
; Function compile flags: /Odtp
;	COMDAT ??Eiterator@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??Eiterator@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAEAAV012@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::iterator::operator++, COMDAT
; _this$ = ecx

; 474  : 			{	// preincrement

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 475  : 			++(*(const_iterator *)this);

	mov	ecx, DWORD PTR _this$[ebp]
	call	??Econst_iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::const_iterator::operator++

; 476  : 			return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 477  : 			}

	mov	esp, ebp
	pop	ebp
	ret	0
??Eiterator@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAEAAV012@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::iterator::operator++
_TEXT	ENDS
PUBLIC	?_Same_container@_Iterator_base_aux@std@@QBE_NABV12@@Z ; std::_Iterator_base_aux::_Same_container
PUBLIC	?_Has_container@_Iterator_base_aux@std@@QBE_NXZ	; std::_Iterator_base_aux::_Has_container
EXTRN	__imp___invalid_parameter_noinfo:PROC
; Function compile flags: /Odtp
;	COMDAT ??8const_iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??8const_iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QBE_NABV012@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::const_iterator::operator==, COMDAT
; _this$ = ecx

; 299  : 			{	// test for iterator equality

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 300  : 
; 301  :  #if _HAS_ITERATOR_DEBUGGING
; 302  : 			if (this->_Mycont == 0 || this->_Mycont != _Right._Mycont)
; 303  : 				{
; 304  : 				_DEBUG_ERROR("map/set iterators incompatible");
; 305  : 				_SCL_SECURE_INVALID_ARGUMENT;
; 306  : 				}
; 307  :  #else
; 308  : 			_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Has_container@_Iterator_base_aux@std@@QBE_NXZ ; std::_Iterator_base_aux::_Has_container
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@operator
	mov	ecx, DWORD PTR __Right$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Same_container@_Iterator_base_aux@std@@QBE_NABV12@@Z ; std::_Iterator_base_aux::_Same_container
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN2@operator
$LN1@operator:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@operator:

; 309  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 310  : 
; 311  : 			return (_Ptr == _Right._Ptr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [eax+4]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+4]
	sete	al

; 312  : 			}

	mov	esp, ebp
	pop	ebp
	ret	4
??8const_iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QBE_NABV012@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::const_iterator::operator==
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ?_Same_container@_Iterator_base_aux@std@@QBE_NABV12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Other$ = 8						; size = 4
?_Same_container@_Iterator_base_aux@std@@QBE_NABV12@@Z PROC ; std::_Iterator_base_aux::_Same_container, COMDAT
; _this$ = ecx

; 462  : 		{	// Accelerate the comparison by not going through the aux object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 463  : 		return _Myaux == _Other._Myaux;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Other$[ebp]
	mov	edx, DWORD PTR [eax]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx]
	sete	al

; 464  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Same_container@_Iterator_base_aux@std@@QBE_NABV12@@Z ENDP ; std::_Iterator_base_aux::_Same_container
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Has_container@_Iterator_base_aux@std@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Has_container@_Iterator_base_aux@std@@QBE_NXZ PROC	; std::_Iterator_base_aux::_Has_container, COMDAT
; _this$ = ecx

; 467  : 		{	// Accelerate the comparison by not going through the aux object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 468  : 		return _Myaux != 0;

	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	cmp	DWORD PTR [eax], 0
	setne	cl
	mov	al, cl

; 469  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Has_container@_Iterator_base_aux@std@@QBE_NXZ ENDP	; std::_Iterator_base_aux::_Has_container
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ?_Left@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Left@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Left, COMDAT

; 166  : 		{	// return reference to left pointer in node

	push	ebp
	mov	ebp, esp

; 167  : 		return ((_Nodepref)(*_Pnode)._Left);

	mov	eax, DWORD PTR __Pnode$[ebp]

; 168  : 		}

	pop	ebp
	ret	0
?_Left@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Left
_TEXT	ENDS
PUBLIC	?_Set_container@_Iterator_base_aux@std@@QAEXQBV_Container_base_aux@2@@Z ; std::_Iterator_base_aux::_Set_container
PUBLIC	??0?$_Bidit@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@HPBU12@ABU12@@std@@QAE@XZ ; std::_Bidit<std::pair<unsigned int const ,Ogre::HardwareBufferPool *>,int,std::pair<unsigned int const ,Ogre::HardwareBufferPool *> const *,std::pair<unsigned int const ,Ogre::HardwareBufferPool *> const &>::_Bidit<std::pair<unsigned int const ,Ogre::HardwareBufferPool *>,int,std::pair<unsigned int const ,Ogre::HardwareBufferPool *> const *,std::pair<unsigned int const ,Ogre::HardwareBufferPool *> const &>
; Function compile flags: /Odtp
;	COMDAT ??0const_iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PBV12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0const_iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PBV12@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::const_iterator::const_iterator, COMDAT
; _this$ = ecx

; 234  : 			{	// construct with node pointer _Pnode

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Bidit@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@HPBU12@ABU12@@std@@QAE@XZ
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 235  : 			_SCL_SECURE_VALIDATE(_Plist != NULL);

	cmp	DWORD PTR __Plist$[ebp], 0
	jne	SHORT $LN1@const_iter
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN1@const_iter:

; 236  : 			this->_Set_container(_Plist);

	mov	edx, DWORD PTR __Plist$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Set_container@_Iterator_base_aux@std@@QAEXQBV_Container_base_aux@2@@Z ; std::_Iterator_base_aux::_Set_container

; 237  : 			}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0const_iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PBV12@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::const_iterator::const_iterator
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ?_Set_container@_Iterator_base_aux@std@@QAEXQBV_Container_base_aux@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pcont$ = 8						; size = 4
?_Set_container@_Iterator_base_aux@std@@QAEXQBV_Container_base_aux@2@@Z PROC ; std::_Iterator_base_aux::_Set_container, COMDAT
; _this$ = ecx

; 452  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 453  : 		_Myaux = _Pcont->_Myownedaux;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Pcont$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 454  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Set_container@_Iterator_base_aux@std@@QAEXQBV_Container_base_aux@2@@Z ENDP ; std::_Iterator_base_aux::_Set_container
_TEXT	ENDS
PUBLIC	?_Myval@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAU?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Myval
PUBLIC	?_Getmycont@_Iterator_base_aux@std@@QBEPBV_Container_base_aux@2@XZ ; std::_Iterator_base_aux::_Getmycont
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ??Dconst_iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QBEABU?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??Dconst_iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QBEABU?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::const_iterator::operator*, COMDAT
; _this$ = ecx

; 249  : 			{	// return designated value

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 250  : 
; 251  :  #if _HAS_ITERATOR_DEBUGGING
; 252  : 			if (this->_Mycont == 0
; 253  : 				|| _Ptr == 0
; 254  : 				|| _Ptr == ((_Myt *)this->_Mycont)->_Myhead)
; 255  : 				{
; 256  : 				_DEBUG_ERROR("map/set iterator not dereferencable");
; 257  : 				_SCL_SECURE_OUT_OF_RANGE;
; 258  : 				}
; 259  :  #else
; 260  : 			_SCL_SECURE_VALIDATE(this->_Has_container());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Has_container@_Iterator_base_aux@std@@QBE_NXZ ; std::_Iterator_base_aux::_Has_container
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN2@operator@2
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@operator@2:

; 261  : 			_SCL_SECURE_VALIDATE_RANGE(_Ptr != ((_Myt *)(this->_Getmycont()))->_Myhead);

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getmycont@_Iterator_base_aux@std@@QBEPBV_Container_base_aux@2@XZ ; std::_Iterator_base_aux::_Getmycont
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, DWORD PTR [eax+24]
	jne	SHORT $LN1@operator@2
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN1@operator@2:

; 262  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 263  : 
; 264  : 			return (_Myval(_Ptr));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?_Myval@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAU?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Myval
	add	esp, 4

; 265  : 			}

	mov	esp, ebp
	pop	ebp
	ret	0
??Dconst_iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QBEABU?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::const_iterator::operator*
_TEXT	ENDS
PUBLIC	?_Getcont@_Aux_cont@std@@QBEPBV_Container_base_aux@2@XZ ; std::_Aux_cont::_Getcont
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ?_Getmycont@_Iterator_base_aux@std@@QBEPBV_Container_base_aux@2@XZ
_TEXT	SEGMENT
tv67 = -8						; size = 4
_this$ = -4						; size = 4
?_Getmycont@_Iterator_base_aux@std@@QBEPBV_Container_base_aux@2@XZ PROC ; std::_Iterator_base_aux::_Getmycont, COMDAT
; _this$ = ecx

; 457  : 		{	// Go through the aux object to get the container

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 458  : 		return _Myaux ? _Myaux->_Getcont() : 0;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN3@Getmycont
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?_Getcont@_Aux_cont@std@@QBEPBV_Container_base_aux@2@XZ ; std::_Aux_cont::_Getcont
	mov	DWORD PTR tv67[ebp], eax
	jmp	SHORT $LN4@Getmycont
$LN3@Getmycont:
	mov	DWORD PTR tv67[ebp], 0
$LN4@Getmycont:
	mov	eax, DWORD PTR tv67[ebp]

; 459  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Getmycont@_Iterator_base_aux@std@@QBEPBV_Container_base_aux@2@XZ ENDP ; std::_Iterator_base_aux::_Getmycont
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Getcont@_Aux_cont@std@@QBEPBV_Container_base_aux@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Getcont@_Aux_cont@std@@QBEPBV_Container_base_aux@2@XZ PROC ; std::_Aux_cont::_Getcont, COMDAT
; _this$ = ecx

; 368  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 369  : 		return _Mycontainer;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 370  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Getcont@_Aux_cont@std@@QBEPBV_Container_base_aux@2@XZ ENDP ; std::_Aux_cont::_Getcont
_TEXT	ENDS
PUBLIC	?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::const_iterator::_Inc
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ??Econst_iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??Econst_iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAEAAV012@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::const_iterator::operator++, COMDAT
; _this$ = ecx

; 273  : 			{	// preincrement

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 274  : 			_Inc();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::const_iterator::_Inc

; 275  : 			return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 276  : 			}

	mov	esp, ebp
	pop	ebp
	ret	0
??Econst_iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAEAAV012@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::const_iterator::operator++
_TEXT	ENDS
PUBLIC	??0?$_Iterator_with_base@Ubidirectional_iterator_tag@std@@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@2@HPBU32@ABU32@V_Iterator_base_aux@2@@std@@QAE@XZ ; std::_Iterator_with_base<std::bidirectional_iterator_tag,std::pair<unsigned int const ,Ogre::HardwareBufferPool *>,int,std::pair<unsigned int const ,Ogre::HardwareBufferPool *> const *,std::pair<unsigned int const ,Ogre::HardwareBufferPool *> const &,std::_Iterator_base_aux>::_Iterator_with_base<std::bidirectional_iterator_tag,std::pair<unsigned int const ,Ogre::HardwareBufferPool *>,int,std::pair<unsigned int const ,Ogre::HardwareBufferPool *> const *,std::pair<unsigned int const ,Ogre::HardwareBufferPool *> const &,std::_Iterator_base_aux>
; Function compile flags: /Odtp
;	COMDAT ??0?$_Bidit@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@HPBU12@ABU12@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Bidit@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@HPBU12@ABU12@@std@@QAE@XZ PROC ; std::_Bidit<std::pair<unsigned int const ,Ogre::HardwareBufferPool *>,int,std::pair<unsigned int const ,Ogre::HardwareBufferPool *> const *,std::pair<unsigned int const ,Ogre::HardwareBufferPool *> const &>::_Bidit<std::pair<unsigned int const ,Ogre::HardwareBufferPool *>,int,std::pair<unsigned int const ,Ogre::HardwareBufferPool *> const *,std::pair<unsigned int const ,Ogre::HardwareBufferPool *> const &>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Iterator_with_base@Ubidirectional_iterator_tag@std@@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@2@HPBU32@ABU32@V_Iterator_base_aux@2@@std@@QAE@XZ
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Bidit@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@HPBU12@ABU12@@std@@QAE@XZ ENDP ; std::_Bidit<std::pair<unsigned int const ,Ogre::HardwareBufferPool *>,int,std::pair<unsigned int const ,Ogre::HardwareBufferPool *> const *,std::pair<unsigned int const ,Ogre::HardwareBufferPool *> const &>::_Bidit<std::pair<unsigned int const ,Ogre::HardwareBufferPool *>,int,std::pair<unsigned int const ,Ogre::HardwareBufferPool *> const *,std::pair<unsigned int const ,Ogre::HardwareBufferPool *> const &>
_TEXT	ENDS
PUBLIC	??0_Iterator_base_aux@std@@QAE@XZ		; std::_Iterator_base_aux::_Iterator_base_aux
; Function compile flags: /Odtp
;	COMDAT ??0?$_Iterator_with_base@Ubidirectional_iterator_tag@std@@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@2@HPBU32@ABU32@V_Iterator_base_aux@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Iterator_with_base@Ubidirectional_iterator_tag@std@@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@2@HPBU32@ABU32@V_Iterator_base_aux@2@@std@@QAE@XZ PROC ; std::_Iterator_with_base<std::bidirectional_iterator_tag,std::pair<unsigned int const ,Ogre::HardwareBufferPool *>,int,std::pair<unsigned int const ,Ogre::HardwareBufferPool *> const *,std::pair<unsigned int const ,Ogre::HardwareBufferPool *> const &,std::_Iterator_base_aux>::_Iterator_with_base<std::bidirectional_iterator_tag,std::pair<unsigned int const ,Ogre::HardwareBufferPool *>,int,std::pair<unsigned int const ,Ogre::HardwareBufferPool *> const *,std::pair<unsigned int const ,Ogre::HardwareBufferPool *> const &,std::_Iterator_base_aux>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Iterator_base_aux@std@@QAE@XZ	; std::_Iterator_base_aux::_Iterator_base_aux
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Iterator_with_base@Ubidirectional_iterator_tag@std@@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@2@HPBU32@ABU32@V_Iterator_base_aux@2@@std@@QAE@XZ ENDP ; std::_Iterator_with_base<std::bidirectional_iterator_tag,std::pair<unsigned int const ,Ogre::HardwareBufferPool *>,int,std::pair<unsigned int const ,Ogre::HardwareBufferPool *> const *,std::pair<unsigned int const ,Ogre::HardwareBufferPool *> const &,std::_Iterator_base_aux>::_Iterator_with_base<std::bidirectional_iterator_tag,std::pair<unsigned int const ,Ogre::HardwareBufferPool *>,int,std::pair<unsigned int const ,Ogre::HardwareBufferPool *> const *,std::pair<unsigned int const ,Ogre::HardwareBufferPool *> const &,std::_Iterator_base_aux>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??0_Iterator_base_aux@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_Iterator_base_aux@std@@QAE@XZ PROC			; std::_Iterator_base_aux::_Iterator_base_aux, COMDAT
; _this$ = ecx

; 448  : 	_Iterator_base_aux()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0_Iterator_base_aux@std@@QAE@XZ ENDP			; std::_Iterator_base_aux::_Iterator_base_aux
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ?_Myval@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAU?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Myval@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAU?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Myval, COMDAT

; 181  : 		{	// return reference to value in node

	push	ebp
	mov	ebp, esp

; 182  : 		return ((_Vref)(*_Pnode)._Myval);

	mov	eax, DWORD PTR __Pnode$[ebp]
	add	eax, 12					; 0000000cH

; 183  : 		}

	pop	ebp
	ret	0
?_Myval@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAU?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Myval
_TEXT	ENDS
PUBLIC	?_Parent@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Parent
PUBLIC	?_Min@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Min
PUBLIC	?_Right@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Right
PUBLIC	?_Isnil@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Isnil
; Function compile flags: /Odtp
;	COMDAT ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Pnode$131230 = -4					; size = 4
?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAEXXZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::const_iterator::_Inc, COMDAT
; _this$ = ecx

; 377  : 			{	// move to node with next larger value

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 378  : 
; 379  :  #if _HAS_ITERATOR_DEBUGGING
; 380  : 			if (this->_Mycont == 0
; 381  : 				|| _Ptr == 0
; 382  : 				|| _Isnil(_Ptr))
; 383  : 				{
; 384  : 				_DEBUG_ERROR("map/set iterator not incrementable");
; 385  : 				_SCL_SECURE_OUT_OF_RANGE;
; 386  : 				}
; 387  :  #else
; 388  : 			_SCL_SECURE_VALIDATE(this->_Has_container());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Has_container@_Iterator_base_aux@std@@QBE_NXZ ; std::_Iterator_base_aux::_Has_container
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN7@Inc
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN7@Inc:

; 389  : 			if (_Isnil(_Ptr))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Isnil
	add	esp, 4
	movsx	eax, BYTE PTR [eax]
	test	eax, eax
	je	SHORT $LN6@Inc

; 390  : 				{
; 391  : 				_SCL_SECURE_OUT_OF_RANGE;

	call	DWORD PTR __imp___invalid_parameter_noinfo
	jmp	$LN8@Inc
$LN6@Inc:

; 392  : 				// end() shouldn't be incremented, don't move if _SCL_SECURE is not turned on
; 393  : 				}
; 394  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 395  : 
; 396  : 			else if (!_Isnil(_Right(_Ptr)))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	?_Right@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Right
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Isnil
	add	esp, 4
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN2@Inc

; 397  : 				_Ptr = _Min(_Right(_Ptr));	// ==> smallest of right subtree

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	?_Right@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?_Min@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Min
	add	esp, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], eax

; 398  : 			else

	jmp	SHORT $LN8@Inc
$LN2@Inc:

; 399  : 				{	// climb looking for right subtree
; 400  : 				_Nodeptr _Pnode;
; 401  : 				while (!_Isnil(_Pnode = _Parent(_Ptr))
; 402  : 					&& _Ptr == _Right(_Pnode))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Parent
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$131230[ebp], edx
	mov	eax, DWORD PTR __Pnode$131230[ebp]
	push	eax
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Isnil
	add	esp, 4
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN1@Inc
	mov	edx, DWORD PTR __Pnode$131230[ebp]
	push	edx
	call	?_Right@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, DWORD PTR [eax]
	jne	SHORT $LN1@Inc

; 403  : 					_Ptr = _Pnode;	// ==> parent while right subtree

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Pnode$131230[ebp]
	mov	DWORD PTR [eax+4], ecx
	jmp	SHORT $LN2@Inc
$LN1@Inc:

; 404  : 				_Ptr = _Pnode;	// ==> parent (head if end())

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Pnode$131230[ebp]
	mov	DWORD PTR [edx+4], eax
$LN8@Inc:

; 405  : 				}
; 406  : 			}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::const_iterator::_Inc
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Isnil@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Isnil@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Isnil, COMDAT

; 156  : 		{	// return reference to nil flag in node

	push	ebp
	mov	ebp, esp

; 157  : 		return ((_Charref)(*_Pnode)._Isnil);

	mov	eax, DWORD PTR __Pnode$[ebp]
	add	eax, 21					; 00000015H

; 158  : 		}

	pop	ebp
	ret	0
?_Isnil@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Isnil
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Parent@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Parent@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Parent, COMDAT

; 171  : 		{	// return reference to parent pointer in node

	push	ebp
	mov	ebp, esp

; 172  : 		return ((_Nodepref)(*_Pnode)._Parent);

	mov	eax, DWORD PTR __Pnode$[ebp]
	add	eax, 4

; 173  : 		}

	pop	ebp
	ret	0
?_Parent@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Parent
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Right@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Right@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Right, COMDAT

; 176  : 		{	// return reference to right pointer in node

	push	ebp
	mov	ebp, esp

; 177  : 		return ((_Nodepref)(*_Pnode)._Right);

	mov	eax, DWORD PTR __Pnode$[ebp]
	add	eax, 8

; 178  : 		}

	pop	ebp
	ret	0
?_Right@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Right
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Min@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Min@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Min, COMDAT

; 1312 : 		{	// return leftmost node in subtree at _Pnode

	push	ebp
	mov	ebp, esp
$LN2@Min:

; 1313 : 		while (!_Isnil(_Left(_Pnode)))

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Isnil
	add	esp, 4
	movsx	edx, BYTE PTR [eax]
	test	edx, edx
	jne	SHORT $LN1@Min

; 1314 : 			_Pnode = _Left(_Pnode);

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$[ebp], ecx
	jmp	SHORT $LN2@Min
$LN1@Min:

; 1315 : 		return (_Pnode);

	mov	eax, DWORD PTR __Pnode$[ebp]

; 1316 : 		}

	pop	ebp
	ret	0
?_Min@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Min
_TEXT	ENDS
END

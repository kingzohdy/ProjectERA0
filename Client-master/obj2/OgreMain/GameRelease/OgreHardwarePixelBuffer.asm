; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	i:\svnroot\client\OgreMain\OgreHardwarePixelBuffer.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	?_Value@?$_Is_swap_move@U_Swap_move_tag@std@@@std@@2_NB ; std::_Is_swap_move<std::_Swap_move_tag>::_Value
PUBLIC	?collate@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::collate
PUBLIC	?ctype@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::ctype
PUBLIC	?monetary@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::monetary
PUBLIC	?numeric@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::numeric
PUBLIC	?time@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::time
PUBLIC	?messages@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::messages
PUBLIC	?all@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::all
PUBLIC	?none@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::none
PUBLIC	?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::skipws
PUBLIC	?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::unitbuf
PUBLIC	?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::uppercase
PUBLIC	?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showbase
PUBLIC	?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpoint
PUBLIC	?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpos
PUBLIC	?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::left
PUBLIC	?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::right
PUBLIC	?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::internal
PUBLIC	?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::dec
PUBLIC	?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::oct
PUBLIC	?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::hex
PUBLIC	?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::scientific
PUBLIC	?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::fixed
PUBLIC	?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::hexfloat
PUBLIC	?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::boolalpha
PUBLIC	?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::_Stdio
PUBLIC	?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::adjustfield
PUBLIC	?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::basefield
PUBLIC	?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::floatfield
PUBLIC	?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::goodbit
PUBLIC	?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::eofbit
PUBLIC	?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::failbit
PUBLIC	?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::badbit
PUBLIC	?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::_Hardfail
PUBLIC	?in@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::in
PUBLIC	?out@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::out
PUBLIC	?ate@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::ate
PUBLIC	?app@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::app
PUBLIC	?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::trunc
PUBLIC	?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Nocreate
PUBLIC	?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Noreplace
PUBLIC	?binary@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::binary
PUBLIC	?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::beg
PUBLIC	?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::cur
PUBLIC	?end@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::end
PUBLIC	?value@?$integral_constant@_N$0A@@tr1@std@@2_NB	; std::tr1::integral_constant<bool,0>::value
PUBLIC	?value@?$integral_constant@_N$00@tr1@std@@2_NB	; std::tr1::integral_constant<bool,1>::value
PUBLIC	?ms_Singleton@?$Singleton@VHardwareBufferManager@Ogre@@@Ogre@@1PAVHardwareBufferManager@2@A ; Ogre::Singleton<Ogre::HardwareBufferManager>::ms_Singleton
PUBLIC	?ms_Singleton@?$Singleton@VHardwarePixelBufferManager@Ogre@@@Ogre@@1PAVHardwarePixelBufferManager@2@A ; Ogre::Singleton<Ogre::HardwarePixelBufferManager>::ms_Singleton
;	COMDAT ?ms_Singleton@?$Singleton@VHardwareBufferManager@Ogre@@@Ogre@@1PAVHardwareBufferManager@2@A
_BSS	SEGMENT
?ms_Singleton@?$Singleton@VHardwareBufferManager@Ogre@@@Ogre@@1PAVHardwareBufferManager@2@A DD 01H DUP (?) ; Ogre::Singleton<Ogre::HardwareBufferManager>::ms_Singleton
_BSS	ENDS
;	COMDAT ?ms_Singleton@?$Singleton@VHardwarePixelBufferManager@Ogre@@@Ogre@@1PAVHardwarePixelBufferManager@2@A
_BSS	SEGMENT
?ms_Singleton@?$Singleton@VHardwarePixelBufferManager@Ogre@@@Ogre@@1PAVHardwarePixelBufferManager@2@A DD 01H DUP (?) ; Ogre::Singleton<Ogre::HardwarePixelBufferManager>::ms_Singleton
_BSS	ENDS
;	COMDAT ?value@?$integral_constant@_N$00@tr1@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$00@tr1@std@@2_NB DB 01H	; std::tr1::integral_constant<bool,1>::value
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$0A@@tr1@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$0A@@tr1@std@@2_NB DB 00H	; std::tr1::integral_constant<bool,0>::value
CONST	ENDS
;	COMDAT ?end@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?end@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 02H		; std::_Iosb<int>::end
CONST	ENDS
;	COMDAT ?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 01H		; std::_Iosb<int>::cur
CONST	ENDS
;	COMDAT ?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 00H		; std::_Iosb<int>::beg
CONST	ENDS
;	COMDAT ?binary@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?binary@?$_Iosb@H@std@@2W4_Openmode@12@B DD 020H	; std::_Iosb<int>::binary
CONST	ENDS
;	COMDAT ?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B DD 080H	; std::_Iosb<int>::_Noreplace
CONST	ENDS
;	COMDAT ?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 040H	; std::_Iosb<int>::_Nocreate
CONST	ENDS
;	COMDAT ?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B DD 010H		; std::_Iosb<int>::trunc
CONST	ENDS
;	COMDAT ?app@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?app@?$_Iosb@H@std@@2W4_Openmode@12@B DD 08H		; std::_Iosb<int>::app
CONST	ENDS
;	COMDAT ?ate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?ate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 04H		; std::_Iosb<int>::ate
CONST	ENDS
;	COMDAT ?out@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?out@?$_Iosb@H@std@@2W4_Openmode@12@B DD 02H		; std::_Iosb<int>::out
CONST	ENDS
;	COMDAT ?in@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?in@?$_Iosb@H@std@@2W4_Openmode@12@B DD 01H		; std::_Iosb<int>::in
CONST	ENDS
;	COMDAT ?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B DD 010H	; std::_Iosb<int>::_Hardfail
CONST	ENDS
;	COMDAT ?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 04H		; std::_Iosb<int>::badbit
CONST	ENDS
;	COMDAT ?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 02H		; std::_Iosb<int>::failbit
CONST	ENDS
;	COMDAT ?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 01H		; std::_Iosb<int>::eofbit
CONST	ENDS
;	COMDAT ?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 00H		; std::_Iosb<int>::goodbit
CONST	ENDS
;	COMDAT ?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 03000H	; std::_Iosb<int>::floatfield
CONST	ENDS
;	COMDAT ?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0e00H	; std::_Iosb<int>::basefield
CONST	ENDS
;	COMDAT ?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01c0H	; std::_Iosb<int>::adjustfield
CONST	ENDS
;	COMDAT ?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08000H	; std::_Iosb<int>::_Stdio
CONST	ENDS
;	COMDAT ?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04000H	; std::_Iosb<int>::boolalpha
CONST	ENDS
;	COMDAT ?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 03000H	; std::_Iosb<int>::hexfloat
CONST	ENDS
;	COMDAT ?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02000H	; std::_Iosb<int>::fixed
CONST	ENDS
;	COMDAT ?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01000H	; std::_Iosb<int>::scientific
CONST	ENDS
;	COMDAT ?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0800H		; std::_Iosb<int>::hex
CONST	ENDS
;	COMDAT ?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0400H		; std::_Iosb<int>::oct
CONST	ENDS
;	COMDAT ?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0200H		; std::_Iosb<int>::dec
CONST	ENDS
;	COMDAT ?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0100H	; std::_Iosb<int>::internal
CONST	ENDS
;	COMDAT ?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 080H		; std::_Iosb<int>::right
CONST	ENDS
;	COMDAT ?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 040H		; std::_Iosb<int>::left
CONST	ENDS
;	COMDAT ?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 020H	; std::_Iosb<int>::showpos
CONST	ENDS
;	COMDAT ?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 010H	; std::_Iosb<int>::showpoint
CONST	ENDS
;	COMDAT ?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08H	; std::_Iosb<int>::showbase
CONST	ENDS
;	COMDAT ?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04H	; std::_Iosb<int>::uppercase
CONST	ENDS
;	COMDAT ?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02H	; std::_Iosb<int>::unitbuf
CONST	ENDS
;	COMDAT ?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01H		; std::_Iosb<int>::skipws
CONST	ENDS
;	COMDAT ?none@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?none@?$_Locbase@H@std@@2HB DD 00H			; std::_Locbase<int>::none
CONST	ENDS
;	COMDAT ?all@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?all@?$_Locbase@H@std@@2HB DD 03fH			; std::_Locbase<int>::all
CONST	ENDS
;	COMDAT ?messages@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?messages@?$_Locbase@H@std@@2HB DD 020H			; std::_Locbase<int>::messages
CONST	ENDS
;	COMDAT ?time@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?time@?$_Locbase@H@std@@2HB DD 010H			; std::_Locbase<int>::time
CONST	ENDS
;	COMDAT ?numeric@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?numeric@?$_Locbase@H@std@@2HB DD 08H			; std::_Locbase<int>::numeric
CONST	ENDS
;	COMDAT ?monetary@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?monetary@?$_Locbase@H@std@@2HB DD 04H			; std::_Locbase<int>::monetary
CONST	ENDS
;	COMDAT ?ctype@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?ctype@?$_Locbase@H@std@@2HB DD 02H			; std::_Locbase<int>::ctype
CONST	ENDS
;	COMDAT ?collate@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?collate@?$_Locbase@H@std@@2HB DD 01H			; std::_Locbase<int>::collate
CONST	ENDS
;	COMDAT ?_Value@?$_Is_swap_move@U_Swap_move_tag@std@@@std@@2_NB
CONST	SEGMENT
?_Value@?$_Is_swap_move@U_Swap_move_tag@std@@@std@@2_NB DB 01H ; std::_Is_swap_move<std::_Swap_move_tag>::_Value
CONST	ENDS
_DATA	SEGMENT
__bad_alloc_Message DD FLAT:$SG5715
_DATA	ENDS
CONST	SEGMENT
$SG5715	DB	'bad allocation', 00H
CONST	ENDS
PUBLIC	??4MemoryDelegation@Ogre@@QAEAAV01@ABV01@@Z	; Ogre::MemoryDelegation::operator=
; Function compile flags: /Odtp
;	COMDAT ??4MemoryDelegation@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4MemoryDelegation@Ogre@@QAEAAV01@ABV01@@Z PROC	; Ogre::MemoryDelegation::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4MemoryDelegation@Ogre@@QAEAAV01@ABV01@@Z ENDP	; Ogre::MemoryDelegation::operator=
_TEXT	ENDS
PUBLIC	?getBaseClass@RuntimeClass@Ogre@@QBEPBV12@XZ	; Ogre::RuntimeClass::getBaseClass
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogrebaseobject.h
;	COMDAT ?getBaseClass@RuntimeClass@Ogre@@QBEPBV12@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getBaseClass@RuntimeClass@Ogre@@QBEPBV12@XZ PROC	; Ogre::RuntimeClass::getBaseClass, COMDAT
; _this$ = ecx

; 20   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 21   : 			return m_pBaseClass;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 22   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?getBaseClass@RuntimeClass@Ogre@@QBEPBV12@XZ ENDP	; Ogre::RuntimeClass::getBaseClass
_TEXT	ENDS
PUBLIC	?getClassName@RuntimeClass@Ogre@@QBEPBDXZ	; Ogre::RuntimeClass::getClassName
; Function compile flags: /Odtp
;	COMDAT ?getClassName@RuntimeClass@Ogre@@QBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getClassName@RuntimeClass@Ogre@@QBEPBDXZ PROC		; Ogre::RuntimeClass::getClassName, COMDAT
; _this$ = ecx

; 25   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 26   : 			return m_pClassName; 

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 27   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?getClassName@RuntimeClass@Ogre@@QBEPBDXZ ENDP		; Ogre::RuntimeClass::getClassName
_TEXT	ENDS
PUBLIC	?getVersion@RuntimeClass@Ogre@@QBEHXZ		; Ogre::RuntimeClass::getVersion
; Function compile flags: /Odtp
;	COMDAT ?getVersion@RuntimeClass@Ogre@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getVersion@RuntimeClass@Ogre@@QBEHXZ PROC		; Ogre::RuntimeClass::getVersion, COMDAT
; _this$ = ecx

; 30   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 31   : 			return m_Version;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]

; 32   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?getVersion@RuntimeClass@Ogre@@QBEHXZ ENDP		; Ogre::RuntimeClass::getVersion
_TEXT	ENDS
PUBLIC	?newObject@RuntimeClass@Ogre@@QAEPAVBaseObject@2@XZ ; Ogre::RuntimeClass::newObject
; Function compile flags: /Odtp
;	COMDAT ?newObject@RuntimeClass@Ogre@@QAEPAVBaseObject@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?newObject@RuntimeClass@Ogre@@QAEPAVBaseObject@2@XZ PROC ; Ogre::RuntimeClass::newObject, COMDAT
; _this$ = ecx

; 35   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 36   : 			return (*m_pNewFunc)();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	call	ecx

; 37   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?newObject@RuntimeClass@Ogre@@QAEPAVBaseObject@2@XZ ENDP ; Ogre::RuntimeClass::newObject
_TEXT	ENDS
PUBLIC	??4RuntimeClass@Ogre@@QAEAAV01@ABV01@@Z		; Ogre::RuntimeClass::operator=
; Function compile flags: /Odtp
;	COMDAT ??4RuntimeClass@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4RuntimeClass@Ogre@@QAEAAV01@ABV01@@Z PROC		; Ogre::RuntimeClass::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], edx
	mov	eax, DWORD PTR [eax+16]
	mov	DWORD PTR [ecx+16], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4RuntimeClass@Ogre@@QAEAAV01@ABV01@@Z ENDP		; Ogre::RuntimeClass::operator=
_TEXT	ENDS
PUBLIC	?getRTTI@BaseObject@Ogre@@UBEPBVRuntimeClass@2@XZ ; Ogre::BaseObject::getRTTI
EXTRN	?m_RTTI@BaseObject@Ogre@@2VRuntimeClass@2@B:BYTE ; Ogre::BaseObject::m_RTTI
; Function compile flags: /Odtp
;	COMDAT ?getRTTI@BaseObject@Ogre@@UBEPBVRuntimeClass@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getRTTI@BaseObject@Ogre@@UBEPBVRuntimeClass@2@XZ PROC	; Ogre::BaseObject::getRTTI, COMDAT
; _this$ = ecx

; 56   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 57   : 			return &m_RTTI;

	mov	eax, OFFSET ?m_RTTI@BaseObject@Ogre@@2VRuntimeClass@2@B ; Ogre::BaseObject::m_RTTI

; 58   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?getRTTI@BaseObject@Ogre@@UBEPBVRuntimeClass@2@XZ ENDP	; Ogre::BaseObject::getRTTI
_TEXT	ENDS
PUBLIC	?isExactKindOf@BaseObject@Ogre@@QBE_NPBVRuntimeClass@2@@Z ; Ogre::BaseObject::isExactKindOf
; Function compile flags: /Odtp
;	COMDAT ?isExactKindOf@BaseObject@Ogre@@QBE_NPBVRuntimeClass@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_prtti$ = 8						; size = 4
?isExactKindOf@BaseObject@Ogre@@QBE_NPBVRuntimeClass@2@@Z PROC ; Ogre::BaseObject::isExactKindOf, COMDAT
; _this$ = ecx

; 61   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 62   : 			return (getRTTI() == prtti);

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	call	eax
	xor	ecx, ecx
	cmp	eax, DWORD PTR _prtti$[ebp]
	sete	cl
	mov	al, cl

; 63   : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?isExactKindOf@BaseObject@Ogre@@QBE_NPBVRuntimeClass@2@@Z ENDP ; Ogre::BaseObject::isExactKindOf
_TEXT	ENDS
PUBLIC	?release@BaseObject@Ogre@@UAEXXZ		; Ogre::BaseObject::release
; Function compile flags: /Odtp
;	COMDAT ?release@BaseObject@Ogre@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?release@BaseObject@Ogre@@UAEXXZ PROC			; Ogre::BaseObject::release, COMDAT
; _this$ = ecx

; 68   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 69   : 			m_RefCount--;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	sub	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 70   : 			if(m_RefCount <= 0 )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jg	SHORT $LN2@release

; 71   : 			{
; 72   : 				deleteThis();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24]
	call	eax
$LN2@release:

; 73   : 			}
; 74   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?release@BaseObject@Ogre@@UAEXXZ ENDP			; Ogre::BaseObject::release
_TEXT	ENDS
PUBLIC	?addRef@BaseObject@Ogre@@UAEXXZ			; Ogre::BaseObject::addRef
; Function compile flags: /Odtp
;	COMDAT ?addRef@BaseObject@Ogre@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?addRef@BaseObject@Ogre@@UAEXXZ PROC			; Ogre::BaseObject::addRef, COMDAT
; _this$ = ecx

; 77   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 78   : 			m_RefCount++;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 79   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?addRef@BaseObject@Ogre@@UAEXXZ ENDP			; Ogre::BaseObject::addRef
_TEXT	ENDS
PUBLIC	?getRefCount@BaseObject@Ogre@@UAEHXZ		; Ogre::BaseObject::getRefCount
; Function compile flags: /Odtp
;	COMDAT ?getRefCount@BaseObject@Ogre@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getRefCount@BaseObject@Ogre@@UAEHXZ PROC		; Ogre::BaseObject::getRefCount, COMDAT
; _this$ = ecx

; 82   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 83   : 			return m_RefCount;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 84   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?getRefCount@BaseObject@Ogre@@UAEHXZ ENDP		; Ogre::BaseObject::getRefCount
_TEXT	ENDS
PUBLIC	?_serialize@BaseObject@Ogre@@UAEXAAVArchive@2@H@Z ; Ogre::BaseObject::_serialize
; Function compile flags: /Odtp
;	COMDAT ?_serialize@BaseObject@Ogre@@UAEXAAVArchive@2@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_ar$ = 8						; size = 4
_version$ = 12						; size = 4
?_serialize@BaseObject@Ogre@@UAEXAAVArchive@2@H@Z PROC	; Ogre::BaseObject::_serialize, COMDAT
; _this$ = ecx

; 87   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 88   : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?_serialize@BaseObject@Ogre@@UAEXAAVArchive@2@H@Z ENDP	; Ogre::BaseObject::_serialize
_TEXT	ENDS
PUBLIC	??_7BaseObject@Ogre@@6B@			; Ogre::BaseObject::`vftable'
PUBLIC	??0BaseObject@Ogre@@IAE@XZ			; Ogre::BaseObject::BaseObject
PUBLIC	??_R4BaseObject@Ogre@@6B@			; Ogre::BaseObject::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVBaseObject@Ogre@@@8			; Ogre::BaseObject `RTTI Type Descriptor'
PUBLIC	??_R3BaseObject@Ogre@@8				; Ogre::BaseObject::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2BaseObject@Ogre@@8				; Ogre::BaseObject::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@BaseObject@Ogre@@8		; Ogre::BaseObject::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R13?0A@EA@MemoryDelegation@Ogre@@8		; Ogre::MemoryDelegation::`RTTI Base Class Descriptor at (4,-1,0,64)'
PUBLIC	??_R0?AVMemoryDelegation@Ogre@@@8		; Ogre::MemoryDelegation `RTTI Type Descriptor'
PUBLIC	??_R3MemoryDelegation@Ogre@@8			; Ogre::MemoryDelegation::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2MemoryDelegation@Ogre@@8			; Ogre::MemoryDelegation::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@MemoryDelegation@Ogre@@8		; Ogre::MemoryDelegation::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_EBaseObject@Ogre@@MAEPAXI@Z			; Ogre::BaseObject::`vector deleting destructor'
PUBLIC	?deleteThis@BaseObject@Ogre@@MAEXXZ		; Ogre::BaseObject::deleteThis
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
;	COMDAT ??_R1A@?0A@EA@MemoryDelegation@Ogre@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@MemoryDelegation@Ogre@@8 DD FLAT:??_R0?AVMemoryDelegation@Ogre@@@8 ; Ogre::MemoryDelegation::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3MemoryDelegation@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R2MemoryDelegation@Ogre@@8
rdata$r	SEGMENT
??_R2MemoryDelegation@Ogre@@8 DD FLAT:??_R1A@?0A@EA@MemoryDelegation@Ogre@@8 ; Ogre::MemoryDelegation::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3MemoryDelegation@Ogre@@8
rdata$r	SEGMENT
??_R3MemoryDelegation@Ogre@@8 DD 00H			; Ogre::MemoryDelegation::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2MemoryDelegation@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVMemoryDelegation@Ogre@@@8
_DATA	SEGMENT
??_R0?AVMemoryDelegation@Ogre@@@8 DD FLAT:??_7type_info@@6B@ ; Ogre::MemoryDelegation `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVMemoryDelegation@Ogre@@', 00H
_DATA	ENDS
;	COMDAT ??_R13?0A@EA@MemoryDelegation@Ogre@@8
rdata$r	SEGMENT
??_R13?0A@EA@MemoryDelegation@Ogre@@8 DD FLAT:??_R0?AVMemoryDelegation@Ogre@@@8 ; Ogre::MemoryDelegation::`RTTI Base Class Descriptor at (4,-1,0,64)'
	DD	00H
	DD	04H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3MemoryDelegation@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@BaseObject@Ogre@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@BaseObject@Ogre@@8 DD FLAT:??_R0?AVBaseObject@Ogre@@@8 ; Ogre::BaseObject::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3BaseObject@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R2BaseObject@Ogre@@8
rdata$r	SEGMENT
??_R2BaseObject@Ogre@@8 DD FLAT:??_R1A@?0A@EA@BaseObject@Ogre@@8 ; Ogre::BaseObject::`RTTI Base Class Array'
	DD	FLAT:??_R13?0A@EA@MemoryDelegation@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R3BaseObject@Ogre@@8
rdata$r	SEGMENT
??_R3BaseObject@Ogre@@8 DD 00H				; Ogre::BaseObject::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2BaseObject@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVBaseObject@Ogre@@@8
_DATA	SEGMENT
??_R0?AVBaseObject@Ogre@@@8 DD FLAT:??_7type_info@@6B@	; Ogre::BaseObject `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVBaseObject@Ogre@@', 00H
_DATA	ENDS
;	COMDAT ??_R4BaseObject@Ogre@@6B@
rdata$r	SEGMENT
??_R4BaseObject@Ogre@@6B@ DD 00H			; Ogre::BaseObject::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVBaseObject@Ogre@@@8
	DD	FLAT:??_R3BaseObject@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_7BaseObject@Ogre@@6B@
CONST	SEGMENT
??_7BaseObject@Ogre@@6B@ DD FLAT:??_R4BaseObject@Ogre@@6B@ ; Ogre::BaseObject::`vftable'
	DD	FLAT:?getRTTI@BaseObject@Ogre@@UBEPBVRuntimeClass@2@XZ
	DD	FLAT:?release@BaseObject@Ogre@@UAEXXZ
	DD	FLAT:?addRef@BaseObject@Ogre@@UAEXXZ
	DD	FLAT:?getRefCount@BaseObject@Ogre@@UAEHXZ
	DD	FLAT:?_serialize@BaseObject@Ogre@@UAEXAAVArchive@2@H@Z
	DD	FLAT:??_EBaseObject@Ogre@@MAEPAXI@Z
	DD	FLAT:?deleteThis@BaseObject@Ogre@@MAEXXZ
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ??0BaseObject@Ogre@@IAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0BaseObject@Ogre@@IAE@XZ PROC				; Ogre::BaseObject::BaseObject, COMDAT
; _this$ = ecx

; 92   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7BaseObject@Ogre@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 1

; 93   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0BaseObject@Ogre@@IAE@XZ ENDP				; Ogre::BaseObject::BaseObject
_TEXT	ENDS
PUBLIC	??1BaseObject@Ogre@@MAE@XZ			; Ogre::BaseObject::~BaseObject
; Function compile flags: /Odtp
;	COMDAT ??1BaseObject@Ogre@@MAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1BaseObject@Ogre@@MAE@XZ PROC				; Ogre::BaseObject::~BaseObject, COMDAT
; _this$ = ecx

; 96   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7BaseObject@Ogre@@6B@

; 97   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??1BaseObject@Ogre@@MAE@XZ ENDP				; Ogre::BaseObject::~BaseObject
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?deleteThis@BaseObject@Ogre@@MAEXXZ
_TEXT	SEGMENT
tv70 = -16						; size = 4
_this$ = -12						; size = 4
$T71442 = -8						; size = 4
$T71441 = -4						; size = 4
?deleteThis@BaseObject@Ogre@@MAEXXZ PROC		; Ogre::BaseObject::deleteThis, COMDAT
; _this$ = ecx

; 100  : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 101  : 			delete this;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR $T71442[ebp], eax
	mov	ecx, DWORD PTR $T71442[ebp]
	mov	DWORD PTR $T71441[ebp], ecx
	cmp	DWORD PTR $T71441[ebp], 0
	je	SHORT $LN3@deleteThis
	push	1
	mov	edx, DWORD PTR $T71441[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR $T71441[ebp]
	mov	edx, DWORD PTR [eax+20]
	call	edx
	mov	DWORD PTR tv70[ebp], eax
	jmp	SHORT $LN1@deleteThis
$LN3@deleteThis:
	mov	DWORD PTR tv70[ebp], 0
$LN1@deleteThis:

; 102  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?deleteThis@BaseObject@Ogre@@MAEXXZ ENDP		; Ogre::BaseObject::deleteThis
_TEXT	ENDS
PUBLIC	??0BaseObject@Ogre@@QAE@ABV01@@Z		; Ogre::BaseObject::BaseObject
; Function compile flags: /Odtp
;	COMDAT ??0BaseObject@Ogre@@QAE@ABV01@@Z
_TEXT	SEGMENT
tv68 = -8						; size = 4
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0BaseObject@Ogre@@QAE@ABV01@@Z PROC			; Ogre::BaseObject::BaseObject, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	cmp	DWORD PTR ___that$[ebp], 0
	je	SHORT $LN3@BaseObject
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 4
	mov	DWORD PTR tv68[ebp], eax
	jmp	SHORT $LN4@BaseObject
$LN3@BaseObject:
	mov	DWORD PTR tv68[ebp], 0
$LN4@BaseObject:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7BaseObject@Ogre@@6B@
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0BaseObject@Ogre@@QAE@ABV01@@Z ENDP			; Ogre::BaseObject::BaseObject
_TEXT	ENDS
PUBLIC	??4BaseObject@Ogre@@QAEAAV01@ABV01@@Z		; Ogre::BaseObject::operator=
; Function compile flags: /Odtp
;	COMDAT ??4BaseObject@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4BaseObject@Ogre@@QAEAAV01@ABV01@@Z PROC		; Ogre::BaseObject::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4BaseObject@Ogre@@QAEAAV01@ABV01@@Z ENDP		; Ogre::BaseObject::operator=
_TEXT	ENDS
PUBLIC	??_GBaseObject@Ogre@@MAEPAXI@Z			; Ogre::BaseObject::`scalar deleting destructor'
EXTRN	??3MemoryDelegation@Ogre@@SAXPAXI@Z:PROC	; Ogre::MemoryDelegation::operator delete
; Function compile flags: /Odtp
;	COMDAT ??_GBaseObject@Ogre@@MAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GBaseObject@Ogre@@MAEPAXI@Z PROC			; Ogre::BaseObject::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1BaseObject@Ogre@@MAE@XZ		; Ogre::BaseObject::~BaseObject
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	push	8
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3MemoryDelegation@Ogre@@SAXPAXI@Z	; Ogre::MemoryDelegation::operator delete
	add	esp, 8
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GBaseObject@Ogre@@MAEPAXI@Z ENDP			; Ogre::BaseObject::`scalar deleting destructor'
_TEXT	ENDS
EXTRN	??_VMemoryDelegation@Ogre@@SAXPAXI@Z:PROC	; Ogre::MemoryDelegation::operator delete[]
EXTRN	??_M@YGXPAXIHP6EX0@Z@Z:PROC			; `eh vector destructor iterator'
; Function compile flags: /Odtp
;	COMDAT ??_EBaseObject@Ogre@@MAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_EBaseObject@Ogre@@MAEPAXI@Z PROC			; Ogre::BaseObject::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 2
	je	SHORT $LN3@vector
	push	OFFSET ??1BaseObject@Ogre@@MAE@XZ	; Ogre::BaseObject::~BaseObject
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx-4]
	push	edx
	push	8
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??_M@YGXPAXIHP6EX0@Z@Z
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN2@vector
	push	8
	mov	edx, DWORD PTR _this$[ebp]
	sub	edx, 4
	push	edx
	call	??_VMemoryDelegation@Ogre@@SAXPAXI@Z	; Ogre::MemoryDelegation::operator delete[]
	add	esp, 8
$LN2@vector:
	mov	eax, DWORD PTR _this$[ebp]
	sub	eax, 4
	jmp	SHORT $LN4@vector
$LN3@vector:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1BaseObject@Ogre@@MAE@XZ		; Ogre::BaseObject::~BaseObject
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@vector
	push	8
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3MemoryDelegation@Ogre@@SAXPAXI@Z	; Ogre::MemoryDelegation::operator delete
	add	esp, 8
$LN1@vector:
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector:
	mov	esp, ebp
	pop	ebp
	ret	4
??_EBaseObject@Ogre@@MAEPAXI@Z ENDP			; Ogre::BaseObject::`vector deleting destructor'
_TEXT	ENDS
PUBLIC	?handle2Ptr@FixedString@Ogre@@SAPBDPAX@Z	; Ogre::FixedString::handle2Ptr
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogrefixedstring.h
;	COMDAT ?handle2Ptr@FixedString@Ogre@@SAPBDPAX@Z
_TEXT	SEGMENT
_h$ = 8							; size = 4
?handle2Ptr@FixedString@Ogre@@SAPBDPAX@Z PROC		; Ogre::FixedString::handle2Ptr, COMDAT

; 22   : 		{

	push	ebp
	mov	ebp, esp

; 23   : 			return (const char *)h;

	mov	eax, DWORD PTR _h$[ebp]

; 24   : 		}

	pop	ebp
	ret	0
?handle2Ptr@FixedString@Ogre@@SAPBDPAX@Z ENDP		; Ogre::FixedString::handle2Ptr
_TEXT	ENDS
PUBLIC	??0FixedString@Ogre@@QAE@XZ			; Ogre::FixedString::FixedString
; Function compile flags: /Odtp
;	COMDAT ??0FixedString@Ogre@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0FixedString@Ogre@@QAE@XZ PROC			; Ogre::FixedString::FixedString, COMDAT
; _this$ = ecx

; 27   : 		FixedString() : m_StrHandle(NULL){}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0FixedString@Ogre@@QAE@XZ ENDP			; Ogre::FixedString::FixedString
_TEXT	ENDS
PUBLIC	??0FixedString@Ogre@@QAE@PAX@Z			; Ogre::FixedString::FixedString
EXTRN	?addRef@FixedString@Ogre@@SAXPAX@Z:PROC		; Ogre::FixedString::addRef
; Function compile flags: /Odtp
;	COMDAT ??0FixedString@Ogre@@QAE@PAX@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_h$ = 8							; size = 4
??0FixedString@Ogre@@QAE@PAX@Z PROC			; Ogre::FixedString::FixedString, COMDAT
; _this$ = ecx

; 29   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _h$[ebp]
	mov	DWORD PTR [eax], ecx

; 30   : 			addRef(h);

	mov	edx, DWORD PTR _h$[ebp]
	push	edx
	call	?addRef@FixedString@Ogre@@SAXPAX@Z	; Ogre::FixedString::addRef
	add	esp, 4

; 31   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0FixedString@Ogre@@QAE@PAX@Z ENDP			; Ogre::FixedString::FixedString
_TEXT	ENDS
PUBLIC	??0FixedString@Ogre@@QAE@ABV01@@Z		; Ogre::FixedString::FixedString
; Function compile flags: /Odtp
;	COMDAT ??0FixedString@Ogre@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_rhs$ = 8						; size = 4
??0FixedString@Ogre@@QAE@ABV01@@Z PROC			; Ogre::FixedString::FixedString, COMDAT
; _this$ = ecx

; 34   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _rhs$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 35   : 			addRef(m_StrHandle);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?addRef@FixedString@Ogre@@SAXPAX@Z	; Ogre::FixedString::addRef
	add	esp, 4

; 36   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0FixedString@Ogre@@QAE@ABV01@@Z ENDP			; Ogre::FixedString::FixedString
_TEXT	ENDS
PUBLIC	??0FixedString@Ogre@@QAE@PBD@Z			; Ogre::FixedString::FixedString
EXTRN	?insert@FixedString@Ogre@@SAPAXPBDH@Z:PROC	; Ogre::FixedString::insert
; Function compile flags: /Odtp
;	COMDAT ??0FixedString@Ogre@@QAE@PBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pstr$ = 8						; size = 4
??0FixedString@Ogre@@QAE@PBD@Z PROC			; Ogre::FixedString::FixedString, COMDAT
; _this$ = ecx

; 38   : 		FixedString(const char *pstr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 39   : 		{
; 40   : 			m_StrHandle = insert(pstr); 

	push	-1
	mov	eax, DWORD PTR _pstr$[ebp]
	push	eax
	call	?insert@FixedString@Ogre@@SAPAXPBDH@Z	; Ogre::FixedString::insert
	add	esp, 8
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 41   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0FixedString@Ogre@@QAE@PBD@Z ENDP			; Ogre::FixedString::FixedString
_TEXT	ENDS
PUBLIC	??0FixedString@Ogre@@QAE@PBDI@Z			; Ogre::FixedString::FixedString
; Function compile flags: /Odtp
;	COMDAT ??0FixedString@Ogre@@QAE@PBDI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pstr$ = 8						; size = 4
_len$ = 12						; size = 4
??0FixedString@Ogre@@QAE@PBDI@Z PROC			; Ogre::FixedString::FixedString, COMDAT
; _this$ = ecx

; 43   : 		FixedString(const char *pstr, size_t len)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 44   : 		{
; 45   : 			m_StrHandle = insert(pstr, (int)len); 

	mov	eax, DWORD PTR _len$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pstr$[ebp]
	push	ecx
	call	?insert@FixedString@Ogre@@SAPAXPBDH@Z	; Ogre::FixedString::insert
	add	esp, 8
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], eax

; 46   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0FixedString@Ogre@@QAE@PBDI@Z ENDP			; Ogre::FixedString::FixedString
_TEXT	ENDS
PUBLIC	??1FixedString@Ogre@@QAE@XZ			; Ogre::FixedString::~FixedString
EXTRN	?release@FixedString@Ogre@@SAXPAX@Z:PROC	; Ogre::FixedString::release
; Function compile flags: /Odtp
;	COMDAT ??1FixedString@Ogre@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1FixedString@Ogre@@QAE@XZ PROC			; Ogre::FixedString::~FixedString, COMDAT
; _this$ = ecx

; 49   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 50   : 			release(m_StrHandle); 

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?release@FixedString@Ogre@@SAXPAX@Z	; Ogre::FixedString::release
	add	esp, 4

; 51   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??1FixedString@Ogre@@QAE@XZ ENDP			; Ogre::FixedString::~FixedString
_TEXT	ENDS
PUBLIC	??BFixedString@Ogre@@QBEPBDXZ			; Ogre::FixedString::operator char const *
; Function compile flags: /Odtp
;	COMDAT ??BFixedString@Ogre@@QBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??BFixedString@Ogre@@QBEPBDXZ PROC			; Ogre::FixedString::operator char const *, COMDAT
; _this$ = ecx

; 54   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 55   : 			return handle2Ptr(m_StrHandle);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?handle2Ptr@FixedString@Ogre@@SAPBDPAX@Z ; Ogre::FixedString::handle2Ptr
	add	esp, 4

; 56   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??BFixedString@Ogre@@QBEPBDXZ ENDP			; Ogre::FixedString::operator char const *
_TEXT	ENDS
PUBLIC	?getHandle@FixedString@Ogre@@QBEPAXXZ		; Ogre::FixedString::getHandle
; Function compile flags: /Odtp
;	COMDAT ?getHandle@FixedString@Ogre@@QBEPAXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getHandle@FixedString@Ogre@@QBEPAXXZ PROC		; Ogre::FixedString::getHandle, COMDAT
; _this$ = ecx

; 59   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 60   : 			return m_StrHandle;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 61   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?getHandle@FixedString@Ogre@@QBEPAXXZ ENDP		; Ogre::FixedString::getHandle
_TEXT	ENDS
PUBLIC	?getRTTI@Resource@Ogre@@UBEPBVRuntimeClass@2@XZ	; Ogre::Resource::getRTTI
EXTRN	?m_RTTI@Resource@Ogre@@2VRuntimeClass@2@B:BYTE	; Ogre::Resource::m_RTTI
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogreresource.h
;	COMDAT ?getRTTI@Resource@Ogre@@UBEPBVRuntimeClass@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getRTTI@Resource@Ogre@@UBEPBVRuntimeClass@2@XZ PROC	; Ogre::Resource::getRTTI, COMDAT
; _this$ = ecx

; 39   : 		DECLARE_RTTI_VIRTUAL(Resource)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, OFFSET ?m_RTTI@Resource@Ogre@@2VRuntimeClass@2@B ; Ogre::Resource::m_RTTI
	mov	esp, ebp
	pop	ebp
	ret	0
?getRTTI@Resource@Ogre@@UBEPBVRuntimeClass@2@XZ ENDP	; Ogre::Resource::getRTTI
_TEXT	ENDS
PUBLIC	?getResPath@Resource@Ogre@@QAEABVFixedString@2@XZ ; Ogre::Resource::getResPath
; Function compile flags: /Odtp
;	COMDAT ?getResPath@Resource@Ogre@@QAEABVFixedString@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getResPath@Resource@Ogre@@QAEABVFixedString@2@XZ PROC	; Ogre::Resource::getResPath, COMDAT
; _this$ = ecx

; 44   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 45   : 			return m_ResPath;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8

; 46   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?getResPath@Resource@Ogre@@QAEABVFixedString@2@XZ ENDP	; Ogre::Resource::getResPath
_TEXT	ENDS
PUBLIC	?setResPath@Resource@Ogre@@QAEXABVFixedString@2@@Z ; Ogre::Resource::setResPath
EXTRN	??4FixedString@Ogre@@QAEAAV01@ABV01@@Z:PROC	; Ogre::FixedString::operator=
; Function compile flags: /Odtp
;	COMDAT ?setResPath@Resource@Ogre@@QAEXABVFixedString@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_path$ = 8						; size = 4
?setResPath@Resource@Ogre@@QAEXABVFixedString@2@@Z PROC	; Ogre::Resource::setResPath, COMDAT
; _this$ = ecx

; 48   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 49   : 			m_ResPath = path;

	mov	eax, DWORD PTR _path$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??4FixedString@Ogre@@QAEAAV01@ABV01@@Z	; Ogre::FixedString::operator=

; 50   : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?setResPath@Resource@Ogre@@QAEXABVFixedString@2@@Z ENDP	; Ogre::Resource::setResPath
_TEXT	ENDS
PUBLIC	??_7Resource@Ogre@@6B@				; Ogre::Resource::`vftable'
PUBLIC	??0Resource@Ogre@@IAE@XZ			; Ogre::Resource::Resource
PUBLIC	??_R4Resource@Ogre@@6B@				; Ogre::Resource::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVResource@Ogre@@@8			; Ogre::Resource `RTTI Type Descriptor'
PUBLIC	??_R3Resource@Ogre@@8				; Ogre::Resource::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2Resource@Ogre@@8				; Ogre::Resource::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@Resource@Ogre@@8			; Ogre::Resource::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_EResource@Ogre@@MAEPAXI@Z			; Ogre::Resource::`vector deleting destructor'
EXTRN	___security_cookie:DWORD
EXTRN	___CxxFrameHandler3:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	?release@Resource@Ogre@@UAEXXZ:PROC		; Ogre::Resource::release
EXTRN	?addRef@Resource@Ogre@@UAEXXZ:PROC		; Ogre::Resource::addRef
EXTRN	?getRefCount@Resource@Ogre@@UAEHXZ:PROC		; Ogre::Resource::getRefCount
;	COMDAT ??_R1A@?0A@EA@Resource@Ogre@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@Resource@Ogre@@8 DD FLAT:??_R0?AVResource@Ogre@@@8 ; Ogre::Resource::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3Resource@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R2Resource@Ogre@@8
rdata$r	SEGMENT
??_R2Resource@Ogre@@8 DD FLAT:??_R1A@?0A@EA@Resource@Ogre@@8 ; Ogre::Resource::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@BaseObject@Ogre@@8
	DD	FLAT:??_R13?0A@EA@MemoryDelegation@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R3Resource@Ogre@@8
rdata$r	SEGMENT
??_R3Resource@Ogre@@8 DD 00H				; Ogre::Resource::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2Resource@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVResource@Ogre@@@8
_DATA	SEGMENT
??_R0?AVResource@Ogre@@@8 DD FLAT:??_7type_info@@6B@	; Ogre::Resource `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVResource@Ogre@@', 00H
_DATA	ENDS
;	COMDAT ??_R4Resource@Ogre@@6B@
rdata$r	SEGMENT
??_R4Resource@Ogre@@6B@ DD 00H				; Ogre::Resource::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVResource@Ogre@@@8
	DD	FLAT:??_R3Resource@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_7Resource@Ogre@@6B@
CONST	SEGMENT
??_7Resource@Ogre@@6B@ DD FLAT:??_R4Resource@Ogre@@6B@	; Ogre::Resource::`vftable'
	DD	FLAT:?getRTTI@Resource@Ogre@@UBEPBVRuntimeClass@2@XZ
	DD	FLAT:?release@Resource@Ogre@@UAEXXZ
	DD	FLAT:?addRef@Resource@Ogre@@UAEXXZ
	DD	FLAT:?getRefCount@Resource@Ogre@@UAEHXZ
	DD	FLAT:?_serialize@BaseObject@Ogre@@UAEXAAVArchive@2@H@Z
	DD	FLAT:??_EResource@Ogre@@MAEPAXI@Z
	DD	FLAT:?deleteThis@BaseObject@Ogre@@MAEXXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0Resource@Ogre@@IAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0Resource@Ogre@@IAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0Resource@Ogre@@IAE@XZ$1
__ehfuncinfo$??0Resource@Ogre@@IAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0Resource@Ogre@@IAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0Resource@Ogre@@IAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0Resource@Ogre@@IAE@XZ PROC				; Ogre::Resource::Resource, COMDAT
; _this$ = ecx

; 72   : 		{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0Resource@Ogre@@IAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0BaseObject@Ogre@@IAE@XZ		; Ogre::BaseObject::BaseObject
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7Resource@Ogre@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??0FixedString@Ogre@@QAE@XZ		; Ogre::FixedString::FixedString
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 1

; 73   : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0Resource@Ogre@@IAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1BaseObject@Ogre@@MAE@XZ		; Ogre::BaseObject::~BaseObject
__unwindfunclet$??0Resource@Ogre@@IAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	jmp	??1FixedString@Ogre@@QAE@XZ		; Ogre::FixedString::~FixedString
__ehhandler$??0Resource@Ogre@@IAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0Resource@Ogre@@IAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0Resource@Ogre@@IAE@XZ ENDP				; Ogre::Resource::Resource
PUBLIC	??1Resource@Ogre@@MAE@XZ			; Ogre::Resource::~Resource
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1Resource@Ogre@@MAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1Resource@Ogre@@MAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1Resource@Ogre@@MAE@XZ$1
__ehfuncinfo$??1Resource@Ogre@@MAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??1Resource@Ogre@@MAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1Resource@Ogre@@MAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1Resource@Ogre@@MAE@XZ PROC				; Ogre::Resource::~Resource, COMDAT
; _this$ = ecx

; 76   : 		{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1Resource@Ogre@@MAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7Resource@Ogre@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 77   : 		}

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??1FixedString@Ogre@@QAE@XZ		; Ogre::FixedString::~FixedString
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1BaseObject@Ogre@@MAE@XZ		; Ogre::BaseObject::~BaseObject
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1Resource@Ogre@@MAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1BaseObject@Ogre@@MAE@XZ		; Ogre::BaseObject::~BaseObject
__unwindfunclet$??1Resource@Ogre@@MAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	jmp	??1FixedString@Ogre@@QAE@XZ		; Ogre::FixedString::~FixedString
__ehhandler$??1Resource@Ogre@@MAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1Resource@Ogre@@MAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1Resource@Ogre@@MAE@XZ ENDP				; Ogre::Resource::~Resource
PUBLIC	??0Resource@Ogre@@QAE@ABV01@@Z			; Ogre::Resource::Resource
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0Resource@Ogre@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0Resource@Ogre@@QAE@ABV01@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0Resource@Ogre@@QAE@ABV01@@Z$1
__ehfuncinfo$??0Resource@Ogre@@QAE@ABV01@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0Resource@Ogre@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0Resource@Ogre@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0Resource@Ogre@@QAE@ABV01@@Z PROC			; Ogre::Resource::Resource, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0Resource@Ogre@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0BaseObject@Ogre@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7Resource@Ogre@@6B@
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 8
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??0FixedString@Ogre@@QAE@ABV01@@Z	; Ogre::FixedString::FixedString
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+12], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0Resource@Ogre@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1BaseObject@Ogre@@MAE@XZ		; Ogre::BaseObject::~BaseObject
__unwindfunclet$??0Resource@Ogre@@QAE@ABV01@@Z$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	jmp	??1FixedString@Ogre@@QAE@XZ		; Ogre::FixedString::~FixedString
__ehhandler$??0Resource@Ogre@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0Resource@Ogre@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0Resource@Ogre@@QAE@ABV01@@Z ENDP			; Ogre::Resource::Resource
PUBLIC	??4Resource@Ogre@@QAEAAV01@ABV01@@Z		; Ogre::Resource::operator=
; Function compile flags: /Odtp
;	COMDAT ??4Resource@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4Resource@Ogre@@QAEAAV01@ABV01@@Z PROC		; Ogre::Resource::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4BaseObject@Ogre@@QAEAAV01@ABV01@@Z
	mov	ecx, DWORD PTR ___that$[ebp]
	add	ecx, 8
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??4FixedString@Ogre@@QAEAAV01@ABV01@@Z	; Ogre::FixedString::operator=
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4Resource@Ogre@@QAEAAV01@ABV01@@Z ENDP		; Ogre::Resource::operator=
_TEXT	ENDS
PUBLIC	??_GResource@Ogre@@MAEPAXI@Z			; Ogre::Resource::`scalar deleting destructor'
; Function compile flags: /Odtp
;	COMDAT ??_GResource@Ogre@@MAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GResource@Ogre@@MAEPAXI@Z PROC			; Ogre::Resource::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1Resource@Ogre@@MAE@XZ		; Ogre::Resource::~Resource
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@2
	push	16					; 00000010H
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3MemoryDelegation@Ogre@@SAXPAXI@Z	; Ogre::MemoryDelegation::operator delete
	add	esp, 8
$LN1@scalar@2:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GResource@Ogre@@MAEPAXI@Z ENDP			; Ogre::Resource::`scalar deleting destructor'
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_EResource@Ogre@@MAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_EResource@Ogre@@MAEPAXI@Z PROC			; Ogre::Resource::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 2
	je	SHORT $LN3@vector@2
	push	OFFSET ??1Resource@Ogre@@MAE@XZ		; Ogre::Resource::~Resource
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx-4]
	push	edx
	push	16					; 00000010H
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??_M@YGXPAXIHP6EX0@Z@Z
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN2@vector@2
	push	16					; 00000010H
	mov	edx, DWORD PTR _this$[ebp]
	sub	edx, 4
	push	edx
	call	??_VMemoryDelegation@Ogre@@SAXPAXI@Z	; Ogre::MemoryDelegation::operator delete[]
	add	esp, 8
$LN2@vector@2:
	mov	eax, DWORD PTR _this$[ebp]
	sub	eax, 4
	jmp	SHORT $LN4@vector@2
$LN3@vector@2:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1Resource@Ogre@@MAE@XZ		; Ogre::Resource::~Resource
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@vector@2
	push	16					; 00000010H
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3MemoryDelegation@Ogre@@SAXPAXI@Z	; Ogre::MemoryDelegation::operator delete
	add	esp, 8
$LN1@vector@2:
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector@2:
	mov	esp, ebp
	pop	ebp
	ret	4
??_EResource@Ogre@@MAEPAXI@Z ENDP			; Ogre::Resource::`vector deleting destructor'
_TEXT	ENDS
PUBLIC	?getRTTI@VertexBuffer@Ogre@@UBEPBVRuntimeClass@2@XZ ; Ogre::VertexBuffer::getRTTI
EXTRN	?m_RTTI@VertexBuffer@Ogre@@2VRuntimeClass@2@B:BYTE ; Ogre::VertexBuffer::m_RTTI
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogrerendertypes.h
;	COMDAT ?getRTTI@VertexBuffer@Ogre@@UBEPBVRuntimeClass@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getRTTI@VertexBuffer@Ogre@@UBEPBVRuntimeClass@2@XZ PROC ; Ogre::VertexBuffer::getRTTI, COMDAT
; _this$ = ecx

; 223  : 		DECLARE_RTTI_VIRTUAL(VertexBuffer)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, OFFSET ?m_RTTI@VertexBuffer@Ogre@@2VRuntimeClass@2@B ; Ogre::VertexBuffer::m_RTTI
	mov	esp, ebp
	pop	ebp
	ret	0
?getRTTI@VertexBuffer@Ogre@@UBEPBVRuntimeClass@2@XZ ENDP ; Ogre::VertexBuffer::getRTTI
_TEXT	ENDS
PUBLIC	??_7VertexBuffer@Ogre@@6B@			; Ogre::VertexBuffer::`vftable'
PUBLIC	??0VertexBuffer@Ogre@@QAE@XZ			; Ogre::VertexBuffer::VertexBuffer
PUBLIC	??_R4VertexBuffer@Ogre@@6B@			; Ogre::VertexBuffer::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVVertexBuffer@Ogre@@@8			; Ogre::VertexBuffer `RTTI Type Descriptor'
PUBLIC	??_R3VertexBuffer@Ogre@@8			; Ogre::VertexBuffer::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2VertexBuffer@Ogre@@8			; Ogre::VertexBuffer::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@VertexBuffer@Ogre@@8		; Ogre::VertexBuffer::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_EVertexBuffer@Ogre@@UAEPAXI@Z		; Ogre::VertexBuffer::`vector deleting destructor'
EXTRN	__purecall:PROC
;	COMDAT ??_R1A@?0A@EA@VertexBuffer@Ogre@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@VertexBuffer@Ogre@@8 DD FLAT:??_R0?AVVertexBuffer@Ogre@@@8 ; Ogre::VertexBuffer::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3VertexBuffer@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R2VertexBuffer@Ogre@@8
rdata$r	SEGMENT
??_R2VertexBuffer@Ogre@@8 DD FLAT:??_R1A@?0A@EA@VertexBuffer@Ogre@@8 ; Ogre::VertexBuffer::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@Resource@Ogre@@8
	DD	FLAT:??_R1A@?0A@EA@BaseObject@Ogre@@8
	DD	FLAT:??_R13?0A@EA@MemoryDelegation@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R3VertexBuffer@Ogre@@8
rdata$r	SEGMENT
??_R3VertexBuffer@Ogre@@8 DD 00H			; Ogre::VertexBuffer::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	04H
	DD	FLAT:??_R2VertexBuffer@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVVertexBuffer@Ogre@@@8
_DATA	SEGMENT
??_R0?AVVertexBuffer@Ogre@@@8 DD FLAT:??_7type_info@@6B@ ; Ogre::VertexBuffer `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVVertexBuffer@Ogre@@', 00H
_DATA	ENDS
;	COMDAT ??_R4VertexBuffer@Ogre@@6B@
rdata$r	SEGMENT
??_R4VertexBuffer@Ogre@@6B@ DD 00H			; Ogre::VertexBuffer::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVVertexBuffer@Ogre@@@8
	DD	FLAT:??_R3VertexBuffer@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_7VertexBuffer@Ogre@@6B@
CONST	SEGMENT
??_7VertexBuffer@Ogre@@6B@ DD FLAT:??_R4VertexBuffer@Ogre@@6B@ ; Ogre::VertexBuffer::`vftable'
	DD	FLAT:?getRTTI@VertexBuffer@Ogre@@UBEPBVRuntimeClass@2@XZ
	DD	FLAT:?release@Resource@Ogre@@UAEXXZ
	DD	FLAT:?addRef@Resource@Ogre@@UAEXXZ
	DD	FLAT:?getRefCount@Resource@Ogre@@UAEHXZ
	DD	FLAT:?_serialize@BaseObject@Ogre@@UAEXAAVArchive@2@H@Z
	DD	FLAT:??_EVertexBuffer@Ogre@@UAEPAXI@Z
	DD	FLAT:?deleteThis@BaseObject@Ogre@@MAEXXZ
	DD	FLAT:__purecall
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0VertexBuffer@Ogre@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0VertexBuffer@Ogre@@QAE@XZ$0
__ehfuncinfo$??0VertexBuffer@Ogre@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0VertexBuffer@Ogre@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0VertexBuffer@Ogre@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0VertexBuffer@Ogre@@QAE@XZ PROC			; Ogre::VertexBuffer::VertexBuffer, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0VertexBuffer@Ogre@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0Resource@Ogre@@IAE@XZ		; Ogre::Resource::Resource
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7VertexBuffer@Ogre@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0VertexBuffer@Ogre@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1Resource@Ogre@@MAE@XZ		; Ogre::Resource::~Resource
__ehhandler$??0VertexBuffer@Ogre@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0VertexBuffer@Ogre@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0VertexBuffer@Ogre@@QAE@XZ ENDP			; Ogre::VertexBuffer::VertexBuffer
PUBLIC	??1VertexBuffer@Ogre@@UAE@XZ			; Ogre::VertexBuffer::~VertexBuffer
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1VertexBuffer@Ogre@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1VertexBuffer@Ogre@@UAE@XZ$0
__ehfuncinfo$??1VertexBuffer@Ogre@@UAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1VertexBuffer@Ogre@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1VertexBuffer@Ogre@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1VertexBuffer@Ogre@@UAE@XZ PROC			; Ogre::VertexBuffer::~VertexBuffer, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1VertexBuffer@Ogre@@UAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1Resource@Ogre@@MAE@XZ		; Ogre::Resource::~Resource
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1VertexBuffer@Ogre@@UAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1Resource@Ogre@@MAE@XZ		; Ogre::Resource::~Resource
__ehhandler$??1VertexBuffer@Ogre@@UAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1VertexBuffer@Ogre@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1VertexBuffer@Ogre@@UAE@XZ ENDP			; Ogre::VertexBuffer::~VertexBuffer
PUBLIC	??0VertexBuffer@Ogre@@QAE@ABV01@@Z		; Ogre::VertexBuffer::VertexBuffer
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0VertexBuffer@Ogre@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0VertexBuffer@Ogre@@QAE@ABV01@@Z$0
__ehfuncinfo$??0VertexBuffer@Ogre@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0VertexBuffer@Ogre@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0VertexBuffer@Ogre@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0VertexBuffer@Ogre@@QAE@ABV01@@Z PROC			; Ogre::VertexBuffer::VertexBuffer, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0VertexBuffer@Ogre@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0Resource@Ogre@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7VertexBuffer@Ogre@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0VertexBuffer@Ogre@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1Resource@Ogre@@MAE@XZ		; Ogre::Resource::~Resource
__ehhandler$??0VertexBuffer@Ogre@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0VertexBuffer@Ogre@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0VertexBuffer@Ogre@@QAE@ABV01@@Z ENDP			; Ogre::VertexBuffer::VertexBuffer
PUBLIC	??4VertexBuffer@Ogre@@QAEAAV01@ABV01@@Z		; Ogre::VertexBuffer::operator=
; Function compile flags: /Odtp
;	COMDAT ??4VertexBuffer@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4VertexBuffer@Ogre@@QAEAAV01@ABV01@@Z PROC		; Ogre::VertexBuffer::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4Resource@Ogre@@QAEAAV01@ABV01@@Z
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4VertexBuffer@Ogre@@QAEAAV01@ABV01@@Z ENDP		; Ogre::VertexBuffer::operator=
_TEXT	ENDS
PUBLIC	??_GVertexBuffer@Ogre@@UAEPAXI@Z		; Ogre::VertexBuffer::`scalar deleting destructor'
; Function compile flags: /Odtp
;	COMDAT ??_GVertexBuffer@Ogre@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GVertexBuffer@Ogre@@UAEPAXI@Z PROC			; Ogre::VertexBuffer::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1VertexBuffer@Ogre@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@3
	push	16					; 00000010H
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3MemoryDelegation@Ogre@@SAXPAXI@Z	; Ogre::MemoryDelegation::operator delete
	add	esp, 8
$LN1@scalar@3:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GVertexBuffer@Ogre@@UAEPAXI@Z ENDP			; Ogre::VertexBuffer::`scalar deleting destructor'
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_EVertexBuffer@Ogre@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_EVertexBuffer@Ogre@@UAEPAXI@Z PROC			; Ogre::VertexBuffer::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 2
	je	SHORT $LN3@vector@3
	push	OFFSET ??1VertexBuffer@Ogre@@UAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx-4]
	push	edx
	push	16					; 00000010H
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??_M@YGXPAXIHP6EX0@Z@Z
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN2@vector@3
	push	16					; 00000010H
	mov	edx, DWORD PTR _this$[ebp]
	sub	edx, 4
	push	edx
	call	??_VMemoryDelegation@Ogre@@SAXPAXI@Z	; Ogre::MemoryDelegation::operator delete[]
	add	esp, 8
$LN2@vector@3:
	mov	eax, DWORD PTR _this$[ebp]
	sub	eax, 4
	jmp	SHORT $LN4@vector@3
$LN3@vector@3:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1VertexBuffer@Ogre@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@vector@3
	push	16					; 00000010H
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3MemoryDelegation@Ogre@@SAXPAXI@Z	; Ogre::MemoryDelegation::operator delete
	add	esp, 8
$LN1@vector@3:
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector@3:
	mov	esp, ebp
	pop	ebp
	ret	4
??_EVertexBuffer@Ogre@@UAEPAXI@Z ENDP			; Ogre::VertexBuffer::`vector deleting destructor'
_TEXT	ENDS
PUBLIC	?getRTTI@IndexBuffer@Ogre@@UBEPBVRuntimeClass@2@XZ ; Ogre::IndexBuffer::getRTTI
EXTRN	?m_RTTI@IndexBuffer@Ogre@@2VRuntimeClass@2@B:BYTE ; Ogre::IndexBuffer::m_RTTI
; Function compile flags: /Odtp
;	COMDAT ?getRTTI@IndexBuffer@Ogre@@UBEPBVRuntimeClass@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getRTTI@IndexBuffer@Ogre@@UBEPBVRuntimeClass@2@XZ PROC	; Ogre::IndexBuffer::getRTTI, COMDAT
; _this$ = ecx

; 230  : 		DECLARE_RTTI_VIRTUAL(IndexBuffer)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, OFFSET ?m_RTTI@IndexBuffer@Ogre@@2VRuntimeClass@2@B ; Ogre::IndexBuffer::m_RTTI
	mov	esp, ebp
	pop	ebp
	ret	0
?getRTTI@IndexBuffer@Ogre@@UBEPBVRuntimeClass@2@XZ ENDP	; Ogre::IndexBuffer::getRTTI
_TEXT	ENDS
PUBLIC	?setVertexRange@IndexBuffer@Ogre@@QAEXII@Z	; Ogre::IndexBuffer::setVertexRange
; Function compile flags: /Odtp
;	COMDAT ?setVertexRange@IndexBuffer@Ogre@@QAEXII@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_start$ = 8						; size = 4
_num$ = 12						; size = 4
?setVertexRange@IndexBuffer@Ogre@@QAEXII@Z PROC		; Ogre::IndexBuffer::setVertexRange, COMDAT
; _this$ = ecx

; 235  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 236  : 			m_RefVertStart = start;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _start$[ebp]
	mov	DWORD PTR [eax+16], ecx

; 237  : 			m_RefVertNum = num;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _num$[ebp]
	mov	DWORD PTR [edx+20], eax

; 238  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?setVertexRange@IndexBuffer@Ogre@@QAEXII@Z ENDP		; Ogre::IndexBuffer::setVertexRange
_TEXT	ENDS
PUBLIC	??_7IndexBuffer@Ogre@@6B@			; Ogre::IndexBuffer::`vftable'
PUBLIC	??0IndexBuffer@Ogre@@QAE@XZ			; Ogre::IndexBuffer::IndexBuffer
PUBLIC	??_R4IndexBuffer@Ogre@@6B@			; Ogre::IndexBuffer::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVIndexBuffer@Ogre@@@8			; Ogre::IndexBuffer `RTTI Type Descriptor'
PUBLIC	??_R3IndexBuffer@Ogre@@8			; Ogre::IndexBuffer::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2IndexBuffer@Ogre@@8			; Ogre::IndexBuffer::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@IndexBuffer@Ogre@@8		; Ogre::IndexBuffer::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_EIndexBuffer@Ogre@@UAEPAXI@Z			; Ogre::IndexBuffer::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@IndexBuffer@Ogre@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@IndexBuffer@Ogre@@8 DD FLAT:??_R0?AVIndexBuffer@Ogre@@@8 ; Ogre::IndexBuffer::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3IndexBuffer@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R2IndexBuffer@Ogre@@8
rdata$r	SEGMENT
??_R2IndexBuffer@Ogre@@8 DD FLAT:??_R1A@?0A@EA@IndexBuffer@Ogre@@8 ; Ogre::IndexBuffer::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@Resource@Ogre@@8
	DD	FLAT:??_R1A@?0A@EA@BaseObject@Ogre@@8
	DD	FLAT:??_R13?0A@EA@MemoryDelegation@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R3IndexBuffer@Ogre@@8
rdata$r	SEGMENT
??_R3IndexBuffer@Ogre@@8 DD 00H				; Ogre::IndexBuffer::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	04H
	DD	FLAT:??_R2IndexBuffer@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVIndexBuffer@Ogre@@@8
_DATA	SEGMENT
??_R0?AVIndexBuffer@Ogre@@@8 DD FLAT:??_7type_info@@6B@	; Ogre::IndexBuffer `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVIndexBuffer@Ogre@@', 00H
_DATA	ENDS
;	COMDAT ??_R4IndexBuffer@Ogre@@6B@
rdata$r	SEGMENT
??_R4IndexBuffer@Ogre@@6B@ DD 00H			; Ogre::IndexBuffer::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVIndexBuffer@Ogre@@@8
	DD	FLAT:??_R3IndexBuffer@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_7IndexBuffer@Ogre@@6B@
CONST	SEGMENT
??_7IndexBuffer@Ogre@@6B@ DD FLAT:??_R4IndexBuffer@Ogre@@6B@ ; Ogre::IndexBuffer::`vftable'
	DD	FLAT:?getRTTI@IndexBuffer@Ogre@@UBEPBVRuntimeClass@2@XZ
	DD	FLAT:?release@Resource@Ogre@@UAEXXZ
	DD	FLAT:?addRef@Resource@Ogre@@UAEXXZ
	DD	FLAT:?getRefCount@Resource@Ogre@@UAEHXZ
	DD	FLAT:?_serialize@BaseObject@Ogre@@UAEXAAVArchive@2@H@Z
	DD	FLAT:??_EIndexBuffer@Ogre@@UAEPAXI@Z
	DD	FLAT:?deleteThis@BaseObject@Ogre@@MAEXXZ
	DD	FLAT:__purecall
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0IndexBuffer@Ogre@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0IndexBuffer@Ogre@@QAE@XZ$0
__ehfuncinfo$??0IndexBuffer@Ogre@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0IndexBuffer@Ogre@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0IndexBuffer@Ogre@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0IndexBuffer@Ogre@@QAE@XZ PROC			; Ogre::IndexBuffer::IndexBuffer, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0IndexBuffer@Ogre@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0Resource@Ogre@@IAE@XZ		; Ogre::Resource::Resource
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7IndexBuffer@Ogre@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0IndexBuffer@Ogre@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1Resource@Ogre@@MAE@XZ		; Ogre::Resource::~Resource
__ehhandler$??0IndexBuffer@Ogre@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0IndexBuffer@Ogre@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0IndexBuffer@Ogre@@QAE@XZ ENDP			; Ogre::IndexBuffer::IndexBuffer
PUBLIC	??1IndexBuffer@Ogre@@UAE@XZ			; Ogre::IndexBuffer::~IndexBuffer
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1IndexBuffer@Ogre@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1IndexBuffer@Ogre@@UAE@XZ$0
__ehfuncinfo$??1IndexBuffer@Ogre@@UAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1IndexBuffer@Ogre@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1IndexBuffer@Ogre@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1IndexBuffer@Ogre@@UAE@XZ PROC			; Ogre::IndexBuffer::~IndexBuffer, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1IndexBuffer@Ogre@@UAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1Resource@Ogre@@MAE@XZ		; Ogre::Resource::~Resource
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1IndexBuffer@Ogre@@UAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1Resource@Ogre@@MAE@XZ		; Ogre::Resource::~Resource
__ehhandler$??1IndexBuffer@Ogre@@UAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1IndexBuffer@Ogre@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1IndexBuffer@Ogre@@UAE@XZ ENDP			; Ogre::IndexBuffer::~IndexBuffer
PUBLIC	??0IndexBuffer@Ogre@@QAE@ABV01@@Z		; Ogre::IndexBuffer::IndexBuffer
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0IndexBuffer@Ogre@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0IndexBuffer@Ogre@@QAE@ABV01@@Z$0
__ehfuncinfo$??0IndexBuffer@Ogre@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0IndexBuffer@Ogre@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0IndexBuffer@Ogre@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0IndexBuffer@Ogre@@QAE@ABV01@@Z PROC			; Ogre::IndexBuffer::IndexBuffer, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0IndexBuffer@Ogre@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0Resource@Ogre@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7IndexBuffer@Ogre@@6B@
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR [edx+16], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR [edx+20], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0IndexBuffer@Ogre@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1Resource@Ogre@@MAE@XZ		; Ogre::Resource::~Resource
__ehhandler$??0IndexBuffer@Ogre@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0IndexBuffer@Ogre@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0IndexBuffer@Ogre@@QAE@ABV01@@Z ENDP			; Ogre::IndexBuffer::IndexBuffer
PUBLIC	??4IndexBuffer@Ogre@@QAEAAV01@ABV01@@Z		; Ogre::IndexBuffer::operator=
; Function compile flags: /Odtp
;	COMDAT ??4IndexBuffer@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4IndexBuffer@Ogre@@QAEAAV01@ABV01@@Z PROC		; Ogre::IndexBuffer::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4Resource@Ogre@@QAEAAV01@ABV01@@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR [ecx+16], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	DWORD PTR [ecx+20], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4IndexBuffer@Ogre@@QAEAAV01@ABV01@@Z ENDP		; Ogre::IndexBuffer::operator=
_TEXT	ENDS
PUBLIC	??_GIndexBuffer@Ogre@@UAEPAXI@Z			; Ogre::IndexBuffer::`scalar deleting destructor'
; Function compile flags: /Odtp
;	COMDAT ??_GIndexBuffer@Ogre@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GIndexBuffer@Ogre@@UAEPAXI@Z PROC			; Ogre::IndexBuffer::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1IndexBuffer@Ogre@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@4
	push	24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3MemoryDelegation@Ogre@@SAXPAXI@Z	; Ogre::MemoryDelegation::operator delete
	add	esp, 8
$LN1@scalar@4:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GIndexBuffer@Ogre@@UAEPAXI@Z ENDP			; Ogre::IndexBuffer::`scalar deleting destructor'
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_EIndexBuffer@Ogre@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_EIndexBuffer@Ogre@@UAEPAXI@Z PROC			; Ogre::IndexBuffer::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 2
	je	SHORT $LN3@vector@4
	push	OFFSET ??1IndexBuffer@Ogre@@UAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx-4]
	push	edx
	push	24					; 00000018H
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??_M@YGXPAXIHP6EX0@Z@Z
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN2@vector@4
	push	24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	sub	edx, 4
	push	edx
	call	??_VMemoryDelegation@Ogre@@SAXPAXI@Z	; Ogre::MemoryDelegation::operator delete[]
	add	esp, 8
$LN2@vector@4:
	mov	eax, DWORD PTR _this$[ebp]
	sub	eax, 4
	jmp	SHORT $LN4@vector@4
$LN3@vector@4:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1IndexBuffer@Ogre@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@vector@4
	push	24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3MemoryDelegation@Ogre@@SAXPAXI@Z	; Ogre::MemoryDelegation::operator delete
	add	esp, 8
$LN1@vector@4:
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector@4:
	mov	esp, ebp
	pop	ebp
	ret	4
??_EIndexBuffer@Ogre@@UAEPAXI@Z ENDP			; Ogre::IndexBuffer::`vector deleting destructor'
_TEXT	ENDS
PUBLIC	?getRTTI@Texture@Ogre@@UBEPBVRuntimeClass@2@XZ	; Ogre::Texture::getRTTI
EXTRN	?m_RTTI@Texture@Ogre@@2VRuntimeClass@2@B:BYTE	; Ogre::Texture::m_RTTI
; Function compile flags: /Odtp
;	COMDAT ?getRTTI@Texture@Ogre@@UBEPBVRuntimeClass@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getRTTI@Texture@Ogre@@UBEPBVRuntimeClass@2@XZ PROC	; Ogre::Texture::getRTTI, COMDAT
; _this$ = ecx

; 248  : 		DECLARE_RTTI_VIRTUAL(Texture)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, OFFSET ?m_RTTI@Texture@Ogre@@2VRuntimeClass@2@B ; Ogre::Texture::m_RTTI
	mov	esp, ebp
	pop	ebp
	ret	0
?getRTTI@Texture@Ogre@@UBEPBVRuntimeClass@2@XZ ENDP	; Ogre::Texture::getRTTI
_TEXT	ENDS
PUBLIC	??_7Texture@Ogre@@6B@				; Ogre::Texture::`vftable'
PUBLIC	??1Texture@Ogre@@MAE@XZ				; Ogre::Texture::~Texture
PUBLIC	??_R4Texture@Ogre@@6B@				; Ogre::Texture::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVTexture@Ogre@@@8			; Ogre::Texture `RTTI Type Descriptor'
PUBLIC	??_R3Texture@Ogre@@8				; Ogre::Texture::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2Texture@Ogre@@8				; Ogre::Texture::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@Texture@Ogre@@8			; Ogre::Texture::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_ETexture@Ogre@@MAEPAXI@Z			; Ogre::Texture::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@Texture@Ogre@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@Texture@Ogre@@8 DD FLAT:??_R0?AVTexture@Ogre@@@8 ; Ogre::Texture::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3Texture@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R2Texture@Ogre@@8
rdata$r	SEGMENT
??_R2Texture@Ogre@@8 DD FLAT:??_R1A@?0A@EA@Texture@Ogre@@8 ; Ogre::Texture::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@Resource@Ogre@@8
	DD	FLAT:??_R1A@?0A@EA@BaseObject@Ogre@@8
	DD	FLAT:??_R13?0A@EA@MemoryDelegation@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R3Texture@Ogre@@8
rdata$r	SEGMENT
??_R3Texture@Ogre@@8 DD 00H				; Ogre::Texture::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	04H
	DD	FLAT:??_R2Texture@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVTexture@Ogre@@@8
_DATA	SEGMENT
??_R0?AVTexture@Ogre@@@8 DD FLAT:??_7type_info@@6B@	; Ogre::Texture `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVTexture@Ogre@@', 00H
_DATA	ENDS
;	COMDAT ??_R4Texture@Ogre@@6B@
rdata$r	SEGMENT
??_R4Texture@Ogre@@6B@ DD 00H				; Ogre::Texture::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVTexture@Ogre@@@8
	DD	FLAT:??_R3Texture@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_7Texture@Ogre@@6B@
CONST	SEGMENT
??_7Texture@Ogre@@6B@ DD FLAT:??_R4Texture@Ogre@@6B@	; Ogre::Texture::`vftable'
	DD	FLAT:?getRTTI@Texture@Ogre@@UBEPBVRuntimeClass@2@XZ
	DD	FLAT:?release@Resource@Ogre@@UAEXXZ
	DD	FLAT:?addRef@Resource@Ogre@@UAEXXZ
	DD	FLAT:?getRefCount@Resource@Ogre@@UAEHXZ
	DD	FLAT:?_serialize@BaseObject@Ogre@@UAEXAAVArchive@2@H@Z
	DD	FLAT:??_ETexture@Ogre@@MAEPAXI@Z
	DD	FLAT:?deleteThis@BaseObject@Ogre@@MAEXXZ
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1Texture@Ogre@@MAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1Texture@Ogre@@MAE@XZ$0
__ehfuncinfo$??1Texture@Ogre@@MAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1Texture@Ogre@@MAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1Texture@Ogre@@MAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1Texture@Ogre@@MAE@XZ PROC				; Ogre::Texture::~Texture, COMDAT
; _this$ = ecx

; 257  : 		{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1Texture@Ogre@@MAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7Texture@Ogre@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 258  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1Resource@Ogre@@MAE@XZ		; Ogre::Resource::~Resource
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1Texture@Ogre@@MAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1Resource@Ogre@@MAE@XZ		; Ogre::Resource::~Resource
__ehhandler$??1Texture@Ogre@@MAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1Texture@Ogre@@MAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1Texture@Ogre@@MAE@XZ ENDP				; Ogre::Texture::~Texture
PUBLIC	??0Texture@Ogre@@QAE@XZ				; Ogre::Texture::Texture
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0Texture@Ogre@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0Texture@Ogre@@QAE@XZ$0
__ehfuncinfo$??0Texture@Ogre@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0Texture@Ogre@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0Texture@Ogre@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0Texture@Ogre@@QAE@XZ PROC				; Ogre::Texture::Texture, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0Texture@Ogre@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0Resource@Ogre@@IAE@XZ		; Ogre::Resource::Resource
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7Texture@Ogre@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0Texture@Ogre@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1Resource@Ogre@@MAE@XZ		; Ogre::Resource::~Resource
__ehhandler$??0Texture@Ogre@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0Texture@Ogre@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0Texture@Ogre@@QAE@XZ ENDP				; Ogre::Texture::Texture
PUBLIC	??0Texture@Ogre@@QAE@ABV01@@Z			; Ogre::Texture::Texture
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0Texture@Ogre@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0Texture@Ogre@@QAE@ABV01@@Z$0
__ehfuncinfo$??0Texture@Ogre@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0Texture@Ogre@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0Texture@Ogre@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0Texture@Ogre@@QAE@ABV01@@Z PROC			; Ogre::Texture::Texture, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0Texture@Ogre@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0Resource@Ogre@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7Texture@Ogre@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0Texture@Ogre@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1Resource@Ogre@@MAE@XZ		; Ogre::Resource::~Resource
__ehhandler$??0Texture@Ogre@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0Texture@Ogre@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0Texture@Ogre@@QAE@ABV01@@Z ENDP			; Ogre::Texture::Texture
PUBLIC	??4Texture@Ogre@@QAEAAV01@ABV01@@Z		; Ogre::Texture::operator=
; Function compile flags: /Odtp
;	COMDAT ??4Texture@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4Texture@Ogre@@QAEAAV01@ABV01@@Z PROC			; Ogre::Texture::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4Resource@Ogre@@QAEAAV01@ABV01@@Z
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4Texture@Ogre@@QAEAAV01@ABV01@@Z ENDP			; Ogre::Texture::operator=
_TEXT	ENDS
PUBLIC	??_GTexture@Ogre@@MAEPAXI@Z			; Ogre::Texture::`scalar deleting destructor'
; Function compile flags: /Odtp
;	COMDAT ??_GTexture@Ogre@@MAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GTexture@Ogre@@MAEPAXI@Z PROC			; Ogre::Texture::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1Texture@Ogre@@MAE@XZ			; Ogre::Texture::~Texture
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@5
	push	16					; 00000010H
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3MemoryDelegation@Ogre@@SAXPAXI@Z	; Ogre::MemoryDelegation::operator delete
	add	esp, 8
$LN1@scalar@5:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GTexture@Ogre@@MAEPAXI@Z ENDP			; Ogre::Texture::`scalar deleting destructor'
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_ETexture@Ogre@@MAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_ETexture@Ogre@@MAEPAXI@Z PROC			; Ogre::Texture::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 2
	je	SHORT $LN3@vector@5
	push	OFFSET ??1Texture@Ogre@@MAE@XZ		; Ogre::Texture::~Texture
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx-4]
	push	edx
	push	16					; 00000010H
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??_M@YGXPAXIHP6EX0@Z@Z
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN2@vector@5
	push	16					; 00000010H
	mov	edx, DWORD PTR _this$[ebp]
	sub	edx, 4
	push	edx
	call	??_VMemoryDelegation@Ogre@@SAXPAXI@Z	; Ogre::MemoryDelegation::operator delete[]
	add	esp, 8
$LN2@vector@5:
	mov	eax, DWORD PTR _this$[ebp]
	sub	eax, 4
	jmp	SHORT $LN4@vector@5
$LN3@vector@5:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1Texture@Ogre@@MAE@XZ			; Ogre::Texture::~Texture
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@vector@5
	push	16					; 00000010H
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3MemoryDelegation@Ogre@@SAXPAXI@Z	; Ogre::MemoryDelegation::operator delete
	add	esp, 8
$LN1@vector@5:
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector@5:
	mov	esp, ebp
	pop	ebp
	ret	4
??_ETexture@Ogre@@MAEPAXI@Z ENDP			; Ogre::Texture::`vector deleting destructor'
_TEXT	ENDS
PUBLIC	??4LockSection@Ogre@@QAEAAV01@ABV01@@Z		; Ogre::LockSection::operator=
; Function compile flags: /Odtp
;	COMDAT ??4LockSection@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4LockSection@Ogre@@QAEAAV01@ABV01@@Z PROC		; Ogre::LockSection::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4LockSection@Ogre@@QAEAAV01@ABV01@@Z ENDP		; Ogre::LockSection::operator=
_TEXT	ENDS
PUBLIC	??0LockFunctor@Ogre@@QAE@PAVLockSection@1@@Z	; Ogre::LockFunctor::LockFunctor
EXTRN	?Lock@LockSection@Ogre@@QAEXXZ:PROC		; Ogre::LockSection::Lock
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogrelocker.h
;	COMDAT ??0LockFunctor@Ogre@@QAE@PAVLockSection@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pSection$ = 8						; size = 4
??0LockFunctor@Ogre@@QAE@PAVLockSection@1@@Z PROC	; Ogre::LockFunctor::LockFunctor, COMDAT
; _this$ = ecx

; 26   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pSection$[ebp]
	mov	DWORD PTR [eax], ecx

; 27   : 			if(m_pSection == NULL) return;

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx], 0
	jne	SHORT $LN1@LockFuncto
	jmp	SHORT $LN2@LockFuncto
$LN1@LockFuncto:

; 28   : 			assert( m_pSection );
; 29   : 			m_pSection->Lock();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?Lock@LockSection@Ogre@@QAEXXZ		; Ogre::LockSection::Lock
$LN2@LockFuncto:

; 30   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0LockFunctor@Ogre@@QAE@PAVLockSection@1@@Z ENDP	; Ogre::LockFunctor::LockFunctor
_TEXT	ENDS
PUBLIC	??1LockFunctor@Ogre@@QAE@XZ			; Ogre::LockFunctor::~LockFunctor
EXTRN	?Unlock@LockSection@Ogre@@QAEXXZ:PROC		; Ogre::LockSection::Unlock
; Function compile flags: /Odtp
;	COMDAT ??1LockFunctor@Ogre@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1LockFunctor@Ogre@@QAE@XZ PROC			; Ogre::LockFunctor::~LockFunctor, COMDAT
; _this$ = ecx

; 33   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 34   : 			if( m_pSection )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN2@LockFuncto@2

; 35   : 			{
; 36   : 				m_pSection->Unlock();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?Unlock@LockSection@Ogre@@QAEXXZ	; Ogre::LockSection::Unlock
$LN2@LockFuncto@2:

; 37   : 			}			
; 38   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??1LockFunctor@Ogre@@QAE@XZ ENDP			; Ogre::LockFunctor::~LockFunctor
_TEXT	ENDS
PUBLIC	??4LockFunctor@Ogre@@QAEAAV01@ABV01@@Z		; Ogre::LockFunctor::operator=
; Function compile flags: /Odtp
;	COMDAT ??4LockFunctor@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4LockFunctor@Ogre@@QAEAAV01@ABV01@@Z PROC		; Ogre::LockFunctor::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4LockFunctor@Ogre@@QAEAAV01@ABV01@@Z ENDP		; Ogre::LockFunctor::operator=
_TEXT	ENDS
PUBLIC	?getPool@HardwareBuffer@Ogre@@QAEPAVHardwareBufferPool@2@XZ ; Ogre::HardwareBuffer::getPool
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogrehardwarebuffer.h
;	COMDAT ?getPool@HardwareBuffer@Ogre@@QAEPAVHardwareBufferPool@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getPool@HardwareBuffer@Ogre@@QAEPAVHardwareBufferPool@2@XZ PROC ; Ogre::HardwareBuffer::getPool, COMDAT
; _this$ = ecx

; 22   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 23   : 			return m_pPool;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+28]

; 24   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?getPool@HardwareBuffer@Ogre@@QAEPAVHardwareBufferPool@2@XZ ENDP ; Ogre::HardwareBuffer::getPool
_TEXT	ENDS
PUBLIC	?getStart@HardwareBuffer@Ogre@@QAEIXZ		; Ogre::HardwareBuffer::getStart
; Function compile flags: /Odtp
;	COMDAT ?getStart@HardwareBuffer@Ogre@@QAEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getStart@HardwareBuffer@Ogre@@QAEIXZ PROC		; Ogre::HardwareBuffer::getStart, COMDAT
; _this$ = ecx

; 26   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 27   : 			return m_Start;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+16]

; 28   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?getStart@HardwareBuffer@Ogre@@QAEIXZ ENDP		; Ogre::HardwareBuffer::getStart
_TEXT	ENDS
PUBLIC	?getNum@HardwareBuffer@Ogre@@QAEIXZ		; Ogre::HardwareBuffer::getNum
; Function compile flags: /Odtp
;	COMDAT ?getNum@HardwareBuffer@Ogre@@QAEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getNum@HardwareBuffer@Ogre@@QAEIXZ PROC		; Ogre::HardwareBuffer::getNum, COMDAT
; _this$ = ecx

; 30   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 31   : 			return m_Num;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+20]

; 32   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?getNum@HardwareBuffer@Ogre@@QAEIXZ ENDP		; Ogre::HardwareBuffer::getNum
_TEXT	ENDS
PUBLIC	?getBubSize@HardwareBuffer@Ogre@@QAEIXZ		; Ogre::HardwareBuffer::getBubSize
; Function compile flags: /Odtp
;	COMDAT ?getBubSize@HardwareBuffer@Ogre@@QAEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getBubSize@HardwareBuffer@Ogre@@QAEIXZ PROC		; Ogre::HardwareBuffer::getBubSize, COMDAT
; _this$ = ecx

; 34   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 35   : 			return m_BubSize;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+24]

; 36   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?getBubSize@HardwareBuffer@Ogre@@QAEIXZ ENDP		; Ogre::HardwareBuffer::getBubSize
_TEXT	ENDS
PUBLIC	??_7HardwareBuffer@Ogre@@6B@			; Ogre::HardwareBuffer::`vftable'
PUBLIC	??0HardwareBuffer@Ogre@@IAE@PAVHardwareBufferPool@1@@Z ; Ogre::HardwareBuffer::HardwareBuffer
PUBLIC	??_R4HardwareBuffer@Ogre@@6B@			; Ogre::HardwareBuffer::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVHardwareBuffer@Ogre@@@8			; Ogre::HardwareBuffer `RTTI Type Descriptor'
PUBLIC	??_R3HardwareBuffer@Ogre@@8			; Ogre::HardwareBuffer::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2HardwareBuffer@Ogre@@8			; Ogre::HardwareBuffer::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@HardwareBuffer@Ogre@@8		; Ogre::HardwareBuffer::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R13?0A@EN@ChainListNode@Ogre@@8		; Ogre::ChainListNode::`RTTI Base Class Descriptor at (4,-1,0,77)'
PUBLIC	??_R0?AVChainListNode@Ogre@@@8			; Ogre::ChainListNode `RTTI Type Descriptor'
PUBLIC	??_R3ChainListNode@Ogre@@8			; Ogre::ChainListNode::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2ChainListNode@Ogre@@8			; Ogre::ChainListNode::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@ChainListNode@Ogre@@8		; Ogre::ChainListNode::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_EHardwareBuffer@Ogre@@MAEPAXI@Z		; Ogre::HardwareBuffer::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@ChainListNode@Ogre@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@ChainListNode@Ogre@@8 DD FLAT:??_R0?AVChainListNode@Ogre@@@8 ; Ogre::ChainListNode::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3ChainListNode@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R2ChainListNode@Ogre@@8
rdata$r	SEGMENT
??_R2ChainListNode@Ogre@@8 DD FLAT:??_R1A@?0A@EA@ChainListNode@Ogre@@8 ; Ogre::ChainListNode::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3ChainListNode@Ogre@@8
rdata$r	SEGMENT
??_R3ChainListNode@Ogre@@8 DD 00H			; Ogre::ChainListNode::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2ChainListNode@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVChainListNode@Ogre@@@8
_DATA	SEGMENT
??_R0?AVChainListNode@Ogre@@@8 DD FLAT:??_7type_info@@6B@ ; Ogre::ChainListNode `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVChainListNode@Ogre@@', 00H
_DATA	ENDS
;	COMDAT ??_R13?0A@EN@ChainListNode@Ogre@@8
rdata$r	SEGMENT
??_R13?0A@EN@ChainListNode@Ogre@@8 DD FLAT:??_R0?AVChainListNode@Ogre@@@8 ; Ogre::ChainListNode::`RTTI Base Class Descriptor at (4,-1,0,77)'
	DD	00H
	DD	04H
	DD	0ffffffffH
	DD	00H
	DD	04dH
	DD	FLAT:??_R3ChainListNode@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@HardwareBuffer@Ogre@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@HardwareBuffer@Ogre@@8 DD FLAT:??_R0?AVHardwareBuffer@Ogre@@@8 ; Ogre::HardwareBuffer::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3HardwareBuffer@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R2HardwareBuffer@Ogre@@8
rdata$r	SEGMENT
??_R2HardwareBuffer@Ogre@@8 DD FLAT:??_R1A@?0A@EA@HardwareBuffer@Ogre@@8 ; Ogre::HardwareBuffer::`RTTI Base Class Array'
	DD	FLAT:??_R13?0A@EN@ChainListNode@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R3HardwareBuffer@Ogre@@8
rdata$r	SEGMENT
??_R3HardwareBuffer@Ogre@@8 DD 00H			; Ogre::HardwareBuffer::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2HardwareBuffer@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVHardwareBuffer@Ogre@@@8
_DATA	SEGMENT
??_R0?AVHardwareBuffer@Ogre@@@8 DD FLAT:??_7type_info@@6B@ ; Ogre::HardwareBuffer `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVHardwareBuffer@Ogre@@', 00H
_DATA	ENDS
;	COMDAT ??_R4HardwareBuffer@Ogre@@6B@
rdata$r	SEGMENT
??_R4HardwareBuffer@Ogre@@6B@ DD 00H			; Ogre::HardwareBuffer::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVHardwareBuffer@Ogre@@@8
	DD	FLAT:??_R3HardwareBuffer@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_7HardwareBuffer@Ogre@@6B@
CONST	SEGMENT
??_7HardwareBuffer@Ogre@@6B@ DD FLAT:??_R4HardwareBuffer@Ogre@@6B@ ; Ogre::HardwareBuffer::`vftable'
	DD	FLAT:??_EHardwareBuffer@Ogre@@MAEPAXI@Z
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ??0HardwareBuffer@Ogre@@IAE@PAVHardwareBufferPool@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pool$ = 8						; size = 4
??0HardwareBuffer@Ogre@@IAE@PAVHardwareBufferPool@1@@Z PROC ; Ogre::HardwareBuffer::HardwareBuffer, COMDAT
; _this$ = ecx

; 40   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7HardwareBuffer@Ogre@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+12], 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _pool$[ebp]
	mov	DWORD PTR [edx+28], eax

; 41   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0HardwareBuffer@Ogre@@IAE@PAVHardwareBufferPool@1@@Z ENDP ; Ogre::HardwareBuffer::HardwareBuffer
_TEXT	ENDS
PUBLIC	??1HardwareBuffer@Ogre@@MAE@XZ			; Ogre::HardwareBuffer::~HardwareBuffer
; Function compile flags: /Odtp
;	COMDAT ??1HardwareBuffer@Ogre@@MAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1HardwareBuffer@Ogre@@MAE@XZ PROC			; Ogre::HardwareBuffer::~HardwareBuffer, COMDAT
; _this$ = ecx

; 44   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7HardwareBuffer@Ogre@@6B@

; 45   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??1HardwareBuffer@Ogre@@MAE@XZ ENDP			; Ogre::HardwareBuffer::~HardwareBuffer
_TEXT	ENDS
PUBLIC	?Set@HardwareBuffer@Ogre@@IAEXIII@Z		; Ogre::HardwareBuffer::Set
; Function compile flags: /Odtp
;	COMDAT ?Set@HardwareBuffer@Ogre@@IAEXIII@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_start$ = 8						; size = 4
_nbytes$ = 12						; size = 4
_bubsize$ = 16						; size = 4
?Set@HardwareBuffer@Ogre@@IAEXIII@Z PROC		; Ogre::HardwareBuffer::Set, COMDAT
; _this$ = ecx

; 48   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 49   : 			m_Start = start;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _start$[ebp]
	mov	DWORD PTR [eax+16], ecx

; 50   : 			m_Num = nbytes;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _nbytes$[ebp]
	mov	DWORD PTR [edx+20], eax

; 51   : 			m_BubSize = bubsize;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _bubsize$[ebp]
	mov	DWORD PTR [ecx+24], edx

; 52   : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?Set@HardwareBuffer@Ogre@@IAEXIII@Z ENDP		; Ogre::HardwareBuffer::Set
_TEXT	ENDS
PUBLIC	??0HardwareBuffer@Ogre@@QAE@ABV01@@Z		; Ogre::HardwareBuffer::HardwareBuffer
; Function compile flags: /Odtp
;	COMDAT ??0HardwareBuffer@Ogre@@QAE@ABV01@@Z
_TEXT	SEGMENT
tv72 = -8						; size = 4
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0HardwareBuffer@Ogre@@QAE@ABV01@@Z PROC		; Ogre::HardwareBuffer::HardwareBuffer, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	cmp	DWORD PTR ___that$[ebp], 0
	je	SHORT $LN3@HardwareBu
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 4
	mov	DWORD PTR tv72[ebp], eax
	jmp	SHORT $LN4@HardwareBu
$LN3@HardwareBu:
	mov	DWORD PTR tv72[ebp], 0
$LN4@HardwareBu:
	mov	ecx, DWORD PTR tv72[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], edx
	mov	DWORD PTR [ecx+8], eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], OFFSET ??_7HardwareBuffer@Ogre@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	dl, BYTE PTR [ecx+12]
	mov	BYTE PTR [eax+12], dl
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+16], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR [eax+20], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR [eax+24], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	DWORD PTR [eax+28], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0HardwareBuffer@Ogre@@QAE@ABV01@@Z ENDP		; Ogre::HardwareBuffer::HardwareBuffer
_TEXT	ENDS
PUBLIC	??4HardwareBuffer@Ogre@@QAEAAV01@ABV01@@Z	; Ogre::HardwareBuffer::operator=
; Function compile flags: /Odtp
;	COMDAT ??4HardwareBuffer@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
tv72 = -8						; size = 4
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4HardwareBuffer@Ogre@@QAEAAV01@ABV01@@Z PROC		; Ogre::HardwareBuffer::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	cmp	DWORD PTR ___that$[ebp], 0
	je	SHORT $LN3@operator
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 4
	mov	DWORD PTR tv72[ebp], eax
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv72[ebp], 0
$LN4@operator:
	mov	ecx, DWORD PTR tv72[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], edx
	mov	DWORD PTR [ecx+8], eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	cl, BYTE PTR [eax+12]
	mov	BYTE PTR [edx+12], cl
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR [edx+16], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR [edx+20], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR [edx+24], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	DWORD PTR [edx+28], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4HardwareBuffer@Ogre@@QAEAAV01@ABV01@@Z ENDP		; Ogre::HardwareBuffer::operator=
_TEXT	ENDS
PUBLIC	??_GHardwareBuffer@Ogre@@MAEPAXI@Z		; Ogre::HardwareBuffer::`scalar deleting destructor'
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
; Function compile flags: /Odtp
;	COMDAT ??_GHardwareBuffer@Ogre@@MAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GHardwareBuffer@Ogre@@MAEPAXI@Z PROC			; Ogre::HardwareBuffer::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1HardwareBuffer@Ogre@@MAE@XZ		; Ogre::HardwareBuffer::~HardwareBuffer
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@6
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@6:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GHardwareBuffer@Ogre@@MAEPAXI@Z ENDP			; Ogre::HardwareBuffer::`scalar deleting destructor'
_TEXT	ENDS
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
; Function compile flags: /Odtp
;	COMDAT ??_EHardwareBuffer@Ogre@@MAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_EHardwareBuffer@Ogre@@MAEPAXI@Z PROC			; Ogre::HardwareBuffer::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 2
	je	SHORT $LN3@vector@6
	push	OFFSET ??1HardwareBuffer@Ogre@@MAE@XZ	; Ogre::HardwareBuffer::~HardwareBuffer
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx-4]
	push	edx
	push	32					; 00000020H
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??_M@YGXPAXIHP6EX0@Z@Z
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN2@vector@6
	mov	edx, DWORD PTR _this$[ebp]
	sub	edx, 4
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN2@vector@6:
	mov	eax, DWORD PTR _this$[ebp]
	sub	eax, 4
	jmp	SHORT $LN4@vector@6
$LN3@vector@6:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1HardwareBuffer@Ogre@@MAE@XZ		; Ogre::HardwareBuffer::~HardwareBuffer
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@vector@6
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@vector@6:
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector@6:
	mov	esp, ebp
	pop	ebp
	ret	4
??_EHardwareBuffer@Ogre@@MAEPAXI@Z ENDP			; Ogre::HardwareBuffer::`vector deleting destructor'
_TEXT	ENDS
PUBLIC	??_7HardwareIndexBuffer@Ogre@@6B@		; Ogre::HardwareIndexBuffer::`vftable'
PUBLIC	??0HardwareIndexBuffer@Ogre@@QAE@PAVHardwareBufferPool@1@@Z ; Ogre::HardwareIndexBuffer::HardwareIndexBuffer
PUBLIC	??_R4HardwareIndexBuffer@Ogre@@6B@		; Ogre::HardwareIndexBuffer::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVHardwareIndexBuffer@Ogre@@@8		; Ogre::HardwareIndexBuffer `RTTI Type Descriptor'
PUBLIC	??_R3HardwareIndexBuffer@Ogre@@8		; Ogre::HardwareIndexBuffer::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2HardwareIndexBuffer@Ogre@@8		; Ogre::HardwareIndexBuffer::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@HardwareIndexBuffer@Ogre@@8	; Ogre::HardwareIndexBuffer::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_EHardwareIndexBuffer@Ogre@@UAEPAXI@Z		; Ogre::HardwareIndexBuffer::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@HardwareIndexBuffer@Ogre@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@HardwareIndexBuffer@Ogre@@8 DD FLAT:??_R0?AVHardwareIndexBuffer@Ogre@@@8 ; Ogre::HardwareIndexBuffer::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3HardwareIndexBuffer@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R2HardwareIndexBuffer@Ogre@@8
rdata$r	SEGMENT
??_R2HardwareIndexBuffer@Ogre@@8 DD FLAT:??_R1A@?0A@EA@HardwareIndexBuffer@Ogre@@8 ; Ogre::HardwareIndexBuffer::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@HardwareBuffer@Ogre@@8
	DD	FLAT:??_R13?0A@EN@ChainListNode@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R3HardwareIndexBuffer@Ogre@@8
rdata$r	SEGMENT
??_R3HardwareIndexBuffer@Ogre@@8 DD 00H			; Ogre::HardwareIndexBuffer::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2HardwareIndexBuffer@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVHardwareIndexBuffer@Ogre@@@8
_DATA	SEGMENT
??_R0?AVHardwareIndexBuffer@Ogre@@@8 DD FLAT:??_7type_info@@6B@ ; Ogre::HardwareIndexBuffer `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVHardwareIndexBuffer@Ogre@@', 00H
_DATA	ENDS
;	COMDAT ??_R4HardwareIndexBuffer@Ogre@@6B@
rdata$r	SEGMENT
??_R4HardwareIndexBuffer@Ogre@@6B@ DD 00H		; Ogre::HardwareIndexBuffer::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVHardwareIndexBuffer@Ogre@@@8
	DD	FLAT:??_R3HardwareIndexBuffer@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_7HardwareIndexBuffer@Ogre@@6B@
CONST	SEGMENT
??_7HardwareIndexBuffer@Ogre@@6B@ DD FLAT:??_R4HardwareIndexBuffer@Ogre@@6B@ ; Ogre::HardwareIndexBuffer::`vftable'
	DD	FLAT:??_EHardwareIndexBuffer@Ogre@@UAEPAXI@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0HardwareIndexBuffer@Ogre@@QAE@PAVHardwareBufferPool@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0HardwareIndexBuffer@Ogre@@QAE@PAVHardwareBufferPool@1@@Z$0
__ehfuncinfo$??0HardwareIndexBuffer@Ogre@@QAE@PAVHardwareBufferPool@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0HardwareIndexBuffer@Ogre@@QAE@PAVHardwareBufferPool@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0HardwareIndexBuffer@Ogre@@QAE@PAVHardwareBufferPool@1@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_pool$ = 8						; size = 4
??0HardwareIndexBuffer@Ogre@@QAE@PAVHardwareBufferPool@1@@Z PROC ; Ogre::HardwareIndexBuffer::HardwareIndexBuffer, COMDAT
; _this$ = ecx

; 68   : 		{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0HardwareIndexBuffer@Ogre@@QAE@PAVHardwareBufferPool@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _pool$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0HardwareBuffer@Ogre@@IAE@PAVHardwareBufferPool@1@@Z ; Ogre::HardwareBuffer::HardwareBuffer
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7HardwareIndexBuffer@Ogre@@6B@

; 69   : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0HardwareIndexBuffer@Ogre@@QAE@PAVHardwareBufferPool@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1HardwareBuffer@Ogre@@MAE@XZ		; Ogre::HardwareBuffer::~HardwareBuffer
__ehhandler$??0HardwareIndexBuffer@Ogre@@QAE@PAVHardwareBufferPool@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0HardwareIndexBuffer@Ogre@@QAE@PAVHardwareBufferPool@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0HardwareIndexBuffer@Ogre@@QAE@PAVHardwareBufferPool@1@@Z ENDP ; Ogre::HardwareIndexBuffer::HardwareIndexBuffer
PUBLIC	?getStartIndex@HardwareIndexBuffer@Ogre@@QAEIXZ	; Ogre::HardwareIndexBuffer::getStartIndex
; Function compile flags: /Odtp
;	COMDAT ?getStartIndex@HardwareIndexBuffer@Ogre@@QAEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getStartIndex@HardwareIndexBuffer@Ogre@@QAEIXZ PROC	; Ogre::HardwareIndexBuffer::getStartIndex, COMDAT
; _this$ = ecx

; 72   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 73   : 			return getStart()/2;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?getStart@HardwareBuffer@Ogre@@QAEIXZ	; Ogre::HardwareBuffer::getStart
	shr	eax, 1

; 74   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?getStartIndex@HardwareIndexBuffer@Ogre@@QAEIXZ ENDP	; Ogre::HardwareIndexBuffer::getStartIndex
_TEXT	ENDS
PUBLIC	??1HardwareIndexBuffer@Ogre@@UAE@XZ		; Ogre::HardwareIndexBuffer::~HardwareIndexBuffer
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1HardwareIndexBuffer@Ogre@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1HardwareIndexBuffer@Ogre@@UAE@XZ$0
__ehfuncinfo$??1HardwareIndexBuffer@Ogre@@UAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1HardwareIndexBuffer@Ogre@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1HardwareIndexBuffer@Ogre@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1HardwareIndexBuffer@Ogre@@UAE@XZ PROC		; Ogre::HardwareIndexBuffer::~HardwareIndexBuffer, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1HardwareIndexBuffer@Ogre@@UAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1HardwareBuffer@Ogre@@MAE@XZ		; Ogre::HardwareBuffer::~HardwareBuffer
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1HardwareIndexBuffer@Ogre@@UAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1HardwareBuffer@Ogre@@MAE@XZ		; Ogre::HardwareBuffer::~HardwareBuffer
__ehhandler$??1HardwareIndexBuffer@Ogre@@UAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1HardwareIndexBuffer@Ogre@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1HardwareIndexBuffer@Ogre@@UAE@XZ ENDP		; Ogre::HardwareIndexBuffer::~HardwareIndexBuffer
PUBLIC	??0HardwareIndexBuffer@Ogre@@QAE@ABV01@@Z	; Ogre::HardwareIndexBuffer::HardwareIndexBuffer
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0HardwareIndexBuffer@Ogre@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0HardwareIndexBuffer@Ogre@@QAE@ABV01@@Z$0
__ehfuncinfo$??0HardwareIndexBuffer@Ogre@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0HardwareIndexBuffer@Ogre@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0HardwareIndexBuffer@Ogre@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0HardwareIndexBuffer@Ogre@@QAE@ABV01@@Z PROC		; Ogre::HardwareIndexBuffer::HardwareIndexBuffer, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0HardwareIndexBuffer@Ogre@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0HardwareBuffer@Ogre@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7HardwareIndexBuffer@Ogre@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0HardwareIndexBuffer@Ogre@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1HardwareBuffer@Ogre@@MAE@XZ		; Ogre::HardwareBuffer::~HardwareBuffer
__ehhandler$??0HardwareIndexBuffer@Ogre@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0HardwareIndexBuffer@Ogre@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0HardwareIndexBuffer@Ogre@@QAE@ABV01@@Z ENDP		; Ogre::HardwareIndexBuffer::HardwareIndexBuffer
PUBLIC	??4HardwareIndexBuffer@Ogre@@QAEAAV01@ABV01@@Z	; Ogre::HardwareIndexBuffer::operator=
; Function compile flags: /Odtp
;	COMDAT ??4HardwareIndexBuffer@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4HardwareIndexBuffer@Ogre@@QAEAAV01@ABV01@@Z PROC	; Ogre::HardwareIndexBuffer::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4HardwareBuffer@Ogre@@QAEAAV01@ABV01@@Z
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4HardwareIndexBuffer@Ogre@@QAEAAV01@ABV01@@Z ENDP	; Ogre::HardwareIndexBuffer::operator=
_TEXT	ENDS
PUBLIC	??_GHardwareIndexBuffer@Ogre@@UAEPAXI@Z		; Ogre::HardwareIndexBuffer::`scalar deleting destructor'
; Function compile flags: /Odtp
;	COMDAT ??_GHardwareIndexBuffer@Ogre@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GHardwareIndexBuffer@Ogre@@UAEPAXI@Z PROC		; Ogre::HardwareIndexBuffer::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1HardwareIndexBuffer@Ogre@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@7
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@7:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GHardwareIndexBuffer@Ogre@@UAEPAXI@Z ENDP		; Ogre::HardwareIndexBuffer::`scalar deleting destructor'
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_EHardwareIndexBuffer@Ogre@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_EHardwareIndexBuffer@Ogre@@UAEPAXI@Z PROC		; Ogre::HardwareIndexBuffer::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 2
	je	SHORT $LN3@vector@7
	push	OFFSET ??1HardwareIndexBuffer@Ogre@@UAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx-4]
	push	edx
	push	32					; 00000020H
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??_M@YGXPAXIHP6EX0@Z@Z
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN2@vector@7
	mov	edx, DWORD PTR _this$[ebp]
	sub	edx, 4
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN2@vector@7:
	mov	eax, DWORD PTR _this$[ebp]
	sub	eax, 4
	jmp	SHORT $LN4@vector@7
$LN3@vector@7:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1HardwareIndexBuffer@Ogre@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@vector@7
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@vector@7:
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector@7:
	mov	esp, ebp
	pop	ebp
	ret	4
??_EHardwareIndexBuffer@Ogre@@UAEPAXI@Z ENDP		; Ogre::HardwareIndexBuffer::`vector deleting destructor'
_TEXT	ENDS
PUBLIC	??_7HardwareVertexBuffer@Ogre@@6B@		; Ogre::HardwareVertexBuffer::`vftable'
PUBLIC	??0HardwareVertexBuffer@Ogre@@QAE@PAVHardwareBufferPool@1@@Z ; Ogre::HardwareVertexBuffer::HardwareVertexBuffer
PUBLIC	??_R4HardwareVertexBuffer@Ogre@@6B@		; Ogre::HardwareVertexBuffer::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVHardwareVertexBuffer@Ogre@@@8		; Ogre::HardwareVertexBuffer `RTTI Type Descriptor'
PUBLIC	??_R3HardwareVertexBuffer@Ogre@@8		; Ogre::HardwareVertexBuffer::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2HardwareVertexBuffer@Ogre@@8		; Ogre::HardwareVertexBuffer::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@HardwareVertexBuffer@Ogre@@8	; Ogre::HardwareVertexBuffer::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_EHardwareVertexBuffer@Ogre@@UAEPAXI@Z	; Ogre::HardwareVertexBuffer::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@HardwareVertexBuffer@Ogre@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@HardwareVertexBuffer@Ogre@@8 DD FLAT:??_R0?AVHardwareVertexBuffer@Ogre@@@8 ; Ogre::HardwareVertexBuffer::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3HardwareVertexBuffer@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R2HardwareVertexBuffer@Ogre@@8
rdata$r	SEGMENT
??_R2HardwareVertexBuffer@Ogre@@8 DD FLAT:??_R1A@?0A@EA@HardwareVertexBuffer@Ogre@@8 ; Ogre::HardwareVertexBuffer::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@HardwareBuffer@Ogre@@8
	DD	FLAT:??_R13?0A@EN@ChainListNode@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R3HardwareVertexBuffer@Ogre@@8
rdata$r	SEGMENT
??_R3HardwareVertexBuffer@Ogre@@8 DD 00H		; Ogre::HardwareVertexBuffer::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2HardwareVertexBuffer@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVHardwareVertexBuffer@Ogre@@@8
_DATA	SEGMENT
??_R0?AVHardwareVertexBuffer@Ogre@@@8 DD FLAT:??_7type_info@@6B@ ; Ogre::HardwareVertexBuffer `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVHardwareVertexBuffer@Ogre@@', 00H
_DATA	ENDS
;	COMDAT ??_R4HardwareVertexBuffer@Ogre@@6B@
rdata$r	SEGMENT
??_R4HardwareVertexBuffer@Ogre@@6B@ DD 00H		; Ogre::HardwareVertexBuffer::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVHardwareVertexBuffer@Ogre@@@8
	DD	FLAT:??_R3HardwareVertexBuffer@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_7HardwareVertexBuffer@Ogre@@6B@
CONST	SEGMENT
??_7HardwareVertexBuffer@Ogre@@6B@ DD FLAT:??_R4HardwareVertexBuffer@Ogre@@6B@ ; Ogre::HardwareVertexBuffer::`vftable'
	DD	FLAT:??_EHardwareVertexBuffer@Ogre@@UAEPAXI@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0HardwareVertexBuffer@Ogre@@QAE@PAVHardwareBufferPool@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0HardwareVertexBuffer@Ogre@@QAE@PAVHardwareBufferPool@1@@Z$0
__ehfuncinfo$??0HardwareVertexBuffer@Ogre@@QAE@PAVHardwareBufferPool@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0HardwareVertexBuffer@Ogre@@QAE@PAVHardwareBufferPool@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0HardwareVertexBuffer@Ogre@@QAE@PAVHardwareBufferPool@1@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_pool$ = 8						; size = 4
??0HardwareVertexBuffer@Ogre@@QAE@PAVHardwareBufferPool@1@@Z PROC ; Ogre::HardwareVertexBuffer::HardwareVertexBuffer, COMDAT
; _this$ = ecx

; 84   : 		{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0HardwareVertexBuffer@Ogre@@QAE@PAVHardwareBufferPool@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _pool$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0HardwareBuffer@Ogre@@IAE@PAVHardwareBufferPool@1@@Z ; Ogre::HardwareBuffer::HardwareBuffer
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7HardwareVertexBuffer@Ogre@@6B@
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+32], 0

; 85   : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0HardwareVertexBuffer@Ogre@@QAE@PAVHardwareBufferPool@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1HardwareBuffer@Ogre@@MAE@XZ		; Ogre::HardwareBuffer::~HardwareBuffer
__ehhandler$??0HardwareVertexBuffer@Ogre@@QAE@PAVHardwareBufferPool@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0HardwareVertexBuffer@Ogre@@QAE@PAVHardwareBufferPool@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0HardwareVertexBuffer@Ogre@@QAE@PAVHardwareBufferPool@1@@Z ENDP ; Ogre::HardwareVertexBuffer::HardwareVertexBuffer
PUBLIC	?setStride@HardwareVertexBuffer@Ogre@@QAEXI@Z	; Ogre::HardwareVertexBuffer::setStride
; Function compile flags: /Odtp
;	COMDAT ?setStride@HardwareVertexBuffer@Ogre@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_stride$ = 8						; size = 4
?setStride@HardwareVertexBuffer@Ogre@@QAEXI@Z PROC	; Ogre::HardwareVertexBuffer::setStride, COMDAT
; _this$ = ecx

; 88   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 89   : 			m_Stride = stride;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _stride$[ebp]
	mov	DWORD PTR [eax+32], ecx

; 90   : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?setStride@HardwareVertexBuffer@Ogre@@QAEXI@Z ENDP	; Ogre::HardwareVertexBuffer::setStride
_TEXT	ENDS
PUBLIC	??1HardwareVertexBuffer@Ogre@@UAE@XZ		; Ogre::HardwareVertexBuffer::~HardwareVertexBuffer
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1HardwareVertexBuffer@Ogre@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1HardwareVertexBuffer@Ogre@@UAE@XZ$0
__ehfuncinfo$??1HardwareVertexBuffer@Ogre@@UAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1HardwareVertexBuffer@Ogre@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1HardwareVertexBuffer@Ogre@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1HardwareVertexBuffer@Ogre@@UAE@XZ PROC		; Ogre::HardwareVertexBuffer::~HardwareVertexBuffer, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1HardwareVertexBuffer@Ogre@@UAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1HardwareBuffer@Ogre@@MAE@XZ		; Ogre::HardwareBuffer::~HardwareBuffer
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1HardwareVertexBuffer@Ogre@@UAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1HardwareBuffer@Ogre@@MAE@XZ		; Ogre::HardwareBuffer::~HardwareBuffer
__ehhandler$??1HardwareVertexBuffer@Ogre@@UAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1HardwareVertexBuffer@Ogre@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1HardwareVertexBuffer@Ogre@@UAE@XZ ENDP		; Ogre::HardwareVertexBuffer::~HardwareVertexBuffer
PUBLIC	??0HardwareVertexBuffer@Ogre@@QAE@ABV01@@Z	; Ogre::HardwareVertexBuffer::HardwareVertexBuffer
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0HardwareVertexBuffer@Ogre@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0HardwareVertexBuffer@Ogre@@QAE@ABV01@@Z$0
__ehfuncinfo$??0HardwareVertexBuffer@Ogre@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0HardwareVertexBuffer@Ogre@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0HardwareVertexBuffer@Ogre@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0HardwareVertexBuffer@Ogre@@QAE@ABV01@@Z PROC		; Ogre::HardwareVertexBuffer::HardwareVertexBuffer, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0HardwareVertexBuffer@Ogre@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0HardwareBuffer@Ogre@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7HardwareVertexBuffer@Ogre@@6B@
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	DWORD PTR [edx+32], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0HardwareVertexBuffer@Ogre@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1HardwareBuffer@Ogre@@MAE@XZ		; Ogre::HardwareBuffer::~HardwareBuffer
__ehhandler$??0HardwareVertexBuffer@Ogre@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0HardwareVertexBuffer@Ogre@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0HardwareVertexBuffer@Ogre@@QAE@ABV01@@Z ENDP		; Ogre::HardwareVertexBuffer::HardwareVertexBuffer
PUBLIC	??4HardwareVertexBuffer@Ogre@@QAEAAV01@ABV01@@Z	; Ogre::HardwareVertexBuffer::operator=
; Function compile flags: /Odtp
;	COMDAT ??4HardwareVertexBuffer@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4HardwareVertexBuffer@Ogre@@QAEAAV01@ABV01@@Z PROC	; Ogre::HardwareVertexBuffer::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4HardwareBuffer@Ogre@@QAEAAV01@ABV01@@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	DWORD PTR [ecx+32], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4HardwareVertexBuffer@Ogre@@QAEAAV01@ABV01@@Z ENDP	; Ogre::HardwareVertexBuffer::operator=
_TEXT	ENDS
PUBLIC	??_GHardwareVertexBuffer@Ogre@@UAEPAXI@Z	; Ogre::HardwareVertexBuffer::`scalar deleting destructor'
; Function compile flags: /Odtp
;	COMDAT ??_GHardwareVertexBuffer@Ogre@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GHardwareVertexBuffer@Ogre@@UAEPAXI@Z PROC		; Ogre::HardwareVertexBuffer::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1HardwareVertexBuffer@Ogre@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@8
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@8:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GHardwareVertexBuffer@Ogre@@UAEPAXI@Z ENDP		; Ogre::HardwareVertexBuffer::`scalar deleting destructor'
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_EHardwareVertexBuffer@Ogre@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_EHardwareVertexBuffer@Ogre@@UAEPAXI@Z PROC		; Ogre::HardwareVertexBuffer::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 2
	je	SHORT $LN3@vector@8
	push	OFFSET ??1HardwareVertexBuffer@Ogre@@UAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx-4]
	push	edx
	push	36					; 00000024H
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??_M@YGXPAXIHP6EX0@Z@Z
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN2@vector@8
	mov	edx, DWORD PTR _this$[ebp]
	sub	edx, 4
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN2@vector@8:
	mov	eax, DWORD PTR _this$[ebp]
	sub	eax, 4
	jmp	SHORT $LN4@vector@8
$LN3@vector@8:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1HardwareVertexBuffer@Ogre@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@vector@8
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@vector@8:
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector@8:
	mov	esp, ebp
	pop	ebp
	ret	4
??_EHardwareVertexBuffer@Ogre@@UAEPAXI@Z ENDP		; Ogre::HardwareVertexBuffer::`vector deleting destructor'
_TEXT	ENDS
PUBLIC	??_7HardwareBufferPool@Ogre@@6B@		; Ogre::HardwareBufferPool::`vftable'
PUBLIC	??0HardwareBufferPool@Ogre@@QAE@ABV01@@Z	; Ogre::HardwareBufferPool::HardwareBufferPool
PUBLIC	??_R4HardwareBufferPool@Ogre@@6B@		; Ogre::HardwareBufferPool::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVHardwareBufferPool@Ogre@@@8		; Ogre::HardwareBufferPool `RTTI Type Descriptor'
PUBLIC	??_R3HardwareBufferPool@Ogre@@8			; Ogre::HardwareBufferPool::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2HardwareBufferPool@Ogre@@8			; Ogre::HardwareBufferPool::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@HardwareBufferPool@Ogre@@8	; Ogre::HardwareBufferPool::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_EHardwareBufferPool@Ogre@@UAEPAXI@Z		; Ogre::HardwareBufferPool::`vector deleting destructor'
EXTRN	??1LockSection@Ogre@@QAE@XZ:PROC		; Ogre::LockSection::~LockSection
;	COMDAT ??_R1A@?0A@EA@HardwareBufferPool@Ogre@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@HardwareBufferPool@Ogre@@8 DD FLAT:??_R0?AVHardwareBufferPool@Ogre@@@8 ; Ogre::HardwareBufferPool::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3HardwareBufferPool@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R2HardwareBufferPool@Ogre@@8
rdata$r	SEGMENT
??_R2HardwareBufferPool@Ogre@@8 DD FLAT:??_R1A@?0A@EA@HardwareBufferPool@Ogre@@8 ; Ogre::HardwareBufferPool::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3HardwareBufferPool@Ogre@@8
rdata$r	SEGMENT
??_R3HardwareBufferPool@Ogre@@8 DD 00H			; Ogre::HardwareBufferPool::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2HardwareBufferPool@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVHardwareBufferPool@Ogre@@@8
_DATA	SEGMENT
??_R0?AVHardwareBufferPool@Ogre@@@8 DD FLAT:??_7type_info@@6B@ ; Ogre::HardwareBufferPool `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVHardwareBufferPool@Ogre@@', 00H
_DATA	ENDS
;	COMDAT ??_R4HardwareBufferPool@Ogre@@6B@
rdata$r	SEGMENT
??_R4HardwareBufferPool@Ogre@@6B@ DD 00H		; Ogre::HardwareBufferPool::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVHardwareBufferPool@Ogre@@@8
	DD	FLAT:??_R3HardwareBufferPool@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_7HardwareBufferPool@Ogre@@6B@
CONST	SEGMENT
??_7HardwareBufferPool@Ogre@@6B@ DD FLAT:??_R4HardwareBufferPool@Ogre@@6B@ ; Ogre::HardwareBufferPool::`vftable'
	DD	FLAT:??_EHardwareBufferPool@Ogre@@UAEPAXI@Z
	DD	FLAT:__purecall
	DD	FLAT:__purecall
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0HardwareBufferPool@Ogre@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0HardwareBufferPool@Ogre@@QAE@ABV01@@Z$0
__ehfuncinfo$??0HardwareBufferPool@Ogre@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0HardwareBufferPool@Ogre@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0HardwareBufferPool@Ogre@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0HardwareBufferPool@Ogre@@QAE@ABV01@@Z PROC		; Ogre::HardwareBufferPool::HardwareBufferPool, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0HardwareBufferPool@Ogre@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7HardwareBufferPool@Ogre@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	al, BYTE PTR [edx+4]
	mov	BYTE PTR [ecx+4], al
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	al, BYTE PTR [edx+5]
	mov	BYTE PTR [ecx+5], al
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+8], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR [ecx+12], eax
	mov	ecx, DWORD PTR ___that$[ebp]
	add	ecx, 16					; 00000010H
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 16					; 00000010H
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], ecx
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 28					; 0000001cH
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 28					; 0000001cH
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	edx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	mov	DWORD PTR [eax+40], edx
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+44], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0HardwareBufferPool@Ogre@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 44					; 0000002cH
	jmp	??1LockSection@Ogre@@QAE@XZ		; Ogre::LockSection::~LockSection
__ehhandler$??0HardwareBufferPool@Ogre@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0HardwareBufferPool@Ogre@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0HardwareBufferPool@Ogre@@QAE@ABV01@@Z ENDP		; Ogre::HardwareBufferPool::HardwareBufferPool
PUBLIC	??4HardwareBufferPool@Ogre@@QAEAAV01@ABV01@@Z	; Ogre::HardwareBufferPool::operator=
; Function compile flags: /Odtp
;	COMDAT ??4HardwareBufferPool@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4HardwareBufferPool@Ogre@@QAEAAV01@ABV01@@Z PROC	; Ogre::HardwareBufferPool::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	dl, BYTE PTR [ecx+4]
	mov	BYTE PTR [eax+4], dl
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	dl, BYTE PTR [ecx+5]
	mov	BYTE PTR [eax+5], dl
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], edx
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 16					; 00000010H
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	mov	ecx, DWORD PTR ___that$[ebp]
	add	ecx, 28					; 0000001cH
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 28					; 0000001cH
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	DWORD PTR [edx+40], ecx
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+44]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+44], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4HardwareBufferPool@Ogre@@QAEAAV01@ABV01@@Z ENDP	; Ogre::HardwareBufferPool::operator=
_TEXT	ENDS
PUBLIC	??_GHardwareBufferPool@Ogre@@UAEPAXI@Z		; Ogre::HardwareBufferPool::`scalar deleting destructor'
EXTRN	??1HardwareBufferPool@Ogre@@UAE@XZ:PROC		; Ogre::HardwareBufferPool::~HardwareBufferPool
; Function compile flags: /Odtp
;	COMDAT ??_GHardwareBufferPool@Ogre@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GHardwareBufferPool@Ogre@@UAEPAXI@Z PROC		; Ogre::HardwareBufferPool::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1HardwareBufferPool@Ogre@@UAE@XZ	; Ogre::HardwareBufferPool::~HardwareBufferPool
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@9
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@9:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GHardwareBufferPool@Ogre@@UAEPAXI@Z ENDP		; Ogre::HardwareBufferPool::`scalar deleting destructor'
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_EHardwareBufferPool@Ogre@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_EHardwareBufferPool@Ogre@@UAEPAXI@Z PROC		; Ogre::HardwareBufferPool::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 2
	je	SHORT $LN3@vector@9
	push	OFFSET ??1HardwareBufferPool@Ogre@@UAE@XZ ; Ogre::HardwareBufferPool::~HardwareBufferPool
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx-4]
	push	edx
	push	48					; 00000030H
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??_M@YGXPAXIHP6EX0@Z@Z
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN2@vector@9
	mov	edx, DWORD PTR _this$[ebp]
	sub	edx, 4
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN2@vector@9:
	mov	eax, DWORD PTR _this$[ebp]
	sub	eax, 4
	jmp	SHORT $LN4@vector@9
$LN3@vector@9:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1HardwareBufferPool@Ogre@@UAE@XZ	; Ogre::HardwareBufferPool::~HardwareBufferPool
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@vector@9
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@vector@9:
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector@9:
	mov	esp, ebp
	pop	ebp
	ret	4
??_EHardwareBufferPool@Ogre@@UAEPAXI@Z ENDP		; Ogre::HardwareBufferPool::`vector deleting destructor'
_TEXT	ENDS
PUBLIC	??4?$Singleton@VHardwareBufferManager@Ogre@@@Ogre@@QAEAAV01@ABV01@@Z ; Ogre::Singleton<Ogre::HardwareBufferManager>::operator=
; Function compile flags: /Odtp
;	COMDAT ??4?$Singleton@VHardwareBufferManager@Ogre@@@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4?$Singleton@VHardwareBufferManager@Ogre@@@Ogre@@QAEAAV01@ABV01@@Z PROC ; Ogre::Singleton<Ogre::HardwareBufferManager>::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4?$Singleton@VHardwareBufferManager@Ogre@@@Ogre@@QAEAAV01@ABV01@@Z ENDP ; Ogre::Singleton<Ogre::HardwareBufferManager>::operator=
_TEXT	ENDS
PUBLIC	??1?$map@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@@std@@QAE@XZ ; std::map<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> > >::~map<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> > >
PUBLIC	??1?$Singleton@VHardwareBufferManager@Ogre@@@Ogre@@QAE@XZ ; Ogre::Singleton<Ogre::HardwareBufferManager>::~Singleton<Ogre::HardwareBufferManager>
PUBLIC	??0?$map@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@@std@@QAE@ABV01@@Z ; std::map<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> > >::map<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> > >
PUBLIC	??_7HardwareBufferManager@Ogre@@6B@		; Ogre::HardwareBufferManager::`vftable'
PUBLIC	??0HardwareBufferManager@Ogre@@QAE@ABV01@@Z	; Ogre::HardwareBufferManager::HardwareBufferManager
PUBLIC	??_R4HardwareBufferManager@Ogre@@6B@		; Ogre::HardwareBufferManager::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVHardwareBufferManager@Ogre@@@8		; Ogre::HardwareBufferManager `RTTI Type Descriptor'
PUBLIC	??_R3HardwareBufferManager@Ogre@@8		; Ogre::HardwareBufferManager::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2HardwareBufferManager@Ogre@@8		; Ogre::HardwareBufferManager::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@HardwareBufferManager@Ogre@@8	; Ogre::HardwareBufferManager::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R13?0A@EA@?$Singleton@VHardwareBufferManager@Ogre@@@Ogre@@8 ; Ogre::Singleton<Ogre::HardwareBufferManager>::`RTTI Base Class Descriptor at (4,-1,0,64)'
PUBLIC	??_R0?AV?$Singleton@VHardwareBufferManager@Ogre@@@Ogre@@@8 ; Ogre::Singleton<Ogre::HardwareBufferManager> `RTTI Type Descriptor'
PUBLIC	??_R3?$Singleton@VHardwareBufferManager@Ogre@@@Ogre@@8 ; Ogre::Singleton<Ogre::HardwareBufferManager>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$Singleton@VHardwareBufferManager@Ogre@@@Ogre@@8 ; Ogre::Singleton<Ogre::HardwareBufferManager>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$Singleton@VHardwareBufferManager@Ogre@@@Ogre@@8 ; Ogre::Singleton<Ogre::HardwareBufferManager>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_EHardwareBufferManager@Ogre@@UAEPAXI@Z	; Ogre::HardwareBufferManager::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@?$Singleton@VHardwareBufferManager@Ogre@@@Ogre@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$Singleton@VHardwareBufferManager@Ogre@@@Ogre@@8 DD FLAT:??_R0?AV?$Singleton@VHardwareBufferManager@Ogre@@@Ogre@@@8 ; Ogre::Singleton<Ogre::HardwareBufferManager>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$Singleton@VHardwareBufferManager@Ogre@@@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R2?$Singleton@VHardwareBufferManager@Ogre@@@Ogre@@8
rdata$r	SEGMENT
??_R2?$Singleton@VHardwareBufferManager@Ogre@@@Ogre@@8 DD FLAT:??_R1A@?0A@EA@?$Singleton@VHardwareBufferManager@Ogre@@@Ogre@@8 ; Ogre::Singleton<Ogre::HardwareBufferManager>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3?$Singleton@VHardwareBufferManager@Ogre@@@Ogre@@8
rdata$r	SEGMENT
??_R3?$Singleton@VHardwareBufferManager@Ogre@@@Ogre@@8 DD 00H ; Ogre::Singleton<Ogre::HardwareBufferManager>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$Singleton@VHardwareBufferManager@Ogre@@@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$Singleton@VHardwareBufferManager@Ogre@@@Ogre@@@8
_DATA	SEGMENT
??_R0?AV?$Singleton@VHardwareBufferManager@Ogre@@@Ogre@@@8 DD FLAT:??_7type_info@@6B@ ; Ogre::Singleton<Ogre::HardwareBufferManager> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$Singleton@VHardwareBufferManager@Ogre@@@Ogre@@', 00H
_DATA	ENDS
;	COMDAT ??_R13?0A@EA@?$Singleton@VHardwareBufferManager@Ogre@@@Ogre@@8
rdata$r	SEGMENT
??_R13?0A@EA@?$Singleton@VHardwareBufferManager@Ogre@@@Ogre@@8 DD FLAT:??_R0?AV?$Singleton@VHardwareBufferManager@Ogre@@@Ogre@@@8 ; Ogre::Singleton<Ogre::HardwareBufferManager>::`RTTI Base Class Descriptor at (4,-1,0,64)'
	DD	00H
	DD	04H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$Singleton@VHardwareBufferManager@Ogre@@@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@HardwareBufferManager@Ogre@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@HardwareBufferManager@Ogre@@8 DD FLAT:??_R0?AVHardwareBufferManager@Ogre@@@8 ; Ogre::HardwareBufferManager::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3HardwareBufferManager@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R2HardwareBufferManager@Ogre@@8
rdata$r	SEGMENT
??_R2HardwareBufferManager@Ogre@@8 DD FLAT:??_R1A@?0A@EA@HardwareBufferManager@Ogre@@8 ; Ogre::HardwareBufferManager::`RTTI Base Class Array'
	DD	FLAT:??_R13?0A@EA@?$Singleton@VHardwareBufferManager@Ogre@@@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R3HardwareBufferManager@Ogre@@8
rdata$r	SEGMENT
??_R3HardwareBufferManager@Ogre@@8 DD 00H		; Ogre::HardwareBufferManager::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2HardwareBufferManager@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVHardwareBufferManager@Ogre@@@8
_DATA	SEGMENT
??_R0?AVHardwareBufferManager@Ogre@@@8 DD FLAT:??_7type_info@@6B@ ; Ogre::HardwareBufferManager `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVHardwareBufferManager@Ogre@@', 00H
_DATA	ENDS
;	COMDAT ??_R4HardwareBufferManager@Ogre@@6B@
rdata$r	SEGMENT
??_R4HardwareBufferManager@Ogre@@6B@ DD 00H		; Ogre::HardwareBufferManager::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVHardwareBufferManager@Ogre@@@8
	DD	FLAT:??_R3HardwareBufferManager@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_7HardwareBufferManager@Ogre@@6B@
CONST	SEGMENT
??_7HardwareBufferManager@Ogre@@6B@ DD FLAT:??_R4HardwareBufferManager@Ogre@@6B@ ; Ogre::HardwareBufferManager::`vftable'
	DD	FLAT:??_EHardwareBufferManager@Ogre@@UAEPAXI@Z
	DD	FLAT:__purecall
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0HardwareBufferManager@Ogre@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0HardwareBufferManager@Ogre@@QAE@ABV01@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0HardwareBufferManager@Ogre@@QAE@ABV01@@Z$1
__ehfuncinfo$??0HardwareBufferManager@Ogre@@QAE@ABV01@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0HardwareBufferManager@Ogre@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0HardwareBufferManager@Ogre@@QAE@ABV01@@Z
_TEXT	SEGMENT
tv68 = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0HardwareBufferManager@Ogre@@QAE@ABV01@@Z PROC	; Ogre::HardwareBufferManager::HardwareBufferManager, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0HardwareBufferManager@Ogre@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	cmp	DWORD PTR ___that$[ebp], 0
	je	SHORT $LN3@HardwareBu@2
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 4
	mov	DWORD PTR tv68[ebp], eax
	jmp	SHORT $LN4@HardwareBu@2
$LN3@HardwareBu@2:
	mov	DWORD PTR tv68[ebp], 0
$LN4@HardwareBu@2:
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7HardwareBufferManager@Ogre@@6B@
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 4
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??0?$map@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@@std@@QAE@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0HardwareBufferManager@Ogre@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	jmp	??1?$Singleton@VHardwareBufferManager@Ogre@@@Ogre@@QAE@XZ ; Ogre::Singleton<Ogre::HardwareBufferManager>::~Singleton<Ogre::HardwareBufferManager>
__unwindfunclet$??0HardwareBufferManager@Ogre@@QAE@ABV01@@Z$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	jmp	??1?$map@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@@std@@QAE@XZ
__ehhandler$??0HardwareBufferManager@Ogre@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0HardwareBufferManager@Ogre@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0HardwareBufferManager@Ogre@@QAE@ABV01@@Z ENDP	; Ogre::HardwareBufferManager::HardwareBufferManager
PUBLIC	??4?$map@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@@std@@QAEAAV01@ABV01@@Z ; std::map<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> > >::operator=
PUBLIC	??4HardwareBufferManager@Ogre@@QAEAAV01@ABV01@@Z ; Ogre::HardwareBufferManager::operator=
; Function compile flags: /Odtp
;	COMDAT ??4HardwareBufferManager@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4HardwareBufferManager@Ogre@@QAEAAV01@ABV01@@Z PROC	; Ogre::HardwareBufferManager::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??4?$map@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@@std@@QAEAAV01@ABV01@@Z
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4HardwareBufferManager@Ogre@@QAEAAV01@ABV01@@Z ENDP	; Ogre::HardwareBufferManager::operator=
_TEXT	ENDS
PUBLIC	??_GHardwareBufferManager@Ogre@@UAEPAXI@Z	; Ogre::HardwareBufferManager::`scalar deleting destructor'
EXTRN	??1HardwareBufferManager@Ogre@@UAE@XZ:PROC	; Ogre::HardwareBufferManager::~HardwareBufferManager
; Function compile flags: /Odtp
;	COMDAT ??_GHardwareBufferManager@Ogre@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GHardwareBufferManager@Ogre@@UAEPAXI@Z PROC		; Ogre::HardwareBufferManager::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1HardwareBufferManager@Ogre@@UAE@XZ	; Ogre::HardwareBufferManager::~HardwareBufferManager
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@10
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@10:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GHardwareBufferManager@Ogre@@UAEPAXI@Z ENDP		; Ogre::HardwareBufferManager::`scalar deleting destructor'
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_EHardwareBufferManager@Ogre@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_EHardwareBufferManager@Ogre@@UAEPAXI@Z PROC		; Ogre::HardwareBufferManager::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 2
	je	SHORT $LN3@vector@10
	push	OFFSET ??1HardwareBufferManager@Ogre@@UAE@XZ ; Ogre::HardwareBufferManager::~HardwareBufferManager
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx-4]
	push	edx
	push	36					; 00000024H
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??_M@YGXPAXIHP6EX0@Z@Z
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN2@vector@10
	mov	edx, DWORD PTR _this$[ebp]
	sub	edx, 4
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN2@vector@10:
	mov	eax, DWORD PTR _this$[ebp]
	sub	eax, 4
	jmp	SHORT $LN4@vector@10
$LN3@vector@10:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1HardwareBufferManager@Ogre@@UAE@XZ	; Ogre::HardwareBufferManager::~HardwareBufferManager
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@vector@10
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@vector@10:
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector@10:
	mov	esp, ebp
	pop	ebp
	ret	4
??_EHardwareBufferManager@Ogre@@UAEPAXI@Z ENDP		; Ogre::HardwareBufferManager::`vector deleting destructor'
_TEXT	ENDS
PUBLIC	??1?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::~_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >
PUBLIC	??0?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@ABV01@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$map@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$map@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@@std@@QAE@ABV01@@Z$0
__ehfuncinfo$??0?$map@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@@std@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$map@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$map@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0?$map@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@@std@@QAE@ABV01@@Z PROC ; std::map<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> > >::map<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> > >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$map@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@ABV01@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$map@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@@std@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::~_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >
__ehhandler$??0?$map@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$map@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$map@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@@std@@QAE@ABV01@@Z ENDP ; std::map<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> > >::map<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> > >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$map@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$map@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@@std@@QAE@XZ$0
__ehfuncinfo$??1?$map@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$map@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$map@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$map@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@@std@@QAE@XZ PROC ; std::map<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> > >::~map<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> > >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$map@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::~_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$map@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::~_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >
__ehhandler$??1?$map@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$map@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$map@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@@std@@QAE@XZ ENDP ; std::map<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> > >::~map<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> > >
PUBLIC	??4?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAEAAV01@ABV01@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::operator=
; Function compile flags: /Odtp
;	COMDAT ??4?$map@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4?$map@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@@std@@QAEAAV01@ABV01@@Z PROC ; std::map<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> > >::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAEAAV01@ABV01@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::operator=
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4?$map@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@@std@@QAEAAV01@ABV01@@Z ENDP ; std::map<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> > >::operator=
_TEXT	ENDS
PUBLIC	?release@HardwareBuffer@Ogre@@QAEXXZ		; Ogre::HardwareBuffer::release
EXTRN	?freeBuffer@HardwareBufferPool@Ogre@@QAEXPAVHardwareBuffer@2@@Z:PROC ; Ogre::HardwareBufferPool::freeBuffer
; Function compile flags: /Odtp
;	COMDAT ?release@HardwareBuffer@Ogre@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?release@HardwareBuffer@Ogre@@QAEXXZ PROC		; Ogre::HardwareBuffer::release, COMDAT
; _this$ = ecx

; 152  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 153  : 		m_pPool->freeBuffer(this);

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+28]
	call	?freeBuffer@HardwareBufferPool@Ogre@@QAEXPAVHardwareBuffer@2@@Z ; Ogre::HardwareBufferPool::freeBuffer

; 154  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?release@HardwareBuffer@Ogre@@QAEXXZ ENDP		; Ogre::HardwareBuffer::release
_TEXT	ENDS
PUBLIC	?lock@HardwareBuffer@Ogre@@QAEPAXW4HardwareBufferLockOpt@2@@Z ; Ogre::HardwareBuffer::lock
; Function compile flags: /Odtp
;	COMDAT ?lock@HardwareBuffer@Ogre@@QAEPAXW4HardwareBufferLockOpt@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_lockopt$ = 8						; size = 4
?lock@HardwareBuffer@Ogre@@QAEPAXW4HardwareBufferLockOpt@2@@Z PROC ; Ogre::HardwareBuffer::lock, COMDAT
; _this$ = ecx

; 157  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 158  : 		return m_pPool->lock(m_Start, m_Num, lockopt);

	mov	eax, DWORD PTR _lockopt$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+28]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+28]
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [edx+4]
	call	eax

; 159  : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
?lock@HardwareBuffer@Ogre@@QAEPAXW4HardwareBufferLockOpt@2@@Z ENDP ; Ogre::HardwareBuffer::lock
_TEXT	ENDS
PUBLIC	?unlock@HardwareBuffer@Ogre@@QAEXXZ		; Ogre::HardwareBuffer::unlock
; Function compile flags: /Odtp
;	COMDAT ?unlock@HardwareBuffer@Ogre@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?unlock@HardwareBuffer@Ogre@@QAEXXZ PROC		; Ogre::HardwareBuffer::unlock, COMDAT
; _this$ = ecx

; 162  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 163  : 		m_pPool->unlock();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+28]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, eax
	mov	eax, DWORD PTR [edx+8]
	call	eax

; 164  : 		m_DataInvalid = false;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+12], 0

; 165  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?unlock@HardwareBuffer@Ogre@@QAEXXZ ENDP		; Ogre::HardwareBuffer::unlock
_TEXT	ENDS
PUBLIC	??0?$TBox@H@Ogre@@QAE@XZ			; Ogre::TBox<int>::TBox<int>
PUBLIC	??0PixelBox@Ogre@@QAE@XZ			; Ogre::PixelBox::PixelBox
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogrepixelformat.h
;	COMDAT ??0PixelBox@Ogre@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0PixelBox@Ogre@@QAE@XZ PROC				; Ogre::PixelBox::PixelBox, COMDAT
; _this$ = ecx

; 183  : 		PixelBox() {}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$TBox@H@Ogre@@QAE@XZ		; Ogre::TBox<int>::TBox<int>
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0PixelBox@Ogre@@QAE@XZ ENDP				; Ogre::PixelBox::PixelBox
_TEXT	ENDS
PUBLIC	?setConsecutive@PixelBox@Ogre@@QAEXXZ		; Ogre::PixelBox::setConsecutive
PUBLIC	??0PixelBox@Ogre@@QAE@ABV?$TBox@H@1@W4PixelFormat@1@PAX@Z ; Ogre::PixelBox::PixelBox
; Function compile flags: /Odtp
;	COMDAT ??0PixelBox@Ogre@@QAE@ABV?$TBox@H@1@W4PixelFormat@1@PAX@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_extents$ = 8						; size = 4
_pixelFormat$ = 12					; size = 4
_pixelData$ = 16					; size = 4
??0PixelBox@Ogre@@QAE@ABV?$TBox@H@1@W4PixelFormat@1@PAX@Z PROC ; Ogre::PixelBox::PixelBox, COMDAT
; _this$ = ecx

; 193  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _extents$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], edx
	mov	edx, DWORD PTR [eax+16]
	mov	DWORD PTR [ecx+16], edx
	mov	eax, DWORD PTR [eax+20]
	mov	DWORD PTR [ecx+20], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _pixelData$[ebp]
	mov	DWORD PTR [ecx+24], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pixelFormat$[ebp]
	mov	DWORD PTR [eax+28], ecx

; 194  : 			setConsecutive();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?setConsecutive@PixelBox@Ogre@@QAEXXZ	; Ogre::PixelBox::setConsecutive

; 195  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??0PixelBox@Ogre@@QAE@ABV?$TBox@H@1@W4PixelFormat@1@PAX@Z ENDP ; Ogre::PixelBox::PixelBox
_TEXT	ENDS
PUBLIC	??0?$TBox@H@Ogre@@QAE@HHHHHH@Z			; Ogre::TBox<int>::TBox<int>
PUBLIC	??0PixelBox@Ogre@@QAE@IIIW4PixelFormat@1@PAX@Z	; Ogre::PixelBox::PixelBox
; Function compile flags: /Odtp
;	COMDAT ??0PixelBox@Ogre@@QAE@IIIW4PixelFormat@1@PAX@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_width$ = 8						; size = 4
_height$ = 12						; size = 4
_depth$ = 16						; size = 4
_pixelFormat$ = 20					; size = 4
_pixelData$ = 24					; size = 4
??0PixelBox@Ogre@@QAE@IIIW4PixelFormat@1@PAX@Z PROC	; Ogre::PixelBox::PixelBox, COMDAT
; _this$ = ecx

; 208  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _depth$[ebp]
	push	eax
	mov	ecx, DWORD PTR _height$[ebp]
	push	ecx
	mov	edx, DWORD PTR _width$[ebp]
	push	edx
	push	0
	push	0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$TBox@H@Ogre@@QAE@HHHHHH@Z		; Ogre::TBox<int>::TBox<int>
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pixelData$[ebp]
	mov	DWORD PTR [eax+24], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _pixelFormat$[ebp]
	mov	DWORD PTR [edx+28], eax

; 209  : 			setConsecutive();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?setConsecutive@PixelBox@Ogre@@QAEXXZ	; Ogre::PixelBox::setConsecutive

; 210  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
??0PixelBox@Ogre@@QAE@IIIW4PixelFormat@1@PAX@Z ENDP	; Ogre::PixelBox::PixelBox
_TEXT	ENDS
PUBLIC	?getHeight@?$TBox@H@Ogre@@QBEHXZ		; Ogre::TBox<int>::getHeight
PUBLIC	?getWidth@?$TBox@H@Ogre@@QBEHXZ			; Ogre::TBox<int>::getWidth
; Function compile flags: /Odtp
;	COMDAT ?setConsecutive@PixelBox@Ogre@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?setConsecutive@PixelBox@Ogre@@QAEXXZ PROC		; Ogre::PixelBox::setConsecutive, COMDAT
; _this$ = ecx

; 232  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 233  : 			rowPitch = getWidth();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?getWidth@?$TBox@H@Ogre@@QBEHXZ		; Ogre::TBox<int>::getWidth
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+32], eax

; 234  : 			slicePitch = getWidth()*getHeight();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?getWidth@?$TBox@H@Ogre@@QBEHXZ		; Ogre::TBox<int>::getWidth
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getHeight@?$TBox@H@Ogre@@QBEHXZ	; Ogre::TBox<int>::getHeight
	imul	esi, eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+36], esi

; 235  : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?setConsecutive@PixelBox@Ogre@@QAEXXZ ENDP		; Ogre::PixelBox::setConsecutive
_TEXT	ENDS
PUBLIC	?getRowSkip@PixelBox@Ogre@@QBEIXZ		; Ogre::PixelBox::getRowSkip
; Function compile flags: /Odtp
;	COMDAT ?getRowSkip@PixelBox@Ogre@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getRowSkip@PixelBox@Ogre@@QBEIXZ PROC			; Ogre::PixelBox::getRowSkip, COMDAT
; _this$ = ecx

; 240  : 		size_t getRowSkip() const { return rowPitch - getWidth(); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getWidth@?$TBox@H@Ogre@@QBEHXZ		; Ogre::TBox<int>::getWidth
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	sub	edx, eax
	mov	eax, edx
	mov	esp, ebp
	pop	ebp
	ret	0
?getRowSkip@PixelBox@Ogre@@QBEIXZ ENDP			; Ogre::PixelBox::getRowSkip
_TEXT	ENDS
PUBLIC	?getSliceSkip@PixelBox@Ogre@@QBEIXZ		; Ogre::PixelBox::getSliceSkip
; Function compile flags: /Odtp
;	COMDAT ?getSliceSkip@PixelBox@Ogre@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getSliceSkip@PixelBox@Ogre@@QBEIXZ PROC		; Ogre::PixelBox::getSliceSkip, COMDAT
; _this$ = ecx

; 245  : 		size_t getSliceSkip() const { return slicePitch - (getHeight() * rowPitch); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getHeight@?$TBox@H@Ogre@@QBEHXZ	; Ogre::TBox<int>::getHeight
	mov	ecx, DWORD PTR _this$[ebp]
	imul	eax, DWORD PTR [ecx+32]
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+36]
	sub	ecx, eax
	mov	eax, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
?getSliceSkip@PixelBox@Ogre@@QBEIXZ ENDP		; Ogre::PixelBox::getSliceSkip
_TEXT	ENDS
PUBLIC	?isConsecutive@PixelBox@Ogre@@QBE_NXZ		; Ogre::PixelBox::isConsecutive
; Function compile flags: /Odtp
;	COMDAT ?isConsecutive@PixelBox@Ogre@@QBE_NXZ
_TEXT	SEGMENT
tv87 = -8						; size = 4
_this$ = -4						; size = 4
?isConsecutive@PixelBox@Ogre@@QBE_NXZ PROC		; Ogre::PixelBox::isConsecutive, COMDAT
; _this$ = ecx

; 251  : 		{ 

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 252  : 			return rowPitch == getWidth() && slicePitch == getWidth()*getHeight(); 

	mov	ecx, DWORD PTR _this$[ebp]
	call	?getWidth@?$TBox@H@Ogre@@QBEHXZ		; Ogre::TBox<int>::getWidth
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+32], eax
	jne	SHORT $LN3@isConsecut
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getWidth@?$TBox@H@Ogre@@QBEHXZ		; Ogre::TBox<int>::getWidth
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getHeight@?$TBox@H@Ogre@@QBEHXZ	; Ogre::TBox<int>::getHeight
	imul	esi, eax
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+36], esi
	jne	SHORT $LN3@isConsecut
	mov	DWORD PTR tv87[ebp], 1
	jmp	SHORT $LN4@isConsecut
$LN3@isConsecut:
	mov	DWORD PTR tv87[ebp], 0
$LN4@isConsecut:
	mov	al, BYTE PTR tv87[ebp]

; 253  : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?isConsecutive@PixelBox@Ogre@@QBE_NXZ ENDP		; Ogre::PixelBox::isConsecutive
_TEXT	ENDS
PUBLIC	??4?$TBox@H@Ogre@@QAEAAV01@ABV01@@Z		; Ogre::TBox<int>::operator=
; Function compile flags: /Odtp
;	COMDAT ??4?$TBox@H@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4?$TBox@H@Ogre@@QAEAAV01@ABV01@@Z PROC		; Ogre::TBox<int>::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], edx
	mov	edx, DWORD PTR [eax+16]
	mov	DWORD PTR [ecx+16], edx
	mov	eax, DWORD PTR [eax+20]
	mov	DWORD PTR [ecx+20], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4?$TBox@H@Ogre@@QAEAAV01@ABV01@@Z ENDP		; Ogre::TBox<int>::operator=
_TEXT	ENDS
PUBLIC	??4PixelBox@Ogre@@QAEAAV01@ABV01@@Z		; Ogre::PixelBox::operator=
; Function compile flags: /Odtp
;	COMDAT ??4PixelBox@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4PixelBox@Ogre@@QAEAAV01@ABV01@@Z PROC		; Ogre::PixelBox::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	esi, DWORD PTR ___that$[ebp]
	mov	ecx, 10					; 0000000aH
	mov	edi, DWORD PTR _this$[ebp]
	rep movsd
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
??4PixelBox@Ogre@@QAEAAV01@ABV01@@Z ENDP		; Ogre::PixelBox::operator=
_TEXT	ENDS
PUBLIC	??4PixelUtil@Ogre@@QAEAAV01@ABV01@@Z		; Ogre::PixelUtil::operator=
; Function compile flags: /Odtp
;	COMDAT ??4PixelUtil@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4PixelUtil@Ogre@@QAEAAV01@ABV01@@Z PROC		; Ogre::PixelUtil::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4PixelUtil@Ogre@@QAEAAV01@ABV01@@Z ENDP		; Ogre::PixelUtil::operator=
_TEXT	ENDS
PUBLIC	?getRTTI@SurfaceData@Ogre@@UBEPBVRuntimeClass@2@XZ ; Ogre::SurfaceData::getRTTI
EXTRN	?m_RTTI@SurfaceData@Ogre@@2VRuntimeClass@2@B:BYTE ; Ogre::SurfaceData::m_RTTI
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogretexture.h
;	COMDAT ?getRTTI@SurfaceData@Ogre@@UBEPBVRuntimeClass@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getRTTI@SurfaceData@Ogre@@UBEPBVRuntimeClass@2@XZ PROC	; Ogre::SurfaceData::getRTTI, COMDAT
; _this$ = ecx

; 32   : 		DECLARE_RTTI(SurfaceData)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, OFFSET ?m_RTTI@SurfaceData@Ogre@@2VRuntimeClass@2@B ; Ogre::SurfaceData::m_RTTI
	mov	esp, ebp
	pop	ebp
	ret	0
?getRTTI@SurfaceData@Ogre@@UBEPBVRuntimeClass@2@XZ ENDP	; Ogre::SurfaceData::getRTTI
_TEXT	ENDS
PUBLIC	?newObject@SurfaceData@Ogre@@SAPAVBaseObject@2@XZ ; Ogre::SurfaceData::newObject
EXTRN	??0SurfaceData@Ogre@@QAE@XZ:PROC		; Ogre::SurfaceData::SurfaceData
EXTRN	??2MemoryDelegation@Ogre@@SAPAXI@Z:PROC		; Ogre::MemoryDelegation::operator new
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?newObject@SurfaceData@Ogre@@SAPAVBaseObject@2@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?newObject@SurfaceData@Ogre@@SAPAVBaseObject@2@XZ$0
__ehfuncinfo$?newObject@SurfaceData@Ogre@@SAPAVBaseObject@2@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?newObject@SurfaceData@Ogre@@SAPAVBaseObject@2@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?newObject@SurfaceData@Ogre@@SAPAVBaseObject@2@XZ
_TEXT	SEGMENT
tv75 = -24						; size = 4
$T71819 = -20						; size = 4
$T71818 = -16						; size = 4
__$EHRec$ = -12						; size = 12
?newObject@SurfaceData@Ogre@@SAPAVBaseObject@2@XZ PROC	; Ogre::SurfaceData::newObject, COMDAT

; 32   : 		DECLARE_RTTI(SurfaceData)

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?newObject@SurfaceData@Ogre@@SAPAVBaseObject@2@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 12					; 0000000cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	push	60					; 0000003cH
	call	??2MemoryDelegation@Ogre@@SAPAXI@Z	; Ogre::MemoryDelegation::operator new
	add	esp, 4
	mov	DWORD PTR $T71819[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T71819[ebp], 0
	je	SHORT $LN3@newObject
	mov	ecx, DWORD PTR $T71819[ebp]
	call	??0SurfaceData@Ogre@@QAE@XZ		; Ogre::SurfaceData::SurfaceData
	mov	DWORD PTR tv75[ebp], eax
	jmp	SHORT $LN4@newObject
$LN3@newObject:
	mov	DWORD PTR tv75[ebp], 0
$LN4@newObject:
	mov	eax, DWORD PTR tv75[ebp]
	mov	DWORD PTR $T71818[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR $T71818[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?newObject@SurfaceData@Ogre@@SAPAVBaseObject@2@XZ$0:
	push	60					; 0000003cH
	mov	eax, DWORD PTR $T71819[ebp]
	push	eax
	call	??3MemoryDelegation@Ogre@@SAXPAXI@Z	; Ogre::MemoryDelegation::operator delete
	add	esp, 8
	ret	0
__ehhandler$?newObject@SurfaceData@Ogre@@SAPAVBaseObject@2@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?newObject@SurfaceData@Ogre@@SAPAVBaseObject@2@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?newObject@SurfaceData@Ogre@@SAPAVBaseObject@2@XZ ENDP	; Ogre::SurfaceData::newObject
PUBLIC	??A?$vector@DV?$allocator@D@std@@@std@@QAEAADI@Z ; std::vector<char,std::allocator<char> >::operator[]
PUBLIC	?getBits@SurfaceData@Ogre@@QAEPAXXZ		; Ogre::SurfaceData::getBits
; Function compile flags: /Odtp
;	COMDAT ?getBits@SurfaceData@Ogre@@QAEPAXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getBits@SurfaceData@Ogre@@QAEPAXXZ PROC		; Ogre::SurfaceData::getBits, COMDAT
; _this$ = ecx

; 38   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 39   : 			return &m_Pixels[0];

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??A?$vector@DV?$allocator@D@std@@@std@@QAEAADI@Z ; std::vector<char,std::allocator<char> >::operator[]

; 40   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?getBits@SurfaceData@Ogre@@QAEPAXXZ ENDP		; Ogre::SurfaceData::getBits
_TEXT	ENDS
PUBLIC	??1?$vector@DV?$allocator@D@std@@@std@@QAE@XZ	; std::vector<char,std::allocator<char> >::~vector<char,std::allocator<char> >
PUBLIC	??1SurfaceData@Ogre@@UAE@XZ			; Ogre::SurfaceData::~SurfaceData
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1SurfaceData@Ogre@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1SurfaceData@Ogre@@UAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1SurfaceData@Ogre@@UAE@XZ$1
__ehfuncinfo$??1SurfaceData@Ogre@@UAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??1SurfaceData@Ogre@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1SurfaceData@Ogre@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1SurfaceData@Ogre@@UAE@XZ PROC			; Ogre::SurfaceData::~SurfaceData, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1SurfaceData@Ogre@@UAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??1?$vector@DV?$allocator@D@std@@@std@@QAE@XZ ; std::vector<char,std::allocator<char> >::~vector<char,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1BaseObject@Ogre@@MAE@XZ		; Ogre::BaseObject::~BaseObject
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1SurfaceData@Ogre@@UAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1BaseObject@Ogre@@MAE@XZ		; Ogre::BaseObject::~BaseObject
__unwindfunclet$??1SurfaceData@Ogre@@UAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	jmp	??1?$vector@DV?$allocator@D@std@@@std@@QAE@XZ ; std::vector<char,std::allocator<char> >::~vector<char,std::allocator<char> >
__ehhandler$??1SurfaceData@Ogre@@UAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1SurfaceData@Ogre@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1SurfaceData@Ogre@@UAE@XZ ENDP			; Ogre::SurfaceData::~SurfaceData
PUBLIC	??0?$vector@DV?$allocator@D@std@@@std@@QAE@ABV01@@Z ; std::vector<char,std::allocator<char> >::vector<char,std::allocator<char> >
PUBLIC	??_7SurfaceData@Ogre@@6B@			; Ogre::SurfaceData::`vftable'
PUBLIC	??0SurfaceData@Ogre@@QAE@ABV01@@Z		; Ogre::SurfaceData::SurfaceData
PUBLIC	??_R4SurfaceData@Ogre@@6B@			; Ogre::SurfaceData::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVSurfaceData@Ogre@@@8			; Ogre::SurfaceData `RTTI Type Descriptor'
PUBLIC	??_R3SurfaceData@Ogre@@8			; Ogre::SurfaceData::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2SurfaceData@Ogre@@8			; Ogre::SurfaceData::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@SurfaceData@Ogre@@8		; Ogre::SurfaceData::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_ESurfaceData@Ogre@@UAEPAXI@Z			; Ogre::SurfaceData::`vector deleting destructor'
EXTRN	?_serialize@SurfaceData@Ogre@@EAEXAAVArchive@2@H@Z:PROC ; Ogre::SurfaceData::_serialize
;	COMDAT ??_R1A@?0A@EA@SurfaceData@Ogre@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@SurfaceData@Ogre@@8 DD FLAT:??_R0?AVSurfaceData@Ogre@@@8 ; Ogre::SurfaceData::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3SurfaceData@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R2SurfaceData@Ogre@@8
rdata$r	SEGMENT
??_R2SurfaceData@Ogre@@8 DD FLAT:??_R1A@?0A@EA@SurfaceData@Ogre@@8 ; Ogre::SurfaceData::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@BaseObject@Ogre@@8
	DD	FLAT:??_R13?0A@EA@MemoryDelegation@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R3SurfaceData@Ogre@@8
rdata$r	SEGMENT
??_R3SurfaceData@Ogre@@8 DD 00H				; Ogre::SurfaceData::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2SurfaceData@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVSurfaceData@Ogre@@@8
_DATA	SEGMENT
??_R0?AVSurfaceData@Ogre@@@8 DD FLAT:??_7type_info@@6B@	; Ogre::SurfaceData `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVSurfaceData@Ogre@@', 00H
_DATA	ENDS
;	COMDAT ??_R4SurfaceData@Ogre@@6B@
rdata$r	SEGMENT
??_R4SurfaceData@Ogre@@6B@ DD 00H			; Ogre::SurfaceData::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVSurfaceData@Ogre@@@8
	DD	FLAT:??_R3SurfaceData@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_7SurfaceData@Ogre@@6B@
CONST	SEGMENT
??_7SurfaceData@Ogre@@6B@ DD FLAT:??_R4SurfaceData@Ogre@@6B@ ; Ogre::SurfaceData::`vftable'
	DD	FLAT:?getRTTI@SurfaceData@Ogre@@UBEPBVRuntimeClass@2@XZ
	DD	FLAT:?release@BaseObject@Ogre@@UAEXXZ
	DD	FLAT:?addRef@BaseObject@Ogre@@UAEXXZ
	DD	FLAT:?getRefCount@BaseObject@Ogre@@UAEHXZ
	DD	FLAT:?_serialize@SurfaceData@Ogre@@EAEXAAVArchive@2@H@Z
	DD	FLAT:??_ESurfaceData@Ogre@@UAEPAXI@Z
	DD	FLAT:?deleteThis@BaseObject@Ogre@@MAEXXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0SurfaceData@Ogre@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0SurfaceData@Ogre@@QAE@ABV01@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0SurfaceData@Ogre@@QAE@ABV01@@Z$1
__ehfuncinfo$??0SurfaceData@Ogre@@QAE@ABV01@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0SurfaceData@Ogre@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0SurfaceData@Ogre@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0SurfaceData@Ogre@@QAE@ABV01@@Z PROC			; Ogre::SurfaceData::SurfaceData, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0SurfaceData@Ogre@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0BaseObject@Ogre@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7SurfaceData@Ogre@@6B@
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [edx+12], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR [edx+16], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR [edx+20], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR [edx+24], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	DWORD PTR [edx+28], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	DWORD PTR [edx+32], ecx
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 36					; 00000024H
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??0?$vector@DV?$allocator@D@std@@@std@@QAE@ABV01@@Z ; std::vector<char,std::allocator<char> >::vector<char,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0SurfaceData@Ogre@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1BaseObject@Ogre@@MAE@XZ		; Ogre::BaseObject::~BaseObject
__unwindfunclet$??0SurfaceData@Ogre@@QAE@ABV01@@Z$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	jmp	??1?$vector@DV?$allocator@D@std@@@std@@QAE@XZ ; std::vector<char,std::allocator<char> >::~vector<char,std::allocator<char> >
__ehhandler$??0SurfaceData@Ogre@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0SurfaceData@Ogre@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0SurfaceData@Ogre@@QAE@ABV01@@Z ENDP			; Ogre::SurfaceData::SurfaceData
PUBLIC	??4?$vector@DV?$allocator@D@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<char,std::allocator<char> >::operator=
PUBLIC	??4SurfaceData@Ogre@@QAEAAV01@ABV01@@Z		; Ogre::SurfaceData::operator=
; Function compile flags: /Odtp
;	COMDAT ??4SurfaceData@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4SurfaceData@Ogre@@QAEAAV01@ABV01@@Z PROC		; Ogre::SurfaceData::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4BaseObject@Ogre@@QAEAAV01@ABV01@@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+8], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR [ecx+12], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR [ecx+16], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	DWORD PTR [ecx+20], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR [ecx+24], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+28]
	mov	DWORD PTR [ecx+28], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	DWORD PTR [ecx+32], eax
	mov	ecx, DWORD PTR ___that$[ebp]
	add	ecx, 36					; 00000024H
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??4?$vector@DV?$allocator@D@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<char,std::allocator<char> >::operator=
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4SurfaceData@Ogre@@QAEAAV01@ABV01@@Z ENDP		; Ogre::SurfaceData::operator=
_TEXT	ENDS
PUBLIC	??_GSurfaceData@Ogre@@UAEPAXI@Z			; Ogre::SurfaceData::`scalar deleting destructor'
; Function compile flags: /Odtp
;	COMDAT ??_GSurfaceData@Ogre@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GSurfaceData@Ogre@@UAEPAXI@Z PROC			; Ogre::SurfaceData::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1SurfaceData@Ogre@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@11
	push	60					; 0000003cH
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3MemoryDelegation@Ogre@@SAXPAXI@Z	; Ogre::MemoryDelegation::operator delete
	add	esp, 8
$LN1@scalar@11:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GSurfaceData@Ogre@@UAEPAXI@Z ENDP			; Ogre::SurfaceData::`scalar deleting destructor'
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_ESurfaceData@Ogre@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_ESurfaceData@Ogre@@UAEPAXI@Z PROC			; Ogre::SurfaceData::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 2
	je	SHORT $LN3@vector@11
	push	OFFSET ??1SurfaceData@Ogre@@UAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx-4]
	push	edx
	push	60					; 0000003cH
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??_M@YGXPAXIHP6EX0@Z@Z
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN2@vector@11
	push	60					; 0000003cH
	mov	edx, DWORD PTR _this$[ebp]
	sub	edx, 4
	push	edx
	call	??_VMemoryDelegation@Ogre@@SAXPAXI@Z	; Ogre::MemoryDelegation::operator delete[]
	add	esp, 8
$LN2@vector@11:
	mov	eax, DWORD PTR _this$[ebp]
	sub	eax, 4
	jmp	SHORT $LN4@vector@11
$LN3@vector@11:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1SurfaceData@Ogre@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@vector@11
	push	60					; 0000003cH
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3MemoryDelegation@Ogre@@SAXPAXI@Z	; Ogre::MemoryDelegation::operator delete
	add	esp, 8
$LN1@vector@11:
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector@11:
	mov	esp, ebp
	pop	ebp
	ret	4
??_ESurfaceData@Ogre@@UAEPAXI@Z ENDP			; Ogre::SurfaceData::`vector deleting destructor'
_TEXT	ENDS
PUBLIC	?getRTTI@DummyTexture@Ogre@@UBEPBVRuntimeClass@2@XZ ; Ogre::DummyTexture::getRTTI
EXTRN	?m_RTTI@DummyTexture@Ogre@@2VRuntimeClass@2@B:BYTE ; Ogre::DummyTexture::m_RTTI
; Function compile flags: /Odtp
;	COMDAT ?getRTTI@DummyTexture@Ogre@@UBEPBVRuntimeClass@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getRTTI@DummyTexture@Ogre@@UBEPBVRuntimeClass@2@XZ PROC ; Ogre::DummyTexture::getRTTI, COMDAT
; _this$ = ecx

; 64   : 		DECLARE_RTTI(DummyTexture)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, OFFSET ?m_RTTI@DummyTexture@Ogre@@2VRuntimeClass@2@B ; Ogre::DummyTexture::m_RTTI
	mov	esp, ebp
	pop	ebp
	ret	0
?getRTTI@DummyTexture@Ogre@@UBEPBVRuntimeClass@2@XZ ENDP ; Ogre::DummyTexture::getRTTI
_TEXT	ENDS
PUBLIC	??0DummyTexture@Ogre@@QAE@XZ			; Ogre::DummyTexture::DummyTexture
PUBLIC	?newObject@DummyTexture@Ogre@@SAPAVBaseObject@2@XZ ; Ogre::DummyTexture::newObject
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?newObject@DummyTexture@Ogre@@SAPAVBaseObject@2@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?newObject@DummyTexture@Ogre@@SAPAVBaseObject@2@XZ$0
__ehfuncinfo$?newObject@DummyTexture@Ogre@@SAPAVBaseObject@2@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?newObject@DummyTexture@Ogre@@SAPAVBaseObject@2@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?newObject@DummyTexture@Ogre@@SAPAVBaseObject@2@XZ
_TEXT	SEGMENT
tv75 = -24						; size = 4
$T71862 = -20						; size = 4
$T71861 = -16						; size = 4
__$EHRec$ = -12						; size = 12
?newObject@DummyTexture@Ogre@@SAPAVBaseObject@2@XZ PROC	; Ogre::DummyTexture::newObject, COMDAT

; 64   : 		DECLARE_RTTI(DummyTexture)

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?newObject@DummyTexture@Ogre@@SAPAVBaseObject@2@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 12					; 0000000cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	push	16					; 00000010H
	call	??2MemoryDelegation@Ogre@@SAPAXI@Z	; Ogre::MemoryDelegation::operator new
	add	esp, 4
	mov	DWORD PTR $T71862[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T71862[ebp], 0
	je	SHORT $LN3@newObject@2
	mov	ecx, DWORD PTR $T71862[ebp]
	call	??0DummyTexture@Ogre@@QAE@XZ
	mov	DWORD PTR tv75[ebp], eax
	jmp	SHORT $LN4@newObject@2
$LN3@newObject@2:
	mov	DWORD PTR tv75[ebp], 0
$LN4@newObject@2:
	mov	eax, DWORD PTR tv75[ebp]
	mov	DWORD PTR $T71861[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR $T71861[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?newObject@DummyTexture@Ogre@@SAPAVBaseObject@2@XZ$0:
	push	16					; 00000010H
	mov	eax, DWORD PTR $T71862[ebp]
	push	eax
	call	??3MemoryDelegation@Ogre@@SAXPAXI@Z	; Ogre::MemoryDelegation::operator delete
	add	esp, 8
	ret	0
__ehhandler$?newObject@DummyTexture@Ogre@@SAPAVBaseObject@2@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?newObject@DummyTexture@Ogre@@SAPAVBaseObject@2@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?newObject@DummyTexture@Ogre@@SAPAVBaseObject@2@XZ ENDP	; Ogre::DummyTexture::newObject
PUBLIC	?getDesc@DummyTexture@Ogre@@UAEXAAUTextureDesc@2@@Z ; Ogre::DummyTexture::getDesc
; Function compile flags: /Odtp
;	COMDAT ?getDesc@DummyTexture@Ogre@@UAEXAAUTextureDesc@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_desc$ = 8						; size = 4
?getDesc@DummyTexture@Ogre@@UAEXAAUTextureDesc@2@@Z PROC ; Ogre::DummyTexture::getDesc, COMDAT
; _this$ = ecx

; 67   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 68   : 			assert(0);
; 69   : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?getDesc@DummyTexture@Ogre@@UAEXAAUTextureDesc@2@@Z ENDP ; Ogre::DummyTexture::getDesc
_TEXT	ENDS
PUBLIC	?getHardwareTexture@DummyTexture@Ogre@@UAEPAVHardwarePixelBuffer@2@XZ ; Ogre::DummyTexture::getHardwareTexture
; Function compile flags: /Odtp
;	COMDAT ?getHardwareTexture@DummyTexture@Ogre@@UAEPAVHardwarePixelBuffer@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getHardwareTexture@DummyTexture@Ogre@@UAEPAVHardwarePixelBuffer@2@XZ PROC ; Ogre::DummyTexture::getHardwareTexture, COMDAT
; _this$ = ecx

; 72   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 73   : 			return NULL;

	xor	eax, eax

; 74   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?getHardwareTexture@DummyTexture@Ogre@@UAEPAVHardwarePixelBuffer@2@XZ ENDP ; Ogre::DummyTexture::getHardwareTexture
_TEXT	ENDS
PUBLIC	?lock@DummyTexture@Ogre@@UAEPAXII_NAAULockResult@2@@Z ; Ogre::DummyTexture::lock
; Function compile flags: /Odtp
;	COMDAT ?lock@DummyTexture@Ogre@@UAEPAXII_NAAULockResult@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_face$ = 8						; size = 4
_level$ = 12						; size = 4
_readonly$ = 16						; size = 1
_lockresult$ = 20					; size = 4
?lock@DummyTexture@Ogre@@UAEPAXII_NAAULockResult@2@@Z PROC ; Ogre::DummyTexture::lock, COMDAT
; _this$ = ecx

; 77   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 78   : 			return NULL;

	xor	eax, eax

; 79   : 		}

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?lock@DummyTexture@Ogre@@UAEPAXII_NAAULockResult@2@@Z ENDP ; Ogre::DummyTexture::lock
_TEXT	ENDS
PUBLIC	?unlock@DummyTexture@Ogre@@UAEXII@Z		; Ogre::DummyTexture::unlock
; Function compile flags: /Odtp
;	COMDAT ?unlock@DummyTexture@Ogre@@UAEXII@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_face$ = 8						; size = 4
_level$ = 12						; size = 4
?unlock@DummyTexture@Ogre@@UAEXII@Z PROC		; Ogre::DummyTexture::unlock, COMDAT
; _this$ = ecx

; 82   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 83   : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?unlock@DummyTexture@Ogre@@UAEXII@Z ENDP		; Ogre::DummyTexture::unlock
_TEXT	ENDS
PUBLIC	??_7DummyTexture@Ogre@@6B@			; Ogre::DummyTexture::`vftable'
PUBLIC	??1DummyTexture@Ogre@@EAE@XZ			; Ogre::DummyTexture::~DummyTexture
PUBLIC	??_R4DummyTexture@Ogre@@6B@			; Ogre::DummyTexture::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVDummyTexture@Ogre@@@8			; Ogre::DummyTexture `RTTI Type Descriptor'
PUBLIC	??_R3DummyTexture@Ogre@@8			; Ogre::DummyTexture::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2DummyTexture@Ogre@@8			; Ogre::DummyTexture::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@DummyTexture@Ogre@@8		; Ogre::DummyTexture::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_EDummyTexture@Ogre@@EAEPAXI@Z		; Ogre::DummyTexture::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@DummyTexture@Ogre@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@DummyTexture@Ogre@@8 DD FLAT:??_R0?AVDummyTexture@Ogre@@@8 ; Ogre::DummyTexture::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	04H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3DummyTexture@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R2DummyTexture@Ogre@@8
rdata$r	SEGMENT
??_R2DummyTexture@Ogre@@8 DD FLAT:??_R1A@?0A@EA@DummyTexture@Ogre@@8 ; Ogre::DummyTexture::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@Texture@Ogre@@8
	DD	FLAT:??_R1A@?0A@EA@Resource@Ogre@@8
	DD	FLAT:??_R1A@?0A@EA@BaseObject@Ogre@@8
	DD	FLAT:??_R13?0A@EA@MemoryDelegation@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R3DummyTexture@Ogre@@8
rdata$r	SEGMENT
??_R3DummyTexture@Ogre@@8 DD 00H			; Ogre::DummyTexture::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	05H
	DD	FLAT:??_R2DummyTexture@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVDummyTexture@Ogre@@@8
_DATA	SEGMENT
??_R0?AVDummyTexture@Ogre@@@8 DD FLAT:??_7type_info@@6B@ ; Ogre::DummyTexture `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVDummyTexture@Ogre@@', 00H
_DATA	ENDS
;	COMDAT ??_R4DummyTexture@Ogre@@6B@
rdata$r	SEGMENT
??_R4DummyTexture@Ogre@@6B@ DD 00H			; Ogre::DummyTexture::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVDummyTexture@Ogre@@@8
	DD	FLAT:??_R3DummyTexture@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_7DummyTexture@Ogre@@6B@
CONST	SEGMENT
??_7DummyTexture@Ogre@@6B@ DD FLAT:??_R4DummyTexture@Ogre@@6B@ ; Ogre::DummyTexture::`vftable'
	DD	FLAT:?getRTTI@DummyTexture@Ogre@@UBEPBVRuntimeClass@2@XZ
	DD	FLAT:?release@Resource@Ogre@@UAEXXZ
	DD	FLAT:?addRef@Resource@Ogre@@UAEXXZ
	DD	FLAT:?getRefCount@Resource@Ogre@@UAEHXZ
	DD	FLAT:?_serialize@BaseObject@Ogre@@UAEXAAVArchive@2@H@Z
	DD	FLAT:??_EDummyTexture@Ogre@@EAEPAXI@Z
	DD	FLAT:?deleteThis@BaseObject@Ogre@@MAEXXZ
	DD	FLAT:?getDesc@DummyTexture@Ogre@@UAEXAAUTextureDesc@2@@Z
	DD	FLAT:?getHardwareTexture@DummyTexture@Ogre@@UAEPAVHardwarePixelBuffer@2@XZ
	DD	FLAT:?lock@DummyTexture@Ogre@@UAEPAXII_NAAULockResult@2@@Z
	DD	FLAT:?unlock@DummyTexture@Ogre@@UAEXII@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1DummyTexture@Ogre@@EAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1DummyTexture@Ogre@@EAE@XZ$0
__ehfuncinfo$??1DummyTexture@Ogre@@EAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1DummyTexture@Ogre@@EAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1DummyTexture@Ogre@@EAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1DummyTexture@Ogre@@EAE@XZ PROC			; Ogre::DummyTexture::~DummyTexture, COMDAT
; _this$ = ecx

; 87   : 		{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1DummyTexture@Ogre@@EAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7DummyTexture@Ogre@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 88   : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1Texture@Ogre@@MAE@XZ			; Ogre::Texture::~Texture
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1DummyTexture@Ogre@@EAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1Texture@Ogre@@MAE@XZ			; Ogre::Texture::~Texture
__ehhandler$??1DummyTexture@Ogre@@EAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1DummyTexture@Ogre@@EAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1DummyTexture@Ogre@@EAE@XZ ENDP			; Ogre::DummyTexture::~DummyTexture
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0DummyTexture@Ogre@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0DummyTexture@Ogre@@QAE@XZ$0
__ehfuncinfo$??0DummyTexture@Ogre@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0DummyTexture@Ogre@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0DummyTexture@Ogre@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0DummyTexture@Ogre@@QAE@XZ PROC			; Ogre::DummyTexture::DummyTexture, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0DummyTexture@Ogre@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0Texture@Ogre@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7DummyTexture@Ogre@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0DummyTexture@Ogre@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1Texture@Ogre@@MAE@XZ			; Ogre::Texture::~Texture
__ehhandler$??0DummyTexture@Ogre@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0DummyTexture@Ogre@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0DummyTexture@Ogre@@QAE@XZ ENDP			; Ogre::DummyTexture::DummyTexture
PUBLIC	??0DummyTexture@Ogre@@QAE@ABV01@@Z		; Ogre::DummyTexture::DummyTexture
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0DummyTexture@Ogre@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0DummyTexture@Ogre@@QAE@ABV01@@Z$0
__ehfuncinfo$??0DummyTexture@Ogre@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0DummyTexture@Ogre@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0DummyTexture@Ogre@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0DummyTexture@Ogre@@QAE@ABV01@@Z PROC			; Ogre::DummyTexture::DummyTexture, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0DummyTexture@Ogre@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0Texture@Ogre@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7DummyTexture@Ogre@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0DummyTexture@Ogre@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1Texture@Ogre@@MAE@XZ			; Ogre::Texture::~Texture
__ehhandler$??0DummyTexture@Ogre@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0DummyTexture@Ogre@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0DummyTexture@Ogre@@QAE@ABV01@@Z ENDP			; Ogre::DummyTexture::DummyTexture
PUBLIC	??4DummyTexture@Ogre@@QAEAAV01@ABV01@@Z		; Ogre::DummyTexture::operator=
; Function compile flags: /Odtp
;	COMDAT ??4DummyTexture@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4DummyTexture@Ogre@@QAEAAV01@ABV01@@Z PROC		; Ogre::DummyTexture::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4Texture@Ogre@@QAEAAV01@ABV01@@Z
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4DummyTexture@Ogre@@QAEAAV01@ABV01@@Z ENDP		; Ogre::DummyTexture::operator=
_TEXT	ENDS
PUBLIC	??_GDummyTexture@Ogre@@EAEPAXI@Z		; Ogre::DummyTexture::`scalar deleting destructor'
; Function compile flags: /Odtp
;	COMDAT ??_GDummyTexture@Ogre@@EAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GDummyTexture@Ogre@@EAEPAXI@Z PROC			; Ogre::DummyTexture::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1DummyTexture@Ogre@@EAE@XZ		; Ogre::DummyTexture::~DummyTexture
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@12
	push	16					; 00000010H
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3MemoryDelegation@Ogre@@SAXPAXI@Z	; Ogre::MemoryDelegation::operator delete
	add	esp, 8
$LN1@scalar@12:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GDummyTexture@Ogre@@EAEPAXI@Z ENDP			; Ogre::DummyTexture::`scalar deleting destructor'
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_EDummyTexture@Ogre@@EAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_EDummyTexture@Ogre@@EAEPAXI@Z PROC			; Ogre::DummyTexture::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 2
	je	SHORT $LN3@vector@12
	push	OFFSET ??1DummyTexture@Ogre@@EAE@XZ	; Ogre::DummyTexture::~DummyTexture
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx-4]
	push	edx
	push	16					; 00000010H
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??_M@YGXPAXIHP6EX0@Z@Z
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN2@vector@12
	push	16					; 00000010H
	mov	edx, DWORD PTR _this$[ebp]
	sub	edx, 4
	push	edx
	call	??_VMemoryDelegation@Ogre@@SAXPAXI@Z	; Ogre::MemoryDelegation::operator delete[]
	add	esp, 8
$LN2@vector@12:
	mov	eax, DWORD PTR _this$[ebp]
	sub	eax, 4
	jmp	SHORT $LN4@vector@12
$LN3@vector@12:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1DummyTexture@Ogre@@EAE@XZ		; Ogre::DummyTexture::~DummyTexture
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@vector@12
	push	16					; 00000010H
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3MemoryDelegation@Ogre@@SAXPAXI@Z	; Ogre::MemoryDelegation::operator delete
	add	esp, 8
$LN1@vector@12:
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector@12:
	mov	esp, ebp
	pop	ebp
	ret	4
??_EDummyTexture@Ogre@@EAEPAXI@Z ENDP			; Ogre::DummyTexture::`vector deleting destructor'
_TEXT	ENDS
PUBLIC	?getRTTI@TextureData@Ogre@@UBEPBVRuntimeClass@2@XZ ; Ogre::TextureData::getRTTI
EXTRN	?m_RTTI@TextureData@Ogre@@2VRuntimeClass@2@B:BYTE ; Ogre::TextureData::m_RTTI
; Function compile flags: /Odtp
;	COMDAT ?getRTTI@TextureData@Ogre@@UBEPBVRuntimeClass@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getRTTI@TextureData@Ogre@@UBEPBVRuntimeClass@2@XZ PROC	; Ogre::TextureData::getRTTI, COMDAT
; _this$ = ecx

; 93   : 		DECLARE_RTTI(TextureData)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, OFFSET ?m_RTTI@TextureData@Ogre@@2VRuntimeClass@2@B ; Ogre::TextureData::m_RTTI
	mov	esp, ebp
	pop	ebp
	ret	0
?getRTTI@TextureData@Ogre@@UBEPBVRuntimeClass@2@XZ ENDP	; Ogre::TextureData::getRTTI
_TEXT	ENDS
PUBLIC	?newObject@TextureData@Ogre@@SAPAVBaseObject@2@XZ ; Ogre::TextureData::newObject
EXTRN	??0TextureData@Ogre@@QAE@XZ:PROC		; Ogre::TextureData::TextureData
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?newObject@TextureData@Ogre@@SAPAVBaseObject@2@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?newObject@TextureData@Ogre@@SAPAVBaseObject@2@XZ$0
__ehfuncinfo$?newObject@TextureData@Ogre@@SAPAVBaseObject@2@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?newObject@TextureData@Ogre@@SAPAVBaseObject@2@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?newObject@TextureData@Ogre@@SAPAVBaseObject@2@XZ
_TEXT	SEGMENT
tv75 = -24						; size = 4
$T71918 = -20						; size = 4
$T71917 = -16						; size = 4
__$EHRec$ = -12						; size = 12
?newObject@TextureData@Ogre@@SAPAVBaseObject@2@XZ PROC	; Ogre::TextureData::newObject, COMDAT

; 93   : 		DECLARE_RTTI(TextureData)

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?newObject@TextureData@Ogre@@SAPAVBaseObject@2@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 12					; 0000000cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	push	108					; 0000006cH
	call	??2MemoryDelegation@Ogre@@SAPAXI@Z	; Ogre::MemoryDelegation::operator new
	add	esp, 4
	mov	DWORD PTR $T71918[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T71918[ebp], 0
	je	SHORT $LN3@newObject@3
	mov	ecx, DWORD PTR $T71918[ebp]
	call	??0TextureData@Ogre@@QAE@XZ		; Ogre::TextureData::TextureData
	mov	DWORD PTR tv75[ebp], eax
	jmp	SHORT $LN4@newObject@3
$LN3@newObject@3:
	mov	DWORD PTR tv75[ebp], 0
$LN4@newObject@3:
	mov	eax, DWORD PTR tv75[ebp]
	mov	DWORD PTR $T71917[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR $T71917[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?newObject@TextureData@Ogre@@SAPAVBaseObject@2@XZ$0:
	push	108					; 0000006cH
	mov	eax, DWORD PTR $T71918[ebp]
	push	eax
	call	??3MemoryDelegation@Ogre@@SAXPAXI@Z	; Ogre::MemoryDelegation::operator delete
	add	esp, 8
	ret	0
__ehhandler$?newObject@TextureData@Ogre@@SAPAVBaseObject@2@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?newObject@TextureData@Ogre@@SAPAVBaseObject@2@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?newObject@TextureData@Ogre@@SAPAVBaseObject@2@XZ ENDP	; Ogre::TextureData::newObject
PUBLIC	?getDesc@TextureData@Ogre@@UAEXAAUTextureDesc@2@@Z ; Ogre::TextureData::getDesc
; Function compile flags: /Odtp
;	COMDAT ?getDesc@TextureData@Ogre@@UAEXAAUTextureDesc@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_desc$ = 8						; size = 4
?getDesc@TextureData@Ogre@@UAEXAAUTextureDesc@2@@Z PROC	; Ogre::TextureData::getDesc, COMDAT
; _this$ = ecx

; 107  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 108  : 			desc = m_Desc;

	mov	esi, DWORD PTR _this$[ebp]
	add	esi, 16					; 00000010H
	mov	ecx, 7
	mov	edi, DWORD PTR _desc$[ebp]
	rep movsd

; 109  : 		}

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?getDesc@TextureData@Ogre@@UAEXAAUTextureDesc@2@@Z ENDP	; Ogre::TextureData::getDesc
_TEXT	ENDS
PUBLIC	?getWidth@TextureData@Ogre@@QAEIXZ		; Ogre::TextureData::getWidth
; Function compile flags: /Odtp
;	COMDAT ?getWidth@TextureData@Ogre@@QAEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getWidth@TextureData@Ogre@@QAEIXZ PROC			; Ogre::TextureData::getWidth, COMDAT
; _this$ = ecx

; 112  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 113  : 			return m_Desc.width;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+20]

; 114  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?getWidth@TextureData@Ogre@@QAEIXZ ENDP			; Ogre::TextureData::getWidth
_TEXT	ENDS
PUBLIC	?getHeight@TextureData@Ogre@@QAEIXZ		; Ogre::TextureData::getHeight
; Function compile flags: /Odtp
;	COMDAT ?getHeight@TextureData@Ogre@@QAEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getHeight@TextureData@Ogre@@QAEIXZ PROC		; Ogre::TextureData::getHeight, COMDAT
; _this$ = ecx

; 117  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 118  : 			return m_Desc.height;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+24]

; 119  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?getHeight@TextureData@Ogre@@QAEIXZ ENDP		; Ogre::TextureData::getHeight
_TEXT	ENDS
PUBLIC	?getFormat@TextureData@Ogre@@QAE?AW4PixelFormat@2@XZ ; Ogre::TextureData::getFormat
; Function compile flags: /Odtp
;	COMDAT ?getFormat@TextureData@Ogre@@QAE?AW4PixelFormat@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getFormat@TextureData@Ogre@@QAE?AW4PixelFormat@2@XZ PROC ; Ogre::TextureData::getFormat, COMDAT
; _this$ = ecx

; 122  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 123  : 			return m_Desc.format;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+36]

; 124  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?getFormat@TextureData@Ogre@@QAE?AW4PixelFormat@2@XZ ENDP ; Ogre::TextureData::getFormat
_TEXT	ENDS
PUBLIC	?setStatic@TextureData@Ogre@@QAEX_N@Z		; Ogre::TextureData::setStatic
; Function compile flags: /Odtp
;	COMDAT ?setStatic@TextureData@Ogre@@QAEX_N@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_is_static$ = 8						; size = 1
?setStatic@TextureData@Ogre@@QAEX_N@Z PROC		; Ogre::TextureData::setStatic, COMDAT
; _this$ = ecx

; 142  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 143  : 			m_isStatic = is_static;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR _is_static$[ebp]
	mov	BYTE PTR [eax+76], cl

; 144  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?setStatic@TextureData@Ogre@@QAEX_N@Z ENDP		; Ogre::TextureData::setStatic
_TEXT	ENDS
PUBLIC	??1?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::~vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >
PUBLIC	??0?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE@ABV01@@Z ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >
PUBLIC	??_7TextureData@Ogre@@6B@			; Ogre::TextureData::`vftable'
PUBLIC	??0TextureData@Ogre@@QAE@ABV01@@Z		; Ogre::TextureData::TextureData
PUBLIC	??_R4TextureData@Ogre@@6B@			; Ogre::TextureData::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVTextureData@Ogre@@@8			; Ogre::TextureData `RTTI Type Descriptor'
PUBLIC	??_R3TextureData@Ogre@@8			; Ogre::TextureData::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2TextureData@Ogre@@8			; Ogre::TextureData::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@TextureData@Ogre@@8		; Ogre::TextureData::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_ETextureData@Ogre@@MAEPAXI@Z			; Ogre::TextureData::`vector deleting destructor'
EXTRN	__imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:PROC
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z:PROC
EXTRN	?_serialize@TextureData@Ogre@@EAEXAAVArchive@2@H@Z:PROC ; Ogre::TextureData::_serialize
EXTRN	?getHardwareTexture@TextureData@Ogre@@UAEPAVHardwarePixelBuffer@2@XZ:PROC ; Ogre::TextureData::getHardwareTexture
EXTRN	?lock@TextureData@Ogre@@UAEPAXII_NAAULockResult@2@@Z:PROC ; Ogre::TextureData::lock
EXTRN	?unlock@TextureData@Ogre@@UAEXII@Z:PROC		; Ogre::TextureData::unlock
;	COMDAT ??_R1A@?0A@EA@TextureData@Ogre@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@TextureData@Ogre@@8 DD FLAT:??_R0?AVTextureData@Ogre@@@8 ; Ogre::TextureData::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	04H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3TextureData@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R2TextureData@Ogre@@8
rdata$r	SEGMENT
??_R2TextureData@Ogre@@8 DD FLAT:??_R1A@?0A@EA@TextureData@Ogre@@8 ; Ogre::TextureData::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@Texture@Ogre@@8
	DD	FLAT:??_R1A@?0A@EA@Resource@Ogre@@8
	DD	FLAT:??_R1A@?0A@EA@BaseObject@Ogre@@8
	DD	FLAT:??_R13?0A@EA@MemoryDelegation@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R3TextureData@Ogre@@8
rdata$r	SEGMENT
??_R3TextureData@Ogre@@8 DD 00H				; Ogre::TextureData::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	05H
	DD	FLAT:??_R2TextureData@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVTextureData@Ogre@@@8
_DATA	SEGMENT
??_R0?AVTextureData@Ogre@@@8 DD FLAT:??_7type_info@@6B@	; Ogre::TextureData `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVTextureData@Ogre@@', 00H
_DATA	ENDS
;	COMDAT ??_R4TextureData@Ogre@@6B@
rdata$r	SEGMENT
??_R4TextureData@Ogre@@6B@ DD 00H			; Ogre::TextureData::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVTextureData@Ogre@@@8
	DD	FLAT:??_R3TextureData@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_7TextureData@Ogre@@6B@
CONST	SEGMENT
??_7TextureData@Ogre@@6B@ DD FLAT:??_R4TextureData@Ogre@@6B@ ; Ogre::TextureData::`vftable'
	DD	FLAT:?getRTTI@TextureData@Ogre@@UBEPBVRuntimeClass@2@XZ
	DD	FLAT:?release@Resource@Ogre@@UAEXXZ
	DD	FLAT:?addRef@Resource@Ogre@@UAEXXZ
	DD	FLAT:?getRefCount@Resource@Ogre@@UAEHXZ
	DD	FLAT:?_serialize@TextureData@Ogre@@EAEXAAVArchive@2@H@Z
	DD	FLAT:??_ETextureData@Ogre@@MAEPAXI@Z
	DD	FLAT:?deleteThis@BaseObject@Ogre@@MAEXXZ
	DD	FLAT:?getDesc@TextureData@Ogre@@UAEXAAUTextureDesc@2@@Z
	DD	FLAT:?getHardwareTexture@TextureData@Ogre@@UAEPAVHardwarePixelBuffer@2@XZ
	DD	FLAT:?lock@TextureData@Ogre@@UAEPAXII_NAAULockResult@2@@Z
	DD	FLAT:?unlock@TextureData@Ogre@@UAEXII@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0TextureData@Ogre@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0TextureData@Ogre@@QAE@ABV01@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0TextureData@Ogre@@QAE@ABV01@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0TextureData@Ogre@@QAE@ABV01@@Z$2
__ehfuncinfo$??0TextureData@Ogre@@QAE@ABV01@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0TextureData@Ogre@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0TextureData@Ogre@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0TextureData@Ogre@@QAE@ABV01@@Z PROC			; Ogre::TextureData::TextureData, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0TextureData@Ogre@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0Texture@Ogre@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7TextureData@Ogre@@6B@
	mov	esi, DWORD PTR ___that$[ebp]
	add	esi, 16					; 00000010H
	mov	edi, DWORD PTR _this$[ebp]
	add	edi, 16					; 00000010H
	mov	ecx, 7
	rep movsd
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 44					; 0000002cH
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 44					; 0000002cH
	call	??0?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE@ABV01@@Z ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+68]
	mov	DWORD PTR [eax+68], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+72]
	mov	DWORD PTR [eax+72], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	dl, BYTE PTR [ecx+76]
	mov	BYTE PTR [eax+76], dl
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 80					; 00000050H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 80					; 00000050H
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0TextureData@Ogre@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1Texture@Ogre@@MAE@XZ			; Ogre::Texture::~Texture
__unwindfunclet$??0TextureData@Ogre@@QAE@ABV01@@Z$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 44					; 0000002cH
	jmp	??1?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::~vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >
__unwindfunclet$??0TextureData@Ogre@@QAE@ABV01@@Z$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 80					; 00000050H
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$??0TextureData@Ogre@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0TextureData@Ogre@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0TextureData@Ogre@@QAE@ABV01@@Z ENDP			; Ogre::TextureData::TextureData
PUBLIC	??4?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::operator=
PUBLIC	??4TextureData@Ogre@@QAEAAV01@ABV01@@Z		; Ogre::TextureData::operator=
EXTRN	__imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z:PROC
; Function compile flags: /Odtp
;	COMDAT ??4TextureData@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4TextureData@Ogre@@QAEAAV01@ABV01@@Z PROC		; Ogre::TextureData::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4Texture@Ogre@@QAEAAV01@ABV01@@Z
	mov	esi, DWORD PTR ___that$[ebp]
	add	esi, 16					; 00000010H
	mov	edi, DWORD PTR _this$[ebp]
	add	edi, 16					; 00000010H
	mov	ecx, 7
	rep movsd
	mov	ecx, DWORD PTR ___that$[ebp]
	add	ecx, 44					; 0000002cH
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 44					; 0000002cH
	call	??4?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::operator=
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+68]
	mov	DWORD PTR [edx+68], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	mov	DWORD PTR [edx+72], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	cl, BYTE PTR [eax+76]
	mov	BYTE PTR [edx+76], cl
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 80					; 00000050H
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 80					; 00000050H
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
??4TextureData@Ogre@@QAEAAV01@ABV01@@Z ENDP		; Ogre::TextureData::operator=
_TEXT	ENDS
PUBLIC	??_GTextureData@Ogre@@MAEPAXI@Z			; Ogre::TextureData::`scalar deleting destructor'
EXTRN	??1TextureData@Ogre@@MAE@XZ:PROC		; Ogre::TextureData::~TextureData
; Function compile flags: /Odtp
;	COMDAT ??_GTextureData@Ogre@@MAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GTextureData@Ogre@@MAEPAXI@Z PROC			; Ogre::TextureData::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1TextureData@Ogre@@MAE@XZ		; Ogre::TextureData::~TextureData
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@13
	push	108					; 0000006cH
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3MemoryDelegation@Ogre@@SAXPAXI@Z	; Ogre::MemoryDelegation::operator delete
	add	esp, 8
$LN1@scalar@13:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GTextureData@Ogre@@MAEPAXI@Z ENDP			; Ogre::TextureData::`scalar deleting destructor'
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_ETextureData@Ogre@@MAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_ETextureData@Ogre@@MAEPAXI@Z PROC			; Ogre::TextureData::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 2
	je	SHORT $LN3@vector@13
	push	OFFSET ??1TextureData@Ogre@@MAE@XZ	; Ogre::TextureData::~TextureData
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx-4]
	push	edx
	push	108					; 0000006cH
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??_M@YGXPAXIHP6EX0@Z@Z
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN2@vector@13
	push	108					; 0000006cH
	mov	edx, DWORD PTR _this$[ebp]
	sub	edx, 4
	push	edx
	call	??_VMemoryDelegation@Ogre@@SAXPAXI@Z	; Ogre::MemoryDelegation::operator delete[]
	add	esp, 8
$LN2@vector@13:
	mov	eax, DWORD PTR _this$[ebp]
	sub	eax, 4
	jmp	SHORT $LN4@vector@13
$LN3@vector@13:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1TextureData@Ogre@@MAE@XZ		; Ogre::TextureData::~TextureData
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@vector@13
	push	108					; 0000006cH
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3MemoryDelegation@Ogre@@SAXPAXI@Z	; Ogre::MemoryDelegation::operator delete
	add	esp, 8
$LN1@vector@13:
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector@13:
	mov	esp, ebp
	pop	ebp
	ret	4
??_ETextureData@Ogre@@MAEPAXI@Z ENDP			; Ogre::TextureData::`vector deleting destructor'
_TEXT	ENDS
PUBLIC	?getRTTI@RT_TEXTURE@Ogre@@UBEPBVRuntimeClass@2@XZ ; Ogre::RT_TEXTURE::getRTTI
EXTRN	?m_RTTI@RT_TEXTURE@Ogre@@2VRuntimeClass@2@B:BYTE ; Ogre::RT_TEXTURE::m_RTTI
; Function compile flags: /Odtp
;	COMDAT ?getRTTI@RT_TEXTURE@Ogre@@UBEPBVRuntimeClass@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getRTTI@RT_TEXTURE@Ogre@@UBEPBVRuntimeClass@2@XZ PROC	; Ogre::RT_TEXTURE::getRTTI, COMDAT
; _this$ = ecx

; 179  : 		DECLARE_RTTI(RT_TEXTURE)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, OFFSET ?m_RTTI@RT_TEXTURE@Ogre@@2VRuntimeClass@2@B ; Ogre::RT_TEXTURE::m_RTTI
	mov	esp, ebp
	pop	ebp
	ret	0
?getRTTI@RT_TEXTURE@Ogre@@UBEPBVRuntimeClass@2@XZ ENDP	; Ogre::RT_TEXTURE::getRTTI
_TEXT	ENDS
PUBLIC	??0RT_TEXTURE@Ogre@@QAE@XZ			; Ogre::RT_TEXTURE::RT_TEXTURE
PUBLIC	?newObject@RT_TEXTURE@Ogre@@SAPAVBaseObject@2@XZ ; Ogre::RT_TEXTURE::newObject
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?newObject@RT_TEXTURE@Ogre@@SAPAVBaseObject@2@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?newObject@RT_TEXTURE@Ogre@@SAPAVBaseObject@2@XZ$0
__ehfuncinfo$?newObject@RT_TEXTURE@Ogre@@SAPAVBaseObject@2@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?newObject@RT_TEXTURE@Ogre@@SAPAVBaseObject@2@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?newObject@RT_TEXTURE@Ogre@@SAPAVBaseObject@2@XZ
_TEXT	SEGMENT
tv75 = -24						; size = 4
$T71960 = -20						; size = 4
$T71959 = -16						; size = 4
__$EHRec$ = -12						; size = 12
?newObject@RT_TEXTURE@Ogre@@SAPAVBaseObject@2@XZ PROC	; Ogre::RT_TEXTURE::newObject, COMDAT

; 179  : 		DECLARE_RTTI(RT_TEXTURE)

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?newObject@RT_TEXTURE@Ogre@@SAPAVBaseObject@2@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 12					; 0000000cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	push	48					; 00000030H
	call	??2MemoryDelegation@Ogre@@SAPAXI@Z	; Ogre::MemoryDelegation::operator new
	add	esp, 4
	mov	DWORD PTR $T71960[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T71960[ebp], 0
	je	SHORT $LN3@newObject@4
	mov	ecx, DWORD PTR $T71960[ebp]
	call	??0RT_TEXTURE@Ogre@@QAE@XZ		; Ogre::RT_TEXTURE::RT_TEXTURE
	mov	DWORD PTR tv75[ebp], eax
	jmp	SHORT $LN4@newObject@4
$LN3@newObject@4:
	mov	DWORD PTR tv75[ebp], 0
$LN4@newObject@4:
	mov	eax, DWORD PTR tv75[ebp]
	mov	DWORD PTR $T71959[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR $T71959[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?newObject@RT_TEXTURE@Ogre@@SAPAVBaseObject@2@XZ$0:
	push	48					; 00000030H
	mov	eax, DWORD PTR $T71960[ebp]
	push	eax
	call	??3MemoryDelegation@Ogre@@SAXPAXI@Z	; Ogre::MemoryDelegation::operator delete
	add	esp, 8
	ret	0
__ehhandler$?newObject@RT_TEXTURE@Ogre@@SAPAVBaseObject@2@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?newObject@RT_TEXTURE@Ogre@@SAPAVBaseObject@2@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?newObject@RT_TEXTURE@Ogre@@SAPAVBaseObject@2@XZ ENDP	; Ogre::RT_TEXTURE::newObject
PUBLIC	??_7RT_TEXTURE@Ogre@@6B@			; Ogre::RT_TEXTURE::`vftable'
PUBLIC	??_R4RT_TEXTURE@Ogre@@6B@			; Ogre::RT_TEXTURE::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVRT_TEXTURE@Ogre@@@8			; Ogre::RT_TEXTURE `RTTI Type Descriptor'
PUBLIC	??_R3RT_TEXTURE@Ogre@@8				; Ogre::RT_TEXTURE::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2RT_TEXTURE@Ogre@@8				; Ogre::RT_TEXTURE::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@RT_TEXTURE@Ogre@@8		; Ogre::RT_TEXTURE::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_ERT_TEXTURE@Ogre@@MAEPAXI@Z			; Ogre::RT_TEXTURE::`vector deleting destructor'
PUBLIC	?getDesc@RT_TEXTURE@Ogre@@UAEXAAUTextureDesc@2@@Z ; Ogre::RT_TEXTURE::getDesc
PUBLIC	?getHardwareTexture@RT_TEXTURE@Ogre@@UAEPAVHardwarePixelBuffer@2@XZ ; Ogre::RT_TEXTURE::getHardwareTexture
EXTRN	?lock@RT_TEXTURE@Ogre@@UAEPAXII_NAAULockResult@2@@Z:PROC ; Ogre::RT_TEXTURE::lock
EXTRN	?unlock@RT_TEXTURE@Ogre@@UAEXII@Z:PROC		; Ogre::RT_TEXTURE::unlock
;	COMDAT ??_R1A@?0A@EA@RT_TEXTURE@Ogre@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@RT_TEXTURE@Ogre@@8 DD FLAT:??_R0?AVRT_TEXTURE@Ogre@@@8 ; Ogre::RT_TEXTURE::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	04H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3RT_TEXTURE@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R2RT_TEXTURE@Ogre@@8
rdata$r	SEGMENT
??_R2RT_TEXTURE@Ogre@@8 DD FLAT:??_R1A@?0A@EA@RT_TEXTURE@Ogre@@8 ; Ogre::RT_TEXTURE::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@Texture@Ogre@@8
	DD	FLAT:??_R1A@?0A@EA@Resource@Ogre@@8
	DD	FLAT:??_R1A@?0A@EA@BaseObject@Ogre@@8
	DD	FLAT:??_R13?0A@EA@MemoryDelegation@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R3RT_TEXTURE@Ogre@@8
rdata$r	SEGMENT
??_R3RT_TEXTURE@Ogre@@8 DD 00H				; Ogre::RT_TEXTURE::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	05H
	DD	FLAT:??_R2RT_TEXTURE@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVRT_TEXTURE@Ogre@@@8
_DATA	SEGMENT
??_R0?AVRT_TEXTURE@Ogre@@@8 DD FLAT:??_7type_info@@6B@	; Ogre::RT_TEXTURE `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVRT_TEXTURE@Ogre@@', 00H
_DATA	ENDS
;	COMDAT ??_R4RT_TEXTURE@Ogre@@6B@
rdata$r	SEGMENT
??_R4RT_TEXTURE@Ogre@@6B@ DD 00H			; Ogre::RT_TEXTURE::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVRT_TEXTURE@Ogre@@@8
	DD	FLAT:??_R3RT_TEXTURE@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_7RT_TEXTURE@Ogre@@6B@
CONST	SEGMENT
??_7RT_TEXTURE@Ogre@@6B@ DD FLAT:??_R4RT_TEXTURE@Ogre@@6B@ ; Ogre::RT_TEXTURE::`vftable'
	DD	FLAT:?getRTTI@RT_TEXTURE@Ogre@@UBEPBVRuntimeClass@2@XZ
	DD	FLAT:?release@Resource@Ogre@@UAEXXZ
	DD	FLAT:?addRef@Resource@Ogre@@UAEXXZ
	DD	FLAT:?getRefCount@Resource@Ogre@@UAEHXZ
	DD	FLAT:?_serialize@BaseObject@Ogre@@UAEXAAVArchive@2@H@Z
	DD	FLAT:??_ERT_TEXTURE@Ogre@@MAEPAXI@Z
	DD	FLAT:?deleteThis@BaseObject@Ogre@@MAEXXZ
	DD	FLAT:?getDesc@RT_TEXTURE@Ogre@@UAEXAAUTextureDesc@2@@Z
	DD	FLAT:?getHardwareTexture@RT_TEXTURE@Ogre@@UAEPAVHardwarePixelBuffer@2@XZ
	DD	FLAT:?lock@RT_TEXTURE@Ogre@@UAEPAXII_NAAULockResult@2@@Z
	DD	FLAT:?unlock@RT_TEXTURE@Ogre@@UAEXII@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0RT_TEXTURE@Ogre@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0RT_TEXTURE@Ogre@@QAE@XZ$0
__ehfuncinfo$??0RT_TEXTURE@Ogre@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0RT_TEXTURE@Ogre@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0RT_TEXTURE@Ogre@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0RT_TEXTURE@Ogre@@QAE@XZ PROC				; Ogre::RT_TEXTURE::RT_TEXTURE, COMDAT
; _this$ = ecx

; 181  : 		RT_TEXTURE() : m_pTexture(NULL){}

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0RT_TEXTURE@Ogre@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0Texture@Ogre@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7RT_TEXTURE@Ogre@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+44], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0RT_TEXTURE@Ogre@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1Texture@Ogre@@MAE@XZ			; Ogre::Texture::~Texture
__ehhandler$??0RT_TEXTURE@Ogre@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0RT_TEXTURE@Ogre@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0RT_TEXTURE@Ogre@@QAE@XZ ENDP				; Ogre::RT_TEXTURE::RT_TEXTURE
; Function compile flags: /Odtp
;	COMDAT ?getHardwareTexture@RT_TEXTURE@Ogre@@UAEPAVHardwarePixelBuffer@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getHardwareTexture@RT_TEXTURE@Ogre@@UAEPAVHardwarePixelBuffer@2@XZ PROC ; Ogre::RT_TEXTURE::getHardwareTexture, COMDAT
; _this$ = ecx

; 184  : 		virtual HardwareTexture *getHardwareTexture(){return m_pTexture;}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+44]
	mov	esp, ebp
	pop	ebp
	ret	0
?getHardwareTexture@RT_TEXTURE@Ogre@@UAEPAVHardwarePixelBuffer@2@XZ ENDP ; Ogre::RT_TEXTURE::getHardwareTexture
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?getDesc@RT_TEXTURE@Ogre@@UAEXAAUTextureDesc@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_desc$ = 8						; size = 4
?getDesc@RT_TEXTURE@Ogre@@UAEXAAUTextureDesc@2@@Z PROC	; Ogre::RT_TEXTURE::getDesc, COMDAT
; _this$ = ecx

; 189  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 190  : 			desc = m_Desc;

	mov	esi, DWORD PTR _this$[ebp]
	add	esi, 16					; 00000010H
	mov	ecx, 7
	mov	edi, DWORD PTR _desc$[ebp]
	rep movsd

; 191  : 		}

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?getDesc@RT_TEXTURE@Ogre@@UAEXAAUTextureDesc@2@@Z ENDP	; Ogre::RT_TEXTURE::getDesc
_TEXT	ENDS
PUBLIC	??0RT_TEXTURE@Ogre@@QAE@ABV01@@Z		; Ogre::RT_TEXTURE::RT_TEXTURE
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0RT_TEXTURE@Ogre@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0RT_TEXTURE@Ogre@@QAE@ABV01@@Z$0
__ehfuncinfo$??0RT_TEXTURE@Ogre@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0RT_TEXTURE@Ogre@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0RT_TEXTURE@Ogre@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0RT_TEXTURE@Ogre@@QAE@ABV01@@Z PROC			; Ogre::RT_TEXTURE::RT_TEXTURE, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0RT_TEXTURE@Ogre@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0Texture@Ogre@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7RT_TEXTURE@Ogre@@6B@
	mov	esi, DWORD PTR ___that$[ebp]
	add	esi, 16					; 00000010H
	mov	edi, DWORD PTR _this$[ebp]
	add	edi, 16					; 00000010H
	mov	ecx, 7
	rep movsd
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	DWORD PTR [edx+44], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0RT_TEXTURE@Ogre@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1Texture@Ogre@@MAE@XZ			; Ogre::Texture::~Texture
__ehhandler$??0RT_TEXTURE@Ogre@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0RT_TEXTURE@Ogre@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0RT_TEXTURE@Ogre@@QAE@ABV01@@Z ENDP			; Ogre::RT_TEXTURE::RT_TEXTURE
PUBLIC	??4RT_TEXTURE@Ogre@@QAEAAV01@ABV01@@Z		; Ogre::RT_TEXTURE::operator=
; Function compile flags: /Odtp
;	COMDAT ??4RT_TEXTURE@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4RT_TEXTURE@Ogre@@QAEAAV01@ABV01@@Z PROC		; Ogre::RT_TEXTURE::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4Texture@Ogre@@QAEAAV01@ABV01@@Z
	mov	esi, DWORD PTR ___that$[ebp]
	add	esi, 16					; 00000010H
	mov	edi, DWORD PTR _this$[ebp]
	add	edi, 16					; 00000010H
	mov	ecx, 7
	rep movsd
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+44]
	mov	DWORD PTR [ecx+44], eax
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
??4RT_TEXTURE@Ogre@@QAEAAV01@ABV01@@Z ENDP		; Ogre::RT_TEXTURE::operator=
_TEXT	ENDS
PUBLIC	??_GRT_TEXTURE@Ogre@@MAEPAXI@Z			; Ogre::RT_TEXTURE::`scalar deleting destructor'
EXTRN	??1RT_TEXTURE@Ogre@@MAE@XZ:PROC			; Ogre::RT_TEXTURE::~RT_TEXTURE
; Function compile flags: /Odtp
;	COMDAT ??_GRT_TEXTURE@Ogre@@MAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GRT_TEXTURE@Ogre@@MAEPAXI@Z PROC			; Ogre::RT_TEXTURE::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1RT_TEXTURE@Ogre@@MAE@XZ		; Ogre::RT_TEXTURE::~RT_TEXTURE
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@14
	push	48					; 00000030H
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3MemoryDelegation@Ogre@@SAXPAXI@Z	; Ogre::MemoryDelegation::operator delete
	add	esp, 8
$LN1@scalar@14:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GRT_TEXTURE@Ogre@@MAEPAXI@Z ENDP			; Ogre::RT_TEXTURE::`scalar deleting destructor'
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_ERT_TEXTURE@Ogre@@MAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_ERT_TEXTURE@Ogre@@MAEPAXI@Z PROC			; Ogre::RT_TEXTURE::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 2
	je	SHORT $LN3@vector@14
	push	OFFSET ??1RT_TEXTURE@Ogre@@MAE@XZ	; Ogre::RT_TEXTURE::~RT_TEXTURE
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx-4]
	push	edx
	push	48					; 00000030H
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??_M@YGXPAXIHP6EX0@Z@Z
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN2@vector@14
	push	48					; 00000030H
	mov	edx, DWORD PTR _this$[ebp]
	sub	edx, 4
	push	edx
	call	??_VMemoryDelegation@Ogre@@SAXPAXI@Z	; Ogre::MemoryDelegation::operator delete[]
	add	esp, 8
$LN2@vector@14:
	mov	eax, DWORD PTR _this$[ebp]
	sub	eax, 4
	jmp	SHORT $LN4@vector@14
$LN3@vector@14:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1RT_TEXTURE@Ogre@@MAE@XZ		; Ogre::RT_TEXTURE::~RT_TEXTURE
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@vector@14
	push	48					; 00000030H
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3MemoryDelegation@Ogre@@SAXPAXI@Z	; Ogre::MemoryDelegation::operator delete
	add	esp, 8
$LN1@vector@14:
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector@14:
	mov	esp, ebp
	pop	ebp
	ret	4
??_ERT_TEXTURE@Ogre@@MAEPAXI@Z ENDP			; Ogre::RT_TEXTURE::`vector deleting destructor'
_TEXT	ENDS
PUBLIC	?getPixelFormat@HardwarePixelBufferPool@Ogre@@QAE?AW4PixelFormat@2@XZ ; Ogre::HardwarePixelBufferPool::getPixelFormat
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogrehardwarepixelbuffer.h
;	COMDAT ?getPixelFormat@HardwarePixelBufferPool@Ogre@@QAE?AW4PixelFormat@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getPixelFormat@HardwarePixelBufferPool@Ogre@@QAE?AW4PixelFormat@2@XZ PROC ; Ogre::HardwarePixelBufferPool::getPixelFormat, COMDAT
; _this$ = ecx

; 22   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 23   : 			return m_Desc.format;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+28]

; 24   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?getPixelFormat@HardwarePixelBufferPool@Ogre@@QAE?AW4PixelFormat@2@XZ ENDP ; Ogre::HardwarePixelBufferPool::getPixelFormat
_TEXT	ENDS
PUBLIC	??1?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::~vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >
PUBLIC	??0?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QAE@ABV01@@Z ; std::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >
PUBLIC	??_7HardwarePixelBufferPool@Ogre@@6B@		; Ogre::HardwarePixelBufferPool::`vftable'
PUBLIC	??0HardwarePixelBufferPool@Ogre@@QAE@ABV01@@Z	; Ogre::HardwarePixelBufferPool::HardwarePixelBufferPool
PUBLIC	??_R4HardwarePixelBufferPool@Ogre@@6B@		; Ogre::HardwarePixelBufferPool::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVHardwarePixelBufferPool@Ogre@@@8	; Ogre::HardwarePixelBufferPool `RTTI Type Descriptor'
PUBLIC	??_R3HardwarePixelBufferPool@Ogre@@8		; Ogre::HardwarePixelBufferPool::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2HardwarePixelBufferPool@Ogre@@8		; Ogre::HardwarePixelBufferPool::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@HardwarePixelBufferPool@Ogre@@8	; Ogre::HardwarePixelBufferPool::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_EHardwarePixelBufferPool@Ogre@@UAEPAXI@Z	; Ogre::HardwarePixelBufferPool::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@HardwarePixelBufferPool@Ogre@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@HardwarePixelBufferPool@Ogre@@8 DD FLAT:??_R0?AVHardwarePixelBufferPool@Ogre@@@8 ; Ogre::HardwarePixelBufferPool::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3HardwarePixelBufferPool@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R2HardwarePixelBufferPool@Ogre@@8
rdata$r	SEGMENT
??_R2HardwarePixelBufferPool@Ogre@@8 DD FLAT:??_R1A@?0A@EA@HardwarePixelBufferPool@Ogre@@8 ; Ogre::HardwarePixelBufferPool::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3HardwarePixelBufferPool@Ogre@@8
rdata$r	SEGMENT
??_R3HardwarePixelBufferPool@Ogre@@8 DD 00H		; Ogre::HardwarePixelBufferPool::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2HardwarePixelBufferPool@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVHardwarePixelBufferPool@Ogre@@@8
_DATA	SEGMENT
??_R0?AVHardwarePixelBufferPool@Ogre@@@8 DD FLAT:??_7type_info@@6B@ ; Ogre::HardwarePixelBufferPool `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVHardwarePixelBufferPool@Ogre@@', 00H
_DATA	ENDS
;	COMDAT ??_R4HardwarePixelBufferPool@Ogre@@6B@
rdata$r	SEGMENT
??_R4HardwarePixelBufferPool@Ogre@@6B@ DD 00H		; Ogre::HardwarePixelBufferPool::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVHardwarePixelBufferPool@Ogre@@@8
	DD	FLAT:??_R3HardwarePixelBufferPool@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_7HardwarePixelBufferPool@Ogre@@6B@
CONST	SEGMENT
??_7HardwarePixelBufferPool@Ogre@@6B@ DD FLAT:??_R4HardwarePixelBufferPool@Ogre@@6B@ ; Ogre::HardwarePixelBufferPool::`vftable'
	DD	FLAT:??_EHardwarePixelBufferPool@Ogre@@UAEPAXI@Z
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0HardwarePixelBufferPool@Ogre@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0HardwarePixelBufferPool@Ogre@@QAE@ABV01@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0HardwarePixelBufferPool@Ogre@@QAE@ABV01@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0HardwarePixelBufferPool@Ogre@@QAE@ABV01@@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$??0HardwarePixelBufferPool@Ogre@@QAE@ABV01@@Z$3
__ehfuncinfo$??0HardwarePixelBufferPool@Ogre@@QAE@ABV01@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$??0HardwarePixelBufferPool@Ogre@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0HardwarePixelBufferPool@Ogre@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0HardwarePixelBufferPool@Ogre@@QAE@ABV01@@Z PROC	; Ogre::HardwarePixelBufferPool::HardwarePixelBufferPool, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0HardwarePixelBufferPool@Ogre@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7HardwarePixelBufferPool@Ogre@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], eax
	mov	esi, DWORD PTR ___that$[ebp]
	add	esi, 8
	mov	edi, DWORD PTR _this$[ebp]
	add	edi, 8
	mov	ecx, 7
	rep movsd
	mov	ecx, DWORD PTR ___that$[ebp]
	add	ecx, 36					; 00000024H
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??0?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QAE@ABV01@@Z ; std::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 60					; 0000003cH
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 60					; 0000003cH
	call	??0?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QAE@ABV01@@Z ; std::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+84]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+84], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+88]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+88], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0HardwarePixelBufferPool@Ogre@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	jmp	??1?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::~vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >
__unwindfunclet$??0HardwarePixelBufferPool@Ogre@@QAE@ABV01@@Z$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 60					; 0000003cH
	jmp	??1?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::~vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >
__unwindfunclet$??0HardwarePixelBufferPool@Ogre@@QAE@ABV01@@Z$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 84					; 00000054H
	jmp	??1LockSection@Ogre@@QAE@XZ		; Ogre::LockSection::~LockSection
__unwindfunclet$??0HardwarePixelBufferPool@Ogre@@QAE@ABV01@@Z$3:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 88					; 00000058H
	jmp	??1LockSection@Ogre@@QAE@XZ		; Ogre::LockSection::~LockSection
__ehhandler$??0HardwarePixelBufferPool@Ogre@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0HardwarePixelBufferPool@Ogre@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0HardwarePixelBufferPool@Ogre@@QAE@ABV01@@Z ENDP	; Ogre::HardwarePixelBufferPool::HardwarePixelBufferPool
PUBLIC	??4?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::operator=
PUBLIC	??4HardwarePixelBufferPool@Ogre@@QAEAAV01@ABV01@@Z ; Ogre::HardwarePixelBufferPool::operator=
; Function compile flags: /Odtp
;	COMDAT ??4HardwarePixelBufferPool@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4HardwarePixelBufferPool@Ogre@@QAEAAV01@ABV01@@Z PROC	; Ogre::HardwarePixelBufferPool::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	esi, DWORD PTR ___that$[ebp]
	add	esi, 8
	mov	edi, DWORD PTR _this$[ebp]
	add	edi, 8
	mov	ecx, 7
	rep movsd
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 36					; 00000024H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??4?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::operator=
	mov	ecx, DWORD PTR ___that$[ebp]
	add	ecx, 60					; 0000003cH
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 60					; 0000003cH
	call	??4?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::operator=
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+84]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+84], eax
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+88]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+88], eax
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
??4HardwarePixelBufferPool@Ogre@@QAEAAV01@ABV01@@Z ENDP	; Ogre::HardwarePixelBufferPool::operator=
_TEXT	ENDS
PUBLIC	??1HardwarePixelBufferPool@Ogre@@UAE@XZ		; Ogre::HardwarePixelBufferPool::~HardwarePixelBufferPool
PUBLIC	??_GHardwarePixelBufferPool@Ogre@@UAEPAXI@Z	; Ogre::HardwarePixelBufferPool::`scalar deleting destructor'
; Function compile flags: /Odtp
;	COMDAT ??_GHardwarePixelBufferPool@Ogre@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GHardwarePixelBufferPool@Ogre@@UAEPAXI@Z PROC	; Ogre::HardwarePixelBufferPool::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1HardwarePixelBufferPool@Ogre@@UAE@XZ	; Ogre::HardwarePixelBufferPool::~HardwarePixelBufferPool
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@15
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@15:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GHardwarePixelBufferPool@Ogre@@UAEPAXI@Z ENDP	; Ogre::HardwarePixelBufferPool::`scalar deleting destructor'
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_EHardwarePixelBufferPool@Ogre@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_EHardwarePixelBufferPool@Ogre@@UAEPAXI@Z PROC	; Ogre::HardwarePixelBufferPool::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 2
	je	SHORT $LN3@vector@15
	push	OFFSET ??1HardwarePixelBufferPool@Ogre@@UAE@XZ ; Ogre::HardwarePixelBufferPool::~HardwarePixelBufferPool
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx-4]
	push	edx
	push	92					; 0000005cH
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??_M@YGXPAXIHP6EX0@Z@Z
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN2@vector@15
	mov	edx, DWORD PTR _this$[ebp]
	sub	edx, 4
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN2@vector@15:
	mov	eax, DWORD PTR _this$[ebp]
	sub	eax, 4
	jmp	SHORT $LN4@vector@15
$LN3@vector@15:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1HardwarePixelBufferPool@Ogre@@UAE@XZ	; Ogre::HardwarePixelBufferPool::~HardwarePixelBufferPool
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@vector@15
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@vector@15:
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector@15:
	mov	esp, ebp
	pop	ebp
	ret	4
??_EHardwarePixelBufferPool@Ogre@@UAEPAXI@Z ENDP	; Ogre::HardwarePixelBufferPool::`vector deleting destructor'
_TEXT	ENDS
PUBLIC	?addRef@HardwarePixelBuffer@Ogre@@QAEXXZ	; Ogre::HardwarePixelBuffer::addRef
; Function compile flags: /Odtp
;	COMDAT ?addRef@HardwarePixelBuffer@Ogre@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?addRef@HardwarePixelBuffer@Ogre@@QAEXXZ PROC		; Ogre::HardwarePixelBuffer::addRef, COMDAT
; _this$ = ecx

; 50   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 51   : 			m_RefCount++;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 52   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?addRef@HardwarePixelBuffer@Ogre@@QAEXXZ ENDP		; Ogre::HardwarePixelBuffer::addRef
_TEXT	ENDS
PUBLIC	?release@HardwarePixelBuffer@Ogre@@QAEXXZ	; Ogre::HardwarePixelBuffer::release
; Function compile flags: /Odtp
;	COMDAT ?release@HardwarePixelBuffer@Ogre@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?release@HardwarePixelBuffer@Ogre@@QAEXXZ PROC		; Ogre::HardwarePixelBuffer::release, COMDAT
; _this$ = ecx

; 54   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 55   : 			m_RefCount--;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	sub	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 56   : 			assert(m_RefCount >= 0);
; 57   : 			//if(m_RefCount == 0)	m_pPool->freeBuffer(this); //!!!
; 58   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?release@HardwarePixelBuffer@Ogre@@QAEXXZ ENDP		; Ogre::HardwarePixelBuffer::release
_TEXT	ENDS
PUBLIC	?deleteThis@HardwarePixelBuffer@Ogre@@QAEXXZ	; Ogre::HardwarePixelBuffer::deleteThis
; Function compile flags: /Odtp
;	COMDAT ?deleteThis@HardwarePixelBuffer@Ogre@@QAEXXZ
_TEXT	SEGMENT
tv70 = -16						; size = 4
_this$ = -12						; size = 4
$T72025 = -8						; size = 4
$T72024 = -4						; size = 4
?deleteThis@HardwarePixelBuffer@Ogre@@QAEXXZ PROC	; Ogre::HardwarePixelBuffer::deleteThis, COMDAT
; _this$ = ecx

; 60   : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 61   : 			delete this;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR $T72025[ebp], eax
	mov	ecx, DWORD PTR $T72025[ebp]
	mov	DWORD PTR $T72024[ebp], ecx
	cmp	DWORD PTR $T72024[ebp], 0
	je	SHORT $LN3@deleteThis@2
	push	1
	mov	edx, DWORD PTR $T72024[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR $T72024[ebp]
	mov	edx, DWORD PTR [eax+12]
	call	edx
	mov	DWORD PTR tv70[ebp], eax
	jmp	SHORT $LN1@deleteThis@2
$LN3@deleteThis@2:
	mov	DWORD PTR tv70[ebp], 0
$LN1@deleteThis@2:

; 62   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?deleteThis@HardwarePixelBuffer@Ogre@@QAEXXZ ENDP	; Ogre::HardwarePixelBuffer::deleteThis
_TEXT	ENDS
PUBLIC	?lock@HardwarePixelBuffer@Ogre@@QAEPAXIW4HardwareBufferLockOpt@2@AAULockResult@2@@Z ; Ogre::HardwarePixelBuffer::lock
; Function compile flags: /Odtp
;	COMDAT ?lock@HardwarePixelBuffer@Ogre@@QAEPAXIW4HardwareBufferLockOpt@2@AAULockResult@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_index$ = 8						; size = 4
_lockopt$ = 12						; size = 4
_lockresult$ = 16					; size = 4
?lock@HardwarePixelBuffer@Ogre@@QAEPAXIW4HardwareBufferLockOpt@2@AAULockResult@2@@Z PROC ; Ogre::HardwarePixelBuffer::lock, COMDAT
; _this$ = ecx

; 66   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 67   : 			return m_pPool->lock(this, index, lockopt, lockresult);

	mov	eax, DWORD PTR _lockresult$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lockopt$[ebp]
	push	ecx
	mov	edx, DWORD PTR _index$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR [edx]
	mov	eax, DWORD PTR [edx+8]
	call	eax

; 68   : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?lock@HardwarePixelBuffer@Ogre@@QAEPAXIW4HardwareBufferLockOpt@2@AAULockResult@2@@Z ENDP ; Ogre::HardwarePixelBuffer::lock
_TEXT	ENDS
PUBLIC	?unlock@HardwarePixelBuffer@Ogre@@QAEXI@Z	; Ogre::HardwarePixelBuffer::unlock
; Function compile flags: /Odtp
;	COMDAT ?unlock@HardwarePixelBuffer@Ogre@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_index$ = 8						; size = 4
?unlock@HardwarePixelBuffer@Ogre@@QAEXI@Z PROC		; Ogre::HardwarePixelBuffer::unlock, COMDAT
; _this$ = ecx

; 71   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 72   : 			m_pPool->unlock(this, index);

	mov	eax, DWORD PTR _index$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+12]
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [edx+12]
	call	eax

; 73   : 			m_DataInvalid = false;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+4], 0

; 74   : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?unlock@HardwarePixelBuffer@Ogre@@QAEXI@Z ENDP		; Ogre::HardwarePixelBuffer::unlock
_TEXT	ENDS
PUBLIC	?loadSurfaceData@HardwarePixelBuffer@Ogre@@QAEXIPAVSurfaceData@2@@Z ; Ogre::HardwarePixelBuffer::loadSurfaceData
; Function compile flags: /Odtp
;	COMDAT ?loadSurfaceData@HardwarePixelBuffer@Ogre@@QAEXIPAVSurfaceData@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_index$ = 8						; size = 4
_psurfacedata$ = 12					; size = 4
?loadSurfaceData@HardwarePixelBuffer@Ogre@@QAEXIPAVSurfaceData@2@@Z PROC ; Ogre::HardwarePixelBuffer::loadSurfaceData, COMDAT
; _this$ = ecx

; 77   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 78   : 			m_pPool->loadSurfaceData(this, index, psurfacedata);

	mov	eax, DWORD PTR _psurfacedata$[ebp]
	push	eax
	mov	ecx, DWORD PTR _index$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, eax
	mov	eax, DWORD PTR [edx+16]
	call	eax

; 79   : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?loadSurfaceData@HardwarePixelBuffer@Ogre@@QAEXIPAVSurfaceData@2@@Z ENDP ; Ogre::HardwarePixelBuffer::loadSurfaceData
_TEXT	ENDS
PUBLIC	?createRenderTarget@HardwarePixelBuffer@Ogre@@QAEPAVTextureRenderTarget@2@IHH@Z ; Ogre::HardwarePixelBuffer::createRenderTarget
; Function compile flags: /Odtp
;	COMDAT ?createRenderTarget@HardwarePixelBuffer@Ogre@@QAEPAVTextureRenderTarget@2@IHH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_index$ = 8						; size = 4
_depthbits$ = 12					; size = 4
_multisample$ = 16					; size = 4
?createRenderTarget@HardwarePixelBuffer@Ogre@@QAEPAVTextureRenderTarget@2@IHH@Z PROC ; Ogre::HardwarePixelBuffer::createRenderTarget, COMDAT
; _this$ = ecx

; 82   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 83   : 			return m_pPool->createRenderTarget(this, index, depthbits, multisample);

	mov	eax, DWORD PTR _multisample$[ebp]
	push	eax
	mov	ecx, DWORD PTR _depthbits$[ebp]
	push	ecx
	mov	edx, DWORD PTR _index$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR [edx]
	mov	eax, DWORD PTR [edx+20]
	call	eax

; 84   : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?createRenderTarget@HardwarePixelBuffer@Ogre@@QAEPAVTextureRenderTarget@2@IHH@Z ENDP ; Ogre::HardwarePixelBuffer::createRenderTarget
_TEXT	ENDS
PUBLIC	?createDepthStencil@HardwarePixelBuffer@Ogre@@QAEPAVTextureRenderTarget@2@I@Z ; Ogre::HardwarePixelBuffer::createDepthStencil
; Function compile flags: /Odtp
;	COMDAT ?createDepthStencil@HardwarePixelBuffer@Ogre@@QAEPAVTextureRenderTarget@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_index$ = 8						; size = 4
?createDepthStencil@HardwarePixelBuffer@Ogre@@QAEPAVTextureRenderTarget@2@I@Z PROC ; Ogre::HardwarePixelBuffer::createDepthStencil, COMDAT
; _this$ = ecx

; 87   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 88   : 			return m_pPool->createDepthStencil(this, index);

	mov	eax, DWORD PTR _index$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+12]
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [edx+24]
	call	eax

; 89   : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?createDepthStencil@HardwarePixelBuffer@Ogre@@QAEPAVTextureRenderTarget@2@I@Z ENDP ; Ogre::HardwarePixelBuffer::createDepthStencil
_TEXT	ENDS
PUBLIC	?getPixelFormat@HardwarePixelBuffer@Ogre@@QAE?AW4PixelFormat@2@XZ ; Ogre::HardwarePixelBuffer::getPixelFormat
; Function compile flags: /Odtp
;	COMDAT ?getPixelFormat@HardwarePixelBuffer@Ogre@@QAE?AW4PixelFormat@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getPixelFormat@HardwarePixelBuffer@Ogre@@QAE?AW4PixelFormat@2@XZ PROC ; Ogre::HardwarePixelBuffer::getPixelFormat, COMDAT
; _this$ = ecx

; 93   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 94   : 			return m_pPool->getPixelFormat();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	call	?getPixelFormat@HardwarePixelBufferPool@Ogre@@QAE?AW4PixelFormat@2@XZ ; Ogre::HardwarePixelBufferPool::getPixelFormat

; 95   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?getPixelFormat@HardwarePixelBuffer@Ogre@@QAE?AW4PixelFormat@2@XZ ENDP ; Ogre::HardwarePixelBuffer::getPixelFormat
_TEXT	ENDS
PUBLIC	??_7HardwarePixelBuffer@Ogre@@6B@		; Ogre::HardwarePixelBuffer::`vftable'
PUBLIC	??0HardwarePixelBuffer@Ogre@@IAE@XZ		; Ogre::HardwarePixelBuffer::HardwarePixelBuffer
PUBLIC	??_R4HardwarePixelBuffer@Ogre@@6B@		; Ogre::HardwarePixelBuffer::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVHardwarePixelBuffer@Ogre@@@8		; Ogre::HardwarePixelBuffer `RTTI Type Descriptor'
PUBLIC	??_R3HardwarePixelBuffer@Ogre@@8		; Ogre::HardwarePixelBuffer::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2HardwarePixelBuffer@Ogre@@8		; Ogre::HardwarePixelBuffer::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@HardwarePixelBuffer@Ogre@@8	; Ogre::HardwarePixelBuffer::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_EHardwarePixelBuffer@Ogre@@MAEPAXI@Z		; Ogre::HardwarePixelBuffer::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@HardwarePixelBuffer@Ogre@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@HardwarePixelBuffer@Ogre@@8 DD FLAT:??_R0?AVHardwarePixelBuffer@Ogre@@@8 ; Ogre::HardwarePixelBuffer::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3HardwarePixelBuffer@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R2HardwarePixelBuffer@Ogre@@8
rdata$r	SEGMENT
??_R2HardwarePixelBuffer@Ogre@@8 DD FLAT:??_R1A@?0A@EA@HardwarePixelBuffer@Ogre@@8 ; Ogre::HardwarePixelBuffer::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3HardwarePixelBuffer@Ogre@@8
rdata$r	SEGMENT
??_R3HardwarePixelBuffer@Ogre@@8 DD 00H			; Ogre::HardwarePixelBuffer::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2HardwarePixelBuffer@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVHardwarePixelBuffer@Ogre@@@8
_DATA	SEGMENT
??_R0?AVHardwarePixelBuffer@Ogre@@@8 DD FLAT:??_7type_info@@6B@ ; Ogre::HardwarePixelBuffer `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVHardwarePixelBuffer@Ogre@@', 00H
_DATA	ENDS
;	COMDAT ??_R4HardwarePixelBuffer@Ogre@@6B@
rdata$r	SEGMENT
??_R4HardwarePixelBuffer@Ogre@@6B@ DD 00H		; Ogre::HardwarePixelBuffer::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVHardwarePixelBuffer@Ogre@@@8
	DD	FLAT:??_R3HardwarePixelBuffer@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_7HardwarePixelBuffer@Ogre@@6B@
CONST	SEGMENT
??_7HardwarePixelBuffer@Ogre@@6B@ DD FLAT:??_R4HardwarePixelBuffer@Ogre@@6B@ ; Ogre::HardwarePixelBuffer::`vftable'
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:??_EHardwarePixelBuffer@Ogre@@MAEPAXI@Z
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ??0HardwarePixelBuffer@Ogre@@IAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0HardwarePixelBuffer@Ogre@@IAE@XZ PROC		; Ogre::HardwarePixelBuffer::HardwarePixelBuffer, COMDAT
; _this$ = ecx

; 107  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7HardwarePixelBuffer@Ogre@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+4], 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+16], 0

; 108  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0HardwarePixelBuffer@Ogre@@IAE@XZ ENDP		; Ogre::HardwarePixelBuffer::HardwarePixelBuffer
_TEXT	ENDS
PUBLIC	??1HardwarePixelBuffer@Ogre@@MAE@XZ		; Ogre::HardwarePixelBuffer::~HardwarePixelBuffer
; Function compile flags: /Odtp
;	COMDAT ??1HardwarePixelBuffer@Ogre@@MAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1HardwarePixelBuffer@Ogre@@MAE@XZ PROC		; Ogre::HardwarePixelBuffer::~HardwarePixelBuffer, COMDAT
; _this$ = ecx

; 111  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7HardwarePixelBuffer@Ogre@@6B@

; 112  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??1HardwarePixelBuffer@Ogre@@MAE@XZ ENDP		; Ogre::HardwarePixelBuffer::~HardwarePixelBuffer
_TEXT	ENDS
PUBLIC	??0HardwarePixelBuffer@Ogre@@QAE@ABV01@@Z	; Ogre::HardwarePixelBuffer::HardwarePixelBuffer
; Function compile flags: /Odtp
;	COMDAT ??0HardwarePixelBuffer@Ogre@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0HardwarePixelBuffer@Ogre@@QAE@ABV01@@Z PROC		; Ogre::HardwarePixelBuffer::HardwarePixelBuffer, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7HardwarePixelBuffer@Ogre@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	al, BYTE PTR [edx+4]
	mov	BYTE PTR [ecx+4], al
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+8], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR [ecx+12], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR [ecx+16], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0HardwarePixelBuffer@Ogre@@QAE@ABV01@@Z ENDP		; Ogre::HardwarePixelBuffer::HardwarePixelBuffer
_TEXT	ENDS
PUBLIC	??4HardwarePixelBuffer@Ogre@@QAEAAV01@ABV01@@Z	; Ogre::HardwarePixelBuffer::operator=
; Function compile flags: /Odtp
;	COMDAT ??4HardwarePixelBuffer@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4HardwarePixelBuffer@Ogre@@QAEAAV01@ABV01@@Z PROC	; Ogre::HardwarePixelBuffer::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	dl, BYTE PTR [ecx+4]
	mov	BYTE PTR [eax+4], dl
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+16], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4HardwarePixelBuffer@Ogre@@QAEAAV01@ABV01@@Z ENDP	; Ogre::HardwarePixelBuffer::operator=
_TEXT	ENDS
PUBLIC	??_GHardwarePixelBuffer@Ogre@@MAEPAXI@Z		; Ogre::HardwarePixelBuffer::`scalar deleting destructor'
; Function compile flags: /Odtp
;	COMDAT ??_GHardwarePixelBuffer@Ogre@@MAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GHardwarePixelBuffer@Ogre@@MAEPAXI@Z PROC		; Ogre::HardwarePixelBuffer::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1HardwarePixelBuffer@Ogre@@MAE@XZ	; Ogre::HardwarePixelBuffer::~HardwarePixelBuffer
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@16
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@16:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GHardwarePixelBuffer@Ogre@@MAEPAXI@Z ENDP		; Ogre::HardwarePixelBuffer::`scalar deleting destructor'
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_EHardwarePixelBuffer@Ogre@@MAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_EHardwarePixelBuffer@Ogre@@MAEPAXI@Z PROC		; Ogre::HardwarePixelBuffer::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 2
	je	SHORT $LN3@vector@16
	push	OFFSET ??1HardwarePixelBuffer@Ogre@@MAE@XZ ; Ogre::HardwarePixelBuffer::~HardwarePixelBuffer
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx-4]
	push	edx
	push	20					; 00000014H
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??_M@YGXPAXIHP6EX0@Z@Z
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN2@vector@16
	mov	edx, DWORD PTR _this$[ebp]
	sub	edx, 4
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN2@vector@16:
	mov	eax, DWORD PTR _this$[ebp]
	sub	eax, 4
	jmp	SHORT $LN4@vector@16
$LN3@vector@16:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1HardwarePixelBuffer@Ogre@@MAE@XZ	; Ogre::HardwarePixelBuffer::~HardwarePixelBuffer
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@vector@16
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@vector@16:
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector@16:
	mov	esp, ebp
	pop	ebp
	ret	4
??_EHardwarePixelBuffer@Ogre@@MAEPAXI@Z ENDP		; Ogre::HardwarePixelBuffer::`vector deleting destructor'
_TEXT	ENDS
PUBLIC	?getCurTime@HardwarePixelBufferManager@Ogre@@QAEIXZ ; Ogre::HardwarePixelBufferManager::getCurTime
; Function compile flags: /Odtp
;	COMDAT ?getCurTime@HardwarePixelBufferManager@Ogre@@QAEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getCurTime@HardwarePixelBufferManager@Ogre@@QAEIXZ PROC ; Ogre::HardwarePixelBufferManager::getCurTime, COMDAT
; _this$ = ecx

; 128  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 129  : 			return m_CurTime;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+36]

; 130  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?getCurTime@HardwarePixelBufferManager@Ogre@@QAEIXZ ENDP ; Ogre::HardwarePixelBufferManager::getCurTime
_TEXT	ENDS
PUBLIC	??4?$Singleton@VHardwarePixelBufferManager@Ogre@@@Ogre@@QAEAAV01@ABV01@@Z ; Ogre::Singleton<Ogre::HardwarePixelBufferManager>::operator=
; Function compile flags: /Odtp
;	COMDAT ??4?$Singleton@VHardwarePixelBufferManager@Ogre@@@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4?$Singleton@VHardwarePixelBufferManager@Ogre@@@Ogre@@QAEAAV01@ABV01@@Z PROC ; Ogre::Singleton<Ogre::HardwarePixelBufferManager>::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4?$Singleton@VHardwarePixelBufferManager@Ogre@@@Ogre@@QAEAAV01@ABV01@@Z ENDP ; Ogre::Singleton<Ogre::HardwarePixelBufferManager>::operator=
_TEXT	ENDS
PUBLIC	??1?$map@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@@std@@QAE@XZ ; std::map<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> > >::~map<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> > >
PUBLIC	??1?$Singleton@VHardwarePixelBufferManager@Ogre@@@Ogre@@QAE@XZ ; Ogre::Singleton<Ogre::HardwarePixelBufferManager>::~Singleton<Ogre::HardwarePixelBufferManager>
PUBLIC	??0?$map@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@@std@@QAE@ABV01@@Z ; std::map<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> > >::map<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> > >
PUBLIC	??_7HardwarePixelBufferManager@Ogre@@6B@	; Ogre::HardwarePixelBufferManager::`vftable'
PUBLIC	??0HardwarePixelBufferManager@Ogre@@QAE@ABV01@@Z ; Ogre::HardwarePixelBufferManager::HardwarePixelBufferManager
PUBLIC	??_R4HardwarePixelBufferManager@Ogre@@6B@	; Ogre::HardwarePixelBufferManager::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVHardwarePixelBufferManager@Ogre@@@8	; Ogre::HardwarePixelBufferManager `RTTI Type Descriptor'
PUBLIC	??_R3HardwarePixelBufferManager@Ogre@@8		; Ogre::HardwarePixelBufferManager::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2HardwarePixelBufferManager@Ogre@@8		; Ogre::HardwarePixelBufferManager::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@HardwarePixelBufferManager@Ogre@@8 ; Ogre::HardwarePixelBufferManager::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R13?0A@EA@?$Singleton@VHardwarePixelBufferManager@Ogre@@@Ogre@@8 ; Ogre::Singleton<Ogre::HardwarePixelBufferManager>::`RTTI Base Class Descriptor at (4,-1,0,64)'
PUBLIC	??_R0?AV?$Singleton@VHardwarePixelBufferManager@Ogre@@@Ogre@@@8 ; Ogre::Singleton<Ogre::HardwarePixelBufferManager> `RTTI Type Descriptor'
PUBLIC	??_R3?$Singleton@VHardwarePixelBufferManager@Ogre@@@Ogre@@8 ; Ogre::Singleton<Ogre::HardwarePixelBufferManager>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$Singleton@VHardwarePixelBufferManager@Ogre@@@Ogre@@8 ; Ogre::Singleton<Ogre::HardwarePixelBufferManager>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$Singleton@VHardwarePixelBufferManager@Ogre@@@Ogre@@8 ; Ogre::Singleton<Ogre::HardwarePixelBufferManager>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_EHardwarePixelBufferManager@Ogre@@UAEPAXI@Z	; Ogre::HardwarePixelBufferManager::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@?$Singleton@VHardwarePixelBufferManager@Ogre@@@Ogre@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$Singleton@VHardwarePixelBufferManager@Ogre@@@Ogre@@8 DD FLAT:??_R0?AV?$Singleton@VHardwarePixelBufferManager@Ogre@@@Ogre@@@8 ; Ogre::Singleton<Ogre::HardwarePixelBufferManager>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$Singleton@VHardwarePixelBufferManager@Ogre@@@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R2?$Singleton@VHardwarePixelBufferManager@Ogre@@@Ogre@@8
rdata$r	SEGMENT
??_R2?$Singleton@VHardwarePixelBufferManager@Ogre@@@Ogre@@8 DD FLAT:??_R1A@?0A@EA@?$Singleton@VHardwarePixelBufferManager@Ogre@@@Ogre@@8 ; Ogre::Singleton<Ogre::HardwarePixelBufferManager>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3?$Singleton@VHardwarePixelBufferManager@Ogre@@@Ogre@@8
rdata$r	SEGMENT
??_R3?$Singleton@VHardwarePixelBufferManager@Ogre@@@Ogre@@8 DD 00H ; Ogre::Singleton<Ogre::HardwarePixelBufferManager>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$Singleton@VHardwarePixelBufferManager@Ogre@@@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$Singleton@VHardwarePixelBufferManager@Ogre@@@Ogre@@@8
_DATA	SEGMENT
??_R0?AV?$Singleton@VHardwarePixelBufferManager@Ogre@@@Ogre@@@8 DD FLAT:??_7type_info@@6B@ ; Ogre::Singleton<Ogre::HardwarePixelBufferManager> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$Singleton@VHardwarePixelBufferManager@Ogre@@@Ogre@'
	DB	'@', 00H
_DATA	ENDS
;	COMDAT ??_R13?0A@EA@?$Singleton@VHardwarePixelBufferManager@Ogre@@@Ogre@@8
rdata$r	SEGMENT
??_R13?0A@EA@?$Singleton@VHardwarePixelBufferManager@Ogre@@@Ogre@@8 DD FLAT:??_R0?AV?$Singleton@VHardwarePixelBufferManager@Ogre@@@Ogre@@@8 ; Ogre::Singleton<Ogre::HardwarePixelBufferManager>::`RTTI Base Class Descriptor at (4,-1,0,64)'
	DD	00H
	DD	04H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$Singleton@VHardwarePixelBufferManager@Ogre@@@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@HardwarePixelBufferManager@Ogre@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@HardwarePixelBufferManager@Ogre@@8 DD FLAT:??_R0?AVHardwarePixelBufferManager@Ogre@@@8 ; Ogre::HardwarePixelBufferManager::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3HardwarePixelBufferManager@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R2HardwarePixelBufferManager@Ogre@@8
rdata$r	SEGMENT
??_R2HardwarePixelBufferManager@Ogre@@8 DD FLAT:??_R1A@?0A@EA@HardwarePixelBufferManager@Ogre@@8 ; Ogre::HardwarePixelBufferManager::`RTTI Base Class Array'
	DD	FLAT:??_R13?0A@EA@?$Singleton@VHardwarePixelBufferManager@Ogre@@@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R3HardwarePixelBufferManager@Ogre@@8
rdata$r	SEGMENT
??_R3HardwarePixelBufferManager@Ogre@@8 DD 00H		; Ogre::HardwarePixelBufferManager::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2HardwarePixelBufferManager@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVHardwarePixelBufferManager@Ogre@@@8
_DATA	SEGMENT
??_R0?AVHardwarePixelBufferManager@Ogre@@@8 DD FLAT:??_7type_info@@6B@ ; Ogre::HardwarePixelBufferManager `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVHardwarePixelBufferManager@Ogre@@', 00H
_DATA	ENDS
;	COMDAT ??_R4HardwarePixelBufferManager@Ogre@@6B@
rdata$r	SEGMENT
??_R4HardwarePixelBufferManager@Ogre@@6B@ DD 00H	; Ogre::HardwarePixelBufferManager::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVHardwarePixelBufferManager@Ogre@@@8
	DD	FLAT:??_R3HardwarePixelBufferManager@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_7HardwarePixelBufferManager@Ogre@@6B@
CONST	SEGMENT
??_7HardwarePixelBufferManager@Ogre@@6B@ DD FLAT:??_R4HardwarePixelBufferManager@Ogre@@6B@ ; Ogre::HardwarePixelBufferManager::`vftable'
	DD	FLAT:??_EHardwarePixelBufferManager@Ogre@@UAEPAXI@Z
	DD	FLAT:__purecall
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0HardwarePixelBufferManager@Ogre@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0HardwarePixelBufferManager@Ogre@@QAE@ABV01@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0HardwarePixelBufferManager@Ogre@@QAE@ABV01@@Z$1
__ehfuncinfo$??0HardwarePixelBufferManager@Ogre@@QAE@ABV01@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0HardwarePixelBufferManager@Ogre@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0HardwarePixelBufferManager@Ogre@@QAE@ABV01@@Z
_TEXT	SEGMENT
tv68 = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0HardwarePixelBufferManager@Ogre@@QAE@ABV01@@Z PROC	; Ogre::HardwarePixelBufferManager::HardwarePixelBufferManager, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0HardwarePixelBufferManager@Ogre@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	cmp	DWORD PTR ___that$[ebp], 0
	je	SHORT $LN3@HardwarePi
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 4
	mov	DWORD PTR tv68[ebp], eax
	jmp	SHORT $LN4@HardwarePi
$LN3@HardwarePi:
	mov	DWORD PTR tv68[ebp], 0
$LN4@HardwarePi:
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7HardwarePixelBufferManager@Ogre@@6B@
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 4
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??0?$map@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@@std@@QAE@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	mov	DWORD PTR [eax+36], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0HardwarePixelBufferManager@Ogre@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	jmp	??1?$Singleton@VHardwarePixelBufferManager@Ogre@@@Ogre@@QAE@XZ ; Ogre::Singleton<Ogre::HardwarePixelBufferManager>::~Singleton<Ogre::HardwarePixelBufferManager>
__unwindfunclet$??0HardwarePixelBufferManager@Ogre@@QAE@ABV01@@Z$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	jmp	??1?$map@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@@std@@QAE@XZ
__ehhandler$??0HardwarePixelBufferManager@Ogre@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0HardwarePixelBufferManager@Ogre@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0HardwarePixelBufferManager@Ogre@@QAE@ABV01@@Z ENDP	; Ogre::HardwarePixelBufferManager::HardwarePixelBufferManager
PUBLIC	??4?$map@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@@std@@QAEAAV01@ABV01@@Z ; std::map<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> > >::operator=
PUBLIC	??4HardwarePixelBufferManager@Ogre@@QAEAAV01@ABV01@@Z ; Ogre::HardwarePixelBufferManager::operator=
; Function compile flags: /Odtp
;	COMDAT ??4HardwarePixelBufferManager@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4HardwarePixelBufferManager@Ogre@@QAEAAV01@ABV01@@Z PROC ; Ogre::HardwarePixelBufferManager::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??4?$map@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@@std@@QAEAAV01@ABV01@@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	DWORD PTR [ecx+36], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4HardwarePixelBufferManager@Ogre@@QAEAAV01@ABV01@@Z ENDP ; Ogre::HardwarePixelBufferManager::operator=
_TEXT	ENDS
PUBLIC	??1HardwarePixelBufferManager@Ogre@@UAE@XZ	; Ogre::HardwarePixelBufferManager::~HardwarePixelBufferManager
PUBLIC	??_GHardwarePixelBufferManager@Ogre@@UAEPAXI@Z	; Ogre::HardwarePixelBufferManager::`scalar deleting destructor'
; Function compile flags: /Odtp
;	COMDAT ??_GHardwarePixelBufferManager@Ogre@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GHardwarePixelBufferManager@Ogre@@UAEPAXI@Z PROC	; Ogre::HardwarePixelBufferManager::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1HardwarePixelBufferManager@Ogre@@UAE@XZ ; Ogre::HardwarePixelBufferManager::~HardwarePixelBufferManager
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@17
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@17:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GHardwarePixelBufferManager@Ogre@@UAEPAXI@Z ENDP	; Ogre::HardwarePixelBufferManager::`scalar deleting destructor'
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_EHardwarePixelBufferManager@Ogre@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_EHardwarePixelBufferManager@Ogre@@UAEPAXI@Z PROC	; Ogre::HardwarePixelBufferManager::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 2
	je	SHORT $LN3@vector@17
	push	OFFSET ??1HardwarePixelBufferManager@Ogre@@UAE@XZ ; Ogre::HardwarePixelBufferManager::~HardwarePixelBufferManager
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx-4]
	push	edx
	push	40					; 00000028H
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??_M@YGXPAXIHP6EX0@Z@Z
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN2@vector@17
	mov	edx, DWORD PTR _this$[ebp]
	sub	edx, 4
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN2@vector@17:
	mov	eax, DWORD PTR _this$[ebp]
	sub	eax, 4
	jmp	SHORT $LN4@vector@17
$LN3@vector@17:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1HardwarePixelBufferManager@Ogre@@UAE@XZ ; Ogre::HardwarePixelBufferManager::~HardwarePixelBufferManager
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@vector@17
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@vector@17:
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector@17:
	mov	esp, ebp
	pop	ebp
	ret	4
??_EHardwarePixelBufferManager@Ogre@@UAEPAXI@Z ENDP	; Ogre::HardwarePixelBufferManager::`vector deleting destructor'
_TEXT	ENDS
PUBLIC	??1?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::~_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >
PUBLIC	??0?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@ABV01@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$map@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$map@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@@std@@QAE@ABV01@@Z$0
__ehfuncinfo$??0?$map@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@@std@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$map@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$map@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0?$map@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@@std@@QAE@ABV01@@Z PROC ; std::map<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> > >::map<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> > >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$map@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@ABV01@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$map@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@@std@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::~_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >
__ehhandler$??0?$map@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$map@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$map@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@@std@@QAE@ABV01@@Z ENDP ; std::map<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> > >::map<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> > >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$map@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$map@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@@std@@QAE@XZ$0
__ehfuncinfo$??1?$map@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$map@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$map@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$map@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@@std@@QAE@XZ PROC ; std::map<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> > >::~map<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> > >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$map@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::~_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$map@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::~_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >
__ehhandler$??1?$map@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$map@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$map@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@@std@@QAE@XZ ENDP ; std::map<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> > >::~map<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> > >
PUBLIC	??4?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAEAAV01@ABV01@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::operator=
; Function compile flags: /Odtp
;	COMDAT ??4?$map@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4?$map@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@@std@@QAEAAV01@ABV01@@Z PROC ; std::map<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> > >::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAEAAV01@ABV01@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::operator=
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4?$map@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@@std@@QAEAAV01@ABV01@@Z ENDP ; std::map<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> > >::operator=
_TEXT	ENDS
PUBLIC	??4Timer@Ogre@@QAEAAV01@ABV01@@Z		; Ogre::Timer::operator=
; Function compile flags: /Odtp
;	COMDAT ??4Timer@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4Timer@Ogre@@QAEAAV01@ABV01@@Z PROC			; Ogre::Timer::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	esi, DWORD PTR ___that$[ebp]
	mov	ecx, 10					; 0000000aH
	mov	edi, DWORD PTR _this$[ebp]
	rep movsd
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
??4Timer@Ogre@@QAEAAV01@ABV01@@Z ENDP			; Ogre::Timer::operator=
_TEXT	ENDS
PUBLIC	??0?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >
PUBLIC	??0HardwarePixelBufferPool@Ogre@@QAE@W4HardwareBufferUsage@1@ABUTextureDesc@1@@Z ; Ogre::HardwarePixelBufferPool::HardwarePixelBufferPool
EXTRN	??0LockSection@Ogre@@QAE@XZ:PROC		; Ogre::LockSection::LockSection
xdata$x	SEGMENT
__unwindtable$??0HardwarePixelBufferPool@Ogre@@QAE@W4HardwareBufferUsage@1@ABUTextureDesc@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0HardwarePixelBufferPool@Ogre@@QAE@W4HardwareBufferUsage@1@ABUTextureDesc@1@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0HardwarePixelBufferPool@Ogre@@QAE@W4HardwareBufferUsage@1@ABUTextureDesc@1@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0HardwarePixelBufferPool@Ogre@@QAE@W4HardwareBufferUsage@1@ABUTextureDesc@1@@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$??0HardwarePixelBufferPool@Ogre@@QAE@W4HardwareBufferUsage@1@ABUTextureDesc@1@@Z$3
__ehfuncinfo$??0HardwarePixelBufferPool@Ogre@@QAE@W4HardwareBufferUsage@1@ABUTextureDesc@1@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$??0HardwarePixelBufferPool@Ogre@@QAE@W4HardwareBufferUsage@1@ABUTextureDesc@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogrehardwarepixelbuffer.cpp
xdata$x	ENDS
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_usage$ = 8						; size = 4
_desc$ = 12						; size = 4
??0HardwarePixelBufferPool@Ogre@@QAE@W4HardwareBufferUsage@1@ABUTextureDesc@1@@Z PROC ; Ogre::HardwarePixelBufferPool::HardwarePixelBufferPool
; _this$ = ecx

; 10   : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0HardwarePixelBufferPool@Ogre@@QAE@W4HardwareBufferUsage@1@ABUTextureDesc@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7HardwarePixelBufferPool@Ogre@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _usage$[ebp]
	mov	DWORD PTR [ecx+4], edx
	mov	esi, DWORD PTR _desc$[ebp]
	mov	edi, DWORD PTR _this$[ebp]
	add	edi, 8
	mov	ecx, 7
	rep movsd
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??0?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 60					; 0000003cH
	call	??0?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 84					; 00000054H
	call	??0LockSection@Ogre@@QAE@XZ		; Ogre::LockSection::LockSection
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 88					; 00000058H
	call	??0LockSection@Ogre@@QAE@XZ		; Ogre::LockSection::LockSection
	mov	BYTE PTR __$EHRec$[ebp+8], 3

; 11   : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$??0HardwarePixelBufferPool@Ogre@@QAE@W4HardwareBufferUsage@1@ABUTextureDesc@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	jmp	??1?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::~vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >
__unwindfunclet$??0HardwarePixelBufferPool@Ogre@@QAE@W4HardwareBufferUsage@1@ABUTextureDesc@1@@Z$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 60					; 0000003cH
	jmp	??1?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::~vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >
__unwindfunclet$??0HardwarePixelBufferPool@Ogre@@QAE@W4HardwareBufferUsage@1@ABUTextureDesc@1@@Z$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 84					; 00000054H
	jmp	??1LockSection@Ogre@@QAE@XZ		; Ogre::LockSection::~LockSection
__unwindfunclet$??0HardwarePixelBufferPool@Ogre@@QAE@W4HardwareBufferUsage@1@ABUTextureDesc@1@@Z$3:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 88					; 00000058H
	jmp	??1LockSection@Ogre@@QAE@XZ		; Ogre::LockSection::~LockSection
__ehhandler$??0HardwarePixelBufferPool@Ogre@@QAE@W4HardwareBufferUsage@1@ABUTextureDesc@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0HardwarePixelBufferPool@Ogre@@QAE@W4HardwareBufferUsage@1@ABUTextureDesc@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0HardwarePixelBufferPool@Ogre@@QAE@W4HardwareBufferUsage@1@ABUTextureDesc@1@@Z ENDP ; Ogre::HardwarePixelBufferPool::HardwarePixelBufferPool
xdata$x	SEGMENT
__unwindtable$??1HardwarePixelBufferPool@Ogre@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1HardwarePixelBufferPool@Ogre@@UAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1HardwarePixelBufferPool@Ogre@@UAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??1HardwarePixelBufferPool@Ogre@@UAE@XZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$??1HardwarePixelBufferPool@Ogre@@UAE@XZ$3
__ehfuncinfo$??1HardwarePixelBufferPool@Ogre@@UAE@XZ DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$??1HardwarePixelBufferPool@Ogre@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1HardwarePixelBufferPool@Ogre@@UAE@XZ PROC		; Ogre::HardwarePixelBufferPool::~HardwarePixelBufferPool
; _this$ = ecx

; 14   : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1HardwarePixelBufferPool@Ogre@@UAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7HardwarePixelBufferPool@Ogre@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], 3

; 15   : 	}

	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 88					; 00000058H
	call	??1LockSection@Ogre@@QAE@XZ		; Ogre::LockSection::~LockSection
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 84					; 00000054H
	call	??1LockSection@Ogre@@QAE@XZ		; Ogre::LockSection::~LockSection
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 60					; 0000003cH
	call	??1?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::~vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??1?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::~vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$??1HardwarePixelBufferPool@Ogre@@UAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	jmp	??1?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::~vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >
__unwindfunclet$??1HardwarePixelBufferPool@Ogre@@UAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 60					; 0000003cH
	jmp	??1?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::~vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >
__unwindfunclet$??1HardwarePixelBufferPool@Ogre@@UAE@XZ$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 84					; 00000054H
	jmp	??1LockSection@Ogre@@QAE@XZ		; Ogre::LockSection::~LockSection
__unwindfunclet$??1HardwarePixelBufferPool@Ogre@@UAE@XZ$3:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 88					; 00000058H
	jmp	??1LockSection@Ogre@@QAE@XZ		; Ogre::LockSection::~LockSection
__ehhandler$??1HardwarePixelBufferPool@Ogre@@UAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1HardwarePixelBufferPool@Ogre@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1HardwarePixelBufferPool@Ogre@@UAE@XZ ENDP		; Ogre::HardwarePixelBufferPool::~HardwarePixelBufferPool
PUBLIC	?push_back@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QAEXABQAVHardwarePixelBuffer@Ogre@@@Z ; std::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::push_back
PUBLIC	?pop_back@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QAEXXZ ; std::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::pop_back
PUBLIC	?back@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QAEAAPAVHardwarePixelBuffer@Ogre@@XZ ; std::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::back
PUBLIC	?empty@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QBE_NXZ ; std::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::empty
PUBLIC	?allocBuffer@HardwarePixelBufferPool@Ogre@@QAEPAVHardwarePixelBuffer@2@XZ ; Ogre::HardwarePixelBufferPool::allocBuffer
xdata$x	SEGMENT
__unwindtable$?allocBuffer@HardwarePixelBufferPool@Ogre@@QAEPAVHardwarePixelBuffer@2@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?allocBuffer@HardwarePixelBufferPool@Ogre@@QAEPAVHardwarePixelBuffer@2@XZ$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?allocBuffer@HardwarePixelBufferPool@Ogre@@QAEPAVHardwarePixelBuffer@2@XZ$1
__ehfuncinfo$?allocBuffer@HardwarePixelBufferPool@Ogre@@QAEPAVHardwarePixelBuffer@2@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?allocBuffer@HardwarePixelBufferPool@Ogre@@QAEPAVHardwarePixelBuffer@2@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
_TEXT	SEGMENT
_this$ = -28						; size = 4
_locker$62389 = -24					; size = 4
_locker$62386 = -20					; size = 4
_pbuf$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
?allocBuffer@HardwarePixelBufferPool@Ogre@@QAEPAVHardwarePixelBuffer@2@XZ PROC ; Ogre::HardwarePixelBufferPool::allocBuffer
; _this$ = ecx

; 18   : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?allocBuffer@HardwarePixelBufferPool@Ogre@@QAEPAVHardwarePixelBuffer@2@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 16					; 00000010H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 19   : 		HardwarePixelBuffer *pbuf = NULL;

	mov	DWORD PTR _pbuf$[ebp], 0

; 20   : 
; 21   : 		{
; 22   : 			LockFunctor locker(&m_FreeBufferMutex);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 84					; 00000054H
	push	eax
	lea	ecx, DWORD PTR _locker$62386[ebp]
	call	??0LockFunctor@Ogre@@QAE@PAVLockSection@1@@Z ; Ogre::LockFunctor::LockFunctor
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 23   : 			if (!m_FreeBuffers.empty())

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	?empty@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QBE_NXZ ; std::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::empty
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN2@allocBuffe

; 24   : 			{
; 25   : 				pbuf = m_FreeBuffers.back();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	?back@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QAEAAPAVHardwarePixelBuffer@Ogre@@XZ ; std::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::back
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR _pbuf$[ebp], edx

; 26   : 				m_FreeBuffers.pop_back();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	?pop_back@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QAEXXZ ; std::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::pop_back
$LN2@allocBuffe:

; 27   : 			}
; 28   : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _locker$62386[ebp]
	call	??1LockFunctor@Ogre@@QAE@XZ		; Ogre::LockFunctor::~LockFunctor

; 29   : 		if (pbuf == NULL)

	cmp	DWORD PTR _pbuf$[ebp], 0
	jne	SHORT $LN1@allocBuffe

; 30   : 		{
; 31   : 			pbuf = newPixelBuffer();

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	call	eax
	mov	DWORD PTR _pbuf$[ebp], eax

; 32   : 			pbuf->m_pPool = this;

	mov	ecx, DWORD PTR _pbuf$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], edx
$LN1@allocBuffe:

; 33   : 		}
; 34   : 
; 35   : 		pbuf->m_DataInvalid = true;

	mov	eax, DWORD PTR _pbuf$[ebp]
	mov	BYTE PTR [eax+4], 1

; 36   : 		pbuf->addRef();

	mov	ecx, DWORD PTR _pbuf$[ebp]
	call	?addRef@HardwarePixelBuffer@Ogre@@QAEXXZ ; Ogre::HardwarePixelBuffer::addRef

; 37   : 
; 38   : 		{
; 39   : 			LockFunctor locker(&m_UsedBufferMutex);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 88					; 00000058H
	push	ecx
	lea	ecx, DWORD PTR _locker$62389[ebp]
	call	??0LockFunctor@Ogre@@QAE@PAVLockSection@1@@Z ; Ogre::LockFunctor::LockFunctor
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 40   : 			m_UsedBuffers.push_back(pbuf);

	lea	edx, DWORD PTR _pbuf$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 60					; 0000003cH
	call	?push_back@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QAEXABQAVHardwarePixelBuffer@Ogre@@@Z ; std::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::push_back

; 41   : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _locker$62389[ebp]
	call	??1LockFunctor@Ogre@@QAE@XZ		; Ogre::LockFunctor::~LockFunctor

; 42   : 
; 43   : 		return pbuf;

	mov	eax, DWORD PTR _pbuf$[ebp]

; 44   : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?allocBuffer@HardwarePixelBufferPool@Ogre@@QAEPAVHardwarePixelBuffer@2@XZ$0:
	lea	ecx, DWORD PTR _locker$62386[ebp]
	jmp	??1LockFunctor@Ogre@@QAE@XZ		; Ogre::LockFunctor::~LockFunctor
__unwindfunclet$?allocBuffer@HardwarePixelBufferPool@Ogre@@QAEPAVHardwarePixelBuffer@2@XZ$1:
	lea	ecx, DWORD PTR _locker$62389[ebp]
	jmp	??1LockFunctor@Ogre@@QAE@XZ		; Ogre::LockFunctor::~LockFunctor
__ehhandler$?allocBuffer@HardwarePixelBufferPool@Ogre@@QAEPAVHardwarePixelBuffer@2@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?allocBuffer@HardwarePixelBufferPool@Ogre@@QAEPAVHardwarePixelBuffer@2@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?allocBuffer@HardwarePixelBufferPool@Ogre@@QAEPAVHardwarePixelBuffer@2@XZ ENDP ; Ogre::HardwarePixelBufferPool::allocBuffer
PUBLIC	??A?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QAEAAPAVHardwarePixelBuffer@Ogre@@I@Z ; std::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::operator[]
PUBLIC	?size@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::size
PUBLIC	??E?$_Vector_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::operator++
PUBLIC	?getSingleton@?$Singleton@VHardwarePixelBufferManager@Ogre@@@Ogre@@SAAAVHardwarePixelBufferManager@2@XZ ; Ogre::Singleton<Ogre::HardwarePixelBufferManager>::getSingleton
PUBLIC	?erase@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@2@@Z ; std::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::erase
PUBLIC	??D?$_Vector_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QBEAAPAVHardwarePixelBuffer@Ogre@@XZ ; std::_Vector_iterator<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::operator*
PUBLIC	??9?$_Vector_const_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::operator!=
PUBLIC	?end@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@2@XZ ; std::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::end
PUBLIC	?begin@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@2@XZ ; std::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::begin
PUBLIC	?clear@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QAEXXZ ; std::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::clear
PUBLIC	?garbageCollect@HardwarePixelBufferPool@Ogre@@QAEXI@Z ; Ogre::HardwarePixelBufferPool::garbageCollect
EXTRN	_atexit:PROC
;	COMDAT ?freeBuffers@?1??garbageCollect@HardwarePixelBufferPool@Ogre@@QAEXI@Z@4V?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@A
_BSS	SEGMENT
?freeBuffers@?1??garbageCollect@HardwarePixelBufferPool@Ogre@@QAEXI@Z@4V?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@A DB 018H DUP (?) ; `Ogre::HardwarePixelBufferPool::garbageCollect'::`2'::freeBuffers
_BSS	ENDS
;	COMDAT ?$S1@?1??garbageCollect@HardwarePixelBufferPool@Ogre@@QAEXI@Z@4IA
_BSS	SEGMENT
?$S1@?1??garbageCollect@HardwarePixelBufferPool@Ogre@@QAEXI@Z@4IA DD 01H DUP (?) ; `Ogre::HardwarePixelBufferPool::garbageCollect'::`2'::$S1
_BSS	ENDS
xdata$x	SEGMENT
__unwindtable$?garbageCollect@HardwarePixelBufferPool@Ogre@@QAEXI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?garbageCollect@HardwarePixelBufferPool@Ogre@@QAEXI@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?garbageCollect@HardwarePixelBufferPool@Ogre@@QAEXI@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?garbageCollect@HardwarePixelBufferPool@Ogre@@QAEXI@Z$2
__ehfuncinfo$?garbageCollect@HardwarePixelBufferPool@Ogre@@QAEXI@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?garbageCollect@HardwarePixelBufferPool@Ogre@@QAEXI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
_TEXT	SEGMENT
tv205 = -116						; size = 4
_this$ = -112						; size = 4
$T72130 = -108						; size = 4
$T72129 = -104						; size = 4
$T72128 = -100						; size = 8
$T72127 = -92						; size = 8
$T72126 = -84						; size = 8
$T72125 = -76						; size = 8
$T72124 = -68						; size = 8
$T72123 = -60						; size = 8
_pbuf$62595 = -52					; size = 4
_iter$62589 = -48					; size = 8
_j$62581 = -40						; size = 4
_i$62580 = -36						; size = 4
_locker$62579 = -32					; size = 4
_pbuf$62574 = -28					; size = 4
_iter$62568 = -24					; size = 8
_locker$62405 = -16					; size = 4
__$EHRec$ = -12						; size = 12
_curtime$ = 8						; size = 4
?garbageCollect@HardwarePixelBufferPool@Ogre@@QAEXI@Z PROC ; Ogre::HardwarePixelBufferPool::garbageCollect
; _this$ = ecx

; 60   : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?garbageCollect@HardwarePixelBufferPool@Ogre@@QAEXI@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 104				; 00000068H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 61   : 		static std::vector<HardwarePixelBuffer *> freeBuffers;

	mov	eax, DWORD PTR ?$S1@?1??garbageCollect@HardwarePixelBufferPool@Ogre@@QAEXI@Z@4IA
	and	eax, 1
	jne	SHORT $LN12@garbageCol
	mov	ecx, DWORD PTR ?$S1@?1??garbageCollect@HardwarePixelBufferPool@Ogre@@QAEXI@Z@4IA
	or	ecx, 1
	mov	DWORD PTR ?$S1@?1??garbageCollect@HardwarePixelBufferPool@Ogre@@QAEXI@Z@4IA, ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, OFFSET ?freeBuffers@?1??garbageCollect@HardwarePixelBufferPool@Ogre@@QAEXI@Z@4V?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@A
	call	??0?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >
	push	OFFSET ??__FfreeBuffers@?1??garbageCollect@HardwarePixelBufferPool@Ogre@@QAEXI@Z@YAXXZ ; `Ogre::HardwarePixelBufferPool::garbageCollect'::`2'::`dynamic atexit destructor for 'freeBuffers''
	call	_atexit
	add	esp, 4
	mov	DWORD PTR __$EHRec$[ebp+8], -1
$LN12@garbageCol:

; 62   : 		freeBuffers.clear();

	mov	ecx, OFFSET ?freeBuffers@?1??garbageCollect@HardwarePixelBufferPool@Ogre@@QAEXI@Z@4V?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@A
	call	?clear@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QAEXXZ ; std::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::clear

; 63   : 
; 64   : 		{
; 65   : 			LockFunctor locker(&m_UsedBufferMutex);

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 88					; 00000058H
	push	edx
	lea	ecx, DWORD PTR _locker$62405[ebp]
	call	??0LockFunctor@Ogre@@QAE@PAVLockSection@1@@Z ; Ogre::LockFunctor::LockFunctor
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 66   : 			for (std::vector<HardwarePixelBuffer *>::iterator iter = m_UsedBuffers.begin();

	lea	eax, DWORD PTR _iter$62568[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 60					; 0000003cH
	call	?begin@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@2@XZ ; std::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::begin
$LN11@garbageCol:

; 67   : 				iter != m_UsedBuffers.end();)

	lea	ecx, DWORD PTR $T72123[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 60					; 0000003cH
	call	?end@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@2@XZ ; std::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::end
	push	eax
	lea	ecx, DWORD PTR _iter$62568[ebp]
	call	??9?$_Vector_const_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::operator!=
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN10@garbageCol

; 68   : 			{
; 69   : 				HardwarePixelBuffer *pbuf = *iter;

	lea	ecx, DWORD PTR _iter$62568[ebp]
	call	??D?$_Vector_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QBEAAPAVHardwarePixelBuffer@Ogre@@XZ ; std::_Vector_iterator<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::operator*
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR _pbuf$62574[ebp], eax

; 70   : 				if(pbuf->m_RefCount == 0)

	mov	ecx, DWORD PTR _pbuf$62574[ebp]
	cmp	DWORD PTR [ecx+8], 0
	jne	SHORT $LN9@garbageCol

; 71   : 				{
; 72   : 					iter = m_UsedBuffers.erase(iter);

	mov	edx, DWORD PTR _iter$62568[ebp]
	mov	DWORD PTR $T72124[ebp], edx
	mov	eax, DWORD PTR _iter$62568[ebp+4]
	mov	DWORD PTR $T72124[ebp+4], eax
	mov	ecx, DWORD PTR $T72124[ebp+4]
	push	ecx
	mov	edx, DWORD PTR $T72124[ebp]
	push	edx
	lea	eax, DWORD PTR $T72125[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 60					; 0000003cH
	call	?erase@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@2@@Z ; std::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::erase
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _iter$62568[ebp], ecx
	mov	DWORD PTR _iter$62568[ebp+4], edx

; 73   : 					pbuf->m_FreeTime = HardwarePixelBufferManager::getSingleton().getCurTime();

	call	?getSingleton@?$Singleton@VHardwarePixelBufferManager@Ogre@@@Ogre@@SAAAVHardwarePixelBufferManager@2@XZ ; Ogre::Singleton<Ogre::HardwarePixelBufferManager>::getSingleton
	mov	ecx, eax
	call	?getCurTime@HardwarePixelBufferManager@Ogre@@QAEIXZ ; Ogre::HardwarePixelBufferManager::getCurTime
	mov	ecx, DWORD PTR _pbuf$62574[ebp]
	mov	DWORD PTR [ecx+16], eax

; 74   : 					freeBuffers.push_back(pbuf);

	lea	edx, DWORD PTR _pbuf$62574[ebp]
	push	edx
	mov	ecx, OFFSET ?freeBuffers@?1??garbageCollect@HardwarePixelBufferPool@Ogre@@QAEXI@Z@4V?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@A
	call	?push_back@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QAEXABQAVHardwarePixelBuffer@Ogre@@@Z ; std::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::push_back

; 75   : 				}
; 76   : 				else

	jmp	SHORT $LN8@garbageCol
$LN9@garbageCol:

; 77   : 				{
; 78   : 					++iter;

	lea	ecx, DWORD PTR _iter$62568[ebp]
	call	??E?$_Vector_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::operator++
$LN8@garbageCol:

; 79   : 				}
; 80   : 			}

	jmp	$LN11@garbageCol
$LN10@garbageCol:

; 81   : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _locker$62405[ebp]
	call	??1LockFunctor@Ogre@@QAE@XZ		; Ogre::LockFunctor::~LockFunctor

; 82   : 
; 83   : 		{
; 84   : 			LockFunctor locker(&m_FreeBufferMutex);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 84					; 00000054H
	push	eax
	lea	ecx, DWORD PTR _locker$62579[ebp]
	call	??0LockFunctor@Ogre@@QAE@PAVLockSection@1@@Z ; Ogre::LockFunctor::LockFunctor
	mov	DWORD PTR __$EHRec$[ebp+8], 2

; 85   : 			for (size_t i = 0, j = freeBuffers.size(); i < j; ++i)

	mov	DWORD PTR _i$62580[ebp], 0
	mov	ecx, OFFSET ?freeBuffers@?1??garbageCollect@HardwarePixelBufferPool@Ogre@@QAEXI@Z@4V?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@A
	call	?size@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::size
	mov	DWORD PTR _j$62581[ebp], eax
	jmp	SHORT $LN7@garbageCol
$LN6@garbageCol:
	mov	ecx, DWORD PTR _i$62580[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$62580[ebp], ecx
$LN7@garbageCol:
	mov	edx, DWORD PTR _i$62580[ebp]
	cmp	edx, DWORD PTR _j$62581[ebp]
	jae	SHORT $LN5@garbageCol

; 86   : 			{
; 87   : 				m_FreeBuffers.push_back(freeBuffers[i]);

	mov	eax, DWORD PTR _i$62580[ebp]
	push	eax
	mov	ecx, OFFSET ?freeBuffers@?1??garbageCollect@HardwarePixelBufferPool@Ogre@@QAEXI@Z@4V?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@A
	call	??A?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QAEAAPAVHardwarePixelBuffer@Ogre@@I@Z ; std::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::operator[]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	?push_back@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QAEXABQAVHardwarePixelBuffer@Ogre@@@Z ; std::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::push_back

; 88   : 			}

	jmp	SHORT $LN6@garbageCol
$LN5@garbageCol:

; 89   : 
; 90   : 			for (std::vector<HardwarePixelBuffer *>::iterator iter = m_FreeBuffers.begin();

	lea	ecx, DWORD PTR _iter$62589[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	?begin@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@2@XZ ; std::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::begin
$LN4@garbageCol:

; 91   : 				iter != m_FreeBuffers.end();)

	lea	edx, DWORD PTR $T72126[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	?end@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@2@XZ ; std::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::end
	push	eax
	lea	ecx, DWORD PTR _iter$62589[ebp]
	call	??9?$_Vector_const_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::operator!=
	movzx	eax, al
	test	eax, eax
	je	$LN3@garbageCol

; 92   : 			{
; 93   : 				HardwarePixelBuffer *pbuf = *iter;

	lea	ecx, DWORD PTR _iter$62589[ebp]
	call	??D?$_Vector_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QBEAAPAVHardwarePixelBuffer@Ogre@@XZ ; std::_Vector_iterator<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::operator*
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _pbuf$62595[ebp], ecx

; 94   : 				if(curtime > pbuf->m_FreeTime + 30000) //60s

	mov	edx, DWORD PTR _pbuf$62595[ebp]
	mov	eax, DWORD PTR [edx+16]
	add	eax, 30000				; 00007530H
	cmp	DWORD PTR _curtime$[ebp], eax
	jbe	SHORT $LN2@garbageCol

; 95   : 				{
; 96   : 					iter = m_FreeBuffers.erase(iter);

	mov	ecx, DWORD PTR _iter$62589[ebp]
	mov	DWORD PTR $T72127[ebp], ecx
	mov	edx, DWORD PTR _iter$62589[ebp+4]
	mov	DWORD PTR $T72127[ebp+4], edx
	mov	eax, DWORD PTR $T72127[ebp+4]
	push	eax
	mov	ecx, DWORD PTR $T72127[ebp]
	push	ecx
	lea	edx, DWORD PTR $T72128[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	?erase@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@2@@Z ; std::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::erase
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _iter$62589[ebp], ecx
	mov	DWORD PTR _iter$62589[ebp+4], edx

; 97   : 					delete pbuf;

	mov	eax, DWORD PTR _pbuf$62595[ebp]
	mov	DWORD PTR $T72130[ebp], eax
	mov	ecx, DWORD PTR $T72130[ebp]
	mov	DWORD PTR $T72129[ebp], ecx
	cmp	DWORD PTR $T72129[ebp], 0
	je	SHORT $LN15@garbageCol
	push	1
	mov	edx, DWORD PTR $T72129[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR $T72129[ebp]
	mov	edx, DWORD PTR [eax+12]
	call	edx
	mov	DWORD PTR tv205[ebp], eax
	jmp	SHORT $LN16@garbageCol
$LN15@garbageCol:
	mov	DWORD PTR tv205[ebp], 0
$LN16@garbageCol:

; 98   : 				}
; 99   : 				else

	jmp	SHORT $LN1@garbageCol
$LN2@garbageCol:

; 100  : 				{
; 101  : 					++iter;

	lea	ecx, DWORD PTR _iter$62589[ebp]
	call	??E?$_Vector_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::operator++
$LN1@garbageCol:

; 102  : 				}
; 103  : 			}

	jmp	$LN4@garbageCol
$LN3@garbageCol:

; 104  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _locker$62579[ebp]
	call	??1LockFunctor@Ogre@@QAE@XZ		; Ogre::LockFunctor::~LockFunctor

; 105  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?garbageCollect@HardwarePixelBufferPool@Ogre@@QAEXI@Z$0:
	mov	eax, DWORD PTR ?$S1@?1??garbageCollect@HardwarePixelBufferPool@Ogre@@QAEXI@Z@4IA
	and	eax, -2					; fffffffeH
	mov	DWORD PTR ?$S1@?1??garbageCollect@HardwarePixelBufferPool@Ogre@@QAEXI@Z@4IA, eax
	ret	0
__unwindfunclet$?garbageCollect@HardwarePixelBufferPool@Ogre@@QAEXI@Z$1:
	lea	ecx, DWORD PTR _locker$62405[ebp]
	jmp	??1LockFunctor@Ogre@@QAE@XZ		; Ogre::LockFunctor::~LockFunctor
__unwindfunclet$?garbageCollect@HardwarePixelBufferPool@Ogre@@QAEXI@Z$2:
	lea	ecx, DWORD PTR _locker$62579[ebp]
	jmp	??1LockFunctor@Ogre@@QAE@XZ		; Ogre::LockFunctor::~LockFunctor
__ehhandler$?garbageCollect@HardwarePixelBufferPool@Ogre@@QAEXI@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-108]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?garbageCollect@HardwarePixelBufferPool@Ogre@@QAEXI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?garbageCollect@HardwarePixelBufferPool@Ogre@@QAEXI@Z ENDP ; Ogre::HardwarePixelBufferPool::garbageCollect
; Function compile flags: /Odtp
;	COMDAT ??__FfreeBuffers@?1??garbageCollect@HardwarePixelBufferPool@Ogre@@QAEXI@Z@YAXXZ
text$yd	SEGMENT
??__FfreeBuffers@?1??garbageCollect@HardwarePixelBufferPool@Ogre@@QAEXI@Z@YAXXZ PROC ; `Ogre::HardwarePixelBufferPool::garbageCollect'::`2'::`dynamic atexit destructor for 'freeBuffers'', COMDAT
	push	ebp
	mov	ebp, esp
	mov	ecx, OFFSET ?freeBuffers@?1??garbageCollect@HardwarePixelBufferPool@Ogre@@QAEXI@Z@4V?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@A
	call	??1?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::~vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >
	pop	ebp
	ret	0
??__FfreeBuffers@?1??garbageCollect@HardwarePixelBufferPool@Ogre@@QAEXI@Z@YAXXZ ENDP ; `Ogre::HardwarePixelBufferPool::garbageCollect'::`2'::`dynamic atexit destructor for 'freeBuffers''
text$yd	ENDS
PUBLIC	??0?$map@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@@std@@QAE@XZ ; std::map<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> > >::map<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> > >
PUBLIC	??0?$Singleton@VHardwarePixelBufferManager@Ogre@@@Ogre@@QAE@XZ ; Ogre::Singleton<Ogre::HardwarePixelBufferManager>::Singleton<Ogre::HardwarePixelBufferManager>
PUBLIC	??0HardwarePixelBufferManager@Ogre@@QAE@XZ	; Ogre::HardwarePixelBufferManager::HardwarePixelBufferManager
EXTRN	?getSystemTick@Timer@Ogre@@SAIXZ:PROC		; Ogre::Timer::getSystemTick
xdata$x	SEGMENT
__unwindtable$??0HardwarePixelBufferManager@Ogre@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0HardwarePixelBufferManager@Ogre@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0HardwarePixelBufferManager@Ogre@@QAE@XZ$1
__ehfuncinfo$??0HardwarePixelBufferManager@Ogre@@QAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0HardwarePixelBufferManager@Ogre@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0HardwarePixelBufferManager@Ogre@@QAE@XZ PROC		; Ogre::HardwarePixelBufferManager::HardwarePixelBufferManager
; _this$ = ecx

; 108  : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0HardwarePixelBufferManager@Ogre@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??0?$Singleton@VHardwarePixelBufferManager@Ogre@@@Ogre@@QAE@XZ ; Ogre::Singleton<Ogre::HardwarePixelBufferManager>::Singleton<Ogre::HardwarePixelBufferManager>
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7HardwarePixelBufferManager@Ogre@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??0?$map@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@@std@@QAE@XZ ; std::map<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> > >::map<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> > >
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 109  : 		m_CurTime = Timer::getSystemTick();

	call	?getSystemTick@Timer@Ogre@@SAIXZ	; Ogre::Timer::getSystemTick
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+36], eax

; 110  : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$??0HardwarePixelBufferManager@Ogre@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	jmp	??1?$Singleton@VHardwarePixelBufferManager@Ogre@@@Ogre@@QAE@XZ ; Ogre::Singleton<Ogre::HardwarePixelBufferManager>::~Singleton<Ogre::HardwarePixelBufferManager>
__unwindfunclet$??0HardwarePixelBufferManager@Ogre@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	jmp	??1?$map@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@@std@@QAE@XZ
__ehhandler$??0HardwarePixelBufferManager@Ogre@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0HardwarePixelBufferManager@Ogre@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0HardwarePixelBufferManager@Ogre@@QAE@XZ ENDP		; Ogre::HardwarePixelBufferManager::HardwarePixelBufferManager
PUBLIC	??Citerator@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QBEPAU?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::iterator::operator->
PUBLIC	??9const_iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::const_iterator::operator!=
PUBLIC	?end@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::end
PUBLIC	??Eiterator@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AV012@H@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::iterator::operator++
PUBLIC	?begin@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::begin
xdata$x	SEGMENT
__unwindtable$??1HardwarePixelBufferManager@Ogre@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1HardwarePixelBufferManager@Ogre@@UAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1HardwarePixelBufferManager@Ogre@@UAE@XZ$1
__ehfuncinfo$??1HardwarePixelBufferManager@Ogre@@UAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??1HardwarePixelBufferManager@Ogre@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
_TEXT	SEGMENT
tv143 = -52						; size = 4
_this$ = -48						; size = 4
$T72153 = -44						; size = 4
$T72152 = -40						; size = 4
$T72151 = -36						; size = 8
$T72150 = -28						; size = 8
_iter$ = -20						; size = 8
__$EHRec$ = -12						; size = 12
??1HardwarePixelBufferManager@Ogre@@UAE@XZ PROC		; Ogre::HardwarePixelBufferManager::~HardwarePixelBufferManager
; _this$ = ecx

; 113  : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1HardwarePixelBufferManager@Ogre@@UAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 40					; 00000028H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7HardwarePixelBufferManager@Ogre@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 114  : 		std::map<uint, HardwarePixelBufferPool *>::iterator iter = m_Pools.begin();

	lea	ecx, DWORD PTR _iter$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?begin@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::begin
	jmp	SHORT $LN3@HardwarePi@2
$LN2@HardwarePi@2:

; 115  : 		for(; iter!=m_Pools.end(); iter++)

	push	0
	lea	edx, DWORD PTR $T72150[ebp]
	push	edx
	lea	ecx, DWORD PTR _iter$[ebp]
	call	??Eiterator@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AV012@H@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::iterator::operator++
$LN3@HardwarePi@2:
	lea	eax, DWORD PTR $T72151[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?end@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::end
	push	eax
	lea	ecx, DWORD PTR _iter$[ebp]
	call	??9const_iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::const_iterator::operator!=
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN4@HardwarePi@2

; 116  : 		{
; 117  : 			delete iter->second;

	lea	ecx, DWORD PTR _iter$[ebp]
	call	??Citerator@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QBEPAU?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::iterator::operator->
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T72153[ebp], edx
	mov	eax, DWORD PTR $T72153[ebp]
	mov	DWORD PTR $T72152[ebp], eax
	cmp	DWORD PTR $T72152[ebp], 0
	je	SHORT $LN6@HardwarePi@2
	push	1
	mov	ecx, DWORD PTR $T72152[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR $T72152[ebp]
	mov	eax, DWORD PTR [edx]
	call	eax
	mov	DWORD PTR tv143[ebp], eax
	jmp	SHORT $LN7@HardwarePi@2
$LN6@HardwarePi@2:
	mov	DWORD PTR tv143[ebp], 0
$LN7@HardwarePi@2:

; 118  : 		}

	jmp	SHORT $LN2@HardwarePi@2
$LN4@HardwarePi@2:

; 119  : 	}

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??1?$map@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??1?$Singleton@VHardwarePixelBufferManager@Ogre@@@Ogre@@QAE@XZ ; Ogre::Singleton<Ogre::HardwarePixelBufferManager>::~Singleton<Ogre::HardwarePixelBufferManager>
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$??1HardwarePixelBufferManager@Ogre@@UAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	jmp	??1?$Singleton@VHardwarePixelBufferManager@Ogre@@@Ogre@@QAE@XZ ; Ogre::Singleton<Ogre::HardwarePixelBufferManager>::~Singleton<Ogre::HardwarePixelBufferManager>
__unwindfunclet$??1HardwarePixelBufferManager@Ogre@@UAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	jmp	??1?$map@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@@std@@QAE@XZ
__ehhandler$??1HardwarePixelBufferManager@Ogre@@UAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-44]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1HardwarePixelBufferManager@Ogre@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1HardwarePixelBufferManager@Ogre@@UAE@XZ ENDP		; Ogre::HardwarePixelBufferManager::~HardwarePixelBufferManager
PUBLIC	?garbageCollect@HardwarePixelBufferManager@Ogre@@QAEXXZ ; Ogre::HardwarePixelBufferManager::garbageCollect
; Function compile flags: /Odtp
_TEXT	SEGMENT
_this$ = -32						; size = 4
$T72164 = -28						; size = 8
$T72163 = -20						; size = 8
_dtick$ = -12						; size = 4
_iter$ = -8						; size = 8
?garbageCollect@HardwarePixelBufferManager@Ogre@@QAEXXZ PROC ; Ogre::HardwarePixelBufferManager::garbageCollect
; _this$ = ecx

; 122  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	DWORD PTR _this$[ebp], ecx

; 123  : 		uint dtick = Timer::getSystemTick() - m_CurTime;

	call	?getSystemTick@Timer@Ogre@@SAIXZ	; Ogre::Timer::getSystemTick
	mov	ecx, DWORD PTR _this$[ebp]
	sub	eax, DWORD PTR [ecx+36]
	mov	DWORD PTR _dtick$[ebp], eax

; 124  : 		if(dtick > 500) dtick = 500; //loading, 

	cmp	DWORD PTR _dtick$[ebp], 500		; 000001f4H
	jbe	SHORT $LN4@garbageCol@2
	mov	DWORD PTR _dtick$[ebp], 500		; 000001f4H
$LN4@garbageCol@2:

; 125  : 		m_CurTime += dtick;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+36]
	add	eax, DWORD PTR _dtick$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+36], eax

; 126  : 
; 127  : 		std::map<uint, HardwarePixelBufferPool *>::iterator iter = m_Pools.begin();

	lea	edx, DWORD PTR _iter$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?begin@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::begin
	jmp	SHORT $LN3@garbageCol@2
$LN2@garbageCol@2:

; 128  : 		for(; iter!=m_Pools.end(); iter++)

	push	0
	lea	eax, DWORD PTR $T72163[ebp]
	push	eax
	lea	ecx, DWORD PTR _iter$[ebp]
	call	??Eiterator@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AV012@H@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::iterator::operator++
$LN3@garbageCol@2:
	lea	ecx, DWORD PTR $T72164[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?end@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::end
	push	eax
	lea	ecx, DWORD PTR _iter$[ebp]
	call	??9const_iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::const_iterator::operator!=
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN5@garbageCol@2

; 129  : 		{
; 130  : 			(iter->second)->garbageCollect(m_CurTime);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	push	ecx
	lea	ecx, DWORD PTR _iter$[ebp]
	call	??Citerator@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QBEPAU?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::iterator::operator->
	mov	ecx, DWORD PTR [eax+4]
	call	?garbageCollect@HardwarePixelBufferPool@Ogre@@QAEXI@Z ; Ogre::HardwarePixelBufferPool::garbageCollect
	jmp	SHORT $LN2@garbageCol@2
$LN5@garbageCol@2:

; 131  : 		}
; 132  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?garbageCollect@HardwarePixelBufferManager@Ogre@@QAEXXZ ENDP ; Ogre::HardwarePixelBufferManager::garbageCollect
_TEXT	ENDS
PUBLIC	??A?$map@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@@std@@QAEAAPAVHardwarePixelBufferPool@Ogre@@ABI@Z ; std::map<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> > >::operator[]
PUBLIC	??8const_iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::const_iterator::operator==
PUBLIC	?find@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@ABI@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::find
PUBLIC	?createPixelBuffer@HardwarePixelBufferManager@Ogre@@QAEPAVHardwarePixelBuffer@2@W4HardwareBufferUsage@2@ABUTextureDesc@2@@Z ; Ogre::HardwarePixelBufferManager::createPixelBuffer
; Function compile flags: /Odtp
_TEXT	SEGMENT
_this$ = -64						; size = 4
$T72166 = -60						; size = 8
_pool$ = -52						; size = 4
_hash$ = -48						; size = 4
_seed1$ = -44						; size = 4
_seed2$ = -40						; size = 4
_iter$ = -36						; size = 8
_desc$ = -28						; size = 28
_usage$ = 8						; size = 4
_desc_src$ = 12						; size = 4
?createPixelBuffer@HardwarePixelBufferManager@Ogre@@QAEPAVHardwarePixelBuffer@2@W4HardwareBufferUsage@2@ABUTextureDesc@2@@Z PROC ; Ogre::HardwarePixelBufferManager::createPixelBuffer
; _this$ = ecx

; 135  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 136  : 		TextureDesc desc = desc_src;

	mov	esi, DWORD PTR _desc_src$[ebp]
	mov	ecx, 7
	lea	edi, DWORD PTR _desc$[ebp]
	rep movsd

; 137  : 		if(desc.type != TEXTURE_CUBE) desc.cubefaces = 0;

	cmp	DWORD PTR _desc$[ebp], 2
	je	SHORT $LN4@createPixe
	mov	DWORD PTR _desc$[ebp+24], 0
$LN4@createPixe:

; 138  : 		if(desc.type != TEXTURE_VOLUME) desc.depth = 1;

	cmp	DWORD PTR _desc$[ebp], 1
	je	SHORT $LN3@createPixe
	mov	DWORD PTR _desc$[ebp+12], 1
$LN3@createPixe:

; 139  : 
; 140  : 		unsigned int seed1 = 0x7FED7FED;

	mov	DWORD PTR _seed1$[ebp], 2146271213	; 7fed7fedH

; 141  : 		unsigned int seed2 = 0xEEEEEEEE;

	mov	DWORD PTR _seed2$[ebp], -286331154	; eeeeeeeeH

; 142  : 
; 143  : 		//!!!for texture_2d  desc.depth is not used
; 144  : 		uint hash = 0;

	mov	DWORD PTR _hash$[ebp], 0

; 145  : 		hash += hash*seed1 + usage*seed1 + desc.cubefaces*seed2;

	mov	eax, DWORD PTR _hash$[ebp]
	imul	eax, DWORD PTR _seed1$[ebp]
	mov	ecx, DWORD PTR _usage$[ebp]
	imul	ecx, DWORD PTR _seed1$[ebp]
	add	eax, ecx
	mov	edx, DWORD PTR _desc$[ebp+24]
	imul	edx, DWORD PTR _seed2$[ebp]
	add	edx, DWORD PTR _hash$[ebp]
	add	edx, eax
	mov	DWORD PTR _hash$[ebp], edx

; 146  : 		hash += hash*seed1 + desc.depth*seed1 + desc.format*seed2;

	mov	eax, DWORD PTR _hash$[ebp]
	imul	eax, DWORD PTR _seed1$[ebp]
	mov	ecx, DWORD PTR _desc$[ebp+12]
	imul	ecx, DWORD PTR _seed1$[ebp]
	add	eax, ecx
	mov	edx, DWORD PTR _desc$[ebp+20]
	imul	edx, DWORD PTR _seed2$[ebp]
	add	edx, DWORD PTR _hash$[ebp]
	add	edx, eax
	mov	DWORD PTR _hash$[ebp], edx

; 147  : 		hash += hash*seed1 + desc.height*seed1 + desc.nmipmap*seed2;

	mov	eax, DWORD PTR _hash$[ebp]
	imul	eax, DWORD PTR _seed1$[ebp]
	mov	ecx, DWORD PTR _desc$[ebp+8]
	imul	ecx, DWORD PTR _seed1$[ebp]
	add	eax, ecx
	mov	edx, DWORD PTR _desc$[ebp+16]
	imul	edx, DWORD PTR _seed2$[ebp]
	add	edx, DWORD PTR _hash$[ebp]
	add	edx, eax
	mov	DWORD PTR _hash$[ebp], edx

; 148  : 		hash += hash*seed1 + desc.type*seed1 + desc.width*seed2;

	mov	eax, DWORD PTR _hash$[ebp]
	imul	eax, DWORD PTR _seed1$[ebp]
	mov	ecx, DWORD PTR _desc$[ebp]
	imul	ecx, DWORD PTR _seed1$[ebp]
	add	eax, ecx
	mov	edx, DWORD PTR _desc$[ebp+4]
	imul	edx, DWORD PTR _seed2$[ebp]
	add	edx, DWORD PTR _hash$[ebp]
	add	edx, eax
	mov	DWORD PTR _hash$[ebp], edx

; 149  : 
; 150  : 		HardwarePixelBufferPool *pool = NULL;

	mov	DWORD PTR _pool$[ebp], 0

; 151  : 		std::map<uint, HardwarePixelBufferPool *>::iterator iter = m_Pools.find(hash);

	lea	eax, DWORD PTR _hash$[ebp]
	push	eax
	lea	ecx, DWORD PTR _iter$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?find@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@ABI@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::find

; 152  : 		if(iter == m_Pools.end())

	lea	edx, DWORD PTR $T72166[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?end@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::end
	push	eax
	lea	ecx, DWORD PTR _iter$[ebp]
	call	??8const_iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::const_iterator::operator==
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@createPixe

; 153  : 		{
; 154  : 			pool = newPixelBufferPool(usage, desc);

	lea	ecx, DWORD PTR _desc$[ebp]
	push	ecx
	mov	edx, DWORD PTR _usage$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	call	eax
	mov	DWORD PTR _pool$[ebp], eax

; 155  : 			m_Pools[hash] = pool;

	lea	ecx, DWORD PTR _hash$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??A?$map@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@@std@@QAEAAPAVHardwarePixelBufferPool@Ogre@@ABI@Z ; std::map<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> > >::operator[]
	mov	edx, DWORD PTR _pool$[ebp]
	mov	DWORD PTR [eax], edx

; 156  : 		}
; 157  : 		else

	jmp	SHORT $LN1@createPixe
$LN2@createPixe:

; 158  : 		{
; 159  : 			pool = iter->second;

	lea	ecx, DWORD PTR _iter$[ebp]
	call	??Citerator@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QBEPAU?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::iterator::operator->
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR _pool$[ebp], eax
$LN1@createPixe:

; 160  : 			assert(pool->m_Usage==usage && memcmp(&pool->m_Desc, &desc, sizeof(TextureDesc))==0);
; 161  : 		}
; 162  : 		
; 163  : 		return pool->allocBuffer();

	mov	ecx, DWORD PTR _pool$[ebp]
	call	?allocBuffer@HardwarePixelBufferPool@Ogre@@QAEPAVHardwarePixelBuffer@2@XZ ; Ogre::HardwarePixelBufferPool::allocBuffer

; 164  : 	}

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	8
?createPixelBuffer@HardwarePixelBufferManager@Ogre@@QAEPAVHardwarePixelBuffer@2@W4HardwareBufferUsage@2@ABUTextureDesc@2@@Z ENDP ; Ogre::HardwarePixelBufferManager::createPixelBuffer
_TEXT	ENDS
PUBLIC	??0?$Singleton@VHardwareBufferManager@Ogre@@@Ogre@@QAE@XZ ; Ogre::Singleton<Ogre::HardwareBufferManager>::Singleton<Ogre::HardwareBufferManager>
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogresingleton.h
;	COMDAT ??0?$Singleton@VHardwareBufferManager@Ogre@@@Ogre@@QAE@XZ
_TEXT	SEGMENT
tv68 = -8						; size = 4
_this$ = -4						; size = 4
??0?$Singleton@VHardwareBufferManager@Ogre@@@Ogre@@QAE@XZ PROC ; Ogre::Singleton<Ogre::HardwareBufferManager>::Singleton<Ogre::HardwareBufferManager>, COMDAT
; _this$ = ecx

; 64   : 		Singleton( void )

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 65   : 		{
; 66   : 			assert( !ms_Singleton );
; 67   : #if defined( _MSC_VER ) && _MSC_VER < 1200	 
; 68   : 			int offset = (int)(T*)1 - (int)(Singleton <T>*)(T*)1;
; 69   : 			ms_Singleton = (T*)((int)this + offset);
; 70   : #else
; 71   : 			ms_Singleton = static_cast< T* >( this );

	cmp	DWORD PTR _this$[ebp], 0
	je	SHORT $LN3@Singleton
	mov	eax, DWORD PTR _this$[ebp]
	sub	eax, 4
	mov	DWORD PTR tv68[ebp], eax
	jmp	SHORT $LN4@Singleton
$LN3@Singleton:
	mov	DWORD PTR tv68[ebp], 0
$LN4@Singleton:
	mov	ecx, DWORD PTR tv68[ebp]
	mov	DWORD PTR ?ms_Singleton@?$Singleton@VHardwareBufferManager@Ogre@@@Ogre@@1PAVHardwareBufferManager@2@A, ecx ; Ogre::Singleton<Ogre::HardwareBufferManager>::ms_Singleton

; 72   : #endif
; 73   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$Singleton@VHardwareBufferManager@Ogre@@@Ogre@@QAE@XZ ENDP ; Ogre::Singleton<Ogre::HardwareBufferManager>::Singleton<Ogre::HardwareBufferManager>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??1?$Singleton@VHardwareBufferManager@Ogre@@@Ogre@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$Singleton@VHardwareBufferManager@Ogre@@@Ogre@@QAE@XZ PROC ; Ogre::Singleton<Ogre::HardwareBufferManager>::~Singleton<Ogre::HardwareBufferManager>, COMDAT
; _this$ = ecx

; 75   : 		{  assert( ms_Singleton );  ms_Singleton = 0;  }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR ?ms_Singleton@?$Singleton@VHardwareBufferManager@Ogre@@@Ogre@@1PAVHardwareBufferManager@2@A, 0 ; Ogre::Singleton<Ogre::HardwareBufferManager>::ms_Singleton
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$Singleton@VHardwareBufferManager@Ogre@@@Ogre@@QAE@XZ ENDP ; Ogre::Singleton<Ogre::HardwareBufferManager>::~Singleton<Ogre::HardwareBufferManager>
_TEXT	ENDS
PUBLIC	?getSingleton@?$Singleton@VHardwareBufferManager@Ogre@@@Ogre@@SAAAVHardwareBufferManager@2@XZ ; Ogre::Singleton<Ogre::HardwareBufferManager>::getSingleton
; Function compile flags: /Odtp
;	COMDAT ?getSingleton@?$Singleton@VHardwareBufferManager@Ogre@@@Ogre@@SAAAVHardwareBufferManager@2@XZ
_TEXT	SEGMENT
?getSingleton@?$Singleton@VHardwareBufferManager@Ogre@@@Ogre@@SAAAVHardwareBufferManager@2@XZ PROC ; Ogre::Singleton<Ogre::HardwareBufferManager>::getSingleton, COMDAT

; 77   : 		{	assert( ms_Singleton );  return ( *ms_Singleton ); }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR ?ms_Singleton@?$Singleton@VHardwareBufferManager@Ogre@@@Ogre@@1PAVHardwareBufferManager@2@A ; Ogre::Singleton<Ogre::HardwareBufferManager>::ms_Singleton
	pop	ebp
	ret	0
?getSingleton@?$Singleton@VHardwareBufferManager@Ogre@@@Ogre@@SAAAVHardwareBufferManager@2@XZ ENDP ; Ogre::Singleton<Ogre::HardwareBufferManager>::getSingleton
_TEXT	ENDS
PUBLIC	?getSingletonPtr@?$Singleton@VHardwareBufferManager@Ogre@@@Ogre@@SAPAVHardwareBufferManager@2@XZ ; Ogre::Singleton<Ogre::HardwareBufferManager>::getSingletonPtr
; Function compile flags: /Odtp
;	COMDAT ?getSingletonPtr@?$Singleton@VHardwareBufferManager@Ogre@@@Ogre@@SAPAVHardwareBufferManager@2@XZ
_TEXT	SEGMENT
?getSingletonPtr@?$Singleton@VHardwareBufferManager@Ogre@@@Ogre@@SAPAVHardwareBufferManager@2@XZ PROC ; Ogre::Singleton<Ogre::HardwareBufferManager>::getSingletonPtr, COMDAT

; 79   : 		{ return ms_Singleton; }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR ?ms_Singleton@?$Singleton@VHardwareBufferManager@Ogre@@@Ogre@@1PAVHardwareBufferManager@2@A ; Ogre::Singleton<Ogre::HardwareBufferManager>::ms_Singleton
	pop	ebp
	ret	0
?getSingletonPtr@?$Singleton@VHardwareBufferManager@Ogre@@@Ogre@@SAPAVHardwareBufferManager@2@XZ ENDP ; Ogre::Singleton<Ogre::HardwareBufferManager>::getSingletonPtr
_TEXT	ENDS
PUBLIC	??1?$_Tree_val@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::~_Tree_val<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >
PUBLIC	?_Tidy@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Tidy
PUBLIC	?_Copy@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEXABV12@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Copy
PUBLIC	?_Init@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Init
PUBLIC	??0?$_Tree_val@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@1@@Z ; std::_Tree_val<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Tree_val<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >
PUBLIC	?key_comp@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QBE?AU?$less@I@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::key_comp
PUBLIC	?get_allocator@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QBE?AV?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::get_allocator
EXTRN	__CxxThrowException@8:PROC
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
xdata$x	SEGMENT
__catchsym$??0?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@ABV01@@Z$3 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??0?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@ABV01@@Z$0
__tryblocktable$??0?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@ABV01@@Z DD 01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??0?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@ABV01@@Z$3
__unwindtable$??0?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@ABV01@@Z$2
	DD	00H
	DD	00H
	DD	00H
	DD	00H
__ehfuncinfo$??0?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@ABV01@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@ABV01@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??0?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -28						; size = 4
$T72179 = -21						; size = 1
$T72178 = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Right$ = 8						; size = 4
??0?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@ABV01@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >, COMDAT
; _this$ = ecx

; 528  : 		{	// construct tree by copying _Right

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 12					; 0000000cH
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	eax, esp
	mov	DWORD PTR $T72178[ebp], esp
	push	eax
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?get_allocator@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QBE?AV?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::get_allocator
	lea	ecx, DWORD PTR $T72179[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?key_comp@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QBE?AU?$less@I@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::key_comp
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Tree_val@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@1@@Z ; std::_Tree_val<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Tree_val<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >
	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 529  : 		_Init();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Init@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Init

; 530  : 		_TRY_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 1

; 531  : 		_Copy(_Right);

	mov	edx, DWORD PTR __Right$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Copy@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEXABV12@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Copy
	jmp	SHORT $LN4@Tree
__catch$??0?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@ABV01@@Z$0:

; 532  : 		_CATCH_ALL
; 533  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Tidy

; 534  : 		_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 535  : 		_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], 0
	mov	eax, $LN2@Tree
	ret	0
$LN4@Tree:
	mov	DWORD PTR __$EHRec$[ebp+12], 0
$LN2@Tree:

; 536  : 		}

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, DWORD PTR _this$[ebp]
$LN3@Tree:
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@ABV01@@Z$2:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Tree_val@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ
__ehhandler$??0?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-32]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@ABV01@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::~_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >, COMDAT
; _this$ = ecx

; 539  : 		{	// destroy tree

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 540  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Tidy

; 541  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Tree_val@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Tree_val@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ
__ehhandler$??1?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::~_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >
PUBLIC	?erase@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::erase
PUBLIC	?begin@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::begin
PUBLIC	?end@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::end
; Function compile flags: /Odtp
;	COMDAT ??4?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -44						; size = 4
$T72210 = -40						; size = 8
$T72209 = -32						; size = 8
$T72208 = -24						; size = 8
$T72207 = -16						; size = 8
$T72206 = -8						; size = 8
__Right$ = 8						; size = 4
??4?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAEAAV01@ABV01@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::operator=, COMDAT
; _this$ = ecx

; 544  : 		{	// replace contents from _Right

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	mov	DWORD PTR _this$[ebp], ecx

; 545  : 		if (this != &_Right)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR __Right$[ebp]
	je	SHORT $LN1@operator@2

; 546  : 			{	// worth doing
; 547  : 			erase(begin(), end());

	lea	ecx, DWORD PTR $T72207[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::end
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR $T72206[ebp], edx
	mov	DWORD PTR $T72206[ebp+4], eax
	lea	ecx, DWORD PTR $T72209[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::begin
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR $T72208[ebp], edx
	mov	DWORD PTR $T72208[ebp+4], eax
	mov	ecx, DWORD PTR $T72206[ebp+4]
	push	ecx
	mov	edx, DWORD PTR $T72206[ebp]
	push	edx
	mov	eax, DWORD PTR $T72208[ebp+4]
	push	eax
	mov	ecx, DWORD PTR $T72208[ebp]
	push	ecx
	lea	edx, DWORD PTR $T72210[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::erase

; 548  : 			this->comp = _Right.comp;
; 549  : 			_Copy(_Right);

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Copy@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEXABV12@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Copy
$LN1@operator@2:

; 550  : 			}
; 551  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 552  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??4?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAEAAV01@ABV01@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::operator=
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogrerect.h
_TEXT	ENDS
;	COMDAT ??0?$TBox@H@Ogre@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$TBox@H@Ogre@@QAE@XZ PROC				; Ogre::TBox<int>::TBox<int>, COMDAT
; _this$ = ecx

; 68   : 		TBox(){}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$TBox@H@Ogre@@QAE@XZ ENDP				; Ogre::TBox<int>::TBox<int>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0?$TBox@H@Ogre@@QAE@HHHHHH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_left$ = 8						; size = 4
_top$ = 12						; size = 4
_front$ = 16						; size = 4
_right$ = 20						; size = 4
_bottom$ = 24						; size = 4
_back$ = 28						; size = 4
??0?$TBox@H@Ogre@@QAE@HHHHHH@Z PROC			; Ogre::TBox<int>::TBox<int>, COMDAT
; _this$ = ecx

; 70   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _left$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _top$[ebp]
	mov	DWORD PTR [edx+4], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _front$[ebp]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _right$[ebp]
	mov	DWORD PTR [eax+12], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _bottom$[ebp]
	mov	DWORD PTR [edx+16], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _back$[ebp]
	mov	DWORD PTR [ecx+20], edx

; 71   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
??0?$TBox@H@Ogre@@QAE@HHHHHH@Z ENDP			; Ogre::TBox<int>::TBox<int>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?getWidth@?$TBox@H@Ogre@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getWidth@?$TBox@H@Ogre@@QBEHXZ PROC			; Ogre::TBox<int>::getWidth, COMDAT
; _this$ = ecx

; 73   : 		T getWidth() const{ return m_Right-m_Left; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+12]
	sub	eax, DWORD PTR [ecx]
	mov	esp, ebp
	pop	ebp
	ret	0
?getWidth@?$TBox@H@Ogre@@QBEHXZ ENDP			; Ogre::TBox<int>::getWidth
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?getHeight@?$TBox@H@Ogre@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getHeight@?$TBox@H@Ogre@@QBEHXZ PROC			; Ogre::TBox<int>::getHeight, COMDAT
; _this$ = ecx

; 74   : 		T getHeight() const{ return m_Bottom-m_Top; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+16]
	sub	eax, DWORD PTR [ecx+4]
	mov	esp, ebp
	pop	ebp
	ret	0
?getHeight@?$TBox@H@Ogre@@QBEHXZ ENDP			; Ogre::TBox<int>::getHeight
_TEXT	ENDS
PUBLIC	?getDepth@?$TBox@H@Ogre@@QBEHXZ			; Ogre::TBox<int>::getDepth
; Function compile flags: /Odtp
;	COMDAT ?getDepth@?$TBox@H@Ogre@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getDepth@?$TBox@H@Ogre@@QBEHXZ PROC			; Ogre::TBox<int>::getDepth, COMDAT
; _this$ = ecx

; 75   : 		T getDepth() const{ return m_Back-m_Front; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+20]
	sub	eax, DWORD PTR [ecx+8]
	mov	esp, ebp
	pop	ebp
	ret	0
?getDepth@?$TBox@H@Ogre@@QBEHXZ ENDP			; Ogre::TBox<int>::getDepth
_TEXT	ENDS
PUBLIC	?contains@?$TBox@H@Ogre@@QBE_NABV12@@Z		; Ogre::TBox<int>::contains
; Function compile flags: /Odtp
;	COMDAT ?contains@?$TBox@H@Ogre@@QBE_NABV12@@Z
_TEXT	SEGMENT
tv80 = -8						; size = 4
_this$ = -4						; size = 4
_def$ = 8						; size = 4
?contains@?$TBox@H@Ogre@@QBE_NABV12@@Z PROC		; Ogre::TBox<int>::contains, COMDAT
; _this$ = ecx

; 78   : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 79   : 			return (def.m_Left >= m_Left && def.m_Top >= m_Top && def.m_Front >= m_Front &&
; 80   : 				def.m_Right <= m_Right && def.m_Bottom <= m_Bottom && def.m_Back <= m_Back);

	mov	eax, DWORD PTR _def$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx]
	jl	SHORT $LN3@contains
	mov	eax, DWORD PTR _def$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+4]
	cmp	edx, DWORD PTR [ecx+4]
	jl	SHORT $LN3@contains
	mov	eax, DWORD PTR _def$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	cmp	edx, DWORD PTR [ecx+8]
	jl	SHORT $LN3@contains
	mov	eax, DWORD PTR _def$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+12]
	cmp	edx, DWORD PTR [ecx+12]
	jg	SHORT $LN3@contains
	mov	eax, DWORD PTR _def$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+16]
	cmp	edx, DWORD PTR [ecx+16]
	jg	SHORT $LN3@contains
	mov	eax, DWORD PTR _def$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+20]
	cmp	edx, DWORD PTR [ecx+20]
	jg	SHORT $LN3@contains
	mov	DWORD PTR tv80[ebp], 1
	jmp	SHORT $LN4@contains
$LN3@contains:
	mov	DWORD PTR tv80[ebp], 0
$LN4@contains:
	mov	al, BYTE PTR tv80[ebp]

; 81   : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?contains@?$TBox@H@Ogre@@QBE_NABV12@@Z ENDP		; Ogre::TBox<int>::contains
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@DV?$allocator@D@std@@@std@@QAE@XZ ; std::_Vector_val<char,std::allocator<char> >::~_Vector_val<char,std::allocator<char> >
PUBLIC	?_Tidy@?$vector@DV?$allocator@D@std@@@std@@IAEXXZ ; std::vector<char,std::allocator<char> >::_Tidy
PUBLIC	??$_Ucopy@V?$_Vector_const_iterator@DV?$allocator@D@std@@@std@@@?$vector@DV?$allocator@D@std@@@std@@IAEPADV?$_Vector_const_iterator@DV?$allocator@D@std@@@1@0PAD@Z ; std::vector<char,std::allocator<char> >::_Ucopy<std::_Vector_const_iterator<char,std::allocator<char> > >
PUBLIC	?begin@?$vector@DV?$allocator@D@std@@@std@@QBE?AV?$_Vector_const_iterator@DV?$allocator@D@std@@@2@XZ ; std::vector<char,std::allocator<char> >::begin
PUBLIC	?end@?$vector@DV?$allocator@D@std@@@std@@QBE?AV?$_Vector_const_iterator@DV?$allocator@D@std@@@2@XZ ; std::vector<char,std::allocator<char> >::end
PUBLIC	?_Buy@?$vector@DV?$allocator@D@std@@@std@@IAE_NI@Z ; std::vector<char,std::allocator<char> >::_Buy
PUBLIC	?size@?$vector@DV?$allocator@D@std@@@std@@QBEIXZ ; std::vector<char,std::allocator<char> >::size
PUBLIC	??0?$_Vector_val@DV?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z ; std::_Vector_val<char,std::allocator<char> >::_Vector_val<char,std::allocator<char> >
EXTRN	__imp_??0?$allocator@D@std@@QAE@ABV01@@Z:PROC
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	SEGMENT
__catchsym$??0?$vector@DV?$allocator@D@std@@@std@@QAE@ABV01@@Z$3 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??0?$vector@DV?$allocator@D@std@@@std@@QAE@ABV01@@Z$0
__tryblocktable$??0?$vector@DV?$allocator@D@std@@@std@@QAE@ABV01@@Z DD 01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??0?$vector@DV?$allocator@D@std@@@std@@QAE@ABV01@@Z$3
__unwindtable$??0?$vector@DV?$allocator@D@std@@@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@DV?$allocator@D@std@@@std@@QAE@ABV01@@Z$2
	DD	00H
	DD	00H
	DD	00H
	DD	00H
__ehfuncinfo$??0?$vector@DV?$allocator@D@std@@@std@@QAE@ABV01@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0?$vector@DV?$allocator@D@std@@@std@@QAE@ABV01@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??0?$vector@DV?$allocator@D@std@@@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$vector@DV?$allocator@D@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -40						; size = 4
$T72229 = -36						; size = 8
$T72228 = -28						; size = 8
$T72227 = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Right$ = 8						; size = 4
??0?$vector@DV?$allocator@D@std@@@std@@QAE@ABV01@@Z PROC ; std::vector<char,std::allocator<char> >::vector<char,std::allocator<char> >, COMDAT
; _this$ = ecx

; 500  : 		{	// construct by copying _Right

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$vector@DV?$allocator@D@std@@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 24					; 00000018H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Right$[ebp]
	add	eax, 8
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T72227[ebp], esp
	push	eax
	call	DWORD PTR __imp_??0?$allocator@D@std@@QAE@ABV01@@Z
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_val@DV?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z ; std::_Vector_val<char,std::allocator<char> >::_Vector_val<char,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 501  : 		if (_Buy(_Right.size()))

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@DV?$allocator@D@std@@@std@@QBEIXZ ; std::vector<char,std::allocator<char> >::size
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@DV?$allocator@D@std@@@std@@IAE_NI@Z ; std::vector<char,std::allocator<char> >::_Buy
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN3@vector@18

; 502  : 			_TRY_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 1

; 503  : 			_Mylast = _Ucopy(_Right.begin(), _Right.end(), _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	lea	ecx, DWORD PTR $T72228[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?end@?$vector@DV?$allocator@D@std@@@std@@QBE?AV?$_Vector_const_iterator@DV?$allocator@D@std@@@2@XZ ; std::vector<char,std::allocator<char> >::end
	mov	edx, DWORD PTR [eax+4]
	push	edx
	mov	eax, DWORD PTR [eax]
	push	eax
	lea	ecx, DWORD PTR $T72229[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?begin@?$vector@DV?$allocator@D@std@@@std@@QBE?AV?$_Vector_const_iterator@DV?$allocator@D@std@@@2@XZ ; std::vector<char,std::allocator<char> >::begin
	mov	edx, DWORD PTR [eax+4]
	push	edx
	mov	eax, DWORD PTR [eax]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Ucopy@V?$_Vector_const_iterator@DV?$allocator@D@std@@@std@@@?$vector@DV?$allocator@D@std@@@std@@IAEPADV?$_Vector_const_iterator@DV?$allocator@D@std@@@1@0PAD@Z ; std::vector<char,std::allocator<char> >::_Ucopy<std::_Vector_const_iterator<char,std::allocator<char> > >
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax
	jmp	SHORT $LN5@vector@18
__catch$??0?$vector@DV?$allocator@D@std@@@std@@QAE@ABV01@@Z$0:

; 504  : 			_CATCH_ALL
; 505  : 			_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@DV?$allocator@D@std@@@std@@IAEXXZ ; std::vector<char,std::allocator<char> >::_Tidy

; 506  : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 507  : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], 0
	mov	eax, $LN3@vector@18
	ret	0
$LN5@vector@18:
	mov	DWORD PTR __$EHRec$[ebp+12], 0
$LN3@vector@18:

; 508  : 		}

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector@18:
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@DV?$allocator@D@std@@@std@@QAE@ABV01@@Z$2:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@DV?$allocator@D@std@@@std@@QAE@XZ
__ehhandler$??0?$vector@DV?$allocator@D@std@@@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-44]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@DV?$allocator@D@std@@@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@DV?$allocator@D@std@@@std@@QAE@ABV01@@Z ENDP ; std::vector<char,std::allocator<char> >::vector<char,std::allocator<char> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$vector@DV?$allocator@D@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$vector@DV?$allocator@D@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$vector@DV?$allocator@D@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$vector@DV?$allocator@D@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$vector@DV?$allocator@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$vector@DV?$allocator@D@std@@@std@@QAE@XZ PROC	; std::vector<char,std::allocator<char> >::~vector<char,std::allocator<char> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$vector@DV?$allocator@D@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 559  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@DV?$allocator@D@std@@@std@@IAEXXZ ; std::vector<char,std::allocator<char> >::_Tidy

; 560  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Vector_val@DV?$allocator@D@std@@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$vector@DV?$allocator@D@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@DV?$allocator@D@std@@@std@@QAE@XZ
__ehhandler$??1?$vector@DV?$allocator@D@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$vector@DV?$allocator@D@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$vector@DV?$allocator@D@std@@@std@@QAE@XZ ENDP	; std::vector<char,std::allocator<char> >::~vector<char,std::allocator<char> >
PUBLIC	??$_Ucopy@PAD@?$vector@DV?$allocator@D@std@@@std@@IAEPADPAD00@Z ; std::vector<char,std::allocator<char> >::_Ucopy<char *>
PUBLIC	?capacity@?$vector@DV?$allocator@D@std@@@std@@QBEIXZ ; std::vector<char,std::allocator<char> >::capacity
PUBLIC	?_Destroy@?$vector@DV?$allocator@D@std@@@std@@IAEXPAD0@Z ; std::vector<char,std::allocator<char> >::_Destroy
PUBLIC	??$unchecked_copy@PADPAD@stdext@@YAPADPAD00@Z	; stdext::unchecked_copy<char *,char *>
PUBLIC	?clear@?$vector@DV?$allocator@D@std@@@std@@QAEXXZ ; std::vector<char,std::allocator<char> >::clear
EXTRN	__imp_?deallocate@?$allocator@D@std@@QAEXPADI@Z:PROC
; Function compile flags: /Odtp
;	COMDAT ??4?$vector@DV?$allocator@D@std@@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
__Ptr$64442 = -8					; size = 4
__Ptr$64432 = -4					; size = 4
__Right$ = 8						; size = 4
??4?$vector@DV?$allocator@D@std@@@std@@QAEAAV01@ABV01@@Z PROC ; std::vector<char,std::allocator<char> >::operator=, COMDAT
; _this$ = ecx

; 563  : 		{	// assign _Right

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 564  : 		if (this != &_Right)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR __Right$[ebp]
	je	$LN9@operator@3

; 565  : 			{	// worth doing
; 566  : 
; 567  :  #if _HAS_ITERATOR_DEBUGGING
; 568  : 			this->_Orphan_all();
; 569  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 570  : 
; 571  : 			if (_Right.size() == 0)

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@DV?$allocator@D@std@@@std@@QBEIXZ ; std::vector<char,std::allocator<char> >::size
	test	eax, eax
	jne	SHORT $LN8@operator@3

; 572  : 				clear();	// new sequence empty, erase existing sequence

	mov	ecx, DWORD PTR _this$[ebp]
	call	?clear@?$vector@DV?$allocator@D@std@@@std@@QAEXXZ ; std::vector<char,std::allocator<char> >::clear
	jmp	$LN9@operator@3
$LN8@operator@3:

; 573  : 			else if (_Right.size() <= size())

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@DV?$allocator@D@std@@@std@@QBEIXZ ; std::vector<char,std::allocator<char> >::size
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@DV?$allocator@D@std@@@std@@QBEIXZ ; std::vector<char,std::allocator<char> >::size
	cmp	esi, eax
	ja	SHORT $LN6@operator@3

; 574  : 				{	// enough elements, copy new and destroy old
; 575  : 				pointer _Ptr = _STDEXT unchecked_copy(_Right._Myfirst, _Right._Mylast,
; 576  : 					_Myfirst);	// copy new

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	call	??$unchecked_copy@PADPAD@stdext@@YAPADPAD00@Z ; stdext::unchecked_copy<char *,char *>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR __Ptr$64432[ebp], eax

; 577  : 				_Destroy(_Ptr, _Mylast);	// destroy old

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR __Ptr$64432[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@DV?$allocator@D@std@@@std@@IAEXPAD0@Z ; std::vector<char,std::allocator<char> >::_Destroy

; 578  : 				_Mylast = _Myfirst + _Right.size();

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@DV?$allocator@D@std@@@std@@QBEIXZ ; std::vector<char,std::allocator<char> >::size
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+12]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+16], eax
	jmp	$LN9@operator@3
$LN6@operator@3:

; 579  : 				}
; 580  : 			else if (_Right.size() <= capacity())

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@DV?$allocator@D@std@@@std@@QBEIXZ ; std::vector<char,std::allocator<char> >::size
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?capacity@?$vector@DV?$allocator@D@std@@@std@@QBEIXZ ; std::vector<char,std::allocator<char> >::capacity
	cmp	esi, eax
	ja	SHORT $LN4@operator@3

; 581  : 				{	// enough room, copy and construct new
; 582  : 				pointer _Ptr = _Right._Myfirst + size();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@DV?$allocator@D@std@@@std@@QBEIXZ ; std::vector<char,std::allocator<char> >::size
	mov	ecx, DWORD PTR __Right$[ebp]
	add	eax, DWORD PTR [ecx+12]
	mov	DWORD PTR __Ptr$64442[ebp], eax

; 583  : 				_STDEXT unchecked_copy(_Right._Myfirst, _Ptr, _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR __Ptr$64442[ebp]
	push	ecx
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	call	??$unchecked_copy@PADPAD@stdext@@YAPADPAD00@Z ; stdext::unchecked_copy<char *,char *>
	add	esp, 12					; 0000000cH

; 584  : 				_Mylast = _Ucopy(_Ptr, _Right._Mylast, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Ptr$64442[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Ucopy@PAD@?$vector@DV?$allocator@D@std@@@std@@IAEPADPAD00@Z ; std::vector<char,std::allocator<char> >::_Ucopy<char *>
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 585  : 				}
; 586  : 			else

	jmp	SHORT $LN9@operator@3
$LN4@operator@3:

; 587  : 				{	// not enough room, allocate new array and construct new
; 588  : 				if (_Myfirst != 0)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+12], 0
	je	SHORT $LN2@operator@3

; 589  : 					{	// discard old array
; 590  : 					_Destroy(_Myfirst, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@DV?$allocator@D@std@@@std@@IAEXPAD0@Z ; std::vector<char,std::allocator<char> >::_Destroy

; 591  : 					this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+20]
	sub	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	DWORD PTR __imp_?deallocate@?$allocator@D@std@@QAEXPADI@Z
$LN2@operator@3:

; 592  : 					}
; 593  : 				if (_Buy(_Right.size()))

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@DV?$allocator@D@std@@@std@@QBEIXZ ; std::vector<char,std::allocator<char> >::size
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@DV?$allocator@D@std@@@std@@IAE_NI@Z ; std::vector<char,std::allocator<char> >::_Buy
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN9@operator@3

; 594  : 					_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 595  : 						_Myfirst);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Ucopy@PAD@?$vector@DV?$allocator@D@std@@@std@@IAEPADPAD00@Z ; std::vector<char,std::allocator<char> >::_Ucopy<char *>
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax
$LN9@operator@3:

; 596  : 				}
; 597  : 			}
; 598  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 599  : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
??4?$vector@DV?$allocator@D@std@@@std@@QAEAAV01@ABV01@@Z ENDP ; std::vector<char,std::allocator<char> >::operator=
_TEXT	ENDS
EXTRN	__imp___invalid_parameter_noinfo:PROC
; Function compile flags: /Odtp
;	COMDAT ??A?$vector@DV?$allocator@D@std@@@std@@QAEAADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pos$ = 8						; size = 4
??A?$vector@DV?$allocator@D@std@@@std@@QAEAADI@Z PROC	; std::vector<char,std::allocator<char> >::operator[], COMDAT
; _this$ = ecx

; 774  : 		{	// subscript mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)
; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");
; 780  : 			_SCL_SECURE_OUT_OF_RANGE;
; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@DV?$allocator@D@std@@@std@@QBEIXZ ; std::vector<char,std::allocator<char> >::size
	cmp	DWORD PTR __Pos$[ebp], eax
	jb	SHORT $LN1@operator@4
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN1@operator@4:

; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+12]
	add	eax, DWORD PTR __Pos$[ebp]

; 786  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??A?$vector@DV?$allocator@D@std@@@std@@QAEAADI@Z ENDP	; std::vector<char,std::allocator<char> >::operator[]
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE@XZ ; std::_Vector_val<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::~_Vector_val<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >
PUBLIC	?_Tidy@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAEXXZ ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::_Tidy
PUBLIC	??$_Ucopy@V?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAEPAPAVSurfaceData@Ogre@@V?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@1@0PAPAV23@@Z ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::_Ucopy<std::_Vector_const_iterator<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> > >
PUBLIC	?begin@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@2@XZ ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::begin
PUBLIC	?end@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@2@XZ ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::end
PUBLIC	?_Buy@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAE_NI@Z ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::_Buy
PUBLIC	?size@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::size
PUBLIC	??0?$_Vector_val@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAE@V?$allocator@PAVSurfaceData@Ogre@@@1@@Z ; std::_Vector_val<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::_Vector_val<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >
PUBLIC	??0?$allocator@PAVSurfaceData@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::SurfaceData *>::allocator<Ogre::SurfaceData *>
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??0?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE@ABV01@@Z$3 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??0?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE@ABV01@@Z$0
__tryblocktable$??0?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE@ABV01@@Z DD 01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??0?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE@ABV01@@Z$3
__unwindtable$??0?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE@ABV01@@Z$2
	DD	00H
	DD	00H
	DD	00H
	DD	00H
__ehfuncinfo$??0?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE@ABV01@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE@ABV01@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??0?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -40						; size = 4
$T72261 = -36						; size = 8
$T72260 = -28						; size = 8
$T72259 = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Right$ = 8						; size = 4
??0?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE@ABV01@@Z PROC ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >, COMDAT
; _this$ = ecx

; 500  : 		{	// construct by copying _Right

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 24					; 00000018H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Right$[ebp]
	add	eax, 8
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T72259[ebp], esp
	push	eax
	call	??0?$allocator@PAVSurfaceData@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::SurfaceData *>::allocator<Ogre::SurfaceData *>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_val@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAE@V?$allocator@PAVSurfaceData@Ogre@@@1@@Z ; std::_Vector_val<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::_Vector_val<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >
	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 501  : 		if (_Buy(_Right.size()))

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::size
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAE_NI@Z ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::_Buy
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN3@vector@19

; 502  : 			_TRY_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 1

; 503  : 			_Mylast = _Ucopy(_Right.begin(), _Right.end(), _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	lea	ecx, DWORD PTR $T72260[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?end@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@2@XZ ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::end
	mov	edx, DWORD PTR [eax+4]
	push	edx
	mov	eax, DWORD PTR [eax]
	push	eax
	lea	ecx, DWORD PTR $T72261[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?begin@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@2@XZ ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::begin
	mov	edx, DWORD PTR [eax+4]
	push	edx
	mov	eax, DWORD PTR [eax]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Ucopy@V?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAEPAPAVSurfaceData@Ogre@@V?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@1@0PAPAV23@@Z ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::_Ucopy<std::_Vector_const_iterator<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> > >
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax
	jmp	SHORT $LN5@vector@19
__catch$??0?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE@ABV01@@Z$0:

; 504  : 			_CATCH_ALL
; 505  : 			_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAEXXZ ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::_Tidy

; 506  : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 507  : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], 0
	mov	eax, $LN3@vector@19
	ret	0
$LN5@vector@19:
	mov	DWORD PTR __$EHRec$[ebp+12], 0
$LN3@vector@19:

; 508  : 		}

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector@19:
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE@ABV01@@Z$2:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE@XZ
__ehhandler$??0?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-44]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE@XZ PROC ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::~vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 559  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAEXXZ ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::_Tidy

; 560  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Vector_val@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE@XZ
__ehhandler$??1?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE@XZ ENDP ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::~vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >
PUBLIC	?deallocate@?$allocator@PAVSurfaceData@Ogre@@@std@@QAEXPAPAVSurfaceData@Ogre@@I@Z ; std::allocator<Ogre::SurfaceData *>::deallocate
PUBLIC	??$_Ucopy@PAPAVSurfaceData@Ogre@@@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAEPAPAVSurfaceData@Ogre@@PAPAV23@00@Z ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::_Ucopy<Ogre::SurfaceData * *>
PUBLIC	?capacity@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::capacity
PUBLIC	?_Destroy@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAEXPAPAVSurfaceData@Ogre@@0@Z ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::_Destroy
PUBLIC	??$unchecked_copy@PAPAVSurfaceData@Ogre@@PAPAV12@@stdext@@YAPAPAVSurfaceData@Ogre@@PAPAV12@00@Z ; stdext::unchecked_copy<Ogre::SurfaceData * *,Ogre::SurfaceData * *>
PUBLIC	?clear@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAEXXZ ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::clear
; Function compile flags: /Odtp
;	COMDAT ??4?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
__Ptr$64600 = -8					; size = 4
__Ptr$64590 = -4					; size = 4
__Right$ = 8						; size = 4
??4?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z PROC ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::operator=, COMDAT
; _this$ = ecx

; 563  : 		{	// assign _Right

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 564  : 		if (this != &_Right)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR __Right$[ebp]
	je	$LN9@operator@5

; 565  : 			{	// worth doing
; 566  : 
; 567  :  #if _HAS_ITERATOR_DEBUGGING
; 568  : 			this->_Orphan_all();
; 569  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 570  : 
; 571  : 			if (_Right.size() == 0)

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::size
	test	eax, eax
	jne	SHORT $LN8@operator@5

; 572  : 				clear();	// new sequence empty, erase existing sequence

	mov	ecx, DWORD PTR _this$[ebp]
	call	?clear@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAEXXZ ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::clear
	jmp	$LN9@operator@5
$LN8@operator@5:

; 573  : 			else if (_Right.size() <= size())

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::size
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::size
	cmp	esi, eax
	ja	SHORT $LN6@operator@5

; 574  : 				{	// enough elements, copy new and destroy old
; 575  : 				pointer _Ptr = _STDEXT unchecked_copy(_Right._Myfirst, _Right._Mylast,
; 576  : 					_Myfirst);	// copy new

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	call	??$unchecked_copy@PAPAVSurfaceData@Ogre@@PAPAV12@@stdext@@YAPAPAVSurfaceData@Ogre@@PAPAV12@00@Z ; stdext::unchecked_copy<Ogre::SurfaceData * *,Ogre::SurfaceData * *>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR __Ptr$64590[ebp], eax

; 577  : 				_Destroy(_Ptr, _Mylast);	// destroy old

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR __Ptr$64590[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAEXPAPAVSurfaceData@Ogre@@0@Z ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::_Destroy

; 578  : 				_Mylast = _Myfirst + _Right.size();

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::size
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	lea	eax, DWORD PTR [edx+eax*4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax
	jmp	$LN9@operator@5
$LN6@operator@5:

; 579  : 				}
; 580  : 			else if (_Right.size() <= capacity())

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::size
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?capacity@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::capacity
	cmp	esi, eax
	ja	SHORT $LN4@operator@5

; 581  : 				{	// enough room, copy and construct new
; 582  : 				pointer _Ptr = _Right._Myfirst + size();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::size
	mov	edx, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR __Ptr$64600[ebp], edx

; 583  : 				_STDEXT unchecked_copy(_Right._Myfirst, _Ptr, _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	edx, DWORD PTR __Ptr$64600[ebp]
	push	edx
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	call	??$unchecked_copy@PAPAVSurfaceData@Ogre@@PAPAV12@@stdext@@YAPAPAVSurfaceData@Ogre@@PAPAV12@00@Z ; stdext::unchecked_copy<Ogre::SurfaceData * *,Ogre::SurfaceData * *>
	add	esp, 12					; 0000000cH

; 584  : 				_Mylast = _Ucopy(_Ptr, _Right._Mylast, _Mylast);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR __Ptr$64600[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Ucopy@PAPAVSurfaceData@Ogre@@@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAEPAPAVSurfaceData@Ogre@@PAPAV23@00@Z ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::_Ucopy<Ogre::SurfaceData * *>
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 585  : 				}
; 586  : 			else

	jmp	SHORT $LN9@operator@5
$LN4@operator@5:

; 587  : 				{	// not enough room, allocate new array and construct new
; 588  : 				if (_Myfirst != 0)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+12], 0
	je	SHORT $LN2@operator@5

; 589  : 					{	// discard old array
; 590  : 					_Destroy(_Myfirst, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAEXPAPAVSurfaceData@Ogre@@0@Z ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::_Destroy

; 591  : 					this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+20]
	sub	eax, DWORD PTR [edx+12]
	sar	eax, 2
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?deallocate@?$allocator@PAVSurfaceData@Ogre@@@std@@QAEXPAPAVSurfaceData@Ogre@@I@Z ; std::allocator<Ogre::SurfaceData *>::deallocate
$LN2@operator@5:

; 592  : 					}
; 593  : 				if (_Buy(_Right.size()))

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::size
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAE_NI@Z ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::_Buy
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN9@operator@5

; 594  : 					_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 595  : 						_Myfirst);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Ucopy@PAPAVSurfaceData@Ogre@@@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAEPAPAVSurfaceData@Ogre@@PAPAV23@00@Z ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::_Ucopy<Ogre::SurfaceData * *>
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax
$LN9@operator@5:

; 596  : 				}
; 597  : 			}
; 598  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 599  : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
??4?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z ENDP ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::operator=
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QAE@XZ ; std::_Vector_val<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::~_Vector_val<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >
PUBLIC	?_Buy@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@IAE_NI@Z ; std::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::_Buy
PUBLIC	??0?$_Vector_val@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@IAE@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@1@@Z ; std::_Vector_val<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::_Vector_val<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >
PUBLIC	??0?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@QAE@XZ ; std::allocator<Ogre::HardwarePixelBuffer *>::allocator<Ogre::HardwarePixelBuffer *>
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??0?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T72289 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QAE@XZ PROC ; std::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T72289[ebp], esp
	call	??0?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@QAE@XZ ; std::allocator<Ogre::HardwarePixelBuffer *>::allocator<Ogre::HardwarePixelBuffer *>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_val@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@IAE@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@1@@Z ; std::_Vector_val<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::_Vector_val<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 471  : 		_Buy(0);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@IAE_NI@Z ; std::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::_Buy

; 472  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QAE@XZ
__ehhandler$??0?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QAE@XZ ENDP ; std::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >
PUBLIC	?_Tidy@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@IAEXXZ ; std::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::_Tidy
PUBLIC	??$_Ucopy@V?$_Vector_const_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@IAEPAPAVHardwarePixelBuffer@Ogre@@V?$_Vector_const_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@1@0PAPAV23@@Z ; std::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::_Ucopy<std::_Vector_const_iterator<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> > >
PUBLIC	?begin@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@2@XZ ; std::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::begin
PUBLIC	?end@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@2@XZ ; std::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::end
PUBLIC	??0?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::HardwarePixelBuffer *>::allocator<Ogre::HardwarePixelBuffer *>
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??0?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QAE@ABV01@@Z$3 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??0?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QAE@ABV01@@Z$0
__tryblocktable$??0?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QAE@ABV01@@Z DD 01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??0?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QAE@ABV01@@Z$3
__unwindtable$??0?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QAE@ABV01@@Z$2
	DD	00H
	DD	00H
	DD	00H
	DD	00H
__ehfuncinfo$??0?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QAE@ABV01@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QAE@ABV01@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??0?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -40						; size = 4
$T72301 = -36						; size = 8
$T72300 = -28						; size = 8
$T72299 = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Right$ = 8						; size = 4
??0?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QAE@ABV01@@Z PROC ; std::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >, COMDAT
; _this$ = ecx

; 500  : 		{	// construct by copying _Right

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 24					; 00000018H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Right$[ebp]
	add	eax, 8
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T72299[ebp], esp
	push	eax
	call	??0?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::HardwarePixelBuffer *>::allocator<Ogre::HardwarePixelBuffer *>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_val@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@IAE@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@1@@Z ; std::_Vector_val<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::_Vector_val<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >
	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 501  : 		if (_Buy(_Right.size()))

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::size
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@IAE_NI@Z ; std::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::_Buy
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN3@vector@20

; 502  : 			_TRY_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 1

; 503  : 			_Mylast = _Ucopy(_Right.begin(), _Right.end(), _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	lea	ecx, DWORD PTR $T72300[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?end@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@2@XZ ; std::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::end
	mov	edx, DWORD PTR [eax+4]
	push	edx
	mov	eax, DWORD PTR [eax]
	push	eax
	lea	ecx, DWORD PTR $T72301[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?begin@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@2@XZ ; std::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::begin
	mov	edx, DWORD PTR [eax+4]
	push	edx
	mov	eax, DWORD PTR [eax]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Ucopy@V?$_Vector_const_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@IAEPAPAVHardwarePixelBuffer@Ogre@@V?$_Vector_const_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@1@0PAPAV23@@Z ; std::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::_Ucopy<std::_Vector_const_iterator<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> > >
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax
	jmp	SHORT $LN5@vector@20
__catch$??0?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QAE@ABV01@@Z$0:

; 504  : 			_CATCH_ALL
; 505  : 			_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@IAEXXZ ; std::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::_Tidy

; 506  : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 507  : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], 0
	mov	eax, $LN3@vector@20
	ret	0
$LN5@vector@20:
	mov	DWORD PTR __$EHRec$[ebp+12], 0
$LN3@vector@20:

; 508  : 		}

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector@20:
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QAE@ABV01@@Z$2:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QAE@XZ
__ehhandler$??0?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-44]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QAE@XZ PROC ; std::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::~vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 559  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@IAEXXZ ; std::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::_Tidy

; 560  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Vector_val@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QAE@XZ
__ehhandler$??1?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QAE@XZ ENDP ; std::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::~vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >
PUBLIC	?deallocate@?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@QAEXPAPAVHardwarePixelBuffer@Ogre@@I@Z ; std::allocator<Ogre::HardwarePixelBuffer *>::deallocate
PUBLIC	??$_Ucopy@PAPAVHardwarePixelBuffer@Ogre@@@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@IAEPAPAVHardwarePixelBuffer@Ogre@@PAPAV23@00@Z ; std::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::_Ucopy<Ogre::HardwarePixelBuffer * *>
PUBLIC	?capacity@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::capacity
PUBLIC	?_Destroy@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@IAEXPAPAVHardwarePixelBuffer@Ogre@@0@Z ; std::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::_Destroy
PUBLIC	??$unchecked_copy@PAPAVHardwarePixelBuffer@Ogre@@PAPAV12@@stdext@@YAPAPAVHardwarePixelBuffer@Ogre@@PAPAV12@00@Z ; stdext::unchecked_copy<Ogre::HardwarePixelBuffer * *,Ogre::HardwarePixelBuffer * *>
; Function compile flags: /Odtp
;	COMDAT ??4?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
__Ptr$64649 = -8					; size = 4
__Ptr$64639 = -4					; size = 4
__Right$ = 8						; size = 4
??4?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z PROC ; std::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::operator=, COMDAT
; _this$ = ecx

; 563  : 		{	// assign _Right

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 564  : 		if (this != &_Right)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR __Right$[ebp]
	je	$LN9@operator@6

; 565  : 			{	// worth doing
; 566  : 
; 567  :  #if _HAS_ITERATOR_DEBUGGING
; 568  : 			this->_Orphan_all();
; 569  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 570  : 
; 571  : 			if (_Right.size() == 0)

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::size
	test	eax, eax
	jne	SHORT $LN8@operator@6

; 572  : 				clear();	// new sequence empty, erase existing sequence

	mov	ecx, DWORD PTR _this$[ebp]
	call	?clear@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QAEXXZ ; std::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::clear
	jmp	$LN9@operator@6
$LN8@operator@6:

; 573  : 			else if (_Right.size() <= size())

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::size
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::size
	cmp	esi, eax
	ja	SHORT $LN6@operator@6

; 574  : 				{	// enough elements, copy new and destroy old
; 575  : 				pointer _Ptr = _STDEXT unchecked_copy(_Right._Myfirst, _Right._Mylast,
; 576  : 					_Myfirst);	// copy new

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	call	??$unchecked_copy@PAPAVHardwarePixelBuffer@Ogre@@PAPAV12@@stdext@@YAPAPAVHardwarePixelBuffer@Ogre@@PAPAV12@00@Z ; stdext::unchecked_copy<Ogre::HardwarePixelBuffer * *,Ogre::HardwarePixelBuffer * *>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR __Ptr$64639[ebp], eax

; 577  : 				_Destroy(_Ptr, _Mylast);	// destroy old

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR __Ptr$64639[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@IAEXPAPAVHardwarePixelBuffer@Ogre@@0@Z ; std::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::_Destroy

; 578  : 				_Mylast = _Myfirst + _Right.size();

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::size
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	lea	eax, DWORD PTR [edx+eax*4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax
	jmp	$LN9@operator@6
$LN6@operator@6:

; 579  : 				}
; 580  : 			else if (_Right.size() <= capacity())

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::size
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?capacity@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::capacity
	cmp	esi, eax
	ja	SHORT $LN4@operator@6

; 581  : 				{	// enough room, copy and construct new
; 582  : 				pointer _Ptr = _Right._Myfirst + size();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::size
	mov	edx, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR __Ptr$64649[ebp], edx

; 583  : 				_STDEXT unchecked_copy(_Right._Myfirst, _Ptr, _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	edx, DWORD PTR __Ptr$64649[ebp]
	push	edx
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	call	??$unchecked_copy@PAPAVHardwarePixelBuffer@Ogre@@PAPAV12@@stdext@@YAPAPAVHardwarePixelBuffer@Ogre@@PAPAV12@00@Z ; stdext::unchecked_copy<Ogre::HardwarePixelBuffer * *,Ogre::HardwarePixelBuffer * *>
	add	esp, 12					; 0000000cH

; 584  : 				_Mylast = _Ucopy(_Ptr, _Right._Mylast, _Mylast);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR __Ptr$64649[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Ucopy@PAPAVHardwarePixelBuffer@Ogre@@@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@IAEPAPAVHardwarePixelBuffer@Ogre@@PAPAV23@00@Z ; std::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::_Ucopy<Ogre::HardwarePixelBuffer * *>
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 585  : 				}
; 586  : 			else

	jmp	SHORT $LN9@operator@6
$LN4@operator@6:

; 587  : 				{	// not enough room, allocate new array and construct new
; 588  : 				if (_Myfirst != 0)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+12], 0
	je	SHORT $LN2@operator@6

; 589  : 					{	// discard old array
; 590  : 					_Destroy(_Myfirst, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@IAEXPAPAVHardwarePixelBuffer@Ogre@@0@Z ; std::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::_Destroy

; 591  : 					this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+20]
	sub	eax, DWORD PTR [edx+12]
	sar	eax, 2
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?deallocate@?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@QAEXPAPAVHardwarePixelBuffer@Ogre@@I@Z ; std::allocator<Ogre::HardwarePixelBuffer *>::deallocate
$LN2@operator@6:

; 592  : 					}
; 593  : 				if (_Buy(_Right.size()))

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::size
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@IAE_NI@Z ; std::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::_Buy
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN9@operator@6

; 594  : 					_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 595  : 						_Myfirst);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Ucopy@PAPAVHardwarePixelBuffer@Ogre@@@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@IAEPAPAVHardwarePixelBuffer@Ogre@@PAPAV23@00@Z ; std::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::_Ucopy<Ogre::HardwarePixelBuffer * *>
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax
$LN9@operator@6:

; 596  : 				}
; 597  : 			}
; 598  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 599  : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
??4?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z ENDP ; std::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::operator=
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QAE@PAPAVHardwarePixelBuffer@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::_Vector_iterator<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >
; Function compile flags: /Odtp
;	COMDAT ?begin@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@2@XZ PROC ; std::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::begin, COMDAT
; _this$ = ecx

; 640  : 		{	// return iterator for beginning of mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 641  : 		return (iterator(_Myfirst, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QAE@PAPAVHardwarePixelBuffer@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::_Vector_iterator<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 642  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?begin@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@2@XZ ENDP ; std::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::begin
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?end@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@2@XZ PROC ; std::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::end, COMDAT
; _this$ = ecx

; 650  : 		{	// return iterator for end of mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 651  : 		return (iterator(_Mylast, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QAE@PAPAVHardwarePixelBuffer@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::_Vector_iterator<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 652  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?end@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@2@XZ ENDP ; std::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::end
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?size@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QBEIXZ PROC ; std::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::size, COMDAT
; _this$ = ecx

; 725  : 		{	// return length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+16]
	sub	eax, DWORD PTR [ecx+12]
	sar	eax, 2

; 727  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?size@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QBEIXZ ENDP ; std::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::size
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?empty@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?empty@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QBE_NXZ PROC ; std::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::empty, COMDAT
; _this$ = ecx

; 735  : 		{	// test if sequence is empty

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 736  : 		return (size() == 0);

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::size
	neg	eax
	sbb	eax, eax
	add	eax, 1

; 737  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?empty@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QBE_NXZ ENDP ; std::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::empty
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??A?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QAEAAPAVHardwarePixelBuffer@Ogre@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pos$ = 8						; size = 4
??A?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QAEAAPAVHardwarePixelBuffer@Ogre@@I@Z PROC ; std::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::operator[], COMDAT
; _this$ = ecx

; 774  : 		{	// subscript mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)
; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");
; 780  : 			_SCL_SECURE_OUT_OF_RANGE;
; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::size
	cmp	DWORD PTR __Pos$[ebp], eax
	jb	SHORT $LN1@operator@7
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN1@operator@7:

; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR __Pos$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]

; 786  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??A?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QAEAAPAVHardwarePixelBuffer@Ogre@@I@Z ENDP ; std::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::operator[]
_TEXT	ENDS
PUBLIC	??G?$_Vector_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::operator-
; Function compile flags: /Odtp
;	COMDAT ?back@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QAEAAPAVHardwarePixelBuffer@Ogre@@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T72340 = -16						; size = 8
$T72339 = -8						; size = 8
?back@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QAEAAPAVHardwarePixelBuffer@Ogre@@XZ PROC ; std::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::back, COMDAT
; _this$ = ecx

; 799  : 		{	// return last element of mutable sequence

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 800  : 		return (*(end() - 1));

	push	1
	lea	eax, DWORD PTR $T72340[ebp]
	push	eax
	lea	ecx, DWORD PTR $T72339[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@2@XZ ; std::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::end
	mov	ecx, eax
	call	??G?$_Vector_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::operator-
	mov	ecx, eax
	call	??D?$_Vector_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QBEAAPAVHardwarePixelBuffer@Ogre@@XZ ; std::_Vector_iterator<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::operator*

; 801  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?back@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QAEAAPAVHardwarePixelBuffer@Ogre@@XZ ENDP ; std::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::back
_TEXT	ENDS
PUBLIC	?insert@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@2@ABQAVHardwarePixelBuffer@Ogre@@@Z ; std::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::insert
PUBLIC	?_Ufill@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@IAEPAPAVHardwarePixelBuffer@Ogre@@PAPAV34@IABQAV34@@Z ; std::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::_Ufill
; Function compile flags: /Odtp
;	COMDAT ?push_back@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QAEXABQAVHardwarePixelBuffer@Ogre@@@Z
_TEXT	SEGMENT
_this$ = -28						; size = 4
$T72345 = -24						; size = 8
$T72344 = -16						; size = 8
$T72343 = -8						; size = 8
__Val$ = 8						; size = 4
?push_back@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QAEXABQAVHardwarePixelBuffer@Ogre@@@Z PROC ; std::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::push_back, COMDAT
; _this$ = ecx

; 809  : 		{	// insert element at end

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 810  : 		if (size() < capacity())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::size
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?capacity@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::capacity
	cmp	esi, eax
	jae	SHORT $LN2@push_back

; 811  : 
; 812  :  #if _HAS_ITERATOR_DEBUGGING
; 813  : 			{ // room at end, construct it there
; 814  : 			_Orphan_range(_Mylast, _Mylast);
; 815  : 			_Mylast = _Ufill(_Mylast, 1, _Val);
; 816  : 			}
; 817  : 
; 818  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 819  : 			_Mylast = _Ufill(_Mylast, 1, _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Ufill@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@IAEPAPAVHardwarePixelBuffer@Ogre@@PAPAV34@IABQAV34@@Z ; std::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::_Ufill
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 820  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 821  : 
; 822  : 		else

	jmp	SHORT $LN3@push_back
$LN2@push_back:

; 823  : 			insert(end(), _Val);

	lea	edx, DWORD PTR $T72344[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@2@XZ ; std::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::end
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T72343[ebp], ecx
	mov	DWORD PTR $T72343[ebp+4], edx
	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T72343[ebp+4]
	push	ecx
	mov	edx, DWORD PTR $T72343[ebp]
	push	edx
	lea	eax, DWORD PTR $T72345[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?insert@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@2@ABQAVHardwarePixelBuffer@Ogre@@@Z ; std::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::insert
$LN3@push_back:

; 824  : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?push_back@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QAEXABQAVHardwarePixelBuffer@Ogre@@@Z ENDP ; std::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::push_back
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?pop_back@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?pop_back@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QAEXXZ PROC ; std::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::pop_back, COMDAT
; _this$ = ecx

; 841  : 		{	// erase element at end

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 842  : 		if (!empty())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?empty@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QBE_NXZ ; std::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::empty
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN2@pop_back

; 843  : 			{	// erase last element
; 844  : 			_Destroy(_Mylast - 1, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	sub	ecx, 4
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@IAEXPAPAVHardwarePixelBuffer@Ogre@@0@Z ; std::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::_Destroy

; 845  : 			--_Mylast;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	sub	eax, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax
$LN2@pop_back:

; 846  : 			}
; 847  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?pop_back@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QAEXXZ ENDP ; std::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::pop_back
_TEXT	ENDS
PUBLIC	?_Make_iter@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@2@@Z ; std::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::_Make_iter
; Function compile flags: /Odtp
;	COMDAT ?erase@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 8
?erase@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@2@@Z PROC ; std::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::erase, COMDAT
; _this$ = ecx

; 1017 : 		{	// erase element at where

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1018 : 		_STDEXT unchecked_copy(_VEC_ITER_BASE(_Where) + 1, _Mylast,
; 1019 : 			_VEC_ITER_BASE(_Where));

	mov	eax, DWORD PTR __Where$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR __Where$[ebp+4]
	add	eax, 4
	push	eax
	call	??$unchecked_copy@PAPAVHardwarePixelBuffer@Ogre@@PAPAV12@@stdext@@YAPAPAVHardwarePixelBuffer@Ogre@@PAPAV12@00@Z ; stdext::unchecked_copy<Ogre::HardwarePixelBuffer * *,Ogre::HardwarePixelBuffer * *>
	add	esp, 12					; 0000000cH

; 1020 : 		_Destroy(_Mylast - 1, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	sub	ecx, 4
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@IAEXPAPAVHardwarePixelBuffer@Ogre@@0@Z ; std::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::_Destroy

; 1021 : 		--_Mylast;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	sub	eax, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 1022 : 		return (_Make_iter(_Where));

	mov	edx, DWORD PTR __Where$[ebp+4]
	push	edx
	mov	eax, DWORD PTR __Where$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Make_iter@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@2@@Z ; std::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::_Make_iter
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1023 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?erase@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@2@@Z ENDP ; std::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::erase
_TEXT	ENDS
PUBLIC	?erase@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@2@0@Z ; std::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::erase
; Function compile flags: /Odtp
;	COMDAT ?clear@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -44						; size = 4
$T72356 = -40						; size = 8
$T72355 = -32						; size = 8
$T72354 = -24						; size = 8
$T72353 = -16						; size = 8
$T72352 = -8						; size = 8
?clear@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QAEXXZ PROC ; std::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::clear, COMDAT
; _this$ = ecx

; 1059 : 		{	// erase all

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	mov	DWORD PTR _this$[ebp], ecx

; 1060 : 		erase(begin(), end());

	lea	eax, DWORD PTR $T72353[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@2@XZ ; std::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::end
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T72352[ebp], ecx
	mov	DWORD PTR $T72352[ebp+4], edx
	lea	eax, DWORD PTR $T72355[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@2@XZ ; std::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::begin
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T72354[ebp], ecx
	mov	DWORD PTR $T72354[ebp+4], edx
	mov	eax, DWORD PTR $T72352[ebp+4]
	push	eax
	mov	ecx, DWORD PTR $T72352[ebp]
	push	ecx
	mov	edx, DWORD PTR $T72354[ebp+4]
	push	edx
	mov	eax, DWORD PTR $T72354[ebp]
	push	eax
	lea	ecx, DWORD PTR $T72356[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@2@0@Z ; std::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::erase

; 1061 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?clear@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QAEXXZ ENDP ; std::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::clear
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogresingleton.h
_TEXT	ENDS
;	COMDAT ??0?$Singleton@VHardwarePixelBufferManager@Ogre@@@Ogre@@QAE@XZ
_TEXT	SEGMENT
tv68 = -8						; size = 4
_this$ = -4						; size = 4
??0?$Singleton@VHardwarePixelBufferManager@Ogre@@@Ogre@@QAE@XZ PROC ; Ogre::Singleton<Ogre::HardwarePixelBufferManager>::Singleton<Ogre::HardwarePixelBufferManager>, COMDAT
; _this$ = ecx

; 64   : 		Singleton( void )

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 65   : 		{
; 66   : 			assert( !ms_Singleton );
; 67   : #if defined( _MSC_VER ) && _MSC_VER < 1200	 
; 68   : 			int offset = (int)(T*)1 - (int)(Singleton <T>*)(T*)1;
; 69   : 			ms_Singleton = (T*)((int)this + offset);
; 70   : #else
; 71   : 			ms_Singleton = static_cast< T* >( this );

	cmp	DWORD PTR _this$[ebp], 0
	je	SHORT $LN3@Singleton@2
	mov	eax, DWORD PTR _this$[ebp]
	sub	eax, 4
	mov	DWORD PTR tv68[ebp], eax
	jmp	SHORT $LN4@Singleton@2
$LN3@Singleton@2:
	mov	DWORD PTR tv68[ebp], 0
$LN4@Singleton@2:
	mov	ecx, DWORD PTR tv68[ebp]
	mov	DWORD PTR ?ms_Singleton@?$Singleton@VHardwarePixelBufferManager@Ogre@@@Ogre@@1PAVHardwarePixelBufferManager@2@A, ecx ; Ogre::Singleton<Ogre::HardwarePixelBufferManager>::ms_Singleton

; 72   : #endif
; 73   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$Singleton@VHardwarePixelBufferManager@Ogre@@@Ogre@@QAE@XZ ENDP ; Ogre::Singleton<Ogre::HardwarePixelBufferManager>::Singleton<Ogre::HardwarePixelBufferManager>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??1?$Singleton@VHardwarePixelBufferManager@Ogre@@@Ogre@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$Singleton@VHardwarePixelBufferManager@Ogre@@@Ogre@@QAE@XZ PROC ; Ogre::Singleton<Ogre::HardwarePixelBufferManager>::~Singleton<Ogre::HardwarePixelBufferManager>, COMDAT
; _this$ = ecx

; 75   : 		{  assert( ms_Singleton );  ms_Singleton = 0;  }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR ?ms_Singleton@?$Singleton@VHardwarePixelBufferManager@Ogre@@@Ogre@@1PAVHardwarePixelBufferManager@2@A, 0 ; Ogre::Singleton<Ogre::HardwarePixelBufferManager>::ms_Singleton
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$Singleton@VHardwarePixelBufferManager@Ogre@@@Ogre@@QAE@XZ ENDP ; Ogre::Singleton<Ogre::HardwarePixelBufferManager>::~Singleton<Ogre::HardwarePixelBufferManager>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?getSingleton@?$Singleton@VHardwarePixelBufferManager@Ogre@@@Ogre@@SAAAVHardwarePixelBufferManager@2@XZ
_TEXT	SEGMENT
?getSingleton@?$Singleton@VHardwarePixelBufferManager@Ogre@@@Ogre@@SAAAVHardwarePixelBufferManager@2@XZ PROC ; Ogre::Singleton<Ogre::HardwarePixelBufferManager>::getSingleton, COMDAT

; 77   : 		{	assert( ms_Singleton );  return ( *ms_Singleton ); }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR ?ms_Singleton@?$Singleton@VHardwarePixelBufferManager@Ogre@@@Ogre@@1PAVHardwarePixelBufferManager@2@A ; Ogre::Singleton<Ogre::HardwarePixelBufferManager>::ms_Singleton
	pop	ebp
	ret	0
?getSingleton@?$Singleton@VHardwarePixelBufferManager@Ogre@@@Ogre@@SAAAVHardwarePixelBufferManager@2@XZ ENDP ; Ogre::Singleton<Ogre::HardwarePixelBufferManager>::getSingleton
_TEXT	ENDS
PUBLIC	?getSingletonPtr@?$Singleton@VHardwarePixelBufferManager@Ogre@@@Ogre@@SAPAVHardwarePixelBufferManager@2@XZ ; Ogre::Singleton<Ogre::HardwarePixelBufferManager>::getSingletonPtr
; Function compile flags: /Odtp
;	COMDAT ?getSingletonPtr@?$Singleton@VHardwarePixelBufferManager@Ogre@@@Ogre@@SAPAVHardwarePixelBufferManager@2@XZ
_TEXT	SEGMENT
?getSingletonPtr@?$Singleton@VHardwarePixelBufferManager@Ogre@@@Ogre@@SAPAVHardwarePixelBufferManager@2@XZ PROC ; Ogre::Singleton<Ogre::HardwarePixelBufferManager>::getSingletonPtr, COMDAT

; 79   : 		{ return ms_Singleton; }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR ?ms_Singleton@?$Singleton@VHardwarePixelBufferManager@Ogre@@@Ogre@@1PAVHardwarePixelBufferManager@2@A ; Ogre::Singleton<Ogre::HardwarePixelBufferManager>::ms_Singleton
	pop	ebp
	ret	0
?getSingletonPtr@?$Singleton@VHardwarePixelBufferManager@Ogre@@@Ogre@@SAPAVHardwarePixelBufferManager@2@XZ ENDP ; Ogre::Singleton<Ogre::HardwarePixelBufferManager>::getSingletonPtr
_TEXT	ENDS
PUBLIC	??0?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@ABU?$less@I@1@ABV?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >
PUBLIC	??0?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@std@@QAE@XZ ; std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\map
xdata$x	SEGMENT
__unwindtable$??0?$map@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$map@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@@std@@QAE@XZ$0
__ehfuncinfo$??0?$map@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$map@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$map@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T72370 = -14						; size = 1
$T72369 = -13						; size = 1
__$EHRec$ = -12						; size = 12
??0?$map@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@@std@@QAE@XZ PROC ; std::map<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> > >::map<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> > >, COMDAT
; _this$ = ecx

; 103  : 		{	// construct empty map from defaults

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$map@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	lea	ecx, DWORD PTR $T72369[ebp]
	call	??0?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@std@@QAE@XZ ; std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >
	push	eax
	lea	eax, DWORD PTR $T72370[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@ABU?$less@I@1@ABV?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 104  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$map@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::~_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >
__ehhandler$??0?$map@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$map@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$map@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@@std@@QAE@XZ ENDP ; std::map<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> > >::map<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> > >
PUBLIC	??Diterator@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QBEAAU?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::iterator::operator*
PUBLIC	?insert@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@ABU?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::insert
PUBLIC	??0?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@QAE@ABIABQAVHardwarePixelBufferPool@Ogre@@@Z ; std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *>::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *>
PUBLIC	??R?$less@I@std@@QBE_NABI0@Z			; std::less<unsigned int>::operator()
PUBLIC	?_Key@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAABIPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Key
PUBLIC	?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@3@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::const_iterator::_Mynode
PUBLIC	?lower_bound@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@ABI@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::lower_bound
; Function compile flags: /Odtp
;	COMDAT ??A?$map@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@@std@@QAEAAPAVHardwarePixelBufferPool@Ogre@@ABI@Z
_TEXT	SEGMENT
_this$ = -48						; size = 4
$T72384 = -44						; size = 8
$T72383 = -36						; size = 8
$T72382 = -28						; size = 4
$T72381 = -24						; size = 8
$T72380 = -16						; size = 8
__Where$ = -8						; size = 8
__Keyval$ = 8						; size = 4
??A?$map@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@@std@@QAEAAPAVHardwarePixelBufferPool@Ogre@@ABI@Z PROC ; std::map<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> > >::operator[], COMDAT
; _this$ = ecx

; 168  : 		{	// find element matching _Keyval or insert with default mapped

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H
	mov	DWORD PTR _this$[ebp], ecx

; 169  : 		iterator _Where = this->lower_bound(_Keyval);

	mov	eax, DWORD PTR __Keyval$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Where$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?lower_bound@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@ABI@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::lower_bound

; 170  : 		if (_Where == this->end()
; 171  : 			|| this->comp(_Keyval, this->_Key(_Where._Mynode())))

	lea	edx, DWORD PTR $T72380[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::end
	push	eax
	lea	ecx, DWORD PTR __Where$[ebp]
	call	??8const_iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::const_iterator::operator==
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN1@operator@8
	lea	ecx, DWORD PTR __Where$[ebp]
	call	?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@3@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::const_iterator::_Mynode
	push	eax
	call	?_Key@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAABIPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Key
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Keyval$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??R?$less@I@std@@QBE_NABI0@Z		; std::less<unsigned int>::operator()
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN2@operator@8
$LN1@operator@8:

; 172  : 			_Where = this->insert(_Where,
; 173  : 				value_type(_Keyval, mapped_type()));

	mov	DWORD PTR $T72382[ebp], 0
	mov	eax, DWORD PTR __Where$[ebp]
	mov	DWORD PTR $T72383[ebp], eax
	mov	ecx, DWORD PTR __Where$[ebp+4]
	mov	DWORD PTR $T72383[ebp+4], ecx
	lea	edx, DWORD PTR $T72382[ebp]
	push	edx
	mov	eax, DWORD PTR __Keyval$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T72381[ebp]
	call	??0?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@QAE@ABIABQAVHardwarePixelBufferPool@Ogre@@@Z ; std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *>::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *>
	push	eax
	mov	ecx, DWORD PTR $T72383[ebp+4]
	push	ecx
	mov	edx, DWORD PTR $T72383[ebp]
	push	edx
	lea	eax, DWORD PTR $T72384[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?insert@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@ABU?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::insert
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR __Where$[ebp], ecx
	mov	DWORD PTR __Where$[ebp+4], edx
$LN2@operator@8:

; 174  : 		return ((*_Where).second);

	lea	ecx, DWORD PTR __Where$[ebp]
	call	??Diterator@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QBEAAU?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::iterator::operator*
	add	eax, 4

; 175  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??A?$map@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@@std@@QAEAAPAVHardwarePixelBufferPool@Ogre@@ABI@Z ENDP ; std::map<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> > >::operator[]
_TEXT	ENDS
PUBLIC	??1?$_Tree_val@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ ; std::_Tree_val<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::~_Tree_val<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >
PUBLIC	?_Tidy@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Tidy
PUBLIC	?_Copy@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEXABV12@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Copy
PUBLIC	?_Init@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Init
PUBLIC	??0?$_Tree_val@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@1@@Z ; std::_Tree_val<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Tree_val<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >
PUBLIC	?key_comp@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QBE?AU?$less@I@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::key_comp
PUBLIC	?get_allocator@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QBE?AV?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::get_allocator
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
xdata$x	SEGMENT
__catchsym$??0?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@ABV01@@Z$3 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??0?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@ABV01@@Z$0
__tryblocktable$??0?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@ABV01@@Z DD 01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??0?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@ABV01@@Z$3
__unwindtable$??0?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@ABV01@@Z$2
	DD	00H
	DD	00H
	DD	00H
	DD	00H
__ehfuncinfo$??0?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@ABV01@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@ABV01@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??0?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -28						; size = 4
$T72388 = -21						; size = 1
$T72387 = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Right$ = 8						; size = 4
??0?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@ABV01@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >, COMDAT
; _this$ = ecx

; 528  : 		{	// construct tree by copying _Right

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 12					; 0000000cH
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	eax, esp
	mov	DWORD PTR $T72387[ebp], esp
	push	eax
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?get_allocator@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QBE?AV?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::get_allocator
	lea	ecx, DWORD PTR $T72388[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?key_comp@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QBE?AU?$less@I@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::key_comp
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Tree_val@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@1@@Z ; std::_Tree_val<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Tree_val<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >
	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 529  : 		_Init();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Init@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Init

; 530  : 		_TRY_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 1

; 531  : 		_Copy(_Right);

	mov	edx, DWORD PTR __Right$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Copy@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEXABV12@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Copy
	jmp	SHORT $LN4@Tree@2
__catch$??0?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@ABV01@@Z$0:

; 532  : 		_CATCH_ALL
; 533  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Tidy

; 534  : 		_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 535  : 		_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], 0
	mov	eax, $LN2@Tree@2
	ret	0
$LN4@Tree@2:
	mov	DWORD PTR __$EHRec$[ebp+12], 0
$LN2@Tree@2:

; 536  : 		}

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, DWORD PTR _this$[ebp]
$LN3@Tree@2:
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@ABV01@@Z$2:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Tree_val@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ
__ehhandler$??0?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-32]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@ABV01@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::~_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >, COMDAT
; _this$ = ecx

; 539  : 		{	// destroy tree

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 540  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Tidy

; 541  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Tree_val@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Tree_val@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ
__ehhandler$??1?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::~_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >
PUBLIC	?erase@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::erase
; Function compile flags: /Odtp
;	COMDAT ??4?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -44						; size = 4
$T72418 = -40						; size = 8
$T72417 = -32						; size = 8
$T72416 = -24						; size = 8
$T72415 = -16						; size = 8
$T72414 = -8						; size = 8
__Right$ = 8						; size = 4
??4?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAEAAV01@ABV01@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::operator=, COMDAT
; _this$ = ecx

; 544  : 		{	// replace contents from _Right

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	mov	DWORD PTR _this$[ebp], ecx

; 545  : 		if (this != &_Right)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR __Right$[ebp]
	je	SHORT $LN1@operator@9

; 546  : 			{	// worth doing
; 547  : 			erase(begin(), end());

	lea	ecx, DWORD PTR $T72415[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::end
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR $T72414[ebp], edx
	mov	DWORD PTR $T72414[ebp+4], eax
	lea	ecx, DWORD PTR $T72417[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::begin
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR $T72416[ebp], edx
	mov	DWORD PTR $T72416[ebp+4], eax
	mov	ecx, DWORD PTR $T72414[ebp+4]
	push	ecx
	mov	edx, DWORD PTR $T72414[ebp]
	push	edx
	mov	eax, DWORD PTR $T72416[ebp+4]
	push	eax
	mov	ecx, DWORD PTR $T72416[ebp]
	push	ecx
	lea	edx, DWORD PTR $T72418[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::erase

; 548  : 			this->comp = _Right.comp;
; 549  : 			_Copy(_Right);

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Copy@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEXABV12@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Copy
$LN1@operator@9:

; 550  : 			}
; 551  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 552  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??4?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAEAAV01@ABV01@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::operator=
_TEXT	ENDS
PUBLIC	??0iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PBV12@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::iterator::iterator
PUBLIC	?_Lmost@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Lmost
; Function compile flags: /Odtp
;	COMDAT ?begin@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::begin, COMDAT
; _this$ = ecx

; 555  : 		{	// return iterator for beginning of mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 556  : 		return (_TREE_ITERATOR(_Lmost()));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lmost@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Lmost
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PBV12@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::iterator::iterator
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 557  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?begin@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::begin
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?end@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::end, COMDAT
; _this$ = ecx

; 565  : 		{	// return iterator for end of mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 566  : 		return (_TREE_ITERATOR(_Myhead));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PBV12@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::iterator::iterator
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 567  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?end@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::end
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?find@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@ABI@Z
_TEXT	SEGMENT
tv137 = -36						; size = 4
_this$ = -32						; size = 4
$T72428 = -28						; size = 8
$T72426 = -20						; size = 8
$T72425 = -12						; size = 4
__Where$ = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__Keyval$ = 12						; size = 4
?find@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@ABI@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::find, COMDAT
; _this$ = ecx

; 977  : 		{	// find an element in mutable sequence that matches _Keyval

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	mov	DWORD PTR _this$[ebp], ecx

; 978  : 		iterator _Where = lower_bound(_Keyval);

	mov	eax, DWORD PTR __Keyval$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Where$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?lower_bound@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@ABI@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::lower_bound

; 979  : 		return (_Where == end()
; 980  : 			|| _DEBUG_LT_PRED(this->comp,
; 981  : 				_Keyval, _Key(_Where._Mynode()))
; 982  : 					? end() : _Where);

	lea	edx, DWORD PTR $T72426[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::end
	push	eax
	lea	ecx, DWORD PTR __Where$[ebp]
	call	??8const_iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::const_iterator::operator==
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN3@find
	lea	ecx, DWORD PTR __Where$[ebp]
	call	?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@3@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::const_iterator::_Mynode
	push	eax
	call	?_Key@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAABIPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Key
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Keyval$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??R?$less@I@std@@QBE_NABI0@Z		; std::less<unsigned int>::operator()
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN3@find
	lea	eax, DWORD PTR __Where$[ebp]
	mov	DWORD PTR tv137[ebp], eax
	jmp	SHORT $LN4@find
$LN3@find:
	lea	ecx, DWORD PTR $T72428[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::end
	mov	DWORD PTR tv137[ebp], eax
$LN4@find:
	mov	edx, DWORD PTR tv137[ebp]
	mov	DWORD PTR $T72425[ebp], edx
	mov	eax, DWORD PTR $T72425[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 983  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?find@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@ABI@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::find
_TEXT	ENDS
PUBLIC	??D?$_Vector_const_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QBEABQAVHardwarePixelBuffer@Ogre@@XZ ; std::_Vector_const_iterator<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::operator*
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??D?$_Vector_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QBEAAPAVHardwarePixelBuffer@Ogre@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??D?$_Vector_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QBEAAPAVHardwarePixelBuffer@Ogre@@XZ PROC ; std::_Vector_iterator<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::operator*, COMDAT
; _this$ = ecx

; 338  : 		{	// return designated object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 339  : 		return ((reference)**(_Mybase *)this);

	mov	ecx, DWORD PTR _this$[ebp]
	call	??D?$_Vector_const_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QBEABQAVHardwarePixelBuffer@Ogre@@XZ ; std::_Vector_const_iterator<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::operator*

; 340  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??D?$_Vector_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QBEAAPAVHardwarePixelBuffer@Ogre@@XZ ENDP ; std::_Vector_iterator<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::operator*
_TEXT	ENDS
PUBLIC	??E?$_Vector_const_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::operator++
; Function compile flags: /Odtp
;	COMDAT ??E?$_Vector_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??E?$_Vector_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_iterator<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::operator++, COMDAT
; _this$ = ecx

; 348  : 		{	// preincrement

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 349  : 		++(*(_Mybase *)this);

	mov	ecx, DWORD PTR _this$[ebp]
	call	??E?$_Vector_const_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::operator++

; 350  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 351  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??E?$_Vector_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_iterator<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::operator++
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::operator==
; Function compile flags: /Odtp
;	COMDAT ??9?$_Vector_const_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::operator!=, COMDAT
; _this$ = ecx

; 215  : 		{	// test for iterator inequality

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??8?$_Vector_const_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::operator==
	movzx	eax, al
	neg	eax
	sbb	eax, eax
	add	eax, 1

; 217  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??9?$_Vector_const_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::operator!=
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ??Citerator@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QBEPAU?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??Citerator@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QBEPAU?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::iterator::operator->, COMDAT
; _this$ = ecx

; 469  : 			{	// return pointer to class object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 470  : 			return (&**this);

	mov	ecx, DWORD PTR _this$[ebp]
	call	??Diterator@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QBEAAU?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::iterator::operator*

; 471  : 			}

	mov	esp, ebp
	pop	ebp
	ret	0
??Citerator@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QBEPAU?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::iterator::operator->
_TEXT	ENDS
PUBLIC	??Eiterator@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::iterator::operator++
; Function compile flags: /Odtp
;	COMDAT ??Eiterator@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AV012@H@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
__Tmp$ = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??Eiterator@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AV012@H@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::iterator::operator++, COMDAT
; _this$ = ecx

; 480  : 			{	// postincrement

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 481  : 			iterator _Tmp = *this;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR __Tmp$[ebp], ecx
	mov	DWORD PTR __Tmp$[ebp+4], edx

; 482  : 			++*this;

	mov	ecx, DWORD PTR _this$[ebp]
	call	??Eiterator@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::iterator::operator++

; 483  : 			return (_Tmp);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR __Tmp$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR __Tmp$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 484  : 			}

	mov	esp, ebp
	pop	ebp
	ret	8
??Eiterator@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AV012@H@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::iterator::operator++
_TEXT	ENDS
PUBLIC	?_Same_container@_Iterator_base_aux@std@@QBE_NABV12@@Z ; std::_Iterator_base_aux::_Same_container
PUBLIC	?_Has_container@_Iterator_base_aux@std@@QBE_NXZ	; std::_Iterator_base_aux::_Has_container
; Function compile flags: /Odtp
;	COMDAT ??8const_iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??8const_iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QBE_NABV012@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::const_iterator::operator==, COMDAT
; _this$ = ecx

; 299  : 			{	// test for iterator equality

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 300  : 
; 301  :  #if _HAS_ITERATOR_DEBUGGING
; 302  : 			if (this->_Mycont == 0 || this->_Mycont != _Right._Mycont)
; 303  : 				{
; 304  : 				_DEBUG_ERROR("map/set iterators incompatible");
; 305  : 				_SCL_SECURE_INVALID_ARGUMENT;
; 306  : 				}
; 307  :  #else
; 308  : 			_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Has_container@_Iterator_base_aux@std@@QBE_NXZ ; std::_Iterator_base_aux::_Has_container
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@operator@10
	mov	ecx, DWORD PTR __Right$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Same_container@_Iterator_base_aux@std@@QBE_NABV12@@Z ; std::_Iterator_base_aux::_Same_container
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN2@operator@10
$LN1@operator@10:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@operator@10:

; 309  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 310  : 
; 311  : 			return (_Ptr == _Right._Ptr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [eax+4]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+4]
	sete	al

; 312  : 			}

	mov	esp, ebp
	pop	ebp
	ret	4
??8const_iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QBE_NABV012@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::const_iterator::operator==
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ?_Same_container@_Iterator_base_aux@std@@QBE_NABV12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Other$ = 8						; size = 4
?_Same_container@_Iterator_base_aux@std@@QBE_NABV12@@Z PROC ; std::_Iterator_base_aux::_Same_container, COMDAT
; _this$ = ecx

; 462  : 		{	// Accelerate the comparison by not going through the aux object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 463  : 		return _Myaux == _Other._Myaux;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Other$[ebp]
	mov	edx, DWORD PTR [eax]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx]
	sete	al

; 464  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Same_container@_Iterator_base_aux@std@@QBE_NABV12@@Z ENDP ; std::_Iterator_base_aux::_Same_container
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Has_container@_Iterator_base_aux@std@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Has_container@_Iterator_base_aux@std@@QBE_NXZ PROC	; std::_Iterator_base_aux::_Has_container, COMDAT
; _this$ = ecx

; 467  : 		{	// Accelerate the comparison by not going through the aux object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 468  : 		return _Myaux != 0;

	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	cmp	DWORD PTR [eax], 0
	setne	cl
	mov	al, cl

; 469  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Has_container@_Iterator_base_aux@std@@QBE_NXZ ENDP	; std::_Iterator_base_aux::_Has_container
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ??9const_iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??9const_iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QBE_NABV012@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::const_iterator::operator!=, COMDAT
; _this$ = ecx

; 315  : 			{	// test for iterator inequality

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 316  : 			return (!(*this == _Right));

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??8const_iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::const_iterator::operator==
	movzx	eax, al
	neg	eax
	sbb	eax, eax
	add	eax, 1

; 317  : 			}

	mov	esp, ebp
	pop	ebp
	ret	4
??9const_iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QBE_NABV012@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::const_iterator::operator!=
_TEXT	ENDS
PUBLIC	??1?$_Tree_ptr@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ ; std::_Tree_ptr<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::~_Tree_ptr<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$_Tree_val@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Tree_val@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$_Tree_val@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Tree_val@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$_Tree_val@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Tree_val@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree_val<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::~_Tree_val<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Tree_val@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Tree_ptr@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Tree_val@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Tree_ptr@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ
__ehhandler$??1?$_Tree_val@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Tree_val@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Tree_val@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree_val<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::~_Tree_val<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >
PUBLIC	??1?$_Container_base_aux_alloc_real@V?$allocator@D@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<char> >::~_Container_base_aux_alloc_real<std::allocator<char> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$_Vector_val@DV?$allocator@D@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Vector_val@DV?$allocator@D@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$_Vector_val@DV?$allocator@D@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Vector_val@DV?$allocator@D@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$_Vector_val@DV?$allocator@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Vector_val@DV?$allocator@D@std@@@std@@QAE@XZ PROC	; std::_Vector_val<char,std::allocator<char> >::~_Vector_val<char,std::allocator<char> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Vector_val@DV?$allocator@D@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Container_base_aux_alloc_real@V?$allocator@D@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<char> >::~_Container_base_aux_alloc_real<std::allocator<char> >
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Vector_val@DV?$allocator@D@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Container_base_aux_alloc_real@V?$allocator@D@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<char> >::~_Container_base_aux_alloc_real<std::allocator<char> >
__ehhandler$??1?$_Vector_val@DV?$allocator@D@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Vector_val@DV?$allocator@D@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Vector_val@DV?$allocator@D@std@@@std@@QAE@XZ ENDP	; std::_Vector_val<char,std::allocator<char> >::~_Vector_val<char,std::allocator<char> >
PUBLIC	??1?$_Container_base_aux_alloc_real@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::SurfaceData *> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::SurfaceData *> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$_Vector_val@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Vector_val@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$_Vector_val@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Vector_val@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$_Vector_val@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Vector_val@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::~_Vector_val<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Vector_val@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Container_base_aux_alloc_real@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::SurfaceData *> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::SurfaceData *> >
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Vector_val@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Container_base_aux_alloc_real@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::SurfaceData *> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::SurfaceData *> >
__ehhandler$??1?$_Vector_val@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Vector_val@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Vector_val@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::~_Vector_val<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >
PUBLIC	??1?$_Container_base_aux_alloc_real@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::HardwarePixelBuffer *> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::HardwarePixelBuffer *> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$_Vector_val@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Vector_val@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$_Vector_val@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Vector_val@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$_Vector_val@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Vector_val@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::~_Vector_val<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Vector_val@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Container_base_aux_alloc_real@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::HardwarePixelBuffer *> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::HardwarePixelBuffer *> >
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Vector_val@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Container_base_aux_alloc_real@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::HardwarePixelBuffer *> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::HardwarePixelBuffer *> >
__ehhandler$??1?$_Vector_val@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Vector_val@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Vector_val@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::~_Vector_val<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >
PUBLIC	??1?$_Tree_ptr@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ ; std::_Tree_ptr<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::~_Tree_ptr<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$_Tree_val@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Tree_val@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$_Tree_val@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Tree_val@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$_Tree_val@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Tree_val@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree_val<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::~_Tree_val<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Tree_val@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Tree_ptr@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Tree_val@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Tree_ptr@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ
__ehhandler$??1?$_Tree_val@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Tree_val@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Tree_val@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree_val<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::~_Tree_val<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >
PUBLIC	??1?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ ; std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::~_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$_Tree_ptr@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Tree_ptr@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$_Tree_ptr@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Tree_ptr@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$_Tree_ptr@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Tree_ptr@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree_ptr<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::~_Tree_ptr<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Tree_ptr@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Tree_ptr@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ
__ehhandler$??1?$_Tree_ptr@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Tree_ptr@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Tree_ptr@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree_ptr<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::~_Tree_ptr<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >
PUBLIC	??1?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ ; std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::~_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$_Tree_ptr@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Tree_ptr@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$_Tree_ptr@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Tree_ptr@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$_Tree_ptr@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Tree_ptr@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree_ptr<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::~_Tree_ptr<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Tree_ptr@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Tree_ptr@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ
__ehhandler$??1?$_Tree_ptr@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Tree_ptr@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Tree_ptr@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree_ptr<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::~_Tree_ptr<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >
PUBLIC	??1?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@QAE@XZ ; std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0>::~_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0>
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::~_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@QAE@XZ
__ehhandler$??1?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::~_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >
PUBLIC	??1?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@QAE@XZ ; std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0>::~_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0>
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::~_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@QAE@XZ
__ehhandler$??1?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::~_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >
PUBLIC	??1?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> > >::~_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> > >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@QAE@XZ$0
__ehfuncinfo$??1?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@QAE@XZ PROC ; std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0>::~_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> > >::~_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> > >
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> > >::~_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> > >
__ehhandler$??1?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@QAE@XZ ENDP ; std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0>::~_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0>
PUBLIC	??1?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> > >::~_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> > >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@QAE@XZ$0
__ehfuncinfo$??1?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@QAE@XZ PROC ; std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0>::~_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> > >::~_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> > >
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> > >::~_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> > >
__ehhandler$??1?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@QAE@XZ ENDP ; std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0>::~_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0>
PUBLIC	??0iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PBV12@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::iterator::iterator
PUBLIC	?_Lmost@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Lmost
; Function compile flags: /Odtp
;	COMDAT ?begin@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::begin, COMDAT
; _this$ = ecx

; 555  : 		{	// return iterator for beginning of mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 556  : 		return (_TREE_ITERATOR(_Lmost()));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lmost@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Lmost
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PBV12@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::iterator::iterator
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 557  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?begin@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::begin
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?end@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::end, COMDAT
; _this$ = ecx

; 565  : 		{	// return iterator for end of mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 566  : 		return (_TREE_ITERATOR(_Myhead));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PBV12@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::iterator::iterator
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 567  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?end@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::end
_TEXT	ENDS
PUBLIC	??0?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >
; Function compile flags: /Odtp
;	COMDAT ?get_allocator@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QBE?AV?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?get_allocator@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QBE?AV?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::get_allocator, COMDAT
; _this$ = ecx

; 615  : 		{	// return allocator object for values

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 616  : 		return (this->_Alval);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 20					; 00000014H
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 617  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?get_allocator@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QBE?AV?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::get_allocator
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?key_comp@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QBE?AU?$less@I@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?key_comp@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QBE?AU?$less@I@2@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::key_comp, COMDAT
; _this$ = ecx

; 620  : 		{	// return object for comparing keys

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 621  : 		return (this->comp);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 622  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?key_comp@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QBE?AU?$less@I@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::key_comp
_TEXT	ENDS
PUBLIC	?_Make_iter@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QBE?AViterator@12@Vconst_iterator@12@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Make_iter
PUBLIC	?erase@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::erase
PUBLIC	??Econst_iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AV012@H@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::const_iterator::operator++
PUBLIC	??9const_iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::const_iterator::operator!=
PUBLIC	?clear@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::clear
PUBLIC	??8const_iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::const_iterator::operator==
; Function compile flags: /Odtp
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z
_TEXT	SEGMENT
_this$ = -36						; size = 4
$T72560 = -32						; size = 8
$T72559 = -24						; size = 8
$T72558 = -16						; size = 8
$T72557 = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 8
__Last$ = 20						; size = 8
?erase@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::erase, COMDAT
; _this$ = ecx

; 934  : 		{	// erase [_First, _Last)

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	mov	DWORD PTR _this$[ebp], ecx

; 935  : 		if (_First == begin() && _Last == end())

	lea	eax, DWORD PTR $T72557[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::begin
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	call	??8const_iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::const_iterator::operator==
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@erase
	lea	edx, DWORD PTR $T72558[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::end
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	call	??8const_iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::const_iterator::operator==
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@erase

; 936  : 			{	// erase all
; 937  : 			clear();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?clear@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::clear

; 938  : 			return (begin());

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::begin
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN5@erase

; 939  : 			}
; 940  : 		else

	jmp	SHORT $LN5@erase
$LN2@erase:

; 941  : 			{	// partial erase, one at a time
; 942  : 			while (_First != _Last)

	lea	edx, DWORD PTR __Last$[ebp]
	push	edx
	lea	ecx, DWORD PTR __First$[ebp]
	call	??9const_iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::const_iterator::operator!=
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@erase

; 943  : 				erase(_First++);

	push	0
	lea	ecx, DWORD PTR $T72559[ebp]
	push	ecx
	lea	ecx, DWORD PTR __First$[ebp]
	call	??Econst_iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AV012@H@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::const_iterator::operator++
	mov	edx, DWORD PTR [eax+4]
	push	edx
	mov	eax, DWORD PTR [eax]
	push	eax
	lea	ecx, DWORD PTR $T72560[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::erase
	jmp	SHORT $LN2@erase
$LN1@erase:

; 944  : 			return (_Make_iter(_First));

	mov	edx, DWORD PTR __First$[ebp+4]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Make_iter@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QBE?AViterator@12@Vconst_iterator@12@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Make_iter
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN5@erase:

; 945  : 			}
; 946  : 		}

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?erase@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::erase
_TEXT	ENDS
PUBLIC	?_Rmost@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Rmost
PUBLIC	?_Max@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Max
PUBLIC	?_Min@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Min
PUBLIC	?_Isnil@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Isnil
PUBLIC	?size@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::size
PUBLIC	?_Copy@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@0@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Copy
PUBLIC	?_Root@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Root
; Function compile flags: /Odtp
;	COMDAT ?_Copy@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEXABV12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
?_Copy@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEXABV12@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Copy, COMDAT
; _this$ = ecx

; 1062 : 		{	// copy entire tree from _Right

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 1063 : 		_Root() = _Copy(_Right._Root(), _Myhead);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	push	ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Root
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Copy@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@0@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Copy
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Root
	mov	DWORD PTR [eax], esi

; 1064 : 		_Mysize = _Right.size();

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::size
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+28], eax

; 1065 : 		if (!_Isnil(_Root()))

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Root
	mov	edx, DWORD PTR [eax]
	push	edx
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Isnil
	add	esp, 4
	movsx	eax, BYTE PTR [eax]
	test	eax, eax
	jne	SHORT $LN2@Copy

; 1066 : 			{	// nonempty tree, look for new smallest and largest
; 1067 : 			_Lmost() = _Min(_Root());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Root
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?_Min@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Min
	add	esp, 4
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lmost@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Lmost
	mov	DWORD PTR [eax], esi

; 1068 : 			_Rmost() = _Max(_Root());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Root
	mov	edx, DWORD PTR [eax]
	push	edx
	call	?_Max@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Max
	add	esp, 4
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rmost@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Rmost
	mov	DWORD PTR [eax], esi

; 1069 : 			}
; 1070 : 		else

	jmp	SHORT $LN3@Copy
$LN2@Copy:

; 1071 : 			_Lmost() = _Myhead, _Rmost() = _Myhead;	// empty tree

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lmost@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Lmost
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rmost@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Rmost
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR [eax], edx
$LN3@Copy:

; 1072 : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?_Copy@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEXABV12@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Copy
_TEXT	ENDS
PUBLIC	?_Buynode@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Buynode
; Function compile flags: /Odtp
;	COMDAT ?_Init@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Init@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEXXZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Init, COMDAT
; _this$ = ecx

; 1177 : 		{	// create head/nil node and make tree empty

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1178 : 		_Myhead = _Buynode();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buynode@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Buynode
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+24], eax

; 1179 : 		_Isnil(_Myhead) = true;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24]
	push	eax
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Isnil
	add	esp, 4
	mov	BYTE PTR [eax], 1

; 1180 : 		_Root() = _Myhead;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Root
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR [eax], edx

; 1181 : 		_Lmost() = _Myhead, _Rmost() = _Myhead;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lmost@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Lmost
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rmost@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Rmost
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR [eax], edx

; 1182 : 		_Mysize = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+28], 0

; 1183 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Init@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Init
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Node>::deallocate
PUBLIC	?_Right@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Right
PUBLIC	?_Parent@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Parent
PUBLIC	?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Node *>::destroy
PUBLIC	?_Left@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Left
; Function compile flags: /Odtp
;	COMDAT ?_Tidy@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -44						; size = 4
$T72571 = -40						; size = 8
$T72570 = -32						; size = 8
$T72569 = -24						; size = 8
$T72568 = -16						; size = 8
$T72567 = -8						; size = 8
?_Tidy@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEXXZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Tidy, COMDAT
; _this$ = ecx

; 1420 : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	mov	DWORD PTR _this$[ebp], ecx

; 1421 : 		erase(begin(), end());

	lea	eax, DWORD PTR $T72568[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::end
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T72567[ebp], ecx
	mov	DWORD PTR $T72567[ebp+4], edx
	lea	eax, DWORD PTR $T72570[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::begin
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T72569[ebp], ecx
	mov	DWORD PTR $T72569[ebp+4], edx
	mov	eax, DWORD PTR $T72567[ebp+4]
	push	eax
	mov	ecx, DWORD PTR $T72567[ebp]
	push	ecx
	mov	edx, DWORD PTR $T72569[ebp+4]
	push	edx
	mov	eax, DWORD PTR $T72569[ebp]
	push	eax
	lea	ecx, DWORD PTR $T72571[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::erase

; 1422 : 		this->_Alptr.destroy(&_Left(_Myhead));

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Left
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Node *>::destroy

; 1423 : 		this->_Alptr.destroy(&_Parent(_Myhead));

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Parent
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Node *>::destroy

; 1424 : 		this->_Alptr.destroy(&_Right(_Myhead));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	push	ecx
	call	?_Right@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Right
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Node *>::destroy

; 1425 : 		this->_Alnod.deallocate(_Myhead, 1);

	push	1
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Node>::deallocate

; 1426 : 		_Myhead = 0, _Mysize = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+24], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+28], 0

; 1427 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Tidy
_TEXT	ENDS
PUBLIC	??0?$_Tree_ptr@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@1@@Z ; std::_Tree_ptr<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Tree_ptr<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$_Tree_val@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Tree_val@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@1@@Z$0
__ehfuncinfo$??0?$_Tree_val@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Tree_val@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Tree_val@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T72574 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Parg$ = 8						; size = 4
__Al$ = 12						; size = 1
??0?$_Tree_val@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@1@@Z PROC ; std::_Tree_val<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Tree_val<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >, COMDAT
; _this$ = ecx

; 97   : 		{	// construct base, and allocator from _Al

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Tree_val@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T72574[ebp], esp
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	call	??0?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >
	mov	ecx, DWORD PTR __Parg$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Tree_ptr@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@1@@Z ; std::_Tree_ptr<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Tree_ptr<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 20					; 00000014H
	call	??0?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >

; 98   : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Tree_val@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Tree_ptr@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ
__ehhandler$??0?$_Tree_val@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Tree_val@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Tree_val@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@1@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Tree_val<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >
PUBLIC	??1_Container_base_aux@std@@QAE@XZ		; std::_Container_base_aux::~_Container_base_aux
PUBLIC	?deallocate@?$allocator@V_Aux_cont@std@@@std@@QAEXPAV_Aux_cont@2@I@Z ; std::allocator<std::_Aux_cont>::deallocate
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??1?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@std@@@std@@IAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@std@@@std@@IAE@XZ$0
__ehfuncinfo$??1?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@std@@@std@@IAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@std@@@std@@IAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> > >::~_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> > >, COMDAT
; _this$ = ecx

; 436  : 		{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@std@@@std@@IAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 437  : 		_Myownedaux->~_Aux_cont();
; 438  : 
; 439  : 		_Alaux.deallocate(_Myownedaux, 1);

	push	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?deallocate@?$allocator@V_Aux_cont@std@@@std@@QAEXPAV_Aux_cont@2@I@Z ; std::allocator<std::_Aux_cont>::deallocate

; 440  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@std@@@std@@IAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
__ehhandler$??1?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@std@@@std@@IAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@std@@@std@@IAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> > >::~_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> > >
; Function compile flags: /Odtp
;	COMDAT ??1_Container_base_aux@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_Container_base_aux@std@@QAE@XZ PROC			; std::_Container_base_aux::~_Container_base_aux, COMDAT
; _this$ = ecx

; 402  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 403  : 		// Do nothing: ~_Container_base_aux_alloc_real() previously destroyed the aux object.
; 404  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??1_Container_base_aux@std@@QAE@XZ ENDP			; std::_Container_base_aux::~_Container_base_aux
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\functional
_TEXT	ENDS
;	COMDAT ??R?$less@I@std@@QBE_NABI0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??R?$less@I@std@@QBE_NABI0@Z PROC			; std::less<unsigned int>::operator(), COMDAT
; _this$ = ecx

; 142  : 		{	// apply operator< to operands

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 143  : 		return (_Left < _Right);

	mov	eax, DWORD PTR __Left$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx]
	sbb	eax, eax
	neg	eax

; 144  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
??R?$less@I@std@@QBE_NABI0@Z ENDP			; std::less<unsigned int>::operator()
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?capacity@?$vector@DV?$allocator@D@std@@@std@@QBEIXZ
_TEXT	SEGMENT
tv69 = -8						; size = 4
_this$ = -4						; size = 4
?capacity@?$vector@DV?$allocator@D@std@@@std@@QBEIXZ PROC ; std::vector<char,std::allocator<char> >::capacity, COMDAT
; _this$ = ecx

; 634  : 		{	// return current length of allocated storage

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	jne	SHORT $LN3@capacity
	mov	DWORD PTR tv69[ebp], 0
	jmp	SHORT $LN4@capacity
$LN3@capacity:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+20]
	sub	eax, DWORD PTR [edx+12]
	mov	DWORD PTR tv69[ebp], eax
$LN4@capacity:
	mov	eax, DWORD PTR tv69[ebp]

; 636  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?capacity@?$vector@DV?$allocator@D@std@@@std@@QBEIXZ ENDP ; std::vector<char,std::allocator<char> >::capacity
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@DV?$allocator@D@std@@@std@@QAE@PADPBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<char,std::allocator<char> >::_Vector_const_iterator<char,std::allocator<char> >
; Function compile flags: /Odtp
;	COMDAT ?begin@?$vector@DV?$allocator@D@std@@@std@@QBE?AV?$_Vector_const_iterator@DV?$allocator@D@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@DV?$allocator@D@std@@@std@@QBE?AV?$_Vector_const_iterator@DV?$allocator@D@std@@@2@XZ PROC ; std::vector<char,std::allocator<char> >::begin, COMDAT
; _this$ = ecx

; 645  : 		{	// return iterator for beginning of nonmutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 646  : 		return (const_iterator(_Myfirst, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_const_iterator@DV?$allocator@D@std@@@std@@QAE@PADPBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<char,std::allocator<char> >::_Vector_const_iterator<char,std::allocator<char> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 647  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?begin@?$vector@DV?$allocator@D@std@@@std@@QBE?AV?$_Vector_const_iterator@DV?$allocator@D@std@@@2@XZ ENDP ; std::vector<char,std::allocator<char> >::begin
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?end@?$vector@DV?$allocator@D@std@@@std@@QBE?AV?$_Vector_const_iterator@DV?$allocator@D@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@DV?$allocator@D@std@@@std@@QBE?AV?$_Vector_const_iterator@DV?$allocator@D@std@@@2@XZ PROC ; std::vector<char,std::allocator<char> >::end, COMDAT
; _this$ = ecx

; 655  : 		{	// return iterator for end of nonmutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 656  : 		return (const_iterator(_Mylast, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_const_iterator@DV?$allocator@D@std@@@std@@QAE@PADPBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<char,std::allocator<char> >::_Vector_const_iterator<char,std::allocator<char> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 657  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?end@?$vector@DV?$allocator@D@std@@@std@@QBE?AV?$_Vector_const_iterator@DV?$allocator@D@std@@@2@XZ ENDP ; std::vector<char,std::allocator<char> >::end
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?size@?$vector@DV?$allocator@D@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$vector@DV?$allocator@D@std@@@std@@QBEIXZ PROC	; std::vector<char,std::allocator<char> >::size, COMDAT
; _this$ = ecx

; 725  : 		{	// return length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+16]
	sub	eax, DWORD PTR [ecx+12]

; 727  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?size@?$vector@DV?$allocator@D@std@@@std@@QBEIXZ ENDP	; std::vector<char,std::allocator<char> >::size
_TEXT	ENDS
PUBLIC	?erase@?$vector@DV?$allocator@D@std@@@std@@QAE?AV?$_Vector_iterator@DV?$allocator@D@std@@@2@V?$_Vector_const_iterator@DV?$allocator@D@std@@@2@0@Z ; std::vector<char,std::allocator<char> >::erase
PUBLIC	?begin@?$vector@DV?$allocator@D@std@@@std@@QAE?AV?$_Vector_iterator@DV?$allocator@D@std@@@2@XZ ; std::vector<char,std::allocator<char> >::begin
PUBLIC	?end@?$vector@DV?$allocator@D@std@@@std@@QAE?AV?$_Vector_iterator@DV?$allocator@D@std@@@2@XZ ; std::vector<char,std::allocator<char> >::end
; Function compile flags: /Odtp
;	COMDAT ?clear@?$vector@DV?$allocator@D@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -44						; size = 4
$T72611 = -40						; size = 8
$T72610 = -32						; size = 8
$T72609 = -24						; size = 8
$T72608 = -16						; size = 8
$T72607 = -8						; size = 8
?clear@?$vector@DV?$allocator@D@std@@@std@@QAEXXZ PROC	; std::vector<char,std::allocator<char> >::clear, COMDAT
; _this$ = ecx

; 1059 : 		{	// erase all

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	mov	DWORD PTR _this$[ebp], ecx

; 1060 : 		erase(begin(), end());

	lea	eax, DWORD PTR $T72608[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$vector@DV?$allocator@D@std@@@std@@QAE?AV?$_Vector_iterator@DV?$allocator@D@std@@@2@XZ ; std::vector<char,std::allocator<char> >::end
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T72607[ebp], ecx
	mov	DWORD PTR $T72607[ebp+4], edx
	lea	eax, DWORD PTR $T72610[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$vector@DV?$allocator@D@std@@@std@@QAE?AV?$_Vector_iterator@DV?$allocator@D@std@@@2@XZ ; std::vector<char,std::allocator<char> >::begin
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T72609[ebp], ecx
	mov	DWORD PTR $T72609[ebp+4], edx
	mov	eax, DWORD PTR $T72607[ebp+4]
	push	eax
	mov	ecx, DWORD PTR $T72607[ebp]
	push	ecx
	mov	edx, DWORD PTR $T72609[ebp+4]
	push	edx
	mov	eax, DWORD PTR $T72609[ebp]
	push	eax
	lea	ecx, DWORD PTR $T72611[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$vector@DV?$allocator@D@std@@@std@@QAE?AV?$_Vector_iterator@DV?$allocator@D@std@@@2@V?$_Vector_const_iterator@DV?$allocator@D@std@@@2@0@Z ; std::vector<char,std::allocator<char> >::erase

; 1061 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?clear@?$vector@DV?$allocator@D@std@@@std@@QAEXXZ ENDP	; std::vector<char,std::allocator<char> >::clear
_TEXT	ENDS
PUBLIC	?_Xlen@?$vector@DV?$allocator@D@std@@@std@@KAXXZ ; std::vector<char,std::allocator<char> >::_Xlen
PUBLIC	?max_size@?$vector@DV?$allocator@D@std@@@std@@QBEIXZ ; std::vector<char,std::allocator<char> >::max_size
EXTRN	__imp_?allocate@?$allocator@D@std@@QAEPADI@Z:PROC
; Function compile flags: /Odtp
;	COMDAT ?_Buy@?$vector@DV?$allocator@D@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Capacity$ = 8						; size = 4
?_Buy@?$vector@DV?$allocator@D@std@@@std@@IAE_NI@Z PROC	; std::vector<char,std::allocator<char> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+20], 0

; 1104 : 		if (_Capacity == 0)

	cmp	DWORD PTR __Capacity$[ebp], 0
	jne	SHORT $LN4@Buy

; 1105 : 			return (false);

	xor	al, al
	jmp	SHORT $LN5@Buy
	jmp	SHORT $LN3@Buy
$LN4@Buy:

; 1106 : 		else if (max_size() < _Capacity)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@DV?$allocator@D@std@@@std@@QBEIXZ ; std::vector<char,std::allocator<char> >::max_size
	cmp	eax, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN2@Buy

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@DV?$allocator@D@std@@@std@@KAXXZ ; std::vector<char,std::allocator<char> >::_Xlen

; 1108 : 		else

	jmp	SHORT $LN3@Buy
$LN2@Buy:

; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	mov	eax, DWORD PTR __Capacity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	DWORD PTR __imp_?allocate@?$allocator@D@std@@QAEPADI@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [edx+16], ecx

; 1112 : 			_Myend = _Myfirst + _Capacity;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	add	eax, DWORD PTR __Capacity$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+20], eax
$LN3@Buy:

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
$LN5@Buy:

; 1115 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Buy@?$vector@DV?$allocator@D@std@@@std@@IAE_NI@Z ENDP	; std::vector<char,std::allocator<char> >::_Buy
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@D@std@@@std@@YAXPAD0AAV?$allocator@D@0@@Z ; std::_Destroy_range<std::allocator<char> >
; Function compile flags: /Odtp
;	COMDAT ?_Destroy@?$vector@DV?$allocator@D@std@@@std@@IAEXPAD0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@DV?$allocator@D@std@@@std@@IAEXPAD0@Z PROC ; std::vector<char,std::allocator<char> >::_Destroy, COMDAT
; _this$ = ecx

; 1118 : 		{	// destroy [_First, _Last) using allocator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Destroy_range@V?$allocator@D@std@@@std@@YAXPAD0AAV?$allocator@D@0@@Z ; std::_Destroy_range<std::allocator<char> >
	add	esp, 12					; 0000000cH

; 1120 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?_Destroy@?$vector@DV?$allocator@D@std@@@std@@IAEXPAD0@Z ENDP ; std::vector<char,std::allocator<char> >::_Destroy
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@DV?$allocator@D@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Tidy@?$vector@DV?$allocator@D@std@@@std@@IAEXXZ PROC	; std::vector<char,std::allocator<char> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	je	SHORT $LN1@Tidy

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@DV?$allocator@D@std@@@std@@IAEXPAD0@Z ; std::vector<char,std::allocator<char> >::_Destroy

; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+20]
	sub	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	DWORD PTR __imp_?deallocate@?$allocator@D@std@@QAEXPADI@Z
$LN1@Tidy:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+16], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], 0

; 1135 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$vector@DV?$allocator@D@std@@@std@@IAEXXZ ENDP	; std::vector<char,std::allocator<char> >::_Tidy
_TEXT	ENDS
PUBLIC	??0?$_Container_base_aux_alloc_real@V?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<char> >::_Container_base_aux_alloc_real<std::allocator<char> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$_Vector_val@DV?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Vector_val@DV?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z$0
__ehfuncinfo$??0?$_Vector_val@DV?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Vector_val@DV?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Vector_val@DV?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T72620 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 1
??0?$_Vector_val@DV?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z PROC ; std::_Vector_val<char,std::allocator<char> >::_Vector_val<char,std::allocator<char> >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Vector_val@DV?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T72620[ebp], esp
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	call	DWORD PTR __imp_??0?$allocator@D@std@@QAE@ABV01@@Z
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Container_base_aux_alloc_real@V?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<char> >::_Container_base_aux_alloc_real<std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	DWORD PTR __imp_??0?$allocator@D@std@@QAE@ABV01@@Z

; 426  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Vector_val@DV?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Container_base_aux_alloc_real@V?$allocator@D@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<char> >::~_Container_base_aux_alloc_real<std::allocator<char> >
__ehhandler$??0?$_Vector_val@DV?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Vector_val@DV?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Vector_val@DV?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z ENDP ; std::_Vector_val<char,std::allocator<char> >::_Vector_val<char,std::allocator<char> >
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??1?$_Container_base_aux_alloc_real@V?$allocator@D@std@@@std@@IAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Container_base_aux_alloc_real@V?$allocator@D@std@@@std@@IAE@XZ$0
__ehfuncinfo$??1?$_Container_base_aux_alloc_real@V?$allocator@D@std@@@std@@IAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Container_base_aux_alloc_real@V?$allocator@D@std@@@std@@IAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$_Container_base_aux_alloc_real@V?$allocator@D@std@@@std@@IAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Container_base_aux_alloc_real@V?$allocator@D@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_real<std::allocator<char> >::~_Container_base_aux_alloc_real<std::allocator<char> >, COMDAT
; _this$ = ecx

; 436  : 		{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Container_base_aux_alloc_real@V?$allocator@D@std@@@std@@IAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 437  : 		_Myownedaux->~_Aux_cont();
; 438  : 
; 439  : 		_Alaux.deallocate(_Myownedaux, 1);

	push	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?deallocate@?$allocator@V_Aux_cont@std@@@std@@QAEXPAV_Aux_cont@2@I@Z ; std::allocator<std::_Aux_cont>::deallocate

; 440  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Container_base_aux_alloc_real@V?$allocator@D@std@@@std@@IAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
__ehhandler$??1?$_Container_base_aux_alloc_real@V?$allocator@D@std@@@std@@IAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Container_base_aux_alloc_real@V?$allocator@D@std@@@std@@IAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Container_base_aux_alloc_real@V?$allocator@D@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_real<std::allocator<char> >::~_Container_base_aux_alloc_real<std::allocator<char> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?capacity@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
tv70 = -8						; size = 4
_this$ = -4						; size = 4
?capacity@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QBEIXZ PROC ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::capacity, COMDAT
; _this$ = ecx

; 634  : 		{	// return current length of allocated storage

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	jne	SHORT $LN3@capacity@2
	mov	DWORD PTR tv70[ebp], 0
	jmp	SHORT $LN4@capacity@2
$LN3@capacity@2:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+20]
	sub	eax, DWORD PTR [edx+12]
	sar	eax, 2
	mov	DWORD PTR tv70[ebp], eax
$LN4@capacity@2:
	mov	eax, DWORD PTR tv70[ebp]

; 636  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?capacity@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QBEIXZ ENDP ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::capacity
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE@PAPAVSurfaceData@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::_Vector_const_iterator<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >
; Function compile flags: /Odtp
;	COMDAT ?begin@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@2@XZ PROC ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::begin, COMDAT
; _this$ = ecx

; 645  : 		{	// return iterator for beginning of nonmutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 646  : 		return (const_iterator(_Myfirst, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE@PAPAVSurfaceData@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::_Vector_const_iterator<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 647  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?begin@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@2@XZ ENDP ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::begin
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?end@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@2@XZ PROC ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::end, COMDAT
; _this$ = ecx

; 655  : 		{	// return iterator for end of nonmutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 656  : 		return (const_iterator(_Mylast, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE@PAPAVSurfaceData@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::_Vector_const_iterator<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 657  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?end@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@2@XZ ENDP ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::end
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?size@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QBEIXZ PROC ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::size, COMDAT
; _this$ = ecx

; 725  : 		{	// return length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+16]
	sub	eax, DWORD PTR [ecx+12]
	sar	eax, 2

; 727  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?size@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QBEIXZ ENDP ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::size
_TEXT	ENDS
PUBLIC	?erase@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@2@0@Z ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::erase
PUBLIC	?begin@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@2@XZ ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::begin
PUBLIC	?end@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@2@XZ ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::end
; Function compile flags: /Odtp
;	COMDAT ?clear@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -44						; size = 4
$T72653 = -40						; size = 8
$T72652 = -32						; size = 8
$T72651 = -24						; size = 8
$T72650 = -16						; size = 8
$T72649 = -8						; size = 8
?clear@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAEXXZ PROC ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::clear, COMDAT
; _this$ = ecx

; 1059 : 		{	// erase all

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	mov	DWORD PTR _this$[ebp], ecx

; 1060 : 		erase(begin(), end());

	lea	eax, DWORD PTR $T72650[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@2@XZ ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::end
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T72649[ebp], ecx
	mov	DWORD PTR $T72649[ebp+4], edx
	lea	eax, DWORD PTR $T72652[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@2@XZ ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::begin
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T72651[ebp], ecx
	mov	DWORD PTR $T72651[ebp+4], edx
	mov	eax, DWORD PTR $T72649[ebp+4]
	push	eax
	mov	ecx, DWORD PTR $T72649[ebp]
	push	ecx
	mov	edx, DWORD PTR $T72651[ebp+4]
	push	edx
	mov	eax, DWORD PTR $T72651[ebp]
	push	eax
	lea	ecx, DWORD PTR $T72653[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@2@0@Z ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::erase

; 1061 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?clear@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAEXXZ ENDP ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::clear
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@PAVSurfaceData@Ogre@@@std@@QAEPAPAVSurfaceData@Ogre@@I@Z ; std::allocator<Ogre::SurfaceData *>::allocate
PUBLIC	?_Xlen@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@KAXXZ ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::_Xlen
PUBLIC	?max_size@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::max_size
; Function compile flags: /Odtp
;	COMDAT ?_Buy@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Capacity$ = 8						; size = 4
?_Buy@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAE_NI@Z PROC ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+20], 0

; 1104 : 		if (_Capacity == 0)

	cmp	DWORD PTR __Capacity$[ebp], 0
	jne	SHORT $LN4@Buy@2

; 1105 : 			return (false);

	xor	al, al
	jmp	SHORT $LN5@Buy@2
	jmp	SHORT $LN3@Buy@2
$LN4@Buy@2:

; 1106 : 		else if (max_size() < _Capacity)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::max_size
	cmp	eax, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN2@Buy@2

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@KAXXZ ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::_Xlen

; 1108 : 		else

	jmp	SHORT $LN3@Buy@2
$LN2@Buy@2:

; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	mov	eax, DWORD PTR __Capacity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?allocate@?$allocator@PAVSurfaceData@Ogre@@@std@@QAEPAPAVSurfaceData@Ogre@@I@Z ; std::allocator<Ogre::SurfaceData *>::allocate
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [edx+16], ecx

; 1112 : 			_Myend = _Myfirst + _Capacity;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR __Capacity$[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], edx
$LN3@Buy@2:

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
$LN5@Buy@2:

; 1115 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Buy@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::_Buy
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@YAXPAPAVSurfaceData@Ogre@@0AAV?$allocator@PAVSurfaceData@Ogre@@@0@@Z ; std::_Destroy_range<std::allocator<Ogre::SurfaceData *> >
; Function compile flags: /Odtp
;	COMDAT ?_Destroy@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAEXPAPAVSurfaceData@Ogre@@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAEXPAPAVSurfaceData@Ogre@@0@Z PROC ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::_Destroy, COMDAT
; _this$ = ecx

; 1118 : 		{	// destroy [_First, _Last) using allocator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Destroy_range@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@YAXPAPAVSurfaceData@Ogre@@0AAV?$allocator@PAVSurfaceData@Ogre@@@0@@Z ; std::_Destroy_range<std::allocator<Ogre::SurfaceData *> >
	add	esp, 12					; 0000000cH

; 1120 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?_Destroy@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAEXPAPAVSurfaceData@Ogre@@0@Z ENDP ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::_Destroy
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Tidy@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAEXXZ PROC ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	je	SHORT $LN1@Tidy@2

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAEXPAPAVSurfaceData@Ogre@@0@Z ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::_Destroy

; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+20]
	sub	ecx, DWORD PTR [eax+12]
	sar	ecx, 2
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?deallocate@?$allocator@PAVSurfaceData@Ogre@@@std@@QAEXPAPAVSurfaceData@Ogre@@I@Z ; std::allocator<Ogre::SurfaceData *>::deallocate
$LN1@Tidy@2:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+16], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], 0

; 1135 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAEXXZ ENDP ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::_Tidy
_TEXT	ENDS
PUBLIC	??0?$_Container_base_aux_alloc_real@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAE@V?$allocator@PAVSurfaceData@Ogre@@@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::SurfaceData *> >::_Container_base_aux_alloc_real<std::allocator<Ogre::SurfaceData *> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$_Vector_val@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAE@V?$allocator@PAVSurfaceData@Ogre@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Vector_val@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAE@V?$allocator@PAVSurfaceData@Ogre@@@1@@Z$0
__ehfuncinfo$??0?$_Vector_val@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAE@V?$allocator@PAVSurfaceData@Ogre@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Vector_val@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAE@V?$allocator@PAVSurfaceData@Ogre@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Vector_val@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAE@V?$allocator@PAVSurfaceData@Ogre@@@1@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T72662 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 1
??0?$_Vector_val@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAE@V?$allocator@PAVSurfaceData@Ogre@@@1@@Z PROC ; std::_Vector_val<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::_Vector_val<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Vector_val@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAE@V?$allocator@PAVSurfaceData@Ogre@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T72662[ebp], esp
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	call	??0?$allocator@PAVSurfaceData@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::SurfaceData *>::allocator<Ogre::SurfaceData *>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Container_base_aux_alloc_real@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAE@V?$allocator@PAVSurfaceData@Ogre@@@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::SurfaceData *> >::_Container_base_aux_alloc_real<std::allocator<Ogre::SurfaceData *> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??0?$allocator@PAVSurfaceData@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::SurfaceData *>::allocator<Ogre::SurfaceData *>

; 426  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Vector_val@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAE@V?$allocator@PAVSurfaceData@Ogre@@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Container_base_aux_alloc_real@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::SurfaceData *> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::SurfaceData *> >
__ehhandler$??0?$_Vector_val@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAE@V?$allocator@PAVSurfaceData@Ogre@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Vector_val@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAE@V?$allocator@PAVSurfaceData@Ogre@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Vector_val@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAE@V?$allocator@PAVSurfaceData@Ogre@@@1@@Z ENDP ; std::_Vector_val<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::_Vector_val<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??1?$_Container_base_aux_alloc_real@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Container_base_aux_alloc_real@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAE@XZ$0
__ehfuncinfo$??1?$_Container_base_aux_alloc_real@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Container_base_aux_alloc_real@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$_Container_base_aux_alloc_real@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Container_base_aux_alloc_real@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::SurfaceData *> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::SurfaceData *> >, COMDAT
; _this$ = ecx

; 436  : 		{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Container_base_aux_alloc_real@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 437  : 		_Myownedaux->~_Aux_cont();
; 438  : 
; 439  : 		_Alaux.deallocate(_Myownedaux, 1);

	push	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?deallocate@?$allocator@V_Aux_cont@std@@@std@@QAEXPAV_Aux_cont@2@I@Z ; std::allocator<std::_Aux_cont>::deallocate

; 440  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Container_base_aux_alloc_real@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
__ehhandler$??1?$_Container_base_aux_alloc_real@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Container_base_aux_alloc_real@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Container_base_aux_alloc_real@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::SurfaceData *> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::SurfaceData *> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@PAVSurfaceData@Ogre@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$allocator@PAVSurfaceData@Ogre@@@std@@QAE@ABV01@@Z PROC ; std::allocator<Ogre::SurfaceData *>::allocator<Ogre::SurfaceData *>, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$allocator@PAVSurfaceData@Ogre@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<Ogre::SurfaceData *>::allocator<Ogre::SurfaceData *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@PAVSurfaceData@Ogre@@@std@@QAEXPAPAVSurfaceData@Ogre@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@PAVSurfaceData@Ogre@@@std@@QAEXPAPAVSurfaceData@Ogre@@I@Z PROC ; std::allocator<Ogre::SurfaceData *>::deallocate, COMDAT
; _this$ = ecx

; 139  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 141  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@PAVSurfaceData@Ogre@@@std@@QAEXPAPAVSurfaceData@Ogre@@I@Z ENDP ; std::allocator<Ogre::SurfaceData *>::deallocate
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?capacity@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
tv70 = -8						; size = 4
_this$ = -4						; size = 4
?capacity@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QBEIXZ PROC ; std::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::capacity, COMDAT
; _this$ = ecx

; 634  : 		{	// return current length of allocated storage

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	jne	SHORT $LN3@capacity@3
	mov	DWORD PTR tv70[ebp], 0
	jmp	SHORT $LN4@capacity@3
$LN3@capacity@3:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+20]
	sub	eax, DWORD PTR [edx+12]
	sar	eax, 2
	mov	DWORD PTR tv70[ebp], eax
$LN4@capacity@3:
	mov	eax, DWORD PTR tv70[ebp]

; 636  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?capacity@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QBEIXZ ENDP ; std::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::capacity
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QAE@PAPAVHardwarePixelBuffer@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::_Vector_const_iterator<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >
; Function compile flags: /Odtp
;	COMDAT ?begin@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@2@XZ PROC ; std::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::begin, COMDAT
; _this$ = ecx

; 645  : 		{	// return iterator for beginning of nonmutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 646  : 		return (const_iterator(_Myfirst, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_const_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QAE@PAPAVHardwarePixelBuffer@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::_Vector_const_iterator<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 647  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?begin@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@2@XZ ENDP ; std::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::begin
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?end@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@2@XZ PROC ; std::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::end, COMDAT
; _this$ = ecx

; 655  : 		{	// return iterator for end of nonmutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 656  : 		return (const_iterator(_Mylast, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_const_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QAE@PAPAVHardwarePixelBuffer@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::_Vector_const_iterator<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 657  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?end@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@2@XZ ENDP ; std::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::end
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Make_iter@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 8
?_Make_iter@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@2@@Z PROC ; std::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::_Make_iter, COMDAT
; _this$ = ecx

; 660  : 		{	// make iterator from const_iterator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 661  : 		return (iterator(_Where._Myptr, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp+4]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QAE@PAPAVHardwarePixelBuffer@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::_Vector_iterator<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 662  : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?_Make_iter@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@2@@Z ENDP ; std::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::_Make_iter
_TEXT	ENDS
PUBLIC	??H?$_Vector_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::operator+
PUBLIC	?_Insert_n@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@2@IABQAVHardwarePixelBuffer@Ogre@@@Z ; std::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::_Insert_n
PUBLIC	??G?$_Vector_const_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QBEHABV01@@Z ; std::_Vector_const_iterator<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::operator-
; Function compile flags: /Odtp
;	COMDAT ?insert@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@2@ABQAVHardwarePixelBuffer@Ogre@@@Z
_TEXT	SEGMENT
tv77 = -28						; size = 4
_this$ = -24						; size = 4
$T72698 = -20						; size = 8
$T72695 = -12						; size = 8
__Off$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 8
__Val$ = 20						; size = 4
?insert@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@2@ABQAVHardwarePixelBuffer@Ogre@@@Z PROC ; std::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::insert, COMDAT
; _this$ = ecx

; 875  : 		{	// insert _Val at _Where

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR _this$[ebp], ecx

; 876  : 		size_type _Off = size() == 0 ? 0 : _Where - begin();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::size
	test	eax, eax
	jne	SHORT $LN3@insert
	mov	DWORD PTR tv77[ebp], 0
	jmp	SHORT $LN4@insert
$LN3@insert:
	lea	eax, DWORD PTR $T72695[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@2@XZ ; std::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::begin
	push	eax
	lea	ecx, DWORD PTR __Where$[ebp]
	call	??G?$_Vector_const_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QBEHABV01@@Z ; std::_Vector_const_iterator<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::operator-
	mov	DWORD PTR tv77[ebp], eax
$LN4@insert:
	mov	ecx, DWORD PTR tv77[ebp]
	mov	DWORD PTR __Off$[ebp], ecx

; 877  : 		_Insert_n(_Where, (size_type)1, _Val);

	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	push	1
	mov	eax, DWORD PTR __Where$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert_n@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@2@IABQAVHardwarePixelBuffer@Ogre@@@Z ; std::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::_Insert_n

; 878  : 		return (begin() + _Off);

	mov	edx, DWORD PTR __Off$[ebp]
	push	edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T72698[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@2@XZ ; std::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::begin
	mov	ecx, eax
	call	??H?$_Vector_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::operator+
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 879  : 		}

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?insert@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@2@ABQAVHardwarePixelBuffer@Ogre@@@Z ENDP ; std::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::insert
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?erase@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@2@0@Z
_TEXT	SEGMENT
_this$ = -24						; size = 4
__Ptr$65973 = -20					; size = 4
__Last$ = -16						; size = 8
__First$ = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 8
__Last_arg$ = 20					; size = 8
?erase@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@2@0@Z PROC ; std::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::erase, COMDAT
; _this$ = ecx

; 1028 : 		{	// erase [_First, _Last)

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	eax, DWORD PTR __First_arg$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __First_arg$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Make_iter@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@2@@Z ; std::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::_Make_iter

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);

	mov	eax, DWORD PTR __Last_arg$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __Last_arg$[ebp]
	push	ecx
	lea	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Make_iter@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@2@@Z ; std::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::_Make_iter

; 1031 : 
; 1032 : 		if (_First != _Last)

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	call	??9?$_Vector_const_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::operator!=
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@erase@2

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	edx, DWORD PTR __First$[ebp+4]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp+4]
	push	edx
	call	??$unchecked_copy@PAPAVHardwarePixelBuffer@Ogre@@PAPAV12@@stdext@@YAPAPAVHardwarePixelBuffer@Ogre@@PAPAV12@00@Z ; stdext::unchecked_copy<Ogre::HardwarePixelBuffer * *,Ogre::HardwarePixelBuffer * *>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR __Ptr$65973[ebp], eax

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Ptr$65973[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@IAEXPAPAVHardwarePixelBuffer@Ogre@@0@Z ; std::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::_Destroy

; 1049 : 			_Mylast = _Ptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Ptr$65973[ebp]
	mov	DWORD PTR [eax+16], ecx
$LN1@erase@2:

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);

	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR __First$[ebp+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1055 : #endif
; 1056 : 		}

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?erase@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@2@0@Z ENDP ; std::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::erase
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@QAEPAPAVHardwarePixelBuffer@Ogre@@I@Z ; std::allocator<Ogre::HardwarePixelBuffer *>::allocate
PUBLIC	?_Xlen@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@KAXXZ ; std::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::_Xlen
PUBLIC	?max_size@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::max_size
; Function compile flags: /Odtp
;	COMDAT ?_Buy@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Capacity$ = 8						; size = 4
?_Buy@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@IAE_NI@Z PROC ; std::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+20], 0

; 1104 : 		if (_Capacity == 0)

	cmp	DWORD PTR __Capacity$[ebp], 0
	jne	SHORT $LN4@Buy@3

; 1105 : 			return (false);

	xor	al, al
	jmp	SHORT $LN5@Buy@3
	jmp	SHORT $LN3@Buy@3
$LN4@Buy@3:

; 1106 : 		else if (max_size() < _Capacity)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::max_size
	cmp	eax, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN2@Buy@3

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@KAXXZ ; std::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::_Xlen

; 1108 : 		else

	jmp	SHORT $LN3@Buy@3
$LN2@Buy@3:

; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	mov	eax, DWORD PTR __Capacity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?allocate@?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@QAEPAPAVHardwarePixelBuffer@Ogre@@I@Z ; std::allocator<Ogre::HardwarePixelBuffer *>::allocate
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [edx+16], ecx

; 1112 : 			_Myend = _Myfirst + _Capacity;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR __Capacity$[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], edx
$LN3@Buy@3:

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
$LN5@Buy@3:

; 1115 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Buy@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::_Buy
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@YAXPAPAVHardwarePixelBuffer@Ogre@@0AAV?$allocator@PAVHardwarePixelBuffer@Ogre@@@0@@Z ; std::_Destroy_range<std::allocator<Ogre::HardwarePixelBuffer *> >
; Function compile flags: /Odtp
;	COMDAT ?_Destroy@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@IAEXPAPAVHardwarePixelBuffer@Ogre@@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@IAEXPAPAVHardwarePixelBuffer@Ogre@@0@Z PROC ; std::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::_Destroy, COMDAT
; _this$ = ecx

; 1118 : 		{	// destroy [_First, _Last) using allocator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Destroy_range@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@YAXPAPAVHardwarePixelBuffer@Ogre@@0AAV?$allocator@PAVHardwarePixelBuffer@Ogre@@@0@@Z ; std::_Destroy_range<std::allocator<Ogre::HardwarePixelBuffer *> >
	add	esp, 12					; 0000000cH

; 1120 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?_Destroy@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@IAEXPAPAVHardwarePixelBuffer@Ogre@@0@Z ENDP ; std::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::_Destroy
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Tidy@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@IAEXXZ PROC ; std::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	je	SHORT $LN1@Tidy@3

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@IAEXPAPAVHardwarePixelBuffer@Ogre@@0@Z ; std::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::_Destroy

; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+20]
	sub	ecx, DWORD PTR [eax+12]
	sar	ecx, 2
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?deallocate@?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@QAEXPAPAVHardwarePixelBuffer@Ogre@@I@Z ; std::allocator<Ogre::HardwarePixelBuffer *>::deallocate
$LN1@Tidy@3:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+16], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], 0

; 1135 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@IAEXXZ ENDP ; std::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::_Tidy
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_fill_n@PAPAVHardwarePixelBuffer@Ogre@@IPAV12@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@stdext@@YAXPAPAVHardwarePixelBuffer@Ogre@@IABQAV12@AAV?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@Z ; stdext::unchecked_uninitialized_fill_n<Ogre::HardwarePixelBuffer * *,unsigned int,Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >
; Function compile flags: /Odtp
;	COMDAT ?_Ufill@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@IAEPAPAVHardwarePixelBuffer@Ogre@@PAPAV34@IABQAV34@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Ufill@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@IAEPAPAVHardwarePixelBuffer@Ogre@@PAPAV34@IABQAV34@@Z PROC ; std::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::_Ufill, COMDAT
; _this$ = ecx

; 1253 : 		{	// copy initializing _Count * _Val, using allocator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1254 : 		_STDEXT unchecked_uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??$unchecked_uninitialized_fill_n@PAPAVHardwarePixelBuffer@Ogre@@IPAV12@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@stdext@@YAXPAPAVHardwarePixelBuffer@Ogre@@IABQAV12@AAV?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@Z ; stdext::unchecked_uninitialized_fill_n<Ogre::HardwarePixelBuffer * *,unsigned int,Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >
	add	esp, 16					; 00000010H

; 1255 : 		return (_Ptr + _Count);

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Ptr$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]

; 1256 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?_Ufill@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@IAEPAPAVHardwarePixelBuffer@Ogre@@PAPAV34@IABQAV34@@Z ENDP ; std::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::_Ufill
_TEXT	ENDS
PUBLIC	??0?$_Container_base_aux_alloc_real@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@IAE@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::HardwarePixelBuffer *> >::_Container_base_aux_alloc_real<std::allocator<Ogre::HardwarePixelBuffer *> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$_Vector_val@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@IAE@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Vector_val@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@IAE@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@1@@Z$0
__ehfuncinfo$??0?$_Vector_val@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@IAE@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Vector_val@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@IAE@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Vector_val@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@IAE@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@1@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T72711 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 1
??0?$_Vector_val@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@IAE@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@1@@Z PROC ; std::_Vector_val<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::_Vector_val<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Vector_val@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@IAE@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T72711[ebp], esp
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	call	??0?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::HardwarePixelBuffer *>::allocator<Ogre::HardwarePixelBuffer *>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Container_base_aux_alloc_real@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@IAE@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::HardwarePixelBuffer *> >::_Container_base_aux_alloc_real<std::allocator<Ogre::HardwarePixelBuffer *> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??0?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::HardwarePixelBuffer *>::allocator<Ogre::HardwarePixelBuffer *>

; 426  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Vector_val@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@IAE@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Container_base_aux_alloc_real@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::HardwarePixelBuffer *> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::HardwarePixelBuffer *> >
__ehhandler$??0?$_Vector_val@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@IAE@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Vector_val@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@IAE@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Vector_val@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@IAE@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@1@@Z ENDP ; std::_Vector_val<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::_Vector_val<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??1?$_Container_base_aux_alloc_real@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@IAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Container_base_aux_alloc_real@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@IAE@XZ$0
__ehfuncinfo$??1?$_Container_base_aux_alloc_real@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@IAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Container_base_aux_alloc_real@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@IAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$_Container_base_aux_alloc_real@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Container_base_aux_alloc_real@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::HardwarePixelBuffer *> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::HardwarePixelBuffer *> >, COMDAT
; _this$ = ecx

; 436  : 		{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Container_base_aux_alloc_real@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@IAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 437  : 		_Myownedaux->~_Aux_cont();
; 438  : 
; 439  : 		_Alaux.deallocate(_Myownedaux, 1);

	push	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?deallocate@?$allocator@V_Aux_cont@std@@@std@@QAEXPAV_Aux_cont@2@I@Z ; std::allocator<std::_Aux_cont>::deallocate

; 440  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Container_base_aux_alloc_real@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@IAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
__ehhandler$??1?$_Container_base_aux_alloc_real@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@IAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Container_base_aux_alloc_real@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@IAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Container_base_aux_alloc_real@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::HardwarePixelBuffer *> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::HardwarePixelBuffer *> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@QAE@XZ PROC ; std::allocator<Ogre::HardwarePixelBuffer *>::allocator<Ogre::HardwarePixelBuffer *>, COMDAT
; _this$ = ecx

; 119  : 	allocator() _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@QAE@XZ ENDP ; std::allocator<Ogre::HardwarePixelBuffer *>::allocator<Ogre::HardwarePixelBuffer *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@QAE@ABV01@@Z PROC ; std::allocator<Ogre::HardwarePixelBuffer *>::allocator<Ogre::HardwarePixelBuffer *>, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<Ogre::HardwarePixelBuffer *>::allocator<Ogre::HardwarePixelBuffer *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@QAEXPAPAVHardwarePixelBuffer@Ogre@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@QAEXPAPAVHardwarePixelBuffer@Ogre@@I@Z PROC ; std::allocator<Ogre::HardwarePixelBuffer *>::deallocate, COMDAT
; _this$ = ecx

; 139  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 141  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@QAEXPAPAVHardwarePixelBuffer@Ogre@@I@Z ENDP ; std::allocator<Ogre::HardwarePixelBuffer *>::deallocate
_TEXT	ENDS
PUBLIC	?_Kfn@?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@SAABIABU?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@2@@Z ; std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0>::_Kfn
PUBLIC	?_Myval@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAU?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Myval
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?_Key@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAABIPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Key@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAABIPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Key, COMDAT

; 161  : 		{	// return reference to key in node

	push	ebp
	mov	ebp, esp

; 162  : 		return (_Mybase::_Kfn(_Myval(_Pnode)));

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Myval@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAU?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Myval
	add	esp, 4
	push	eax
	call	?_Kfn@?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@SAABIABU?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@2@@Z ; std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0>::_Kfn
	add	esp, 4

; 163  : 		}

	pop	ebp
	ret	0
?_Key@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAABIPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Key
_TEXT	ENDS
PUBLIC	??0?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@ABU?$less@I@1@ABV?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@ABU?$less@I@1@ABV?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@1@@Z$0
__ehfuncinfo$??0?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@ABU?$less@I@1@ABV?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@ABU?$less@I@1@ABV?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@ABU?$less@I@1@ABV?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T72738 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Parg$ = 8						; size = 4
__Al$ = 12						; size = 4
??0?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@ABU?$less@I@1@ABV?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@1@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >, COMDAT
; _this$ = ecx

; 509  : 		{	// construct empty tree

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@ABU?$less@I@1@ABV?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T72738[ebp], esp
	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	call	??0?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >
	mov	ecx, DWORD PTR __Parg$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Tree_val@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@1@@Z ; std::_Tree_val<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Tree_val<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 510  : 		_Init();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Init@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Init

; 511  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@ABU?$less@I@1@ABV?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Tree_val@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ
__ehhandler$??0?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@ABU?$less@I@1@ABV?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@ABU?$less@I@1@ABV?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@ABU?$less@I@1@ABV?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >
; Function compile flags: /Odtp
;	COMDAT ?get_allocator@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QBE?AV?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?get_allocator@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QBE?AV?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::get_allocator, COMDAT
; _this$ = ecx

; 615  : 		{	// return allocator object for values

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 616  : 		return (this->_Alval);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 20					; 00000014H
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 617  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?get_allocator@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QBE?AV?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::get_allocator
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?key_comp@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QBE?AU?$less@I@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?key_comp@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QBE?AU?$less@I@2@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::key_comp, COMDAT
; _this$ = ecx

; 620  : 		{	// return object for comparing keys

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 621  : 		return (this->comp);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 622  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?key_comp@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QBE?AU?$less@I@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::key_comp
_TEXT	ENDS
PUBLIC	?insert@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@_N@2@ABU?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::insert
PUBLIC	??Econst_iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::const_iterator::operator++
PUBLIC	?_Isnil@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Isnil
PUBLIC	?_Right@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Right
PUBLIC	??Fconst_iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::const_iterator::operator--
PUBLIC	?_Rmost@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Rmost
PUBLIC	?_Insert@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@ABU?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Insert
PUBLIC	?size@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::size
PUBLIC	??0const_iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::const_iterator::const_iterator
; Function compile flags: /Odtp
;	COMDAT ?insert@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@ABU?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@2@@Z
_TEXT	SEGMENT
_this$ = -72						; size = 4
$T72758 = -68						; size = 12
$T72757 = -56						; size = 8
$T72756 = -48						; size = 8
$T72755 = -40						; size = 8
$T72754 = -32						; size = 8
$T72753 = -24						; size = 8
$T72752 = -16						; size = 8
__Next$ = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 8
__Val$ = 20						; size = 4
?insert@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@ABU?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::insert, COMDAT
; _this$ = ecx

; 664  : 		{	// try to insert node with value _Val using _Where as a hint

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	mov	DWORD PTR _this$[ebp], ecx

; 665  : 
; 666  :  #if _HAS_ITERATOR_DEBUGGING
; 667  : 		if (_Where._Mycont != this)
; 668  : 			_DEBUG_ERROR("map/set insert iterator outside range");
; 669  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 670  : 
; 671  : 		const_iterator _Next;

	lea	ecx, DWORD PTR __Next$[ebp]
	call	??0const_iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::const_iterator::const_iterator

; 672  : 
; 673  : 		if (size() == 0)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::size
	test	eax, eax
	jne	SHORT $LN32@insert@2

; 674  : 			return (_Insert(true, _Myhead, _Val));	// insert into empty tree

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	push	edx
	push	1
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@ABU?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Insert
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN33@insert@2
	jmp	$LN31@insert@2
$LN32@insert@2:

; 675  : 		else if (this->_Multi)

	xor	ecx, ecx
	je	$LN30@insert@2

; 676  : 			{	// insert even if duplicate
; 677  : 			if (_Where == begin())

	lea	edx, DWORD PTR $T72752[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::begin
	push	eax
	lea	ecx, DWORD PTR __Where$[ebp]
	call	??8const_iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::const_iterator::operator==
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN29@insert@2

; 678  : 				{	// insert at beginning if before first element
; 679  : 				if (!_DEBUG_LT_PRED(this->comp,

	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	call	?_Kfn@?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@SAABIABU?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@2@@Z ; std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0>::_Kfn
	add	esp, 4
	push	eax
	lea	ecx, DWORD PTR __Where$[ebp]
	call	?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@3@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::const_iterator::_Mynode
	push	eax
	call	?_Key@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAABIPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Key
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??R?$less@I@std@@QBE_NABI0@Z		; std::less<unsigned int>::operator()
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN28@insert@2

; 680  : 					_Key(_Where._Mynode()), this->_Kfn(_Val)))
; 681  : 					return (_Insert(true, _Where._Mynode(), _Val));

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Where$[ebp]
	call	?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@3@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::const_iterator::_Mynode
	push	eax
	push	1
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@ABU?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Insert
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN33@insert@2
$LN28@insert@2:

; 682  : 				}

	jmp	$LN27@insert@2
$LN29@insert@2:

; 683  : 			else if (_Where == end())

	lea	edx, DWORD PTR $T72753[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::end
	push	eax
	lea	ecx, DWORD PTR __Where$[ebp]
	call	??8const_iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::const_iterator::operator==
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN26@insert@2

; 684  : 				{	// insert at end if after last element
; 685  : 				if (!_DEBUG_LT_PRED(this->comp,

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rmost@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Rmost
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?_Key@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAABIPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Key
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	call	?_Kfn@?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@SAABIABU?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@2@@Z ; std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0>::_Kfn
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??R?$less@I@std@@QBE_NABI0@Z		; std::less<unsigned int>::operator()
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN25@insert@2

; 686  : 					this->_Kfn(_Val), _Key(_Rmost())))
; 687  : 					return (_Insert(false, _Rmost(), _Val));

	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rmost@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Rmost
	mov	edx, DWORD PTR [eax]
	push	edx
	push	0
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@ABU?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Insert
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN33@insert@2
$LN25@insert@2:

; 688  : 				}
; 689  : 			else if (!_DEBUG_LT_PRED(this->comp,

	jmp	$LN27@insert@2
$LN26@insert@2:

; 690  : 				_Key(_Where._Mynode()), this->_Kfn(_Val))
; 691  : 				&& !_DEBUG_LT_PRED(this->comp,

	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	call	?_Kfn@?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@SAABIABU?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@2@@Z ; std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0>::_Kfn
	add	esp, 4
	push	eax
	lea	ecx, DWORD PTR __Where$[ebp]
	call	?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@3@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::const_iterator::_Mynode
	push	eax
	call	?_Key@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAABIPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Key
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??R?$less@I@std@@QBE_NABI0@Z		; std::less<unsigned int>::operator()
	movzx	edx, al
	test	edx, edx
	jne	$LN23@insert@2
	mov	eax, DWORD PTR __Where$[ebp]
	mov	DWORD PTR __Next$[ebp], eax
	mov	ecx, DWORD PTR __Where$[ebp+4]
	mov	DWORD PTR __Next$[ebp+4], ecx
	lea	ecx, DWORD PTR __Next$[ebp]
	call	??Fconst_iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::const_iterator::operator--
	mov	ecx, eax
	call	?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@3@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::const_iterator::_Mynode
	push	eax
	call	?_Key@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAABIPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Key
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	call	?_Kfn@?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@SAABIABU?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@2@@Z ; std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0>::_Kfn
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??R?$less@I@std@@QBE_NABI0@Z		; std::less<unsigned int>::operator()
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN23@insert@2

; 692  : 					this->_Kfn(_Val), _Key((--(_Next = _Where))._Mynode())))
; 693  : 				{	// insert before _Where
; 694  : 				if (_Isnil(_Right(_Next._Mynode())))

	lea	ecx, DWORD PTR __Next$[ebp]
	call	?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@3@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::const_iterator::_Mynode
	push	eax
	call	?_Right@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Isnil
	add	esp, 4
	movsx	edx, BYTE PTR [eax]
	test	edx, edx
	je	SHORT $LN22@insert@2

; 695  : 					return (_Insert(false, _Next._Mynode(), _Val));

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Next$[ebp]
	call	?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@3@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::const_iterator::_Mynode
	push	eax
	push	0
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@ABU?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Insert
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN33@insert@2

; 696  : 				else

	jmp	SHORT $LN21@insert@2
$LN22@insert@2:

; 697  : 					return (_Insert(true, _Where._Mynode(), _Val));

	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	lea	ecx, DWORD PTR __Where$[ebp]
	call	?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@3@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::const_iterator::_Mynode
	push	eax
	push	1
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@ABU?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Insert
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN33@insert@2
$LN21@insert@2:

; 698  : 				}
; 699  : 			else if (!_DEBUG_LT_PRED(this->comp,

	jmp	$LN27@insert@2
$LN23@insert@2:

; 700  : 				this->_Kfn(_Val), _Key(_Where._Mynode()))
; 701  : 				&& (++(_Next = _Where) == end()
; 702  : 					|| !_DEBUG_LT_PRED(this->comp,

	lea	ecx, DWORD PTR __Where$[ebp]
	call	?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@3@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::const_iterator::_Mynode
	push	eax
	call	?_Key@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAABIPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Key
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	call	?_Kfn@?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@SAABIABU?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@2@@Z ; std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0>::_Kfn
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??R?$less@I@std@@QBE_NABI0@Z		; std::less<unsigned int>::operator()
	movzx	edx, al
	test	edx, edx
	jne	$LN27@insert@2
	mov	eax, DWORD PTR __Where$[ebp]
	mov	DWORD PTR __Next$[ebp], eax
	mov	ecx, DWORD PTR __Where$[ebp+4]
	mov	DWORD PTR __Next$[ebp+4], ecx
	lea	edx, DWORD PTR $T72754[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::end
	push	eax
	lea	ecx, DWORD PTR __Next$[ebp]
	call	??Econst_iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::const_iterator::operator++
	mov	ecx, eax
	call	??8const_iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::const_iterator::operator==
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN18@insert@2
	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	call	?_Kfn@?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@SAABIABU?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@2@@Z ; std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0>::_Kfn
	add	esp, 4
	push	eax
	lea	ecx, DWORD PTR __Next$[ebp]
	call	?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@3@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::const_iterator::_Mynode
	push	eax
	call	?_Key@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAABIPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Key
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??R?$less@I@std@@QBE_NABI0@Z		; std::less<unsigned int>::operator()
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN27@insert@2
$LN18@insert@2:

; 703  : 						_Key(_Next._Mynode()), this->_Kfn(_Val))))
; 704  : 				{	// insert after _Where
; 705  : 				if (_Isnil(_Right(_Where._Mynode())))

	lea	ecx, DWORD PTR __Where$[ebp]
	call	?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@3@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::const_iterator::_Mynode
	push	eax
	call	?_Right@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Right
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Isnil
	add	esp, 4
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN17@insert@2

; 706  : 					return (_Insert(false, _Where._Mynode(), _Val));

	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	lea	ecx, DWORD PTR __Where$[ebp]
	call	?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@3@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::const_iterator::_Mynode
	push	eax
	push	0
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@ABU?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Insert
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN33@insert@2

; 707  : 				else

	jmp	SHORT $LN27@insert@2
$LN17@insert@2:

; 708  : 					return (_Insert(true, _Next._Mynode(), _Val));

	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	lea	ecx, DWORD PTR __Next$[ebp]
	call	?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@3@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::const_iterator::_Mynode
	push	eax
	push	1
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@ABU?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Insert
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN33@insert@2
$LN27@insert@2:

; 709  : 				}
; 710  : 			}
; 711  : 		else

	jmp	$LN31@insert@2
$LN30@insert@2:

; 712  : 			{	// insert only if unique
; 713  : 			if (_Where == begin())

	lea	eax, DWORD PTR $T72755[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::begin
	push	eax
	lea	ecx, DWORD PTR __Where$[ebp]
	call	??8const_iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::const_iterator::operator==
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN14@insert@2

; 714  : 				{	// insert at beginning if before first element
; 715  : 				if (_DEBUG_LT_PRED(this->comp,

	lea	ecx, DWORD PTR __Where$[ebp]
	call	?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@3@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::const_iterator::_Mynode
	push	eax
	call	?_Key@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAABIPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Key
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	call	?_Kfn@?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@SAABIABU?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@2@@Z ; std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0>::_Kfn
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??R?$less@I@std@@QBE_NABI0@Z		; std::less<unsigned int>::operator()
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN13@insert@2

; 716  : 					this->_Kfn(_Val), _Key(_Where._Mynode())))
; 717  : 					return (_Insert(true, _Where._Mynode(), _Val));

	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	lea	ecx, DWORD PTR __Where$[ebp]
	call	?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@3@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::const_iterator::_Mynode
	push	eax
	push	1
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@ABU?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Insert
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN33@insert@2
$LN13@insert@2:

; 718  : 				}

	jmp	$LN31@insert@2
$LN14@insert@2:

; 719  : 			else if (_Where == end())

	lea	eax, DWORD PTR $T72756[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::end
	push	eax
	lea	ecx, DWORD PTR __Where$[ebp]
	call	??8const_iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::const_iterator::operator==
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN11@insert@2

; 720  : 				{	// insert at end if after last element
; 721  : 				if (_DEBUG_LT_PRED(this->comp,

	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	call	?_Kfn@?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@SAABIABU?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@2@@Z ; std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0>::_Kfn
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rmost@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Rmost
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Key@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAABIPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Key
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??R?$less@I@std@@QBE_NABI0@Z		; std::less<unsigned int>::operator()
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN10@insert@2

; 722  : 					_Key(_Rmost()), this->_Kfn(_Val)))
; 723  : 					return (_Insert(false, _Rmost(), _Val));

	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rmost@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Rmost
	mov	eax, DWORD PTR [eax]
	push	eax
	push	0
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@ABU?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Insert
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN33@insert@2
$LN10@insert@2:

; 724  : 				}
; 725  : 			else if (_DEBUG_LT_PRED(this->comp,

	jmp	$LN31@insert@2
$LN11@insert@2:

; 726  : 				this->_Kfn(_Val), _Key(_Where._Mynode()))
; 727  : 				&& _DEBUG_LT_PRED(this->comp,

	lea	ecx, DWORD PTR __Where$[ebp]
	call	?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@3@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::const_iterator::_Mynode
	push	eax
	call	?_Key@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAABIPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Key
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	call	?_Kfn@?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@SAABIABU?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@2@@Z ; std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0>::_Kfn
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??R?$less@I@std@@QBE_NABI0@Z		; std::less<unsigned int>::operator()
	movzx	eax, al
	test	eax, eax
	je	$LN8@insert@2
	mov	ecx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR __Next$[ebp], ecx
	mov	edx, DWORD PTR __Where$[ebp+4]
	mov	DWORD PTR __Next$[ebp+4], edx
	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	call	?_Kfn@?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@SAABIABU?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@2@@Z ; std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0>::_Kfn
	add	esp, 4
	push	eax
	lea	ecx, DWORD PTR __Next$[ebp]
	call	??Fconst_iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::const_iterator::operator--
	mov	ecx, eax
	call	?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@3@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::const_iterator::_Mynode
	push	eax
	call	?_Key@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAABIPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Key
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??R?$less@I@std@@QBE_NABI0@Z		; std::less<unsigned int>::operator()
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN8@insert@2

; 728  : 					_Key((--(_Next = _Where))._Mynode()), this->_Kfn(_Val)))
; 729  : 				{	// insert before _Where
; 730  : 				if (_Isnil(_Right(_Next._Mynode())))

	lea	ecx, DWORD PTR __Next$[ebp]
	call	?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@3@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::const_iterator::_Mynode
	push	eax
	call	?_Right@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Right
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	push	edx
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Isnil
	add	esp, 4
	movsx	eax, BYTE PTR [eax]
	test	eax, eax
	je	SHORT $LN7@insert@2

; 731  : 					return (_Insert(false, _Next._Mynode(), _Val));

	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	lea	ecx, DWORD PTR __Next$[ebp]
	call	?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@3@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::const_iterator::_Mynode
	push	eax
	push	0
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@ABU?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Insert
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN33@insert@2

; 732  : 				else

	jmp	SHORT $LN6@insert@2
$LN7@insert@2:

; 733  : 					return (_Insert(true, _Where._Mynode(), _Val));

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Where$[ebp]
	call	?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@3@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::const_iterator::_Mynode
	push	eax
	push	1
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@ABU?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Insert
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN33@insert@2
$LN6@insert@2:

; 734  : 				}
; 735  : 			else if (_DEBUG_LT_PRED(this->comp,

	jmp	$LN31@insert@2
$LN8@insert@2:

; 736  : 				_Key(_Where._Mynode()), this->_Kfn(_Val))
; 737  : 				&& (++(_Next = _Where) == end()
; 738  : 					|| _DEBUG_LT_PRED(this->comp,

	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	call	?_Kfn@?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@SAABIABU?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@2@@Z ; std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0>::_Kfn
	add	esp, 4
	push	eax
	lea	ecx, DWORD PTR __Where$[ebp]
	call	?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@3@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::const_iterator::_Mynode
	push	eax
	call	?_Key@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAABIPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Key
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??R?$less@I@std@@QBE_NABI0@Z		; std::less<unsigned int>::operator()
	movzx	eax, al
	test	eax, eax
	je	$LN31@insert@2
	mov	ecx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR __Next$[ebp], ecx
	mov	edx, DWORD PTR __Where$[ebp+4]
	mov	DWORD PTR __Next$[ebp+4], edx
	lea	eax, DWORD PTR $T72757[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::end
	push	eax
	lea	ecx, DWORD PTR __Next$[ebp]
	call	??Econst_iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::const_iterator::operator++
	mov	ecx, eax
	call	??8const_iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::const_iterator::operator==
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN3@insert@2
	lea	ecx, DWORD PTR __Next$[ebp]
	call	?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@3@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::const_iterator::_Mynode
	push	eax
	call	?_Key@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAABIPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Key
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	call	?_Kfn@?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@SAABIABU?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@2@@Z ; std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0>::_Kfn
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??R?$less@I@std@@QBE_NABI0@Z		; std::less<unsigned int>::operator()
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN31@insert@2
$LN3@insert@2:

; 739  : 						this->_Kfn(_Val), _Key(_Next._Mynode()))))
; 740  : 				{	// insert after _Where
; 741  : 				if (_Isnil(_Right(_Where._Mynode())))

	lea	ecx, DWORD PTR __Where$[ebp]
	call	?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@3@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::const_iterator::_Mynode
	push	eax
	call	?_Right@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Isnil
	add	esp, 4
	movsx	edx, BYTE PTR [eax]
	test	edx, edx
	je	SHORT $LN2@insert@2

; 742  : 					return (_Insert(false, _Where._Mynode(), _Val));

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Where$[ebp]
	call	?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@3@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::const_iterator::_Mynode
	push	eax
	push	0
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@ABU?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Insert
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN33@insert@2

; 743  : 				else

	jmp	SHORT $LN31@insert@2
$LN2@insert@2:

; 744  : 					return (_Insert(true, _Next._Mynode(), _Val));

	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	lea	ecx, DWORD PTR __Next$[ebp]
	call	?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@3@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::const_iterator::_Mynode
	push	eax
	push	1
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@ABU?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Insert
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN33@insert@2
$LN31@insert@2:

; 745  : 				}
; 746  : 			}
; 747  : 
; 748  : 		return (insert(_Val).first);	// try usual insert if all else fails

	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T72758[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?insert@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@_N@2@ABU?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::insert
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN33@insert@2:

; 749  : 		}

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?insert@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@ABU?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::insert
_TEXT	ENDS
PUBLIC	?_Make_iter@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QBE?AViterator@12@Vconst_iterator@12@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Make_iter
PUBLIC	?erase@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::erase
PUBLIC	??Econst_iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AV012@H@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::const_iterator::operator++
PUBLIC	?clear@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::clear
; Function compile flags: /Odtp
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z
_TEXT	SEGMENT
_this$ = -36						; size = 4
$T72764 = -32						; size = 8
$T72763 = -24						; size = 8
$T72762 = -16						; size = 8
$T72761 = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 8
__Last$ = 20						; size = 8
?erase@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::erase, COMDAT
; _this$ = ecx

; 934  : 		{	// erase [_First, _Last)

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	mov	DWORD PTR _this$[ebp], ecx

; 935  : 		if (_First == begin() && _Last == end())

	lea	eax, DWORD PTR $T72761[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::begin
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	call	??8const_iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::const_iterator::operator==
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@erase@3
	lea	edx, DWORD PTR $T72762[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::end
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	call	??8const_iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::const_iterator::operator==
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@erase@3

; 936  : 			{	// erase all
; 937  : 			clear();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?clear@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::clear

; 938  : 			return (begin());

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::begin
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN5@erase@3

; 939  : 			}
; 940  : 		else

	jmp	SHORT $LN5@erase@3
$LN2@erase@3:

; 941  : 			{	// partial erase, one at a time
; 942  : 			while (_First != _Last)

	lea	edx, DWORD PTR __Last$[ebp]
	push	edx
	lea	ecx, DWORD PTR __First$[ebp]
	call	??9const_iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::const_iterator::operator!=
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@erase@3

; 943  : 				erase(_First++);

	push	0
	lea	ecx, DWORD PTR $T72763[ebp]
	push	ecx
	lea	ecx, DWORD PTR __First$[ebp]
	call	??Econst_iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AV012@H@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::const_iterator::operator++
	mov	edx, DWORD PTR [eax+4]
	push	edx
	mov	eax, DWORD PTR [eax]
	push	eax
	lea	ecx, DWORD PTR $T72764[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::erase
	jmp	SHORT $LN2@erase@3
$LN1@erase@3:

; 944  : 			return (_Make_iter(_First));

	mov	edx, DWORD PTR __First$[ebp+4]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Make_iter@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QBE?AViterator@12@Vconst_iterator@12@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Make_iter
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN5@erase@3:

; 945  : 			}
; 946  : 		}

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?erase@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::erase
_TEXT	ENDS
PUBLIC	?_Lbound@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@ABI@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Lbound
; Function compile flags: /Odtp
;	COMDAT ?lower_bound@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@ABI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Keyval$ = 12						; size = 4
?lower_bound@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@ABI@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::lower_bound, COMDAT
; _this$ = ecx

; 1003 : 		{	// find leftmost node not less than _Keyval in mutable tree

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1004 : 		return (_TREE_ITERATOR(_Lbound(_Keyval)));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Keyval$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lbound@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@ABI@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Lbound
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PBV12@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::iterator::iterator
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1005 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?lower_bound@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@ABI@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::lower_bound
_TEXT	ENDS
PUBLIC	?_Max@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Max
PUBLIC	?_Min@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Min
PUBLIC	?_Copy@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@0@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Copy
PUBLIC	?_Root@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Root
; Function compile flags: /Odtp
;	COMDAT ?_Copy@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEXABV12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
?_Copy@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEXABV12@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Copy, COMDAT
; _this$ = ecx

; 1062 : 		{	// copy entire tree from _Right

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 1063 : 		_Root() = _Copy(_Right._Root(), _Myhead);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	push	ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Root
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Copy@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@0@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Copy
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Root
	mov	DWORD PTR [eax], esi

; 1064 : 		_Mysize = _Right.size();

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::size
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+28], eax

; 1065 : 		if (!_Isnil(_Root()))

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Root
	mov	edx, DWORD PTR [eax]
	push	edx
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Isnil
	add	esp, 4
	movsx	eax, BYTE PTR [eax]
	test	eax, eax
	jne	SHORT $LN2@Copy@2

; 1066 : 			{	// nonempty tree, look for new smallest and largest
; 1067 : 			_Lmost() = _Min(_Root());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Root
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?_Min@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Min
	add	esp, 4
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lmost@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Lmost
	mov	DWORD PTR [eax], esi

; 1068 : 			_Rmost() = _Max(_Root());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Root
	mov	edx, DWORD PTR [eax]
	push	edx
	call	?_Max@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Max
	add	esp, 4
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rmost@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Rmost
	mov	DWORD PTR [eax], esi

; 1069 : 			}
; 1070 : 		else

	jmp	SHORT $LN3@Copy@2
$LN2@Copy@2:

; 1071 : 			_Lmost() = _Myhead, _Rmost() = _Myhead;	// empty tree

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lmost@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Lmost
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rmost@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Rmost
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR [eax], edx
$LN3@Copy@2:

; 1072 : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?_Copy@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEXABV12@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Copy
_TEXT	ENDS
PUBLIC	?_Buynode@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Buynode
; Function compile flags: /Odtp
;	COMDAT ?_Init@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Init@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEXXZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Init, COMDAT
; _this$ = ecx

; 1177 : 		{	// create head/nil node and make tree empty

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1178 : 		_Myhead = _Buynode();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buynode@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Buynode
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+24], eax

; 1179 : 		_Isnil(_Myhead) = true;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24]
	push	eax
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Isnil
	add	esp, 4
	mov	BYTE PTR [eax], 1

; 1180 : 		_Root() = _Myhead;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Root
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR [eax], edx

; 1181 : 		_Lmost() = _Myhead, _Rmost() = _Myhead;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lmost@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Lmost
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rmost@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Rmost
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR [eax], edx

; 1182 : 		_Mysize = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+28], 0

; 1183 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Init@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Init
_TEXT	ENDS
PUBLIC	?_Left@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Left
; Function compile flags: /Odtp
;	COMDAT ?_Lmost@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Lmost@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Lmost, COMDAT
; _this$ = ecx

; 1280 : 		{	// return leftmost node in nonmutable tree

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1281 : 		return (_Left(_Myhead));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	push	ecx
	call	?_Left@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Left
	add	esp, 4

; 1282 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Lmost@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Lmost
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Node>::deallocate
PUBLIC	?_Parent@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Parent
PUBLIC	?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Node *>::destroy
; Function compile flags: /Odtp
;	COMDAT ?_Tidy@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -44						; size = 4
$T72779 = -40						; size = 8
$T72778 = -32						; size = 8
$T72777 = -24						; size = 8
$T72776 = -16						; size = 8
$T72775 = -8						; size = 8
?_Tidy@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEXXZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Tidy, COMDAT
; _this$ = ecx

; 1420 : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	mov	DWORD PTR _this$[ebp], ecx

; 1421 : 		erase(begin(), end());

	lea	eax, DWORD PTR $T72776[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::end
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T72775[ebp], ecx
	mov	DWORD PTR $T72775[ebp+4], edx
	lea	eax, DWORD PTR $T72778[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::begin
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T72777[ebp], ecx
	mov	DWORD PTR $T72777[ebp+4], edx
	mov	eax, DWORD PTR $T72775[ebp+4]
	push	eax
	mov	ecx, DWORD PTR $T72775[ebp]
	push	ecx
	mov	edx, DWORD PTR $T72777[ebp+4]
	push	edx
	mov	eax, DWORD PTR $T72777[ebp]
	push	eax
	lea	ecx, DWORD PTR $T72779[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@0@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::erase

; 1422 : 		this->_Alptr.destroy(&_Left(_Myhead));

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Left
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Node *>::destroy

; 1423 : 		this->_Alptr.destroy(&_Parent(_Myhead));

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Parent
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Node *>::destroy

; 1424 : 		this->_Alptr.destroy(&_Right(_Myhead));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	push	ecx
	call	?_Right@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Right
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Node *>::destroy

; 1425 : 		this->_Alnod.deallocate(_Myhead, 1);

	push	1
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Node>::deallocate

; 1426 : 		_Myhead = 0, _Mysize = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+24], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+28], 0

; 1427 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Tidy
_TEXT	ENDS
PUBLIC	??0?$_Tree_ptr@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@1@@Z ; std::_Tree_ptr<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Tree_ptr<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$_Tree_val@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Tree_val@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@1@@Z$0
__ehfuncinfo$??0?$_Tree_val@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Tree_val@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Tree_val@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T72782 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Parg$ = 8						; size = 4
__Al$ = 12						; size = 1
??0?$_Tree_val@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@1@@Z PROC ; std::_Tree_val<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Tree_val<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >, COMDAT
; _this$ = ecx

; 97   : 		{	// construct base, and allocator from _Al

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Tree_val@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T72782[ebp], esp
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	call	??0?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >
	mov	ecx, DWORD PTR __Parg$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Tree_ptr@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@1@@Z ; std::_Tree_ptr<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Tree_ptr<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 20					; 00000014H
	call	??0?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >

; 98   : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Tree_val@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Tree_ptr@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ
__ehhandler$??0?$_Tree_val@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Tree_val@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Tree_val@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@1@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Tree_val<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??1?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@std@@@std@@IAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@std@@@std@@IAE@XZ$0
__ehfuncinfo$??1?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@std@@@std@@IAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@std@@@std@@IAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> > >::~_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> > >, COMDAT
; _this$ = ecx

; 436  : 		{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@std@@@std@@IAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 437  : 		_Myownedaux->~_Aux_cont();
; 438  : 
; 439  : 		_Alaux.deallocate(_Myownedaux, 1);

	push	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?deallocate@?$allocator@V_Aux_cont@std@@@std@@QAEXPAV_Aux_cont@2@I@Z ; std::allocator<std::_Aux_cont>::deallocate

; 440  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@std@@@std@@IAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
__ehhandler$??1?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@std@@@std@@IAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@std@@@std@@IAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> > >::~_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> > >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@std@@QAE@XZ PROC ; std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >, COMDAT
; _this$ = ecx

; 119  : 	allocator() _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@std@@QAE@XZ ENDP ; std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ??0?$_Vector_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QAE@PAPAVHardwarePixelBuffer@Ogre@@PBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QAE@PAPAVHardwarePixelBuffer@Ogre@@PBV_Container_base_aux@1@@Z PROC ; std::_Vector_iterator<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::_Vector_iterator<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >, COMDAT
; _this$ = ecx

; 327  : 		{	// construct with pointer _Ptr

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Pvector$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_const_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QAE@PAPAVHardwarePixelBuffer@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::_Vector_const_iterator<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >

; 328  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Vector_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QAE@PAPAVHardwarePixelBuffer@Ogre@@PBV_Container_base_aux@1@@Z ENDP ; std::_Vector_iterator<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::_Vector_iterator<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >
_TEXT	ENDS
PUBLIC	??Z?$_Vector_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::operator-=
; Function compile flags: /Odtp
;	COMDAT ??G?$_Vector_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
__Tmp$ = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??G?$_Vector_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::operator-, COMDAT
; _this$ = ecx

; 391  : 		{	// return this - integer

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 392  : 		_Myt _Tmp = *this;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR __Tmp$[ebp], ecx
	mov	DWORD PTR __Tmp$[ebp+4], edx

; 393  : 		return (_Tmp -= _Off);

	mov	eax, DWORD PTR __Off$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Tmp$[ebp]
	call	??Z?$_Vector_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::operator-=
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 394  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
??G?$_Vector_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::operator-
_TEXT	ENDS
PUBLIC	?_Getmycont@_Iterator_base_aux@std@@QBEPBV_Container_base_aux@2@XZ ; std::_Iterator_base_aux::_Getmycont
; Function compile flags: /Odtp
;	COMDAT ??D?$_Vector_const_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QBEABQAVHardwarePixelBuffer@Ogre@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??D?$_Vector_const_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QBEABQAVHardwarePixelBuffer@Ogre@@XZ PROC ; std::_Vector_const_iterator<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::operator*, COMDAT
; _this$ = ecx

; 91   : 		{	// return designated object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 92   : 
; 93   :  #if _HAS_ITERATOR_DEBUGGING
; 94   : 		if (this->_Mycont == 0
; 95   : 			|| _Myptr < ((_Myvec *)this->_Mycont)->_Myfirst
; 96   : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 97   : 			{
; 98   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 99   : 			_SCL_SECURE_OUT_OF_RANGE;
; 100  : 			}
; 101  :  #else
; 102  :  		_SCL_SECURE_VALIDATE(this->_Has_container());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Has_container@_Iterator_base_aux@std@@QBE_NXZ ; std::_Iterator_base_aux::_Has_container
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN2@operator@11
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@operator@11:

; 103  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getmycont@_Iterator_base_aux@std@@QBEPBV_Container_base_aux@2@XZ ; std::_Iterator_base_aux::_Getmycont
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, DWORD PTR [eax+16]
	jb	SHORT $LN1@operator@11
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN1@operator@11:

; 104  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 105  : 
; 106  : 		return (*_Myptr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 107  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??D?$_Vector_const_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QBEABQAVHardwarePixelBuffer@Ogre@@XZ ENDP ; std::_Vector_const_iterator<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::operator*
_TEXT	ENDS
PUBLIC	?_Getcont@_Aux_cont@std@@QBEPBV_Container_base_aux@2@XZ ; std::_Aux_cont::_Getcont
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ?_Getmycont@_Iterator_base_aux@std@@QBEPBV_Container_base_aux@2@XZ
_TEXT	SEGMENT
tv67 = -8						; size = 4
_this$ = -4						; size = 4
?_Getmycont@_Iterator_base_aux@std@@QBEPBV_Container_base_aux@2@XZ PROC ; std::_Iterator_base_aux::_Getmycont, COMDAT
; _this$ = ecx

; 457  : 		{	// Go through the aux object to get the container

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 458  : 		return _Myaux ? _Myaux->_Getcont() : 0;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN3@Getmycont
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?_Getcont@_Aux_cont@std@@QBEPBV_Container_base_aux@2@XZ ; std::_Aux_cont::_Getcont
	mov	DWORD PTR tv67[ebp], eax
	jmp	SHORT $LN4@Getmycont
$LN3@Getmycont:
	mov	DWORD PTR tv67[ebp], 0
$LN4@Getmycont:
	mov	eax, DWORD PTR tv67[ebp]

; 459  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Getmycont@_Iterator_base_aux@std@@QBEPBV_Container_base_aux@2@XZ ENDP ; std::_Iterator_base_aux::_Getmycont
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Getcont@_Aux_cont@std@@QBEPBV_Container_base_aux@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Getcont@_Aux_cont@std@@QBEPBV_Container_base_aux@2@XZ PROC ; std::_Aux_cont::_Getcont, COMDAT
; _this$ = ecx

; 368  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 369  : 		return _Mycontainer;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 370  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Getcont@_Aux_cont@std@@QBEPBV_Container_base_aux@2@XZ ENDP ; std::_Aux_cont::_Getcont
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ??E?$_Vector_const_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??E?$_Vector_const_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::operator++, COMDAT
; _this$ = ecx

; 115  : 		{	// preincrement

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 116  : 		_SCL_SECURE_VALIDATE(this->_Has_container());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Has_container@_Iterator_base_aux@std@@QBE_NXZ ; std::_Iterator_base_aux::_Has_container
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN2@operator@12
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@operator@12:

; 117  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getmycont@_Iterator_base_aux@std@@QBEPBV_Container_base_aux@2@XZ ; std::_Iterator_base_aux::_Getmycont
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, DWORD PTR [eax+16]
	jb	SHORT $LN1@operator@12
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN1@operator@12:

; 118  : 
; 119  :  #if _HAS_ITERATOR_DEBUGGING
; 120  : 		if (this->_Mycont == 0
; 121  : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 122  : 			_DEBUG_ERROR("vector iterator not incrementable");
; 123  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 124  : 
; 125  : 		++_Myptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 126  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 127  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??E?$_Vector_const_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::operator++
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??8?$_Vector_const_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::operator==, COMDAT
; _this$ = ecx

; 203  : 		{	// test for iterator equality

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Has_container@_Iterator_base_aux@std@@QBE_NXZ ; std::_Iterator_base_aux::_Has_container
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@operator@13
	mov	ecx, DWORD PTR __Right$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Same_container@_Iterator_base_aux@std@@QBE_NABV12@@Z ; std::_Iterator_base_aux::_Same_container
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN2@operator@13
$LN1@operator@13:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@operator@13:

; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [eax+4]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+4]
	sete	al

; 212  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??8?$_Vector_const_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::operator==
_TEXT	ENDS
PUBLIC	??0const_iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PBV12@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::const_iterator::const_iterator
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ??0iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PBV12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PBV12@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::iterator::iterator, COMDAT
; _this$ = ecx

; 451  : 			{	// construct with node pointer _Pnode

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Plist$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0const_iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PBV12@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::const_iterator::const_iterator

; 452  : 			}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PBV12@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::iterator::iterator
_TEXT	ENDS
PUBLIC	??Dconst_iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QBEABU?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::const_iterator::operator*
; Function compile flags: /Odtp
;	COMDAT ??Diterator@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QBEAAU?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??Diterator@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QBEAAU?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::iterator::operator*, COMDAT
; _this$ = ecx

; 464  : 			{	// return designated value

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 465  : 			return ((reference)**(const_iterator *)this);

	mov	ecx, DWORD PTR _this$[ebp]
	call	??Dconst_iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QBEABU?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::const_iterator::operator*

; 466  : 			}

	mov	esp, ebp
	pop	ebp
	ret	0
??Diterator@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QBEAAU?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::iterator::operator*
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??Eiterator@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??Eiterator@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAEAAV012@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::iterator::operator++, COMDAT
; _this$ = ecx

; 474  : 			{	// preincrement

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 475  : 			++(*(const_iterator *)this);

	mov	ecx, DWORD PTR _this$[ebp]
	call	??Econst_iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::const_iterator::operator++

; 476  : 			return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 477  : 			}

	mov	esp, ebp
	pop	ebp
	ret	0
??Eiterator@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAEAAV012@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::iterator::operator++
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@3@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@3@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::const_iterator::_Mynode, COMDAT
; _this$ = ecx

; 409  : 			{	// return node pointer

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 410  : 			return (_Ptr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 411  : 			}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@3@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::const_iterator::_Mynode
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\utility
_TEXT	ENDS
;	COMDAT ??0?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@QAE@ABIABQAVHardwarePixelBufferPool@Ogre@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??0?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@QAE@ABIABQAVHardwarePixelBufferPool@Ogre@@@Z PROC ; std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *>::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *>, COMDAT
; _this$ = ecx

; 50   : 		{	// construct from specified values

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Val1$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Val2$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+4], edx

; 51   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@QAE@ABIABQAVHardwarePixelBufferPool@Ogre@@@Z ENDP ; std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *>::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ?_Isnil@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Isnil@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Isnil, COMDAT

; 156  : 		{	// return reference to nil flag in node

	push	ebp
	mov	ebp, esp

; 157  : 		return ((_Charref)(*_Pnode)._Isnil);

	mov	eax, DWORD PTR __Pnode$[ebp]
	add	eax, 21					; 00000015H

; 158  : 		}

	pop	ebp
	ret	0
?_Isnil@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Isnil
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Left@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Left@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Left, COMDAT

; 166  : 		{	// return reference to left pointer in node

	push	ebp
	mov	ebp, esp

; 167  : 		return ((_Nodepref)(*_Pnode)._Left);

	mov	eax, DWORD PTR __Pnode$[ebp]

; 168  : 		}

	pop	ebp
	ret	0
?_Left@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Left
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Parent@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Parent@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Parent, COMDAT

; 171  : 		{	// return reference to parent pointer in node

	push	ebp
	mov	ebp, esp

; 172  : 		return ((_Nodepref)(*_Pnode)._Parent);

	mov	eax, DWORD PTR __Pnode$[ebp]
	add	eax, 4

; 173  : 		}

	pop	ebp
	ret	0
?_Parent@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Parent
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Right@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Right@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Right, COMDAT

; 176  : 		{	// return reference to right pointer in node

	push	ebp
	mov	ebp, esp

; 177  : 		return ((_Nodepref)(*_Pnode)._Right);

	mov	eax, DWORD PTR __Pnode$[ebp]
	add	eax, 8

; 178  : 		}

	pop	ebp
	ret	0
?_Right@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Right
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Make_iter@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QBE?AViterator@12@Vconst_iterator@12@@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
$T72837 = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 8
?_Make_iter@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QBE?AViterator@12@Vconst_iterator@12@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Make_iter, COMDAT
; _this$ = ecx

; 575  : 		{	// make iterator from const_iterator

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 576  : 		return (iterator(_TREE_ITERATOR(_Where._Ptr)));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp+4]
	push	ecx
	lea	ecx, DWORD PTR $T72837[ebp]
	call	??0iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PBV12@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::iterator::iterator
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 577  : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?_Make_iter@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QBE?AViterator@12@Vconst_iterator@12@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Make_iter
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?size@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QBEIXZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::size, COMDAT
; _this$ = ecx

; 600  : 		{	// return length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 601  : 		return (_Mysize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+28]

; 602  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?size@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QBEIXZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::size
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Node>::destroy
PUBLIC	?_Rrotate@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Rrotate
PUBLIC	?_Lrotate@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Lrotate
PUBLIC	??$swap@D@std@@YAXAAD0@Z			; std::swap<char>
PUBLIC	?_Color@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Color
PUBLIC	??Econst_iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::const_iterator::operator++
PUBLIC	__TI3?AVout_of_range@std@@
PUBLIC	??0out_of_range@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::out_of_range::out_of_range
PUBLIC	??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@ ; `string'
PUBLIC	?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@3@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::const_iterator::_Mynode
PUBLIC	??1out_of_range@std@@UAE@XZ			; std::out_of_range::~out_of_range
PUBLIC	__CTA3?AVout_of_range@std@@
PUBLIC	__CT??_R0?AVout_of_range@std@@@8??0out_of_range@std@@QAE@ABV01@@Z40
PUBLIC	??_R0?AVout_of_range@std@@@8			; std::out_of_range `RTTI Type Descriptor'
PUBLIC	??0out_of_range@std@@QAE@ABV01@@Z		; std::out_of_range::out_of_range
PUBLIC	__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
PUBLIC	??_R0?AVlogic_error@std@@@8			; std::logic_error `RTTI Type Descriptor'
PUBLIC	??0logic_error@std@@QAE@ABV01@@Z		; std::logic_error::logic_error
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z:PROC
EXTRN	??0exception@std@@QAE@ABV01@@Z:PROC		; std::exception::exception
;	COMDAT ??_R0?AVexception@std@@@8
_DATA	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVlogic_error@std@@@8
_DATA	SEGMENT
??_R0?AVlogic_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::logic_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlogic_error@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0logic_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVout_of_range@std@@@8
_DATA	SEGMENT
??_R0?AVout_of_range@std@@@8 DD FLAT:??_7type_info@@6B@	; std::out_of_range `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVout_of_range@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVout_of_range@std@@@8??0out_of_range@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVout_of_range@std@@@8??0out_of_range@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVout_of_range@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0out_of_range@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA3?AVout_of_range@std@@
xdata$x	SEGMENT
__CTA3?AVout_of_range@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVout_of_range@std@@@8??0out_of_range@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVout_of_range@std@@
xdata$x	SEGMENT
__TI3?AVout_of_range@std@@ DD 00H
	DD	FLAT:??1out_of_range@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVout_of_range@std@@
xdata$x	ENDS
;	COMDAT ??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@
CONST	SEGMENT
??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@ DB 'invalid '
	DB	'map/set<T> iterator', 00H			; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?erase@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?erase@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z$0
__ehfuncinfo$?erase@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?erase@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z
_TEXT	SEGMENT
tv177 = -108						; size = 4
tv165 = -104						; size = 4
_this$ = -100						; size = 4
$T72843 = -96						; size = 28
$T72842 = -68						; size = 40
__Fixnodeparent$ = -28					; size = 4
__Pnode$ = -24						; size = 4
__Fixnode$ = -20					; size = 4
__Erasednode$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 8
?erase@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::erase, COMDAT
; _this$ = ecx

; 764  : 		{	// erase element at _Where

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?erase@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 96					; 00000060H
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 765  : 
; 766  :  #if _HAS_ITERATOR_DEBUGGING
; 767  : 		if (_Where._Mycont != this || _Isnil(_Where._Mynode()))
; 768  : 			_DEBUG_ERROR("map/set erase iterator outside range");
; 769  : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase
; 770  : 		++_Where;	// save successor iterator for return
; 771  : 		_Orphan_ptr(*this, _Erasednode);
; 772  : 
; 773  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 774  : 		if (_Isnil(_Where._Mynode()))

	lea	ecx, DWORD PTR __Where$[ebp]
	call	?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@3@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::const_iterator::_Mynode
	push	eax
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Isnil
	add	esp, 4
	movsx	eax, BYTE PTR [eax]
	test	eax, eax
	je	SHORT $LN40@erase@4

; 775  : 			_THROW(out_of_range, "invalid map/set<T> iterator");

	push	OFFSET ??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@
	lea	ecx, DWORD PTR $T72843[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR $T72843[ebp]
	push	ecx
	lea	ecx, DWORD PTR $T72842[ebp]
	call	??0out_of_range@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::out_of_range::out_of_range
	push	OFFSET __TI3?AVout_of_range@std@@
	lea	edx, DWORD PTR $T72842[ebp]
	push	edx
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T72843[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN40@erase@4:

; 776  : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase

	lea	ecx, DWORD PTR __Where$[ebp]
	call	?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@3@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::const_iterator::_Mynode
	mov	DWORD PTR __Erasednode$[ebp], eax

; 777  : 		++_Where;	// save successor iterator for return

	lea	ecx, DWORD PTR __Where$[ebp]
	call	??Econst_iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::const_iterator::operator++

; 778  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 779  : 
; 780  : 		_Nodeptr _Fixnode;	// the node to recolor as needed
; 781  : 		_Nodeptr _Fixnodeparent;	// parent of _Fixnode (which may be nil)
; 782  : 		_Nodeptr _Pnode = _Erasednode;

	mov	eax, DWORD PTR __Erasednode$[ebp]
	mov	DWORD PTR __Pnode$[ebp], eax

; 783  : 
; 784  : 		if (_Isnil(_Left(_Pnode)))

	mov	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	call	?_Left@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Left
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	push	edx
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Isnil
	add	esp, 4
	movsx	eax, BYTE PTR [eax]
	test	eax, eax
	je	SHORT $LN39@erase@4

; 785  : 			_Fixnode = _Right(_Pnode);	// must stitch up right subtree

	mov	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	call	?_Right@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Right
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR __Fixnode$[ebp], edx
	jmp	SHORT $LN38@erase@4
$LN39@erase@4:

; 786  : 		else if (_Isnil(_Right(_Pnode)))

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Right@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Isnil
	add	esp, 4
	movsx	edx, BYTE PTR [eax]
	test	edx, edx
	je	SHORT $LN37@erase@4

; 787  : 			_Fixnode = _Left(_Pnode);	// must stitch up left subtree

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Fixnode$[ebp], ecx

; 788  : 		else

	jmp	SHORT $LN38@erase@4
$LN37@erase@4:

; 789  : 			{	// two subtrees, must lift successor node to replace erased
; 790  : 			_Pnode = _Where._Mynode();	// _Pnode is successor node

	lea	ecx, DWORD PTR __Where$[ebp]
	call	?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@3@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::const_iterator::_Mynode
	mov	DWORD PTR __Pnode$[ebp], eax

; 791  : 			_Fixnode = _Right(_Pnode);	// _Fixnode is its only subtree

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Right@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Right
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR __Fixnode$[ebp], eax
$LN38@erase@4:

; 792  : 			}
; 793  : 
; 794  : 		if (_Pnode == _Erasednode)

	mov	ecx, DWORD PTR __Pnode$[ebp]
	cmp	ecx, DWORD PTR __Erasednode$[ebp]
	jne	$LN35@erase@4

; 795  : 			{	// at most one subtree, relink it
; 796  : 			_Fixnodeparent = _Parent(_Erasednode);

	mov	edx, DWORD PTR __Erasednode$[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR __Fixnodeparent$[ebp], eax

; 797  : 			if (!_Isnil(_Fixnode))

	mov	ecx, DWORD PTR __Fixnode$[ebp]
	push	ecx
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Isnil
	add	esp, 4
	movsx	edx, BYTE PTR [eax]
	test	edx, edx
	jne	SHORT $LN34@erase@4

; 798  : 				_Parent(_Fixnode) = _Fixnodeparent;	// link up

	mov	eax, DWORD PTR __Fixnode$[ebp]
	push	eax
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Parent
	add	esp, 4
	mov	ecx, DWORD PTR __Fixnodeparent$[ebp]
	mov	DWORD PTR [eax], ecx
$LN34@erase@4:

; 799  : 
; 800  : 			if (_Root() == _Erasednode)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Root
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR __Erasednode$[ebp]
	jne	SHORT $LN33@erase@4

; 801  : 				_Root() = _Fixnode;	// link down from root

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Root
	mov	ecx, DWORD PTR __Fixnode$[ebp]
	mov	DWORD PTR [eax], ecx
	jmp	SHORT $LN32@erase@4
$LN33@erase@4:

; 802  : 			else if (_Left(_Fixnodeparent) == _Erasednode)

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	push	edx
	call	?_Left@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Left
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	cmp	eax, DWORD PTR __Erasednode$[ebp]
	jne	SHORT $LN31@erase@4

; 803  : 				_Left(_Fixnodeparent) = _Fixnode;	// link down to left

	mov	ecx, DWORD PTR __Fixnodeparent$[ebp]
	push	ecx
	call	?_Left@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Left
	add	esp, 4
	mov	edx, DWORD PTR __Fixnode$[ebp]
	mov	DWORD PTR [eax], edx

; 804  : 			else

	jmp	SHORT $LN32@erase@4
$LN31@erase@4:

; 805  : 				_Right(_Fixnodeparent) = _Fixnode;	// link down to right

	mov	eax, DWORD PTR __Fixnodeparent$[ebp]
	push	eax
	call	?_Right@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR __Fixnode$[ebp]
	mov	DWORD PTR [eax], ecx
$LN32@erase@4:

; 806  : 
; 807  : 			if (_Lmost() == _Erasednode)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lmost@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Lmost
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR __Erasednode$[ebp]
	jne	SHORT $LN29@erase@4

; 808  : 				_Lmost() = _Isnil(_Fixnode)
; 809  : 					? _Fixnodeparent	// smallest is parent of erased node
; 810  : 					: _Min(_Fixnode);	// smallest in relinked subtree

	mov	eax, DWORD PTR __Fixnode$[ebp]
	push	eax
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Isnil
	add	esp, 4
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN43@erase@4
	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	mov	DWORD PTR tv165[ebp], edx
	jmp	SHORT $LN44@erase@4
$LN43@erase@4:
	mov	eax, DWORD PTR __Fixnode$[ebp]
	push	eax
	call	?_Min@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Min
	add	esp, 4
	mov	DWORD PTR tv165[ebp], eax
$LN44@erase@4:
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lmost@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Lmost
	mov	ecx, DWORD PTR tv165[ebp]
	mov	DWORD PTR [eax], ecx
$LN29@erase@4:

; 811  : 
; 812  : 			if (_Rmost() == _Erasednode)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rmost@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Rmost
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR __Erasednode$[ebp]
	jne	SHORT $LN28@erase@4

; 813  : 				_Rmost() = _Isnil(_Fixnode)
; 814  : 					? _Fixnodeparent	// largest is parent of erased node
; 815  : 					: _Max(_Fixnode);	// largest in relinked subtree

	mov	eax, DWORD PTR __Fixnode$[ebp]
	push	eax
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Isnil
	add	esp, 4
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN45@erase@4
	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	mov	DWORD PTR tv177[ebp], edx
	jmp	SHORT $LN46@erase@4
$LN45@erase@4:
	mov	eax, DWORD PTR __Fixnode$[ebp]
	push	eax
	call	?_Max@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Max
	add	esp, 4
	mov	DWORD PTR tv177[ebp], eax
$LN46@erase@4:
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rmost@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Rmost
	mov	ecx, DWORD PTR tv177[ebp]
	mov	DWORD PTR [eax], ecx
$LN28@erase@4:

; 816  : 			}
; 817  : 		else

	jmp	$LN27@erase@4
$LN35@erase@4:

; 818  : 			{	// erased has two subtrees, _Pnode is successor to erased
; 819  : 			_Parent(_Left(_Erasednode)) = _Pnode;	// link left up

	mov	edx, DWORD PTR __Erasednode$[ebp]
	push	edx
	call	?_Left@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Left
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Parent
	add	esp, 4
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax], ecx

; 820  : 			_Left(_Pnode) = _Left(_Erasednode);	// link successor down

	mov	edx, DWORD PTR __Erasednode$[ebp]
	push	edx
	call	?_Left@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Left
	add	esp, 4
	mov	esi, eax
	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [eax], ecx

; 821  : 
; 822  : 			if (_Pnode == _Right(_Erasednode))

	mov	edx, DWORD PTR __Erasednode$[ebp]
	push	edx
	call	?_Right@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR __Pnode$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jne	SHORT $LN26@erase@4

; 823  : 				_Fixnodeparent = _Pnode;	// successor is next to erased

	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR __Fixnodeparent$[ebp], edx

; 824  : 			else

	jmp	$LN25@erase@4
$LN26@erase@4:

; 825  : 				{	// successor further down, link in place of erased
; 826  : 				_Fixnodeparent = _Parent(_Pnode);	// parent is successor's

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Parent
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Fixnodeparent$[ebp], ecx

; 827  : 				if (!_Isnil(_Fixnode))

	mov	edx, DWORD PTR __Fixnode$[ebp]
	push	edx
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Isnil
	add	esp, 4
	movsx	eax, BYTE PTR [eax]
	test	eax, eax
	jne	SHORT $LN24@erase@4

; 828  : 					_Parent(_Fixnode) = _Fixnodeparent;	// link fix up

	mov	ecx, DWORD PTR __Fixnode$[ebp]
	push	ecx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Parent
	add	esp, 4
	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	mov	DWORD PTR [eax], edx
$LN24@erase@4:

; 829  : 				_Left(_Fixnodeparent) = _Fixnode;	// link fix down

	mov	eax, DWORD PTR __Fixnodeparent$[ebp]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR __Fixnode$[ebp]
	mov	DWORD PTR [eax], ecx

; 830  : 				_Right(_Pnode) = _Right(_Erasednode);	// link successor down

	mov	edx, DWORD PTR __Erasednode$[ebp]
	push	edx
	call	?_Right@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Right
	add	esp, 4
	mov	esi, eax
	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Right@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [eax], ecx

; 831  : 				_Parent(_Right(_Erasednode)) = _Pnode;	// link right up

	mov	edx, DWORD PTR __Erasednode$[ebp]
	push	edx
	call	?_Right@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Right
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Parent
	add	esp, 4
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax], ecx
$LN25@erase@4:

; 832  : 				}
; 833  : 
; 834  : 			if (_Root() == _Erasednode)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Root
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR __Erasednode$[ebp]
	jne	SHORT $LN23@erase@4

; 835  : 				_Root() = _Pnode;	// link down from root

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Root
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax], ecx
	jmp	SHORT $LN22@erase@4
$LN23@erase@4:

; 836  : 			else if (_Left(_Parent(_Erasednode)) == _Erasednode)

	mov	edx, DWORD PTR __Erasednode$[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	cmp	ecx, DWORD PTR __Erasednode$[ebp]
	jne	SHORT $LN21@erase@4

; 837  : 				_Left(_Parent(_Erasednode)) = _Pnode;	// link down to left

	mov	edx, DWORD PTR __Erasednode$[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax], ecx

; 838  : 			else

	jmp	SHORT $LN22@erase@4
$LN21@erase@4:

; 839  : 				_Right(_Parent(_Erasednode)) = _Pnode;	// link down to right

	mov	edx, DWORD PTR __Erasednode$[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Right@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax], ecx
$LN22@erase@4:

; 840  : 
; 841  : 			_Parent(_Pnode) = _Parent(_Erasednode);	// link successor up

	mov	edx, DWORD PTR __Erasednode$[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Parent
	add	esp, 4
	mov	esi, eax
	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Parent
	add	esp, 4
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [eax], ecx

; 842  : 			_STD swap(_Color(_Pnode), _Color(_Erasednode));	// recolor it

	mov	edx, DWORD PTR __Erasednode$[ebp]
	push	edx
	call	?_Color@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Color
	add	esp, 4
	push	eax
	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Color@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Color
	add	esp, 4
	push	eax
	call	??$swap@D@std@@YAXAAD0@Z		; std::swap<char>
	add	esp, 8
$LN27@erase@4:

; 843  : 			}
; 844  : 
; 845  : 		if (_Color(_Erasednode) == _Black)

	mov	ecx, DWORD PTR __Erasednode$[ebp]
	push	ecx
	call	?_Color@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Color
	add	esp, 4
	movsx	edx, BYTE PTR [eax]
	cmp	edx, 1
	jne	$LN19@erase@4

; 846  : 			{	// erasing black link, must recolor/rebalance tree
; 847  : 			for (; _Fixnode != _Root() && _Color(_Fixnode) == _Black;
; 848  : 				_Fixnodeparent = _Parent(_Fixnode))

	jmp	SHORT $LN18@erase@4
$LN17@erase@4:
	mov	eax, DWORD PTR __Fixnode$[ebp]
	push	eax
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Parent
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Fixnodeparent$[ebp], ecx
$LN18@erase@4:
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Root
	mov	edx, DWORD PTR __Fixnode$[ebp]
	cmp	edx, DWORD PTR [eax]
	je	$LN16@erase@4
	mov	eax, DWORD PTR __Fixnode$[ebp]
	push	eax
	call	?_Color@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Color
	add	esp, 4
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 1
	jne	$LN16@erase@4

; 849  : 				if (_Fixnode == _Left(_Fixnodeparent))

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	push	edx
	call	?_Left@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR __Fixnode$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jne	$LN15@erase@4

; 850  : 					{	// fixup left subtree
; 851  : 					_Pnode = _Right(_Fixnodeparent);

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	push	edx
	call	?_Right@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Right
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$[ebp], eax

; 852  : 					if (_Color(_Pnode) == _Red)

	mov	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	call	?_Color@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Color
	add	esp, 4
	movsx	edx, BYTE PTR [eax]
	test	edx, edx
	jne	SHORT $LN14@erase@4

; 853  : 						{	// rotate red up from right subtree
; 854  : 						_Color(_Pnode) = _Black;

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Color@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 1

; 855  : 						_Color(_Fixnodeparent) = _Red;

	mov	ecx, DWORD PTR __Fixnodeparent$[ebp]
	push	ecx
	call	?_Color@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 0

; 856  : 						_Lrotate(_Fixnodeparent);

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lrotate@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Lrotate

; 857  : 						_Pnode = _Right(_Fixnodeparent);

	mov	eax, DWORD PTR __Fixnodeparent$[ebp]
	push	eax
	call	?_Right@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$[ebp], ecx
$LN14@erase@4:

; 858  : 						}
; 859  : 
; 860  : 					if (_Isnil(_Pnode))

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Isnil
	add	esp, 4
	movsx	eax, BYTE PTR [eax]
	test	eax, eax
	je	SHORT $LN13@erase@4

; 861  : 						_Fixnode = _Fixnodeparent;	// shouldn't happen

	mov	ecx, DWORD PTR __Fixnodeparent$[ebp]
	mov	DWORD PTR __Fixnode$[ebp], ecx

; 862  : 					else if (_Color(_Left(_Pnode)) == _Black

	jmp	$LN12@erase@4
$LN13@erase@4:

; 863  : 						&& _Color(_Right(_Pnode)) == _Black)

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Left@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Left
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Color@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Color
	add	esp, 4
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 1
	jne	SHORT $LN11@erase@4
	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Right@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Right
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Color@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Color
	add	esp, 4
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 1
	jne	SHORT $LN11@erase@4

; 864  : 						{	// redden right subtree with black children
; 865  : 						_Color(_Pnode) = _Red;

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Color@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 0

; 866  : 						_Fixnode = _Fixnodeparent;

	mov	eax, DWORD PTR __Fixnodeparent$[ebp]
	mov	DWORD PTR __Fixnode$[ebp], eax

; 867  : 						}
; 868  : 					else

	jmp	$LN12@erase@4
$LN11@erase@4:

; 869  : 						{	// must rearrange right subtree
; 870  : 						if (_Color(_Right(_Pnode)) == _Black)

	mov	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	call	?_Right@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Right
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	push	edx
	call	?_Color@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Color
	add	esp, 4
	movsx	eax, BYTE PTR [eax]
	cmp	eax, 1
	jne	SHORT $LN9@erase@4

; 871  : 							{	// rotate red up from left sub-subtree
; 872  : 							_Color(_Left(_Pnode)) = _Black;

	mov	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	call	?_Left@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Left
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	push	edx
	call	?_Color@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 1

; 873  : 							_Color(_Pnode) = _Red;

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Color@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 0

; 874  : 							_Rrotate(_Pnode);

	mov	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rrotate@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Rrotate

; 875  : 							_Pnode = _Right(_Fixnodeparent);

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	push	edx
	call	?_Right@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Right
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$[ebp], eax
$LN9@erase@4:

; 876  : 							}
; 877  : 
; 878  : 						_Color(_Pnode) = _Color(_Fixnodeparent);

	mov	ecx, DWORD PTR __Fixnodeparent$[ebp]
	push	ecx
	call	?_Color@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Color
	add	esp, 4
	mov	esi, eax
	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Color@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Color
	add	esp, 4
	mov	cl, BYTE PTR [esi]
	mov	BYTE PTR [eax], cl

; 879  : 						_Color(_Fixnodeparent) = _Black;

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	push	edx
	call	?_Color@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 1

; 880  : 						_Color(_Right(_Pnode)) = _Black;

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Right@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?_Color@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 1

; 881  : 						_Lrotate(_Fixnodeparent);

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lrotate@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Lrotate

; 882  : 						break;	// tree now recolored/rebalanced

	jmp	$LN16@erase@4
$LN12@erase@4:

; 883  : 						}
; 884  : 					}
; 885  : 				else

	jmp	$LN8@erase@4
$LN15@erase@4:

; 886  : 					{	// fixup right subtree
; 887  : 					_Pnode = _Left(_Fixnodeparent);

	mov	eax, DWORD PTR __Fixnodeparent$[ebp]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$[ebp], ecx

; 888  : 					if (_Color(_Pnode) == _Red)

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Color@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Color
	add	esp, 4
	movsx	eax, BYTE PTR [eax]
	test	eax, eax
	jne	SHORT $LN7@erase@4

; 889  : 						{	// rotate red up from left subtree
; 890  : 						_Color(_Pnode) = _Black;

	mov	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	call	?_Color@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 1

; 891  : 						_Color(_Fixnodeparent) = _Red;

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	push	edx
	call	?_Color@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 0

; 892  : 						_Rrotate(_Fixnodeparent);

	mov	eax, DWORD PTR __Fixnodeparent$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rrotate@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Rrotate

; 893  : 						_Pnode = _Left(_Fixnodeparent);

	mov	ecx, DWORD PTR __Fixnodeparent$[ebp]
	push	ecx
	call	?_Left@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Left
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$[ebp], edx
$LN7@erase@4:

; 894  : 						}
; 895  : 					if (_Isnil(_Pnode))

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Isnil
	add	esp, 4
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN6@erase@4

; 896  : 						_Fixnode = _Fixnodeparent;	// shouldn't happen

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	mov	DWORD PTR __Fixnode$[ebp], edx

; 897  : 					else if (_Color(_Right(_Pnode)) == _Black

	jmp	$LN8@erase@4
$LN6@erase@4:

; 898  : 						&& _Color(_Left(_Pnode)) == _Black)

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Right@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?_Color@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Color
	add	esp, 4
	movsx	edx, BYTE PTR [eax]
	cmp	edx, 1
	jne	SHORT $LN4@erase@4
	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?_Color@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Color
	add	esp, 4
	movsx	edx, BYTE PTR [eax]
	cmp	edx, 1
	jne	SHORT $LN4@erase@4

; 899  : 						{	// redden left subtree with black children
; 900  : 						_Color(_Pnode) = _Red;

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Color@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 0

; 901  : 						_Fixnode = _Fixnodeparent;

	mov	ecx, DWORD PTR __Fixnodeparent$[ebp]
	mov	DWORD PTR __Fixnode$[ebp], ecx

; 902  : 						}
; 903  : 					else

	jmp	$LN8@erase@4
$LN4@erase@4:

; 904  : 						{	// must rearrange left subtree
; 905  : 						if (_Color(_Left(_Pnode)) == _Black)

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Left@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Left
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Color@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Color
	add	esp, 4
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 1
	jne	SHORT $LN2@erase@4

; 906  : 							{	// rotate red up from right sub-subtree
; 907  : 							_Color(_Right(_Pnode)) = _Black;

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Right@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Right
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Color@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 1

; 908  : 							_Color(_Pnode) = _Red;

	mov	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	call	?_Color@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 0

; 909  : 							_Lrotate(_Pnode);

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lrotate@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Lrotate

; 910  : 							_Pnode = _Left(_Fixnodeparent);

	mov	eax, DWORD PTR __Fixnodeparent$[ebp]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$[ebp], ecx
$LN2@erase@4:

; 911  : 							}
; 912  : 
; 913  : 						_Color(_Pnode) = _Color(_Fixnodeparent);

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	push	edx
	call	?_Color@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Color
	add	esp, 4
	mov	esi, eax
	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Color@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Color
	add	esp, 4
	mov	cl, BYTE PTR [esi]
	mov	BYTE PTR [eax], cl

; 914  : 						_Color(_Fixnodeparent) = _Black;

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	push	edx
	call	?_Color@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 1

; 915  : 						_Color(_Left(_Pnode)) = _Black;

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?_Color@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 1

; 916  : 						_Rrotate(_Fixnodeparent);

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rrotate@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Rrotate

; 917  : 						break;	// tree now recolored/rebalanced

	jmp	SHORT $LN16@erase@4
$LN8@erase@4:

; 918  : 						}
; 919  : 					}

	jmp	$LN17@erase@4
$LN16@erase@4:

; 920  : 
; 921  : 			_Color(_Fixnode) = _Black;	// ensure stopping node is black

	mov	eax, DWORD PTR __Fixnode$[ebp]
	push	eax
	call	?_Color@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 1
$LN19@erase@4:

; 922  : 			}
; 923  : 
; 924  : 		this->_Alnod.destroy(_Erasednode);	// destroy, free erased node

	mov	ecx, DWORD PTR __Erasednode$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Node>::destroy

; 925  : 		this->_Alnod.deallocate(_Erasednode, 1);

	push	1
	mov	edx, DWORD PTR __Erasednode$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Node>::deallocate

; 926  : 
; 927  : 		if (0 < _Mysize)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+28], 0
	jbe	SHORT $LN1@erase@4

; 928  : 			--_Mysize;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	sub	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+28], edx
$LN1@erase@4:

; 929  : 
; 930  : 		return (_Make_iter(_Where));	// return successor iterator

	mov	ecx, DWORD PTR __Where$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR __Where$[ebp]
	push	edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Make_iter@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QBE?AViterator@12@Vconst_iterator@12@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Make_iter
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN42@erase@4:

; 931  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?erase@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z$0:
	lea	ecx, DWORD PTR $T72843[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?erase@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-104]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?erase@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?erase@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::erase
PUBLIC	??1logic_error@std@@UAE@XZ			; std::logic_error::~logic_error
PUBLIC	??_7out_of_range@std@@6B@			; std::out_of_range::`vftable'
PUBLIC	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
PUBLIC	??_R4out_of_range@std@@6B@			; std::out_of_range::`RTTI Complete Object Locator'
PUBLIC	??_R3out_of_range@std@@8			; std::out_of_range::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2out_of_range@std@@8			; std::out_of_range::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@out_of_range@std@@8		; std::out_of_range::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@logic_error@std@@8		; std::logic_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3logic_error@std@@8				; std::logic_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2logic_error@std@@8				; std::logic_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
PUBLIC	?what@logic_error@std@@UBEPBDXZ			; std::logic_error::what
EXTRN	??_Eout_of_range@std@@UAEPAXI@Z:PROC		; std::out_of_range::`vector deleting destructor'
;	COMDAT ??_R2exception@std@@8
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R2logic_error@std@@8
rdata$r	SEGMENT
??_R2logic_error@std@@8 DD FLAT:??_R1A@?0A@EA@logic_error@std@@8 ; std::logic_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3logic_error@std@@8
rdata$r	SEGMENT
??_R3logic_error@std@@8 DD 00H				; std::logic_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@logic_error@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@logic_error@std@@8 DD FLAT:??_R0?AVlogic_error@std@@@8 ; std::logic_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@out_of_range@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@out_of_range@std@@8 DD FLAT:??_R0?AVout_of_range@std@@@8 ; std::out_of_range::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3out_of_range@std@@8
rdata$r	ENDS
;	COMDAT ??_R2out_of_range@std@@8
rdata$r	SEGMENT
??_R2out_of_range@std@@8 DD FLAT:??_R1A@?0A@EA@out_of_range@std@@8 ; std::out_of_range::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@logic_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3out_of_range@std@@8
rdata$r	SEGMENT
??_R3out_of_range@std@@8 DD 00H				; std::out_of_range::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2out_of_range@std@@8
rdata$r	ENDS
;	COMDAT ??_R4out_of_range@std@@6B@
rdata$r	SEGMENT
??_R4out_of_range@std@@6B@ DD 00H			; std::out_of_range::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVout_of_range@std@@@8
	DD	FLAT:??_R3out_of_range@std@@8
rdata$r	ENDS
;	COMDAT ??_7out_of_range@std@@6B@
CONST	SEGMENT
??_7out_of_range@std@@6B@ DD FLAT:??_R4out_of_range@std@@6B@ ; std::out_of_range::`vftable'
	DD	FLAT:??_Eout_of_range@std@@UAEPAXI@Z
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0out_of_range@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0out_of_range@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0
__ehfuncinfo$??0out_of_range@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0out_of_range@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0out_of_range@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Message$ = 8						; size = 4
??0out_of_range@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::out_of_range::out_of_range, COMDAT
; _this$ = ecx

; 129  : 		{	// construct from message string

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0out_of_range@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Message$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7out_of_range@std@@6B@

; 130  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0out_of_range@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1logic_error@std@@UAE@XZ		; std::logic_error::~logic_error
__ehhandler$??0out_of_range@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0out_of_range@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0out_of_range@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::out_of_range::out_of_range
PUBLIC	??_7logic_error@std@@6B@			; std::logic_error::`vftable'
PUBLIC	??_R4logic_error@std@@6B@			; std::logic_error::`RTTI Complete Object Locator'
EXTRN	__imp_??1exception@std@@UAE@XZ:PROC
EXTRN	__imp_??0exception@std@@QAE@XZ:PROC
EXTRN	??_Elogic_error@std@@UAEPAXI@Z:PROC		; std::logic_error::`vector deleting destructor'
;	COMDAT ??_R4logic_error@std@@6B@
rdata$r	SEGMENT
??_R4logic_error@std@@6B@ DD 00H			; std::logic_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	FLAT:??_R3logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_7logic_error@std@@6B@
CONST	SEGMENT
??_7logic_error@std@@6B@ DD FLAT:??_R4logic_error@std@@6B@ ; std::logic_error::`vftable'
	DD	FLAT:??_Elogic_error@std@@UAEPAXI@Z
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$1
__ehfuncinfo$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Message$ = 8						; size = 4
??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::logic_error::logic_error, COMDAT
; _this$ = ecx

; 26   : 		{	// construct from message string

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7logic_error@std@@6B@
	mov	ecx, DWORD PTR __Message$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 27   : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__unwindfunclet$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::logic_error::logic_error
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1logic_error@std@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1logic_error@std@@UAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1logic_error@std@@UAE@XZ$1
__ehfuncinfo$??1logic_error@std@@UAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??1logic_error@std@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1logic_error@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1logic_error@std@@UAE@XZ PROC				; std::logic_error::~logic_error, COMDAT
; _this$ = ecx

; 30   : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1logic_error@std@@UAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7logic_error@std@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 31   : 		}

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1logic_error@std@@UAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__unwindfunclet$??1logic_error@std@@UAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$??1logic_error@std@@UAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1logic_error@std@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1logic_error@std@@UAE@XZ ENDP				; std::logic_error::~logic_error
EXTRN	__imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ:PROC
; Function compile flags: /Odtp
;	COMDAT ?what@logic_error@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?what@logic_error@std@@UBEPBDXZ PROC			; std::logic_error::what, COMDAT
; _this$ = ecx

; 34   : 		{	// return pointer to message string

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 35   : 		return (_Str.c_str());

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ

; 36   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?what@logic_error@std@@UBEPBDXZ ENDP			; std::logic_error::what
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_Glogic_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Glogic_error@std@@UAEPAXI@Z PROC			; std::logic_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1logic_error@std@@UAE@XZ		; std::logic_error::~logic_error
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@18
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@18:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Glogic_error@std@@UAEPAXI@Z ENDP			; std::logic_error::`scalar deleting destructor'
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1out_of_range@std@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1out_of_range@std@@UAE@XZ$0
__ehfuncinfo$??1out_of_range@std@@UAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1out_of_range@std@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1out_of_range@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1out_of_range@std@@UAE@XZ PROC			; std::out_of_range::~out_of_range, COMDAT
; _this$ = ecx

; 133  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1out_of_range@std@@UAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7out_of_range@std@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 134  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1logic_error@std@@UAE@XZ		; std::logic_error::~logic_error
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1out_of_range@std@@UAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1logic_error@std@@UAE@XZ		; std::logic_error::~logic_error
__ehhandler$??1out_of_range@std@@UAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1out_of_range@std@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1out_of_range@std@@UAE@XZ ENDP			; std::out_of_range::~out_of_range
; Function compile flags: /Odtp
;	COMDAT ??_Gout_of_range@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gout_of_range@std@@UAEPAXI@Z PROC			; std::out_of_range::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1out_of_range@std@@UAE@XZ		; std::out_of_range::~out_of_range
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@19
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@19:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Gout_of_range@std@@UAEPAXI@Z ENDP			; std::out_of_range::`scalar deleting destructor'
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0out_of_range@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0out_of_range@std@@QAE@ABV01@@Z$0
__ehfuncinfo$??0out_of_range@std@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0out_of_range@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0out_of_range@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0out_of_range@std@@QAE@ABV01@@Z PROC			; std::out_of_range::out_of_range, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0out_of_range@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0logic_error@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7out_of_range@std@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0out_of_range@std@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1logic_error@std@@UAE@XZ		; std::logic_error::~logic_error
__ehhandler$??0out_of_range@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0out_of_range@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0out_of_range@std@@QAE@ABV01@@Z ENDP			; std::out_of_range::out_of_range
EXTRN	__imp_??0exception@std@@QAE@ABV01@@Z:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0logic_error@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$1
__ehfuncinfo$??0logic_error@std@@QAE@ABV01@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0logic_error@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0logic_error@std@@QAE@ABV01@@Z PROC			; std::logic_error::logic_error, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0logic_error@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7logic_error@std@@6B@
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 12					; 0000000cH
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$??0logic_error@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0logic_error@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0logic_error@std@@QAE@ABV01@@Z ENDP			; std::logic_error::logic_error
PUBLIC	?_Erase@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Erase
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ?clear@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?clear@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAEXXZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::clear, COMDAT
; _this$ = ecx

; 965  : 		{	// erase all

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 966  : 
; 967  :  #if _HAS_ITERATOR_DEBUGGING
; 968  : 		this->_Orphan_ptr(*this, 0);
; 969  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 970  : 
; 971  : 		_Erase(_Root());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Root
	mov	eax, DWORD PTR [eax]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Erase@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Erase

; 972  : 		_Root() = _Myhead, _Mysize = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Root
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+28], 0

; 973  : 		_Lmost() = _Myhead, _Rmost() = _Myhead;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lmost@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Lmost
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rmost@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Rmost
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR [eax], edx

; 974  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?clear@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::clear
_TEXT	ENDS
PUBLIC	?_Buynode@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@2@D@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Buynode
PUBLIC	?_Myval@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAU?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Myval
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Copy@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@0@Z$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@0@Z$0
__unwindtable$?_Copy@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@0@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?_Copy@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@0@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@0@Z$2
__ehfuncinfo$?_Copy@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@0@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Copy@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@0@Z
	DD	01H
	DD	FLAT:__tryblocktable$?_Copy@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@0@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?_Copy@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@0@Z
_TEXT	SEGMENT
_this$ = -28						; size = 4
__Pnode$66504 = -24					; size = 4
__Newroot$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Rootnode$ = 8						; size = 4
__Wherenode$ = 12					; size = 4
?_Copy@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@0@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Copy, COMDAT
; _this$ = ecx

; 1075 : 		{	// copy entire subtree, recursively

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Copy@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@0@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 12					; 0000000cH
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1076 : 		_Nodeptr _Newroot = _Myhead;	// point at nil node

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR __Newroot$[ebp], ecx

; 1077 : 
; 1078 : 		if (!_Isnil(_Rootnode))

	mov	edx, DWORD PTR __Rootnode$[ebp]
	push	edx
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Isnil
	add	esp, 4
	movsx	eax, BYTE PTR [eax]
	test	eax, eax
	jne	$LN3@Copy@3

; 1079 : 			{	// copy a node, then any subtrees
; 1080 : 			_Nodeptr _Pnode = _Buynode(_Myhead, _Wherenode, _Myhead,
; 1081 : 				_Myval(_Rootnode), _Color(_Rootnode));

	mov	ecx, DWORD PTR __Rootnode$[ebp]
	push	ecx
	call	?_Color@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Color
	add	esp, 4
	movzx	edx, BYTE PTR [eax]
	push	edx
	mov	eax, DWORD PTR __Rootnode$[ebp]
	push	eax
	call	?_Myval@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAU?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Myval
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	push	edx
	mov	eax, DWORD PTR __Wherenode$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buynode@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@2@D@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Buynode
	mov	DWORD PTR __Pnode$66504[ebp], eax

; 1082 : 			if (_Isnil(_Newroot))

	mov	eax, DWORD PTR __Newroot$[ebp]
	push	eax
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Isnil
	add	esp, 4
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN2@Copy@3

; 1083 : 				_Newroot = _Pnode;	// memorize new root

	mov	edx, DWORD PTR __Pnode$66504[ebp]
	mov	DWORD PTR __Newroot$[ebp], edx
$LN2@Copy@3:

; 1084 : 
; 1085 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1086 : 			_Left(_Pnode) = _Copy(_Left(_Rootnode), _Pnode);

	mov	eax, DWORD PTR __Pnode$66504[ebp]
	push	eax
	mov	ecx, DWORD PTR __Rootnode$[ebp]
	push	ecx
	call	?_Left@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Left
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Copy@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@0@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Copy
	mov	esi, eax
	mov	eax, DWORD PTR __Pnode$66504[ebp]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Left
	add	esp, 4
	mov	DWORD PTR [eax], esi

; 1087 : 			_Right(_Pnode) = _Copy(_Right(_Rootnode), _Pnode);

	mov	ecx, DWORD PTR __Pnode$66504[ebp]
	push	ecx
	mov	edx, DWORD PTR __Rootnode$[ebp]
	push	edx
	call	?_Right@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Right
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Copy@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@0@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Copy
	mov	esi, eax
	mov	ecx, DWORD PTR __Pnode$66504[ebp]
	push	ecx
	call	?_Right@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Right
	add	esp, 4
	mov	DWORD PTR [eax], esi
	jmp	SHORT $LN6@Copy@3
__catch$?_Copy@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@0@Z$0:

; 1088 : 			_CATCH_ALL
; 1089 : 			_Erase(_Newroot);	// subtree copy failed, bail out

	mov	edx, DWORD PTR __Newroot$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Erase@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Erase

; 1090 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1091 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, $LN3@Copy@3
	ret	0
$LN6@Copy@3:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
$LN3@Copy@3:

; 1092 : 			}
; 1093 : 
; 1094 : 		return (_Newroot);	// return newly constructed tree

	mov	eax, DWORD PTR __Newroot$[ebp]
$LN5@Copy@3:

; 1095 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Copy@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@0@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-32]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Copy@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@0@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Copy@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@0@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Copy
; Function compile flags: /Odtp
;	COMDAT ?_Lmost@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Lmost@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Lmost, COMDAT
; _this$ = ecx

; 1280 : 		{	// return leftmost node in nonmutable tree

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1281 : 		return (_Left(_Myhead));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	push	ecx
	call	?_Left@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Left
	add	esp, 4

; 1282 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Lmost@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Lmost
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Max@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Max@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Max, COMDAT

; 1305 : 		{	// return rightmost node in subtree at _Pnode

	push	ebp
	mov	ebp, esp
$LN2@Max:

; 1306 : 		while (!_Isnil(_Right(_Pnode)))

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Right@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Isnil
	add	esp, 4
	movsx	edx, BYTE PTR [eax]
	test	edx, edx
	jne	SHORT $LN1@Max

; 1307 : 			_Pnode = _Right(_Pnode);

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Right@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$[ebp], ecx
	jmp	SHORT $LN2@Max
$LN1@Max:

; 1308 : 		return (_Pnode);

	mov	eax, DWORD PTR __Pnode$[ebp]

; 1309 : 		}

	pop	ebp
	ret	0
?_Max@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Max
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Min@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Min@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Min, COMDAT

; 1312 : 		{	// return leftmost node in subtree at _Pnode

	push	ebp
	mov	ebp, esp
$LN2@Min:

; 1313 : 		while (!_Isnil(_Left(_Pnode)))

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Isnil
	add	esp, 4
	movsx	edx, BYTE PTR [eax]
	test	edx, edx
	jne	SHORT $LN1@Min

; 1314 : 			_Pnode = _Left(_Pnode);

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$[ebp], ecx
	jmp	SHORT $LN2@Min
$LN1@Min:

; 1315 : 		return (_Pnode);

	mov	eax, DWORD PTR __Pnode$[ebp]

; 1316 : 		}

	pop	ebp
	ret	0
?_Min@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Min
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Rmost@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Rmost@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Rmost, COMDAT
; _this$ = ecx

; 1319 : 		{	// return rightmost node in nonmutable tree

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1320 : 		return (_Right(_Myhead));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	push	ecx
	call	?_Right@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Right
	add	esp, 4

; 1321 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Rmost@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Rmost
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Root@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Root, COMDAT
; _this$ = ecx

; 1324 : 		{	// return root of nonmutable tree

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1325 : 		return (_Parent(_Myhead));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	push	ecx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Parent
	add	esp, 4

; 1326 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Root@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Root
_TEXT	ENDS
PUBLIC	?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@ABQAU342@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Node *>::construct
PUBLIC	?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Node>::allocate
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Buynode@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@XZ$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Buynode@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@XZ$0
__unwindtable$?_Buynode@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@XZ DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?_Buynode@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@XZ DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Buynode@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@XZ$2
__ehfuncinfo$?_Buynode@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Buynode@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@XZ
	DD	01H
	DD	FLAT:__tryblocktable$?_Buynode@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@XZ
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?_Buynode@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -40						; size = 4
$T72949 = -36						; size = 4
$T72948 = -32						; size = 4
$T72947 = -28						; size = 4
__Wherenode$ = -24					; size = 4
__Linkcnt$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
?_Buynode@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Buynode, COMDAT
; _this$ = ecx

; 1383 : 		{	// allocate a head/nil node

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Buynode@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 24					; 00000018H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1384 : 		_Nodeptr _Wherenode = this->_Alnod.allocate(1);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Node>::allocate
	mov	DWORD PTR __Wherenode$[ebp], eax

; 1385 : 		int _Linkcnt = 0;

	mov	DWORD PTR __Linkcnt$[ebp], 0

; 1386 : 
; 1387 : 		_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1388 : 		this->_Alptr.construct(&_Left(_Wherenode), 0);

	mov	DWORD PTR $T72947[ebp], 0
	lea	eax, DWORD PTR $T72947[ebp]
	push	eax
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	push	ecx
	call	?_Left@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Left
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@ABQAU342@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Node *>::construct

; 1389 : 		++_Linkcnt;

	mov	edx, DWORD PTR __Linkcnt$[ebp]
	add	edx, 1
	mov	DWORD PTR __Linkcnt$[ebp], edx

; 1390 : 		this->_Alptr.construct(&_Parent(_Wherenode), 0);

	mov	DWORD PTR $T72948[ebp], 0
	lea	eax, DWORD PTR $T72948[ebp]
	push	eax
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	push	ecx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Parent
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@ABQAU342@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Node *>::construct

; 1391 : 		++_Linkcnt;

	mov	edx, DWORD PTR __Linkcnt$[ebp]
	add	edx, 1
	mov	DWORD PTR __Linkcnt$[ebp], edx

; 1392 : 		this->_Alptr.construct(&_Right(_Wherenode), 0);

	mov	DWORD PTR $T72949[ebp], 0
	lea	eax, DWORD PTR $T72949[ebp]
	push	eax
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	push	ecx
	call	?_Right@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Right
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@ABQAU342@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Node *>::construct
	jmp	SHORT $LN6@Buynode
__catch$?_Buynode@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@XZ$0:

; 1393 : 		_CATCH_ALL
; 1394 : 		if (1 < _Linkcnt)

	cmp	DWORD PTR __Linkcnt$[ebp], 1
	jle	SHORT $LN2@Buynode

; 1395 : 			this->_Alptr.destroy(&_Parent(_Wherenode));

	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Parent
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Node *>::destroy
$LN2@Buynode:

; 1396 : 		if (0 < _Linkcnt)

	cmp	DWORD PTR __Linkcnt$[ebp], 0
	jle	SHORT $LN1@Buynode

; 1397 : 			this->_Alptr.destroy(&_Left(_Wherenode));

	mov	eax, DWORD PTR __Wherenode$[ebp]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Left
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Node *>::destroy
$LN1@Buynode:

; 1398 : 		this->_Alnod.deallocate(_Wherenode, 1);

	push	1
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Node>::deallocate

; 1399 : 		_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1400 : 		_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$?_Buynode@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@XZ$1
	ret	0
$LN6@Buynode:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Buynode@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@XZ$1:

; 1401 : 		_Color(_Wherenode) = _Black;

	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	call	?_Color@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 1

; 1402 : 		_Isnil(_Wherenode) = false;

	mov	eax, DWORD PTR __Wherenode$[ebp]
	push	eax
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Isnil
	add	esp, 4
	mov	BYTE PTR [eax], 0

; 1403 : 		return (_Wherenode);

	mov	eax, DWORD PTR __Wherenode$[ebp]
$LN5@Buynode:

; 1404 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Buynode@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-44]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Buynode@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Buynode@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Buynode
PUBLIC	??$?0U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@1@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Node *>::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Node *><std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >
PUBLIC	??0?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@1@@Z ; std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$_Tree_ptr@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Tree_ptr@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@1@@Z$0
__ehfuncinfo$??0?$_Tree_ptr@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Tree_ptr@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Tree_ptr@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T72965 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Parg$ = 8						; size = 4
__Al$ = 12						; size = 1
??0?$_Tree_ptr@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@1@@Z PROC ; std::_Tree_ptr<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Tree_ptr<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >, COMDAT
; _this$ = ecx

; 78   : 		{	// construct base, and allocator from _Al

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Tree_ptr@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T72965[ebp], esp
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	call	??0?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >
	mov	ecx, DWORD PTR __Parg$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@1@@Z ; std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??$?0U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@1@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Node *>::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Node *><std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >

; 79   : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Tree_ptr@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ
__ehhandler$??0?$_Tree_ptr@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Tree_ptr@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Tree_ptr@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@1@@Z ENDP ; std::_Tree_ptr<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Tree_ptr<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@std@@QAE@ABV01@@Z PROC ; std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@V_Aux_cont@std@@@std@@QAEXPAV_Aux_cont@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@V_Aux_cont@std@@@std@@QAEXPAV_Aux_cont@2@I@Z PROC ; std::allocator<std::_Aux_cont>::deallocate, COMDAT
; _this$ = ecx

; 139  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 141  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@V_Aux_cont@std@@@std@@QAEXPAV_Aux_cont@2@I@Z ENDP ; std::allocator<std::_Aux_cont>::deallocate
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@I@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Node>::deallocate, COMDAT
; _this$ = ecx

; 139  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 141  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@I@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Node>::deallocate
_TEXT	ENDS
PUBLIC	??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@0@@Z ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Node *>
; Function compile flags: /Odtp
;	COMDAT ?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Node *>::destroy, COMDAT
; _this$ = ecx

; 159  : 		{	// destroy object at _Ptr

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 160  : 		_Destroy(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@0@@Z ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Node *>
	add	esp, 4

; 161  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Node *>::destroy
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@DV?$allocator@D@std@@@std@@QAE@PADPBV_Container_base_aux@1@@Z ; std::_Vector_iterator<char,std::allocator<char> >::_Vector_iterator<char,std::allocator<char> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?begin@?$vector@DV?$allocator@D@std@@@std@@QAE?AV?$_Vector_iterator@DV?$allocator@D@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@DV?$allocator@D@std@@@std@@QAE?AV?$_Vector_iterator@DV?$allocator@D@std@@@2@XZ PROC ; std::vector<char,std::allocator<char> >::begin, COMDAT
; _this$ = ecx

; 640  : 		{	// return iterator for beginning of mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 641  : 		return (iterator(_Myfirst, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@DV?$allocator@D@std@@@std@@QAE@PADPBV_Container_base_aux@1@@Z ; std::_Vector_iterator<char,std::allocator<char> >::_Vector_iterator<char,std::allocator<char> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 642  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?begin@?$vector@DV?$allocator@D@std@@@std@@QAE?AV?$_Vector_iterator@DV?$allocator@D@std@@@2@XZ ENDP ; std::vector<char,std::allocator<char> >::begin
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?end@?$vector@DV?$allocator@D@std@@@std@@QAE?AV?$_Vector_iterator@DV?$allocator@D@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@DV?$allocator@D@std@@@std@@QAE?AV?$_Vector_iterator@DV?$allocator@D@std@@@2@XZ PROC ; std::vector<char,std::allocator<char> >::end, COMDAT
; _this$ = ecx

; 650  : 		{	// return iterator for end of mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 651  : 		return (iterator(_Mylast, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@DV?$allocator@D@std@@@std@@QAE@PADPBV_Container_base_aux@1@@Z ; std::_Vector_iterator<char,std::allocator<char> >::_Vector_iterator<char,std::allocator<char> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 652  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?end@?$vector@DV?$allocator@D@std@@@std@@QAE?AV?$_Vector_iterator@DV?$allocator@D@std@@@2@XZ ENDP ; std::vector<char,std::allocator<char> >::end
_TEXT	ENDS
EXTRN	__imp_?max_size@?$allocator@D@std@@QBEIXZ:PROC
; Function compile flags: /Odtp
;	COMDAT ?max_size@?$vector@DV?$allocator@D@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$vector@DV?$allocator@D@std@@@std@@QBEIXZ PROC ; std::vector<char,std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 730  : 		{	// return maximum possible length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 731  : 		return (this->_Alval.max_size());

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	DWORD PTR __imp_?max_size@?$allocator@D@std@@QBEIXZ

; 732  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$vector@DV?$allocator@D@std@@@std@@QBEIXZ ENDP ; std::vector<char,std::allocator<char> >::max_size
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@DV?$allocator@D@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<char,std::allocator<char> >::operator!=
PUBLIC	?_Make_iter@?$vector@DV?$allocator@D@std@@@std@@QBE?AV?$_Vector_iterator@DV?$allocator@D@std@@@2@V?$_Vector_const_iterator@DV?$allocator@D@std@@@2@@Z ; std::vector<char,std::allocator<char> >::_Make_iter
; Function compile flags: /Odtp
;	COMDAT ?erase@?$vector@DV?$allocator@D@std@@@std@@QAE?AV?$_Vector_iterator@DV?$allocator@D@std@@@2@V?$_Vector_const_iterator@DV?$allocator@D@std@@@2@0@Z
_TEXT	SEGMENT
_this$ = -24						; size = 4
__Ptr$66570 = -20					; size = 4
__Last$ = -16						; size = 8
__First$ = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 8
__Last_arg$ = 20					; size = 8
?erase@?$vector@DV?$allocator@D@std@@@std@@QAE?AV?$_Vector_iterator@DV?$allocator@D@std@@@2@V?$_Vector_const_iterator@DV?$allocator@D@std@@@2@0@Z PROC ; std::vector<char,std::allocator<char> >::erase, COMDAT
; _this$ = ecx

; 1028 : 		{	// erase [_First, _Last)

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	eax, DWORD PTR __First_arg$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __First_arg$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Make_iter@?$vector@DV?$allocator@D@std@@@std@@QBE?AV?$_Vector_iterator@DV?$allocator@D@std@@@2@V?$_Vector_const_iterator@DV?$allocator@D@std@@@2@@Z ; std::vector<char,std::allocator<char> >::_Make_iter

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);

	mov	eax, DWORD PTR __Last_arg$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __Last_arg$[ebp]
	push	ecx
	lea	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Make_iter@?$vector@DV?$allocator@D@std@@@std@@QBE?AV?$_Vector_iterator@DV?$allocator@D@std@@@2@V?$_Vector_const_iterator@DV?$allocator@D@std@@@2@@Z ; std::vector<char,std::allocator<char> >::_Make_iter

; 1031 : 
; 1032 : 		if (_First != _Last)

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	call	??9?$_Vector_const_iterator@DV?$allocator@D@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<char,std::allocator<char> >::operator!=
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@erase@5

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	edx, DWORD PTR __First$[ebp+4]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp+4]
	push	edx
	call	??$unchecked_copy@PADPAD@stdext@@YAPADPAD00@Z ; stdext::unchecked_copy<char *,char *>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR __Ptr$66570[ebp], eax

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Ptr$66570[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@DV?$allocator@D@std@@@std@@IAEXPAD0@Z ; std::vector<char,std::allocator<char> >::_Destroy

; 1049 : 			_Mylast = _Ptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Ptr$66570[ebp]
	mov	DWORD PTR [eax+16], ecx
$LN1@erase@5:

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);

	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR __First$[ebp+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1055 : #endif
; 1056 : 		}

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?erase@?$vector@DV?$allocator@D@std@@@std@@QAE?AV?$_Vector_iterator@DV?$allocator@D@std@@@2@V?$_Vector_const_iterator@DV?$allocator@D@std@@@2@0@Z ENDP ; std::vector<char,std::allocator<char> >::erase
_TEXT	ENDS
PUBLIC	__TI3?AVlength_error@std@@
PUBLIC	??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::length_error::length_error
PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	??1length_error@std@@UAE@XZ			; std::length_error::~length_error
PUBLIC	__CTA3?AVlength_error@std@@
PUBLIC	__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
PUBLIC	??_R0?AVlength_error@std@@@8			; std::length_error `RTTI Type Descriptor'
PUBLIC	??0length_error@std@@QAE@ABV01@@Z		; std::length_error::length_error
;	COMDAT ??_R0?AVlength_error@std@@@8
_DATA	SEGMENT
??_R0?AVlength_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::length_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlength_error@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlength_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0length_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA3?AVlength_error@std@@
xdata$x	SEGMENT
__CTA3?AVlength_error@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVlength_error@std@@
xdata$x	SEGMENT
__TI3?AVlength_error@std@@ DD 00H
	DD	FLAT:??1length_error@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVlength_error@std@@
xdata$x	ENDS
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ DB 'vector<T> too long'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@DV?$allocator@D@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@DV?$allocator@D@std@@@std@@KAXXZ$0
__ehfuncinfo$?_Xlen@?$vector@DV?$allocator@D@std@@@std@@KAXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@DV?$allocator@D@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@DV?$allocator@D@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T72992 = -80						; size = 28
$T72991 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@DV?$allocator@D@std@@@std@@KAXXZ PROC	; std::vector<char,std::allocator<char> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Xlen@?$vector@DV?$allocator@D@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T72992[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR $T72992[ebp]
	push	eax
	lea	ecx, DWORD PTR $T72991[ebp]
	call	??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::length_error::length_error
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T72991[ebp]
	push	ecx
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T72992[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN2@Xlen:

; 1261 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@DV?$allocator@D@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T72992[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?_Xlen@?$vector@DV?$allocator@D@std@@@std@@KAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@DV?$allocator@D@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@DV?$allocator@D@std@@@std@@KAXXZ ENDP	; std::vector<char,std::allocator<char> >::_Xlen
PUBLIC	??_7length_error@std@@6B@			; std::length_error::`vftable'
PUBLIC	??_R4length_error@std@@6B@			; std::length_error::`RTTI Complete Object Locator'
PUBLIC	??_R3length_error@std@@8			; std::length_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2length_error@std@@8			; std::length_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@length_error@std@@8		; std::length_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??_Elength_error@std@@UAEPAXI@Z:PROC		; std::length_error::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@length_error@std@@8
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
rdata$r	SEGMENT
??_R1A@?0A@EA@length_error@std@@8 DD FLAT:??_R0?AVlength_error@std@@@8 ; std::length_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2length_error@std@@8
rdata$r	SEGMENT
??_R2length_error@std@@8 DD FLAT:??_R1A@?0A@EA@length_error@std@@8 ; std::length_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@logic_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3length_error@std@@8
rdata$r	SEGMENT
??_R3length_error@std@@8 DD 00H				; std::length_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R4length_error@std@@6B@
rdata$r	SEGMENT
??_R4length_error@std@@6B@ DD 00H			; std::length_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVlength_error@std@@@8
	DD	FLAT:??_R3length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_7length_error@std@@6B@
CONST	SEGMENT
??_7length_error@std@@6B@ DD FLAT:??_R4length_error@std@@6B@ ; std::length_error::`vftable'
	DD	FLAT:??_Elength_error@std@@UAEPAXI@Z
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0
__ehfuncinfo$??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Message$ = 8						; size = 4
??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::length_error::length_error, COMDAT
; _this$ = ecx

; 105  : 		{	// construct from message string

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Message$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7length_error@std@@6B@

; 106  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1logic_error@std@@UAE@XZ		; std::logic_error::~logic_error
__ehhandler$??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::length_error::length_error
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1length_error@std@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1length_error@std@@UAE@XZ$0
__ehfuncinfo$??1length_error@std@@UAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1length_error@std@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1length_error@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1length_error@std@@UAE@XZ PROC			; std::length_error::~length_error, COMDAT
; _this$ = ecx

; 109  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1length_error@std@@UAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7length_error@std@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 110  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1logic_error@std@@UAE@XZ		; std::logic_error::~logic_error
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1length_error@std@@UAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1logic_error@std@@UAE@XZ		; std::logic_error::~logic_error
__ehhandler$??1length_error@std@@UAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1length_error@std@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1length_error@std@@UAE@XZ ENDP			; std::length_error::~length_error
; Function compile flags: /Odtp
;	COMDAT ??_Glength_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Glength_error@std@@UAEPAXI@Z PROC			; std::length_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1length_error@std@@UAE@XZ		; std::length_error::~length_error
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@20
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@20:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Glength_error@std@@UAEPAXI@Z ENDP			; std::length_error::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??3@YAXPAX0@Z					; operator delete
PUBLIC	??0_Aux_cont@std@@QAE@QBV_Container_base_aux@1@@Z ; std::_Aux_cont::_Aux_cont
PUBLIC	??2@YAPAXIPAX@Z					; operator new
PUBLIC	?allocate@?$allocator@V_Aux_cont@std@@@std@@QAEPAV_Aux_cont@2@I@Z ; std::allocator<std::_Aux_cont>::allocate
PUBLIC	??$?0D@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><char>
PUBLIC	??0_Container_base_aux@std@@QAE@XZ		; std::_Container_base_aux::_Container_base_aux
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??0?$_Container_base_aux_alloc_real@V?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z$1
__ehfuncinfo$??0?$_Container_base_aux_alloc_real@V?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0?$_Container_base_aux_alloc_real@V?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Container_base_aux_alloc_real@V?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z
_TEXT	SEGMENT
tv133 = -32						; size = 4
_this$ = -28						; size = 4
$T73024 = -24						; size = 4
$T73023 = -20						; size = 4
$T73022 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 1
??0?$_Container_base_aux_alloc_real@V?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z PROC ; std::_Container_base_aux_alloc_real<std::allocator<char> >::_Container_base_aux_alloc_real<std::allocator<char> >, COMDAT
; _this$ = ecx

; 419  : 		{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Container_base_aux_alloc_real@V?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 20					; 00000014H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::_Container_base_aux
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??$?0D@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><char>

; 420  : 		_Myownedaux = new (_Alaux.allocate(1)) _Aux_cont(this);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?allocate@?$allocator@V_Aux_cont@std@@@std@@QAEPAV_Aux_cont@2@I@Z ; std::allocator<std::_Aux_cont>::allocate
	mov	DWORD PTR $T73024[ebp], eax
	mov	ecx, DWORD PTR $T73024[ebp]
	push	ecx
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T73023[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	cmp	DWORD PTR $T73023[ebp], 0
	je	SHORT $LN3@Container_
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T73023[ebp]
	call	??0_Aux_cont@std@@QAE@QBV_Container_base_aux@1@@Z ; std::_Aux_cont::_Aux_cont
	mov	DWORD PTR tv133[ebp], eax
	jmp	SHORT $LN4@Container_
$LN3@Container_:
	mov	DWORD PTR tv133[ebp], 0
$LN4@Container_:
	mov	eax, DWORD PTR tv133[ebp]
	mov	DWORD PTR $T73022[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T73022[ebp]
	mov	DWORD PTR [ecx], edx

; 421  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z$1:
	mov	eax, DWORD PTR $T73024[ebp]
	push	eax
	mov	ecx, DWORD PTR $T73023[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??0?$_Container_base_aux_alloc_real@V?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Container_base_aux_alloc_real@V?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Container_base_aux_alloc_real@V?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z ENDP ; std::_Container_base_aux_alloc_real<std::allocator<char> >::_Container_base_aux_alloc_real<std::allocator<char> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\new
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 58   : 	{	// construct array with placement at _Where

	push	ebp
	mov	ebp, esp

; 59   : 	return (_Where);

	mov	eax, DWORD PTR __Where$[ebp]

; 60   : 	}

	pop	ebp
	ret	0
??2@YAPAXIPAX@Z ENDP					; operator new
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??3@YAXPAX0@Z PROC					; operator delete, COMDAT

; 63   : 	{	// delete if placement new fails

	push	ebp
	mov	ebp, esp

; 64   : 	}

	pop	ebp
	ret	0
??3@YAXPAX0@Z ENDP					; operator delete
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??0_Aux_cont@std@@QAE@QBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pcont$ = 8						; size = 4
??0_Aux_cont@std@@QAE@QBV_Container_base_aux@1@@Z PROC	; std::_Aux_cont::_Aux_cont, COMDAT
; _this$ = ecx

; 364  : 	explicit _Aux_cont(const _Container_base_aux * const _Pcont)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Pcont$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0_Aux_cont@std@@QAE@QBV_Container_base_aux@1@@Z ENDP	; std::_Aux_cont::_Aux_cont
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0_Container_base_aux@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_Container_base_aux@std@@QAE@XZ PROC			; std::_Container_base_aux::_Container_base_aux, COMDAT
; _this$ = ecx

; 379  : 	_Container_base_aux()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 380  : 		{
; 381  : 		// Do nothing: _Container_base_aux_alloc_real() will construct the aux object.
; 382  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0_Container_base_aux@std@@QAE@XZ ENDP			; std::_Container_base_aux::_Container_base_aux
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE@PAPAVSurfaceData@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::_Vector_iterator<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?begin@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@2@XZ PROC ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::begin, COMDAT
; _this$ = ecx

; 640  : 		{	// return iterator for beginning of mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 641  : 		return (iterator(_Myfirst, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE@PAPAVSurfaceData@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::_Vector_iterator<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 642  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?begin@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@2@XZ ENDP ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::begin
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?end@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@2@XZ PROC ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::end, COMDAT
; _this$ = ecx

; 650  : 		{	// return iterator for end of mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 651  : 		return (iterator(_Mylast, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE@PAPAVSurfaceData@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::_Vector_iterator<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 652  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?end@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@2@XZ ENDP ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::end
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@PAVSurfaceData@Ogre@@@std@@QBEIXZ ; std::allocator<Ogre::SurfaceData *>::max_size
; Function compile flags: /Odtp
;	COMDAT ?max_size@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QBEIXZ PROC ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::max_size, COMDAT
; _this$ = ecx

; 730  : 		{	// return maximum possible length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 731  : 		return (this->_Alval.max_size());

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?max_size@?$allocator@PAVSurfaceData@Ogre@@@std@@QBEIXZ ; std::allocator<Ogre::SurfaceData *>::max_size

; 732  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QBEIXZ ENDP ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::max_size
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::operator!=
PUBLIC	?_Make_iter@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@2@@Z ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::_Make_iter
; Function compile flags: /Odtp
;	COMDAT ?erase@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@2@0@Z
_TEXT	SEGMENT
_this$ = -24						; size = 4
__Ptr$66611 = -20					; size = 4
__Last$ = -16						; size = 8
__First$ = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 8
__Last_arg$ = 20					; size = 8
?erase@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@2@0@Z PROC ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::erase, COMDAT
; _this$ = ecx

; 1028 : 		{	// erase [_First, _Last)

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	eax, DWORD PTR __First_arg$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __First_arg$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Make_iter@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@2@@Z ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::_Make_iter

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);

	mov	eax, DWORD PTR __Last_arg$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __Last_arg$[ebp]
	push	ecx
	lea	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Make_iter@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@2@@Z ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::_Make_iter

; 1031 : 
; 1032 : 		if (_First != _Last)

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	call	??9?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::operator!=
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@erase@6

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	edx, DWORD PTR __First$[ebp+4]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp+4]
	push	edx
	call	??$unchecked_copy@PAPAVSurfaceData@Ogre@@PAPAV12@@stdext@@YAPAPAVSurfaceData@Ogre@@PAPAV12@00@Z ; stdext::unchecked_copy<Ogre::SurfaceData * *,Ogre::SurfaceData * *>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR __Ptr$66611[ebp], eax

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Ptr$66611[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAEXPAPAVSurfaceData@Ogre@@0@Z ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::_Destroy

; 1049 : 			_Mylast = _Ptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Ptr$66611[ebp]
	mov	DWORD PTR [eax+16], ecx
$LN1@erase@6:

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);

	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR __First$[ebp+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1055 : #endif
; 1056 : 		}

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?erase@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@2@0@Z ENDP ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::erase
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@KAXXZ$0
__ehfuncinfo$?_Xlen@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@KAXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T73054 = -80						; size = 28
$T73053 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@KAXXZ PROC ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Xlen@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T73054[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR $T73054[ebp]
	push	eax
	lea	ecx, DWORD PTR $T73053[ebp]
	call	??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::length_error::length_error
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T73053[ebp]
	push	ecx
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T73054[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN2@Xlen@2:

; 1261 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T73054[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?_Xlen@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@KAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@KAXXZ ENDP ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::_Xlen
PUBLIC	??$?0PAVSurfaceData@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@PAVSurfaceData@Ogre@@@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::SurfaceData *>
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAE@V?$allocator@PAVSurfaceData@Ogre@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAE@V?$allocator@PAVSurfaceData@Ogre@@@1@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAE@V?$allocator@PAVSurfaceData@Ogre@@@1@@Z$1
__ehfuncinfo$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAE@V?$allocator@PAVSurfaceData@Ogre@@@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAE@V?$allocator@PAVSurfaceData@Ogre@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Container_base_aux_alloc_real@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAE@V?$allocator@PAVSurfaceData@Ogre@@@1@@Z
_TEXT	SEGMENT
tv133 = -32						; size = 4
_this$ = -28						; size = 4
$T73066 = -24						; size = 4
$T73065 = -20						; size = 4
$T73064 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 1
??0?$_Container_base_aux_alloc_real@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAE@V?$allocator@PAVSurfaceData@Ogre@@@1@@Z PROC ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::SurfaceData *> >::_Container_base_aux_alloc_real<std::allocator<Ogre::SurfaceData *> >, COMDAT
; _this$ = ecx

; 419  : 		{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAE@V?$allocator@PAVSurfaceData@Ogre@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 20					; 00000014H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::_Container_base_aux
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??$?0PAVSurfaceData@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@PAVSurfaceData@Ogre@@@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::SurfaceData *>

; 420  : 		_Myownedaux = new (_Alaux.allocate(1)) _Aux_cont(this);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?allocate@?$allocator@V_Aux_cont@std@@@std@@QAEPAV_Aux_cont@2@I@Z ; std::allocator<std::_Aux_cont>::allocate
	mov	DWORD PTR $T73066[ebp], eax
	mov	ecx, DWORD PTR $T73066[ebp]
	push	ecx
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T73065[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	cmp	DWORD PTR $T73065[ebp], 0
	je	SHORT $LN3@Container_@2
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T73065[ebp]
	call	??0_Aux_cont@std@@QAE@QBV_Container_base_aux@1@@Z ; std::_Aux_cont::_Aux_cont
	mov	DWORD PTR tv133[ebp], eax
	jmp	SHORT $LN4@Container_@2
$LN3@Container_@2:
	mov	DWORD PTR tv133[ebp], 0
$LN4@Container_@2:
	mov	eax, DWORD PTR tv133[ebp]
	mov	DWORD PTR $T73064[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T73064[ebp]
	mov	DWORD PTR [ecx], edx

; 421  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAE@V?$allocator@PAVSurfaceData@Ogre@@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAE@V?$allocator@PAVSurfaceData@Ogre@@@1@@Z$1:
	mov	eax, DWORD PTR $T73066[ebp]
	push	eax
	mov	ecx, DWORD PTR $T73065[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAE@V?$allocator@PAVSurfaceData@Ogre@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAE@V?$allocator@PAVSurfaceData@Ogre@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Container_base_aux_alloc_real@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAE@V?$allocator@PAVSurfaceData@Ogre@@@1@@Z ENDP ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::SurfaceData *> >::_Container_base_aux_alloc_real<std::allocator<Ogre::SurfaceData *> >
PUBLIC	??$_Allocate@PAVSurfaceData@Ogre@@@std@@YAPAPAVSurfaceData@Ogre@@IPAPAV12@@Z ; std::_Allocate<Ogre::SurfaceData *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@PAVSurfaceData@Ogre@@@std@@QAEPAPAVSurfaceData@Ogre@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@PAVSurfaceData@Ogre@@@std@@QAEPAPAVSurfaceData@Ogre@@I@Z PROC ; std::allocator<Ogre::SurfaceData *>::allocate, COMDAT
; _this$ = ecx

; 144  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@PAVSurfaceData@Ogre@@@std@@YAPAPAVSurfaceData@Ogre@@IPAPAV12@@Z ; std::_Allocate<Ogre::SurfaceData *>
	add	esp, 8

; 146  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@PAVSurfaceData@Ogre@@@std@@QAEPAPAVSurfaceData@Ogre@@I@Z ENDP ; std::allocator<Ogre::SurfaceData *>::allocate
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@QBEIXZ ; std::allocator<Ogre::HardwarePixelBuffer *>::max_size
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?max_size@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QBEIXZ PROC ; std::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::max_size, COMDAT
; _this$ = ecx

; 730  : 		{	// return maximum possible length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 731  : 		return (this->_Alval.max_size());

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?max_size@?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@QBEIXZ ; std::allocator<Ogre::HardwarePixelBuffer *>::max_size

; 732  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QBEIXZ ENDP ; std::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::max_size
_TEXT	ENDS
PUBLIC	??$_Unchecked_move_backward@PAPAVHardwarePixelBuffer@Ogre@@PAPAV12@@stdext@@YAPAPAVHardwarePixelBuffer@Ogre@@PAPAV12@00@Z ; stdext::_Unchecked_move_backward<Ogre::HardwarePixelBuffer * *,Ogre::HardwarePixelBuffer * *>
PUBLIC	??$fill@PAPAVHardwarePixelBuffer@Ogre@@PAV12@@std@@YAXPAPAVHardwarePixelBuffer@Ogre@@0ABQAV12@@Z ; std::fill<Ogre::HardwarePixelBuffer * *,Ogre::HardwarePixelBuffer *>
PUBLIC	??$_Umove@PAPAVHardwarePixelBuffer@Ogre@@@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@IAEPAPAVHardwarePixelBuffer@Ogre@@PAPAV23@00@Z ; std::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::_Umove<Ogre::HardwarePixelBuffer * *>
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Insert_n@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@2@IABQAVHardwarePixelBuffer@Ogre@@@Z$5 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@2@IABQAVHardwarePixelBuffer@Ogre@@@Z$2
__catchsym$?_Insert_n@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@2@IABQAVHardwarePixelBuffer@Ogre@@@Z$4 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@2@IABQAVHardwarePixelBuffer@Ogre@@@Z$0
__unwindtable$?_Insert_n@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@2@IABQAVHardwarePixelBuffer@Ogre@@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$?_Insert_n@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@2@IABQAVHardwarePixelBuffer@Ogre@@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Insert_n@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@2@IABQAVHardwarePixelBuffer@Ogre@@@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Insert_n@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@2@IABQAVHardwarePixelBuffer@Ogre@@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__tryblocktable$?_Insert_n@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@2@IABQAVHardwarePixelBuffer@Ogre@@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@2@IABQAVHardwarePixelBuffer@Ogre@@@Z$4
	DD	02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@2@IABQAVHardwarePixelBuffer@Ogre@@@Z$5
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?_Insert_n@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@2@IABQAVHardwarePixelBuffer@Ogre@@@Z
_TEXT	SEGMENT
tv84 = -52						; size = 4
_this$ = -48						; size = 4
__Tmp$66673 = -44					; size = 4
__Oldend$66674 = -40					; size = 4
__Tmp$66663 = -36					; size = 4
__Ncopied$66650 = -32					; size = 4
__Newvec$66648 = -28					; size = 4
__Whereoff$66649 = -24					; size = 4
__Capacity$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Where$ = 8						; size = 8
__Count$ = 16						; size = 4
__Val$ = 20						; size = 4
?_Insert_n@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@2@IABQAVHardwarePixelBuffer@Ogre@@@Z PROC ; std::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::_Insert_n, COMDAT
; _this$ = ecx

; 1153 : 		{	// insert _Count * _Val at _Where

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Insert_n@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@2@IABQAVHardwarePixelBuffer@Ogre@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 36					; 00000024H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1154 : 
; 1155 :  #if _HAS_ITERATOR_DEBUGGING
; 1156 : 		if (_Where._Mycont != this
; 1157 : 			|| _Where._Myptr < _Myfirst || _Mylast < _Where._Myptr)
; 1158 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1159 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1160 : 
; 1161 : 		size_type _Capacity = capacity();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?capacity@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::capacity
	mov	DWORD PTR __Capacity$[ebp], eax

; 1162 : 
; 1163 : 		if (_Count == 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN14@Insert_n
	jmp	$LN16@Insert_n
$LN14@Insert_n:

; 1164 : 			;
; 1165 : 		else if (max_size() - size() < _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::max_size
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::size
	sub	esi, eax
	cmp	esi, DWORD PTR __Count$[ebp]
	jae	SHORT $LN12@Insert_n

; 1166 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@KAXXZ ; std::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::_Xlen
	jmp	$LN16@Insert_n
$LN12@Insert_n:

; 1167 : 		else if (_Capacity < size() + _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::size
	add	eax, DWORD PTR __Count$[ebp]
	cmp	DWORD PTR __Capacity$[ebp], eax
	jae	$LN10@Insert_n

; 1168 : 			{	// not enough room, reallocate
; 1169 : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1170 : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::max_size
	mov	ecx, DWORD PTR __Capacity$[ebp]
	shr	ecx, 1
	sub	eax, ecx
	cmp	eax, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN17@Insert_n
	mov	DWORD PTR tv84[ebp], 0
	jmp	SHORT $LN18@Insert_n
$LN17@Insert_n:
	mov	edx, DWORD PTR __Capacity$[ebp]
	shr	edx, 1
	add	edx, DWORD PTR __Capacity$[ebp]
	mov	DWORD PTR tv84[ebp], edx
$LN18@Insert_n:
	mov	eax, DWORD PTR tv84[ebp]
	mov	DWORD PTR __Capacity$[ebp], eax

; 1171 : 			if (_Capacity < size() + _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::size
	add	eax, DWORD PTR __Count$[ebp]
	cmp	DWORD PTR __Capacity$[ebp], eax
	jae	SHORT $LN9@Insert_n

; 1172 : 				_Capacity = size() + _Count;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::size
	add	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Capacity$[ebp], eax
$LN9@Insert_n:

; 1173 : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

	mov	ecx, DWORD PTR __Capacity$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?allocate@?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@QAEPAPAVHardwarePixelBuffer@Ogre@@I@Z ; std::allocator<Ogre::HardwarePixelBuffer *>::allocate
	mov	DWORD PTR __Newvec$66648[ebp], eax

; 1174 : 			size_type _Whereoff = _VEC_ITER_BASE(_Where) - _Myfirst;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Where$[ebp+4]
	sub	eax, DWORD PTR [edx+12]
	sar	eax, 2
	mov	DWORD PTR __Whereoff$66649[ebp], eax

; 1175 : 			int _Ncopied = 0;

	mov	DWORD PTR __Ncopied$66650[ebp], 0

; 1176 : 
; 1177 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1178 : 			_Ufill(_Newvec + _Whereoff, _Count, _Val);	// add new stuff

	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __Whereoff$66649[ebp]
	mov	ecx, DWORD PTR __Newvec$66648[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Ufill@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@IAEPAPAVHardwarePixelBuffer@Ogre@@PAPAV34@IABQAV34@@Z ; std::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::_Ufill

; 1179 : 			++_Ncopied;

	mov	eax, DWORD PTR __Ncopied$66650[ebp]
	add	eax, 1
	mov	DWORD PTR __Ncopied$66650[ebp], eax

; 1180 : 			_Umove(this->_Myfirst, _VEC_ITER_BASE(_Where),
; 1181 : 				_Newvec);	// move prefix

	mov	ecx, DWORD PTR __Newvec$66648[ebp]
	push	ecx
	mov	edx, DWORD PTR __Where$[ebp+4]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Umove@PAPAVHardwarePixelBuffer@Ogre@@@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@IAEPAPAVHardwarePixelBuffer@Ogre@@PAPAV23@00@Z ; std::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::_Umove<Ogre::HardwarePixelBuffer * *>

; 1182 : 			++_Ncopied;

	mov	edx, DWORD PTR __Ncopied$66650[ebp]
	add	edx, 1
	mov	DWORD PTR __Ncopied$66650[ebp], edx

; 1183 : 			_Umove(_VEC_ITER_BASE(_Where), this->_Mylast,
; 1184 : 				_Newvec + (_Whereoff + _Count));	// move suffix

	mov	eax, DWORD PTR __Whereoff$66649[ebp]
	add	eax, DWORD PTR __Count$[ebp]
	mov	ecx, DWORD PTR __Newvec$66648[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Where$[ebp+4]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Umove@PAPAVHardwarePixelBuffer@Ogre@@@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@IAEPAPAVHardwarePixelBuffer@Ogre@@PAPAV23@00@Z ; std::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::_Umove<Ogre::HardwarePixelBuffer * *>
	jmp	SHORT $LN19@Insert_n
__catch$?_Insert_n@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@2@IABQAVHardwarePixelBuffer@Ogre@@@Z$0:

; 1185 : 			_CATCH_ALL
; 1186 : 			if (1 < _Ncopied)

	cmp	DWORD PTR __Ncopied$66650[ebp], 1
	jle	SHORT $LN7@Insert_n

; 1187 : 				_Destroy(_Newvec, _Newvec + _Whereoff);

	mov	eax, DWORD PTR __Whereoff$66649[ebp]
	mov	ecx, DWORD PTR __Newvec$66648[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	push	edx
	mov	eax, DWORD PTR __Newvec$66648[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@IAEXPAPAVHardwarePixelBuffer@Ogre@@0@Z ; std::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::_Destroy
$LN7@Insert_n:

; 1188 : 			if (0 < _Ncopied)

	cmp	DWORD PTR __Ncopied$66650[ebp], 0
	jle	SHORT $LN6@Insert_n

; 1189 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);

	mov	ecx, DWORD PTR __Whereoff$66649[ebp]
	mov	edx, DWORD PTR __Newvec$66648[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR __Count$[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]
	push	edx
	mov	eax, DWORD PTR __Whereoff$66649[ebp]
	mov	ecx, DWORD PTR __Newvec$66648[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@IAEXPAPAVHardwarePixelBuffer@Ogre@@0@Z ; std::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::_Destroy
$LN6@Insert_n:

; 1190 : 			this->_Alval.deallocate(_Newvec, _Capacity);

	mov	eax, DWORD PTR __Capacity$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Newvec$66648[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?deallocate@?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@QAEXPAPAVHardwarePixelBuffer@Ogre@@I@Z ; std::allocator<Ogre::HardwarePixelBuffer *>::deallocate

; 1191 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1192 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$?_Insert_n@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@2@IABQAVHardwarePixelBuffer@Ogre@@@Z$1
	ret	0
$LN19@Insert_n:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Insert_n@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@2@IABQAVHardwarePixelBuffer@Ogre@@@Z$1:

; 1193 : 
; 1194 : 			_Count += size();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::size
	add	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Count$[ebp], eax

; 1195 : 			if (_Myfirst != 0)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+12], 0
	je	SHORT $LN5@Insert_n

; 1196 : 				{	// destroy and deallocate old array
; 1197 : 				_Destroy(_Myfirst, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@IAEXPAPAVHardwarePixelBuffer@Ogre@@0@Z ; std::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::_Destroy

; 1198 : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+20]
	sub	eax, DWORD PTR [edx+12]
	sar	eax, 2
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?deallocate@?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@QAEXPAPAVHardwarePixelBuffer@Ogre@@I@Z ; std::allocator<Ogre::HardwarePixelBuffer *>::deallocate
$LN5@Insert_n:

; 1199 : 				}
; 1200 : 
; 1201 :  #if _HAS_ITERATOR_DEBUGGING
; 1202 : 			this->_Orphan_all();
; 1203 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1204 : 
; 1205 : 			_Myend = _Newvec + _Capacity;

	mov	eax, DWORD PTR __Capacity$[ebp]
	mov	ecx, DWORD PTR __Newvec$66648[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], edx

; 1206 : 			_Mylast = _Newvec + _Count;

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Newvec$66648[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 1207 : 			_Myfirst = _Newvec;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Newvec$66648[ebp]
	mov	DWORD PTR [edx+12], eax
	jmp	$LN16@Insert_n
$LN10@Insert_n:

; 1208 : 			}
; 1209 : 		else if ((size_type)(_Mylast - _VEC_ITER_BASE(_Where)) < _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	sub	edx, DWORD PTR __Where$[ebp+4]
	sar	edx, 2
	cmp	edx, DWORD PTR __Count$[ebp]
	jae	$LN3@Insert_n

; 1210 : 			{	// new stuff spills off end
; 1211 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Tmp$66663[ebp], ecx

; 1212 : 
; 1213 : 			_Umove(_VEC_ITER_BASE(_Where), _Mylast,
; 1214 : 				_VEC_ITER_BASE(_Where) + _Count);	// copy suffix

	mov	edx, DWORD PTR __Count$[ebp]
	mov	eax, DWORD PTR __Where$[ebp+4]
	lea	ecx, DWORD PTR [eax+edx*4]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp+4]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Umove@PAPAVHardwarePixelBuffer@Ogre@@@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@IAEPAPAVHardwarePixelBuffer@Ogre@@PAPAV23@00@Z ; std::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::_Umove<Ogre::HardwarePixelBuffer * *>

; 1215 : 
; 1216 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 2

; 1217 : 			_Ufill(_Mylast, _Count - (_Mylast - _VEC_ITER_BASE(_Where)),
; 1218 : 				_Tmp);	// insert new stuff off end

	lea	edx, DWORD PTR __Tmp$66663[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	sub	ecx, DWORD PTR __Where$[ebp+4]
	sar	ecx, 2
	mov	edx, DWORD PTR __Count$[ebp]
	sub	edx, ecx
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Ufill@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@IAEPAPAVHardwarePixelBuffer@Ogre@@PAPAV34@IABQAV34@@Z ; std::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::_Ufill
	jmp	SHORT $LN21@Insert_n
__catch$?_Insert_n@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@2@IABQAVHardwarePixelBuffer@Ogre@@@Z$2:

; 1219 : 			_CATCH_ALL
; 1220 : 			_Destroy(_VEC_ITER_BASE(_Where) + _Count, _Mylast + _Count);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR __Count$[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	mov	ecx, DWORD PTR __Where$[ebp+4]
	lea	edx, DWORD PTR [ecx+eax*4]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@IAEXPAPAVHardwarePixelBuffer@Ogre@@0@Z ; std::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::_Destroy

; 1221 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1222 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$?_Insert_n@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@2@IABQAVHardwarePixelBuffer@Ogre@@@Z$3
	ret	0
$LN21@Insert_n:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Insert_n@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@2@IABQAVHardwarePixelBuffer@Ogre@@@Z$3:

; 1223 : 
; 1224 : 			_Mylast += _Count;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR __Count$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 1225 : 
; 1226 :  #if _HAS_ITERATOR_DEBUGGING
; 1227 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1228 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1229 : 
; 1230 : 			std::fill(_VEC_ITER_BASE(_Where), _Mylast - _Count,
; 1231 : 				_Tmp);	// insert up to old end

	lea	edx, DWORD PTR __Tmp$66663[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 2
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	sub	edx, eax
	push	edx
	mov	eax, DWORD PTR __Where$[ebp+4]
	push	eax
	call	??$fill@PAPAVHardwarePixelBuffer@Ogre@@PAV12@@std@@YAXPAPAVHardwarePixelBuffer@Ogre@@0ABQAV12@@Z ; std::fill<Ogre::HardwarePixelBuffer * *,Ogre::HardwarePixelBuffer *>
	add	esp, 12					; 0000000cH

; 1232 : 			}
; 1233 : 		else

	jmp	SHORT $LN16@Insert_n
$LN3@Insert_n:

; 1234 : 			{	// new stuff can all be assigned
; 1235 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	ecx, DWORD PTR __Val$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR __Tmp$66673[ebp], edx

; 1236 : 
; 1237 : 			pointer _Oldend = _Mylast;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR __Oldend$66674[ebp], ecx

; 1238 : 			_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1239 : 				_Mylast);	// copy suffix

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR __Oldend$66674[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count$[ebp]
	shl	edx, 2
	mov	eax, DWORD PTR __Oldend$66674[ebp]
	sub	eax, edx
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Umove@PAPAVHardwarePixelBuffer@Ogre@@@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@IAEPAPAVHardwarePixelBuffer@Ogre@@PAPAV23@00@Z ; std::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::_Umove<Ogre::HardwarePixelBuffer * *>
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 1240 : 
; 1241 :  #if _HAS_ITERATOR_DEBUGGING
; 1242 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1243 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1244 : 
; 1245 : 			_STDEXT _Unchecked_move_backward(_VEC_ITER_BASE(_Where), _Oldend - _Count,
; 1246 : 				_Oldend);	// copy hole

	mov	edx, DWORD PTR __Oldend$66674[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 2
	mov	ecx, DWORD PTR __Oldend$66674[ebp]
	sub	ecx, eax
	push	ecx
	mov	edx, DWORD PTR __Where$[ebp+4]
	push	edx
	call	??$_Unchecked_move_backward@PAPAVHardwarePixelBuffer@Ogre@@PAPAV12@@stdext@@YAPAPAVHardwarePixelBuffer@Ogre@@PAPAV12@00@Z ; stdext::_Unchecked_move_backward<Ogre::HardwarePixelBuffer * *,Ogre::HardwarePixelBuffer * *>
	add	esp, 12					; 0000000cH

; 1247 : 			std::fill(_VEC_ITER_BASE(_Where), _VEC_ITER_BASE(_Where) + _Count,
; 1248 : 				_Tmp);	// insert into hole

	lea	eax, DWORD PTR __Tmp$66673[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Where$[ebp+4]
	lea	eax, DWORD PTR [edx+ecx*4]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp+4]
	push	ecx
	call	??$fill@PAPAVHardwarePixelBuffer@Ogre@@PAV12@@std@@YAXPAPAVHardwarePixelBuffer@Ogre@@0ABQAV12@@Z ; std::fill<Ogre::HardwarePixelBuffer * *,Ogre::HardwarePixelBuffer *>
	add	esp, 12					; 0000000cH
$LN16@Insert_n:

; 1249 : 			}
; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Insert_n@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@2@IABQAVHardwarePixelBuffer@Ogre@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-56]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Insert_n@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@2@IABQAVHardwarePixelBuffer@Ogre@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Insert_n@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@2@IABQAVHardwarePixelBuffer@Ogre@@@Z ENDP ; std::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::_Insert_n
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@KAXXZ$0
__ehfuncinfo$?_Xlen@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@KAXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T73107 = -80						; size = 28
$T73106 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@KAXXZ PROC ; std::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Xlen@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T73107[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR $T73107[ebp]
	push	eax
	lea	ecx, DWORD PTR $T73106[ebp]
	call	??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::length_error::length_error
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T73106[ebp]
	push	ecx
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T73107[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN2@Xlen@3:

; 1261 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T73107[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?_Xlen@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@KAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@KAXXZ ENDP ; std::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::_Xlen
PUBLIC	??$?0PAVHardwarePixelBuffer@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@PAVHardwarePixelBuffer@Ogre@@@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::HardwarePixelBuffer *>
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@IAE@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@IAE@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@1@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@IAE@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@1@@Z$1
__ehfuncinfo$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@IAE@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@IAE@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Container_base_aux_alloc_real@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@IAE@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@1@@Z
_TEXT	SEGMENT
tv133 = -32						; size = 4
_this$ = -28						; size = 4
$T73119 = -24						; size = 4
$T73118 = -20						; size = 4
$T73117 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 1
??0?$_Container_base_aux_alloc_real@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@IAE@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@1@@Z PROC ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::HardwarePixelBuffer *> >::_Container_base_aux_alloc_real<std::allocator<Ogre::HardwarePixelBuffer *> >, COMDAT
; _this$ = ecx

; 419  : 		{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@IAE@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 20					; 00000014H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::_Container_base_aux
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??$?0PAVHardwarePixelBuffer@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@PAVHardwarePixelBuffer@Ogre@@@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::HardwarePixelBuffer *>

; 420  : 		_Myownedaux = new (_Alaux.allocate(1)) _Aux_cont(this);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?allocate@?$allocator@V_Aux_cont@std@@@std@@QAEPAV_Aux_cont@2@I@Z ; std::allocator<std::_Aux_cont>::allocate
	mov	DWORD PTR $T73119[ebp], eax
	mov	ecx, DWORD PTR $T73119[ebp]
	push	ecx
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T73118[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	cmp	DWORD PTR $T73118[ebp], 0
	je	SHORT $LN3@Container_@3
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T73118[ebp]
	call	??0_Aux_cont@std@@QAE@QBV_Container_base_aux@1@@Z ; std::_Aux_cont::_Aux_cont
	mov	DWORD PTR tv133[ebp], eax
	jmp	SHORT $LN4@Container_@3
$LN3@Container_@3:
	mov	DWORD PTR tv133[ebp], 0
$LN4@Container_@3:
	mov	eax, DWORD PTR tv133[ebp]
	mov	DWORD PTR $T73117[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T73117[ebp]
	mov	DWORD PTR [ecx], edx

; 421  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@IAE@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@IAE@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@1@@Z$1:
	mov	eax, DWORD PTR $T73119[ebp]
	push	eax
	mov	ecx, DWORD PTR $T73118[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@IAE@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@IAE@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Container_base_aux_alloc_real@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@IAE@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@1@@Z ENDP ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::HardwarePixelBuffer *> >::_Container_base_aux_alloc_real<std::allocator<Ogre::HardwarePixelBuffer *> >
PUBLIC	??$_Allocate@PAVHardwarePixelBuffer@Ogre@@@std@@YAPAPAVHardwarePixelBuffer@Ogre@@IPAPAV12@@Z ; std::_Allocate<Ogre::HardwarePixelBuffer *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@QAEPAPAVHardwarePixelBuffer@Ogre@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@QAEPAPAVHardwarePixelBuffer@Ogre@@I@Z PROC ; std::allocator<Ogre::HardwarePixelBuffer *>::allocate, COMDAT
; _this$ = ecx

; 144  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@PAVHardwarePixelBuffer@Ogre@@@std@@YAPAPAVHardwarePixelBuffer@Ogre@@IPAPAV12@@Z ; std::_Allocate<Ogre::HardwarePixelBuffer *>
	add	esp, 8

; 146  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@QAEPAPAVHardwarePixelBuffer@Ogre@@I@Z ENDP ; std::allocator<Ogre::HardwarePixelBuffer *>::allocate
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ?_Isnil@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Isnil@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Isnil, COMDAT

; 156  : 		{	// return reference to nil flag in node

	push	ebp
	mov	ebp, esp

; 157  : 		return ((_Charref)(*_Pnode)._Isnil);

	mov	eax, DWORD PTR __Pnode$[ebp]
	add	eax, 21					; 00000015H

; 158  : 		}

	pop	ebp
	ret	0
?_Isnil@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Isnil
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Left@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Left@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Left, COMDAT

; 166  : 		{	// return reference to left pointer in node

	push	ebp
	mov	ebp, esp

; 167  : 		return ((_Nodepref)(*_Pnode)._Left);

	mov	eax, DWORD PTR __Pnode$[ebp]

; 168  : 		}

	pop	ebp
	ret	0
?_Left@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Left
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Parent@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Parent@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Parent, COMDAT

; 171  : 		{	// return reference to parent pointer in node

	push	ebp
	mov	ebp, esp

; 172  : 		return ((_Nodepref)(*_Pnode)._Parent);

	mov	eax, DWORD PTR __Pnode$[ebp]
	add	eax, 4

; 173  : 		}

	pop	ebp
	ret	0
?_Parent@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Parent
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Right@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Right@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Right, COMDAT

; 176  : 		{	// return reference to right pointer in node

	push	ebp
	mov	ebp, esp

; 177  : 		return ((_Nodepref)(*_Pnode)._Right);

	mov	eax, DWORD PTR __Pnode$[ebp]
	add	eax, 8

; 178  : 		}

	pop	ebp
	ret	0
?_Right@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Right
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Myval@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAU?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Myval@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAU?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Myval, COMDAT

; 181  : 		{	// return reference to value in node

	push	ebp
	mov	ebp, esp

; 182  : 		return ((_Vref)(*_Pnode)._Myval);

	mov	eax, DWORD PTR __Pnode$[ebp]
	add	eax, 12					; 0000000cH

; 183  : 		}

	pop	ebp
	ret	0
?_Myval@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAU?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Myval
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Make_iter@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QBE?AViterator@12@Vconst_iterator@12@@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
$T73144 = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 8
?_Make_iter@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QBE?AViterator@12@Vconst_iterator@12@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Make_iter, COMDAT
; _this$ = ecx

; 575  : 		{	// make iterator from const_iterator

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 576  : 		return (iterator(_TREE_ITERATOR(_Where._Ptr)));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp+4]
	push	ecx
	lea	ecx, DWORD PTR $T73144[ebp]
	call	??0iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PBV12@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::iterator::iterator
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 577  : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?_Make_iter@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QBE?AViterator@12@Vconst_iterator@12@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Make_iter
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?size@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QBEIXZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::size, COMDAT
; _this$ = ecx

; 600  : 		{	// return length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 601  : 		return (_Mysize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+28]

; 602  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?size@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QBEIXZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::size
_TEXT	ENDS
PUBLIC	??Fiterator@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::iterator::operator--
PUBLIC	??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@1@AB_N@Z ; std::pair<std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::iterator,bool>::pair<std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::iterator,bool>
; Function compile flags: /Odtp
;	COMDAT ?insert@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@_N@2@ABU?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@2@@Z
_TEXT	SEGMENT
tv90 = -76						; size = 4
_this$ = -72						; size = 4
$T73158 = -65						; size = 1
$T73157 = -64						; size = 8
$T73156 = -53						; size = 1
$T73155 = -52						; size = 8
$T73154 = -41						; size = 1
$T73153 = -40						; size = 8
$T73152 = -32						; size = 8
$T73151 = -21						; size = 1
__Where$66761 = -20					; size = 8
__Trynode$ = -12					; size = 4
__Wherenode$ = -8					; size = 4
__Addleft$ = -1						; size = 1
___$ReturnUdt$ = 8					; size = 4
__Val$ = 12						; size = 4
?insert@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@_N@2@ABU?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::insert, COMDAT
; _this$ = ecx

; 630  : 		{	// try to insert node with value _Val

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	mov	DWORD PTR _this$[ebp], ecx

; 631  : 		_Nodeptr _Trynode = _Root();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Root
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR __Trynode$[ebp], eax

; 632  : 		_Nodeptr _Wherenode = _Myhead;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR __Wherenode$[ebp], edx

; 633  : 		bool _Addleft = true;	// add to left of head if tree empty

	mov	BYTE PTR __Addleft$[ebp], 1
$LN10@insert@3:

; 634  : 		while (!_Isnil(_Trynode))

	mov	eax, DWORD PTR __Trynode$[ebp]
	push	eax
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Isnil
	add	esp, 4
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN9@insert@3

; 635  : 			{	// look for leaf to insert before (_Addleft) or after
; 636  : 			_Wherenode = _Trynode;

	mov	edx, DWORD PTR __Trynode$[ebp]
	mov	DWORD PTR __Wherenode$[ebp], edx

; 637  : 			_Addleft = _DEBUG_LT_PRED(this->comp,

	mov	eax, DWORD PTR __Trynode$[ebp]
	push	eax
	call	?_Key@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAABIPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Key
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	call	?_Kfn@?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@SAABIABU?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@2@@Z ; std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0>::_Kfn
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??R?$less@I@std@@QBE_NABI0@Z		; std::less<unsigned int>::operator()
	mov	BYTE PTR __Addleft$[ebp], al

; 638  : 				this->_Kfn(_Val), _Key(_Trynode));
; 639  : 			_Trynode = _Addleft ? _Left(_Trynode) : _Right(_Trynode);

	movzx	edx, BYTE PTR __Addleft$[ebp]
	test	edx, edx
	je	SHORT $LN13@insert@3
	mov	eax, DWORD PTR __Trynode$[ebp]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv90[ebp], ecx
	jmp	SHORT $LN14@insert@3
$LN13@insert@3:
	mov	edx, DWORD PTR __Trynode$[ebp]
	push	edx
	call	?_Right@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Right
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR tv90[ebp], eax
$LN14@insert@3:
	mov	ecx, DWORD PTR tv90[ebp]
	mov	DWORD PTR __Trynode$[ebp], ecx

; 640  : 			}

	jmp	SHORT $LN10@insert@3
$LN9@insert@3:

; 641  : 
; 642  : 		if (this->_Multi)

	xor	edx, edx
	je	SHORT $LN8@insert@3

; 643  : 			return (_Pairib(_Insert(_Addleft, _Wherenode, _Val), true));

	mov	BYTE PTR $T73151[ebp], 1
	lea	eax, DWORD PTR $T73151[ebp]
	push	eax
	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	movzx	eax, BYTE PTR __Addleft$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T73152[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@ABU?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Insert
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@1@AB_N@Z ; std::pair<std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::iterator,bool>::pair<std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::iterator,bool>
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN11@insert@3

; 644  : 		else

	jmp	$LN11@insert@3
$LN8@insert@3:

; 645  : 			{	// insert only if unique
; 646  : 			iterator _Where = _TREE_ITERATOR(_Wherenode);

	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR __Wherenode$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Where$66761[ebp]
	call	??0iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PBV12@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::iterator::iterator

; 647  : 			if (!_Addleft)

	movzx	ecx, BYTE PTR __Addleft$[ebp]
	test	ecx, ecx
	jne	SHORT $LN6@insert@3
	jmp	SHORT $LN5@insert@3
$LN6@insert@3:

; 648  : 				;	// need to test if insert after is okay
; 649  : 			else if (_Where == begin())

	lea	edx, DWORD PTR $T73153[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::begin
	push	eax
	lea	ecx, DWORD PTR __Where$66761[ebp]
	call	??8const_iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::const_iterator::operator==
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN4@insert@3

; 650  : 				return (_Pairib(_Insert(true, _Wherenode, _Val), true));

	mov	BYTE PTR $T73154[ebp], 1
	lea	ecx, DWORD PTR $T73154[ebp]
	push	ecx
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	eax, DWORD PTR __Wherenode$[ebp]
	push	eax
	push	1
	lea	ecx, DWORD PTR $T73155[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@ABU?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Insert
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@1@AB_N@Z ; std::pair<std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::iterator,bool>::pair<std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::iterator,bool>
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN11@insert@3

; 651  : 			else

	jmp	SHORT $LN5@insert@3
$LN4@insert@3:

; 652  : 				--_Where;	// need to test if insert before is okay

	lea	ecx, DWORD PTR __Where$66761[ebp]
	call	??Fiterator@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::iterator::operator--
$LN5@insert@3:

; 653  : 
; 654  : 			if (_DEBUG_LT_PRED(this->comp,

	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	call	?_Kfn@?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@SAABIABU?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@2@@Z ; std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0>::_Kfn
	add	esp, 4
	push	eax
	lea	ecx, DWORD PTR __Where$66761[ebp]
	call	?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@3@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::const_iterator::_Mynode
	push	eax
	call	?_Key@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAABIPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Key
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??R?$less@I@std@@QBE_NABI0@Z		; std::less<unsigned int>::operator()
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@insert@3

; 655  : 				_Key(_Where._Mynode()), this->_Kfn(_Val)))
; 656  : 				return (_Pairib(_Insert(_Addleft, _Wherenode, _Val), true));

	mov	BYTE PTR $T73156[ebp], 1
	lea	ecx, DWORD PTR $T73156[ebp]
	push	ecx
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	eax, DWORD PTR __Wherenode$[ebp]
	push	eax
	movzx	ecx, BYTE PTR __Addleft$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T73157[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@ABU?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Insert
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@1@AB_N@Z ; std::pair<std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::iterator,bool>::pair<std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::iterator,bool>
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	SHORT $LN11@insert@3

; 657  : 			else

	jmp	SHORT $LN11@insert@3
$LN2@insert@3:

; 658  : 				return (_Pairib(_Where, false));

	mov	BYTE PTR $T73158[ebp], 0
	lea	eax, DWORD PTR $T73158[ebp]
	push	eax
	lea	ecx, DWORD PTR __Where$66761[ebp]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@1@AB_N@Z ; std::pair<std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::iterator,bool>::pair<std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::iterator,bool>
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN11@insert@3:

; 659  : 			}
; 660  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?insert@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@_N@2@ABU?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::insert
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Node>::destroy
PUBLIC	?_Rrotate@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Rrotate
PUBLIC	?_Lrotate@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Lrotate
PUBLIC	?_Color@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Color
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?erase@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?erase@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z$0
__ehfuncinfo$?erase@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?erase@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z
_TEXT	SEGMENT
tv177 = -108						; size = 4
tv165 = -104						; size = 4
_this$ = -100						; size = 4
$T73162 = -96						; size = 28
$T73161 = -68						; size = 40
__Fixnodeparent$ = -28					; size = 4
__Pnode$ = -24						; size = 4
__Fixnode$ = -20					; size = 4
__Erasednode$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 8
?erase@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::erase, COMDAT
; _this$ = ecx

; 764  : 		{	// erase element at _Where

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?erase@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 96					; 00000060H
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 765  : 
; 766  :  #if _HAS_ITERATOR_DEBUGGING
; 767  : 		if (_Where._Mycont != this || _Isnil(_Where._Mynode()))
; 768  : 			_DEBUG_ERROR("map/set erase iterator outside range");
; 769  : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase
; 770  : 		++_Where;	// save successor iterator for return
; 771  : 		_Orphan_ptr(*this, _Erasednode);
; 772  : 
; 773  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 774  : 		if (_Isnil(_Where._Mynode()))

	lea	ecx, DWORD PTR __Where$[ebp]
	call	?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@3@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::const_iterator::_Mynode
	push	eax
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Isnil
	add	esp, 4
	movsx	eax, BYTE PTR [eax]
	test	eax, eax
	je	SHORT $LN40@erase@7

; 775  : 			_THROW(out_of_range, "invalid map/set<T> iterator");

	push	OFFSET ??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@
	lea	ecx, DWORD PTR $T73162[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR $T73162[ebp]
	push	ecx
	lea	ecx, DWORD PTR $T73161[ebp]
	call	??0out_of_range@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::out_of_range::out_of_range
	push	OFFSET __TI3?AVout_of_range@std@@
	lea	edx, DWORD PTR $T73161[ebp]
	push	edx
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T73162[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN40@erase@7:

; 776  : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase

	lea	ecx, DWORD PTR __Where$[ebp]
	call	?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@3@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::const_iterator::_Mynode
	mov	DWORD PTR __Erasednode$[ebp], eax

; 777  : 		++_Where;	// save successor iterator for return

	lea	ecx, DWORD PTR __Where$[ebp]
	call	??Econst_iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::const_iterator::operator++

; 778  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 779  : 
; 780  : 		_Nodeptr _Fixnode;	// the node to recolor as needed
; 781  : 		_Nodeptr _Fixnodeparent;	// parent of _Fixnode (which may be nil)
; 782  : 		_Nodeptr _Pnode = _Erasednode;

	mov	eax, DWORD PTR __Erasednode$[ebp]
	mov	DWORD PTR __Pnode$[ebp], eax

; 783  : 
; 784  : 		if (_Isnil(_Left(_Pnode)))

	mov	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	call	?_Left@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Left
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	push	edx
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Isnil
	add	esp, 4
	movsx	eax, BYTE PTR [eax]
	test	eax, eax
	je	SHORT $LN39@erase@7

; 785  : 			_Fixnode = _Right(_Pnode);	// must stitch up right subtree

	mov	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	call	?_Right@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Right
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR __Fixnode$[ebp], edx
	jmp	SHORT $LN38@erase@7
$LN39@erase@7:

; 786  : 		else if (_Isnil(_Right(_Pnode)))

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Right@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Isnil
	add	esp, 4
	movsx	edx, BYTE PTR [eax]
	test	edx, edx
	je	SHORT $LN37@erase@7

; 787  : 			_Fixnode = _Left(_Pnode);	// must stitch up left subtree

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Fixnode$[ebp], ecx

; 788  : 		else

	jmp	SHORT $LN38@erase@7
$LN37@erase@7:

; 789  : 			{	// two subtrees, must lift successor node to replace erased
; 790  : 			_Pnode = _Where._Mynode();	// _Pnode is successor node

	lea	ecx, DWORD PTR __Where$[ebp]
	call	?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@3@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::const_iterator::_Mynode
	mov	DWORD PTR __Pnode$[ebp], eax

; 791  : 			_Fixnode = _Right(_Pnode);	// _Fixnode is its only subtree

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Right@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Right
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR __Fixnode$[ebp], eax
$LN38@erase@7:

; 792  : 			}
; 793  : 
; 794  : 		if (_Pnode == _Erasednode)

	mov	ecx, DWORD PTR __Pnode$[ebp]
	cmp	ecx, DWORD PTR __Erasednode$[ebp]
	jne	$LN35@erase@7

; 795  : 			{	// at most one subtree, relink it
; 796  : 			_Fixnodeparent = _Parent(_Erasednode);

	mov	edx, DWORD PTR __Erasednode$[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR __Fixnodeparent$[ebp], eax

; 797  : 			if (!_Isnil(_Fixnode))

	mov	ecx, DWORD PTR __Fixnode$[ebp]
	push	ecx
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Isnil
	add	esp, 4
	movsx	edx, BYTE PTR [eax]
	test	edx, edx
	jne	SHORT $LN34@erase@7

; 798  : 				_Parent(_Fixnode) = _Fixnodeparent;	// link up

	mov	eax, DWORD PTR __Fixnode$[ebp]
	push	eax
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Parent
	add	esp, 4
	mov	ecx, DWORD PTR __Fixnodeparent$[ebp]
	mov	DWORD PTR [eax], ecx
$LN34@erase@7:

; 799  : 
; 800  : 			if (_Root() == _Erasednode)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Root
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR __Erasednode$[ebp]
	jne	SHORT $LN33@erase@7

; 801  : 				_Root() = _Fixnode;	// link down from root

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Root
	mov	ecx, DWORD PTR __Fixnode$[ebp]
	mov	DWORD PTR [eax], ecx
	jmp	SHORT $LN32@erase@7
$LN33@erase@7:

; 802  : 			else if (_Left(_Fixnodeparent) == _Erasednode)

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	push	edx
	call	?_Left@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Left
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	cmp	eax, DWORD PTR __Erasednode$[ebp]
	jne	SHORT $LN31@erase@7

; 803  : 				_Left(_Fixnodeparent) = _Fixnode;	// link down to left

	mov	ecx, DWORD PTR __Fixnodeparent$[ebp]
	push	ecx
	call	?_Left@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Left
	add	esp, 4
	mov	edx, DWORD PTR __Fixnode$[ebp]
	mov	DWORD PTR [eax], edx

; 804  : 			else

	jmp	SHORT $LN32@erase@7
$LN31@erase@7:

; 805  : 				_Right(_Fixnodeparent) = _Fixnode;	// link down to right

	mov	eax, DWORD PTR __Fixnodeparent$[ebp]
	push	eax
	call	?_Right@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR __Fixnode$[ebp]
	mov	DWORD PTR [eax], ecx
$LN32@erase@7:

; 806  : 
; 807  : 			if (_Lmost() == _Erasednode)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lmost@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Lmost
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR __Erasednode$[ebp]
	jne	SHORT $LN29@erase@7

; 808  : 				_Lmost() = _Isnil(_Fixnode)
; 809  : 					? _Fixnodeparent	// smallest is parent of erased node
; 810  : 					: _Min(_Fixnode);	// smallest in relinked subtree

	mov	eax, DWORD PTR __Fixnode$[ebp]
	push	eax
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Isnil
	add	esp, 4
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN43@erase@7
	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	mov	DWORD PTR tv165[ebp], edx
	jmp	SHORT $LN44@erase@7
$LN43@erase@7:
	mov	eax, DWORD PTR __Fixnode$[ebp]
	push	eax
	call	?_Min@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Min
	add	esp, 4
	mov	DWORD PTR tv165[ebp], eax
$LN44@erase@7:
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lmost@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Lmost
	mov	ecx, DWORD PTR tv165[ebp]
	mov	DWORD PTR [eax], ecx
$LN29@erase@7:

; 811  : 
; 812  : 			if (_Rmost() == _Erasednode)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rmost@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Rmost
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR __Erasednode$[ebp]
	jne	SHORT $LN28@erase@7

; 813  : 				_Rmost() = _Isnil(_Fixnode)
; 814  : 					? _Fixnodeparent	// largest is parent of erased node
; 815  : 					: _Max(_Fixnode);	// largest in relinked subtree

	mov	eax, DWORD PTR __Fixnode$[ebp]
	push	eax
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Isnil
	add	esp, 4
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN45@erase@7
	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	mov	DWORD PTR tv177[ebp], edx
	jmp	SHORT $LN46@erase@7
$LN45@erase@7:
	mov	eax, DWORD PTR __Fixnode$[ebp]
	push	eax
	call	?_Max@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Max
	add	esp, 4
	mov	DWORD PTR tv177[ebp], eax
$LN46@erase@7:
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rmost@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Rmost
	mov	ecx, DWORD PTR tv177[ebp]
	mov	DWORD PTR [eax], ecx
$LN28@erase@7:

; 816  : 			}
; 817  : 		else

	jmp	$LN27@erase@7
$LN35@erase@7:

; 818  : 			{	// erased has two subtrees, _Pnode is successor to erased
; 819  : 			_Parent(_Left(_Erasednode)) = _Pnode;	// link left up

	mov	edx, DWORD PTR __Erasednode$[ebp]
	push	edx
	call	?_Left@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Left
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Parent
	add	esp, 4
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax], ecx

; 820  : 			_Left(_Pnode) = _Left(_Erasednode);	// link successor down

	mov	edx, DWORD PTR __Erasednode$[ebp]
	push	edx
	call	?_Left@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Left
	add	esp, 4
	mov	esi, eax
	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [eax], ecx

; 821  : 
; 822  : 			if (_Pnode == _Right(_Erasednode))

	mov	edx, DWORD PTR __Erasednode$[ebp]
	push	edx
	call	?_Right@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR __Pnode$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jne	SHORT $LN26@erase@7

; 823  : 				_Fixnodeparent = _Pnode;	// successor is next to erased

	mov	edx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR __Fixnodeparent$[ebp], edx

; 824  : 			else

	jmp	$LN25@erase@7
$LN26@erase@7:

; 825  : 				{	// successor further down, link in place of erased
; 826  : 				_Fixnodeparent = _Parent(_Pnode);	// parent is successor's

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Parent
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Fixnodeparent$[ebp], ecx

; 827  : 				if (!_Isnil(_Fixnode))

	mov	edx, DWORD PTR __Fixnode$[ebp]
	push	edx
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Isnil
	add	esp, 4
	movsx	eax, BYTE PTR [eax]
	test	eax, eax
	jne	SHORT $LN24@erase@7

; 828  : 					_Parent(_Fixnode) = _Fixnodeparent;	// link fix up

	mov	ecx, DWORD PTR __Fixnode$[ebp]
	push	ecx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Parent
	add	esp, 4
	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	mov	DWORD PTR [eax], edx
$LN24@erase@7:

; 829  : 				_Left(_Fixnodeparent) = _Fixnode;	// link fix down

	mov	eax, DWORD PTR __Fixnodeparent$[ebp]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR __Fixnode$[ebp]
	mov	DWORD PTR [eax], ecx

; 830  : 				_Right(_Pnode) = _Right(_Erasednode);	// link successor down

	mov	edx, DWORD PTR __Erasednode$[ebp]
	push	edx
	call	?_Right@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Right
	add	esp, 4
	mov	esi, eax
	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Right@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [eax], ecx

; 831  : 				_Parent(_Right(_Erasednode)) = _Pnode;	// link right up

	mov	edx, DWORD PTR __Erasednode$[ebp]
	push	edx
	call	?_Right@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Right
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Parent
	add	esp, 4
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax], ecx
$LN25@erase@7:

; 832  : 				}
; 833  : 
; 834  : 			if (_Root() == _Erasednode)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Root
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR __Erasednode$[ebp]
	jne	SHORT $LN23@erase@7

; 835  : 				_Root() = _Pnode;	// link down from root

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Root
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax], ecx
	jmp	SHORT $LN22@erase@7
$LN23@erase@7:

; 836  : 			else if (_Left(_Parent(_Erasednode)) == _Erasednode)

	mov	edx, DWORD PTR __Erasednode$[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	cmp	ecx, DWORD PTR __Erasednode$[ebp]
	jne	SHORT $LN21@erase@7

; 837  : 				_Left(_Parent(_Erasednode)) = _Pnode;	// link down to left

	mov	edx, DWORD PTR __Erasednode$[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax], ecx

; 838  : 			else

	jmp	SHORT $LN22@erase@7
$LN21@erase@7:

; 839  : 				_Right(_Parent(_Erasednode)) = _Pnode;	// link down to right

	mov	edx, DWORD PTR __Erasednode$[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Right@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax], ecx
$LN22@erase@7:

; 840  : 
; 841  : 			_Parent(_Pnode) = _Parent(_Erasednode);	// link successor up

	mov	edx, DWORD PTR __Erasednode$[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Parent
	add	esp, 4
	mov	esi, eax
	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Parent
	add	esp, 4
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [eax], ecx

; 842  : 			_STD swap(_Color(_Pnode), _Color(_Erasednode));	// recolor it

	mov	edx, DWORD PTR __Erasednode$[ebp]
	push	edx
	call	?_Color@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Color
	add	esp, 4
	push	eax
	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Color@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Color
	add	esp, 4
	push	eax
	call	??$swap@D@std@@YAXAAD0@Z		; std::swap<char>
	add	esp, 8
$LN27@erase@7:

; 843  : 			}
; 844  : 
; 845  : 		if (_Color(_Erasednode) == _Black)

	mov	ecx, DWORD PTR __Erasednode$[ebp]
	push	ecx
	call	?_Color@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Color
	add	esp, 4
	movsx	edx, BYTE PTR [eax]
	cmp	edx, 1
	jne	$LN19@erase@7

; 846  : 			{	// erasing black link, must recolor/rebalance tree
; 847  : 			for (; _Fixnode != _Root() && _Color(_Fixnode) == _Black;
; 848  : 				_Fixnodeparent = _Parent(_Fixnode))

	jmp	SHORT $LN18@erase@7
$LN17@erase@7:
	mov	eax, DWORD PTR __Fixnode$[ebp]
	push	eax
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Parent
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Fixnodeparent$[ebp], ecx
$LN18@erase@7:
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Root
	mov	edx, DWORD PTR __Fixnode$[ebp]
	cmp	edx, DWORD PTR [eax]
	je	$LN16@erase@7
	mov	eax, DWORD PTR __Fixnode$[ebp]
	push	eax
	call	?_Color@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Color
	add	esp, 4
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 1
	jne	$LN16@erase@7

; 849  : 				if (_Fixnode == _Left(_Fixnodeparent))

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	push	edx
	call	?_Left@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR __Fixnode$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jne	$LN15@erase@7

; 850  : 					{	// fixup left subtree
; 851  : 					_Pnode = _Right(_Fixnodeparent);

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	push	edx
	call	?_Right@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Right
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$[ebp], eax

; 852  : 					if (_Color(_Pnode) == _Red)

	mov	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	call	?_Color@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Color
	add	esp, 4
	movsx	edx, BYTE PTR [eax]
	test	edx, edx
	jne	SHORT $LN14@erase@7

; 853  : 						{	// rotate red up from right subtree
; 854  : 						_Color(_Pnode) = _Black;

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Color@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 1

; 855  : 						_Color(_Fixnodeparent) = _Red;

	mov	ecx, DWORD PTR __Fixnodeparent$[ebp]
	push	ecx
	call	?_Color@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 0

; 856  : 						_Lrotate(_Fixnodeparent);

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lrotate@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Lrotate

; 857  : 						_Pnode = _Right(_Fixnodeparent);

	mov	eax, DWORD PTR __Fixnodeparent$[ebp]
	push	eax
	call	?_Right@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$[ebp], ecx
$LN14@erase@7:

; 858  : 						}
; 859  : 
; 860  : 					if (_Isnil(_Pnode))

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Isnil
	add	esp, 4
	movsx	eax, BYTE PTR [eax]
	test	eax, eax
	je	SHORT $LN13@erase@7

; 861  : 						_Fixnode = _Fixnodeparent;	// shouldn't happen

	mov	ecx, DWORD PTR __Fixnodeparent$[ebp]
	mov	DWORD PTR __Fixnode$[ebp], ecx

; 862  : 					else if (_Color(_Left(_Pnode)) == _Black

	jmp	$LN12@erase@7
$LN13@erase@7:

; 863  : 						&& _Color(_Right(_Pnode)) == _Black)

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Left@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Left
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Color@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Color
	add	esp, 4
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 1
	jne	SHORT $LN11@erase@7
	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Right@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Right
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Color@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Color
	add	esp, 4
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 1
	jne	SHORT $LN11@erase@7

; 864  : 						{	// redden right subtree with black children
; 865  : 						_Color(_Pnode) = _Red;

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Color@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 0

; 866  : 						_Fixnode = _Fixnodeparent;

	mov	eax, DWORD PTR __Fixnodeparent$[ebp]
	mov	DWORD PTR __Fixnode$[ebp], eax

; 867  : 						}
; 868  : 					else

	jmp	$LN12@erase@7
$LN11@erase@7:

; 869  : 						{	// must rearrange right subtree
; 870  : 						if (_Color(_Right(_Pnode)) == _Black)

	mov	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	call	?_Right@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Right
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	push	edx
	call	?_Color@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Color
	add	esp, 4
	movsx	eax, BYTE PTR [eax]
	cmp	eax, 1
	jne	SHORT $LN9@erase@7

; 871  : 							{	// rotate red up from left sub-subtree
; 872  : 							_Color(_Left(_Pnode)) = _Black;

	mov	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	call	?_Left@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Left
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	push	edx
	call	?_Color@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 1

; 873  : 							_Color(_Pnode) = _Red;

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Color@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 0

; 874  : 							_Rrotate(_Pnode);

	mov	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rrotate@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Rrotate

; 875  : 							_Pnode = _Right(_Fixnodeparent);

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	push	edx
	call	?_Right@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Right
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$[ebp], eax
$LN9@erase@7:

; 876  : 							}
; 877  : 
; 878  : 						_Color(_Pnode) = _Color(_Fixnodeparent);

	mov	ecx, DWORD PTR __Fixnodeparent$[ebp]
	push	ecx
	call	?_Color@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Color
	add	esp, 4
	mov	esi, eax
	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Color@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Color
	add	esp, 4
	mov	cl, BYTE PTR [esi]
	mov	BYTE PTR [eax], cl

; 879  : 						_Color(_Fixnodeparent) = _Black;

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	push	edx
	call	?_Color@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 1

; 880  : 						_Color(_Right(_Pnode)) = _Black;

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Right@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?_Color@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 1

; 881  : 						_Lrotate(_Fixnodeparent);

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lrotate@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Lrotate

; 882  : 						break;	// tree now recolored/rebalanced

	jmp	$LN16@erase@7
$LN12@erase@7:

; 883  : 						}
; 884  : 					}
; 885  : 				else

	jmp	$LN8@erase@7
$LN15@erase@7:

; 886  : 					{	// fixup right subtree
; 887  : 					_Pnode = _Left(_Fixnodeparent);

	mov	eax, DWORD PTR __Fixnodeparent$[ebp]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$[ebp], ecx

; 888  : 					if (_Color(_Pnode) == _Red)

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Color@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Color
	add	esp, 4
	movsx	eax, BYTE PTR [eax]
	test	eax, eax
	jne	SHORT $LN7@erase@7

; 889  : 						{	// rotate red up from left subtree
; 890  : 						_Color(_Pnode) = _Black;

	mov	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	call	?_Color@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 1

; 891  : 						_Color(_Fixnodeparent) = _Red;

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	push	edx
	call	?_Color@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 0

; 892  : 						_Rrotate(_Fixnodeparent);

	mov	eax, DWORD PTR __Fixnodeparent$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rrotate@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Rrotate

; 893  : 						_Pnode = _Left(_Fixnodeparent);

	mov	ecx, DWORD PTR __Fixnodeparent$[ebp]
	push	ecx
	call	?_Left@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Left
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$[ebp], edx
$LN7@erase@7:

; 894  : 						}
; 895  : 					if (_Isnil(_Pnode))

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Isnil
	add	esp, 4
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN6@erase@7

; 896  : 						_Fixnode = _Fixnodeparent;	// shouldn't happen

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	mov	DWORD PTR __Fixnode$[ebp], edx

; 897  : 					else if (_Color(_Right(_Pnode)) == _Black

	jmp	$LN8@erase@7
$LN6@erase@7:

; 898  : 						&& _Color(_Left(_Pnode)) == _Black)

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Right@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?_Color@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Color
	add	esp, 4
	movsx	edx, BYTE PTR [eax]
	cmp	edx, 1
	jne	SHORT $LN4@erase@7
	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?_Color@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Color
	add	esp, 4
	movsx	edx, BYTE PTR [eax]
	cmp	edx, 1
	jne	SHORT $LN4@erase@7

; 899  : 						{	// redden left subtree with black children
; 900  : 						_Color(_Pnode) = _Red;

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Color@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 0

; 901  : 						_Fixnode = _Fixnodeparent;

	mov	ecx, DWORD PTR __Fixnodeparent$[ebp]
	mov	DWORD PTR __Fixnode$[ebp], ecx

; 902  : 						}
; 903  : 					else

	jmp	$LN8@erase@7
$LN4@erase@7:

; 904  : 						{	// must rearrange left subtree
; 905  : 						if (_Color(_Left(_Pnode)) == _Black)

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Left@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Left
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Color@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Color
	add	esp, 4
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 1
	jne	SHORT $LN2@erase@7

; 906  : 							{	// rotate red up from right sub-subtree
; 907  : 							_Color(_Right(_Pnode)) = _Black;

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Right@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Right
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Color@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 1

; 908  : 							_Color(_Pnode) = _Red;

	mov	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	call	?_Color@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 0

; 909  : 							_Lrotate(_Pnode);

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lrotate@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Lrotate

; 910  : 							_Pnode = _Left(_Fixnodeparent);

	mov	eax, DWORD PTR __Fixnodeparent$[ebp]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$[ebp], ecx
$LN2@erase@7:

; 911  : 							}
; 912  : 
; 913  : 						_Color(_Pnode) = _Color(_Fixnodeparent);

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	push	edx
	call	?_Color@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Color
	add	esp, 4
	mov	esi, eax
	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Color@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Color
	add	esp, 4
	mov	cl, BYTE PTR [esi]
	mov	BYTE PTR [eax], cl

; 914  : 						_Color(_Fixnodeparent) = _Black;

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	push	edx
	call	?_Color@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 1

; 915  : 						_Color(_Left(_Pnode)) = _Black;

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?_Color@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 1

; 916  : 						_Rrotate(_Fixnodeparent);

	mov	edx, DWORD PTR __Fixnodeparent$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rrotate@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Rrotate

; 917  : 						break;	// tree now recolored/rebalanced

	jmp	SHORT $LN16@erase@7
$LN8@erase@7:

; 918  : 						}
; 919  : 					}

	jmp	$LN17@erase@7
$LN16@erase@7:

; 920  : 
; 921  : 			_Color(_Fixnode) = _Black;	// ensure stopping node is black

	mov	eax, DWORD PTR __Fixnode$[ebp]
	push	eax
	call	?_Color@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 1
$LN19@erase@7:

; 922  : 			}
; 923  : 
; 924  : 		this->_Alnod.destroy(_Erasednode);	// destroy, free erased node

	mov	ecx, DWORD PTR __Erasednode$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Node>::destroy

; 925  : 		this->_Alnod.deallocate(_Erasednode, 1);

	push	1
	mov	edx, DWORD PTR __Erasednode$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Node>::deallocate

; 926  : 
; 927  : 		if (0 < _Mysize)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+28], 0
	jbe	SHORT $LN1@erase@7

; 928  : 			--_Mysize;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	sub	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+28], edx
$LN1@erase@7:

; 929  : 
; 930  : 		return (_Make_iter(_Where));	// return successor iterator

	mov	ecx, DWORD PTR __Where$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR __Where$[ebp]
	push	edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Make_iter@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QBE?AViterator@12@Vconst_iterator@12@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Make_iter
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN42@erase@7:

; 931  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?erase@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z$0:
	lea	ecx, DWORD PTR $T73162[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?erase@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-104]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?erase@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?erase@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AViterator@12@Vconst_iterator@12@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::erase
PUBLIC	?_Erase@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Erase
; Function compile flags: /Odtp
;	COMDAT ?clear@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?clear@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAEXXZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::clear, COMDAT
; _this$ = ecx

; 965  : 		{	// erase all

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 966  : 
; 967  :  #if _HAS_ITERATOR_DEBUGGING
; 968  : 		this->_Orphan_ptr(*this, 0);
; 969  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 970  : 
; 971  : 		_Erase(_Root());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Root
	mov	eax, DWORD PTR [eax]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Erase@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Erase

; 972  : 		_Root() = _Myhead, _Mysize = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Root
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+28], 0

; 973  : 		_Lmost() = _Myhead, _Rmost() = _Myhead;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lmost@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Lmost
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rmost@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Rmost
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR [eax], edx

; 974  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?clear@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::clear
_TEXT	ENDS
PUBLIC	?_Buynode@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@2@D@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Buynode
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Copy@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@0@Z$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@0@Z$0
__unwindtable$?_Copy@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@0@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?_Copy@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@0@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@0@Z$2
__ehfuncinfo$?_Copy@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@0@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Copy@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@0@Z
	DD	01H
	DD	FLAT:__tryblocktable$?_Copy@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@0@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?_Copy@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@0@Z
_TEXT	SEGMENT
_this$ = -28						; size = 4
__Pnode$66835 = -24					; size = 4
__Newroot$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Rootnode$ = 8						; size = 4
__Wherenode$ = 12					; size = 4
?_Copy@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@0@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Copy, COMDAT
; _this$ = ecx

; 1075 : 		{	// copy entire subtree, recursively

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Copy@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@0@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 12					; 0000000cH
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1076 : 		_Nodeptr _Newroot = _Myhead;	// point at nil node

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR __Newroot$[ebp], ecx

; 1077 : 
; 1078 : 		if (!_Isnil(_Rootnode))

	mov	edx, DWORD PTR __Rootnode$[ebp]
	push	edx
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Isnil
	add	esp, 4
	movsx	eax, BYTE PTR [eax]
	test	eax, eax
	jne	$LN3@Copy@4

; 1079 : 			{	// copy a node, then any subtrees
; 1080 : 			_Nodeptr _Pnode = _Buynode(_Myhead, _Wherenode, _Myhead,
; 1081 : 				_Myval(_Rootnode), _Color(_Rootnode));

	mov	ecx, DWORD PTR __Rootnode$[ebp]
	push	ecx
	call	?_Color@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Color
	add	esp, 4
	movzx	edx, BYTE PTR [eax]
	push	edx
	mov	eax, DWORD PTR __Rootnode$[ebp]
	push	eax
	call	?_Myval@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAU?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Myval
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	push	edx
	mov	eax, DWORD PTR __Wherenode$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buynode@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@2@D@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Buynode
	mov	DWORD PTR __Pnode$66835[ebp], eax

; 1082 : 			if (_Isnil(_Newroot))

	mov	eax, DWORD PTR __Newroot$[ebp]
	push	eax
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Isnil
	add	esp, 4
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN2@Copy@4

; 1083 : 				_Newroot = _Pnode;	// memorize new root

	mov	edx, DWORD PTR __Pnode$66835[ebp]
	mov	DWORD PTR __Newroot$[ebp], edx
$LN2@Copy@4:

; 1084 : 
; 1085 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1086 : 			_Left(_Pnode) = _Copy(_Left(_Rootnode), _Pnode);

	mov	eax, DWORD PTR __Pnode$66835[ebp]
	push	eax
	mov	ecx, DWORD PTR __Rootnode$[ebp]
	push	ecx
	call	?_Left@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Left
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Copy@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@0@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Copy
	mov	esi, eax
	mov	eax, DWORD PTR __Pnode$66835[ebp]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Left
	add	esp, 4
	mov	DWORD PTR [eax], esi

; 1087 : 			_Right(_Pnode) = _Copy(_Right(_Rootnode), _Pnode);

	mov	ecx, DWORD PTR __Pnode$66835[ebp]
	push	ecx
	mov	edx, DWORD PTR __Rootnode$[ebp]
	push	edx
	call	?_Right@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Right
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Copy@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@0@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Copy
	mov	esi, eax
	mov	ecx, DWORD PTR __Pnode$66835[ebp]
	push	ecx
	call	?_Right@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Right
	add	esp, 4
	mov	DWORD PTR [eax], esi
	jmp	SHORT $LN6@Copy@4
__catch$?_Copy@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@0@Z$0:

; 1088 : 			_CATCH_ALL
; 1089 : 			_Erase(_Newroot);	// subtree copy failed, bail out

	mov	edx, DWORD PTR __Newroot$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Erase@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Erase

; 1090 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1091 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, $LN3@Copy@4
	ret	0
$LN6@Copy@4:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
$LN3@Copy@4:

; 1092 : 			}
; 1093 : 
; 1094 : 		return (_Newroot);	// return newly constructed tree

	mov	eax, DWORD PTR __Newroot$[ebp]
$LN5@Copy@4:

; 1095 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Copy@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@0@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-32]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Copy@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@0@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Copy@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@0@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Copy
PUBLIC	??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	?max_size@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::max_size
;	COMDAT ??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@ DB 'map/set<T> too l'
	DB	'ong', 00H					; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Insert@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@ABU?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Insert@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@ABU?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@2@@Z$0
__ehfuncinfo$?_Insert@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@ABU?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@2@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Insert@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@ABU?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?_Insert@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@ABU?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@2@@Z
_TEXT	SEGMENT
_this$ = -92						; size = 4
$T73194 = -88						; size = 28
$T73193 = -60						; size = 40
__Pnode$66853 = -20					; size = 4
__Newnode$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Addleft$ = 12						; size = 1
__Wherenode$ = 16					; size = 4
__Val$ = 20						; size = 4
?_Insert@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@ABU?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Insert, COMDAT
; _this$ = ecx

; 1187 : 		{	// add node with value next to _Wherenode, to left if _Addnode

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Insert@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@ABU?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 80					; 00000050H
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1188 : 		if (max_size() - 1 <= _Mysize)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::max_size
	sub	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR [ecx+28]
	ja	SHORT $LN17@Insert

; 1189 : 			_THROW(length_error, "map/set<T> too long");

	push	OFFSET ??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T73194[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	edx, DWORD PTR $T73194[ebp]
	push	edx
	lea	ecx, DWORD PTR $T73193[ebp]
	call	??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::length_error::length_error
	push	OFFSET __TI3?AVlength_error@std@@
	lea	eax, DWORD PTR $T73193[ebp]
	push	eax
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T73194[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN17@Insert:

; 1190 : 		_Nodeptr _Newnode = _Buynode(_Myhead, _Wherenode, _Myhead,
; 1191 : 			_Val, _Red);

	push	0
	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24]
	push	eax
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buynode@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@2@D@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Buynode
	mov	DWORD PTR __Newnode$[ebp], eax

; 1192 : 
; 1193 : 		++_Mysize;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	add	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+28], edx

; 1194 : 		if (_Wherenode == _Myhead)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Wherenode$[ebp]
	cmp	edx, DWORD PTR [ecx+24]
	jne	SHORT $LN16@Insert

; 1195 : 			{	// first node in tree, just set head values
; 1196 : 			_Root() = _Newnode;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Root
	mov	ecx, DWORD PTR __Newnode$[ebp]
	mov	DWORD PTR [eax], ecx

; 1197 : 			_Lmost() = _Newnode, _Rmost() = _Newnode;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lmost@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Lmost
	mov	edx, DWORD PTR __Newnode$[ebp]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rmost@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Rmost
	mov	ecx, DWORD PTR __Newnode$[ebp]
	mov	DWORD PTR [eax], ecx
	jmp	SHORT $LN15@Insert
$LN16@Insert:

; 1198 : 			}
; 1199 : 		else if (_Addleft)

	movzx	edx, BYTE PTR __Addleft$[ebp]
	test	edx, edx
	je	SHORT $LN14@Insert

; 1200 : 			{	// add to left of _Wherenode
; 1201 : 			_Left(_Wherenode) = _Newnode;

	mov	eax, DWORD PTR __Wherenode$[ebp]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR __Newnode$[ebp]
	mov	DWORD PTR [eax], ecx

; 1202 : 			if (_Wherenode == _Lmost())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lmost@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Lmost
	mov	edx, DWORD PTR __Wherenode$[ebp]
	cmp	edx, DWORD PTR [eax]
	jne	SHORT $LN13@Insert

; 1203 : 				_Lmost() = _Newnode;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lmost@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Lmost
	mov	ecx, DWORD PTR __Newnode$[ebp]
	mov	DWORD PTR [eax], ecx
$LN13@Insert:

; 1204 : 			}
; 1205 : 		else

	jmp	SHORT $LN15@Insert
$LN14@Insert:

; 1206 : 			{	// add to right of _Wherenode
; 1207 : 			_Right(_Wherenode) = _Newnode;

	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	call	?_Right@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR __Newnode$[ebp]
	mov	DWORD PTR [eax], ecx

; 1208 : 			if (_Wherenode == _Rmost())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rmost@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Rmost
	mov	edx, DWORD PTR __Wherenode$[ebp]
	cmp	edx, DWORD PTR [eax]
	jne	SHORT $LN15@Insert

; 1209 : 				_Rmost() = _Newnode;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rmost@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Rmost
	mov	ecx, DWORD PTR __Newnode$[ebp]
	mov	DWORD PTR [eax], ecx
$LN15@Insert:

; 1210 : 			}
; 1211 : 
; 1212 : 		for (_Nodeptr _Pnode = _Newnode; _Color(_Parent(_Pnode)) == _Red; )

	mov	edx, DWORD PTR __Newnode$[ebp]
	mov	DWORD PTR __Pnode$66853[ebp], edx
$LN10@Insert:
	mov	eax, DWORD PTR __Pnode$66853[ebp]
	push	eax
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Parent
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?_Color@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Color
	add	esp, 4
	movsx	edx, BYTE PTR [eax]
	test	edx, edx
	jne	$LN9@Insert

; 1213 : 			if (_Parent(_Pnode) == _Left(_Parent(_Parent(_Pnode))))

	mov	eax, DWORD PTR __Pnode$66853[ebp]
	push	eax
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Parent
	add	esp, 4
	mov	esi, eax
	mov	ecx, DWORD PTR __Pnode$66853[ebp]
	push	ecx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Parent
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR [esi]
	cmp	ecx, DWORD PTR [eax]
	jne	$LN8@Insert

; 1214 : 				{	// fixup red-red in left subtree
; 1215 : 				_Wherenode = _Right(_Parent(_Parent(_Pnode)));

	mov	edx, DWORD PTR __Pnode$66853[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Parent
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?_Right@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Right
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR __Wherenode$[ebp], edx

; 1216 : 				if (_Color(_Wherenode) == _Red)

	mov	eax, DWORD PTR __Wherenode$[ebp]
	push	eax
	call	?_Color@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Color
	add	esp, 4
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN7@Insert

; 1217 : 					{	// parent has two red children, blacken both
; 1218 : 					_Color(_Parent(_Pnode)) = _Black;

	mov	edx, DWORD PTR __Pnode$66853[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Color@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 1

; 1219 : 					_Color(_Wherenode) = _Black;

	mov	ecx, DWORD PTR __Wherenode$[ebp]
	push	ecx
	call	?_Color@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 1

; 1220 : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

	mov	edx, DWORD PTR __Pnode$66853[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Parent
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?_Color@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 0

; 1221 : 					_Pnode = _Parent(_Parent(_Pnode));

	mov	edx, DWORD PTR __Pnode$66853[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Parent
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$66853[ebp], ecx

; 1222 : 					}
; 1223 : 				else

	jmp	$LN6@Insert
$LN7@Insert:

; 1224 : 					{	// parent has red and black children
; 1225 : 					if (_Pnode == _Right(_Parent(_Pnode)))

	mov	edx, DWORD PTR __Pnode$66853[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Right@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR __Pnode$66853[ebp]
	cmp	ecx, DWORD PTR [eax]
	jne	SHORT $LN5@Insert

; 1226 : 						{	// rotate right child to left
; 1227 : 						_Pnode = _Parent(_Pnode);

	mov	edx, DWORD PTR __Pnode$66853[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$66853[ebp], eax

; 1228 : 						_Lrotate(_Pnode);

	mov	ecx, DWORD PTR __Pnode$66853[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lrotate@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Lrotate
$LN5@Insert:

; 1229 : 						}
; 1230 : 					_Color(_Parent(_Pnode)) = _Black;	// propagate red up

	mov	edx, DWORD PTR __Pnode$66853[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Color@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 1

; 1231 : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

	mov	ecx, DWORD PTR __Pnode$66853[ebp]
	push	ecx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Parent
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Color@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 0

; 1232 : 					_Rrotate(_Parent(_Parent(_Pnode)));

	mov	ecx, DWORD PTR __Pnode$66853[ebp]
	push	ecx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Parent
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rrotate@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Rrotate
$LN6@Insert:

; 1233 : 					}
; 1234 : 				}
; 1235 : 			else

	jmp	$LN4@Insert
$LN8@Insert:

; 1236 : 				{	// fixup red-red in right subtree
; 1237 : 				_Wherenode = _Left(_Parent(_Parent(_Pnode)));

	mov	ecx, DWORD PTR __Pnode$66853[ebp]
	push	ecx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Parent
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Wherenode$[ebp], ecx

; 1238 : 				if (_Color(_Wherenode) == _Red)

	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	call	?_Color@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Color
	add	esp, 4
	movsx	eax, BYTE PTR [eax]
	test	eax, eax
	jne	SHORT $LN3@Insert

; 1239 : 					{	// parent has two red children, blacken both
; 1240 : 					_Color(_Parent(_Pnode)) = _Black;

	mov	ecx, DWORD PTR __Pnode$66853[ebp]
	push	ecx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Parent
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	push	edx
	call	?_Color@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 1

; 1241 : 					_Color(_Wherenode) = _Black;

	mov	eax, DWORD PTR __Wherenode$[ebp]
	push	eax
	call	?_Color@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 1

; 1242 : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

	mov	ecx, DWORD PTR __Pnode$66853[ebp]
	push	ecx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Parent
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Color@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 0

; 1243 : 					_Pnode = _Parent(_Parent(_Pnode));

	mov	ecx, DWORD PTR __Pnode$66853[ebp]
	push	ecx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Parent
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$66853[ebp], eax

; 1244 : 					}
; 1245 : 				else

	jmp	$LN4@Insert
$LN3@Insert:

; 1246 : 					{	// parent has red and black children
; 1247 : 					if (_Pnode == _Left(_Parent(_Pnode)))

	mov	ecx, DWORD PTR __Pnode$66853[ebp]
	push	ecx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Parent
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	push	edx
	call	?_Left@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR __Pnode$66853[ebp]
	cmp	ecx, DWORD PTR [eax]
	jne	SHORT $LN1@Insert

; 1248 : 						{	// rotate left child to right
; 1249 : 						_Pnode = _Parent(_Pnode);

	mov	edx, DWORD PTR __Pnode$66853[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$66853[ebp], eax

; 1250 : 						_Rrotate(_Pnode);

	mov	ecx, DWORD PTR __Pnode$66853[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Rrotate@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Rrotate
$LN1@Insert:

; 1251 : 						}
; 1252 : 					_Color(_Parent(_Pnode)) = _Black;	// propagate red up

	mov	edx, DWORD PTR __Pnode$66853[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Color@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 1

; 1253 : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

	mov	ecx, DWORD PTR __Pnode$66853[ebp]
	push	ecx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Parent
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Color@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 0

; 1254 : 					_Lrotate(_Parent(_Parent(_Pnode)));

	mov	ecx, DWORD PTR __Pnode$66853[ebp]
	push	ecx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Parent
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Lrotate@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Lrotate
$LN4@Insert:

; 1255 : 					}
; 1256 : 				}

	jmp	$LN10@Insert
$LN9@Insert:

; 1257 : 
; 1258 : 		_Color(_Root()) = _Black;	// root is always black

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Root
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?_Color@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 1

; 1259 : 		return (_TREE_ITERATOR(_Newnode));

	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	eax, DWORD PTR __Newnode$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PBV12@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::iterator::iterator
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN19@Insert:

; 1260 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Insert@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@ABU?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@2@@Z$0:
	lea	ecx, DWORD PTR $T73194[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?_Insert@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@ABU?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@2@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-88]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Insert@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@ABU?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Insert@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@ABU?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Insert
; Function compile flags: /Odtp
;	COMDAT ?_Lbound@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@ABI@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
__Pnode$ = -8						; size = 4
__Wherenode$ = -4					; size = 4
__Keyval$ = 8						; size = 4
?_Lbound@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@ABI@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Lbound, COMDAT
; _this$ = ecx

; 1263 : 		{	// find leftmost node not less than _Keyval

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 1264 : 		_Nodeptr _Pnode = _Root();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Root
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$[ebp], eax

; 1265 : 		_Nodeptr _Wherenode = _Myhead;	// end() if search fails

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR __Wherenode$[ebp], edx
$LN4@Lbound:

; 1266 : 
; 1267 : 		while (!_Isnil(_Pnode))

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Isnil
	add	esp, 4
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN3@Lbound

; 1268 : 			if (_DEBUG_LT_PRED(this->comp, _Key(_Pnode), _Keyval))

	mov	edx, DWORD PTR __Keyval$[ebp]
	push	edx
	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Key@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAABIPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Key
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??R?$less@I@std@@QBE_NABI0@Z		; std::less<unsigned int>::operator()
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@Lbound

; 1269 : 				_Pnode = _Right(_Pnode);	// descend right subtree

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Right@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Right
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$[ebp], eax

; 1270 : 			else

	jmp	SHORT $LN1@Lbound
$LN2@Lbound:

; 1271 : 				{	// _Pnode not less than _Keyval, remember it
; 1272 : 				_Wherenode = _Pnode;

	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR __Wherenode$[ebp], ecx

; 1273 : 				_Pnode = _Left(_Pnode);	// descend left subtree

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Left@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Left
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$[ebp], eax
$LN1@Lbound:

; 1274 : 				}

	jmp	SHORT $LN4@Lbound
$LN3@Lbound:

; 1275 : 
; 1276 : 		return (_Wherenode);	// return best remembered candidate

	mov	eax, DWORD PTR __Wherenode$[ebp]

; 1277 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Lbound@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@ABI@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Lbound
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Max@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Max@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Max, COMDAT

; 1305 : 		{	// return rightmost node in subtree at _Pnode

	push	ebp
	mov	ebp, esp
$LN2@Max@2:

; 1306 : 		while (!_Isnil(_Right(_Pnode)))

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Right@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Isnil
	add	esp, 4
	movsx	edx, BYTE PTR [eax]
	test	edx, edx
	jne	SHORT $LN1@Max@2

; 1307 : 			_Pnode = _Right(_Pnode);

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Right@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$[ebp], ecx
	jmp	SHORT $LN2@Max@2
$LN1@Max@2:

; 1308 : 		return (_Pnode);

	mov	eax, DWORD PTR __Pnode$[ebp]

; 1309 : 		}

	pop	ebp
	ret	0
?_Max@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Max
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Min@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Min@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Min, COMDAT

; 1312 : 		{	// return leftmost node in subtree at _Pnode

	push	ebp
	mov	ebp, esp
$LN2@Min@2:

; 1313 : 		while (!_Isnil(_Left(_Pnode)))

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Isnil
	add	esp, 4
	movsx	edx, BYTE PTR [eax]
	test	edx, edx
	jne	SHORT $LN1@Min@2

; 1314 : 			_Pnode = _Left(_Pnode);

	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$[ebp], ecx
	jmp	SHORT $LN2@Min@2
$LN1@Min@2:

; 1315 : 		return (_Pnode);

	mov	eax, DWORD PTR __Pnode$[ebp]

; 1316 : 		}

	pop	ebp
	ret	0
?_Min@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Min
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Rmost@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Rmost@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Rmost, COMDAT
; _this$ = ecx

; 1319 : 		{	// return rightmost node in nonmutable tree

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1320 : 		return (_Right(_Myhead));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	push	ecx
	call	?_Right@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Right
	add	esp, 4

; 1321 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Rmost@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Rmost
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Root@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Root, COMDAT
; _this$ = ecx

; 1324 : 		{	// return root of nonmutable tree

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1325 : 		return (_Parent(_Myhead));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	push	ecx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Parent
	add	esp, 4

; 1326 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Root@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Root
_TEXT	ENDS
PUBLIC	?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@ABQAU342@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Node *>::construct
PUBLIC	?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Node>::allocate
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Buynode@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@XZ$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Buynode@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@XZ$0
__unwindtable$?_Buynode@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@XZ DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?_Buynode@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@XZ DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Buynode@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@XZ$2
__ehfuncinfo$?_Buynode@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Buynode@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@XZ
	DD	01H
	DD	FLAT:__tryblocktable$?_Buynode@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@XZ
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?_Buynode@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -40						; size = 4
$T73216 = -36						; size = 4
$T73215 = -32						; size = 4
$T73214 = -28						; size = 4
__Wherenode$ = -24					; size = 4
__Linkcnt$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
?_Buynode@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Buynode, COMDAT
; _this$ = ecx

; 1383 : 		{	// allocate a head/nil node

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Buynode@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 24					; 00000018H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1384 : 		_Nodeptr _Wherenode = this->_Alnod.allocate(1);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Node>::allocate
	mov	DWORD PTR __Wherenode$[ebp], eax

; 1385 : 		int _Linkcnt = 0;

	mov	DWORD PTR __Linkcnt$[ebp], 0

; 1386 : 
; 1387 : 		_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1388 : 		this->_Alptr.construct(&_Left(_Wherenode), 0);

	mov	DWORD PTR $T73214[ebp], 0
	lea	eax, DWORD PTR $T73214[ebp]
	push	eax
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	push	ecx
	call	?_Left@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Left
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@ABQAU342@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Node *>::construct

; 1389 : 		++_Linkcnt;

	mov	edx, DWORD PTR __Linkcnt$[ebp]
	add	edx, 1
	mov	DWORD PTR __Linkcnt$[ebp], edx

; 1390 : 		this->_Alptr.construct(&_Parent(_Wherenode), 0);

	mov	DWORD PTR $T73215[ebp], 0
	lea	eax, DWORD PTR $T73215[ebp]
	push	eax
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	push	ecx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Parent
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@ABQAU342@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Node *>::construct

; 1391 : 		++_Linkcnt;

	mov	edx, DWORD PTR __Linkcnt$[ebp]
	add	edx, 1
	mov	DWORD PTR __Linkcnt$[ebp], edx

; 1392 : 		this->_Alptr.construct(&_Right(_Wherenode), 0);

	mov	DWORD PTR $T73216[ebp], 0
	lea	eax, DWORD PTR $T73216[ebp]
	push	eax
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	push	ecx
	call	?_Right@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Right
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@ABQAU342@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Node *>::construct
	jmp	SHORT $LN6@Buynode@2
__catch$?_Buynode@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@XZ$0:

; 1393 : 		_CATCH_ALL
; 1394 : 		if (1 < _Linkcnt)

	cmp	DWORD PTR __Linkcnt$[ebp], 1
	jle	SHORT $LN2@Buynode@2

; 1395 : 			this->_Alptr.destroy(&_Parent(_Wherenode));

	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Parent
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Node *>::destroy
$LN2@Buynode@2:

; 1396 : 		if (0 < _Linkcnt)

	cmp	DWORD PTR __Linkcnt$[ebp], 0
	jle	SHORT $LN1@Buynode@2

; 1397 : 			this->_Alptr.destroy(&_Left(_Wherenode));

	mov	eax, DWORD PTR __Wherenode$[ebp]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Left
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Node *>::destroy
$LN1@Buynode@2:

; 1398 : 		this->_Alnod.deallocate(_Wherenode, 1);

	push	1
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Node>::deallocate

; 1399 : 		_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1400 : 		_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$?_Buynode@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@XZ$1
	ret	0
$LN6@Buynode@2:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Buynode@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@XZ$1:

; 1401 : 		_Color(_Wherenode) = _Black;

	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	call	?_Color@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Color
	add	esp, 4
	mov	BYTE PTR [eax], 1

; 1402 : 		_Isnil(_Wherenode) = false;

	mov	eax, DWORD PTR __Wherenode$[ebp]
	push	eax
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Isnil
	add	esp, 4
	mov	BYTE PTR [eax], 0

; 1403 : 		return (_Wherenode);

	mov	eax, DWORD PTR __Wherenode$[ebp]
$LN5@Buynode@2:

; 1404 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Buynode@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-44]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Buynode@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Buynode@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Buynode
PUBLIC	??$?0U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@1@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Node *>::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Node *><std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >
PUBLIC	??0?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@1@@Z ; std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$_Tree_ptr@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Tree_ptr@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@1@@Z$0
__ehfuncinfo$??0?$_Tree_ptr@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Tree_ptr@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Tree_ptr@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T73232 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Parg$ = 8						; size = 4
__Al$ = 12						; size = 1
??0?$_Tree_ptr@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@1@@Z PROC ; std::_Tree_ptr<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Tree_ptr<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >, COMDAT
; _this$ = ecx

; 78   : 		{	// construct base, and allocator from _Al

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Tree_ptr@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T73232[ebp], esp
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	call	??0?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >
	mov	ecx, DWORD PTR __Parg$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@1@@Z ; std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??$?0U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@1@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Node *>::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Node *><std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >

; 79   : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Tree_ptr@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ
__ehhandler$??0?$_Tree_ptr@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Tree_ptr@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Tree_ptr@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@1@@Z ENDP ; std::_Tree_ptr<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Tree_ptr<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\map
;	COMDAT ?_Kfn@?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@SAABIABU?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@2@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?_Kfn@?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@SAABIABU?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@2@@Z PROC ; std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0>::_Kfn, COMDAT

; 64   : 		{	// extract key from element value

	push	ebp
	mov	ebp, esp

; 65   : 		return (_Val.first);

	mov	eax, DWORD PTR __Val$[ebp]

; 66   : 		}

	pop	ebp
	ret	0
?_Kfn@?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@SAABIABU?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@2@@Z ENDP ; std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0>::_Kfn
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@std@@QAE@ABV01@@Z PROC ; std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@I@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Node>::deallocate, COMDAT
; _this$ = ecx

; 139  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 141  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@I@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Node>::deallocate
_TEXT	ENDS
PUBLIC	??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@0@@Z ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Node *>
; Function compile flags: /Odtp
;	COMDAT ?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Node *>::destroy, COMDAT
; _this$ = ecx

; 159  : 		{	// destroy object at _Ptr

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 160  : 		_Destroy(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@0@@Z ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Node *>
	add	esp, 4

; 161  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Node *>::destroy
_TEXT	ENDS
PUBLIC	??Y?$_Vector_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::operator+=
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??H?$_Vector_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
__Tmp$ = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Vector_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::operator+, COMDAT
; _this$ = ecx

; 380  : 		{	// return this + integer

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 381  : 		_Myt _Tmp = *this;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR __Tmp$[ebp], ecx
	mov	DWORD PTR __Tmp$[ebp+4], edx

; 382  : 		return (_Tmp += _Off);

	mov	eax, DWORD PTR __Off$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Tmp$[ebp]
	call	??Y?$_Vector_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::operator+=
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 383  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
??H?$_Vector_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::operator+
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??Z?$_Vector_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
??Z?$_Vector_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::operator-=, COMDAT
; _this$ = ecx

; 386  : 		{	// decrement by integer

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 387  : 		return (*this += -_Off);

	mov	eax, DWORD PTR __Off$[ebp]
	neg	eax
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??Y?$_Vector_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::operator+=

; 388  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??Z?$_Vector_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::operator-=
_TEXT	ENDS
PUBLIC	?_Set_container@_Iterator_base_aux@std@@QAEXQBV_Container_base_aux@2@@Z ; std::_Iterator_base_aux::_Set_container
PUBLIC	??0?$_Ranit@PAVHardwarePixelBuffer@Ogre@@HPBQAV12@ABQAV12@@std@@QAE@XZ ; std::_Ranit<Ogre::HardwarePixelBuffer *,int,Ogre::HardwarePixelBuffer * const *,Ogre::HardwarePixelBuffer * const &>::_Ranit<Ogre::HardwarePixelBuffer *,int,Ogre::HardwarePixelBuffer * const *,Ogre::HardwarePixelBuffer * const &>
; Function compile flags: /Odtp
;	COMDAT ??0?$_Vector_const_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QAE@PAPAVHardwarePixelBuffer@Ogre@@PBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QAE@PAPAVHardwarePixelBuffer@Ogre@@PBV_Container_base_aux@1@@Z PROC ; std::_Vector_const_iterator<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::_Vector_const_iterator<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >, COMDAT
; _this$ = ecx

; 76   : 	_Vector_const_iterator(_Tptr _Ptr, const _Container_base *_Pvector)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Ranit@PAVHardwarePixelBuffer@Ogre@@HPBQAV12@ABQAV12@@std@@QAE@XZ

; 77   : 		{	// construct with pointer _Ptr
; 78   : 		_SCL_SECURE_VALIDATE(_Pvector != NULL && ((_Myvec *)_Pvector)->_Myfirst <= _Ptr && _Ptr <= ((_Myvec *)_Pvector)->_Mylast);

	cmp	DWORD PTR __Pvector$[ebp], 0
	je	SHORT $LN1@Vector_con
	mov	eax, DWORD PTR __Pvector$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	cmp	ecx, DWORD PTR __Ptr$[ebp]
	ja	SHORT $LN1@Vector_con
	mov	edx, DWORD PTR __Pvector$[ebp]
	mov	eax, DWORD PTR __Ptr$[ebp]
	cmp	eax, DWORD PTR [edx+16]
	jbe	SHORT $LN2@Vector_con
$LN1@Vector_con:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@Vector_con:

; 79   : 		this->_Set_container(_Pvector);

	mov	ecx, DWORD PTR __Pvector$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Set_container@_Iterator_base_aux@std@@QAEXQBV_Container_base_aux@2@@Z ; std::_Iterator_base_aux::_Set_container

; 80   : 		_Myptr = _Ptr;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR [edx+4], eax

; 81   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Vector_const_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QAE@PAPAVHardwarePixelBuffer@Ogre@@PBV_Container_base_aux@1@@Z ENDP ; std::_Vector_const_iterator<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::_Vector_const_iterator<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ?_Set_container@_Iterator_base_aux@std@@QAEXQBV_Container_base_aux@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pcont$ = 8						; size = 4
?_Set_container@_Iterator_base_aux@std@@QAEXQBV_Container_base_aux@2@@Z PROC ; std::_Iterator_base_aux::_Set_container, COMDAT
; _this$ = ecx

; 452  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 453  : 		_Myaux = _Pcont->_Myownedaux;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Pcont$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 454  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Set_container@_Iterator_base_aux@std@@QAEXQBV_Container_base_aux@2@@Z ENDP ; std::_Iterator_base_aux::_Set_container
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ??G?$_Vector_const_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QBEHABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??G?$_Vector_const_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QBEHABV01@@Z PROC ; std::_Vector_const_iterator<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::operator-, COMDAT
; _this$ = ecx

; 186  : 		{	// return difference of iterators

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 187  : 
; 188  :  #if _HAS_ITERATOR_DEBUGGING
; 189  : 		_Compat(_Right);
; 190  :  #else
; 191  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Has_container@_Iterator_base_aux@std@@QBE_NXZ ; std::_Iterator_base_aux::_Has_container
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@operator@14
	mov	ecx, DWORD PTR __Right$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Same_container@_Iterator_base_aux@std@@QBE_NABV12@@Z ; std::_Iterator_base_aux::_Same_container
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN2@operator@14
$LN1@operator@14:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@operator@14:

; 192  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 193  : 
; 194  : 		return (_Myptr - _Right._Myptr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [eax+4]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 195  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??G?$_Vector_const_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QBEHABV01@@Z ENDP ; std::_Vector_const_iterator<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::operator-
_TEXT	ENDS
PUBLIC	??0?$_Bidit@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@HPBU12@ABU12@@std@@QAE@XZ ; std::_Bidit<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *>,int,std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> const *,std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> const &>::_Bidit<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *>,int,std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> const *,std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> const &>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
;	COMDAT ??0const_iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0const_iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::const_iterator::const_iterator, COMDAT
; _this$ = ecx

; 217  : 			{	// construct with null node pointer

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Bidit@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@HPBU12@ABU12@@std@@QAE@XZ
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0

; 218  : 			}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0const_iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::const_iterator::const_iterator
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PBV12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0const_iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PBV12@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::const_iterator::const_iterator, COMDAT
; _this$ = ecx

; 234  : 			{	// construct with node pointer _Pnode

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Bidit@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@HPBU12@ABU12@@std@@QAE@XZ
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 235  : 			_SCL_SECURE_VALIDATE(_Plist != NULL);

	cmp	DWORD PTR __Plist$[ebp], 0
	jne	SHORT $LN1@const_iter
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN1@const_iter:

; 236  : 			this->_Set_container(_Plist);

	mov	edx, DWORD PTR __Plist$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Set_container@_Iterator_base_aux@std@@QAEXQBV_Container_base_aux@2@@Z ; std::_Iterator_base_aux::_Set_container

; 237  : 			}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0const_iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PBV12@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::const_iterator::const_iterator
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QBEABU?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??Dconst_iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QBEABU?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::const_iterator::operator*, COMDAT
; _this$ = ecx

; 249  : 			{	// return designated value

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 250  : 
; 251  :  #if _HAS_ITERATOR_DEBUGGING
; 252  : 			if (this->_Mycont == 0
; 253  : 				|| _Ptr == 0
; 254  : 				|| _Ptr == ((_Myt *)this->_Mycont)->_Myhead)
; 255  : 				{
; 256  : 				_DEBUG_ERROR("map/set iterator not dereferencable");
; 257  : 				_SCL_SECURE_OUT_OF_RANGE;
; 258  : 				}
; 259  :  #else
; 260  : 			_SCL_SECURE_VALIDATE(this->_Has_container());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Has_container@_Iterator_base_aux@std@@QBE_NXZ ; std::_Iterator_base_aux::_Has_container
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN2@operator@15
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@operator@15:

; 261  : 			_SCL_SECURE_VALIDATE_RANGE(_Ptr != ((_Myt *)(this->_Getmycont()))->_Myhead);

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getmycont@_Iterator_base_aux@std@@QBEPBV_Container_base_aux@2@XZ ; std::_Iterator_base_aux::_Getmycont
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, DWORD PTR [eax+24]
	jne	SHORT $LN1@operator@15
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN1@operator@15:

; 262  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 263  : 
; 264  : 			return (_Myval(_Ptr));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?_Myval@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAU?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Myval
	add	esp, 4

; 265  : 			}

	mov	esp, ebp
	pop	ebp
	ret	0
??Dconst_iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QBEABU?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::const_iterator::operator*
_TEXT	ENDS
PUBLIC	?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::const_iterator::_Inc
; Function compile flags: /Odtp
;	COMDAT ??Econst_iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??Econst_iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAEAAV012@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::const_iterator::operator++, COMDAT
; _this$ = ecx

; 273  : 			{	// preincrement

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 274  : 			_Inc();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::const_iterator::_Inc

; 275  : 			return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 276  : 			}

	mov	esp, ebp
	pop	ebp
	ret	0
??Econst_iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAEAAV012@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::const_iterator::operator++
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??Econst_iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AV012@H@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
__Tmp$ = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??Econst_iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AV012@H@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::const_iterator::operator++, COMDAT
; _this$ = ecx

; 279  : 			{	// postincrement

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 280  : 			const_iterator _Tmp = *this;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR __Tmp$[ebp], ecx
	mov	DWORD PTR __Tmp$[ebp+4], edx

; 281  : 			++*this;

	mov	ecx, DWORD PTR _this$[ebp]
	call	??Econst_iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::const_iterator::operator++

; 282  : 			return (_Tmp);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR __Tmp$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR __Tmp$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 283  : 			}

	mov	esp, ebp
	pop	ebp
	ret	8
??Econst_iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AV012@H@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::const_iterator::operator++
_TEXT	ENDS
PUBLIC	?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::const_iterator::_Dec
; Function compile flags: /Odtp
;	COMDAT ??Fconst_iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??Fconst_iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAEAAV012@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::const_iterator::operator--, COMDAT
; _this$ = ecx

; 286  : 			{	// predecrement

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 287  : 			_Dec();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::const_iterator::_Dec

; 288  : 			return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 289  : 			}

	mov	esp, ebp
	pop	ebp
	ret	0
??Fconst_iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAEAAV012@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::const_iterator::operator--
_TEXT	ENDS
PUBLIC	??0const_iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PBV12@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::const_iterator::const_iterator
; Function compile flags: /Odtp
;	COMDAT ??0iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PBV12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PBV12@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::iterator::iterator, COMDAT
; _this$ = ecx

; 451  : 			{	// construct with node pointer _Pnode

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Plist$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Pnode$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0const_iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PBV12@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::const_iterator::const_iterator

; 452  : 			}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PBV12@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::iterator::iterator
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??Econst_iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AV012@H@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
__Tmp$ = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??Econst_iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AV012@H@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::const_iterator::operator++, COMDAT
; _this$ = ecx

; 279  : 			{	// postincrement

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 280  : 			const_iterator _Tmp = *this;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR __Tmp$[ebp], ecx
	mov	DWORD PTR __Tmp$[ebp+4], edx

; 281  : 			++*this;

	mov	ecx, DWORD PTR _this$[ebp]
	call	??Econst_iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::const_iterator::operator++

; 282  : 			return (_Tmp);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR __Tmp$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR __Tmp$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 283  : 			}

	mov	esp, ebp
	pop	ebp
	ret	8
??Econst_iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE?AV012@H@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::const_iterator::operator++
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??8const_iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QBE_NABV012@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::const_iterator::operator==, COMDAT
; _this$ = ecx

; 299  : 			{	// test for iterator equality

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 300  : 
; 301  :  #if _HAS_ITERATOR_DEBUGGING
; 302  : 			if (this->_Mycont == 0 || this->_Mycont != _Right._Mycont)
; 303  : 				{
; 304  : 				_DEBUG_ERROR("map/set iterators incompatible");
; 305  : 				_SCL_SECURE_INVALID_ARGUMENT;
; 306  : 				}
; 307  :  #else
; 308  : 			_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Has_container@_Iterator_base_aux@std@@QBE_NXZ ; std::_Iterator_base_aux::_Has_container
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@operator@16
	mov	ecx, DWORD PTR __Right$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Same_container@_Iterator_base_aux@std@@QBE_NABV12@@Z ; std::_Iterator_base_aux::_Same_container
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN2@operator@16
$LN1@operator@16:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@operator@16:

; 309  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 310  : 
; 311  : 			return (_Ptr == _Right._Ptr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [eax+4]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+4]
	sete	al

; 312  : 			}

	mov	esp, ebp
	pop	ebp
	ret	4
??8const_iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QBE_NABV012@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::const_iterator::operator==
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??9const_iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??9const_iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QBE_NABV012@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::const_iterator::operator!=, COMDAT
; _this$ = ecx

; 315  : 			{	// test for iterator inequality

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 316  : 			return (!(*this == _Right));

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??8const_iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::const_iterator::operator==
	movzx	eax, al
	neg	eax
	sbb	eax, eax
	add	eax, 1

; 317  : 			}

	mov	esp, ebp
	pop	ebp
	ret	4
??9const_iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QBE_NABV012@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::const_iterator::operator!=
_TEXT	ENDS
PUBLIC	??0?$_Ranit@DHPBDABD@std@@QAE@XZ		; std::_Ranit<char,int,char const *,char const &>::_Ranit<char,int,char const *,char const &>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@DV?$allocator@D@std@@@std@@QAE@PADPBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@DV?$allocator@D@std@@@std@@QAE@PADPBV_Container_base_aux@1@@Z PROC ; std::_Vector_const_iterator<char,std::allocator<char> >::_Vector_const_iterator<char,std::allocator<char> >, COMDAT
; _this$ = ecx

; 76   : 	_Vector_const_iterator(_Tptr _Ptr, const _Container_base *_Pvector)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Ranit@DHPBDABD@std@@QAE@XZ

; 77   : 		{	// construct with pointer _Ptr
; 78   : 		_SCL_SECURE_VALIDATE(_Pvector != NULL && ((_Myvec *)_Pvector)->_Myfirst <= _Ptr && _Ptr <= ((_Myvec *)_Pvector)->_Mylast);

	cmp	DWORD PTR __Pvector$[ebp], 0
	je	SHORT $LN1@Vector_con@2
	mov	eax, DWORD PTR __Pvector$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	cmp	ecx, DWORD PTR __Ptr$[ebp]
	ja	SHORT $LN1@Vector_con@2
	mov	edx, DWORD PTR __Pvector$[ebp]
	mov	eax, DWORD PTR __Ptr$[ebp]
	cmp	eax, DWORD PTR [edx+16]
	jbe	SHORT $LN2@Vector_con@2
$LN1@Vector_con@2:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@Vector_con@2:

; 79   : 		this->_Set_container(_Pvector);

	mov	ecx, DWORD PTR __Pvector$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Set_container@_Iterator_base_aux@std@@QAEXQBV_Container_base_aux@2@@Z ; std::_Iterator_base_aux::_Set_container

; 80   : 		_Myptr = _Ptr;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR [edx+4], eax

; 81   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Vector_const_iterator@DV?$allocator@D@std@@@std@@QAE@PADPBV_Container_base_aux@1@@Z ENDP ; std::_Vector_const_iterator<char,std::allocator<char> >::_Vector_const_iterator<char,std::allocator<char> >
_TEXT	ENDS
PUBLIC	??0?$_Ranit@PAVSurfaceData@Ogre@@HPBQAV12@ABQAV12@@std@@QAE@XZ ; std::_Ranit<Ogre::SurfaceData *,int,Ogre::SurfaceData * const *,Ogre::SurfaceData * const &>::_Ranit<Ogre::SurfaceData *,int,Ogre::SurfaceData * const *,Ogre::SurfaceData * const &>
; Function compile flags: /Odtp
;	COMDAT ??0?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE@PAPAVSurfaceData@Ogre@@PBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE@PAPAVSurfaceData@Ogre@@PBV_Container_base_aux@1@@Z PROC ; std::_Vector_const_iterator<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::_Vector_const_iterator<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >, COMDAT
; _this$ = ecx

; 76   : 	_Vector_const_iterator(_Tptr _Ptr, const _Container_base *_Pvector)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Ranit@PAVSurfaceData@Ogre@@HPBQAV12@ABQAV12@@std@@QAE@XZ

; 77   : 		{	// construct with pointer _Ptr
; 78   : 		_SCL_SECURE_VALIDATE(_Pvector != NULL && ((_Myvec *)_Pvector)->_Myfirst <= _Ptr && _Ptr <= ((_Myvec *)_Pvector)->_Mylast);

	cmp	DWORD PTR __Pvector$[ebp], 0
	je	SHORT $LN1@Vector_con@3
	mov	eax, DWORD PTR __Pvector$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	cmp	ecx, DWORD PTR __Ptr$[ebp]
	ja	SHORT $LN1@Vector_con@3
	mov	edx, DWORD PTR __Pvector$[ebp]
	mov	eax, DWORD PTR __Ptr$[ebp]
	cmp	eax, DWORD PTR [edx+16]
	jbe	SHORT $LN2@Vector_con@3
$LN1@Vector_con@3:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@Vector_con@3:

; 79   : 		this->_Set_container(_Pvector);

	mov	ecx, DWORD PTR __Pvector$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Set_container@_Iterator_base_aux@std@@QAEXQBV_Container_base_aux@2@@Z ; std::_Iterator_base_aux::_Set_container

; 80   : 		_Myptr = _Ptr;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR [edx+4], eax

; 81   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE@PAPAVSurfaceData@Ogre@@PBV_Container_base_aux@1@@Z ENDP ; std::_Vector_const_iterator<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::_Vector_const_iterator<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0length_error@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0length_error@std@@QAE@ABV01@@Z$0
__ehfuncinfo$??0length_error@std@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0length_error@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0length_error@std@@QAE@ABV01@@Z PROC			; std::length_error::length_error, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0length_error@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0logic_error@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7length_error@std@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0length_error@std@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1logic_error@std@@UAE@XZ		; std::logic_error::~logic_error
__ehhandler$??0length_error@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0length_error@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0length_error@std@@QAE@ABV01@@Z ENDP			; std::length_error::length_error
PUBLIC	??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@PAVHardwarePixelBuffer@Ogre@@HPBQAV34@ABQAV34@V_Iterator_base_aux@2@@std@@QAE@XZ ; std::_Iterator_with_base<std::random_access_iterator_tag,Ogre::HardwarePixelBuffer *,int,Ogre::HardwarePixelBuffer * const *,Ogre::HardwarePixelBuffer * const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,Ogre::HardwarePixelBuffer *,int,Ogre::HardwarePixelBuffer * const *,Ogre::HardwarePixelBuffer * const &,std::_Iterator_base_aux>
; Function compile flags: /Odtp
;	COMDAT ??0?$_Ranit@PAVHardwarePixelBuffer@Ogre@@HPBQAV12@ABQAV12@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Ranit@PAVHardwarePixelBuffer@Ogre@@HPBQAV12@ABQAV12@@std@@QAE@XZ PROC ; std::_Ranit<Ogre::HardwarePixelBuffer *,int,Ogre::HardwarePixelBuffer * const *,Ogre::HardwarePixelBuffer * const &>::_Ranit<Ogre::HardwarePixelBuffer *,int,Ogre::HardwarePixelBuffer * const *,Ogre::HardwarePixelBuffer * const &>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@PAVHardwarePixelBuffer@Ogre@@HPBQAV34@ABQAV34@V_Iterator_base_aux@2@@std@@QAE@XZ
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Ranit@PAVHardwarePixelBuffer@Ogre@@HPBQAV12@ABQAV12@@std@@QAE@XZ ENDP ; std::_Ranit<Ogre::HardwarePixelBuffer *,int,Ogre::HardwarePixelBuffer * const *,Ogre::HardwarePixelBuffer * const &>::_Ranit<Ogre::HardwarePixelBuffer *,int,Ogre::HardwarePixelBuffer * const *,Ogre::HardwarePixelBuffer * const &>
_TEXT	ENDS
PUBLIC	??0?$_Iterator_with_base@Ubidirectional_iterator_tag@std@@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@2@HPBU32@ABU32@V_Iterator_base_aux@2@@std@@QAE@XZ ; std::_Iterator_with_base<std::bidirectional_iterator_tag,std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *>,int,std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> const *,std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> const &,std::_Iterator_base_aux>::_Iterator_with_base<std::bidirectional_iterator_tag,std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *>,int,std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> const *,std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> const &,std::_Iterator_base_aux>
; Function compile flags: /Odtp
;	COMDAT ??0?$_Bidit@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@HPBU12@ABU12@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Bidit@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@HPBU12@ABU12@@std@@QAE@XZ PROC ; std::_Bidit<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *>,int,std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> const *,std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> const &>::_Bidit<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *>,int,std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> const *,std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> const &>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Iterator_with_base@Ubidirectional_iterator_tag@std@@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@2@HPBU32@ABU32@V_Iterator_base_aux@2@@std@@QAE@XZ
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Bidit@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@HPBU12@ABU12@@std@@QAE@XZ ENDP ; std::_Bidit<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *>,int,std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> const *,std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> const &>::_Bidit<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *>,int,std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> const *,std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> const &>
_TEXT	ENDS
PUBLIC	??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@DHPBDABDV_Iterator_base_aux@2@@std@@QAE@XZ ; std::_Iterator_with_base<std::random_access_iterator_tag,char,int,char const *,char const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,char,int,char const *,char const &,std::_Iterator_base_aux>
; Function compile flags: /Odtp
;	COMDAT ??0?$_Ranit@DHPBDABD@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Ranit@DHPBDABD@std@@QAE@XZ PROC			; std::_Ranit<char,int,char const *,char const &>::_Ranit<char,int,char const *,char const &>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@DHPBDABDV_Iterator_base_aux@2@@std@@QAE@XZ
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Ranit@DHPBDABD@std@@QAE@XZ ENDP			; std::_Ranit<char,int,char const *,char const &>::_Ranit<char,int,char const *,char const &>
_TEXT	ENDS
PUBLIC	??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@PAVSurfaceData@Ogre@@HPBQAV34@ABQAV34@V_Iterator_base_aux@2@@std@@QAE@XZ ; std::_Iterator_with_base<std::random_access_iterator_tag,Ogre::SurfaceData *,int,Ogre::SurfaceData * const *,Ogre::SurfaceData * const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,Ogre::SurfaceData *,int,Ogre::SurfaceData * const *,Ogre::SurfaceData * const &,std::_Iterator_base_aux>
; Function compile flags: /Odtp
;	COMDAT ??0?$_Ranit@PAVSurfaceData@Ogre@@HPBQAV12@ABQAV12@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Ranit@PAVSurfaceData@Ogre@@HPBQAV12@ABQAV12@@std@@QAE@XZ PROC ; std::_Ranit<Ogre::SurfaceData *,int,Ogre::SurfaceData * const *,Ogre::SurfaceData * const &>::_Ranit<Ogre::SurfaceData *,int,Ogre::SurfaceData * const *,Ogre::SurfaceData * const &>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@PAVSurfaceData@Ogre@@HPBQAV34@ABQAV34@V_Iterator_base_aux@2@@std@@QAE@XZ
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Ranit@PAVSurfaceData@Ogre@@HPBQAV12@ABQAV12@@std@@QAE@XZ ENDP ; std::_Ranit<Ogre::SurfaceData *,int,Ogre::SurfaceData * const *,Ogre::SurfaceData * const &>::_Ranit<Ogre::SurfaceData *,int,Ogre::SurfaceData * const *,Ogre::SurfaceData * const &>
_TEXT	ENDS
PUBLIC	??0_Iterator_base_aux@std@@QAE@XZ		; std::_Iterator_base_aux::_Iterator_base_aux
; Function compile flags: /Odtp
;	COMDAT ??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@PAVHardwarePixelBuffer@Ogre@@HPBQAV34@ABQAV34@V_Iterator_base_aux@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@PAVHardwarePixelBuffer@Ogre@@HPBQAV34@ABQAV34@V_Iterator_base_aux@2@@std@@QAE@XZ PROC ; std::_Iterator_with_base<std::random_access_iterator_tag,Ogre::HardwarePixelBuffer *,int,Ogre::HardwarePixelBuffer * const *,Ogre::HardwarePixelBuffer * const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,Ogre::HardwarePixelBuffer *,int,Ogre::HardwarePixelBuffer * const *,Ogre::HardwarePixelBuffer * const &,std::_Iterator_base_aux>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Iterator_base_aux@std@@QAE@XZ	; std::_Iterator_base_aux::_Iterator_base_aux
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@PAVHardwarePixelBuffer@Ogre@@HPBQAV34@ABQAV34@V_Iterator_base_aux@2@@std@@QAE@XZ ENDP ; std::_Iterator_with_base<std::random_access_iterator_tag,Ogre::HardwarePixelBuffer *,int,Ogre::HardwarePixelBuffer * const *,Ogre::HardwarePixelBuffer * const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,Ogre::HardwarePixelBuffer *,int,Ogre::HardwarePixelBuffer * const *,Ogre::HardwarePixelBuffer * const &,std::_Iterator_base_aux>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??0_Iterator_base_aux@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_Iterator_base_aux@std@@QAE@XZ PROC			; std::_Iterator_base_aux::_Iterator_base_aux, COMDAT
; _this$ = ecx

; 448  : 	_Iterator_base_aux()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0_Iterator_base_aux@std@@QAE@XZ ENDP			; std::_Iterator_base_aux::_Iterator_base_aux
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0?$_Iterator_with_base@Ubidirectional_iterator_tag@std@@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@2@HPBU32@ABU32@V_Iterator_base_aux@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Iterator_with_base@Ubidirectional_iterator_tag@std@@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@2@HPBU32@ABU32@V_Iterator_base_aux@2@@std@@QAE@XZ PROC ; std::_Iterator_with_base<std::bidirectional_iterator_tag,std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *>,int,std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> const *,std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> const &,std::_Iterator_base_aux>::_Iterator_with_base<std::bidirectional_iterator_tag,std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *>,int,std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> const *,std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> const &,std::_Iterator_base_aux>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Iterator_base_aux@std@@QAE@XZ	; std::_Iterator_base_aux::_Iterator_base_aux
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Iterator_with_base@Ubidirectional_iterator_tag@std@@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@2@HPBU32@ABU32@V_Iterator_base_aux@2@@std@@QAE@XZ ENDP ; std::_Iterator_with_base<std::bidirectional_iterator_tag,std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *>,int,std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> const *,std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> const &,std::_Iterator_base_aux>::_Iterator_with_base<std::bidirectional_iterator_tag,std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *>,int,std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> const *,std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> const &,std::_Iterator_base_aux>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@DHPBDABDV_Iterator_base_aux@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@DHPBDABDV_Iterator_base_aux@2@@std@@QAE@XZ PROC ; std::_Iterator_with_base<std::random_access_iterator_tag,char,int,char const *,char const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,char,int,char const *,char const &,std::_Iterator_base_aux>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Iterator_base_aux@std@@QAE@XZ	; std::_Iterator_base_aux::_Iterator_base_aux
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@DHPBDABDV_Iterator_base_aux@2@@std@@QAE@XZ ENDP ; std::_Iterator_with_base<std::random_access_iterator_tag,char,int,char const *,char const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,char,int,char const *,char const &,std::_Iterator_base_aux>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@PAVSurfaceData@Ogre@@HPBQAV34@ABQAV34@V_Iterator_base_aux@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@PAVSurfaceData@Ogre@@HPBQAV34@ABQAV34@V_Iterator_base_aux@2@@std@@QAE@XZ PROC ; std::_Iterator_with_base<std::random_access_iterator_tag,Ogre::SurfaceData *,int,Ogre::SurfaceData * const *,Ogre::SurfaceData * const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,Ogre::SurfaceData *,int,Ogre::SurfaceData * const *,Ogre::SurfaceData * const &,std::_Iterator_base_aux>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Iterator_base_aux@std@@QAE@XZ	; std::_Iterator_base_aux::_Iterator_base_aux
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@PAVSurfaceData@Ogre@@HPBQAV34@ABQAV34@V_Iterator_base_aux@2@@std@@QAE@XZ ENDP ; std::_Iterator_with_base<std::random_access_iterator_tag,Ogre::SurfaceData *,int,Ogre::SurfaceData * const *,Ogre::SurfaceData * const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,Ogre::SurfaceData *,int,Ogre::SurfaceData * const *,Ogre::SurfaceData * const &,std::_Iterator_base_aux>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ?_Color@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Color@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Color, COMDAT

; 151  : 		{	// return reference to color in node

	push	ebp
	mov	ebp, esp

; 152  : 		return ((_Charref)(*_Pnode)._Color);

	mov	eax, DWORD PTR __Pnode$[ebp]
	add	eax, 20					; 00000014H

; 153  : 		}

	pop	ebp
	ret	0
?_Color@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Color
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Myval@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAU?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Myval@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAU?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Myval, COMDAT

; 181  : 		{	// return reference to value in node

	push	ebp
	mov	ebp, esp

; 182  : 		return ((_Vref)(*_Pnode)._Myval);

	mov	eax, DWORD PTR __Pnode$[ebp]
	add	eax, 12					; 0000000cH

; 183  : 		}

	pop	ebp
	ret	0
?_Myval@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAU?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Myval
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Erase@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Pnode$67138 = -4					; size = 4
__Rootnode$ = 8						; size = 4
?_Erase@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Erase, COMDAT
; _this$ = ecx

; 1166 : 		{	// free entire subtree, recursively

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1167 : 		for (_Nodeptr _Pnode = _Rootnode; !_Isnil(_Pnode); _Rootnode = _Pnode)

	mov	eax, DWORD PTR __Rootnode$[ebp]
	mov	DWORD PTR __Pnode$67138[ebp], eax
	jmp	SHORT $LN3@Erase
$LN2@Erase:
	mov	ecx, DWORD PTR __Pnode$67138[ebp]
	mov	DWORD PTR __Rootnode$[ebp], ecx
$LN3@Erase:
	mov	edx, DWORD PTR __Pnode$67138[ebp]
	push	edx
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Isnil
	add	esp, 4
	movsx	eax, BYTE PTR [eax]
	test	eax, eax
	jne	SHORT $LN4@Erase

; 1168 : 			{	// free subtrees, then node
; 1169 : 			_Erase(_Right(_Pnode));

	mov	ecx, DWORD PTR __Pnode$67138[ebp]
	push	ecx
	call	?_Right@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Right
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Erase@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Erase

; 1170 : 			_Pnode = _Left(_Pnode);

	mov	eax, DWORD PTR __Pnode$67138[ebp]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$67138[ebp], ecx

; 1171 : 			this->_Alnod.destroy(_Rootnode);	// destroy, free erased node

	mov	edx, DWORD PTR __Rootnode$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Node>::destroy

; 1172 : 			this->_Alnod.deallocate(_Rootnode, 1);

	push	1
	mov	eax, DWORD PTR __Rootnode$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Node>::deallocate

; 1173 : 			}

	jmp	SHORT $LN2@Erase
$LN4@Erase:

; 1174 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Erase@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Erase
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Lrotate@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Pnode$ = -4						; size = 4
__Wherenode$ = 8					; size = 4
?_Lrotate@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Lrotate, COMDAT
; _this$ = ecx

; 1285 : 		{	// promote right node to root of subtree

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 1286 : 		_Nodeptr _Pnode = _Right(_Wherenode);

	mov	eax, DWORD PTR __Wherenode$[ebp]
	push	eax
	call	?_Right@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$[ebp], ecx

; 1287 : 		_Right(_Wherenode) = _Left(_Pnode);

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Left@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Left
	add	esp, 4
	mov	esi, eax
	mov	eax, DWORD PTR __Wherenode$[ebp]
	push	eax
	call	?_Right@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [eax], ecx

; 1288 : 
; 1289 : 		if (!_Isnil(_Left(_Pnode)))

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Left@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Left
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Isnil
	add	esp, 4
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN5@Lrotate

; 1290 : 			_Parent(_Left(_Pnode)) = _Wherenode;

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Left@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Left
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Parent
	add	esp, 4
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	mov	DWORD PTR [eax], ecx
$LN5@Lrotate:

; 1291 : 		_Parent(_Pnode) = _Parent(_Wherenode);

	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Parent
	add	esp, 4
	mov	esi, eax
	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Parent
	add	esp, 4
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [eax], ecx

; 1292 : 
; 1293 : 		if (_Wherenode == _Root())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Root
	mov	edx, DWORD PTR __Wherenode$[ebp]
	cmp	edx, DWORD PTR [eax]
	jne	SHORT $LN4@Lrotate

; 1294 : 			_Root() = _Pnode;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Root
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax], ecx
	jmp	SHORT $LN3@Lrotate
$LN4@Lrotate:

; 1295 : 		else if (_Wherenode == _Left(_Parent(_Wherenode)))

	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jne	SHORT $LN2@Lrotate

; 1296 : 			_Left(_Parent(_Wherenode)) = _Pnode;

	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax], ecx

; 1297 : 		else

	jmp	SHORT $LN3@Lrotate
$LN2@Lrotate:

; 1298 : 			_Right(_Parent(_Wherenode)) = _Pnode;

	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Right@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax], ecx
$LN3@Lrotate:

; 1299 : 
; 1300 : 		_Left(_Pnode) = _Wherenode;

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Left@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	mov	DWORD PTR [eax], ecx

; 1301 : 		_Parent(_Wherenode) = _Pnode;

	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Parent
	add	esp, 4
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax], ecx

; 1302 : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?_Lrotate@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Lrotate
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Rrotate@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Pnode$ = -4						; size = 4
__Wherenode$ = 8					; size = 4
?_Rrotate@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Rrotate, COMDAT
; _this$ = ecx

; 1329 : 		{	// promote left node to root of subtree

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 1330 : 		_Nodeptr _Pnode = _Left(_Wherenode);

	mov	eax, DWORD PTR __Wherenode$[ebp]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$[ebp], ecx

; 1331 : 		_Left(_Wherenode) = _Right(_Pnode);

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Right@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Right
	add	esp, 4
	mov	esi, eax
	mov	eax, DWORD PTR __Wherenode$[ebp]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [eax], ecx

; 1332 : 
; 1333 : 		if (!_Isnil(_Right(_Pnode)))

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Right@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Right
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Isnil
	add	esp, 4
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN5@Rrotate

; 1334 : 			_Parent(_Right(_Pnode)) = _Wherenode;

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Right@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Right
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Parent
	add	esp, 4
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	mov	DWORD PTR [eax], ecx
$LN5@Rrotate:

; 1335 : 		_Parent(_Pnode) = _Parent(_Wherenode);

	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Parent
	add	esp, 4
	mov	esi, eax
	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Parent
	add	esp, 4
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [eax], ecx

; 1336 : 
; 1337 : 		if (_Wherenode == _Root())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Root
	mov	edx, DWORD PTR __Wherenode$[ebp]
	cmp	edx, DWORD PTR [eax]
	jne	SHORT $LN4@Rrotate

; 1338 : 			_Root() = _Pnode;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Root
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax], ecx
	jmp	SHORT $LN3@Rrotate
$LN4@Rrotate:

; 1339 : 		else if (_Wherenode == _Right(_Parent(_Wherenode)))

	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Right@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jne	SHORT $LN2@Rrotate

; 1340 : 			_Right(_Parent(_Wherenode)) = _Pnode;

	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Right@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax], ecx

; 1341 : 		else

	jmp	SHORT $LN3@Rrotate
$LN2@Rrotate:

; 1342 : 			_Left(_Parent(_Wherenode)) = _Pnode;

	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax], ecx
$LN3@Rrotate:

; 1343 : 
; 1344 : 		_Right(_Pnode) = _Wherenode;

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Right@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	mov	DWORD PTR [eax], ecx

; 1345 : 		_Parent(_Wherenode) = _Pnode;

	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Parent
	add	esp, 4
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax], ecx

; 1346 : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?_Rrotate@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Rrotate
_TEXT	ENDS
PUBLIC	??0_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@2@D@Z ; std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Node::_Node
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Buynode@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@2@D@Z$3 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Buynode@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@2@D@Z$0
__tryblocktable$?_Buynode@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@2@D@Z DD 00H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$?_Buynode@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@2@D@Z$3
__unwindtable$?_Buynode@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@2@D@Z DD 0ffffffffH
	DD	00H
	DD	00H
	DD	FLAT:__unwindfunclet$?_Buynode@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@2@D@Z$2
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$?_Buynode@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@2@D@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?_Buynode@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@2@D@Z
	DD	01H
	DD	FLAT:__tryblocktable$?_Buynode@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@2@D@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?_Buynode@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@2@D@Z
_TEXT	SEGMENT
tv86 = -36						; size = 4
_this$ = -32						; size = 4
$T73322 = -28						; size = 4
$T73321 = -24						; size = 4
__Wherenode$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Larg$ = 8						; size = 4
__Parg$ = 12						; size = 4
__Rarg$ = 16						; size = 4
__Val$ = 20						; size = 4
__Carg$ = 24						; size = 1
?_Buynode@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@2@D@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Buynode, COMDAT
; _this$ = ecx

; 1408 : 		{	// allocate a node with pointers, value, and color

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Buynode@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@2@D@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 20					; 00000014H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1409 : 		_Nodeptr _Wherenode = this->_Alnod.allocate(1);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Node>::allocate
	mov	DWORD PTR __Wherenode$[ebp], eax

; 1410 : 		_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1411 : 		new (_Wherenode) _Node(_Larg, _Parg, _Rarg, _Val, _Carg);

	mov	eax, DWORD PTR __Wherenode$[ebp]
	push	eax
	push	24					; 00000018H
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T73322[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	cmp	DWORD PTR $T73322[ebp], 0
	je	SHORT $LN4@Buynode@3
	movzx	ecx, BYTE PTR __Carg$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	eax, DWORD PTR __Rarg$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Parg$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Larg$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T73322[ebp]
	call	??0_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@2@D@Z ; std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Node::_Node
	mov	DWORD PTR tv86[ebp], eax
	jmp	SHORT $LN5@Buynode@3
$LN4@Buynode@3:
	mov	DWORD PTR tv86[ebp], 0
$LN5@Buynode@3:
	mov	eax, DWORD PTR tv86[ebp]
	mov	DWORD PTR $T73321[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+12], 0
	jmp	SHORT $LN6@Buynode@3
__catch$?_Buynode@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@2@D@Z$0:

; 1412 : 		_CATCH_ALL
; 1413 : 		this->_Alnod.deallocate(_Wherenode, 1);

	push	1
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Node>::deallocate

; 1414 : 		_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1415 : 		_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$?_Buynode@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@2@D@Z$1
	ret	0
$LN6@Buynode@3:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Buynode@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@2@D@Z$1:

; 1416 : 		return (_Wherenode);

	mov	eax, DWORD PTR __Wherenode$[ebp]
$LN3@Buynode@3:

; 1417 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Buynode@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@2@D@Z$2:
	mov	eax, DWORD PTR __Wherenode$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T73322[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$?_Buynode@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@2@D@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-40]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Buynode@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@2@D@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Buynode@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@2@D@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Buynode
PUBLIC	??$?0U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@1@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Node><std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >
PUBLIC	??0?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@QAE@U?$less@I@1@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@1@@Z ; std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0>::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0>
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@1@@Z$0
__ehfuncinfo$??0?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T73341 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Parg$ = 8						; size = 4
__Al$ = 12						; size = 1
??0?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@1@@Z PROC ; std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >, COMDAT
; _this$ = ecx

; 52   : 		{	// construct traits from _Parg and allocator from _Al

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T73341[ebp], esp
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	call	??0?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >
	mov	ecx, DWORD PTR __Parg$[ebp]
	movzx	edx, BYTE PTR [ecx]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@QAE@U?$less@I@1@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@1@@Z ; std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0>::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0>
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??$?0U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@1@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Node><std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >

; 53   : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@QAE@XZ
__ehhandler$??0?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@1@@Z ENDP ; std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >
PUBLIC	??$_Allocate@V_Aux_cont@std@@@std@@YAPAV_Aux_cont@0@IPAV10@@Z ; std::_Allocate<std::_Aux_cont>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@V_Aux_cont@std@@@std@@QAEPAV_Aux_cont@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@V_Aux_cont@std@@@std@@QAEPAV_Aux_cont@2@I@Z PROC ; std::allocator<std::_Aux_cont>::allocate, COMDAT
; _this$ = ecx

; 144  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@V_Aux_cont@std@@@std@@YAPAV_Aux_cont@0@IPAV10@@Z ; std::_Allocate<std::_Aux_cont>
	add	esp, 8

; 146  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@V_Aux_cont@std@@@std@@QAEPAV_Aux_cont@2@I@Z ENDP ; std::allocator<std::_Aux_cont>::allocate
_TEXT	ENDS
PUBLIC	??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@0@IPAU120@@Z ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Node>
; Function compile flags: /Odtp
;	COMDAT ?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@I@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Node>::allocate, COMDAT
; _this$ = ecx

; 144  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@0@IPAU120@@Z ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Node>
	add	esp, 8

; 146  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@I@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Node>::allocate
_TEXT	ENDS
PUBLIC	??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@0@@Z ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Node>
; Function compile flags: /Odtp
;	COMDAT ?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Node>::destroy, COMDAT
; _this$ = ecx

; 159  : 		{	// destroy object at _Ptr

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 160  : 		_Destroy(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@0@@Z ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Node>
	add	esp, 4

; 161  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Node>::destroy
_TEXT	ENDS
PUBLIC	??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@0@ABQAU120@@Z ; std::_Construct<std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Node *,std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Node *>
; Function compile flags: /Odtp
;	COMDAT ?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@ABQAU342@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@ABQAU342@@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Node *>::construct, COMDAT
; _this$ = ecx

; 154  : 		{	// construct object at _Ptr with value _Val

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 155  : 		_Construct(_Ptr, _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	call	??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@0@ABQAU120@@Z ; std::_Construct<std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Node *,std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Node *>
	add	esp, 8

; 156  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@ABQAU342@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Node *>::construct
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?_Make_iter@?$vector@DV?$allocator@D@std@@@std@@QBE?AV?$_Vector_iterator@DV?$allocator@D@std@@@2@V?$_Vector_const_iterator@DV?$allocator@D@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 8
?_Make_iter@?$vector@DV?$allocator@D@std@@@std@@QBE?AV?$_Vector_iterator@DV?$allocator@D@std@@@2@V?$_Vector_const_iterator@DV?$allocator@D@std@@@2@@Z PROC ; std::vector<char,std::allocator<char> >::_Make_iter, COMDAT
; _this$ = ecx

; 660  : 		{	// make iterator from const_iterator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 661  : 		return (iterator(_Where._Myptr, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp+4]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@DV?$allocator@D@std@@@std@@QAE@PADPBV_Container_base_aux@1@@Z ; std::_Vector_iterator<char,std::allocator<char> >::_Vector_iterator<char,std::allocator<char> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 662  : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?_Make_iter@?$vector@DV?$allocator@D@std@@@std@@QBE?AV?$_Vector_iterator@DV?$allocator@D@std@@@2@V?$_Vector_const_iterator@DV?$allocator@D@std@@@2@@Z ENDP ; std::vector<char,std::allocator<char> >::_Make_iter
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Make_iter@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 8
?_Make_iter@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@2@@Z PROC ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::_Make_iter, COMDAT
; _this$ = ecx

; 660  : 		{	// make iterator from const_iterator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 661  : 		return (iterator(_Where._Myptr, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp+4]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE@PAPAVSurfaceData@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::_Vector_iterator<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 662  : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?_Make_iter@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@2@@Z ENDP ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::_Make_iter
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@PAVSurfaceData@Ogre@@@std@@QBEIXZ
_TEXT	SEGMENT
tv65 = -12						; size = 4
_this$ = -8						; size = 4
__Count$ = -4						; size = 4
?max_size@?$allocator@PAVSurfaceData@Ogre@@@std@@QBEIXZ PROC ; std::allocator<Ogre::SurfaceData *>::max_size, COMDAT
; _this$ = ecx

; 164  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);

	mov	DWORD PTR __Count$[ebp], 1073741823	; 3fffffffH

; 166  : 		return (0 < _Count ? _Count : 1);

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN3@max_size
	mov	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR tv65[ebp], eax
	jmp	SHORT $LN4@max_size
$LN3@max_size:
	mov	DWORD PTR tv65[ebp], 1
$LN4@max_size:
	mov	eax, DWORD PTR tv65[ebp]

; 167  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$allocator@PAVSurfaceData@Ogre@@@std@@QBEIXZ ENDP ; std::allocator<Ogre::SurfaceData *>::max_size
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@QBEIXZ
_TEXT	SEGMENT
tv65 = -12						; size = 4
_this$ = -8						; size = 4
__Count$ = -4						; size = 4
?max_size@?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@QBEIXZ PROC ; std::allocator<Ogre::HardwarePixelBuffer *>::max_size, COMDAT
; _this$ = ecx

; 164  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);

	mov	DWORD PTR __Count$[ebp], 1073741823	; 3fffffffH

; 166  : 		return (0 < _Count ? _Count : 1);

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN3@max_size@2
	mov	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR tv65[ebp], eax
	jmp	SHORT $LN4@max_size@2
$LN3@max_size@2:
	mov	DWORD PTR tv65[ebp], 1
$LN4@max_size@2:
	mov	eax, DWORD PTR tv65[ebp]

; 167  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@QBEIXZ ENDP ; std::allocator<Ogre::HardwarePixelBuffer *>::max_size
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ?_Color@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Color@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Color, COMDAT

; 151  : 		{	// return reference to color in node

	push	ebp
	mov	ebp, esp

; 152  : 		return ((_Charref)(*_Pnode)._Color);

	mov	eax, DWORD PTR __Pnode$[ebp]
	add	eax, 20					; 00000014H

; 153  : 		}

	pop	ebp
	ret	0
?_Color@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Color
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@std@@QBEIXZ ; std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >::max_size
; Function compile flags: /Odtp
;	COMDAT ?max_size@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QBEIXZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::max_size, COMDAT
; _this$ = ecx

; 605  : 		{	// return maximum possible length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 606  : 		return (this->_Alval.max_size());

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 20					; 00000014H
	call	?max_size@?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@std@@QBEIXZ ; std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >::max_size

; 607  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QBEIXZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::max_size
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Erase@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Pnode$67229 = -4					; size = 4
__Rootnode$ = 8						; size = 4
?_Erase@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Erase, COMDAT
; _this$ = ecx

; 1166 : 		{	// free entire subtree, recursively

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 1167 : 		for (_Nodeptr _Pnode = _Rootnode; !_Isnil(_Pnode); _Rootnode = _Pnode)

	mov	eax, DWORD PTR __Rootnode$[ebp]
	mov	DWORD PTR __Pnode$67229[ebp], eax
	jmp	SHORT $LN3@Erase@2
$LN2@Erase@2:
	mov	ecx, DWORD PTR __Pnode$67229[ebp]
	mov	DWORD PTR __Rootnode$[ebp], ecx
$LN3@Erase@2:
	mov	edx, DWORD PTR __Pnode$67229[ebp]
	push	edx
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Isnil
	add	esp, 4
	movsx	eax, BYTE PTR [eax]
	test	eax, eax
	jne	SHORT $LN4@Erase@2

; 1168 : 			{	// free subtrees, then node
; 1169 : 			_Erase(_Right(_Pnode));

	mov	ecx, DWORD PTR __Pnode$67229[ebp]
	push	ecx
	call	?_Right@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Right
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Erase@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Erase

; 1170 : 			_Pnode = _Left(_Pnode);

	mov	eax, DWORD PTR __Pnode$67229[ebp]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$67229[ebp], ecx

; 1171 : 			this->_Alnod.destroy(_Rootnode);	// destroy, free erased node

	mov	edx, DWORD PTR __Rootnode$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Node>::destroy

; 1172 : 			this->_Alnod.deallocate(_Rootnode, 1);

	push	1
	mov	eax, DWORD PTR __Rootnode$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Node>::deallocate

; 1173 : 			}

	jmp	SHORT $LN2@Erase@2
$LN4@Erase@2:

; 1174 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Erase@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Erase
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Lrotate@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Pnode$ = -4						; size = 4
__Wherenode$ = 8					; size = 4
?_Lrotate@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Lrotate, COMDAT
; _this$ = ecx

; 1285 : 		{	// promote right node to root of subtree

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 1286 : 		_Nodeptr _Pnode = _Right(_Wherenode);

	mov	eax, DWORD PTR __Wherenode$[ebp]
	push	eax
	call	?_Right@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$[ebp], ecx

; 1287 : 		_Right(_Wherenode) = _Left(_Pnode);

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Left@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Left
	add	esp, 4
	mov	esi, eax
	mov	eax, DWORD PTR __Wherenode$[ebp]
	push	eax
	call	?_Right@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [eax], ecx

; 1288 : 
; 1289 : 		if (!_Isnil(_Left(_Pnode)))

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Left@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Left
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Isnil
	add	esp, 4
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN5@Lrotate@2

; 1290 : 			_Parent(_Left(_Pnode)) = _Wherenode;

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Left@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Left
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Parent
	add	esp, 4
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	mov	DWORD PTR [eax], ecx
$LN5@Lrotate@2:

; 1291 : 		_Parent(_Pnode) = _Parent(_Wherenode);

	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Parent
	add	esp, 4
	mov	esi, eax
	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Parent
	add	esp, 4
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [eax], ecx

; 1292 : 
; 1293 : 		if (_Wherenode == _Root())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Root
	mov	edx, DWORD PTR __Wherenode$[ebp]
	cmp	edx, DWORD PTR [eax]
	jne	SHORT $LN4@Lrotate@2

; 1294 : 			_Root() = _Pnode;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Root
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax], ecx
	jmp	SHORT $LN3@Lrotate@2
$LN4@Lrotate@2:

; 1295 : 		else if (_Wherenode == _Left(_Parent(_Wherenode)))

	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jne	SHORT $LN2@Lrotate@2

; 1296 : 			_Left(_Parent(_Wherenode)) = _Pnode;

	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax], ecx

; 1297 : 		else

	jmp	SHORT $LN3@Lrotate@2
$LN2@Lrotate@2:

; 1298 : 			_Right(_Parent(_Wherenode)) = _Pnode;

	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Right@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax], ecx
$LN3@Lrotate@2:

; 1299 : 
; 1300 : 		_Left(_Pnode) = _Wherenode;

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Left@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	mov	DWORD PTR [eax], ecx

; 1301 : 		_Parent(_Wherenode) = _Pnode;

	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Parent
	add	esp, 4
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax], ecx

; 1302 : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?_Lrotate@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Lrotate
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Rrotate@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Pnode$ = -4						; size = 4
__Wherenode$ = 8					; size = 4
?_Rrotate@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Rrotate, COMDAT
; _this$ = ecx

; 1329 : 		{	// promote left node to root of subtree

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 1330 : 		_Nodeptr _Pnode = _Left(_Wherenode);

	mov	eax, DWORD PTR __Wherenode$[ebp]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$[ebp], ecx

; 1331 : 		_Left(_Wherenode) = _Right(_Pnode);

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Right@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Right
	add	esp, 4
	mov	esi, eax
	mov	eax, DWORD PTR __Wherenode$[ebp]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [eax], ecx

; 1332 : 
; 1333 : 		if (!_Isnil(_Right(_Pnode)))

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Right@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Right
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Isnil
	add	esp, 4
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN5@Rrotate@2

; 1334 : 			_Parent(_Right(_Pnode)) = _Wherenode;

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Right@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Right
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Parent
	add	esp, 4
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	mov	DWORD PTR [eax], ecx
$LN5@Rrotate@2:

; 1335 : 		_Parent(_Pnode) = _Parent(_Wherenode);

	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Parent
	add	esp, 4
	mov	esi, eax
	mov	eax, DWORD PTR __Pnode$[ebp]
	push	eax
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Parent
	add	esp, 4
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [eax], ecx

; 1336 : 
; 1337 : 		if (_Wherenode == _Root())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Root
	mov	edx, DWORD PTR __Wherenode$[ebp]
	cmp	edx, DWORD PTR [eax]
	jne	SHORT $LN4@Rrotate@2

; 1338 : 			_Root() = _Pnode;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Root@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Root
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax], ecx
	jmp	SHORT $LN3@Rrotate@2
$LN4@Rrotate@2:

; 1339 : 		else if (_Wherenode == _Right(_Parent(_Wherenode)))

	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Right@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jne	SHORT $LN2@Rrotate@2

; 1340 : 			_Right(_Parent(_Wherenode)) = _Pnode;

	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Right@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax], ecx

; 1341 : 		else

	jmp	SHORT $LN3@Rrotate@2
$LN2@Rrotate@2:

; 1342 : 			_Left(_Parent(_Wherenode)) = _Pnode;

	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Parent
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Left@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Left
	add	esp, 4
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax], ecx
$LN3@Rrotate@2:

; 1343 : 
; 1344 : 		_Right(_Pnode) = _Wherenode;

	mov	edx, DWORD PTR __Pnode$[ebp]
	push	edx
	call	?_Right@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	mov	DWORD PTR [eax], ecx

; 1345 : 		_Parent(_Wherenode) = _Pnode;

	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	edx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Parent
	add	esp, 4
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax], ecx

; 1346 : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?_Rrotate@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Rrotate
_TEXT	ENDS
PUBLIC	??0_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@2@D@Z ; std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Node::_Node
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Buynode@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@2@D@Z$3 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Buynode@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@2@D@Z$0
__tryblocktable$?_Buynode@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@2@D@Z DD 00H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$?_Buynode@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@2@D@Z$3
__unwindtable$?_Buynode@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@2@D@Z DD 0ffffffffH
	DD	00H
	DD	00H
	DD	FLAT:__unwindfunclet$?_Buynode@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@2@D@Z$2
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$?_Buynode@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@2@D@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?_Buynode@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@2@D@Z
	DD	01H
	DD	FLAT:__tryblocktable$?_Buynode@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@2@D@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?_Buynode@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@2@D@Z
_TEXT	SEGMENT
tv86 = -36						; size = 4
_this$ = -32						; size = 4
$T73382 = -28						; size = 4
$T73381 = -24						; size = 4
__Wherenode$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Larg$ = 8						; size = 4
__Parg$ = 12						; size = 4
__Rarg$ = 16						; size = 4
__Val$ = 20						; size = 4
__Carg$ = 24						; size = 1
?_Buynode@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@2@D@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Buynode, COMDAT
; _this$ = ecx

; 1408 : 		{	// allocate a node with pointers, value, and color

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Buynode@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@2@D@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 20					; 00000014H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1409 : 		_Nodeptr _Wherenode = this->_Alnod.allocate(1);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Node>::allocate
	mov	DWORD PTR __Wherenode$[ebp], eax

; 1410 : 		_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1411 : 		new (_Wherenode) _Node(_Larg, _Parg, _Rarg, _Val, _Carg);

	mov	eax, DWORD PTR __Wherenode$[ebp]
	push	eax
	push	24					; 00000018H
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T73382[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	cmp	DWORD PTR $T73382[ebp], 0
	je	SHORT $LN4@Buynode@4
	movzx	ecx, BYTE PTR __Carg$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	eax, DWORD PTR __Rarg$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Parg$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Larg$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T73382[ebp]
	call	??0_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@2@D@Z ; std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Node::_Node
	mov	DWORD PTR tv86[ebp], eax
	jmp	SHORT $LN5@Buynode@4
$LN4@Buynode@4:
	mov	DWORD PTR tv86[ebp], 0
$LN5@Buynode@4:
	mov	eax, DWORD PTR tv86[ebp]
	mov	DWORD PTR $T73381[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+12], 0
	jmp	SHORT $LN6@Buynode@4
__catch$?_Buynode@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@2@D@Z$0:

; 1412 : 		_CATCH_ALL
; 1413 : 		this->_Alnod.deallocate(_Wherenode, 1);

	push	1
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Node>::deallocate

; 1414 : 		_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1415 : 		_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$?_Buynode@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@2@D@Z$1
	ret	0
$LN6@Buynode@4:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Buynode@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@2@D@Z$1:

; 1416 : 		return (_Wherenode);

	mov	eax, DWORD PTR __Wherenode$[ebp]
$LN3@Buynode@4:

; 1417 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Buynode@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@2@D@Z$2:
	mov	eax, DWORD PTR __Wherenode$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T73382[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$?_Buynode@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@2@D@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-40]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Buynode@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@2@D@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Buynode@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@2@D@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Buynode
PUBLIC	??$?0U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@1@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Node><std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >
PUBLIC	??0?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@QAE@U?$less@I@1@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@1@@Z ; std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0>::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0>
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@1@@Z$0
__ehfuncinfo$??0?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T73401 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Parg$ = 8						; size = 4
__Al$ = 12						; size = 1
??0?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@1@@Z PROC ; std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >, COMDAT
; _this$ = ecx

; 52   : 		{	// construct traits from _Parg and allocator from _Al

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T73401[ebp], esp
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	call	??0?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >
	mov	ecx, DWORD PTR __Parg$[ebp]
	movzx	edx, BYTE PTR [ecx]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@QAE@U?$less@I@1@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@1@@Z ; std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0>::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0>
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??$?0U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@1@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Node><std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >

; 53   : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@QAE@XZ
__ehhandler$??0?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@IAE@ABU?$less@I@1@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@1@@Z ENDP ; std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >
PUBLIC	??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@0@IPAU120@@Z ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Node>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@I@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Node>::allocate, COMDAT
; _this$ = ecx

; 144  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@0@IPAU120@@Z ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Node>
	add	esp, 8

; 146  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@I@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Node>::allocate
_TEXT	ENDS
PUBLIC	??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@0@@Z ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Node>
; Function compile flags: /Odtp
;	COMDAT ?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Node>::destroy, COMDAT
; _this$ = ecx

; 159  : 		{	// destroy object at _Ptr

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 160  : 		_Destroy(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@0@@Z ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Node>
	add	esp, 4

; 161  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Node>::destroy
_TEXT	ENDS
PUBLIC	??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@0@ABQAU120@@Z ; std::_Construct<std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Node *,std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Node *>
; Function compile flags: /Odtp
;	COMDAT ?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@ABQAU342@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@ABQAU342@@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Node *>::construct, COMDAT
; _this$ = ecx

; 154  : 		{	// construct object at _Ptr with value _Val

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 155  : 		_Construct(_Ptr, _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	call	??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@0@ABQAU120@@Z ; std::_Construct<std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Node *,std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Node *>
	add	esp, 8

; 156  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@ABQAU342@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Node *>::construct
_TEXT	ENDS
PUBLIC	??Y?$_Vector_const_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::operator+=
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??Y?$_Vector_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
??Y?$_Vector_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::operator+=, COMDAT
; _this$ = ecx

; 374  : 		{	// increment by integer

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 375  : 		(*(_Mybase *)this) += _Off;

	mov	eax, DWORD PTR __Off$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??Y?$_Vector_const_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::operator+=

; 376  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 377  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??Y?$_Vector_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::operator+=
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ??Fiterator@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??Fiterator@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAEAAV012@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::iterator::operator--, COMDAT
; _this$ = ecx

; 487  : 			{	// predecrement

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 488  : 			--(*(const_iterator *)this);

	mov	ecx, DWORD PTR _this$[ebp]
	call	??Fconst_iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::const_iterator::operator--

; 489  : 			return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 490  : 			}

	mov	esp, ebp
	pop	ebp
	ret	0
??Fiterator@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAEAAV012@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::iterator::operator--
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Pnode$67304 = -4					; size = 4
?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAEXXZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::const_iterator::_Dec, COMDAT
; _this$ = ecx

; 320  : 			{	// move to node with next smaller value

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 321  : 
; 322  :  #if _HAS_ITERATOR_DEBUGGING
; 323  : 			if (this->_Mycont == 0
; 324  : 				|| _Ptr == 0)
; 325  : 				{
; 326  : 				_DEBUG_ERROR("map/set iterator not decrementable");
; 327  : 				_SCL_SECURE_INVALID_ARGUMENT;
; 328  : 				}
; 329  :  #else
; 330  : 			_SCL_SECURE_VALIDATE(this->_Has_container());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Has_container@_Iterator_base_aux@std@@QBE_NXZ ; std::_Iterator_base_aux::_Has_container
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN10@Dec
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN10@Dec:

; 331  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 332  : 
; 333  : 			if (_Isnil(_Ptr))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Isnil
	add	esp, 4
	movsx	eax, BYTE PTR [eax]
	test	eax, eax
	je	SHORT $LN9@Dec

; 334  : 			{
; 335  : 				_Ptr = _Right(_Ptr);	// end() ==> rightmost

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	?_Right@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx+4], edx

; 336  :    				if (_Isnil(_Ptr))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Isnil
	add	esp, 4
	movsx	edx, BYTE PTR [eax]
	test	edx, edx
	je	SHORT $LN8@Dec

; 337  : #if _HAS_ITERATOR_DEBUGGING
; 338  : 				{
; 339  : 					_DEBUG_ERROR("map/set iterator not decrementable");
; 340  : 					_SCL_SECURE_OUT_OF_RANGE;
; 341  : 				}
; 342  : #elif _SECURE_SCL
; 343  : 				{
; 344  :     				_SCL_SECURE_OUT_OF_RANGE;

	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN8@Dec:

; 345  : 				}
; 346  : #else
; 347  : 				return;	// begin() shouldn't be incremented, don't move
; 348  : #endif
; 349  : 			}

	jmp	$LN11@Dec
$LN9@Dec:

; 350  : 			else if (!_Isnil(_Left(_Ptr)))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?_Left@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Left
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	push	edx
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Isnil
	add	esp, 4
	movsx	eax, BYTE PTR [eax]
	test	eax, eax
	jne	SHORT $LN4@Dec

; 351  : 				_Ptr = _Max(_Left(_Ptr));	// ==> largest of left subtree

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	?_Left@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Left
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Max@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Max
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 352  : 			else

	jmp	SHORT $LN11@Dec
$LN4@Dec:

; 353  : 				{	// climb looking for left subtree
; 354  : 				_Nodeptr _Pnode;
; 355  : 				while (!_Isnil(_Pnode = _Parent(_Ptr))
; 356  : 					&& _Ptr == _Left(_Pnode))

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Parent
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$67304[ebp], ecx
	mov	edx, DWORD PTR __Pnode$67304[ebp]
	push	edx
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Isnil
	add	esp, 4
	movsx	eax, BYTE PTR [eax]
	test	eax, eax
	jne	SHORT $LN3@Dec
	mov	ecx, DWORD PTR __Pnode$67304[ebp]
	push	ecx
	call	?_Left@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Left
	add	esp, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	cmp	ecx, DWORD PTR [eax]
	jne	SHORT $LN3@Dec

; 357  : 					_Ptr = _Pnode;	// ==> parent while left subtree

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Pnode$67304[ebp]
	mov	DWORD PTR [edx+4], eax
	jmp	SHORT $LN4@Dec
$LN3@Dec:

; 358  : 				if (_Isnil(_Ptr))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Isnil
	add	esp, 4
	movsx	eax, BYTE PTR [eax]
	test	eax, eax
	je	SHORT $LN2@Dec

; 359  :  #if _HAS_ITERATOR_DEBUGGING
; 360  :  					{
; 361  : 					_DEBUG_ERROR("map/set iterator not decrementable");
; 362  : 					_SCL_SECURE_OUT_OF_RANGE;
; 363  : 					}
; 364  :  #elif _SECURE_SCL
; 365  : 					{
; 366  : 					_SCL_SECURE_OUT_OF_RANGE;

	call	DWORD PTR __imp___invalid_parameter_noinfo

; 367  : 					}
; 368  :  #else
; 369  : 					return;	// begin() shouldn't be incremented, don't move
; 370  :  #endif
; 371  : 				else

	jmp	SHORT $LN11@Dec
$LN2@Dec:

; 372  : 					_Ptr = _Pnode;	// ==> parent if not head

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Pnode$67304[ebp]
	mov	DWORD PTR [ecx+4], edx
$LN11@Dec:

; 373  : 				}
; 374  : 			}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::const_iterator::_Dec
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Pnode$67320 = -4					; size = 4
?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAEXXZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::const_iterator::_Inc, COMDAT
; _this$ = ecx

; 377  : 			{	// move to node with next larger value

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 378  : 
; 379  :  #if _HAS_ITERATOR_DEBUGGING
; 380  : 			if (this->_Mycont == 0
; 381  : 				|| _Ptr == 0
; 382  : 				|| _Isnil(_Ptr))
; 383  : 				{
; 384  : 				_DEBUG_ERROR("map/set iterator not incrementable");
; 385  : 				_SCL_SECURE_OUT_OF_RANGE;
; 386  : 				}
; 387  :  #else
; 388  : 			_SCL_SECURE_VALIDATE(this->_Has_container());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Has_container@_Iterator_base_aux@std@@QBE_NXZ ; std::_Iterator_base_aux::_Has_container
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN7@Inc
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN7@Inc:

; 389  : 			if (_Isnil(_Ptr))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Isnil
	add	esp, 4
	movsx	eax, BYTE PTR [eax]
	test	eax, eax
	je	SHORT $LN6@Inc

; 390  : 				{
; 391  : 				_SCL_SECURE_OUT_OF_RANGE;

	call	DWORD PTR __imp___invalid_parameter_noinfo
	jmp	$LN8@Inc
$LN6@Inc:

; 392  : 				// end() shouldn't be incremented, don't move if _SCL_SECURE is not turned on
; 393  : 				}
; 394  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 395  : 
; 396  : 			else if (!_Isnil(_Right(_Ptr)))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	?_Right@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Right
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Isnil
	add	esp, 4
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN2@Inc

; 397  : 				_Ptr = _Min(_Right(_Ptr));	// ==> smallest of right subtree

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	?_Right@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?_Min@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Min
	add	esp, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], eax

; 398  : 			else

	jmp	SHORT $LN8@Inc
$LN2@Inc:

; 399  : 				{	// climb looking for right subtree
; 400  : 				_Nodeptr _Pnode;
; 401  : 				while (!_Isnil(_Pnode = _Parent(_Ptr))
; 402  : 					&& _Ptr == _Right(_Pnode))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Parent
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$67320[ebp], edx
	mov	eax, DWORD PTR __Pnode$67320[ebp]
	push	eax
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Isnil
	add	esp, 4
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN1@Inc
	mov	edx, DWORD PTR __Pnode$67320[ebp]
	push	edx
	call	?_Right@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, DWORD PTR [eax]
	jne	SHORT $LN1@Inc

; 403  : 					_Ptr = _Pnode;	// ==> parent while right subtree

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Pnode$67320[ebp]
	mov	DWORD PTR [eax+4], ecx
	jmp	SHORT $LN2@Inc
$LN1@Inc:

; 404  : 				_Ptr = _Pnode;	// ==> parent (head if end())

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Pnode$67320[ebp]
	mov	DWORD PTR [edx+4], eax
$LN8@Inc:

; 405  : 				}
; 406  : 			}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::const_iterator::_Inc
_TEXT	ENDS
PUBLIC	??0?$_Bidit@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@HPBU12@ABU12@@std@@QAE@XZ ; std::_Bidit<std::pair<unsigned int const ,Ogre::HardwareBufferPool *>,int,std::pair<unsigned int const ,Ogre::HardwareBufferPool *> const *,std::pair<unsigned int const ,Ogre::HardwareBufferPool *> const &>::_Bidit<std::pair<unsigned int const ,Ogre::HardwareBufferPool *>,int,std::pair<unsigned int const ,Ogre::HardwareBufferPool *> const *,std::pair<unsigned int const ,Ogre::HardwareBufferPool *> const &>
; Function compile flags: /Odtp
;	COMDAT ??0const_iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PBV12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0const_iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PBV12@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::const_iterator::const_iterator, COMDAT
; _this$ = ecx

; 234  : 			{	// construct with node pointer _Pnode

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Bidit@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@HPBU12@ABU12@@std@@QAE@XZ
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 235  : 			_SCL_SECURE_VALIDATE(_Plist != NULL);

	cmp	DWORD PTR __Plist$[ebp], 0
	jne	SHORT $LN1@const_iter@2
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN1@const_iter@2:

; 236  : 			this->_Set_container(_Plist);

	mov	edx, DWORD PTR __Plist$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Set_container@_Iterator_base_aux@std@@QAEXQBV_Container_base_aux@2@@Z ; std::_Iterator_base_aux::_Set_container

; 237  : 			}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0const_iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PBV12@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::const_iterator::const_iterator
_TEXT	ENDS
PUBLIC	?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::const_iterator::_Inc
; Function compile flags: /Odtp
;	COMDAT ??Econst_iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??Econst_iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAEAAV012@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::const_iterator::operator++, COMDAT
; _this$ = ecx

; 273  : 			{	// preincrement

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 274  : 			_Inc();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::const_iterator::_Inc

; 275  : 			return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 276  : 			}

	mov	esp, ebp
	pop	ebp
	ret	0
??Econst_iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAEAAV012@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::const_iterator::operator++
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@3@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@3@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::const_iterator::_Mynode, COMDAT
; _this$ = ecx

; 409  : 			{	// return node pointer

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 410  : 			return (_Ptr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 411  : 			}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@3@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::const_iterator::_Mynode
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@DV?$allocator@D@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<char,std::allocator<char> >::operator==
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??9?$_Vector_const_iterator@DV?$allocator@D@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@DV?$allocator@D@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<char,std::allocator<char> >::operator!=, COMDAT
; _this$ = ecx

; 215  : 		{	// test for iterator inequality

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??8?$_Vector_const_iterator@DV?$allocator@D@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<char,std::allocator<char> >::operator==
	movzx	eax, al
	neg	eax
	sbb	eax, eax
	add	eax, 1

; 217  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??9?$_Vector_const_iterator@DV?$allocator@D@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<char,std::allocator<char> >::operator!=
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::operator==
; Function compile flags: /Odtp
;	COMDAT ??9?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::operator!=, COMDAT
; _this$ = ecx

; 215  : 		{	// test for iterator inequality

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??8?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::operator==
	movzx	eax, al
	neg	eax
	sbb	eax, eax
	add	eax, 1

; 217  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??9?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::operator!=
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0?$_Vector_iterator@DV?$allocator@D@std@@@std@@QAE@PADPBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@DV?$allocator@D@std@@@std@@QAE@PADPBV_Container_base_aux@1@@Z PROC ; std::_Vector_iterator<char,std::allocator<char> >::_Vector_iterator<char,std::allocator<char> >, COMDAT
; _this$ = ecx

; 327  : 		{	// construct with pointer _Ptr

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Pvector$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_const_iterator@DV?$allocator@D@std@@@std@@QAE@PADPBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<char,std::allocator<char> >::_Vector_const_iterator<char,std::allocator<char> >

; 328  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Vector_iterator@DV?$allocator@D@std@@@std@@QAE@PADPBV_Container_base_aux@1@@Z ENDP ; std::_Vector_iterator<char,std::allocator<char> >::_Vector_iterator<char,std::allocator<char> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0?$_Vector_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE@PAPAVSurfaceData@Ogre@@PBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE@PAPAVSurfaceData@Ogre@@PBV_Container_base_aux@1@@Z PROC ; std::_Vector_iterator<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::_Vector_iterator<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >, COMDAT
; _this$ = ecx

; 327  : 		{	// construct with pointer _Ptr

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Pvector$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE@PAPAVSurfaceData@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::_Vector_const_iterator<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >

; 328  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Vector_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE@PAPAVSurfaceData@Ogre@@PBV_Container_base_aux@1@@Z ENDP ; std::_Vector_iterator<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::_Vector_iterator<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\utility
_TEXT	ENDS
;	COMDAT ??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@1@AB_N@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@1@AB_N@Z PROC ; std::pair<std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::iterator,bool>::pair<std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::iterator,bool>, COMDAT
; _this$ = ecx

; 50   : 		{	// construct from specified values

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Val1$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Val2$[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR [ecx+8], al

; 51   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@1@AB_N@Z ENDP ; std::pair<std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::iterator,bool>::pair<std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::iterator,bool>
_TEXT	ENDS
PUBLIC	??0?$_Iterator_with_base@Ubidirectional_iterator_tag@std@@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@2@HPBU32@ABU32@V_Iterator_base_aux@2@@std@@QAE@XZ ; std::_Iterator_with_base<std::bidirectional_iterator_tag,std::pair<unsigned int const ,Ogre::HardwareBufferPool *>,int,std::pair<unsigned int const ,Ogre::HardwareBufferPool *> const *,std::pair<unsigned int const ,Ogre::HardwareBufferPool *> const &,std::_Iterator_base_aux>::_Iterator_with_base<std::bidirectional_iterator_tag,std::pair<unsigned int const ,Ogre::HardwareBufferPool *>,int,std::pair<unsigned int const ,Ogre::HardwareBufferPool *> const *,std::pair<unsigned int const ,Ogre::HardwareBufferPool *> const &,std::_Iterator_base_aux>
; Function compile flags: /Odtp
;	COMDAT ??0?$_Bidit@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@HPBU12@ABU12@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Bidit@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@HPBU12@ABU12@@std@@QAE@XZ PROC ; std::_Bidit<std::pair<unsigned int const ,Ogre::HardwareBufferPool *>,int,std::pair<unsigned int const ,Ogre::HardwareBufferPool *> const *,std::pair<unsigned int const ,Ogre::HardwareBufferPool *> const &>::_Bidit<std::pair<unsigned int const ,Ogre::HardwareBufferPool *>,int,std::pair<unsigned int const ,Ogre::HardwareBufferPool *> const *,std::pair<unsigned int const ,Ogre::HardwareBufferPool *> const &>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Iterator_with_base@Ubidirectional_iterator_tag@std@@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@2@HPBU32@ABU32@V_Iterator_base_aux@2@@std@@QAE@XZ
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Bidit@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@HPBU12@ABU12@@std@@QAE@XZ ENDP ; std::_Bidit<std::pair<unsigned int const ,Ogre::HardwareBufferPool *>,int,std::pair<unsigned int const ,Ogre::HardwareBufferPool *> const *,std::pair<unsigned int const ,Ogre::HardwareBufferPool *> const &>::_Bidit<std::pair<unsigned int const ,Ogre::HardwareBufferPool *>,int,std::pair<unsigned int const ,Ogre::HardwareBufferPool *> const *,std::pair<unsigned int const ,Ogre::HardwareBufferPool *> const &>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0?$_Iterator_with_base@Ubidirectional_iterator_tag@std@@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@2@HPBU32@ABU32@V_Iterator_base_aux@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Iterator_with_base@Ubidirectional_iterator_tag@std@@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@2@HPBU32@ABU32@V_Iterator_base_aux@2@@std@@QAE@XZ PROC ; std::_Iterator_with_base<std::bidirectional_iterator_tag,std::pair<unsigned int const ,Ogre::HardwareBufferPool *>,int,std::pair<unsigned int const ,Ogre::HardwareBufferPool *> const *,std::pair<unsigned int const ,Ogre::HardwareBufferPool *> const &,std::_Iterator_base_aux>::_Iterator_with_base<std::bidirectional_iterator_tag,std::pair<unsigned int const ,Ogre::HardwareBufferPool *>,int,std::pair<unsigned int const ,Ogre::HardwareBufferPool *> const *,std::pair<unsigned int const ,Ogre::HardwareBufferPool *> const &,std::_Iterator_base_aux>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Iterator_base_aux@std@@QAE@XZ	; std::_Iterator_base_aux::_Iterator_base_aux
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Iterator_with_base@Ubidirectional_iterator_tag@std@@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@2@HPBU32@ABU32@V_Iterator_base_aux@2@@std@@QAE@XZ ENDP ; std::_Iterator_with_base<std::bidirectional_iterator_tag,std::pair<unsigned int const ,Ogre::HardwareBufferPool *>,int,std::pair<unsigned int const ,Ogre::HardwareBufferPool *> const *,std::pair<unsigned int const ,Ogre::HardwareBufferPool *> const &,std::_Iterator_base_aux>::_Iterator_with_base<std::bidirectional_iterator_tag,std::pair<unsigned int const ,Ogre::HardwareBufferPool *>,int,std::pair<unsigned int const ,Ogre::HardwareBufferPool *> const *,std::pair<unsigned int const ,Ogre::HardwareBufferPool *> const &,std::_Iterator_base_aux>
_TEXT	ENDS
PUBLIC	??0?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> > >::_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> > >
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\map
xdata$x	SEGMENT
__unwindtable$??0?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@QAE@U?$less@I@1@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@QAE@U?$less@I@1@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@1@@Z$0
__ehfuncinfo$??0?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@QAE@U?$less@I@1@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@QAE@U?$less@I@1@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@QAE@U?$less@I@1@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T73445 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Parg$ = 8						; size = 1
__Al$ = 12						; size = 1
??0?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@QAE@U?$less@I@1@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@1@@Z PROC ; std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0>::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0>, COMDAT
; _this$ = ecx

; 39   : 		{	// construct with specified comparator

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@QAE@U?$less@I@1@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T73445[ebp], esp
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	call	??0?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> > >::_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> > >
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 40   : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@QAE@U?$less@I@1@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> > >::~_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> > >
__ehhandler$??0?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@QAE@U?$less@I@1@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@QAE@U?$less@I@1@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@QAE@U?$less@I@1@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@1@@Z ENDP ; std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0>::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0>
PUBLIC	??0?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> > >::_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> > >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@QAE@U?$less@I@1@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@QAE@U?$less@I@1@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@1@@Z$0
__ehfuncinfo$??0?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@QAE@U?$less@I@1@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@QAE@U?$less@I@1@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@QAE@U?$less@I@1@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T73455 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Parg$ = 8						; size = 1
__Al$ = 12						; size = 1
??0?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@QAE@U?$less@I@1@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@1@@Z PROC ; std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0>::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0>, COMDAT
; _this$ = ecx

; 39   : 		{	// construct with specified comparator

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@QAE@U?$less@I@1@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T73455[ebp], esp
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	call	??0?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> > >::_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> > >
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 40   : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@QAE@U?$less@I@1@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> > >::~_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> > >
__ehhandler$??0?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@QAE@U?$less@I@1@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@QAE@U?$less@I@1@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@QAE@U?$less@I@1@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@1@@Z ENDP ; std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0>::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?max_size@?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
tv65 = -12						; size = 4
_this$ = -8						; size = 4
__Count$ = -4						; size = 4
?max_size@?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@std@@QBEIXZ PROC ; std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >::max_size, COMDAT
; _this$ = ecx

; 164  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);

	mov	DWORD PTR __Count$[ebp], 536870911	; 1fffffffH

; 166  : 		return (0 < _Count ? _Count : 1);

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN3@max_size@3
	mov	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR tv65[ebp], eax
	jmp	SHORT $LN4@max_size@3
$LN3@max_size@3:
	mov	DWORD PTR tv65[ebp], 1
$LN4@max_size@3:
	mov	eax, DWORD PTR tv65[ebp]

; 167  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@std@@QBEIXZ ENDP ; std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >::max_size
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ??Y?$_Vector_const_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
??Y?$_Vector_const_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::operator+=, COMDAT
; _this$ = ecx

; 159  : 		{	// increment by integer

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 160  : 		_SCL_SECURE_VALIDATE(this->_Has_container());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Has_container@_Iterator_base_aux@std@@QBE_NXZ ; std::_Iterator_base_aux::_Has_container
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN3@operator@17
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN3@operator@17:

; 161  : 		_SCL_SECURE_VALIDATE_RANGE(

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR __Off$[ebp]
	lea	esi, DWORD PTR [edx+eax*4]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getmycont@_Iterator_base_aux@std@@QBEPBV_Container_base_aux@2@XZ ; std::_Iterator_base_aux::_Getmycont
	cmp	esi, DWORD PTR [eax+16]
	ja	SHORT $LN1@operator@17
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR __Off$[ebp]
	lea	esi, DWORD PTR [edx+eax*4]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getmycont@_Iterator_base_aux@std@@QBEPBV_Container_base_aux@2@XZ ; std::_Iterator_base_aux::_Getmycont
	cmp	esi, DWORD PTR [eax+12]
	jae	SHORT $LN2@operator@17
$LN1@operator@17:

; 162  : 			_Myptr + _Off <= ((_Myvec *)(this->_Getmycont()))->_Mylast &&
; 163  : 			_Myptr + _Off >= ((_Myvec *)(this->_Getmycont()))->_Myfirst);

	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@operator@17:

; 164  : 		_Myptr += _Off;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR __Off$[ebp]
	lea	ecx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 165  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 166  : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
??Y?$_Vector_const_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::operator+=
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Pnode$67424 = -4					; size = 4
?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAEXXZ PROC ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::const_iterator::_Inc, COMDAT
; _this$ = ecx

; 377  : 			{	// move to node with next larger value

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 378  : 
; 379  :  #if _HAS_ITERATOR_DEBUGGING
; 380  : 			if (this->_Mycont == 0
; 381  : 				|| _Ptr == 0
; 382  : 				|| _Isnil(_Ptr))
; 383  : 				{
; 384  : 				_DEBUG_ERROR("map/set iterator not incrementable");
; 385  : 				_SCL_SECURE_OUT_OF_RANGE;
; 386  : 				}
; 387  :  #else
; 388  : 			_SCL_SECURE_VALIDATE(this->_Has_container());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Has_container@_Iterator_base_aux@std@@QBE_NXZ ; std::_Iterator_base_aux::_Has_container
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN7@Inc@2
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN7@Inc@2:

; 389  : 			if (_Isnil(_Ptr))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Isnil
	add	esp, 4
	movsx	eax, BYTE PTR [eax]
	test	eax, eax
	je	SHORT $LN6@Inc@2

; 390  : 				{
; 391  : 				_SCL_SECURE_OUT_OF_RANGE;

	call	DWORD PTR __imp___invalid_parameter_noinfo
	jmp	$LN8@Inc@2
$LN6@Inc@2:

; 392  : 				// end() shouldn't be incremented, don't move if _SCL_SECURE is not turned on
; 393  : 				}
; 394  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 395  : 
; 396  : 			else if (!_Isnil(_Right(_Ptr)))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	?_Right@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Right
	add	esp, 4
	mov	eax, DWORD PTR [eax]
	push	eax
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Isnil
	add	esp, 4
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN2@Inc@2

; 397  : 				_Ptr = _Min(_Right(_Ptr));	// ==> smallest of right subtree

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	?_Right@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?_Min@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Min
	add	esp, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], eax

; 398  : 			else

	jmp	SHORT $LN8@Inc@2
$LN2@Inc@2:

; 399  : 				{	// climb looking for right subtree
; 400  : 				_Nodeptr _Pnode;
; 401  : 				while (!_Isnil(_Pnode = _Parent(_Ptr))
; 402  : 					&& _Ptr == _Right(_Pnode))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	?_Parent@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Parent
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR __Pnode$67424[ebp], edx
	mov	eax, DWORD PTR __Pnode$67424[ebp]
	push	eax
	call	?_Isnil@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Isnil
	add	esp, 4
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN1@Inc@2
	mov	edx, DWORD PTR __Pnode$67424[ebp]
	push	edx
	call	?_Right@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Right
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, DWORD PTR [eax]
	jne	SHORT $LN1@Inc@2

; 403  : 					_Ptr = _Pnode;	// ==> parent while right subtree

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Pnode$67424[ebp]
	mov	DWORD PTR [eax+4], ecx
	jmp	SHORT $LN2@Inc@2
$LN1@Inc@2:

; 404  : 				_Ptr = _Pnode;	// ==> parent (head if end())

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Pnode$67424[ebp]
	mov	DWORD PTR [edx+4], eax
$LN8@Inc@2:

; 405  : 				}
; 406  : 			}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::const_iterator::_Inc
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ??8?$_Vector_const_iterator@DV?$allocator@D@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@DV?$allocator@D@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<char,std::allocator<char> >::operator==, COMDAT
; _this$ = ecx

; 203  : 		{	// test for iterator equality

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Has_container@_Iterator_base_aux@std@@QBE_NXZ ; std::_Iterator_base_aux::_Has_container
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@operator@18
	mov	ecx, DWORD PTR __Right$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Same_container@_Iterator_base_aux@std@@QBE_NABV12@@Z ; std::_Iterator_base_aux::_Same_container
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN2@operator@18
$LN1@operator@18:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@operator@18:

; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [eax+4]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+4]
	sete	al

; 212  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??8?$_Vector_const_iterator@DV?$allocator@D@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<char,std::allocator<char> >::operator==
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??8?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::operator==, COMDAT
; _this$ = ecx

; 203  : 		{	// test for iterator equality

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Has_container@_Iterator_base_aux@std@@QBE_NXZ ; std::_Iterator_base_aux::_Has_container
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@operator@19
	mov	ecx, DWORD PTR __Right$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Same_container@_Iterator_base_aux@std@@QBE_NABV12@@Z ; std::_Iterator_base_aux::_Same_container
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN2@operator@19
$LN1@operator@19:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@operator@19:

; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [eax+4]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+4]
	sete	al

; 212  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??8?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::operator==
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xtree
_TEXT	ENDS
;	COMDAT ??0_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@2@D@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Larg$ = 8						; size = 4
__Parg$ = 12						; size = 4
__Rarg$ = 16						; size = 4
__Val$ = 20						; size = 4
__Carg$ = 24						; size = 1
??0_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@2@D@Z PROC ; std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Node::_Node, COMDAT
; _this$ = ecx

; 38   : 			{	// construct a node with value

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Larg$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Parg$[ebp]
	mov	DWORD PTR [edx+4], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Rarg$[ebp]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], ecx
	mov	DWORD PTR [eax+16], edx
	mov	ecx, DWORD PTR _this$[ebp]
	mov	dl, BYTE PTR __Carg$[ebp]
	mov	BYTE PTR [ecx+20], dl
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+21], 0

; 39   : 			}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
??0_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@2@D@Z ENDP ; std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Node::_Node
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@2@D@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Larg$ = 8						; size = 4
__Parg$ = 12						; size = 4
__Rarg$ = 16						; size = 4
__Val$ = 20						; size = 4
__Carg$ = 24						; size = 1
??0_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@2@D@Z PROC ; std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Node::_Node, COMDAT
; _this$ = ecx

; 38   : 			{	// construct a node with value

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Larg$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Parg$[ebp]
	mov	DWORD PTR [edx+4], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Rarg$[ebp]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], ecx
	mov	DWORD PTR [eax+16], edx
	mov	ecx, DWORD PTR _this$[ebp]
	mov	dl, BYTE PTR __Carg$[ebp]
	mov	BYTE PTR [ecx+20], dl
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+21], 0

; 39   : 			}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
??0_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@2@D@Z ENDP ; std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Node::_Node
_TEXT	ENDS
PUBLIC	??$?0U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??0?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@1@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@1@@Z$1
__ehfuncinfo$??0?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@1@@Z
_TEXT	SEGMENT
tv133 = -32						; size = 4
_this$ = -28						; size = 4
$T73483 = -24						; size = 4
$T73482 = -20						; size = 4
$T73481 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 1
??0?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@1@@Z PROC ; std::_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> > >::_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> > >, COMDAT
; _this$ = ecx

; 419  : 		{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 20					; 00000014H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::_Container_base_aux
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??$?0U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >

; 420  : 		_Myownedaux = new (_Alaux.allocate(1)) _Aux_cont(this);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?allocate@?$allocator@V_Aux_cont@std@@@std@@QAEPAV_Aux_cont@2@I@Z ; std::allocator<std::_Aux_cont>::allocate
	mov	DWORD PTR $T73483[ebp], eax
	mov	ecx, DWORD PTR $T73483[ebp]
	push	ecx
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T73482[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	cmp	DWORD PTR $T73482[ebp], 0
	je	SHORT $LN3@Container_@4
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T73482[ebp]
	call	??0_Aux_cont@std@@QAE@QBV_Container_base_aux@1@@Z ; std::_Aux_cont::_Aux_cont
	mov	DWORD PTR tv133[ebp], eax
	jmp	SHORT $LN4@Container_@4
$LN3@Container_@4:
	mov	DWORD PTR tv133[ebp], 0
$LN4@Container_@4:
	mov	eax, DWORD PTR tv133[ebp]
	mov	DWORD PTR $T73481[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T73481[ebp]
	mov	DWORD PTR [ecx], edx

; 421  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@1@@Z$1:
	mov	eax, DWORD PTR $T73483[ebp]
	push	eax
	mov	ecx, DWORD PTR $T73482[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??0?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@1@@Z ENDP ; std::_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> > >::_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> > >
PUBLIC	??$?0U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@1@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@1@@Z$1
__ehfuncinfo$??0?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@1@@Z
_TEXT	SEGMENT
tv133 = -32						; size = 4
_this$ = -28						; size = 4
$T73498 = -24						; size = 4
$T73497 = -20						; size = 4
$T73496 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 1
??0?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@1@@Z PROC ; std::_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> > >::_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> > >, COMDAT
; _this$ = ecx

; 419  : 		{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 20					; 00000014H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::_Container_base_aux
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??$?0U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >

; 420  : 		_Myownedaux = new (_Alaux.allocate(1)) _Aux_cont(this);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?allocate@?$allocator@V_Aux_cont@std@@@std@@QAEPAV_Aux_cont@2@I@Z ; std::allocator<std::_Aux_cont>::allocate
	mov	DWORD PTR $T73498[ebp], eax
	mov	ecx, DWORD PTR $T73498[ebp]
	push	ecx
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T73497[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	cmp	DWORD PTR $T73497[ebp], 0
	je	SHORT $LN3@Container_@5
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T73497[ebp]
	call	??0_Aux_cont@std@@QAE@QBV_Container_base_aux@1@@Z ; std::_Aux_cont::_Aux_cont
	mov	DWORD PTR tv133[ebp], eax
	jmp	SHORT $LN4@Container_@5
$LN3@Container_@5:
	mov	DWORD PTR tv133[ebp], 0
$LN4@Container_@5:
	mov	eax, DWORD PTR tv133[ebp]
	mov	DWORD PTR $T73496[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T73496[ebp]
	mov	DWORD PTR [ecx], edx

; 421  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@1@@Z$1:
	mov	eax, DWORD PTR $T73498[ebp]
	push	eax
	mov	ecx, DWORD PTR $T73497[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??0?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Container_base_aux_alloc_real@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@std@@@std@@IAE@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@1@@Z ENDP ; std::_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> > >::_Container_base_aux_alloc_real<std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> > >
PUBLIC	??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@DV?$allocator@D@std@@@std@@PADV?$allocator@D@2@@stdext@@YAPADV?$_Vector_const_iterator@DV?$allocator@D@std@@@std@@0PADAAV?$allocator@D@2@@Z ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<char,std::allocator<char> >,char *,std::allocator<char> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??$_Ucopy@V?$_Vector_const_iterator@DV?$allocator@D@std@@@std@@@?$vector@DV?$allocator@D@std@@@std@@IAEPADV?$_Vector_const_iterator@DV?$allocator@D@std@@@1@0PAD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 8
__Last$ = 16						; size = 8
__Ptr$ = 24						; size = 4
??$_Ucopy@V?$_Vector_const_iterator@DV?$allocator@D@std@@@std@@@?$vector@DV?$allocator@D@std@@@std@@IAEPADV?$_Vector_const_iterator@DV?$allocator@D@std@@@1@0PAD@Z PROC ; std::vector<char,std::allocator<char> >::_Ucopy<std::_Vector_const_iterator<char,std::allocator<char> > >, COMDAT
; _this$ = ecx

; 1138 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1139 : 		{	// copy initializing [_First, _Last), using allocator
; 1140 : 		return (_STDEXT unchecked_uninitialized_copy(_First, _Last,
; 1141 : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp+4]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@DV?$allocator@D@std@@@std@@PADV?$allocator@D@2@@stdext@@YAPADV?$_Vector_const_iterator@DV?$allocator@D@std@@@std@@0PADAAV?$allocator@D@2@@Z ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<char,std::allocator<char> >,char *,std::allocator<char> >
	add	esp, 24					; 00000018H

; 1142 : 		}

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
??$_Ucopy@V?$_Vector_const_iterator@DV?$allocator@D@std@@@std@@@?$vector@DV?$allocator@D@std@@@std@@IAEPADV?$_Vector_const_iterator@DV?$allocator@D@std@@@1@0PAD@Z ENDP ; std::vector<char,std::allocator<char> >::_Ucopy<std::_Vector_const_iterator<char,std::allocator<char> > >
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PADPADUrandom_access_iterator_tag@std@@@std@@YAPADPAD00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<char *,char *,std::random_access_iterator_tag>
PUBLIC	??$_Checked_base@PAD@std@@YAPADAAPAD@Z		; std::_Checked_base<char *>
PUBLIC	??$_Iter_random@PADPAD@std@@YA?AUrandom_access_iterator_tag@0@ABQAD0@Z ; std::_Iter_random<char *,char *>
PUBLIC	??$_Ptr_cat@PADPAD@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAD0@Z ; std::_Ptr_cat<char *,char *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$unchecked_copy@PADPAD@stdext@@YAPADPAD00@Z
_TEXT	SEGMENT
$T73515 = -3						; size = 1
$T73514 = -2						; size = 1
$T73513 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PADPAD@stdext@@YAPADPAD00@Z PROC	; stdext::unchecked_copy<char *,char *>, COMDAT

; 3604 : 	{	// copy [_First, _Last) to [_Dest, ...)

	push	ebp
	mov	ebp, esp
	push	ecx

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T73513[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PADPAD@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAD0@Z ; std::_Ptr_cat<char *,char *>
	add	esp, 8
	mov	BYTE PTR $T73514[ebp], al
	movzx	eax, BYTE PTR $T73513[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T73514[ebp]
	push	ecx
	lea	edx, DWORD PTR __Dest$[ebp]
	push	edx
	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T73515[ebp]
	push	ecx
	call	??$_Iter_random@PADPAD@std@@YA?AUrandom_access_iterator_tag@0@ABQAD0@Z ; std::_Iter_random<char *,char *>
	add	esp, 12					; 0000000cH
	movzx	edx, BYTE PTR [eax]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@PAD@std@@YAPADAAPAD@Z	; std::_Checked_base<char *>
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@PAD@std@@YAPADAAPAD@Z	; std::_Checked_base<char *>
	add	esp, 4
	push	eax
	call	??$_Copy_opt@PADPADUrandom_access_iterator_tag@std@@@std@@YAPADPAD00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<char *,char *,std::random_access_iterator_tag>
	add	esp, 24					; 00000018H

; 3607 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_copy@PADPAD@stdext@@YAPADPAD00@Z ENDP	; stdext::unchecked_copy<char *,char *>
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@PADPADV?$allocator@D@std@@@stdext@@YAPADPAD00AAV?$allocator@D@std@@@Z ; stdext::unchecked_uninitialized_copy<char *,char *,std::allocator<char> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??$_Ucopy@PAD@?$vector@DV?$allocator@D@std@@@std@@IAEPADPAD00@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Ucopy@PAD@?$vector@DV?$allocator@D@std@@@std@@IAEPADPAD00@Z PROC ; std::vector<char,std::allocator<char> >::_Ucopy<char *>, COMDAT
; _this$ = ecx

; 1138 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1139 : 		{	// copy initializing [_First, _Last), using allocator
; 1140 : 		return (_STDEXT unchecked_uninitialized_copy(_First, _Last,
; 1141 : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$unchecked_uninitialized_copy@PADPADV?$allocator@D@std@@@stdext@@YAPADPAD00AAV?$allocator@D@std@@@Z ; stdext::unchecked_uninitialized_copy<char *,char *,std::allocator<char> >
	add	esp, 16					; 00000010H

; 1142 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??$_Ucopy@PAD@?$vector@DV?$allocator@D@std@@@std@@IAEPADPAD00@Z ENDP ; std::vector<char,std::allocator<char> >::_Ucopy<char *>
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@PAPAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@2@@stdext@@YAPAPAVSurfaceData@Ogre@@V?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@0PAPAV12@AAV?$allocator@PAVSurfaceData@Ogre@@@4@@Z ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >,Ogre::SurfaceData * *,std::allocator<Ogre::SurfaceData *> >
; Function compile flags: /Odtp
;	COMDAT ??$_Ucopy@V?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAEPAPAVSurfaceData@Ogre@@V?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@1@0PAPAV23@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 8
__Last$ = 16						; size = 8
__Ptr$ = 24						; size = 4
??$_Ucopy@V?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAEPAPAVSurfaceData@Ogre@@V?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@1@0PAPAV23@@Z PROC ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::_Ucopy<std::_Vector_const_iterator<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> > >, COMDAT
; _this$ = ecx

; 1138 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1139 : 		{	// copy initializing [_First, _Last), using allocator
; 1140 : 		return (_STDEXT unchecked_uninitialized_copy(_First, _Last,
; 1141 : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp+4]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@PAPAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@2@@stdext@@YAPAPAVSurfaceData@Ogre@@V?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@0PAPAV12@AAV?$allocator@PAVSurfaceData@Ogre@@@4@@Z ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >,Ogre::SurfaceData * *,std::allocator<Ogre::SurfaceData *> >
	add	esp, 24					; 00000018H

; 1142 : 		}

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
??$_Ucopy@V?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAEPAPAVSurfaceData@Ogre@@V?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@1@0PAPAV23@@Z ENDP ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::_Ucopy<std::_Vector_const_iterator<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> > >
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAPAVSurfaceData@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@@std@@YAPAPAVSurfaceData@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<Ogre::SurfaceData * *,Ogre::SurfaceData * *,std::random_access_iterator_tag>
PUBLIC	??$_Checked_base@PAPAVSurfaceData@Ogre@@@std@@YAPAPAVSurfaceData@Ogre@@AAPAPAV12@@Z ; std::_Checked_base<Ogre::SurfaceData * *>
PUBLIC	??$_Iter_random@PAPAVSurfaceData@Ogre@@PAPAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVSurfaceData@Ogre@@0@Z ; std::_Iter_random<Ogre::SurfaceData * *,Ogre::SurfaceData * *>
PUBLIC	??$_Ptr_cat@PAPAVSurfaceData@Ogre@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVSurfaceData@Ogre@@0@Z ; std::_Ptr_cat<Ogre::SurfaceData * *,Ogre::SurfaceData * *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$unchecked_copy@PAPAVSurfaceData@Ogre@@PAPAV12@@stdext@@YAPAPAVSurfaceData@Ogre@@PAPAV12@00@Z
_TEXT	SEGMENT
$T73524 = -3						; size = 1
$T73523 = -2						; size = 1
$T73522 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAPAVSurfaceData@Ogre@@PAPAV12@@stdext@@YAPAPAVSurfaceData@Ogre@@PAPAV12@00@Z PROC ; stdext::unchecked_copy<Ogre::SurfaceData * *,Ogre::SurfaceData * *>, COMDAT

; 3604 : 	{	// copy [_First, _Last) to [_Dest, ...)

	push	ebp
	mov	ebp, esp
	push	ecx

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T73522[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAPAVSurfaceData@Ogre@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVSurfaceData@Ogre@@0@Z ; std::_Ptr_cat<Ogre::SurfaceData * *,Ogre::SurfaceData * *>
	add	esp, 8
	mov	BYTE PTR $T73523[ebp], al
	movzx	eax, BYTE PTR $T73522[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T73523[ebp]
	push	ecx
	lea	edx, DWORD PTR __Dest$[ebp]
	push	edx
	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T73524[ebp]
	push	ecx
	call	??$_Iter_random@PAPAVSurfaceData@Ogre@@PAPAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVSurfaceData@Ogre@@0@Z ; std::_Iter_random<Ogre::SurfaceData * *,Ogre::SurfaceData * *>
	add	esp, 12					; 0000000cH
	movzx	edx, BYTE PTR [eax]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@PAPAVSurfaceData@Ogre@@@std@@YAPAPAVSurfaceData@Ogre@@AAPAPAV12@@Z ; std::_Checked_base<Ogre::SurfaceData * *>
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@PAPAVSurfaceData@Ogre@@@std@@YAPAPAVSurfaceData@Ogre@@AAPAPAV12@@Z ; std::_Checked_base<Ogre::SurfaceData * *>
	add	esp, 4
	push	eax
	call	??$_Copy_opt@PAPAVSurfaceData@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@@std@@YAPAPAVSurfaceData@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<Ogre::SurfaceData * *,Ogre::SurfaceData * *,std::random_access_iterator_tag>
	add	esp, 24					; 00000018H

; 3607 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_copy@PAPAVSurfaceData@Ogre@@PAPAV12@@stdext@@YAPAPAVSurfaceData@Ogre@@PAPAV12@00@Z ENDP ; stdext::unchecked_copy<Ogre::SurfaceData * *,Ogre::SurfaceData * *>
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@PAPAVSurfaceData@Ogre@@PAPAV12@V?$allocator@PAVSurfaceData@Ogre@@@std@@@stdext@@YAPAPAVSurfaceData@Ogre@@PAPAV12@00AAV?$allocator@PAVSurfaceData@Ogre@@@std@@@Z ; stdext::unchecked_uninitialized_copy<Ogre::SurfaceData * *,Ogre::SurfaceData * *,std::allocator<Ogre::SurfaceData *> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??$_Ucopy@PAPAVSurfaceData@Ogre@@@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAEPAPAVSurfaceData@Ogre@@PAPAV23@00@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Ucopy@PAPAVSurfaceData@Ogre@@@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAEPAPAVSurfaceData@Ogre@@PAPAV23@00@Z PROC ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::_Ucopy<Ogre::SurfaceData * *>, COMDAT
; _this$ = ecx

; 1138 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1139 : 		{	// copy initializing [_First, _Last), using allocator
; 1140 : 		return (_STDEXT unchecked_uninitialized_copy(_First, _Last,
; 1141 : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$unchecked_uninitialized_copy@PAPAVSurfaceData@Ogre@@PAPAV12@V?$allocator@PAVSurfaceData@Ogre@@@std@@@stdext@@YAPAPAVSurfaceData@Ogre@@PAPAV12@00AAV?$allocator@PAVSurfaceData@Ogre@@@std@@@Z ; stdext::unchecked_uninitialized_copy<Ogre::SurfaceData * *,Ogre::SurfaceData * *,std::allocator<Ogre::SurfaceData *> >
	add	esp, 16					; 00000010H

; 1142 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??$_Ucopy@PAPAVSurfaceData@Ogre@@@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAEPAPAVSurfaceData@Ogre@@PAPAV23@00@Z ENDP ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::_Ucopy<Ogre::SurfaceData * *>
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@PAPAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@2@@stdext@@YAPAPAVHardwarePixelBuffer@Ogre@@V?$_Vector_const_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@0PAPAV12@AAV?$allocator@PAVHardwarePixelBuffer@Ogre@@@4@@Z ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >,Ogre::HardwarePixelBuffer * *,std::allocator<Ogre::HardwarePixelBuffer *> >
; Function compile flags: /Odtp
;	COMDAT ??$_Ucopy@V?$_Vector_const_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@IAEPAPAVHardwarePixelBuffer@Ogre@@V?$_Vector_const_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@1@0PAPAV23@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 8
__Last$ = 16						; size = 8
__Ptr$ = 24						; size = 4
??$_Ucopy@V?$_Vector_const_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@IAEPAPAVHardwarePixelBuffer@Ogre@@V?$_Vector_const_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@1@0PAPAV23@@Z PROC ; std::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::_Ucopy<std::_Vector_const_iterator<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> > >, COMDAT
; _this$ = ecx

; 1138 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1139 : 		{	// copy initializing [_First, _Last), using allocator
; 1140 : 		return (_STDEXT unchecked_uninitialized_copy(_First, _Last,
; 1141 : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp+4]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@PAPAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@2@@stdext@@YAPAPAVHardwarePixelBuffer@Ogre@@V?$_Vector_const_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@0PAPAV12@AAV?$allocator@PAVHardwarePixelBuffer@Ogre@@@4@@Z ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >,Ogre::HardwarePixelBuffer * *,std::allocator<Ogre::HardwarePixelBuffer *> >
	add	esp, 24					; 00000018H

; 1142 : 		}

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
??$_Ucopy@V?$_Vector_const_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@IAEPAPAVHardwarePixelBuffer@Ogre@@V?$_Vector_const_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@1@0PAPAV23@@Z ENDP ; std::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::_Ucopy<std::_Vector_const_iterator<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> > >
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAPAVHardwarePixelBuffer@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@@std@@YAPAPAVHardwarePixelBuffer@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<Ogre::HardwarePixelBuffer * *,Ogre::HardwarePixelBuffer * *,std::random_access_iterator_tag>
PUBLIC	??$_Checked_base@PAPAVHardwarePixelBuffer@Ogre@@@std@@YAPAPAVHardwarePixelBuffer@Ogre@@AAPAPAV12@@Z ; std::_Checked_base<Ogre::HardwarePixelBuffer * *>
PUBLIC	??$_Iter_random@PAPAVHardwarePixelBuffer@Ogre@@PAPAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVHardwarePixelBuffer@Ogre@@0@Z ; std::_Iter_random<Ogre::HardwarePixelBuffer * *,Ogre::HardwarePixelBuffer * *>
PUBLIC	??$_Ptr_cat@PAPAVHardwarePixelBuffer@Ogre@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVHardwarePixelBuffer@Ogre@@0@Z ; std::_Ptr_cat<Ogre::HardwarePixelBuffer * *,Ogre::HardwarePixelBuffer * *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$unchecked_copy@PAPAVHardwarePixelBuffer@Ogre@@PAPAV12@@stdext@@YAPAPAVHardwarePixelBuffer@Ogre@@PAPAV12@00@Z
_TEXT	SEGMENT
$T73533 = -3						; size = 1
$T73532 = -2						; size = 1
$T73531 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAPAVHardwarePixelBuffer@Ogre@@PAPAV12@@stdext@@YAPAPAVHardwarePixelBuffer@Ogre@@PAPAV12@00@Z PROC ; stdext::unchecked_copy<Ogre::HardwarePixelBuffer * *,Ogre::HardwarePixelBuffer * *>, COMDAT

; 3604 : 	{	// copy [_First, _Last) to [_Dest, ...)

	push	ebp
	mov	ebp, esp
	push	ecx

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T73531[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAPAVHardwarePixelBuffer@Ogre@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVHardwarePixelBuffer@Ogre@@0@Z ; std::_Ptr_cat<Ogre::HardwarePixelBuffer * *,Ogre::HardwarePixelBuffer * *>
	add	esp, 8
	mov	BYTE PTR $T73532[ebp], al
	movzx	eax, BYTE PTR $T73531[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T73532[ebp]
	push	ecx
	lea	edx, DWORD PTR __Dest$[ebp]
	push	edx
	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T73533[ebp]
	push	ecx
	call	??$_Iter_random@PAPAVHardwarePixelBuffer@Ogre@@PAPAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVHardwarePixelBuffer@Ogre@@0@Z ; std::_Iter_random<Ogre::HardwarePixelBuffer * *,Ogre::HardwarePixelBuffer * *>
	add	esp, 12					; 0000000cH
	movzx	edx, BYTE PTR [eax]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@PAPAVHardwarePixelBuffer@Ogre@@@std@@YAPAPAVHardwarePixelBuffer@Ogre@@AAPAPAV12@@Z ; std::_Checked_base<Ogre::HardwarePixelBuffer * *>
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@PAPAVHardwarePixelBuffer@Ogre@@@std@@YAPAPAVHardwarePixelBuffer@Ogre@@AAPAPAV12@@Z ; std::_Checked_base<Ogre::HardwarePixelBuffer * *>
	add	esp, 4
	push	eax
	call	??$_Copy_opt@PAPAVHardwarePixelBuffer@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@@std@@YAPAPAVHardwarePixelBuffer@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<Ogre::HardwarePixelBuffer * *,Ogre::HardwarePixelBuffer * *,std::random_access_iterator_tag>
	add	esp, 24					; 00000018H

; 3607 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_copy@PAPAVHardwarePixelBuffer@Ogre@@PAPAV12@@stdext@@YAPAPAVHardwarePixelBuffer@Ogre@@PAPAV12@00@Z ENDP ; stdext::unchecked_copy<Ogre::HardwarePixelBuffer * *,Ogre::HardwarePixelBuffer * *>
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@PAPAVHardwarePixelBuffer@Ogre@@PAPAV12@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@stdext@@YAPAPAVHardwarePixelBuffer@Ogre@@PAPAV12@00AAV?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@Z ; stdext::unchecked_uninitialized_copy<Ogre::HardwarePixelBuffer * *,Ogre::HardwarePixelBuffer * *,std::allocator<Ogre::HardwarePixelBuffer *> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??$_Ucopy@PAPAVHardwarePixelBuffer@Ogre@@@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@IAEPAPAVHardwarePixelBuffer@Ogre@@PAPAV23@00@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Ucopy@PAPAVHardwarePixelBuffer@Ogre@@@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@IAEPAPAVHardwarePixelBuffer@Ogre@@PAPAV23@00@Z PROC ; std::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::_Ucopy<Ogre::HardwarePixelBuffer * *>, COMDAT
; _this$ = ecx

; 1138 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1139 : 		{	// copy initializing [_First, _Last), using allocator
; 1140 : 		return (_STDEXT unchecked_uninitialized_copy(_First, _Last,
; 1141 : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$unchecked_uninitialized_copy@PAPAVHardwarePixelBuffer@Ogre@@PAPAV12@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@stdext@@YAPAPAVHardwarePixelBuffer@Ogre@@PAPAV12@00AAV?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@Z ; stdext::unchecked_uninitialized_copy<Ogre::HardwarePixelBuffer * *,Ogre::HardwarePixelBuffer * *,std::allocator<Ogre::HardwarePixelBuffer *> >
	add	esp, 16					; 00000010H

; 1142 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??$_Ucopy@PAPAVHardwarePixelBuffer@Ogre@@@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@IAEPAPAVHardwarePixelBuffer@Ogre@@PAPAV23@00@Z ENDP ; std::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::_Ucopy<Ogre::HardwarePixelBuffer * *>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@D@std@@@std@@YAXPAD0AAV?$allocator@D@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<char> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@D@std@@@std@@YAXPAD0AAV?$allocator@D@0@@Z
_TEXT	SEGMENT
$T73538 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@D@std@@@std@@YAXPAD0AAV?$allocator@D@0@@Z PROC ; std::_Destroy_range<std::allocator<char> >, COMDAT

; 224  : 	{	// destroy [_First, _Last)

	push	ebp
	mov	ebp, esp
	push	ecx

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Ptr_cat@PADPAD@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAD0@Z ; std::_Ptr_cat<char *,char *>
	add	esp, 8
	mov	BYTE PTR $T73538[ebp], al
	movzx	edx, BYTE PTR $T73538[ebp]
	push	edx
	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Destroy_range@V?$allocator@D@std@@@std@@YAXPAD0AAV?$allocator@D@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<char> >
	add	esp, 16					; 00000010H

; 226  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Destroy_range@V?$allocator@D@std@@@std@@YAXPAD0AAV?$allocator@D@0@@Z ENDP ; std::_Destroy_range<std::allocator<char> >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@YAXPAPAVSurfaceData@Ogre@@0AAV?$allocator@PAVSurfaceData@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<Ogre::SurfaceData *> >
; Function compile flags: /Odtp
;	COMDAT ??$_Destroy_range@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@YAXPAPAVSurfaceData@Ogre@@0AAV?$allocator@PAVSurfaceData@Ogre@@@0@@Z
_TEXT	SEGMENT
$T73541 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@YAXPAPAVSurfaceData@Ogre@@0AAV?$allocator@PAVSurfaceData@Ogre@@@0@@Z PROC ; std::_Destroy_range<std::allocator<Ogre::SurfaceData *> >, COMDAT

; 224  : 	{	// destroy [_First, _Last)

	push	ebp
	mov	ebp, esp
	push	ecx

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Ptr_cat@PAPAVSurfaceData@Ogre@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVSurfaceData@Ogre@@0@Z ; std::_Ptr_cat<Ogre::SurfaceData * *,Ogre::SurfaceData * *>
	add	esp, 8
	mov	BYTE PTR $T73541[ebp], al
	movzx	edx, BYTE PTR $T73541[ebp]
	push	edx
	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Destroy_range@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@YAXPAPAVSurfaceData@Ogre@@0AAV?$allocator@PAVSurfaceData@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<Ogre::SurfaceData *> >
	add	esp, 16					; 00000010H

; 226  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Destroy_range@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@YAXPAPAVSurfaceData@Ogre@@0AAV?$allocator@PAVSurfaceData@Ogre@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<Ogre::SurfaceData *> >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@YAXPAPAVHardwarePixelBuffer@Ogre@@0AAV?$allocator@PAVHardwarePixelBuffer@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<Ogre::HardwarePixelBuffer *> >
; Function compile flags: /Odtp
;	COMDAT ??$_Destroy_range@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@YAXPAPAVHardwarePixelBuffer@Ogre@@0AAV?$allocator@PAVHardwarePixelBuffer@Ogre@@@0@@Z
_TEXT	SEGMENT
$T73544 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@YAXPAPAVHardwarePixelBuffer@Ogre@@0AAV?$allocator@PAVHardwarePixelBuffer@Ogre@@@0@@Z PROC ; std::_Destroy_range<std::allocator<Ogre::HardwarePixelBuffer *> >, COMDAT

; 224  : 	{	// destroy [_First, _Last)

	push	ebp
	mov	ebp, esp
	push	ecx

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Ptr_cat@PAPAVHardwarePixelBuffer@Ogre@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVHardwarePixelBuffer@Ogre@@0@Z ; std::_Ptr_cat<Ogre::HardwarePixelBuffer * *,Ogre::HardwarePixelBuffer * *>
	add	esp, 8
	mov	BYTE PTR $T73544[ebp], al
	movzx	edx, BYTE PTR $T73544[ebp]
	push	edx
	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Destroy_range@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@YAXPAPAVHardwarePixelBuffer@Ogre@@0AAV?$allocator@PAVHardwarePixelBuffer@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<Ogre::HardwarePixelBuffer *> >
	add	esp, 16					; 00000010H

; 226  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Destroy_range@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@YAXPAPAVHardwarePixelBuffer@Ogre@@0AAV?$allocator@PAVHardwarePixelBuffer@Ogre@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<Ogre::HardwarePixelBuffer *> >
_TEXT	ENDS
PUBLIC	??$_Uninit_fill_n@PAPAVHardwarePixelBuffer@Ogre@@IPAV12@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@YAXPAPAVHardwarePixelBuffer@Ogre@@IABQAV12@AAV?$allocator@PAVHardwarePixelBuffer@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<Ogre::HardwarePixelBuffer * *,unsigned int,Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_fill_n@PAPAVHardwarePixelBuffer@Ogre@@IPAV12@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@stdext@@YAXPAPAVHardwarePixelBuffer@Ogre@@IABQAV12@AAV?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@Z
_TEXT	SEGMENT
$T73548 = -2						; size = 1
$T73547 = -1						; size = 1
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_fill_n@PAPAVHardwarePixelBuffer@Ogre@@IPAV12@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@stdext@@YAXPAPAVHardwarePixelBuffer@Ogre@@IABQAV12@AAV?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@Z PROC ; stdext::unchecked_uninitialized_fill_n<Ogre::HardwarePixelBuffer * *,unsigned int,Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >, COMDAT

; 940  : 	{	// copy _Count *_Val to raw _First, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 941  : 	_STD _Uninit_fill_n(_First, _Count, _Val, _Al,
; 942  : 		_STD _Ptr_cat(_First, _First), _STD _Range_checked_iterator_tag());

	xor	eax, eax
	mov	BYTE PTR $T73547[ebp], al
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAPAVHardwarePixelBuffer@Ogre@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVHardwarePixelBuffer@Ogre@@0@Z ; std::_Ptr_cat<Ogre::HardwarePixelBuffer * *,Ogre::HardwarePixelBuffer * *>
	add	esp, 8
	mov	BYTE PTR $T73548[ebp], al
	movzx	eax, BYTE PTR $T73547[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T73548[ebp]
	push	ecx
	mov	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Uninit_fill_n@PAPAVHardwarePixelBuffer@Ogre@@IPAV12@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@YAXPAPAVHardwarePixelBuffer@Ogre@@IABQAV12@AAV?$allocator@PAVHardwarePixelBuffer@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<Ogre::HardwarePixelBuffer * *,unsigned int,Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >
	add	esp, 24					; 00000018H

; 943  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_fill_n@PAPAVHardwarePixelBuffer@Ogre@@IPAV12@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@stdext@@YAXPAPAVHardwarePixelBuffer@Ogre@@IABQAV12@AAV?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_fill_n<Ogre::HardwarePixelBuffer * *,unsigned int,Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\utility
_TEXT	ENDS
;	COMDAT ??$swap@D@std@@YAXAAD0@Z
_TEXT	SEGMENT
__Tmp$68383 = -1					; size = 1
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$swap@D@std@@YAXAAD0@Z PROC				; std::swap<char>, COMDAT

; 17   : 	{	// exchange values stored at _Left and _Right

	push	ebp
	mov	ebp, esp
	push	ecx

; 18   : 	if (&_Left != &_Right)

	mov	eax, DWORD PTR __Left$[ebp]
	cmp	eax, DWORD PTR __Right$[ebp]
	je	SHORT $LN2@swap

; 19   : 		{	// different, worth swapping
; 20   : 		_Ty _Tmp = _Left;

	mov	ecx, DWORD PTR __Left$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR __Tmp$68383[ebp], dl

; 21   : 
; 22   : 		_Left = _Right;

	mov	eax, DWORD PTR __Left$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl

; 23   : 		_Right = _Tmp;

	mov	eax, DWORD PTR __Right$[ebp]
	mov	cl, BYTE PTR __Tmp$68383[ebp]
	mov	BYTE PTR [eax], cl
$LN2@swap:

; 24   : 		}
; 25   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$swap@D@std@@YAXAAD0@Z ENDP				; std::swap<char>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$?0U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??$?0U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@1@@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Node *>::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Node *><std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >, COMDAT
; _this$ = ecx

; 128  : 		allocator(const allocator<_Other>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@1@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Node *>::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Node *><std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@0@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@0@@Z PROC ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Node *>, COMDAT

; 58   : 	{	// destroy object at _Ptr

	push	ebp
	mov	ebp, esp

; 59   : 	_DESTRUCTOR(_Ty, _Ptr);
; 60   : 	}

	pop	ebp
	ret	0
??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@0@@Z ENDP ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Node *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$?0D@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@D@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??$?0D@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@D@1@@Z PROC ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><char>, COMDAT
; _this$ = ecx

; 128  : 		allocator(const allocator<_Other>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0D@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@D@1@@Z ENDP ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><char>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$?0PAVSurfaceData@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@PAVSurfaceData@Ogre@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??$?0PAVSurfaceData@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@PAVSurfaceData@Ogre@@@1@@Z PROC ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::SurfaceData *>, COMDAT
; _this$ = ecx

; 128  : 		allocator(const allocator<_Other>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0PAVSurfaceData@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@PAVSurfaceData@Ogre@@@1@@Z ENDP ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::SurfaceData *>
_TEXT	ENDS
PUBLIC	__TI2?AVbad_alloc@std@@
PUBLIC	??0bad_alloc@std@@QAE@PBD@Z			; std::bad_alloc::bad_alloc
PUBLIC	??1bad_alloc@std@@UAE@XZ			; std::bad_alloc::~bad_alloc
PUBLIC	__CTA2?AVbad_alloc@std@@
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
EXTRN	??2@YAPAXI@Z:PROC				; operator new
;	COMDAT ??_R0?AVbad_alloc@std@@@8
_DATA	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_alloc@std@@
xdata$x	SEGMENT
__CTA2?AVbad_alloc@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI2?AVbad_alloc@std@@
xdata$x	SEGMENT
__TI2?AVbad_alloc@std@@ DD 00H
	DD	FLAT:??1bad_alloc@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVbad_alloc@std@@
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??$_Allocate@PAVSurfaceData@Ogre@@@std@@YAPAPAVSurfaceData@Ogre@@IPAPAV12@@Z
_TEXT	SEGMENT
$T73561 = -12						; size = 12
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@PAVSurfaceData@Ogre@@@std@@YAPAPAVSurfaceData@Ogre@@IPAPAV12@@Z PROC ; std::_Allocate<Ogre::SurfaceData *>, COMDAT

; 36   : 	{	// check for integer overflow

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 37   : 	if (_Count <= 0)

	cmp	DWORD PTR __Count$[ebp], 0
	ja	SHORT $LN3@Allocate

; 38   : 		_Count = 0;

	mov	DWORD PTR __Count$[ebp], 0
	jmp	SHORT $LN2@Allocate
$LN3@Allocate:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Count$[ebp]
	cmp	eax, 4
	jae	SHORT $LN2@Allocate

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	push	0
	lea	ecx, DWORD PTR $T73561[ebp]
	call	??0bad_alloc@std@@QAE@PBD@Z		; std::bad_alloc::bad_alloc
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	eax, DWORD PTR $T73561[ebp]
	push	eax
	call	__CxxThrowException@8
$LN2@Allocate:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 2
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
$LN5@Allocate:

; 44   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@PAVSurfaceData@Ogre@@@std@@YAPAPAVSurfaceData@Ogre@@IPAPAV12@@Z ENDP ; std::_Allocate<Ogre::SurfaceData *>
_TEXT	ENDS
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	__imp_??0exception@std@@QAE@ABQBD@Z:PROC
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	?what@exception@std@@UBEPBDXZ:PROC		; std::exception::what
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0bad_alloc@std@@QAE@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0bad_alloc@std@@QAE@PBD@Z$0
__ehfuncinfo$??0bad_alloc@std@@QAE@PBD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0bad_alloc@std@@QAE@PBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@PBD@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Message$ = 8						; size = 4
??0bad_alloc@std@@QAE@PBD@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx

; 371  : 		{	// construct from message string

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0bad_alloc@std@@QAE@PBD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	lea	eax, DWORD PTR __Message$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7bad_alloc@std@@6B@

; 372  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0bad_alloc@std@@QAE@PBD@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??0bad_alloc@std@@QAE@PBD@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0bad_alloc@std@@QAE@PBD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0bad_alloc@std@@QAE@PBD@Z ENDP			; std::bad_alloc::bad_alloc
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1bad_alloc@std@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1bad_alloc@std@@UAE@XZ$0
__ehfuncinfo$??1bad_alloc@std@@UAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1bad_alloc@std@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1bad_alloc@std@@UAE@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
; _this$ = ecx

; 380  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1bad_alloc@std@@UAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 381  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1bad_alloc@std@@UAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??1bad_alloc@std@@UAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1bad_alloc@std@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1bad_alloc@std@@UAE@XZ ENDP				; std::bad_alloc::~bad_alloc
; Function compile flags: /Odtp
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1bad_alloc@std@@UAE@XZ		; std::bad_alloc::~bad_alloc
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@21
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@21:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??$_Unchecked_uninitialized_move@PAPAVHardwarePixelBuffer@Ogre@@PAPAV12@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@stdext@@YAPAPAVHardwarePixelBuffer@Ogre@@PAPAV12@00AAV?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@Z ; stdext::_Unchecked_uninitialized_move<Ogre::HardwarePixelBuffer * *,Ogre::HardwarePixelBuffer * *,std::allocator<Ogre::HardwarePixelBuffer *> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??$_Umove@PAPAVHardwarePixelBuffer@Ogre@@@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@IAEPAPAVHardwarePixelBuffer@Ogre@@PAPAV23@00@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Umove@PAPAVHardwarePixelBuffer@Ogre@@@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@IAEPAPAVHardwarePixelBuffer@Ogre@@PAPAV23@00@Z PROC ; std::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::_Umove<Ogre::HardwarePixelBuffer * *>, COMDAT
; _this$ = ecx

; 1145 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1146 : 		{	// move initializing [_First, _Last), using allocator
; 1147 : 		return (_STDEXT _Unchecked_uninitialized_move(_First, _Last,
; 1148 : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Unchecked_uninitialized_move@PAPAVHardwarePixelBuffer@Ogre@@PAPAV12@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@stdext@@YAPAPAVHardwarePixelBuffer@Ogre@@PAPAV12@00AAV?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@Z ; stdext::_Unchecked_uninitialized_move<Ogre::HardwarePixelBuffer * *,Ogre::HardwarePixelBuffer * *,std::allocator<Ogre::HardwarePixelBuffer *> >
	add	esp, 16					; 00000010H

; 1149 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??$_Umove@PAPAVHardwarePixelBuffer@Ogre@@@?$vector@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@IAEPAPAVHardwarePixelBuffer@Ogre@@PAPAV23@00@Z ENDP ; std::vector<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::_Umove<Ogre::HardwarePixelBuffer * *>
_TEXT	ENDS
PUBLIC	??$_Fill@PAPAVHardwarePixelBuffer@Ogre@@PAV12@@std@@YAXPAPAVHardwarePixelBuffer@Ogre@@0ABQAV12@@Z ; std::_Fill<Ogre::HardwarePixelBuffer * *,Ogre::HardwarePixelBuffer *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$fill@PAPAVHardwarePixelBuffer@Ogre@@PAV12@@std@@YAXPAPAVHardwarePixelBuffer@Ogre@@0ABQAV12@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$fill@PAPAVHardwarePixelBuffer@Ogre@@PAV12@@std@@YAXPAPAVHardwarePixelBuffer@Ogre@@0ABQAV12@@Z PROC ; std::fill<Ogre::HardwarePixelBuffer * *,Ogre::HardwarePixelBuffer *>, COMDAT

; 3186 : 	{	// copy _Val through [_First, _Last)

	push	ebp
	mov	ebp, esp

; 3187 : 	_Fill(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@PAPAVHardwarePixelBuffer@Ogre@@@std@@YAPAPAVHardwarePixelBuffer@Ogre@@AAPAPAV12@@Z ; std::_Checked_base<Ogre::HardwarePixelBuffer * *>
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@PAPAVHardwarePixelBuffer@Ogre@@@std@@YAPAPAVHardwarePixelBuffer@Ogre@@AAPAPAV12@@Z ; std::_Checked_base<Ogre::HardwarePixelBuffer * *>
	add	esp, 4
	push	eax
	call	??$_Fill@PAPAVHardwarePixelBuffer@Ogre@@PAV12@@std@@YAXPAPAVHardwarePixelBuffer@Ogre@@0ABQAV12@@Z ; std::_Fill<Ogre::HardwarePixelBuffer * *,Ogre::HardwarePixelBuffer *>
	add	esp, 12					; 0000000cH

; 3188 : 	}

	pop	ebp
	ret	0
??$fill@PAPAVHardwarePixelBuffer@Ogre@@PAV12@@std@@YAXPAPAVHardwarePixelBuffer@Ogre@@0ABQAV12@@Z ENDP ; std::fill<Ogre::HardwarePixelBuffer * *,Ogre::HardwarePixelBuffer *>
_TEXT	ENDS
PUBLIC	??$_Move_backward_opt@PAPAVHardwarePixelBuffer@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@4@@std@@YAPAPAVHardwarePixelBuffer@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Move_backward_opt<Ogre::HardwarePixelBuffer * *,Ogre::HardwarePixelBuffer * *,std::random_access_iterator_tag,std::_Undefined_move_tag>
PUBLIC	??$_Move_cat@PAPAVHardwarePixelBuffer@Ogre@@@std@@YA?AU_Undefined_move_tag@0@ABQAPAVHardwarePixelBuffer@Ogre@@@Z ; std::_Move_cat<Ogre::HardwarePixelBuffer * *>
; Function compile flags: /Odtp
;	COMDAT ??$_Unchecked_move_backward@PAPAVHardwarePixelBuffer@Ogre@@PAPAV12@@stdext@@YAPAPAVHardwarePixelBuffer@Ogre@@PAPAV12@00@Z
_TEXT	SEGMENT
$T73590 = -3						; size = 1
$T73589 = -2						; size = 1
$T73588 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Unchecked_move_backward@PAPAVHardwarePixelBuffer@Ogre@@PAPAV12@@stdext@@YAPAPAVHardwarePixelBuffer@Ogre@@PAPAV12@00@Z PROC ; stdext::_Unchecked_move_backward<Ogre::HardwarePixelBuffer * *,Ogre::HardwarePixelBuffer * *>, COMDAT

; 3694 : 	{	// move [_First, _Last) backwards to [..., _Dest)

	push	ebp
	mov	ebp, esp
	push	ecx

; 3695 : 		return (_STD _Move_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3696 : 			_STD _Iter_random(_First, _Dest), _STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T73588[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	??$_Move_cat@PAPAVHardwarePixelBuffer@Ogre@@@std@@YA?AU_Undefined_move_tag@0@ABQAPAVHardwarePixelBuffer@Ogre@@@Z ; std::_Move_cat<Ogre::HardwarePixelBuffer * *>
	add	esp, 4
	mov	BYTE PTR $T73589[ebp], al
	movzx	edx, BYTE PTR $T73588[ebp]
	push	edx
	movzx	eax, BYTE PTR $T73589[ebp]
	push	eax
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	lea	eax, DWORD PTR $T73590[ebp]
	push	eax
	call	??$_Iter_random@PAPAVHardwarePixelBuffer@Ogre@@PAPAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVHardwarePixelBuffer@Ogre@@0@Z ; std::_Iter_random<Ogre::HardwarePixelBuffer * *,Ogre::HardwarePixelBuffer * *>
	add	esp, 12					; 0000000cH
	movzx	ecx, BYTE PTR [eax]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	call	??$_Checked_base@PAPAVHardwarePixelBuffer@Ogre@@@std@@YAPAPAVHardwarePixelBuffer@Ogre@@AAPAPAV12@@Z ; std::_Checked_base<Ogre::HardwarePixelBuffer * *>
	add	esp, 4
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Checked_base@PAPAVHardwarePixelBuffer@Ogre@@@std@@YAPAPAVHardwarePixelBuffer@Ogre@@AAPAPAV12@@Z ; std::_Checked_base<Ogre::HardwarePixelBuffer * *>
	add	esp, 4
	push	eax
	call	??$_Move_backward_opt@PAPAVHardwarePixelBuffer@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@4@@std@@YAPAPAVHardwarePixelBuffer@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Move_backward_opt<Ogre::HardwarePixelBuffer * *,Ogre::HardwarePixelBuffer * *,std::random_access_iterator_tag,std::_Undefined_move_tag>
	add	esp, 24					; 00000018H

; 3697 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Unchecked_move_backward@PAPAVHardwarePixelBuffer@Ogre@@PAPAV12@@stdext@@YAPAPAVHardwarePixelBuffer@Ogre@@PAPAV12@00@Z ENDP ; stdext::_Unchecked_move_backward<Ogre::HardwarePixelBuffer * *,Ogre::HardwarePixelBuffer * *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$?0PAVHardwarePixelBuffer@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@PAVHardwarePixelBuffer@Ogre@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??$?0PAVHardwarePixelBuffer@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@PAVHardwarePixelBuffer@Ogre@@@1@@Z PROC ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::HardwarePixelBuffer *>, COMDAT
; _this$ = ecx

; 128  : 		allocator(const allocator<_Other>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0PAVHardwarePixelBuffer@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@PAVHardwarePixelBuffer@Ogre@@@1@@Z ENDP ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::HardwarePixelBuffer *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Allocate@PAVHardwarePixelBuffer@Ogre@@@std@@YAPAPAVHardwarePixelBuffer@Ogre@@IPAPAV12@@Z
_TEXT	SEGMENT
$T73595 = -12						; size = 12
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@PAVHardwarePixelBuffer@Ogre@@@std@@YAPAPAVHardwarePixelBuffer@Ogre@@IPAPAV12@@Z PROC ; std::_Allocate<Ogre::HardwarePixelBuffer *>, COMDAT

; 36   : 	{	// check for integer overflow

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 37   : 	if (_Count <= 0)

	cmp	DWORD PTR __Count$[ebp], 0
	ja	SHORT $LN3@Allocate@2

; 38   : 		_Count = 0;

	mov	DWORD PTR __Count$[ebp], 0
	jmp	SHORT $LN2@Allocate@2
$LN3@Allocate@2:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Count$[ebp]
	cmp	eax, 4
	jae	SHORT $LN2@Allocate@2

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	push	0
	lea	ecx, DWORD PTR $T73595[ebp]
	call	??0bad_alloc@std@@QAE@PBD@Z		; std::bad_alloc::bad_alloc
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	eax, DWORD PTR $T73595[ebp]
	push	eax
	call	__CxxThrowException@8
$LN2@Allocate@2:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 2
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
$LN5@Allocate@2:

; 44   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@PAVHardwarePixelBuffer@Ogre@@@std@@YAPAPAVHardwarePixelBuffer@Ogre@@IPAPAV12@@Z ENDP ; std::_Allocate<Ogre::HardwarePixelBuffer *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$?0U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??$?0U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@1@@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Node *>::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Node *><std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >, COMDAT
; _this$ = ecx

; 128  : 		allocator(const allocator<_Other>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@1@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Node *>::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Node *><std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@0@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@0@@Z PROC ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Node *>, COMDAT

; 58   : 	{	// destroy object at _Ptr

	push	ebp
	mov	ebp, esp

; 59   : 	_DESTRUCTOR(_Ty, _Ptr);
; 60   : 	}

	pop	ebp
	ret	0
??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@0@@Z ENDP ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Node *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$?0U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??$?0U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@1@@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Node><std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >, COMDAT
; _this$ = ecx

; 128  : 		allocator(const allocator<_Other>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@1@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Node><std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Allocate@V_Aux_cont@std@@@std@@YAPAV_Aux_cont@0@IPAV10@@Z
_TEXT	SEGMENT
$T73604 = -12						; size = 12
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@V_Aux_cont@std@@@std@@YAPAV_Aux_cont@0@IPAV10@@Z PROC ; std::_Allocate<std::_Aux_cont>, COMDAT

; 36   : 	{	// check for integer overflow

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 37   : 	if (_Count <= 0)

	cmp	DWORD PTR __Count$[ebp], 0
	ja	SHORT $LN3@Allocate@3

; 38   : 		_Count = 0;

	mov	DWORD PTR __Count$[ebp], 0
	jmp	SHORT $LN2@Allocate@3
$LN3@Allocate@3:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Count$[ebp]
	cmp	eax, 4
	jae	SHORT $LN2@Allocate@3

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	push	0
	lea	ecx, DWORD PTR $T73604[ebp]
	call	??0bad_alloc@std@@QAE@PBD@Z		; std::bad_alloc::bad_alloc
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	eax, DWORD PTR $T73604[ebp]
	push	eax
	call	__CxxThrowException@8
$LN2@Allocate@3:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 2
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
$LN5@Allocate@3:

; 44   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@V_Aux_cont@std@@@std@@YAPAV_Aux_cont@0@IPAV10@@Z ENDP ; std::_Allocate<std::_Aux_cont>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@0@IPAU120@@Z
_TEXT	SEGMENT
$T73607 = -12						; size = 12
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@0@IPAU120@@Z PROC ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Node>, COMDAT

; 36   : 	{	// check for integer overflow

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 37   : 	if (_Count <= 0)

	cmp	DWORD PTR __Count$[ebp], 0
	ja	SHORT $LN3@Allocate@4

; 38   : 		_Count = 0;

	mov	DWORD PTR __Count$[ebp], 0
	jmp	SHORT $LN2@Allocate@4
$LN3@Allocate@4:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Count$[ebp]
	cmp	eax, 24					; 00000018H
	jae	SHORT $LN2@Allocate@4

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	push	0
	lea	ecx, DWORD PTR $T73607[ebp]
	call	??0bad_alloc@std@@QAE@PBD@Z		; std::bad_alloc::bad_alloc
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	eax, DWORD PTR $T73607[ebp]
	push	eax
	call	__CxxThrowException@8
$LN2@Allocate@4:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	mov	ecx, DWORD PTR __Count$[ebp]
	imul	ecx, 24					; 00000018H
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
$LN5@Allocate@4:

; 44   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@0@IPAU120@@Z ENDP ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Node>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@0@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@0@@Z PROC ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Node>, COMDAT

; 58   : 	{	// destroy object at _Ptr

	push	ebp
	mov	ebp, esp

; 59   : 	_DESTRUCTOR(_Ty, _Ptr);
; 60   : 	}

	pop	ebp
	ret	0
??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@0@@Z ENDP ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Node>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@0@ABQAU120@@Z
_TEXT	SEGMENT
tv68 = -12						; size = 4
$T73612 = -8						; size = 4
__Vptr$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@0@ABQAU120@@Z PROC ; std::_Construct<std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Node *,std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Node *>, COMDAT

; 50   : 	{	// construct object at _Ptr with value _Val

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 51   : 	void _FARQ *_Vptr = _Ptr;

	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR __Vptr$[ebp], eax

; 52   : 	::new (_Vptr) _T1(_Val);

	mov	ecx, DWORD PTR __Vptr$[ebp]
	push	ecx
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T73612[ebp], eax
	cmp	DWORD PTR $T73612[ebp], 0
	je	SHORT $LN3@Construct
	mov	edx, DWORD PTR $T73612[ebp]
	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR $T73612[ebp]
	mov	DWORD PTR tv68[ebp], edx
	jmp	SHORT $LN1@Construct
$LN3@Construct:
	mov	DWORD PTR tv68[ebp], 0
$LN1@Construct:

; 53   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwareBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@4@$0A@@std@@@0@ABQAU120@@Z ENDP ; std::_Construct<std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Node *,std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::HardwareBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >,0> >::_Node *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$?0U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??$?0U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@1@@Z PROC ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Node><std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >, COMDAT
; _this$ = ecx

; 128  : 		allocator(const allocator<_Other>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@1@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Node><std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@0@IPAU120@@Z
_TEXT	SEGMENT
$T73619 = -12						; size = 12
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@0@IPAU120@@Z PROC ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Node>, COMDAT

; 36   : 	{	// check for integer overflow

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 37   : 	if (_Count <= 0)

	cmp	DWORD PTR __Count$[ebp], 0
	ja	SHORT $LN3@Allocate@5

; 38   : 		_Count = 0;

	mov	DWORD PTR __Count$[ebp], 0
	jmp	SHORT $LN2@Allocate@5
$LN3@Allocate@5:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Count$[ebp]
	cmp	eax, 24					; 00000018H
	jae	SHORT $LN2@Allocate@5

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	push	0
	lea	ecx, DWORD PTR $T73619[ebp]
	call	??0bad_alloc@std@@QAE@PBD@Z		; std::bad_alloc::bad_alloc
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	eax, DWORD PTR $T73619[ebp]
	push	eax
	call	__CxxThrowException@8
$LN2@Allocate@5:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	mov	ecx, DWORD PTR __Count$[ebp]
	imul	ecx, 24					; 00000018H
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
$LN5@Allocate@5:

; 44   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@0@IPAU120@@Z ENDP ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Node>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@0@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@0@@Z PROC ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Node>, COMDAT

; 58   : 	{	// destroy object at _Ptr

	push	ebp
	mov	ebp, esp

; 59   : 	_DESTRUCTOR(_Ty, _Ptr);
; 60   : 	}

	pop	ebp
	ret	0
??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@0@@Z ENDP ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Node>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@0@ABQAU120@@Z
_TEXT	SEGMENT
tv68 = -12						; size = 4
$T73624 = -8						; size = 4
__Vptr$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@0@ABQAU120@@Z PROC ; std::_Construct<std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Node *,std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Node *>, COMDAT

; 50   : 	{	// construct object at _Ptr with value _Val

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 51   : 	void _FARQ *_Vptr = _Ptr;

	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR __Vptr$[ebp], eax

; 52   : 	::new (_Vptr) _T1(_Val);

	mov	ecx, DWORD PTR __Vptr$[ebp]
	push	ecx
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T73624[ebp], eax
	cmp	DWORD PTR $T73624[ebp], 0
	je	SHORT $LN3@Construct@2
	mov	edx, DWORD PTR $T73624[ebp]
	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR $T73624[ebp]
	mov	DWORD PTR tv68[ebp], edx
	jmp	SHORT $LN1@Construct@2
$LN3@Construct@2:
	mov	DWORD PTR tv68[ebp], 0
$LN1@Construct@2:

; 53   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@IPAVHardwarePixelBufferPool@Ogre@@U?$less@I@std@@V?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@4@$0A@@std@@@0@ABQAU120@@Z ENDP ; std::_Construct<std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Node *,std::_Tree_nod<std::_Tmap_traits<unsigned int,Ogre::HardwarePixelBufferPool *,std::less<unsigned int>,std::allocator<std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >,0> >::_Node *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$?0U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??$?0U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@1@@Z PROC ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >, COMDAT
; _this$ = ecx

; 128  : 		allocator(const allocator<_Other>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBIPAVHardwareBufferPool@Ogre@@@std@@@1@@Z ENDP ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><std::pair<unsigned int const ,Ogre::HardwareBufferPool *> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$?0U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??$?0U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@1@@Z PROC ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >, COMDAT
; _this$ = ecx

; 128  : 		allocator(const allocator<_Other>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBIPAVHardwarePixelBufferPool@Ogre@@@std@@@1@@Z ENDP ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><std::pair<unsigned int const ,Ogre::HardwarePixelBufferPool *> >
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0bad_alloc@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0bad_alloc@std@@QAE@ABV01@@Z$0
__ehfuncinfo$??0bad_alloc@std@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0bad_alloc@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0bad_alloc@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7bad_alloc@std@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0bad_alloc@std@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??0bad_alloc@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0bad_alloc@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
PUBLIC	??$_Uninit_copy@PBDPADV?$allocator@D@std@@@std@@YAPADPBD0PADAAV?$allocator@D@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<char const *,char *,std::allocator<char> >
PUBLIC	??$_Checked_base@V?$_Vector_const_iterator@DV?$allocator@D@std@@@std@@@std@@YAPBDAAV?$_Vector_const_iterator@DV?$allocator@D@std@@@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<char,std::allocator<char> > >
PUBLIC	??$_Ptr_cat@V?$_Vector_const_iterator@DV?$allocator@D@std@@@std@@PAD@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@DV?$allocator@D@std@@@0@AAPAD@Z ; std::_Ptr_cat<std::_Vector_const_iterator<char,std::allocator<char> >,char *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@DV?$allocator@D@std@@@std@@PADV?$allocator@D@2@@stdext@@YAPADV?$_Vector_const_iterator@DV?$allocator@D@std@@@std@@0PADAAV?$allocator@D@2@@Z
_TEXT	SEGMENT
$T73643 = -2						; size = 1
$T73642 = -1						; size = 1
__First$ = 8						; size = 8
__Last$ = 16						; size = 8
__Dest$ = 24						; size = 4
__Al$ = 28						; size = 4
??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@DV?$allocator@D@std@@@std@@PADV?$allocator@D@2@@stdext@@YAPADV?$_Vector_const_iterator@DV?$allocator@D@std@@@std@@0PADAAV?$allocator@D@2@@Z PROC ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<char,std::allocator<char> >,char *,std::allocator<char> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T73642[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@V?$_Vector_const_iterator@DV?$allocator@D@std@@@std@@PAD@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@DV?$allocator@D@std@@@0@AAPAD@Z ; std::_Ptr_cat<std::_Vector_const_iterator<char,std::allocator<char> >,char *>
	add	esp, 8
	mov	BYTE PTR $T73643[ebp], al
	movzx	eax, BYTE PTR $T73642[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T73643[ebp]
	push	ecx
	mov	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@V?$_Vector_const_iterator@DV?$allocator@D@std@@@std@@@std@@YAPBDAAV?$_Vector_const_iterator@DV?$allocator@D@std@@@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<char,std::allocator<char> > >
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@V?$_Vector_const_iterator@DV?$allocator@D@std@@@std@@@std@@YAPBDAAV?$_Vector_const_iterator@DV?$allocator@D@std@@@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<char,std::allocator<char> > >
	add	esp, 4
	push	eax
	call	??$_Uninit_copy@PBDPADV?$allocator@D@std@@@std@@YAPADPBD0PADAAV?$allocator@D@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<char const *,char *,std::allocator<char> >
	add	esp, 24					; 00000018H

; 823  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@DV?$allocator@D@std@@@std@@PADV?$allocator@D@2@@stdext@@YAPADV?$_Vector_const_iterator@DV?$allocator@D@std@@@std@@0PADAAV?$allocator@D@2@@Z ENDP ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<char,std::allocator<char> >,char *,std::allocator<char> >
_TEXT	ENDS
PUBLIC	??$_Checked_base@PAD@std@@YAPADAAPADU_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<char *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Checked_base@PAD@std@@YAPADAAPAD@Z
_TEXT	SEGMENT
__Base_tag$ = -1					; size = 1
__It$ = 8						; size = 4
??$_Checked_base@PAD@std@@YAPADAAPAD@Z PROC		; std::_Checked_base<char *>, COMDAT

; 1163 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1164 : 		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
; 1165 : 		return _Checked_base(_It, _Base_tag);

	movzx	eax, BYTE PTR __Base_tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR __It$[ebp]
	push	ecx
	call	??$_Checked_base@PAD@std@@YAPADAAPADU_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<char *>
	add	esp, 8

; 1166 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Checked_base@PAD@std@@YAPADAAPAD@Z ENDP		; std::_Checked_base<char *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Iter_random@PADPAD@std@@YA?AUrandom_access_iterator_tag@0@ABQAD0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PADPAD@std@@YA?AUrandom_access_iterator_tag@0@ABQAD0@Z PROC ; std::_Iter_random<char *,char *>, COMDAT

; 993  : 	{	// return category from iterator argument

	push	ebp
	mov	ebp, esp
	push	ecx

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 998  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Iter_random@PADPAD@std@@YA?AUrandom_access_iterator_tag@0@ABQAD0@Z ENDP ; std::_Iter_random<char *,char *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PADPAD@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAD0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PADPAD@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAD0@Z PROC ; std::_Ptr_cat<char *,char *>, COMDAT

; 1509 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 1512 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Ptr_cat@PADPAD@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAD0@Z ENDP ; std::_Ptr_cat<char *,char *>
_TEXT	ENDS
EXTRN	__imp__memmove_s:PROC
; Function compile flags: /Odtp
;	COMDAT ??$_Copy_opt@PADPADUrandom_access_iterator_tag@std@@@std@@YAPADPAD00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Off$ = -8						; size = 4
__Result$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PADPADUrandom_access_iterator_tag@std@@@std@@YAPADPAD00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<char *,char *,std::random_access_iterator_tag>, COMDAT

; 2494 : 	{	// copy [_First, _Last) to [_Dest, ...), pointers to scalars

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 2495 : 
; 2496 :  #if _HAS_ITERATOR_DEBUGGING
; 2497 : 	_DEBUG_RANGE(_First, _Last);
; 2498 : 	if (_First != _Last)
; 2499 : 		_DEBUG_POINTER(_Dest);
; 2500 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2501 : 
; 2502 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Off$[ebp], eax

; 2503 : 	// if _OutIt is range checked, this will make sure there is enough space for the memmove
; 2504 : 	_OutIt _Result = _Dest + _Off;

	mov	ecx, DWORD PTR __Dest$[ebp]
	add	ecx, DWORD PTR __Off$[ebp]
	mov	DWORD PTR __Result$[ebp], ecx

; 2505 : 	if (_Off > 0)

	cmp	DWORD PTR __Off$[ebp], 0
	jle	SHORT $LN1@Copy_opt

; 2506 : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Off * sizeof (*_First), &*_First, _Off * sizeof (*_First));

	mov	edx, DWORD PTR __Off$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Off$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN1@Copy_opt:

; 2507 : 	return _Result;

	mov	eax, DWORD PTR __Result$[ebp]

; 2508 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Copy_opt@PADPADUrandom_access_iterator_tag@std@@@std@@YAPADPAD00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<char *,char *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PADPADV?$allocator@D@std@@@std@@YAPADPAD00AAV?$allocator@D@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<char *,char *,std::allocator<char> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_copy@PADPADV?$allocator@D@std@@@stdext@@YAPADPAD00AAV?$allocator@D@std@@@Z
_TEXT	SEGMENT
$T73655 = -2						; size = 1
$T73654 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@PADPADV?$allocator@D@std@@@stdext@@YAPADPAD00AAV?$allocator@D@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<char *,char *,std::allocator<char> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T73654[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PADPAD@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAD0@Z ; std::_Ptr_cat<char *,char *>
	add	esp, 8
	mov	BYTE PTR $T73655[ebp], al
	movzx	eax, BYTE PTR $T73654[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T73655[ebp]
	push	ecx
	mov	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@PAD@std@@YAPADAAPAD@Z	; std::_Checked_base<char *>
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@PAD@std@@YAPADAAPAD@Z	; std::_Checked_base<char *>
	add	esp, 4
	push	eax
	call	??$_Uninit_copy@PADPADV?$allocator@D@std@@@std@@YAPADPAD00AAV?$allocator@D@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<char *,char *,std::allocator<char> >
	add	esp, 24					; 00000018H

; 823  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_copy@PADPADV?$allocator@D@std@@@stdext@@YAPADPAD00AAV?$allocator@D@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<char *,char *,std::allocator<char> >
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PBQAVSurfaceData@Ogre@@PAPAV12@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@YAPAPAVSurfaceData@Ogre@@PBQAV12@0PAPAV12@AAV?$allocator@PAVSurfaceData@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Ogre::SurfaceData * const *,Ogre::SurfaceData * *,std::allocator<Ogre::SurfaceData *> >
PUBLIC	??$_Checked_base@V?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@@std@@YAPBQAVSurfaceData@Ogre@@AAV?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> > >
PUBLIC	??$_Ptr_cat@V?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@PAPAVSurfaceData@Ogre@@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@0@AAPAPAVSurfaceData@Ogre@@@Z ; std::_Ptr_cat<std::_Vector_const_iterator<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >,Ogre::SurfaceData * *>
; Function compile flags: /Odtp
;	COMDAT ??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@PAPAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@2@@stdext@@YAPAPAVSurfaceData@Ogre@@V?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@0PAPAV12@AAV?$allocator@PAVSurfaceData@Ogre@@@4@@Z
_TEXT	SEGMENT
$T73659 = -2						; size = 1
$T73658 = -1						; size = 1
__First$ = 8						; size = 8
__Last$ = 16						; size = 8
__Dest$ = 24						; size = 4
__Al$ = 28						; size = 4
??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@PAPAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@2@@stdext@@YAPAPAVSurfaceData@Ogre@@V?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@0PAPAV12@AAV?$allocator@PAVSurfaceData@Ogre@@@4@@Z PROC ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >,Ogre::SurfaceData * *,std::allocator<Ogre::SurfaceData *> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T73658[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@V?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@PAPAVSurfaceData@Ogre@@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@0@AAPAPAVSurfaceData@Ogre@@@Z ; std::_Ptr_cat<std::_Vector_const_iterator<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >,Ogre::SurfaceData * *>
	add	esp, 8
	mov	BYTE PTR $T73659[ebp], al
	movzx	eax, BYTE PTR $T73658[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T73659[ebp]
	push	ecx
	mov	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@V?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@@std@@YAPBQAVSurfaceData@Ogre@@AAV?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> > >
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@V?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@@std@@YAPBQAVSurfaceData@Ogre@@AAV?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> > >
	add	esp, 4
	push	eax
	call	??$_Uninit_copy@PBQAVSurfaceData@Ogre@@PAPAV12@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@YAPAPAVSurfaceData@Ogre@@PBQAV12@0PAPAV12@AAV?$allocator@PAVSurfaceData@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Ogre::SurfaceData * const *,Ogre::SurfaceData * *,std::allocator<Ogre::SurfaceData *> >
	add	esp, 24					; 00000018H

; 823  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@PAPAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@2@@stdext@@YAPAPAVSurfaceData@Ogre@@V?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@0PAPAV12@AAV?$allocator@PAVSurfaceData@Ogre@@@4@@Z ENDP ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >,Ogre::SurfaceData * *,std::allocator<Ogre::SurfaceData *> >
_TEXT	ENDS
PUBLIC	??$_Checked_base@PAPAVSurfaceData@Ogre@@@std@@YAPAPAVSurfaceData@Ogre@@AAPAPAV12@U_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<Ogre::SurfaceData * *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Checked_base@PAPAVSurfaceData@Ogre@@@std@@YAPAPAVSurfaceData@Ogre@@AAPAPAV12@@Z
_TEXT	SEGMENT
__Base_tag$ = -1					; size = 1
__It$ = 8						; size = 4
??$_Checked_base@PAPAVSurfaceData@Ogre@@@std@@YAPAPAVSurfaceData@Ogre@@AAPAPAV12@@Z PROC ; std::_Checked_base<Ogre::SurfaceData * *>, COMDAT

; 1163 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1164 : 		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
; 1165 : 		return _Checked_base(_It, _Base_tag);

	movzx	eax, BYTE PTR __Base_tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR __It$[ebp]
	push	ecx
	call	??$_Checked_base@PAPAVSurfaceData@Ogre@@@std@@YAPAPAVSurfaceData@Ogre@@AAPAPAV12@U_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<Ogre::SurfaceData * *>
	add	esp, 8

; 1166 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Checked_base@PAPAVSurfaceData@Ogre@@@std@@YAPAPAVSurfaceData@Ogre@@AAPAPAV12@@Z ENDP ; std::_Checked_base<Ogre::SurfaceData * *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Iter_random@PAPAVSurfaceData@Ogre@@PAPAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVSurfaceData@Ogre@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAPAVSurfaceData@Ogre@@PAPAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVSurfaceData@Ogre@@0@Z PROC ; std::_Iter_random<Ogre::SurfaceData * *,Ogre::SurfaceData * *>, COMDAT

; 993  : 	{	// return category from iterator argument

	push	ebp
	mov	ebp, esp
	push	ecx

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 998  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Iter_random@PAPAVSurfaceData@Ogre@@PAPAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVSurfaceData@Ogre@@0@Z ENDP ; std::_Iter_random<Ogre::SurfaceData * *,Ogre::SurfaceData * *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAPAVSurfaceData@Ogre@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVSurfaceData@Ogre@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAPAVSurfaceData@Ogre@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVSurfaceData@Ogre@@0@Z PROC ; std::_Ptr_cat<Ogre::SurfaceData * *,Ogre::SurfaceData * *>, COMDAT

; 1509 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 1512 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Ptr_cat@PAPAVSurfaceData@Ogre@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVSurfaceData@Ogre@@0@Z ENDP ; std::_Ptr_cat<Ogre::SurfaceData * *,Ogre::SurfaceData * *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Copy_opt@PAPAVSurfaceData@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@@std@@YAPAPAVSurfaceData@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Off$ = -8						; size = 4
__Result$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAPAVSurfaceData@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@@std@@YAPAPAVSurfaceData@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<Ogre::SurfaceData * *,Ogre::SurfaceData * *,std::random_access_iterator_tag>, COMDAT

; 2494 : 	{	// copy [_First, _Last) to [_Dest, ...), pointers to scalars

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 2495 : 
; 2496 :  #if _HAS_ITERATOR_DEBUGGING
; 2497 : 	_DEBUG_RANGE(_First, _Last);
; 2498 : 	if (_First != _Last)
; 2499 : 		_DEBUG_POINTER(_Dest);
; 2500 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2501 : 
; 2502 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 2
	mov	DWORD PTR __Off$[ebp], eax

; 2503 : 	// if _OutIt is range checked, this will make sure there is enough space for the memmove
; 2504 : 	_OutIt _Result = _Dest + _Off;

	mov	ecx, DWORD PTR __Off$[ebp]
	mov	edx, DWORD PTR __Dest$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR __Result$[ebp], eax

; 2505 : 	if (_Off > 0)

	cmp	DWORD PTR __Off$[ebp], 0
	jle	SHORT $LN1@Copy_opt@2

; 2506 : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Off * sizeof (*_First), &*_First, _Off * sizeof (*_First));

	mov	ecx, DWORD PTR __Off$[ebp]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	eax, DWORD PTR __Off$[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN1@Copy_opt@2:

; 2507 : 	return _Result;

	mov	eax, DWORD PTR __Result$[ebp]

; 2508 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Copy_opt@PAPAVSurfaceData@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@@std@@YAPAPAVSurfaceData@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<Ogre::SurfaceData * *,Ogre::SurfaceData * *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PAPAVSurfaceData@Ogre@@PAPAV12@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@YAPAPAVSurfaceData@Ogre@@PAPAV12@00AAV?$allocator@PAVSurfaceData@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Ogre::SurfaceData * *,Ogre::SurfaceData * *,std::allocator<Ogre::SurfaceData *> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_copy@PAPAVSurfaceData@Ogre@@PAPAV12@V?$allocator@PAVSurfaceData@Ogre@@@std@@@stdext@@YAPAPAVSurfaceData@Ogre@@PAPAV12@00AAV?$allocator@PAVSurfaceData@Ogre@@@std@@@Z
_TEXT	SEGMENT
$T73671 = -2						; size = 1
$T73670 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@PAPAVSurfaceData@Ogre@@PAPAV12@V?$allocator@PAVSurfaceData@Ogre@@@std@@@stdext@@YAPAPAVSurfaceData@Ogre@@PAPAV12@00AAV?$allocator@PAVSurfaceData@Ogre@@@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<Ogre::SurfaceData * *,Ogre::SurfaceData * *,std::allocator<Ogre::SurfaceData *> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T73670[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAPAVSurfaceData@Ogre@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVSurfaceData@Ogre@@0@Z ; std::_Ptr_cat<Ogre::SurfaceData * *,Ogre::SurfaceData * *>
	add	esp, 8
	mov	BYTE PTR $T73671[ebp], al
	movzx	eax, BYTE PTR $T73670[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T73671[ebp]
	push	ecx
	mov	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@PAPAVSurfaceData@Ogre@@@std@@YAPAPAVSurfaceData@Ogre@@AAPAPAV12@@Z ; std::_Checked_base<Ogre::SurfaceData * *>
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@PAPAVSurfaceData@Ogre@@@std@@YAPAPAVSurfaceData@Ogre@@AAPAPAV12@@Z ; std::_Checked_base<Ogre::SurfaceData * *>
	add	esp, 4
	push	eax
	call	??$_Uninit_copy@PAPAVSurfaceData@Ogre@@PAPAV12@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@YAPAPAVSurfaceData@Ogre@@PAPAV12@00AAV?$allocator@PAVSurfaceData@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Ogre::SurfaceData * *,Ogre::SurfaceData * *,std::allocator<Ogre::SurfaceData *> >
	add	esp, 24					; 00000018H

; 823  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_copy@PAPAVSurfaceData@Ogre@@PAPAV12@V?$allocator@PAVSurfaceData@Ogre@@@std@@@stdext@@YAPAPAVSurfaceData@Ogre@@PAPAV12@00AAV?$allocator@PAVSurfaceData@Ogre@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<Ogre::SurfaceData * *,Ogre::SurfaceData * *,std::allocator<Ogre::SurfaceData *> >
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PBQAVHardwarePixelBuffer@Ogre@@PAPAV12@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@YAPAPAVHardwarePixelBuffer@Ogre@@PBQAV12@0PAPAV12@AAV?$allocator@PAVHardwarePixelBuffer@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Ogre::HardwarePixelBuffer * const *,Ogre::HardwarePixelBuffer * *,std::allocator<Ogre::HardwarePixelBuffer *> >
PUBLIC	??$_Checked_base@V?$_Vector_const_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@@std@@YAPBQAVHardwarePixelBuffer@Ogre@@AAV?$_Vector_const_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> > >
PUBLIC	??$_Ptr_cat@V?$_Vector_const_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@PAPAVHardwarePixelBuffer@Ogre@@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@0@AAPAPAVHardwarePixelBuffer@Ogre@@@Z ; std::_Ptr_cat<std::_Vector_const_iterator<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >,Ogre::HardwarePixelBuffer * *>
; Function compile flags: /Odtp
;	COMDAT ??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@PAPAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@2@@stdext@@YAPAPAVHardwarePixelBuffer@Ogre@@V?$_Vector_const_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@0PAPAV12@AAV?$allocator@PAVHardwarePixelBuffer@Ogre@@@4@@Z
_TEXT	SEGMENT
$T73675 = -2						; size = 1
$T73674 = -1						; size = 1
__First$ = 8						; size = 8
__Last$ = 16						; size = 8
__Dest$ = 24						; size = 4
__Al$ = 28						; size = 4
??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@PAPAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@2@@stdext@@YAPAPAVHardwarePixelBuffer@Ogre@@V?$_Vector_const_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@0PAPAV12@AAV?$allocator@PAVHardwarePixelBuffer@Ogre@@@4@@Z PROC ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >,Ogre::HardwarePixelBuffer * *,std::allocator<Ogre::HardwarePixelBuffer *> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T73674[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@V?$_Vector_const_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@PAPAVHardwarePixelBuffer@Ogre@@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@0@AAPAPAVHardwarePixelBuffer@Ogre@@@Z ; std::_Ptr_cat<std::_Vector_const_iterator<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >,Ogre::HardwarePixelBuffer * *>
	add	esp, 8
	mov	BYTE PTR $T73675[ebp], al
	movzx	eax, BYTE PTR $T73674[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T73675[ebp]
	push	ecx
	mov	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@V?$_Vector_const_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@@std@@YAPBQAVHardwarePixelBuffer@Ogre@@AAV?$_Vector_const_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> > >
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@V?$_Vector_const_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@@std@@YAPBQAVHardwarePixelBuffer@Ogre@@AAV?$_Vector_const_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> > >
	add	esp, 4
	push	eax
	call	??$_Uninit_copy@PBQAVHardwarePixelBuffer@Ogre@@PAPAV12@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@YAPAPAVHardwarePixelBuffer@Ogre@@PBQAV12@0PAPAV12@AAV?$allocator@PAVHardwarePixelBuffer@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Ogre::HardwarePixelBuffer * const *,Ogre::HardwarePixelBuffer * *,std::allocator<Ogre::HardwarePixelBuffer *> >
	add	esp, 24					; 00000018H

; 823  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@PAPAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@2@@stdext@@YAPAPAVHardwarePixelBuffer@Ogre@@V?$_Vector_const_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@0PAPAV12@AAV?$allocator@PAVHardwarePixelBuffer@Ogre@@@4@@Z ENDP ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >,Ogre::HardwarePixelBuffer * *,std::allocator<Ogre::HardwarePixelBuffer *> >
_TEXT	ENDS
PUBLIC	??$_Checked_base@PAPAVHardwarePixelBuffer@Ogre@@@std@@YAPAPAVHardwarePixelBuffer@Ogre@@AAPAPAV12@U_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<Ogre::HardwarePixelBuffer * *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Checked_base@PAPAVHardwarePixelBuffer@Ogre@@@std@@YAPAPAVHardwarePixelBuffer@Ogre@@AAPAPAV12@@Z
_TEXT	SEGMENT
__Base_tag$ = -1					; size = 1
__It$ = 8						; size = 4
??$_Checked_base@PAPAVHardwarePixelBuffer@Ogre@@@std@@YAPAPAVHardwarePixelBuffer@Ogre@@AAPAPAV12@@Z PROC ; std::_Checked_base<Ogre::HardwarePixelBuffer * *>, COMDAT

; 1163 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1164 : 		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
; 1165 : 		return _Checked_base(_It, _Base_tag);

	movzx	eax, BYTE PTR __Base_tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR __It$[ebp]
	push	ecx
	call	??$_Checked_base@PAPAVHardwarePixelBuffer@Ogre@@@std@@YAPAPAVHardwarePixelBuffer@Ogre@@AAPAPAV12@U_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<Ogre::HardwarePixelBuffer * *>
	add	esp, 8

; 1166 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Checked_base@PAPAVHardwarePixelBuffer@Ogre@@@std@@YAPAPAVHardwarePixelBuffer@Ogre@@AAPAPAV12@@Z ENDP ; std::_Checked_base<Ogre::HardwarePixelBuffer * *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Iter_random@PAPAVHardwarePixelBuffer@Ogre@@PAPAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVHardwarePixelBuffer@Ogre@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAPAVHardwarePixelBuffer@Ogre@@PAPAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVHardwarePixelBuffer@Ogre@@0@Z PROC ; std::_Iter_random<Ogre::HardwarePixelBuffer * *,Ogre::HardwarePixelBuffer * *>, COMDAT

; 993  : 	{	// return category from iterator argument

	push	ebp
	mov	ebp, esp
	push	ecx

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 998  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Iter_random@PAPAVHardwarePixelBuffer@Ogre@@PAPAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVHardwarePixelBuffer@Ogre@@0@Z ENDP ; std::_Iter_random<Ogre::HardwarePixelBuffer * *,Ogre::HardwarePixelBuffer * *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAPAVHardwarePixelBuffer@Ogre@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVHardwarePixelBuffer@Ogre@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAPAVHardwarePixelBuffer@Ogre@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVHardwarePixelBuffer@Ogre@@0@Z PROC ; std::_Ptr_cat<Ogre::HardwarePixelBuffer * *,Ogre::HardwarePixelBuffer * *>, COMDAT

; 1509 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 1512 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Ptr_cat@PAPAVHardwarePixelBuffer@Ogre@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVHardwarePixelBuffer@Ogre@@0@Z ENDP ; std::_Ptr_cat<Ogre::HardwarePixelBuffer * *,Ogre::HardwarePixelBuffer * *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Copy_opt@PAPAVHardwarePixelBuffer@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@@std@@YAPAPAVHardwarePixelBuffer@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Off$ = -8						; size = 4
__Result$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAPAVHardwarePixelBuffer@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@@std@@YAPAPAVHardwarePixelBuffer@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<Ogre::HardwarePixelBuffer * *,Ogre::HardwarePixelBuffer * *,std::random_access_iterator_tag>, COMDAT

; 2494 : 	{	// copy [_First, _Last) to [_Dest, ...), pointers to scalars

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 2495 : 
; 2496 :  #if _HAS_ITERATOR_DEBUGGING
; 2497 : 	_DEBUG_RANGE(_First, _Last);
; 2498 : 	if (_First != _Last)
; 2499 : 		_DEBUG_POINTER(_Dest);
; 2500 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2501 : 
; 2502 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 2
	mov	DWORD PTR __Off$[ebp], eax

; 2503 : 	// if _OutIt is range checked, this will make sure there is enough space for the memmove
; 2504 : 	_OutIt _Result = _Dest + _Off;

	mov	ecx, DWORD PTR __Off$[ebp]
	mov	edx, DWORD PTR __Dest$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR __Result$[ebp], eax

; 2505 : 	if (_Off > 0)

	cmp	DWORD PTR __Off$[ebp], 0
	jle	SHORT $LN1@Copy_opt@3

; 2506 : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Off * sizeof (*_First), &*_First, _Off * sizeof (*_First));

	mov	ecx, DWORD PTR __Off$[ebp]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	eax, DWORD PTR __Off$[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN1@Copy_opt@3:

; 2507 : 	return _Result;

	mov	eax, DWORD PTR __Result$[ebp]

; 2508 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Copy_opt@PAPAVHardwarePixelBuffer@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@@std@@YAPAPAVHardwarePixelBuffer@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<Ogre::HardwarePixelBuffer * *,Ogre::HardwarePixelBuffer * *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PAPAVHardwarePixelBuffer@Ogre@@PAPAV12@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@YAPAPAVHardwarePixelBuffer@Ogre@@PAPAV12@00AAV?$allocator@PAVHardwarePixelBuffer@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Ogre::HardwarePixelBuffer * *,Ogre::HardwarePixelBuffer * *,std::allocator<Ogre::HardwarePixelBuffer *> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_copy@PAPAVHardwarePixelBuffer@Ogre@@PAPAV12@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@stdext@@YAPAPAVHardwarePixelBuffer@Ogre@@PAPAV12@00AAV?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@Z
_TEXT	SEGMENT
$T73687 = -2						; size = 1
$T73686 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@PAPAVHardwarePixelBuffer@Ogre@@PAPAV12@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@stdext@@YAPAPAVHardwarePixelBuffer@Ogre@@PAPAV12@00AAV?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<Ogre::HardwarePixelBuffer * *,Ogre::HardwarePixelBuffer * *,std::allocator<Ogre::HardwarePixelBuffer *> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T73686[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAPAVHardwarePixelBuffer@Ogre@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVHardwarePixelBuffer@Ogre@@0@Z ; std::_Ptr_cat<Ogre::HardwarePixelBuffer * *,Ogre::HardwarePixelBuffer * *>
	add	esp, 8
	mov	BYTE PTR $T73687[ebp], al
	movzx	eax, BYTE PTR $T73686[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T73687[ebp]
	push	ecx
	mov	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@PAPAVHardwarePixelBuffer@Ogre@@@std@@YAPAPAVHardwarePixelBuffer@Ogre@@AAPAPAV12@@Z ; std::_Checked_base<Ogre::HardwarePixelBuffer * *>
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@PAPAVHardwarePixelBuffer@Ogre@@@std@@YAPAPAVHardwarePixelBuffer@Ogre@@AAPAPAV12@@Z ; std::_Checked_base<Ogre::HardwarePixelBuffer * *>
	add	esp, 4
	push	eax
	call	??$_Uninit_copy@PAPAVHardwarePixelBuffer@Ogre@@PAPAV12@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@YAPAPAVHardwarePixelBuffer@Ogre@@PAPAV12@00AAV?$allocator@PAVHardwarePixelBuffer@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Ogre::HardwarePixelBuffer * *,Ogre::HardwarePixelBuffer * *,std::allocator<Ogre::HardwarePixelBuffer *> >
	add	esp, 24					; 00000018H

; 823  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_copy@PAPAVHardwarePixelBuffer@Ogre@@PAPAV12@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@stdext@@YAPAPAVHardwarePixelBuffer@Ogre@@PAPAV12@00AAV?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<Ogre::HardwarePixelBuffer * *,Ogre::HardwarePixelBuffer * *,std::allocator<Ogre::HardwarePixelBuffer *> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@V?$allocator@D@std@@@std@@YAXPAD0AAV?$allocator@D@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@D@std@@@std@@YAXPAD0AAV?$allocator@D@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<char> >, COMDAT

; 241  : 	{	// destroy [_First, _Last), scalar type (do nothing)

	push	ebp
	mov	ebp, esp

; 242  : 	}

	pop	ebp
	ret	0
??$_Destroy_range@V?$allocator@D@std@@@std@@YAXPAD0AAV?$allocator@D@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<char> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@YAXPAPAVSurfaceData@Ogre@@0AAV?$allocator@PAVSurfaceData@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@YAXPAPAVSurfaceData@Ogre@@0AAV?$allocator@PAVSurfaceData@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<Ogre::SurfaceData *> >, COMDAT

; 241  : 	{	// destroy [_First, _Last), scalar type (do nothing)

	push	ebp
	mov	ebp, esp

; 242  : 	}

	pop	ebp
	ret	0
??$_Destroy_range@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@YAXPAPAVSurfaceData@Ogre@@0AAV?$allocator@PAVSurfaceData@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<Ogre::SurfaceData *> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@YAXPAPAVHardwarePixelBuffer@Ogre@@0AAV?$allocator@PAVHardwarePixelBuffer@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@YAXPAPAVHardwarePixelBuffer@Ogre@@0AAV?$allocator@PAVHardwarePixelBuffer@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<Ogre::HardwarePixelBuffer *> >, COMDAT

; 241  : 	{	// destroy [_First, _Last), scalar type (do nothing)

	push	ebp
	mov	ebp, esp

; 242  : 	}

	pop	ebp
	ret	0
??$_Destroy_range@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@YAXPAPAVHardwarePixelBuffer@Ogre@@0AAV?$allocator@PAVHardwarePixelBuffer@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<Ogre::HardwarePixelBuffer *> >
_TEXT	ENDS
PUBLIC	??$unchecked_fill_n@PAPAVHardwarePixelBuffer@Ogre@@IPAV12@@stdext@@YAXPAPAVHardwarePixelBuffer@Ogre@@IABQAV12@@Z ; stdext::unchecked_fill_n<Ogre::HardwarePixelBuffer * *,unsigned int,Ogre::HardwarePixelBuffer *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Uninit_fill_n@PAPAVHardwarePixelBuffer@Ogre@@IPAV12@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@YAXPAPAVHardwarePixelBuffer@Ogre@@IABQAV12@AAV?$allocator@PAVHardwarePixelBuffer@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_fill_n@PAPAVHardwarePixelBuffer@Ogre@@IPAV12@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@YAXPAPAVHardwarePixelBuffer@Ogre@@IABQAV12@AAV?$allocator@PAVHardwarePixelBuffer@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<Ogre::HardwarePixelBuffer * *,unsigned int,Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >, COMDAT

; 418  : 	{	// copy _Count *_Val to raw _First, using _Al, scalar type

	push	ebp
	mov	ebp, esp

; 419  : 		_STDEXT unchecked_fill_n(_First, _Count, _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$unchecked_fill_n@PAPAVHardwarePixelBuffer@Ogre@@IPAV12@@stdext@@YAXPAPAVHardwarePixelBuffer@Ogre@@IABQAV12@@Z ; stdext::unchecked_fill_n<Ogre::HardwarePixelBuffer * *,unsigned int,Ogre::HardwarePixelBuffer *>
	add	esp, 12					; 0000000cH

; 420  : 	}

	pop	ebp
	ret	0
??$_Uninit_fill_n@PAPAVHardwarePixelBuffer@Ogre@@IPAV12@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@YAXPAPAVHardwarePixelBuffer@Ogre@@IABQAV12@AAV?$allocator@PAVHardwarePixelBuffer@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<Ogre::HardwarePixelBuffer * *,unsigned int,Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >
_TEXT	ENDS
PUBLIC	??$_Uninit_move@PAPAVHardwarePixelBuffer@Ogre@@PAPAV12@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@U_Undefined_move_tag@4@@std@@YAPAPAVHardwarePixelBuffer@Ogre@@PAPAV12@00AAV?$allocator@PAVHardwarePixelBuffer@Ogre@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<Ogre::HardwarePixelBuffer * *,Ogre::HardwarePixelBuffer * *,std::allocator<Ogre::HardwarePixelBuffer *>,std::_Undefined_move_tag>
; Function compile flags: /Odtp
;	COMDAT ??$_Unchecked_uninitialized_move@PAPAVHardwarePixelBuffer@Ogre@@PAPAV12@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@stdext@@YAPAPAVHardwarePixelBuffer@Ogre@@PAPAV12@00AAV?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@Z
_TEXT	SEGMENT
$T73699 = -2						; size = 1
$T73698 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Unchecked_uninitialized_move@PAPAVHardwarePixelBuffer@Ogre@@PAPAV12@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@stdext@@YAPAPAVHardwarePixelBuffer@Ogre@@PAPAV12@00AAV?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@Z PROC ; stdext::_Unchecked_uninitialized_move<Ogre::HardwarePixelBuffer * *,Ogre::HardwarePixelBuffer * *,std::allocator<Ogre::HardwarePixelBuffer *> >, COMDAT

; 861  : 	{	// move [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 862  : 	return (_STD _Uninit_move(_CHECKED_BASE(_First),
; 863  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 864  : 		_STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T73698[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	??$_Move_cat@PAPAVHardwarePixelBuffer@Ogre@@@std@@YA?AU_Undefined_move_tag@0@ABQAPAVHardwarePixelBuffer@Ogre@@@Z ; std::_Move_cat<Ogre::HardwarePixelBuffer * *>
	add	esp, 4
	mov	BYTE PTR $T73699[ebp], al
	movzx	edx, BYTE PTR $T73698[ebp]
	push	edx
	movzx	eax, BYTE PTR $T73699[ebp]
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	call	??$_Checked_base@PAPAVHardwarePixelBuffer@Ogre@@@std@@YAPAPAVHardwarePixelBuffer@Ogre@@AAPAPAV12@@Z ; std::_Checked_base<Ogre::HardwarePixelBuffer * *>
	add	esp, 4
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Checked_base@PAPAVHardwarePixelBuffer@Ogre@@@std@@YAPAPAVHardwarePixelBuffer@Ogre@@AAPAPAV12@@Z ; std::_Checked_base<Ogre::HardwarePixelBuffer * *>
	add	esp, 4
	push	eax
	call	??$_Uninit_move@PAPAVHardwarePixelBuffer@Ogre@@PAPAV12@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@U_Undefined_move_tag@4@@std@@YAPAPAVHardwarePixelBuffer@Ogre@@PAPAV12@00AAV?$allocator@PAVHardwarePixelBuffer@Ogre@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<Ogre::HardwarePixelBuffer * *,Ogre::HardwarePixelBuffer * *,std::allocator<Ogre::HardwarePixelBuffer *>,std::_Undefined_move_tag>
	add	esp, 24					; 00000018H

; 865  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Unchecked_uninitialized_move@PAPAVHardwarePixelBuffer@Ogre@@PAPAV12@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@stdext@@YAPAPAVHardwarePixelBuffer@Ogre@@PAPAV12@00AAV?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@Z ENDP ; stdext::_Unchecked_uninitialized_move<Ogre::HardwarePixelBuffer * *,Ogre::HardwarePixelBuffer * *,std::allocator<Ogre::HardwarePixelBuffer *> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Fill@PAPAVHardwarePixelBuffer@Ogre@@PAV12@@std@@YAXPAPAVHardwarePixelBuffer@Ogre@@0ABQAV12@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$_Fill@PAPAVHardwarePixelBuffer@Ogre@@PAV12@@std@@YAXPAPAVHardwarePixelBuffer@Ogre@@0ABQAV12@@Z PROC ; std::_Fill<Ogre::HardwarePixelBuffer * *,Ogre::HardwarePixelBuffer *>, COMDAT

; 3156 : 	{	// copy _Val through [_First, _Last)

	push	ebp
	mov	ebp, esp

; 3157 : 	_DEBUG_RANGE(_First, _Last);
; 3158 : 	for (; _First != _Last; ++_First)

	jmp	SHORT $LN3@Fill
$LN2@Fill:
	mov	eax, DWORD PTR __First$[ebp]
	add	eax, 4
	mov	DWORD PTR __First$[ebp], eax
$LN3@Fill:
	mov	ecx, DWORD PTR __First$[ebp]
	cmp	ecx, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Fill

; 3159 : 		*_First = _Val;

	mov	edx, DWORD PTR __First$[ebp]
	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	jmp	SHORT $LN2@Fill
$LN4@Fill:

; 3160 : 	}

	pop	ebp
	ret	0
??$_Fill@PAPAVHardwarePixelBuffer@Ogre@@PAV12@@std@@YAXPAPAVHardwarePixelBuffer@Ogre@@0ABQAV12@@Z ENDP ; std::_Fill<Ogre::HardwarePixelBuffer * *,Ogre::HardwarePixelBuffer *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Move_cat@PAPAVHardwarePixelBuffer@Ogre@@@std@@YA?AU_Undefined_move_tag@0@ABQAPAVHardwarePixelBuffer@Ogre@@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
??$_Move_cat@PAPAVHardwarePixelBuffer@Ogre@@@std@@YA?AU_Undefined_move_tag@0@ABQAPAVHardwarePixelBuffer@Ogre@@@Z PROC ; std::_Move_cat<Ogre::HardwarePixelBuffer * *>, COMDAT

; 1200 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1201 : 		typename _Move_operation_category<typename iterator_traits<_Iter>::value_type>::_Move_cat _Cat;
; 1202 : 		return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 1203 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Move_cat@PAPAVHardwarePixelBuffer@Ogre@@@std@@YA?AU_Undefined_move_tag@0@ABQAPAVHardwarePixelBuffer@Ogre@@@Z ENDP ; std::_Move_cat<Ogre::HardwarePixelBuffer * *>
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@PAPAVHardwarePixelBuffer@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@@std@@YAPAPAVHardwarePixelBuffer@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<Ogre::HardwarePixelBuffer * *,Ogre::HardwarePixelBuffer * *,std::random_access_iterator_tag>
; Function compile flags: /Odtp
;	COMDAT ??$_Move_backward_opt@PAPAVHardwarePixelBuffer@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@4@@std@@YAPAPAVHardwarePixelBuffer@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T73707 = -2						; size = 1
$T73706 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__First_dest_cat$ = 20					; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Move_backward_opt@PAPAVHardwarePixelBuffer@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@4@@std@@YAPAPAVHardwarePixelBuffer@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Move_backward_opt<Ogre::HardwarePixelBuffer * *,Ogre::HardwarePixelBuffer * *,std::random_access_iterator_tag,std::_Undefined_move_tag>, COMDAT

; 2752 : 	{	// move defaults to copy if there is not a more effecient way

	push	ebp
	mov	ebp, esp
	push	ecx

; 2753 : 	return _Copy_backward_opt(_First, _Last, _Dest,
; 2754 : 		_First_dest_cat, _Ptr_cat(_First, _Dest), _Range_checked_iterator_tag());

	xor	eax, eax
	mov	BYTE PTR $T73706[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAPAVHardwarePixelBuffer@Ogre@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVHardwarePixelBuffer@Ogre@@0@Z ; std::_Ptr_cat<Ogre::HardwarePixelBuffer * *,Ogre::HardwarePixelBuffer * *>
	add	esp, 8
	mov	BYTE PTR $T73707[ebp], al
	movzx	eax, BYTE PTR $T73706[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T73707[ebp]
	push	ecx
	movzx	edx, BYTE PTR __First_dest_cat$[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Copy_backward_opt@PAPAVHardwarePixelBuffer@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@@std@@YAPAPAVHardwarePixelBuffer@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<Ogre::HardwarePixelBuffer * *,Ogre::HardwarePixelBuffer * *,std::random_access_iterator_tag>
	add	esp, 24					; 00000018H

; 2755 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Move_backward_opt@PAPAVHardwarePixelBuffer@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@4@@std@@YAPAPAVHardwarePixelBuffer@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Move_backward_opt<Ogre::HardwarePixelBuffer * *,Ogre::HardwarePixelBuffer * *,std::random_access_iterator_tag,std::_Undefined_move_tag>
_TEXT	ENDS
PUBLIC	??$_Checked_base@V?$_Vector_const_iterator@DV?$allocator@D@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBDAAV?$_Vector_const_iterator@DV?$allocator@D@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<char,std::allocator<char> >,std::_Different_checked_iterator_base_type_tag>
; Function compile flags: /Odtp
;	COMDAT ??$_Checked_base@V?$_Vector_const_iterator@DV?$allocator@D@std@@@std@@@std@@YAPBDAAV?$_Vector_const_iterator@DV?$allocator@D@std@@@0@@Z
_TEXT	SEGMENT
__Base_tag$ = -1					; size = 1
__It$ = 8						; size = 4
??$_Checked_base@V?$_Vector_const_iterator@DV?$allocator@D@std@@@std@@@std@@YAPBDAAV?$_Vector_const_iterator@DV?$allocator@D@std@@@0@@Z PROC ; std::_Checked_base<std::_Vector_const_iterator<char,std::allocator<char> > >, COMDAT

; 1163 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1164 : 		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
; 1165 : 		return _Checked_base(_It, _Base_tag);

	movzx	eax, BYTE PTR __Base_tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR __It$[ebp]
	push	ecx
	call	??$_Checked_base@V?$_Vector_const_iterator@DV?$allocator@D@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBDAAV?$_Vector_const_iterator@DV?$allocator@D@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<char,std::allocator<char> >,std::_Different_checked_iterator_base_type_tag>
	add	esp, 8

; 1166 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Checked_base@V?$_Vector_const_iterator@DV?$allocator@D@std@@@std@@@std@@YAPBDAAV?$_Vector_const_iterator@DV?$allocator@D@std@@@0@@Z ENDP ; std::_Checked_base<std::_Vector_const_iterator<char,std::allocator<char> > >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@V?$_Vector_const_iterator@DV?$allocator@D@std@@@std@@PAD@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@DV?$allocator@D@std@@@0@AAPAD@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@V?$_Vector_const_iterator@DV?$allocator@D@std@@@std@@PAD@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@DV?$allocator@D@std@@@0@AAPAD@Z PROC ; std::_Ptr_cat<std::_Vector_const_iterator<char,std::allocator<char> >,char *>, COMDAT

; 1509 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 1512 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Ptr_cat@V?$_Vector_const_iterator@DV?$allocator@D@std@@@std@@PAD@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@DV?$allocator@D@std@@@0@AAPAD@Z ENDP ; std::_Ptr_cat<std::_Vector_const_iterator<char,std::allocator<char> >,char *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@PBDPADV?$allocator@D@std@@@std@@YAPADPBD0PADAAV?$allocator@D@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Result$ = -8						; size = 4
__Count$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PBDPADV?$allocator@D@std@@@std@@YAPADPBD0PADAAV?$allocator@D@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<char const *,char *,std::allocator<char> >, COMDAT

; 145  : 	{	// copy [_First, _Last) to raw _Dest, scalar type

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 146  : 	_DEBUG_RANGE(_First, _Last);
; 147  : 	_DEBUG_POINTER(_Dest);
; 148  : 	size_t _Count = (size_t)(_Last - _First);

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Count$[ebp], eax

; 149  : 	_FwdIt _Result = _Dest + _Count;

	mov	ecx, DWORD PTR __Dest$[ebp]
	add	ecx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Result$[ebp], ecx

; 150  : 	if (_Count > 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN1@Uninit_cop

; 151  : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Count * sizeof (*_First), &*_First, _Count * sizeof (*_First));	// NB: non-overlapping move

	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN1@Uninit_cop:

; 152  : 	return (_Result);

	mov	eax, DWORD PTR __Result$[ebp]

; 153  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Uninit_copy@PBDPADV?$allocator@D@std@@@std@@YAPADPBD0PADAAV?$allocator@D@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<char const *,char *,std::allocator<char> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Checked_base@PAD@std@@YAPADAAPADU_Unchanged_checked_iterator_base_type_tag@0@@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Checked_base@PAD@std@@YAPADAAPADU_Unchanged_checked_iterator_base_type_tag@0@@Z PROC ; std::_Checked_base<char *>, COMDAT

; 1146 : 	{

	push	ebp
	mov	ebp, esp

; 1147 : 		return _It;

	mov	eax, DWORD PTR __It$[ebp]
	mov	eax, DWORD PTR [eax]

; 1148 : 	}

	pop	ebp
	ret	0
??$_Checked_base@PAD@std@@YAPADAAPADU_Unchanged_checked_iterator_base_type_tag@0@@Z ENDP ; std::_Checked_base<char *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@PADPADV?$allocator@D@std@@@std@@YAPADPAD00AAV?$allocator@D@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Result$ = -8						; size = 4
__Count$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PADPADV?$allocator@D@std@@@std@@YAPADPAD00AAV?$allocator@D@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<char *,char *,std::allocator<char> >, COMDAT

; 145  : 	{	// copy [_First, _Last) to raw _Dest, scalar type

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 146  : 	_DEBUG_RANGE(_First, _Last);
; 147  : 	_DEBUG_POINTER(_Dest);
; 148  : 	size_t _Count = (size_t)(_Last - _First);

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Count$[ebp], eax

; 149  : 	_FwdIt _Result = _Dest + _Count;

	mov	ecx, DWORD PTR __Dest$[ebp]
	add	ecx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Result$[ebp], ecx

; 150  : 	if (_Count > 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN1@Uninit_cop@2

; 151  : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Count * sizeof (*_First), &*_First, _Count * sizeof (*_First));	// NB: non-overlapping move

	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN1@Uninit_cop@2:

; 152  : 	return (_Result);

	mov	eax, DWORD PTR __Result$[ebp]

; 153  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Uninit_copy@PADPADV?$allocator@D@std@@@std@@YAPADPAD00AAV?$allocator@D@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<char *,char *,std::allocator<char> >
_TEXT	ENDS
PUBLIC	??$_Checked_base@V?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBQAVSurfaceData@Ogre@@AAV?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >,std::_Different_checked_iterator_base_type_tag>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Checked_base@V?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@@std@@YAPBQAVSurfaceData@Ogre@@AAV?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@0@@Z
_TEXT	SEGMENT
__Base_tag$ = -1					; size = 1
__It$ = 8						; size = 4
??$_Checked_base@V?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@@std@@YAPBQAVSurfaceData@Ogre@@AAV?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@0@@Z PROC ; std::_Checked_base<std::_Vector_const_iterator<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> > >, COMDAT

; 1163 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1164 : 		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
; 1165 : 		return _Checked_base(_It, _Base_tag);

	movzx	eax, BYTE PTR __Base_tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR __It$[ebp]
	push	ecx
	call	??$_Checked_base@V?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBQAVSurfaceData@Ogre@@AAV?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >,std::_Different_checked_iterator_base_type_tag>
	add	esp, 8

; 1166 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Checked_base@V?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@@std@@YAPBQAVSurfaceData@Ogre@@AAV?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@0@@Z ENDP ; std::_Checked_base<std::_Vector_const_iterator<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> > >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@V?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@PAPAVSurfaceData@Ogre@@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@0@AAPAPAVSurfaceData@Ogre@@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@V?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@PAPAVSurfaceData@Ogre@@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@0@AAPAPAVSurfaceData@Ogre@@@Z PROC ; std::_Ptr_cat<std::_Vector_const_iterator<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >,Ogre::SurfaceData * *>, COMDAT

; 1509 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 1512 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Ptr_cat@V?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@PAPAVSurfaceData@Ogre@@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@0@AAPAPAVSurfaceData@Ogre@@@Z ENDP ; std::_Ptr_cat<std::_Vector_const_iterator<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >,Ogre::SurfaceData * *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@PBQAVSurfaceData@Ogre@@PAPAV12@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@YAPAPAVSurfaceData@Ogre@@PBQAV12@0PAPAV12@AAV?$allocator@PAVSurfaceData@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Result$ = -8						; size = 4
__Count$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PBQAVSurfaceData@Ogre@@PAPAV12@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@YAPAPAVSurfaceData@Ogre@@PBQAV12@0PAPAV12@AAV?$allocator@PAVSurfaceData@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<Ogre::SurfaceData * const *,Ogre::SurfaceData * *,std::allocator<Ogre::SurfaceData *> >, COMDAT

; 145  : 	{	// copy [_First, _Last) to raw _Dest, scalar type

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 146  : 	_DEBUG_RANGE(_First, _Last);
; 147  : 	_DEBUG_POINTER(_Dest);
; 148  : 	size_t _Count = (size_t)(_Last - _First);

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 2
	mov	DWORD PTR __Count$[ebp], eax

; 149  : 	_FwdIt _Result = _Dest + _Count;

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Dest$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR __Result$[ebp], eax

; 150  : 	if (_Count > 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN1@Uninit_cop@3

; 151  : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Count * sizeof (*_First), &*_First, _Count * sizeof (*_First));	// NB: non-overlapping move

	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN1@Uninit_cop@3:

; 152  : 	return (_Result);

	mov	eax, DWORD PTR __Result$[ebp]

; 153  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Uninit_copy@PBQAVSurfaceData@Ogre@@PAPAV12@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@YAPAPAVSurfaceData@Ogre@@PBQAV12@0PAPAV12@AAV?$allocator@PAVSurfaceData@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<Ogre::SurfaceData * const *,Ogre::SurfaceData * *,std::allocator<Ogre::SurfaceData *> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Checked_base@PAPAVSurfaceData@Ogre@@@std@@YAPAPAVSurfaceData@Ogre@@AAPAPAV12@U_Unchanged_checked_iterator_base_type_tag@0@@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Checked_base@PAPAVSurfaceData@Ogre@@@std@@YAPAPAVSurfaceData@Ogre@@AAPAPAV12@U_Unchanged_checked_iterator_base_type_tag@0@@Z PROC ; std::_Checked_base<Ogre::SurfaceData * *>, COMDAT

; 1146 : 	{

	push	ebp
	mov	ebp, esp

; 1147 : 		return _It;

	mov	eax, DWORD PTR __It$[ebp]
	mov	eax, DWORD PTR [eax]

; 1148 : 	}

	pop	ebp
	ret	0
??$_Checked_base@PAPAVSurfaceData@Ogre@@@std@@YAPAPAVSurfaceData@Ogre@@AAPAPAV12@U_Unchanged_checked_iterator_base_type_tag@0@@Z ENDP ; std::_Checked_base<Ogre::SurfaceData * *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@PAPAVSurfaceData@Ogre@@PAPAV12@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@YAPAPAVSurfaceData@Ogre@@PAPAV12@00AAV?$allocator@PAVSurfaceData@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Result$ = -8						; size = 4
__Count$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PAPAVSurfaceData@Ogre@@PAPAV12@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@YAPAPAVSurfaceData@Ogre@@PAPAV12@00AAV?$allocator@PAVSurfaceData@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<Ogre::SurfaceData * *,Ogre::SurfaceData * *,std::allocator<Ogre::SurfaceData *> >, COMDAT

; 145  : 	{	// copy [_First, _Last) to raw _Dest, scalar type

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 146  : 	_DEBUG_RANGE(_First, _Last);
; 147  : 	_DEBUG_POINTER(_Dest);
; 148  : 	size_t _Count = (size_t)(_Last - _First);

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 2
	mov	DWORD PTR __Count$[ebp], eax

; 149  : 	_FwdIt _Result = _Dest + _Count;

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Dest$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR __Result$[ebp], eax

; 150  : 	if (_Count > 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN1@Uninit_cop@4

; 151  : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Count * sizeof (*_First), &*_First, _Count * sizeof (*_First));	// NB: non-overlapping move

	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN1@Uninit_cop@4:

; 152  : 	return (_Result);

	mov	eax, DWORD PTR __Result$[ebp]

; 153  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Uninit_copy@PAPAVSurfaceData@Ogre@@PAPAV12@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@YAPAPAVSurfaceData@Ogre@@PAPAV12@00AAV?$allocator@PAVSurfaceData@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<Ogre::SurfaceData * *,Ogre::SurfaceData * *,std::allocator<Ogre::SurfaceData *> >
_TEXT	ENDS
PUBLIC	??$_Checked_base@V?$_Vector_const_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBQAVHardwarePixelBuffer@Ogre@@AAV?$_Vector_const_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >,std::_Different_checked_iterator_base_type_tag>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Checked_base@V?$_Vector_const_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@@std@@YAPBQAVHardwarePixelBuffer@Ogre@@AAV?$_Vector_const_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@0@@Z
_TEXT	SEGMENT
__Base_tag$ = -1					; size = 1
__It$ = 8						; size = 4
??$_Checked_base@V?$_Vector_const_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@@std@@YAPBQAVHardwarePixelBuffer@Ogre@@AAV?$_Vector_const_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@0@@Z PROC ; std::_Checked_base<std::_Vector_const_iterator<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> > >, COMDAT

; 1163 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1164 : 		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
; 1165 : 		return _Checked_base(_It, _Base_tag);

	movzx	eax, BYTE PTR __Base_tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR __It$[ebp]
	push	ecx
	call	??$_Checked_base@V?$_Vector_const_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBQAVHardwarePixelBuffer@Ogre@@AAV?$_Vector_const_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >,std::_Different_checked_iterator_base_type_tag>
	add	esp, 8

; 1166 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Checked_base@V?$_Vector_const_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@@std@@YAPBQAVHardwarePixelBuffer@Ogre@@AAV?$_Vector_const_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@0@@Z ENDP ; std::_Checked_base<std::_Vector_const_iterator<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> > >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@V?$_Vector_const_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@PAPAVHardwarePixelBuffer@Ogre@@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@0@AAPAPAVHardwarePixelBuffer@Ogre@@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@V?$_Vector_const_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@PAPAVHardwarePixelBuffer@Ogre@@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@0@AAPAPAVHardwarePixelBuffer@Ogre@@@Z PROC ; std::_Ptr_cat<std::_Vector_const_iterator<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >,Ogre::HardwarePixelBuffer * *>, COMDAT

; 1509 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 1512 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Ptr_cat@V?$_Vector_const_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@PAPAVHardwarePixelBuffer@Ogre@@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@0@AAPAPAVHardwarePixelBuffer@Ogre@@@Z ENDP ; std::_Ptr_cat<std::_Vector_const_iterator<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >,Ogre::HardwarePixelBuffer * *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@PBQAVHardwarePixelBuffer@Ogre@@PAPAV12@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@YAPAPAVHardwarePixelBuffer@Ogre@@PBQAV12@0PAPAV12@AAV?$allocator@PAVHardwarePixelBuffer@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Result$ = -8						; size = 4
__Count$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PBQAVHardwarePixelBuffer@Ogre@@PAPAV12@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@YAPAPAVHardwarePixelBuffer@Ogre@@PBQAV12@0PAPAV12@AAV?$allocator@PAVHardwarePixelBuffer@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<Ogre::HardwarePixelBuffer * const *,Ogre::HardwarePixelBuffer * *,std::allocator<Ogre::HardwarePixelBuffer *> >, COMDAT

; 145  : 	{	// copy [_First, _Last) to raw _Dest, scalar type

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 146  : 	_DEBUG_RANGE(_First, _Last);
; 147  : 	_DEBUG_POINTER(_Dest);
; 148  : 	size_t _Count = (size_t)(_Last - _First);

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 2
	mov	DWORD PTR __Count$[ebp], eax

; 149  : 	_FwdIt _Result = _Dest + _Count;

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Dest$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR __Result$[ebp], eax

; 150  : 	if (_Count > 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN1@Uninit_cop@5

; 151  : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Count * sizeof (*_First), &*_First, _Count * sizeof (*_First));	// NB: non-overlapping move

	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN1@Uninit_cop@5:

; 152  : 	return (_Result);

	mov	eax, DWORD PTR __Result$[ebp]

; 153  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Uninit_copy@PBQAVHardwarePixelBuffer@Ogre@@PAPAV12@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@YAPAPAVHardwarePixelBuffer@Ogre@@PBQAV12@0PAPAV12@AAV?$allocator@PAVHardwarePixelBuffer@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<Ogre::HardwarePixelBuffer * const *,Ogre::HardwarePixelBuffer * *,std::allocator<Ogre::HardwarePixelBuffer *> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Checked_base@PAPAVHardwarePixelBuffer@Ogre@@@std@@YAPAPAVHardwarePixelBuffer@Ogre@@AAPAPAV12@U_Unchanged_checked_iterator_base_type_tag@0@@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Checked_base@PAPAVHardwarePixelBuffer@Ogre@@@std@@YAPAPAVHardwarePixelBuffer@Ogre@@AAPAPAV12@U_Unchanged_checked_iterator_base_type_tag@0@@Z PROC ; std::_Checked_base<Ogre::HardwarePixelBuffer * *>, COMDAT

; 1146 : 	{

	push	ebp
	mov	ebp, esp

; 1147 : 		return _It;

	mov	eax, DWORD PTR __It$[ebp]
	mov	eax, DWORD PTR [eax]

; 1148 : 	}

	pop	ebp
	ret	0
??$_Checked_base@PAPAVHardwarePixelBuffer@Ogre@@@std@@YAPAPAVHardwarePixelBuffer@Ogre@@AAPAPAV12@U_Unchanged_checked_iterator_base_type_tag@0@@Z ENDP ; std::_Checked_base<Ogre::HardwarePixelBuffer * *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@PAPAVHardwarePixelBuffer@Ogre@@PAPAV12@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@YAPAPAVHardwarePixelBuffer@Ogre@@PAPAV12@00AAV?$allocator@PAVHardwarePixelBuffer@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Result$ = -8						; size = 4
__Count$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PAPAVHardwarePixelBuffer@Ogre@@PAPAV12@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@YAPAPAVHardwarePixelBuffer@Ogre@@PAPAV12@00AAV?$allocator@PAVHardwarePixelBuffer@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<Ogre::HardwarePixelBuffer * *,Ogre::HardwarePixelBuffer * *,std::allocator<Ogre::HardwarePixelBuffer *> >, COMDAT

; 145  : 	{	// copy [_First, _Last) to raw _Dest, scalar type

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 146  : 	_DEBUG_RANGE(_First, _Last);
; 147  : 	_DEBUG_POINTER(_Dest);
; 148  : 	size_t _Count = (size_t)(_Last - _First);

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 2
	mov	DWORD PTR __Count$[ebp], eax

; 149  : 	_FwdIt _Result = _Dest + _Count;

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Dest$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR __Result$[ebp], eax

; 150  : 	if (_Count > 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN1@Uninit_cop@6

; 151  : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Count * sizeof (*_First), &*_First, _Count * sizeof (*_First));	// NB: non-overlapping move

	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN1@Uninit_cop@6:

; 152  : 	return (_Result);

	mov	eax, DWORD PTR __Result$[ebp]

; 153  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Uninit_copy@PAPAVHardwarePixelBuffer@Ogre@@PAPAV12@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@YAPAPAVHardwarePixelBuffer@Ogre@@PAPAV12@00AAV?$allocator@PAVHardwarePixelBuffer@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<Ogre::HardwarePixelBuffer * *,Ogre::HardwarePixelBuffer * *,std::allocator<Ogre::HardwarePixelBuffer *> >
_TEXT	ENDS
PUBLIC	??$_Fill_n@PAPAVHardwarePixelBuffer@Ogre@@IPAV12@@std@@YAXPAPAVHardwarePixelBuffer@Ogre@@IABQAV12@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Fill_n<Ogre::HardwarePixelBuffer * *,unsigned int,Ogre::HardwarePixelBuffer *>
PUBLIC	??$_Iter_cat@PAPAVHardwarePixelBuffer@Ogre@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVHardwarePixelBuffer@Ogre@@@Z ; std::_Iter_cat<Ogre::HardwarePixelBuffer * *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$unchecked_fill_n@PAPAVHardwarePixelBuffer@Ogre@@IPAV12@@stdext@@YAXPAPAVHardwarePixelBuffer@Ogre@@IABQAV12@@Z
_TEXT	SEGMENT
$T73741 = -2						; size = 1
$T73740 = -1						; size = 1
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
??$unchecked_fill_n@PAPAVHardwarePixelBuffer@Ogre@@IPAV12@@stdext@@YAXPAPAVHardwarePixelBuffer@Ogre@@IABQAV12@@Z PROC ; stdext::unchecked_fill_n<Ogre::HardwarePixelBuffer * *,unsigned int,Ogre::HardwarePixelBuffer *>, COMDAT

; 3720 : 	{	// copy _Val _Count times through [_First, ...)

	push	ebp
	mov	ebp, esp
	push	ecx

; 3721 : 		_STD _Fill_n(_First, _Count, _Val, _STD _Iter_cat(_First), _STD _Range_checked_iterator_tag());

	xor	eax, eax
	mov	BYTE PTR $T73740[ebp], al
	movzx	ecx, BYTE PTR $T73740[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	lea	eax, DWORD PTR $T73741[ebp]
	push	eax
	call	??$_Iter_cat@PAPAVHardwarePixelBuffer@Ogre@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVHardwarePixelBuffer@Ogre@@@Z ; std::_Iter_cat<Ogre::HardwarePixelBuffer * *>
	add	esp, 8
	movzx	ecx, BYTE PTR [eax]
	push	ecx
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Fill_n@PAPAVHardwarePixelBuffer@Ogre@@IPAV12@@std@@YAXPAPAVHardwarePixelBuffer@Ogre@@IABQAV12@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Fill_n<Ogre::HardwarePixelBuffer * *,unsigned int,Ogre::HardwarePixelBuffer *>
	add	esp, 20					; 00000014H

; 3722 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_fill_n@PAPAVHardwarePixelBuffer@Ogre@@IPAV12@@stdext@@YAXPAPAVHardwarePixelBuffer@Ogre@@IABQAV12@@Z ENDP ; stdext::unchecked_fill_n<Ogre::HardwarePixelBuffer * *,unsigned int,Ogre::HardwarePixelBuffer *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$_Uninit_move@PAPAVHardwarePixelBuffer@Ogre@@PAPAV12@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@U_Undefined_move_tag@4@@std@@YAPAPAVHardwarePixelBuffer@Ogre@@PAPAV12@00AAV?$allocator@PAVHardwarePixelBuffer@Ogre@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_move@PAPAVHardwarePixelBuffer@Ogre@@PAPAV12@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@U_Undefined_move_tag@4@@std@@YAPAPAVHardwarePixelBuffer@Ogre@@PAPAV12@00AAV?$allocator@PAVHardwarePixelBuffer@Ogre@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_move<Ogre::HardwarePixelBuffer * *,Ogre::HardwarePixelBuffer * *,std::allocator<Ogre::HardwarePixelBuffer *>,std::_Undefined_move_tag>, COMDAT

; 206  : 	{	// move defaults to copy if there is not a more effecient way

	push	ebp
	mov	ebp, esp

; 207  : 	return (_STDEXT unchecked_uninitialized_copy(_First, _Last, _Dest, _Al));

	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$unchecked_uninitialized_copy@PAPAVHardwarePixelBuffer@Ogre@@PAPAV12@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@stdext@@YAPAPAVHardwarePixelBuffer@Ogre@@PAPAV12@00AAV?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@Z ; stdext::unchecked_uninitialized_copy<Ogre::HardwarePixelBuffer * *,Ogre::HardwarePixelBuffer * *,std::allocator<Ogre::HardwarePixelBuffer *> >
	add	esp, 16					; 00000010H

; 208  : 	}

	pop	ebp
	ret	0
??$_Uninit_move@PAPAVHardwarePixelBuffer@Ogre@@PAPAV12@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@U_Undefined_move_tag@4@@std@@YAPAPAVHardwarePixelBuffer@Ogre@@PAPAV12@00AAV?$allocator@PAVHardwarePixelBuffer@Ogre@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_move<Ogre::HardwarePixelBuffer * *,Ogre::HardwarePixelBuffer * *,std::allocator<Ogre::HardwarePixelBuffer *>,std::_Undefined_move_tag>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Copy_backward_opt@PAPAVHardwarePixelBuffer@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@@std@@YAPAPAVHardwarePixelBuffer@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Off$ = -8						; size = 4
__Result$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_backward_opt@PAPAVHardwarePixelBuffer@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@@std@@YAPAPAVHardwarePixelBuffer@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<Ogre::HardwarePixelBuffer * *,Ogre::HardwarePixelBuffer * *,std::random_access_iterator_tag>, COMDAT

; 2698 : 	{	// copy [_First, _Last) backwards to [..., _Dest), pointers to scalars

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 2699 : 
; 2700 :  #if _HAS_ITERATOR_DEBUGGING
; 2701 : 	_DEBUG_RANGE(_First, _Last);
; 2702 : 	if (_First != _Last)
; 2703 : 		_DEBUG_POINTER(_Dest);
; 2704 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2705 : 
; 2706 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 2
	mov	DWORD PTR __Off$[ebp], eax

; 2707 : 	/* if _OutIt is range checked, this will make sure there is enough space for 
; 2708 : 	 * the memmove
; 2709 : 	 */
; 2710 : 	_OutIt _Result = _Dest - _Off;

	mov	ecx, DWORD PTR __Off$[ebp]
	shl	ecx, 2
	mov	edx, DWORD PTR __Dest$[ebp]
	sub	edx, ecx
	mov	DWORD PTR __Result$[ebp], edx

; 2711 : 	if (_Off > 0)

	cmp	DWORD PTR __Off$[ebp], 0
	jle	SHORT $LN1@Copy_backw

; 2712 : 		_CRT_SECURE_MEMMOVE(&*_Result, _Off * sizeof (*_First), &*_First, _Off * sizeof (*_First));

	mov	eax, DWORD PTR __Off$[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Off$[ebp]
	shl	edx, 2
	push	edx
	mov	eax, DWORD PTR __Result$[ebp]
	push	eax
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN1@Copy_backw:

; 2713 : 	return _Result;

	mov	eax, DWORD PTR __Result$[ebp]

; 2714 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Copy_backward_opt@PAPAVHardwarePixelBuffer@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@@std@@YAPAPAVHardwarePixelBuffer@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<Ogre::HardwarePixelBuffer * *,Ogre::HardwarePixelBuffer * *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	?_Checked_iterator_base@?$_Vector_const_iterator@DV?$allocator@D@std@@@std@@QBEPBDXZ ; std::_Vector_const_iterator<char,std::allocator<char> >::_Checked_iterator_base
; Function compile flags: /Odtp
;	COMDAT ??$_Checked_base@V?$_Vector_const_iterator@DV?$allocator@D@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBDAAV?$_Vector_const_iterator@DV?$allocator@D@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Checked_base@V?$_Vector_const_iterator@DV?$allocator@D@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBDAAV?$_Vector_const_iterator@DV?$allocator@D@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z PROC ; std::_Checked_base<std::_Vector_const_iterator<char,std::allocator<char> >,std::_Different_checked_iterator_base_type_tag>, COMDAT

; 1138 : 	{

	push	ebp
	mov	ebp, esp

; 1139 : 		return _It._Checked_iterator_base();

	mov	ecx, DWORD PTR __It$[ebp]
	call	?_Checked_iterator_base@?$_Vector_const_iterator@DV?$allocator@D@std@@@std@@QBEPBDXZ ; std::_Vector_const_iterator<char,std::allocator<char> >::_Checked_iterator_base

; 1140 : 	}

	pop	ebp
	ret	0
??$_Checked_base@V?$_Vector_const_iterator@DV?$allocator@D@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBDAAV?$_Vector_const_iterator@DV?$allocator@D@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z ENDP ; std::_Checked_base<std::_Vector_const_iterator<char,std::allocator<char> >,std::_Different_checked_iterator_base_type_tag>
_TEXT	ENDS
PUBLIC	?_Checked_iterator_base@?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QBEPBQAVSurfaceData@Ogre@@XZ ; std::_Vector_const_iterator<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::_Checked_iterator_base
; Function compile flags: /Odtp
;	COMDAT ??$_Checked_base@V?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBQAVSurfaceData@Ogre@@AAV?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Checked_base@V?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBQAVSurfaceData@Ogre@@AAV?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z PROC ; std::_Checked_base<std::_Vector_const_iterator<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >,std::_Different_checked_iterator_base_type_tag>, COMDAT

; 1138 : 	{

	push	ebp
	mov	ebp, esp

; 1139 : 		return _It._Checked_iterator_base();

	mov	ecx, DWORD PTR __It$[ebp]
	call	?_Checked_iterator_base@?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QBEPBQAVSurfaceData@Ogre@@XZ ; std::_Vector_const_iterator<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::_Checked_iterator_base

; 1140 : 	}

	pop	ebp
	ret	0
??$_Checked_base@V?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBQAVSurfaceData@Ogre@@AAV?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z ENDP ; std::_Checked_base<std::_Vector_const_iterator<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >,std::_Different_checked_iterator_base_type_tag>
_TEXT	ENDS
PUBLIC	?_Checked_iterator_base@?$_Vector_const_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QBEPBQAVHardwarePixelBuffer@Ogre@@XZ ; std::_Vector_const_iterator<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::_Checked_iterator_base
; Function compile flags: /Odtp
;	COMDAT ??$_Checked_base@V?$_Vector_const_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBQAVHardwarePixelBuffer@Ogre@@AAV?$_Vector_const_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Checked_base@V?$_Vector_const_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBQAVHardwarePixelBuffer@Ogre@@AAV?$_Vector_const_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z PROC ; std::_Checked_base<std::_Vector_const_iterator<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >,std::_Different_checked_iterator_base_type_tag>, COMDAT

; 1138 : 	{

	push	ebp
	mov	ebp, esp

; 1139 : 		return _It._Checked_iterator_base();

	mov	ecx, DWORD PTR __It$[ebp]
	call	?_Checked_iterator_base@?$_Vector_const_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QBEPBQAVHardwarePixelBuffer@Ogre@@XZ ; std::_Vector_const_iterator<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::_Checked_iterator_base

; 1140 : 	}

	pop	ebp
	ret	0
??$_Checked_base@V?$_Vector_const_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBQAVHardwarePixelBuffer@Ogre@@AAV?$_Vector_const_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z ENDP ; std::_Checked_base<std::_Vector_const_iterator<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >,std::_Different_checked_iterator_base_type_tag>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Iter_cat@PAPAVHardwarePixelBuffer@Ogre@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVHardwarePixelBuffer@Ogre@@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??$_Iter_cat@PAPAVHardwarePixelBuffer@Ogre@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVHardwarePixelBuffer@Ogre@@@Z PROC ; std::_Iter_cat<Ogre::HardwarePixelBuffer * *>, COMDAT

; 952  : 	{	// return category from iterator argument

	push	ebp
	mov	ebp, esp
	push	ecx

; 953  : 	typename iterator_traits<_Iter>::iterator_category _Cat;
; 954  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 955  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Iter_cat@PAPAVHardwarePixelBuffer@Ogre@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVHardwarePixelBuffer@Ogre@@@Z ENDP ; std::_Iter_cat<Ogre::HardwarePixelBuffer * *>
_TEXT	ENDS
PUBLIC	??$_Fill_n@PAPAVHardwarePixelBuffer@Ogre@@IPAV12@@std@@YAXPAPAVHardwarePixelBuffer@Ogre@@IABQAV12@U_Range_checked_iterator_tag@0@@Z ; std::_Fill_n<Ogre::HardwarePixelBuffer * *,unsigned int,Ogre::HardwarePixelBuffer *>
; Function compile flags: /Odtp
;	COMDAT ??$_Fill_n@PAPAVHardwarePixelBuffer@Ogre@@IPAV12@@std@@YAXPAPAVHardwarePixelBuffer@Ogre@@IABQAV12@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T73756 = -5						; size = 1
__Last$ = -4						; size = 4
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
??$_Fill_n@PAPAVHardwarePixelBuffer@Ogre@@IPAV12@@std@@YAXPAPAVHardwarePixelBuffer@Ogre@@IABQAV12@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Fill_n<Ogre::HardwarePixelBuffer * *,unsigned int,Ogre::HardwarePixelBuffer *>, COMDAT

; 3250 : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 3251 : 		// if _OutIt is checked, this will ensure we have enough space
; 3252 : 		_OutIt _Last = _First + _Count; (_Last);

	mov	eax, DWORD PTR __Count$[ebp]
	mov	ecx, DWORD PTR __First$[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR __Last$[ebp], edx

; 3253 : 		_Fill_n(_CHECKED_BASE(_First), _Count, _Val,
; 3254 : 			_Range_checked_iterator_tag());

	xor	eax, eax
	mov	BYTE PTR $T73756[ebp], al
	movzx	ecx, BYTE PTR $T73756[ebp]
	push	ecx
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Checked_base@PAPAVHardwarePixelBuffer@Ogre@@@std@@YAPAPAVHardwarePixelBuffer@Ogre@@AAPAPAV12@@Z ; std::_Checked_base<Ogre::HardwarePixelBuffer * *>
	add	esp, 4
	push	eax
	call	??$_Fill_n@PAPAVHardwarePixelBuffer@Ogre@@IPAV12@@std@@YAXPAPAVHardwarePixelBuffer@Ogre@@IABQAV12@U_Range_checked_iterator_tag@0@@Z ; std::_Fill_n<Ogre::HardwarePixelBuffer * *,unsigned int,Ogre::HardwarePixelBuffer *>
	add	esp, 16					; 00000010H

; 3255 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Fill_n@PAPAVHardwarePixelBuffer@Ogre@@IPAV12@@std@@YAXPAPAVHardwarePixelBuffer@Ogre@@IABQAV12@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Fill_n<Ogre::HardwarePixelBuffer * *,unsigned int,Ogre::HardwarePixelBuffer *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?_Checked_iterator_base@?$_Vector_const_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QBEPBQAVHardwarePixelBuffer@Ogre@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Checked_iterator_base@?$_Vector_const_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QBEPBQAVHardwarePixelBuffer@Ogre@@XZ PROC ; std::_Vector_const_iterator<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::_Checked_iterator_base, COMDAT
; _this$ = ecx

; 46   : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 47   : 		return _Myptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 48   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Checked_iterator_base@?$_Vector_const_iterator@PAVHardwarePixelBuffer@Ogre@@V?$allocator@PAVHardwarePixelBuffer@Ogre@@@std@@@std@@QBEPBQAVHardwarePixelBuffer@Ogre@@XZ ENDP ; std::_Vector_const_iterator<Ogre::HardwarePixelBuffer *,std::allocator<Ogre::HardwarePixelBuffer *> >::_Checked_iterator_base
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Checked_iterator_base@?$_Vector_const_iterator@DV?$allocator@D@std@@@std@@QBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Checked_iterator_base@?$_Vector_const_iterator@DV?$allocator@D@std@@@std@@QBEPBDXZ PROC ; std::_Vector_const_iterator<char,std::allocator<char> >::_Checked_iterator_base, COMDAT
; _this$ = ecx

; 46   : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 47   : 		return _Myptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 48   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Checked_iterator_base@?$_Vector_const_iterator@DV?$allocator@D@std@@@std@@QBEPBDXZ ENDP ; std::_Vector_const_iterator<char,std::allocator<char> >::_Checked_iterator_base
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Checked_iterator_base@?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QBEPBQAVSurfaceData@Ogre@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Checked_iterator_base@?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QBEPBQAVSurfaceData@Ogre@@XZ PROC ; std::_Vector_const_iterator<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::_Checked_iterator_base, COMDAT
; _this$ = ecx

; 46   : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 47   : 		return _Myptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 48   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Checked_iterator_base@?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QBEPBQAVSurfaceData@Ogre@@XZ ENDP ; std::_Vector_const_iterator<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::_Checked_iterator_base
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Fill_n@PAPAVHardwarePixelBuffer@Ogre@@IPAV12@@std@@YAXPAPAVHardwarePixelBuffer@Ogre@@IABQAV12@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Fill_n@PAPAVHardwarePixelBuffer@Ogre@@IPAV12@@std@@YAXPAPAVHardwarePixelBuffer@Ogre@@IABQAV12@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Fill_n<Ogre::HardwarePixelBuffer * *,unsigned int,Ogre::HardwarePixelBuffer *>, COMDAT

; 3196 : 	{	// copy _Val _Count times through [_First, ...)

	push	ebp
	mov	ebp, esp

; 3197 : 	for (; 0 < _Count; --_Count, ++_First)

	jmp	SHORT $LN3@Fill_n
$LN2@Fill_n:
	mov	eax, DWORD PTR __Count$[ebp]
	sub	eax, 1
	mov	DWORD PTR __Count$[ebp], eax
	mov	ecx, DWORD PTR __First$[ebp]
	add	ecx, 4
	mov	DWORD PTR __First$[ebp], ecx
$LN3@Fill_n:
	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN4@Fill_n

; 3198 : 		*_First = _Val;

	mov	edx, DWORD PTR __First$[ebp]
	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	jmp	SHORT $LN2@Fill_n
$LN4@Fill_n:

; 3199 : 	}

	pop	ebp
	ret	0
??$_Fill_n@PAPAVHardwarePixelBuffer@Ogre@@IPAV12@@std@@YAXPAPAVHardwarePixelBuffer@Ogre@@IABQAV12@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Fill_n<Ogre::HardwarePixelBuffer * *,unsigned int,Ogre::HardwarePixelBuffer *>
_TEXT	ENDS
END

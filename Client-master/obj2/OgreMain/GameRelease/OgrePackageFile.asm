; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	i:\svnroot\client\OgreMain\OgrePackageFile.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	?_Value@?$_Is_swap_move@U_Swap_move_tag@std@@@std@@2_NB ; std::_Is_swap_move<std::_Swap_move_tag>::_Value
PUBLIC	?collate@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::collate
PUBLIC	?ctype@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::ctype
PUBLIC	?monetary@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::monetary
PUBLIC	?numeric@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::numeric
PUBLIC	?time@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::time
PUBLIC	?messages@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::messages
PUBLIC	?all@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::all
PUBLIC	?none@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::none
PUBLIC	?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::skipws
PUBLIC	?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::unitbuf
PUBLIC	?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::uppercase
PUBLIC	?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showbase
PUBLIC	?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpoint
PUBLIC	?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpos
PUBLIC	?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::left
PUBLIC	?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::right
PUBLIC	?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::internal
PUBLIC	?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::dec
PUBLIC	?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::oct
PUBLIC	?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::hex
PUBLIC	?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::scientific
PUBLIC	?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::fixed
PUBLIC	?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::hexfloat
PUBLIC	?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::boolalpha
PUBLIC	?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::_Stdio
PUBLIC	?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::adjustfield
PUBLIC	?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::basefield
PUBLIC	?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::floatfield
PUBLIC	?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::goodbit
PUBLIC	?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::eofbit
PUBLIC	?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::failbit
PUBLIC	?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::badbit
PUBLIC	?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::_Hardfail
PUBLIC	?in@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::in
PUBLIC	?out@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::out
PUBLIC	?ate@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::ate
PUBLIC	?app@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::app
PUBLIC	?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::trunc
PUBLIC	?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Nocreate
PUBLIC	?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Noreplace
PUBLIC	?binary@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::binary
PUBLIC	?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::beg
PUBLIC	?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::cur
PUBLIC	?end@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::end
PUBLIC	?value@?$integral_constant@_N$0A@@tr1@std@@2_NB	; std::tr1::integral_constant<bool,0>::value
PUBLIC	?value@?$integral_constant@_N$00@tr1@std@@2_NB	; std::tr1::integral_constant<bool,1>::value
;	COMDAT ?value@?$integral_constant@_N$00@tr1@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$00@tr1@std@@2_NB DB 01H	; std::tr1::integral_constant<bool,1>::value
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$0A@@tr1@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$0A@@tr1@std@@2_NB DB 00H	; std::tr1::integral_constant<bool,0>::value
CONST	ENDS
;	COMDAT ?end@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?end@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 02H		; std::_Iosb<int>::end
CONST	ENDS
;	COMDAT ?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 01H		; std::_Iosb<int>::cur
CONST	ENDS
;	COMDAT ?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 00H		; std::_Iosb<int>::beg
CONST	ENDS
;	COMDAT ?binary@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?binary@?$_Iosb@H@std@@2W4_Openmode@12@B DD 020H	; std::_Iosb<int>::binary
CONST	ENDS
;	COMDAT ?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B DD 080H	; std::_Iosb<int>::_Noreplace
CONST	ENDS
;	COMDAT ?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 040H	; std::_Iosb<int>::_Nocreate
CONST	ENDS
;	COMDAT ?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B DD 010H		; std::_Iosb<int>::trunc
CONST	ENDS
;	COMDAT ?app@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?app@?$_Iosb@H@std@@2W4_Openmode@12@B DD 08H		; std::_Iosb<int>::app
CONST	ENDS
;	COMDAT ?ate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?ate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 04H		; std::_Iosb<int>::ate
CONST	ENDS
;	COMDAT ?out@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?out@?$_Iosb@H@std@@2W4_Openmode@12@B DD 02H		; std::_Iosb<int>::out
CONST	ENDS
;	COMDAT ?in@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?in@?$_Iosb@H@std@@2W4_Openmode@12@B DD 01H		; std::_Iosb<int>::in
CONST	ENDS
;	COMDAT ?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B DD 010H	; std::_Iosb<int>::_Hardfail
CONST	ENDS
;	COMDAT ?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 04H		; std::_Iosb<int>::badbit
CONST	ENDS
;	COMDAT ?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 02H		; std::_Iosb<int>::failbit
CONST	ENDS
;	COMDAT ?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 01H		; std::_Iosb<int>::eofbit
CONST	ENDS
;	COMDAT ?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 00H		; std::_Iosb<int>::goodbit
CONST	ENDS
;	COMDAT ?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 03000H	; std::_Iosb<int>::floatfield
CONST	ENDS
;	COMDAT ?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0e00H	; std::_Iosb<int>::basefield
CONST	ENDS
;	COMDAT ?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01c0H	; std::_Iosb<int>::adjustfield
CONST	ENDS
;	COMDAT ?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08000H	; std::_Iosb<int>::_Stdio
CONST	ENDS
;	COMDAT ?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04000H	; std::_Iosb<int>::boolalpha
CONST	ENDS
;	COMDAT ?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 03000H	; std::_Iosb<int>::hexfloat
CONST	ENDS
;	COMDAT ?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02000H	; std::_Iosb<int>::fixed
CONST	ENDS
;	COMDAT ?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01000H	; std::_Iosb<int>::scientific
CONST	ENDS
;	COMDAT ?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0800H		; std::_Iosb<int>::hex
CONST	ENDS
;	COMDAT ?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0400H		; std::_Iosb<int>::oct
CONST	ENDS
;	COMDAT ?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0200H		; std::_Iosb<int>::dec
CONST	ENDS
;	COMDAT ?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0100H	; std::_Iosb<int>::internal
CONST	ENDS
;	COMDAT ?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 080H		; std::_Iosb<int>::right
CONST	ENDS
;	COMDAT ?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 040H		; std::_Iosb<int>::left
CONST	ENDS
;	COMDAT ?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 020H	; std::_Iosb<int>::showpos
CONST	ENDS
;	COMDAT ?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 010H	; std::_Iosb<int>::showpoint
CONST	ENDS
;	COMDAT ?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08H	; std::_Iosb<int>::showbase
CONST	ENDS
;	COMDAT ?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04H	; std::_Iosb<int>::uppercase
CONST	ENDS
;	COMDAT ?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02H	; std::_Iosb<int>::unitbuf
CONST	ENDS
;	COMDAT ?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01H		; std::_Iosb<int>::skipws
CONST	ENDS
;	COMDAT ?none@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?none@?$_Locbase@H@std@@2HB DD 00H			; std::_Locbase<int>::none
CONST	ENDS
;	COMDAT ?all@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?all@?$_Locbase@H@std@@2HB DD 03fH			; std::_Locbase<int>::all
CONST	ENDS
;	COMDAT ?messages@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?messages@?$_Locbase@H@std@@2HB DD 020H			; std::_Locbase<int>::messages
CONST	ENDS
;	COMDAT ?time@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?time@?$_Locbase@H@std@@2HB DD 010H			; std::_Locbase<int>::time
CONST	ENDS
;	COMDAT ?numeric@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?numeric@?$_Locbase@H@std@@2HB DD 08H			; std::_Locbase<int>::numeric
CONST	ENDS
;	COMDAT ?monetary@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?monetary@?$_Locbase@H@std@@2HB DD 04H			; std::_Locbase<int>::monetary
CONST	ENDS
;	COMDAT ?ctype@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?ctype@?$_Locbase@H@std@@2HB DD 02H			; std::_Locbase<int>::ctype
CONST	ENDS
;	COMDAT ?collate@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?collate@?$_Locbase@H@std@@2HB DD 01H			; std::_Locbase<int>::collate
CONST	ENDS
;	COMDAT ?_Value@?$_Is_swap_move@U_Swap_move_tag@std@@@std@@2_NB
CONST	SEGMENT
?_Value@?$_Is_swap_move@U_Swap_move_tag@std@@@std@@2_NB DB 01H ; std::_Is_swap_move<std::_Swap_move_tag>::_Value
CONST	ENDS
_DATA	SEGMENT
__bad_alloc_Message DD FLAT:$SG5713
_DATA	ENDS
CONST	SEGMENT
$SG5713	DB	'bad allocation', 00H
	ORG $+1
$SG116374 DB	'wb', 00H
	ORG $+1
$SG116378 DB	'.\OgrePackageFile.cpp', 00H
	ORG $+2
$SG116379 DB	'write pkgfile error', 00H
$SG116414 DB	'rb', 00H
	ORG $+1
$SG116415 DB	'r+b', 00H
$SG116418 DB	'.\OgrePackageFile.cpp', 00H
	ORG $+2
$SG116419 DB	'open pkgfile error: %s', 00H
	ORG $+1
$SG116422 DB	'r+b', 00H
$SG116425 DB	'.\OgrePackageFile.cpp', 00H
	ORG $+2
$SG116426 DB	'read pkgfile error: %s', 00H
	ORG $+1
$SG116430 DB	'.\OgrePackageFile.cpp', 00H
	ORG $+2
$SG116431 DB	'read pkgfile error: %s', 00H
	ORG $+1
$SG116445 DB	'.\OgrePackageFile.cpp', 00H
	ORG $+2
$SG116446 DB	'write pkgfile error', 00H
$SG116448 DB	'.\OgrePackageFile.cpp', 00H
	ORG $+2
$SG116449 DB	'write pkgfile error', 00H
$SG116554 DB	'.\OgrePackageFile.cpp', 00H
	ORG $+2
$SG116555 DB	'openFile wrong file_number:%d', 00H
	ORG $+2
$SG116571 DB	'.\OgrePackageFile.cpp', 00H
	ORG $+2
$SG116572 DB	'read pkgfile error: %d,%d', 00H
	ORG $+2
$SG116578 DB	'.\OgrePackageFile.cpp', 00H
	ORG $+2
$SG116579 DB	'uncompress data error: %d, %d', 00H
	ORG $+2
$SG116613 DB	'.\OgrePackageFile.cpp', 00H
	ORG $+2
$SG116614 DB	'compress error', 00H
	ORG $+1
$SG116621 DB	'.\OgrePackageFile.cpp', 00H
	ORG $+2
$SG116622 DB	'write pkgfile error: %d, %d', 00H
$SG116638 DB	'rb', 00H
CONST	ENDS
PUBLIC	??_7DataStream@Ogre@@6B@			; Ogre::DataStream::`vftable'
PUBLIC	??0DataStream@Ogre@@QAE@XZ			; Ogre::DataStream::DataStream
PUBLIC	??_R4DataStream@Ogre@@6B@			; Ogre::DataStream::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVDataStream@Ogre@@@8			; Ogre::DataStream `RTTI Type Descriptor'
PUBLIC	??_R3DataStream@Ogre@@8				; Ogre::DataStream::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2DataStream@Ogre@@8				; Ogre::DataStream::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@DataStream@Ogre@@8		; Ogre::DataStream::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_EDataStream@Ogre@@UAEPAXI@Z			; Ogre::DataStream::`vector deleting destructor'
PUBLIC	?size@DataStream@Ogre@@UBEIXZ			; Ogre::DataStream::size
EXTRN	__imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:PROC
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:PROC
EXTRN	___security_cookie:DWORD
EXTRN	___CxxFrameHandler3:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	__purecall:PROC
EXTRN	?readLine@DataStream@Ogre@@UAEIPADIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z:PROC ; Ogre::DataStream::readLine
EXTRN	?getLine@DataStream@Ogre@@UAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z:PROC ; Ogre::DataStream::getLine
EXTRN	?getAsString@DataStream@Ogre@@UAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ:PROC ; Ogre::DataStream::getAsString
EXTRN	?skipLine@DataStream@Ogre@@UAEIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z:PROC ; Ogre::DataStream::skipLine
;	COMDAT ??_R1A@?0A@EA@DataStream@Ogre@@8
; File i:\svnroot\client\ogremain\ogredatastream.h
rdata$r	SEGMENT
??_R1A@?0A@EA@DataStream@Ogre@@8 DD FLAT:??_R0?AVDataStream@Ogre@@@8 ; Ogre::DataStream::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3DataStream@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R2DataStream@Ogre@@8
rdata$r	SEGMENT
??_R2DataStream@Ogre@@8 DD FLAT:??_R1A@?0A@EA@DataStream@Ogre@@8 ; Ogre::DataStream::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3DataStream@Ogre@@8
rdata$r	SEGMENT
??_R3DataStream@Ogre@@8 DD 00H				; Ogre::DataStream::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2DataStream@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVDataStream@Ogre@@@8
_DATA	SEGMENT
??_R0?AVDataStream@Ogre@@@8 DD FLAT:??_7type_info@@6B@	; Ogre::DataStream `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVDataStream@Ogre@@', 00H
_DATA	ENDS
;	COMDAT ??_R4DataStream@Ogre@@6B@
rdata$r	SEGMENT
??_R4DataStream@Ogre@@6B@ DD 00H			; Ogre::DataStream::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVDataStream@Ogre@@@8
	DD	FLAT:??_R3DataStream@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_7DataStream@Ogre@@6B@
CONST	SEGMENT
??_7DataStream@Ogre@@6B@ DD FLAT:??_R4DataStream@Ogre@@6B@ ; Ogre::DataStream::`vftable'
	DD	FLAT:??_EDataStream@Ogre@@UAEPAXI@Z
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:?readLine@DataStream@Ogre@@UAEIPADIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	FLAT:?getLine@DataStream@Ogre@@UAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z
	DD	FLAT:?getAsString@DataStream@Ogre@@UAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
	DD	FLAT:?skipLine@DataStream@Ogre@@UAEIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:?size@DataStream@Ogre@@UBEIXZ
	DD	FLAT:__purecall
	DD	FLAT:__purecall
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0DataStream@Ogre@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0DataStream@Ogre@@QAE@XZ$0
__ehfuncinfo$??0DataStream@Ogre@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0DataStream@Ogre@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0DataStream@Ogre@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0DataStream@Ogre@@QAE@XZ PROC				; Ogre::DataStream::DataStream, COMDAT
; _this$ = ecx

; 68   : 		DataStream() : mSize(0) {}

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0DataStream@Ogre@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7DataStream@Ogre@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+32], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0DataStream@Ogre@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$??0DataStream@Ogre@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0DataStream@Ogre@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0DataStream@Ogre@@QAE@XZ ENDP				; Ogre::DataStream::DataStream
PUBLIC	??0DataStream@Ogre@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Ogre::DataStream::DataStream
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0DataStream@Ogre@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0DataStream@Ogre@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$0
__ehfuncinfo$??0DataStream@Ogre@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0DataStream@Ogre@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0DataStream@Ogre@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_name$ = 8						; size = 4
??0DataStream@Ogre@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; Ogre::DataStream::DataStream, COMDAT
; _this$ = ecx

; 70   : 		DataStream(const String& name) : mName(name), mSize(0) {}

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0DataStream@Ogre@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7DataStream@Ogre@@6B@
	mov	ecx, DWORD PTR _name$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+32], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0DataStream@Ogre@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$??0DataStream@Ogre@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0DataStream@Ogre@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0DataStream@Ogre@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; Ogre::DataStream::DataStream
PUBLIC	?getName@DataStream@Ogre@@QAEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ; Ogre::DataStream::getName
; Function compile flags: /Odtp
;	COMDAT ?getName@DataStream@Ogre@@QAEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getName@DataStream@Ogre@@QAEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ PROC ; Ogre::DataStream::getName, COMDAT
; _this$ = ecx

; 72   : 		const String& getName(void) { return mName; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4
	mov	esp, ebp
	pop	ebp
	ret	0
?getName@DataStream@Ogre@@QAEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ENDP ; Ogre::DataStream::getName
_TEXT	ENDS
PUBLIC	??1DataStream@Ogre@@UAE@XZ			; Ogre::DataStream::~DataStream
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1DataStream@Ogre@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1DataStream@Ogre@@UAE@XZ$0
__ehfuncinfo$??1DataStream@Ogre@@UAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1DataStream@Ogre@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1DataStream@Ogre@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1DataStream@Ogre@@UAE@XZ PROC				; Ogre::DataStream::~DataStream, COMDAT
; _this$ = ecx

; 73   : 		virtual ~DataStream() {}

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1DataStream@Ogre@@UAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7DataStream@Ogre@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1DataStream@Ogre@@UAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$??1DataStream@Ogre@@UAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1DataStream@Ogre@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1DataStream@Ogre@@UAE@XZ ENDP				; Ogre::DataStream::~DataStream
; Function compile flags: /Odtp
;	COMDAT ?size@DataStream@Ogre@@UBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@DataStream@Ogre@@UBEIXZ PROC			; Ogre::DataStream::size, COMDAT
; _this$ = ecx

; 157  : 		virtual size_t size(void) const { return mSize; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+32]
	mov	esp, ebp
	pop	ebp
	ret	0
?size@DataStream@Ogre@@UBEIXZ ENDP			; Ogre::DataStream::size
_TEXT	ENDS
PUBLIC	??0DataStream@Ogre@@QAE@ABV01@@Z		; Ogre::DataStream::DataStream
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0DataStream@Ogre@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0DataStream@Ogre@@QAE@ABV01@@Z$0
__ehfuncinfo$??0DataStream@Ogre@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0DataStream@Ogre@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0DataStream@Ogre@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0DataStream@Ogre@@QAE@ABV01@@Z PROC			; Ogre::DataStream::DataStream, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0DataStream@Ogre@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7DataStream@Ogre@@6B@
	mov	ecx, DWORD PTR ___that$[ebp]
	add	ecx, 4
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	DWORD PTR [edx+32], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0DataStream@Ogre@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$??0DataStream@Ogre@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0DataStream@Ogre@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0DataStream@Ogre@@QAE@ABV01@@Z ENDP			; Ogre::DataStream::DataStream
PUBLIC	??4DataStream@Ogre@@QAEAAV01@ABV01@@Z		; Ogre::DataStream::operator=
EXTRN	__imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z:PROC
; Function compile flags: /Odtp
;	COMDAT ??4DataStream@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4DataStream@Ogre@@QAEAAV01@ABV01@@Z PROC		; Ogre::DataStream::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	DWORD PTR [ecx+32], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4DataStream@Ogre@@QAEAAV01@ABV01@@Z ENDP		; Ogre::DataStream::operator=
_TEXT	ENDS
PUBLIC	??_GDataStream@Ogre@@UAEPAXI@Z			; Ogre::DataStream::`scalar deleting destructor'
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
; Function compile flags: /Odtp
;	COMDAT ??_GDataStream@Ogre@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GDataStream@Ogre@@UAEPAXI@Z PROC			; Ogre::DataStream::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1DataStream@Ogre@@UAE@XZ		; Ogre::DataStream::~DataStream
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GDataStream@Ogre@@UAEPAXI@Z ENDP			; Ogre::DataStream::`scalar deleting destructor'
_TEXT	ENDS
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
EXTRN	??_M@YGXPAXIHP6EX0@Z@Z:PROC			; `eh vector destructor iterator'
; Function compile flags: /Odtp
;	COMDAT ??_EDataStream@Ogre@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_EDataStream@Ogre@@UAEPAXI@Z PROC			; Ogre::DataStream::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 2
	je	SHORT $LN3@vector
	push	OFFSET ??1DataStream@Ogre@@UAE@XZ	; Ogre::DataStream::~DataStream
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx-4]
	push	edx
	push	36					; 00000024H
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??_M@YGXPAXIHP6EX0@Z@Z
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN2@vector
	mov	edx, DWORD PTR _this$[ebp]
	sub	edx, 4
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN2@vector:
	mov	eax, DWORD PTR _this$[ebp]
	sub	eax, 4
	jmp	SHORT $LN4@vector
$LN3@vector:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1DataStream@Ogre@@UAE@XZ		; Ogre::DataStream::~DataStream
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@vector
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@vector:
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector:
	mov	esp, ebp
	pop	ebp
	ret	4
??_EDataStream@Ogre@@UAEPAXI@Z ENDP			; Ogre::DataStream::`vector deleting destructor'
_TEXT	ENDS
PUBLIC	?getPtr@MemoryDataStream@Ogre@@QAEPAEXZ		; Ogre::MemoryDataStream::getPtr
; Function compile flags: /Odtp
;	COMDAT ?getPtr@MemoryDataStream@Ogre@@QAEPAEXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getPtr@MemoryDataStream@Ogre@@QAEPAEXZ PROC		; Ogre::MemoryDataStream::getPtr, COMDAT
; _this$ = ecx

; 267  : 		uchar* getPtr(void) { return mData; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+36]
	mov	esp, ebp
	pop	ebp
	ret	0
?getPtr@MemoryDataStream@Ogre@@QAEPAEXZ ENDP		; Ogre::MemoryDataStream::getPtr
_TEXT	ENDS
PUBLIC	?getCurrentPtr@MemoryDataStream@Ogre@@QAEPAEXZ	; Ogre::MemoryDataStream::getCurrentPtr
; Function compile flags: /Odtp
;	COMDAT ?getCurrentPtr@MemoryDataStream@Ogre@@QAEPAEXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getCurrentPtr@MemoryDataStream@Ogre@@QAEPAEXZ PROC	; Ogre::MemoryDataStream::getCurrentPtr, COMDAT
; _this$ = ecx

; 270  : 		uchar* getCurrentPtr(void) { return mPos; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+40]
	mov	esp, ebp
	pop	ebp
	ret	0
?getCurrentPtr@MemoryDataStream@Ogre@@QAEPAEXZ ENDP	; Ogre::MemoryDataStream::getCurrentPtr
_TEXT	ENDS
PUBLIC	?getMemoryImage@MemoryDataStream@Ogre@@UAEPAXXZ	; Ogre::MemoryDataStream::getMemoryImage
; Function compile flags: /Odtp
;	COMDAT ?getMemoryImage@MemoryDataStream@Ogre@@UAEPAXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getMemoryImage@MemoryDataStream@Ogre@@UAEPAXXZ PROC	; Ogre::MemoryDataStream::getMemoryImage, COMDAT
; _this$ = ecx

; 307  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 308  : 			return mData;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+36]

; 309  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?getMemoryImage@MemoryDataStream@Ogre@@UAEPAXXZ ENDP	; Ogre::MemoryDataStream::getMemoryImage
_TEXT	ENDS
PUBLIC	?setFreeOnClose@MemoryDataStream@Ogre@@QAEXP6AXPAX@Z@Z ; Ogre::MemoryDataStream::setFreeOnClose
; Function compile flags: /Odtp
;	COMDAT ?setFreeOnClose@MemoryDataStream@Ogre@@QAEXP6AXPAX@Z@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_freeOnClose$ = 8					; size = 4
?setFreeOnClose@MemoryDataStream@Ogre@@QAEXP6AXPAX@Z@Z PROC ; Ogre::MemoryDataStream::setFreeOnClose, COMDAT
; _this$ = ecx

; 313  : 		void setFreeOnClose(void (*freeOnClose)(void *)) { mFreeOnClose = freeOnClose; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _freeOnClose$[ebp]
	mov	DWORD PTR [eax+48], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?setFreeOnClose@MemoryDataStream@Ogre@@QAEXP6AXPAX@Z@Z ENDP ; Ogre::MemoryDataStream::setFreeOnClose
_TEXT	ENDS
PUBLIC	??_7MemoryDataStream@Ogre@@6B@			; Ogre::MemoryDataStream::`vftable'
PUBLIC	??0MemoryDataStream@Ogre@@QAE@ABV01@@Z		; Ogre::MemoryDataStream::MemoryDataStream
PUBLIC	??_R4MemoryDataStream@Ogre@@6B@			; Ogre::MemoryDataStream::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVMemoryDataStream@Ogre@@@8		; Ogre::MemoryDataStream `RTTI Type Descriptor'
PUBLIC	??_R3MemoryDataStream@Ogre@@8			; Ogre::MemoryDataStream::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2MemoryDataStream@Ogre@@8			; Ogre::MemoryDataStream::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@MemoryDataStream@Ogre@@8		; Ogre::MemoryDataStream::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_EMemoryDataStream@Ogre@@UAEPAXI@Z		; Ogre::MemoryDataStream::`vector deleting destructor'
EXTRN	?read@MemoryDataStream@Ogre@@UAEIPAXI@Z:PROC	; Ogre::MemoryDataStream::read
EXTRN	?write@MemoryDataStream@Ogre@@UAEIPBXI@Z:PROC	; Ogre::MemoryDataStream::write
EXTRN	?readLine@MemoryDataStream@Ogre@@UAEIPADIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z:PROC ; Ogre::MemoryDataStream::readLine
EXTRN	?skipLine@MemoryDataStream@Ogre@@UAEIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z:PROC ; Ogre::MemoryDataStream::skipLine
EXTRN	?skip@MemoryDataStream@Ogre@@UAEXJ@Z:PROC	; Ogre::MemoryDataStream::skip
EXTRN	?seek@MemoryDataStream@Ogre@@UAEXI@Z:PROC	; Ogre::MemoryDataStream::seek
EXTRN	?tell@MemoryDataStream@Ogre@@UBEIXZ:PROC	; Ogre::MemoryDataStream::tell
EXTRN	?eof@MemoryDataStream@Ogre@@UBE_NXZ:PROC	; Ogre::MemoryDataStream::eof
EXTRN	?close@MemoryDataStream@Ogre@@UAEXXZ:PROC	; Ogre::MemoryDataStream::close
;	COMDAT ??_R1A@?0A@EA@MemoryDataStream@Ogre@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@MemoryDataStream@Ogre@@8 DD FLAT:??_R0?AVMemoryDataStream@Ogre@@@8 ; Ogre::MemoryDataStream::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3MemoryDataStream@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R2MemoryDataStream@Ogre@@8
rdata$r	SEGMENT
??_R2MemoryDataStream@Ogre@@8 DD FLAT:??_R1A@?0A@EA@MemoryDataStream@Ogre@@8 ; Ogre::MemoryDataStream::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@DataStream@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R3MemoryDataStream@Ogre@@8
rdata$r	SEGMENT
??_R3MemoryDataStream@Ogre@@8 DD 00H			; Ogre::MemoryDataStream::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2MemoryDataStream@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVMemoryDataStream@Ogre@@@8
_DATA	SEGMENT
??_R0?AVMemoryDataStream@Ogre@@@8 DD FLAT:??_7type_info@@6B@ ; Ogre::MemoryDataStream `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVMemoryDataStream@Ogre@@', 00H
_DATA	ENDS
;	COMDAT ??_R4MemoryDataStream@Ogre@@6B@
rdata$r	SEGMENT
??_R4MemoryDataStream@Ogre@@6B@ DD 00H			; Ogre::MemoryDataStream::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVMemoryDataStream@Ogre@@@8
	DD	FLAT:??_R3MemoryDataStream@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_7MemoryDataStream@Ogre@@6B@
CONST	SEGMENT
??_7MemoryDataStream@Ogre@@6B@ DD FLAT:??_R4MemoryDataStream@Ogre@@6B@ ; Ogre::MemoryDataStream::`vftable'
	DD	FLAT:??_EMemoryDataStream@Ogre@@UAEPAXI@Z
	DD	FLAT:?read@MemoryDataStream@Ogre@@UAEIPAXI@Z
	DD	FLAT:?write@MemoryDataStream@Ogre@@UAEIPBXI@Z
	DD	FLAT:?readLine@MemoryDataStream@Ogre@@UAEIPADIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	FLAT:?getLine@DataStream@Ogre@@UAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z
	DD	FLAT:?getAsString@DataStream@Ogre@@UAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
	DD	FLAT:?skipLine@MemoryDataStream@Ogre@@UAEIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	FLAT:?skip@MemoryDataStream@Ogre@@UAEXJ@Z
	DD	FLAT:?seek@MemoryDataStream@Ogre@@UAEXI@Z
	DD	FLAT:?tell@MemoryDataStream@Ogre@@UBEIXZ
	DD	FLAT:?eof@MemoryDataStream@Ogre@@UBE_NXZ
	DD	FLAT:?size@DataStream@Ogre@@UBEIXZ
	DD	FLAT:?close@MemoryDataStream@Ogre@@UAEXXZ
	DD	FLAT:?getMemoryImage@MemoryDataStream@Ogre@@UAEPAXXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0MemoryDataStream@Ogre@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0MemoryDataStream@Ogre@@QAE@ABV01@@Z$0
__ehfuncinfo$??0MemoryDataStream@Ogre@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0MemoryDataStream@Ogre@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0MemoryDataStream@Ogre@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0MemoryDataStream@Ogre@@QAE@ABV01@@Z PROC		; Ogre::MemoryDataStream::MemoryDataStream, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0MemoryDataStream@Ogre@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0DataStream@Ogre@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7MemoryDataStream@Ogre@@6B@
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR [edx+36], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	DWORD PTR [edx+40], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	DWORD PTR [edx+44], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	mov	DWORD PTR [edx+48], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0MemoryDataStream@Ogre@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1DataStream@Ogre@@UAE@XZ		; Ogre::DataStream::~DataStream
__ehhandler$??0MemoryDataStream@Ogre@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0MemoryDataStream@Ogre@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0MemoryDataStream@Ogre@@QAE@ABV01@@Z ENDP		; Ogre::MemoryDataStream::MemoryDataStream
PUBLIC	??4MemoryDataStream@Ogre@@QAEAAV01@ABV01@@Z	; Ogre::MemoryDataStream::operator=
; Function compile flags: /Odtp
;	COMDAT ??4MemoryDataStream@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4MemoryDataStream@Ogre@@QAEAAV01@ABV01@@Z PROC	; Ogre::MemoryDataStream::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4DataStream@Ogre@@QAEAAV01@ABV01@@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	DWORD PTR [ecx+36], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	DWORD PTR [ecx+40], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+44]
	mov	DWORD PTR [ecx+44], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+48]
	mov	DWORD PTR [ecx+48], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4MemoryDataStream@Ogre@@QAEAAV01@ABV01@@Z ENDP	; Ogre::MemoryDataStream::operator=
_TEXT	ENDS
PUBLIC	??_GMemoryDataStream@Ogre@@UAEPAXI@Z		; Ogre::MemoryDataStream::`scalar deleting destructor'
EXTRN	??1MemoryDataStream@Ogre@@UAE@XZ:PROC		; Ogre::MemoryDataStream::~MemoryDataStream
; Function compile flags: /Odtp
;	COMDAT ??_GMemoryDataStream@Ogre@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GMemoryDataStream@Ogre@@UAEPAXI@Z PROC		; Ogre::MemoryDataStream::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1MemoryDataStream@Ogre@@UAE@XZ	; Ogre::MemoryDataStream::~MemoryDataStream
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@2
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@2:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GMemoryDataStream@Ogre@@UAEPAXI@Z ENDP		; Ogre::MemoryDataStream::`scalar deleting destructor'
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_EMemoryDataStream@Ogre@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_EMemoryDataStream@Ogre@@UAEPAXI@Z PROC		; Ogre::MemoryDataStream::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 2
	je	SHORT $LN3@vector@2
	push	OFFSET ??1MemoryDataStream@Ogre@@UAE@XZ	; Ogre::MemoryDataStream::~MemoryDataStream
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx-4]
	push	edx
	push	52					; 00000034H
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??_M@YGXPAXIHP6EX0@Z@Z
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN2@vector@2
	mov	edx, DWORD PTR _this$[ebp]
	sub	edx, 4
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN2@vector@2:
	mov	eax, DWORD PTR _this$[ebp]
	sub	eax, 4
	jmp	SHORT $LN4@vector@2
$LN3@vector@2:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1MemoryDataStream@Ogre@@UAE@XZ	; Ogre::MemoryDataStream::~MemoryDataStream
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@vector@2
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@vector@2:
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector@2:
	mov	esp, ebp
	pop	ebp
	ret	4
??_EMemoryDataStream@Ogre@@UAEPAXI@Z ENDP		; Ogre::MemoryDataStream::`vector deleting destructor'
_TEXT	ENDS
PUBLIC	??_7FileStreamDataStream@Ogre@@6B@		; Ogre::FileStreamDataStream::`vftable'
PUBLIC	??0FileStreamDataStream@Ogre@@QAE@ABV01@@Z	; Ogre::FileStreamDataStream::FileStreamDataStream
PUBLIC	??_R4FileStreamDataStream@Ogre@@6B@		; Ogre::FileStreamDataStream::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVFileStreamDataStream@Ogre@@@8		; Ogre::FileStreamDataStream `RTTI Type Descriptor'
PUBLIC	??_R3FileStreamDataStream@Ogre@@8		; Ogre::FileStreamDataStream::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2FileStreamDataStream@Ogre@@8		; Ogre::FileStreamDataStream::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@FileStreamDataStream@Ogre@@8	; Ogre::FileStreamDataStream::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_EFileStreamDataStream@Ogre@@UAEPAXI@Z	; Ogre::FileStreamDataStream::`vector deleting destructor'
EXTRN	?read@FileStreamDataStream@Ogre@@UAEIPAXI@Z:PROC ; Ogre::FileStreamDataStream::read
EXTRN	?write@FileStreamDataStream@Ogre@@UAEIPBXI@Z:PROC ; Ogre::FileStreamDataStream::write
EXTRN	?readLine@FileStreamDataStream@Ogre@@UAEIPADIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z:PROC ; Ogre::FileStreamDataStream::readLine
EXTRN	?skip@FileStreamDataStream@Ogre@@UAEXJ@Z:PROC	; Ogre::FileStreamDataStream::skip
EXTRN	?seek@FileStreamDataStream@Ogre@@UAEXI@Z:PROC	; Ogre::FileStreamDataStream::seek
EXTRN	?tell@FileStreamDataStream@Ogre@@UBEIXZ:PROC	; Ogre::FileStreamDataStream::tell
EXTRN	?eof@FileStreamDataStream@Ogre@@UBE_NXZ:PROC	; Ogre::FileStreamDataStream::eof
EXTRN	?close@FileStreamDataStream@Ogre@@UAEXXZ:PROC	; Ogre::FileStreamDataStream::close
EXTRN	?getMemoryImage@FileStreamDataStream@Ogre@@UAEPAXXZ:PROC ; Ogre::FileStreamDataStream::getMemoryImage
;	COMDAT ??_R1A@?0A@EA@FileStreamDataStream@Ogre@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@FileStreamDataStream@Ogre@@8 DD FLAT:??_R0?AVFileStreamDataStream@Ogre@@@8 ; Ogre::FileStreamDataStream::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3FileStreamDataStream@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R2FileStreamDataStream@Ogre@@8
rdata$r	SEGMENT
??_R2FileStreamDataStream@Ogre@@8 DD FLAT:??_R1A@?0A@EA@FileStreamDataStream@Ogre@@8 ; Ogre::FileStreamDataStream::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@DataStream@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R3FileStreamDataStream@Ogre@@8
rdata$r	SEGMENT
??_R3FileStreamDataStream@Ogre@@8 DD 00H		; Ogre::FileStreamDataStream::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2FileStreamDataStream@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVFileStreamDataStream@Ogre@@@8
_DATA	SEGMENT
??_R0?AVFileStreamDataStream@Ogre@@@8 DD FLAT:??_7type_info@@6B@ ; Ogre::FileStreamDataStream `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVFileStreamDataStream@Ogre@@', 00H
_DATA	ENDS
;	COMDAT ??_R4FileStreamDataStream@Ogre@@6B@
rdata$r	SEGMENT
??_R4FileStreamDataStream@Ogre@@6B@ DD 00H		; Ogre::FileStreamDataStream::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVFileStreamDataStream@Ogre@@@8
	DD	FLAT:??_R3FileStreamDataStream@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_7FileStreamDataStream@Ogre@@6B@
CONST	SEGMENT
??_7FileStreamDataStream@Ogre@@6B@ DD FLAT:??_R4FileStreamDataStream@Ogre@@6B@ ; Ogre::FileStreamDataStream::`vftable'
	DD	FLAT:??_EFileStreamDataStream@Ogre@@UAEPAXI@Z
	DD	FLAT:?read@FileStreamDataStream@Ogre@@UAEIPAXI@Z
	DD	FLAT:?write@FileStreamDataStream@Ogre@@UAEIPBXI@Z
	DD	FLAT:?readLine@FileStreamDataStream@Ogre@@UAEIPADIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	FLAT:?getLine@DataStream@Ogre@@UAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z
	DD	FLAT:?getAsString@DataStream@Ogre@@UAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
	DD	FLAT:?skipLine@DataStream@Ogre@@UAEIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	FLAT:?skip@FileStreamDataStream@Ogre@@UAEXJ@Z
	DD	FLAT:?seek@FileStreamDataStream@Ogre@@UAEXI@Z
	DD	FLAT:?tell@FileStreamDataStream@Ogre@@UBEIXZ
	DD	FLAT:?eof@FileStreamDataStream@Ogre@@UBE_NXZ
	DD	FLAT:?size@DataStream@Ogre@@UBEIXZ
	DD	FLAT:?close@FileStreamDataStream@Ogre@@UAEXXZ
	DD	FLAT:?getMemoryImage@FileStreamDataStream@Ogre@@UAEPAXXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0FileStreamDataStream@Ogre@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0FileStreamDataStream@Ogre@@QAE@ABV01@@Z$0
__ehfuncinfo$??0FileStreamDataStream@Ogre@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0FileStreamDataStream@Ogre@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0FileStreamDataStream@Ogre@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0FileStreamDataStream@Ogre@@QAE@ABV01@@Z PROC		; Ogre::FileStreamDataStream::FileStreamDataStream, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0FileStreamDataStream@Ogre@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0DataStream@Ogre@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7FileStreamDataStream@Ogre@@6B@
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR [edx+36], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	cl, BYTE PTR [eax+40]
	mov	BYTE PTR [edx+40], cl
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0FileStreamDataStream@Ogre@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1DataStream@Ogre@@UAE@XZ		; Ogre::DataStream::~DataStream
__ehhandler$??0FileStreamDataStream@Ogre@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0FileStreamDataStream@Ogre@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0FileStreamDataStream@Ogre@@QAE@ABV01@@Z ENDP		; Ogre::FileStreamDataStream::FileStreamDataStream
PUBLIC	??4FileStreamDataStream@Ogre@@QAEAAV01@ABV01@@Z	; Ogre::FileStreamDataStream::operator=
; Function compile flags: /Odtp
;	COMDAT ??4FileStreamDataStream@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4FileStreamDataStream@Ogre@@QAEAAV01@ABV01@@Z PROC	; Ogre::FileStreamDataStream::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4DataStream@Ogre@@QAEAAV01@ABV01@@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	DWORD PTR [ecx+36], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	al, BYTE PTR [edx+40]
	mov	BYTE PTR [ecx+40], al
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4FileStreamDataStream@Ogre@@QAEAAV01@ABV01@@Z ENDP	; Ogre::FileStreamDataStream::operator=
_TEXT	ENDS
PUBLIC	??_GFileStreamDataStream@Ogre@@UAEPAXI@Z	; Ogre::FileStreamDataStream::`scalar deleting destructor'
EXTRN	??1FileStreamDataStream@Ogre@@UAE@XZ:PROC	; Ogre::FileStreamDataStream::~FileStreamDataStream
; Function compile flags: /Odtp
;	COMDAT ??_GFileStreamDataStream@Ogre@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GFileStreamDataStream@Ogre@@UAEPAXI@Z PROC		; Ogre::FileStreamDataStream::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1FileStreamDataStream@Ogre@@UAE@XZ	; Ogre::FileStreamDataStream::~FileStreamDataStream
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@3
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@3:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GFileStreamDataStream@Ogre@@UAEPAXI@Z ENDP		; Ogre::FileStreamDataStream::`scalar deleting destructor'
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_EFileStreamDataStream@Ogre@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_EFileStreamDataStream@Ogre@@UAEPAXI@Z PROC		; Ogre::FileStreamDataStream::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 2
	je	SHORT $LN3@vector@3
	push	OFFSET ??1FileStreamDataStream@Ogre@@UAE@XZ ; Ogre::FileStreamDataStream::~FileStreamDataStream
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx-4]
	push	edx
	push	44					; 0000002cH
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??_M@YGXPAXIHP6EX0@Z@Z
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN2@vector@3
	mov	edx, DWORD PTR _this$[ebp]
	sub	edx, 4
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN2@vector@3:
	mov	eax, DWORD PTR _this$[ebp]
	sub	eax, 4
	jmp	SHORT $LN4@vector@3
$LN3@vector@3:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1FileStreamDataStream@Ogre@@UAE@XZ	; Ogre::FileStreamDataStream::~FileStreamDataStream
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@vector@3
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@vector@3:
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector@3:
	mov	esp, ebp
	pop	ebp
	ret	4
??_EFileStreamDataStream@Ogre@@UAEPAXI@Z ENDP		; Ogre::FileStreamDataStream::`vector deleting destructor'
_TEXT	ENDS
PUBLIC	??_7FileHandleDataStream@Ogre@@6B@		; Ogre::FileHandleDataStream::`vftable'
PUBLIC	??0FileHandleDataStream@Ogre@@QAE@ABV01@@Z	; Ogre::FileHandleDataStream::FileHandleDataStream
PUBLIC	??_R4FileHandleDataStream@Ogre@@6B@		; Ogre::FileHandleDataStream::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVFileHandleDataStream@Ogre@@@8		; Ogre::FileHandleDataStream `RTTI Type Descriptor'
PUBLIC	??_R3FileHandleDataStream@Ogre@@8		; Ogre::FileHandleDataStream::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2FileHandleDataStream@Ogre@@8		; Ogre::FileHandleDataStream::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@FileHandleDataStream@Ogre@@8	; Ogre::FileHandleDataStream::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_EFileHandleDataStream@Ogre@@UAEPAXI@Z	; Ogre::FileHandleDataStream::`vector deleting destructor'
EXTRN	?read@FileHandleDataStream@Ogre@@UAEIPAXI@Z:PROC ; Ogre::FileHandleDataStream::read
EXTRN	?write@FileHandleDataStream@Ogre@@UAEIPBXI@Z:PROC ; Ogre::FileHandleDataStream::write
EXTRN	?skip@FileHandleDataStream@Ogre@@UAEXJ@Z:PROC	; Ogre::FileHandleDataStream::skip
EXTRN	?seek@FileHandleDataStream@Ogre@@UAEXI@Z:PROC	; Ogre::FileHandleDataStream::seek
EXTRN	?tell@FileHandleDataStream@Ogre@@UBEIXZ:PROC	; Ogre::FileHandleDataStream::tell
EXTRN	?eof@FileHandleDataStream@Ogre@@UBE_NXZ:PROC	; Ogre::FileHandleDataStream::eof
EXTRN	?close@FileHandleDataStream@Ogre@@UAEXXZ:PROC	; Ogre::FileHandleDataStream::close
EXTRN	?getMemoryImage@FileHandleDataStream@Ogre@@UAEPAXXZ:PROC ; Ogre::FileHandleDataStream::getMemoryImage
;	COMDAT ??_R1A@?0A@EA@FileHandleDataStream@Ogre@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@FileHandleDataStream@Ogre@@8 DD FLAT:??_R0?AVFileHandleDataStream@Ogre@@@8 ; Ogre::FileHandleDataStream::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3FileHandleDataStream@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R2FileHandleDataStream@Ogre@@8
rdata$r	SEGMENT
??_R2FileHandleDataStream@Ogre@@8 DD FLAT:??_R1A@?0A@EA@FileHandleDataStream@Ogre@@8 ; Ogre::FileHandleDataStream::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@DataStream@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R3FileHandleDataStream@Ogre@@8
rdata$r	SEGMENT
??_R3FileHandleDataStream@Ogre@@8 DD 00H		; Ogre::FileHandleDataStream::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2FileHandleDataStream@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVFileHandleDataStream@Ogre@@@8
_DATA	SEGMENT
??_R0?AVFileHandleDataStream@Ogre@@@8 DD FLAT:??_7type_info@@6B@ ; Ogre::FileHandleDataStream `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVFileHandleDataStream@Ogre@@', 00H
_DATA	ENDS
;	COMDAT ??_R4FileHandleDataStream@Ogre@@6B@
rdata$r	SEGMENT
??_R4FileHandleDataStream@Ogre@@6B@ DD 00H		; Ogre::FileHandleDataStream::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVFileHandleDataStream@Ogre@@@8
	DD	FLAT:??_R3FileHandleDataStream@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_7FileHandleDataStream@Ogre@@6B@
CONST	SEGMENT
??_7FileHandleDataStream@Ogre@@6B@ DD FLAT:??_R4FileHandleDataStream@Ogre@@6B@ ; Ogre::FileHandleDataStream::`vftable'
	DD	FLAT:??_EFileHandleDataStream@Ogre@@UAEPAXI@Z
	DD	FLAT:?read@FileHandleDataStream@Ogre@@UAEIPAXI@Z
	DD	FLAT:?write@FileHandleDataStream@Ogre@@UAEIPBXI@Z
	DD	FLAT:?readLine@DataStream@Ogre@@UAEIPADIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	FLAT:?getLine@DataStream@Ogre@@UAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z
	DD	FLAT:?getAsString@DataStream@Ogre@@UAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
	DD	FLAT:?skipLine@DataStream@Ogre@@UAEIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	FLAT:?skip@FileHandleDataStream@Ogre@@UAEXJ@Z
	DD	FLAT:?seek@FileHandleDataStream@Ogre@@UAEXI@Z
	DD	FLAT:?tell@FileHandleDataStream@Ogre@@UBEIXZ
	DD	FLAT:?eof@FileHandleDataStream@Ogre@@UBE_NXZ
	DD	FLAT:?size@DataStream@Ogre@@UBEIXZ
	DD	FLAT:?close@FileHandleDataStream@Ogre@@UAEXXZ
	DD	FLAT:?getMemoryImage@FileHandleDataStream@Ogre@@UAEPAXXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0FileHandleDataStream@Ogre@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0FileHandleDataStream@Ogre@@QAE@ABV01@@Z$0
__ehfuncinfo$??0FileHandleDataStream@Ogre@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0FileHandleDataStream@Ogre@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0FileHandleDataStream@Ogre@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0FileHandleDataStream@Ogre@@QAE@ABV01@@Z PROC		; Ogre::FileHandleDataStream::FileHandleDataStream, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0FileHandleDataStream@Ogre@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0DataStream@Ogre@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7FileHandleDataStream@Ogre@@6B@
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR [edx+36], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	DWORD PTR [edx+40], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0FileHandleDataStream@Ogre@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1DataStream@Ogre@@UAE@XZ		; Ogre::DataStream::~DataStream
__ehhandler$??0FileHandleDataStream@Ogre@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0FileHandleDataStream@Ogre@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0FileHandleDataStream@Ogre@@QAE@ABV01@@Z ENDP		; Ogre::FileHandleDataStream::FileHandleDataStream
PUBLIC	??4FileHandleDataStream@Ogre@@QAEAAV01@ABV01@@Z	; Ogre::FileHandleDataStream::operator=
; Function compile flags: /Odtp
;	COMDAT ??4FileHandleDataStream@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4FileHandleDataStream@Ogre@@QAEAAV01@ABV01@@Z PROC	; Ogre::FileHandleDataStream::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4DataStream@Ogre@@QAEAAV01@ABV01@@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	DWORD PTR [ecx+36], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	DWORD PTR [ecx+40], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4FileHandleDataStream@Ogre@@QAEAAV01@ABV01@@Z ENDP	; Ogre::FileHandleDataStream::operator=
_TEXT	ENDS
PUBLIC	??_GFileHandleDataStream@Ogre@@UAEPAXI@Z	; Ogre::FileHandleDataStream::`scalar deleting destructor'
EXTRN	??1FileHandleDataStream@Ogre@@UAE@XZ:PROC	; Ogre::FileHandleDataStream::~FileHandleDataStream
; Function compile flags: /Odtp
;	COMDAT ??_GFileHandleDataStream@Ogre@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GFileHandleDataStream@Ogre@@UAEPAXI@Z PROC		; Ogre::FileHandleDataStream::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1FileHandleDataStream@Ogre@@UAE@XZ	; Ogre::FileHandleDataStream::~FileHandleDataStream
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@4
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@4:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GFileHandleDataStream@Ogre@@UAEPAXI@Z ENDP		; Ogre::FileHandleDataStream::`scalar deleting destructor'
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_EFileHandleDataStream@Ogre@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_EFileHandleDataStream@Ogre@@UAEPAXI@Z PROC		; Ogre::FileHandleDataStream::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 2
	je	SHORT $LN3@vector@4
	push	OFFSET ??1FileHandleDataStream@Ogre@@UAE@XZ ; Ogre::FileHandleDataStream::~FileHandleDataStream
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx-4]
	push	edx
	push	44					; 0000002cH
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??_M@YGXPAXIHP6EX0@Z@Z
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN2@vector@4
	mov	edx, DWORD PTR _this$[ebp]
	sub	edx, 4
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN2@vector@4:
	mov	eax, DWORD PTR _this$[ebp]
	sub	eax, 4
	jmp	SHORT $LN4@vector@4
$LN3@vector@4:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1FileHandleDataStream@Ogre@@UAE@XZ	; Ogre::FileHandleDataStream::~FileHandleDataStream
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@vector@4
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@vector@4:
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector@4:
	mov	esp, ebp
	pop	ebp
	ret	4
??_EFileHandleDataStream@Ogre@@UAEPAXI@Z ENDP		; Ogre::FileHandleDataStream::`vector deleting destructor'
_TEXT	ENDS
PUBLIC	??_7DataStreamObject@Ogre@@6B@			; Ogre::DataStreamObject::`vftable'
PUBLIC	??1DataStreamObject@Ogre@@MAE@XZ		; Ogre::DataStreamObject::~DataStreamObject
PUBLIC	??_R4DataStreamObject@Ogre@@6B@			; Ogre::DataStreamObject::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVDataStreamObject@Ogre@@@8		; Ogre::DataStreamObject `RTTI Type Descriptor'
PUBLIC	??_R3DataStreamObject@Ogre@@8			; Ogre::DataStreamObject::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2DataStreamObject@Ogre@@8			; Ogre::DataStreamObject::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@DataStreamObject@Ogre@@8		; Ogre::DataStreamObject::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_EDataStreamObject@Ogre@@MAEPAXI@Z		; Ogre::DataStreamObject::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@DataStreamObject@Ogre@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@DataStreamObject@Ogre@@8 DD FLAT:??_R0?AVDataStreamObject@Ogre@@@8 ; Ogre::DataStreamObject::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3DataStreamObject@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R2DataStreamObject@Ogre@@8
rdata$r	SEGMENT
??_R2DataStreamObject@Ogre@@8 DD FLAT:??_R1A@?0A@EA@DataStreamObject@Ogre@@8 ; Ogre::DataStreamObject::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3DataStreamObject@Ogre@@8
rdata$r	SEGMENT
??_R3DataStreamObject@Ogre@@8 DD 00H			; Ogre::DataStreamObject::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2DataStreamObject@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVDataStreamObject@Ogre@@@8
_DATA	SEGMENT
??_R0?AVDataStreamObject@Ogre@@@8 DD FLAT:??_7type_info@@6B@ ; Ogre::DataStreamObject `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVDataStreamObject@Ogre@@', 00H
_DATA	ENDS
;	COMDAT ??_R4DataStreamObject@Ogre@@6B@
rdata$r	SEGMENT
??_R4DataStreamObject@Ogre@@6B@ DD 00H			; Ogre::DataStreamObject::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVDataStreamObject@Ogre@@@8
	DD	FLAT:??_R3DataStreamObject@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_7DataStreamObject@Ogre@@6B@
CONST	SEGMENT
??_7DataStreamObject@Ogre@@6B@ DD FLAT:??_R4DataStreamObject@Ogre@@6B@ ; Ogre::DataStreamObject::`vftable'
	DD	FLAT:??_EDataStreamObject@Ogre@@MAEPAXI@Z
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ??1DataStreamObject@Ogre@@MAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1DataStreamObject@Ogre@@MAE@XZ PROC			; Ogre::DataStreamObject::~DataStreamObject, COMDAT
; _this$ = ecx

; 445  : 		virtual ~DataStreamObject(){}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7DataStreamObject@Ogre@@6B@
	mov	esp, ebp
	pop	ebp
	ret	0
??1DataStreamObject@Ogre@@MAE@XZ ENDP			; Ogre::DataStreamObject::~DataStreamObject
_TEXT	ENDS
PUBLIC	??0DataStreamObject@Ogre@@QAE@XZ		; Ogre::DataStreamObject::DataStreamObject
; Function compile flags: /Odtp
;	COMDAT ??0DataStreamObject@Ogre@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0DataStreamObject@Ogre@@QAE@XZ PROC			; Ogre::DataStreamObject::DataStreamObject, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7DataStreamObject@Ogre@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0DataStreamObject@Ogre@@QAE@XZ ENDP			; Ogre::DataStreamObject::DataStreamObject
_TEXT	ENDS
PUBLIC	??0DataStreamObject@Ogre@@QAE@ABV01@@Z		; Ogre::DataStreamObject::DataStreamObject
; Function compile flags: /Odtp
;	COMDAT ??0DataStreamObject@Ogre@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0DataStreamObject@Ogre@@QAE@ABV01@@Z PROC		; Ogre::DataStreamObject::DataStreamObject, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7DataStreamObject@Ogre@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0DataStreamObject@Ogre@@QAE@ABV01@@Z ENDP		; Ogre::DataStreamObject::DataStreamObject
_TEXT	ENDS
PUBLIC	??4DataStreamObject@Ogre@@QAEAAV01@ABV01@@Z	; Ogre::DataStreamObject::operator=
; Function compile flags: /Odtp
;	COMDAT ??4DataStreamObject@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4DataStreamObject@Ogre@@QAEAAV01@ABV01@@Z PROC	; Ogre::DataStreamObject::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4DataStreamObject@Ogre@@QAEAAV01@ABV01@@Z ENDP	; Ogre::DataStreamObject::operator=
_TEXT	ENDS
PUBLIC	??_GDataStreamObject@Ogre@@MAEPAXI@Z		; Ogre::DataStreamObject::`scalar deleting destructor'
; Function compile flags: /Odtp
;	COMDAT ??_GDataStreamObject@Ogre@@MAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GDataStreamObject@Ogre@@MAEPAXI@Z PROC		; Ogre::DataStreamObject::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1DataStreamObject@Ogre@@MAE@XZ	; Ogre::DataStreamObject::~DataStreamObject
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@5
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@5:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GDataStreamObject@Ogre@@MAEPAXI@Z ENDP		; Ogre::DataStreamObject::`scalar deleting destructor'
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_EDataStreamObject@Ogre@@MAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_EDataStreamObject@Ogre@@MAEPAXI@Z PROC		; Ogre::DataStreamObject::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 2
	je	SHORT $LN3@vector@5
	push	OFFSET ??1DataStreamObject@Ogre@@MAE@XZ	; Ogre::DataStreamObject::~DataStreamObject
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx-4]
	push	edx
	push	4
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??_M@YGXPAXIHP6EX0@Z@Z
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN2@vector@5
	mov	edx, DWORD PTR _this$[ebp]
	sub	edx, 4
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN2@vector@5:
	mov	eax, DWORD PTR _this$[ebp]
	sub	eax, 4
	jmp	SHORT $LN4@vector@5
$LN3@vector@5:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1DataStreamObject@Ogre@@MAE@XZ	; Ogre::DataStreamObject::~DataStreamObject
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@vector@5
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@vector@5:
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector@5:
	mov	esp, ebp
	pop	ebp
	ret	4
??_EDataStreamObject@Ogre@@MAEPAXI@Z ENDP		; Ogre::DataStreamObject::`vector deleting destructor'
_TEXT	ENDS
PUBLIC	??_7ObjectDataStream@Ogre@@6B@			; Ogre::ObjectDataStream::`vftable'
PUBLIC	??0ObjectDataStream@Ogre@@QAE@ABV01@@Z		; Ogre::ObjectDataStream::ObjectDataStream
PUBLIC	??_R4ObjectDataStream@Ogre@@6B@			; Ogre::ObjectDataStream::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVObjectDataStream@Ogre@@@8		; Ogre::ObjectDataStream `RTTI Type Descriptor'
PUBLIC	??_R3ObjectDataStream@Ogre@@8			; Ogre::ObjectDataStream::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2ObjectDataStream@Ogre@@8			; Ogre::ObjectDataStream::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@ObjectDataStream@Ogre@@8		; Ogre::ObjectDataStream::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_EObjectDataStream@Ogre@@UAEPAXI@Z		; Ogre::ObjectDataStream::`vector deleting destructor'
EXTRN	?read@ObjectDataStream@Ogre@@UAEIPAXI@Z:PROC	; Ogre::ObjectDataStream::read
EXTRN	?write@ObjectDataStream@Ogre@@UAEIPBXI@Z:PROC	; Ogre::ObjectDataStream::write
EXTRN	?skip@ObjectDataStream@Ogre@@UAEXJ@Z:PROC	; Ogre::ObjectDataStream::skip
EXTRN	?seek@ObjectDataStream@Ogre@@UAEXI@Z:PROC	; Ogre::ObjectDataStream::seek
EXTRN	?tell@ObjectDataStream@Ogre@@UBEIXZ:PROC	; Ogre::ObjectDataStream::tell
EXTRN	?eof@ObjectDataStream@Ogre@@UBE_NXZ:PROC	; Ogre::ObjectDataStream::eof
EXTRN	?size@ObjectDataStream@Ogre@@UBEIXZ:PROC	; Ogre::ObjectDataStream::size
EXTRN	?close@ObjectDataStream@Ogre@@UAEXXZ:PROC	; Ogre::ObjectDataStream::close
EXTRN	?getMemoryImage@ObjectDataStream@Ogre@@UAEPAXXZ:PROC ; Ogre::ObjectDataStream::getMemoryImage
;	COMDAT ??_R1A@?0A@EA@ObjectDataStream@Ogre@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@ObjectDataStream@Ogre@@8 DD FLAT:??_R0?AVObjectDataStream@Ogre@@@8 ; Ogre::ObjectDataStream::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3ObjectDataStream@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R2ObjectDataStream@Ogre@@8
rdata$r	SEGMENT
??_R2ObjectDataStream@Ogre@@8 DD FLAT:??_R1A@?0A@EA@ObjectDataStream@Ogre@@8 ; Ogre::ObjectDataStream::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@DataStream@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R3ObjectDataStream@Ogre@@8
rdata$r	SEGMENT
??_R3ObjectDataStream@Ogre@@8 DD 00H			; Ogre::ObjectDataStream::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2ObjectDataStream@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVObjectDataStream@Ogre@@@8
_DATA	SEGMENT
??_R0?AVObjectDataStream@Ogre@@@8 DD FLAT:??_7type_info@@6B@ ; Ogre::ObjectDataStream `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVObjectDataStream@Ogre@@', 00H
_DATA	ENDS
;	COMDAT ??_R4ObjectDataStream@Ogre@@6B@
rdata$r	SEGMENT
??_R4ObjectDataStream@Ogre@@6B@ DD 00H			; Ogre::ObjectDataStream::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVObjectDataStream@Ogre@@@8
	DD	FLAT:??_R3ObjectDataStream@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_7ObjectDataStream@Ogre@@6B@
CONST	SEGMENT
??_7ObjectDataStream@Ogre@@6B@ DD FLAT:??_R4ObjectDataStream@Ogre@@6B@ ; Ogre::ObjectDataStream::`vftable'
	DD	FLAT:??_EObjectDataStream@Ogre@@UAEPAXI@Z
	DD	FLAT:?read@ObjectDataStream@Ogre@@UAEIPAXI@Z
	DD	FLAT:?write@ObjectDataStream@Ogre@@UAEIPBXI@Z
	DD	FLAT:?readLine@DataStream@Ogre@@UAEIPADIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	FLAT:?getLine@DataStream@Ogre@@UAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z
	DD	FLAT:?getAsString@DataStream@Ogre@@UAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
	DD	FLAT:?skipLine@DataStream@Ogre@@UAEIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	FLAT:?skip@ObjectDataStream@Ogre@@UAEXJ@Z
	DD	FLAT:?seek@ObjectDataStream@Ogre@@UAEXI@Z
	DD	FLAT:?tell@ObjectDataStream@Ogre@@UBEIXZ
	DD	FLAT:?eof@ObjectDataStream@Ogre@@UBE_NXZ
	DD	FLAT:?size@ObjectDataStream@Ogre@@UBEIXZ
	DD	FLAT:?close@ObjectDataStream@Ogre@@UAEXXZ
	DD	FLAT:?getMemoryImage@ObjectDataStream@Ogre@@UAEPAXXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0ObjectDataStream@Ogre@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0ObjectDataStream@Ogre@@QAE@ABV01@@Z$0
__ehfuncinfo$??0ObjectDataStream@Ogre@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0ObjectDataStream@Ogre@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0ObjectDataStream@Ogre@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0ObjectDataStream@Ogre@@QAE@ABV01@@Z PROC		; Ogre::ObjectDataStream::ObjectDataStream, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0ObjectDataStream@Ogre@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0DataStream@Ogre@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7ObjectDataStream@Ogre@@6B@
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR [edx+36], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	DWORD PTR [edx+40], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0ObjectDataStream@Ogre@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1DataStream@Ogre@@UAE@XZ		; Ogre::DataStream::~DataStream
__ehhandler$??0ObjectDataStream@Ogre@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0ObjectDataStream@Ogre@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0ObjectDataStream@Ogre@@QAE@ABV01@@Z ENDP		; Ogre::ObjectDataStream::ObjectDataStream
PUBLIC	??4ObjectDataStream@Ogre@@QAEAAV01@ABV01@@Z	; Ogre::ObjectDataStream::operator=
; Function compile flags: /Odtp
;	COMDAT ??4ObjectDataStream@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4ObjectDataStream@Ogre@@QAEAAV01@ABV01@@Z PROC	; Ogre::ObjectDataStream::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4DataStream@Ogre@@QAEAAV01@ABV01@@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	DWORD PTR [ecx+36], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	DWORD PTR [ecx+40], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4ObjectDataStream@Ogre@@QAEAAV01@ABV01@@Z ENDP	; Ogre::ObjectDataStream::operator=
_TEXT	ENDS
PUBLIC	??_GObjectDataStream@Ogre@@UAEPAXI@Z		; Ogre::ObjectDataStream::`scalar deleting destructor'
EXTRN	??1ObjectDataStream@Ogre@@UAE@XZ:PROC		; Ogre::ObjectDataStream::~ObjectDataStream
; Function compile flags: /Odtp
;	COMDAT ??_GObjectDataStream@Ogre@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GObjectDataStream@Ogre@@UAEPAXI@Z PROC		; Ogre::ObjectDataStream::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1ObjectDataStream@Ogre@@UAE@XZ	; Ogre::ObjectDataStream::~ObjectDataStream
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@6
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@6:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GObjectDataStream@Ogre@@UAEPAXI@Z ENDP		; Ogre::ObjectDataStream::`scalar deleting destructor'
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_EObjectDataStream@Ogre@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_EObjectDataStream@Ogre@@UAEPAXI@Z PROC		; Ogre::ObjectDataStream::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 2
	je	SHORT $LN3@vector@6
	push	OFFSET ??1ObjectDataStream@Ogre@@UAE@XZ	; Ogre::ObjectDataStream::~ObjectDataStream
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx-4]
	push	edx
	push	44					; 0000002cH
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??_M@YGXPAXIHP6EX0@Z@Z
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN2@vector@6
	mov	edx, DWORD PTR _this$[ebp]
	sub	edx, 4
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN2@vector@6:
	mov	eax, DWORD PTR _this$[ebp]
	sub	eax, 4
	jmp	SHORT $LN4@vector@6
$LN3@vector@6:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1ObjectDataStream@Ogre@@UAE@XZ	; Ogre::ObjectDataStream::~ObjectDataStream
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@vector@6
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@vector@6:
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector@6:
	mov	esp, ebp
	pop	ebp
	ret	4
??_EObjectDataStream@Ogre@@UAEPAXI@Z ENDP		; Ogre::ObjectDataStream::`vector deleting destructor'
_TEXT	ENDS
PUBLIC	??4LockSection@Ogre@@QAEAAV01@ABV01@@Z		; Ogre::LockSection::operator=
; Function compile flags: /Odtp
;	COMDAT ??4LockSection@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4LockSection@Ogre@@QAEAAV01@ABV01@@Z PROC		; Ogre::LockSection::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4LockSection@Ogre@@QAEAAV01@ABV01@@Z ENDP		; Ogre::LockSection::operator=
_TEXT	ENDS
PUBLIC	??0LockFunctor@Ogre@@QAE@PAVLockSection@1@@Z	; Ogre::LockFunctor::LockFunctor
EXTRN	?Lock@LockSection@Ogre@@QAEXXZ:PROC		; Ogre::LockSection::Lock
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogrelocker.h
;	COMDAT ??0LockFunctor@Ogre@@QAE@PAVLockSection@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pSection$ = 8						; size = 4
??0LockFunctor@Ogre@@QAE@PAVLockSection@1@@Z PROC	; Ogre::LockFunctor::LockFunctor, COMDAT
; _this$ = ecx

; 26   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pSection$[ebp]
	mov	DWORD PTR [eax], ecx

; 27   : 			if(m_pSection == NULL) return;

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx], 0
	jne	SHORT $LN1@LockFuncto
	jmp	SHORT $LN2@LockFuncto
$LN1@LockFuncto:

; 28   : 			assert( m_pSection );
; 29   : 			m_pSection->Lock();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?Lock@LockSection@Ogre@@QAEXXZ		; Ogre::LockSection::Lock
$LN2@LockFuncto:

; 30   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0LockFunctor@Ogre@@QAE@PAVLockSection@1@@Z ENDP	; Ogre::LockFunctor::LockFunctor
_TEXT	ENDS
PUBLIC	??1LockFunctor@Ogre@@QAE@XZ			; Ogre::LockFunctor::~LockFunctor
EXTRN	?Unlock@LockSection@Ogre@@QAEXXZ:PROC		; Ogre::LockSection::Unlock
; Function compile flags: /Odtp
;	COMDAT ??1LockFunctor@Ogre@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1LockFunctor@Ogre@@QAE@XZ PROC			; Ogre::LockFunctor::~LockFunctor, COMDAT
; _this$ = ecx

; 33   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 34   : 			if( m_pSection )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN2@LockFuncto@2

; 35   : 			{
; 36   : 				m_pSection->Unlock();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?Unlock@LockSection@Ogre@@QAEXXZ	; Ogre::LockSection::Unlock
$LN2@LockFuncto@2:

; 37   : 			}			
; 38   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??1LockFunctor@Ogre@@QAE@XZ ENDP			; Ogre::LockFunctor::~LockFunctor
_TEXT	ENDS
PUBLIC	??4LockFunctor@Ogre@@QAEAAV01@ABV01@@Z		; Ogre::LockFunctor::operator=
; Function compile flags: /Odtp
;	COMDAT ??4LockFunctor@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4LockFunctor@Ogre@@QAEAAV01@ABV01@@Z PROC		; Ogre::LockFunctor::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4LockFunctor@Ogre@@QAEAAV01@ABV01@@Z ENDP		; Ogre::LockFunctor::operator=
_TEXT	ENDS
PUBLIC	??_7PackageDataStreamObject@Ogre@@6B@		; Ogre::PackageDataStreamObject::`vftable'
PUBLIC	??0PackageDataStreamObject@Ogre@@QAE@ABV01@@Z	; Ogre::PackageDataStreamObject::PackageDataStreamObject
PUBLIC	??_R4PackageDataStreamObject@Ogre@@6B@		; Ogre::PackageDataStreamObject::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVPackageDataStreamObject@Ogre@@@8	; Ogre::PackageDataStreamObject `RTTI Type Descriptor'
PUBLIC	??_R3PackageDataStreamObject@Ogre@@8		; Ogre::PackageDataStreamObject::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2PackageDataStreamObject@Ogre@@8		; Ogre::PackageDataStreamObject::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@PackageDataStreamObject@Ogre@@8	; Ogre::PackageDataStreamObject::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_EPackageDataStreamObject@Ogre@@UAEPAXI@Z	; Ogre::PackageDataStreamObject::`vector deleting destructor'
PUBLIC	?release@PackageDataStreamObject@Ogre@@UAEXXZ	; Ogre::PackageDataStreamObject::release
PUBLIC	?buffer@PackageDataStreamObject@Ogre@@UAEPAXI@Z	; Ogre::PackageDataStreamObject::buffer
PUBLIC	?buffer@PackageDataStreamObject@Ogre@@UAEPAXXZ	; Ogre::PackageDataStreamObject::buffer
PUBLIC	?length@PackageDataStreamObject@Ogre@@UAEIXZ	; Ogre::PackageDataStreamObject::length
PUBLIC	?size@PackageDataStreamObject@Ogre@@UAEIXZ	; Ogre::PackageDataStreamObject::size
PUBLIC	?shift@PackageDataStreamObject@Ogre@@UAEXI@Z	; Ogre::PackageDataStreamObject::shift
;	COMDAT ??_R1A@?0A@EA@PackageDataStreamObject@Ogre@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@PackageDataStreamObject@Ogre@@8 DD FLAT:??_R0?AVPackageDataStreamObject@Ogre@@@8 ; Ogre::PackageDataStreamObject::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3PackageDataStreamObject@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R2PackageDataStreamObject@Ogre@@8
rdata$r	SEGMENT
??_R2PackageDataStreamObject@Ogre@@8 DD FLAT:??_R1A@?0A@EA@PackageDataStreamObject@Ogre@@8 ; Ogre::PackageDataStreamObject::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@DataStreamObject@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R3PackageDataStreamObject@Ogre@@8
rdata$r	SEGMENT
??_R3PackageDataStreamObject@Ogre@@8 DD 00H		; Ogre::PackageDataStreamObject::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2PackageDataStreamObject@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVPackageDataStreamObject@Ogre@@@8
_DATA	SEGMENT
??_R0?AVPackageDataStreamObject@Ogre@@@8 DD FLAT:??_7type_info@@6B@ ; Ogre::PackageDataStreamObject `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVPackageDataStreamObject@Ogre@@', 00H
_DATA	ENDS
;	COMDAT ??_R4PackageDataStreamObject@Ogre@@6B@
rdata$r	SEGMENT
??_R4PackageDataStreamObject@Ogre@@6B@ DD 00H		; Ogre::PackageDataStreamObject::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVPackageDataStreamObject@Ogre@@@8
	DD	FLAT:??_R3PackageDataStreamObject@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_7PackageDataStreamObject@Ogre@@6B@
CONST	SEGMENT
??_7PackageDataStreamObject@Ogre@@6B@ DD FLAT:??_R4PackageDataStreamObject@Ogre@@6B@ ; Ogre::PackageDataStreamObject::`vftable'
	DD	FLAT:??_EPackageDataStreamObject@Ogre@@UAEPAXI@Z
	DD	FLAT:?release@PackageDataStreamObject@Ogre@@UAEXXZ
	DD	FLAT:?buffer@PackageDataStreamObject@Ogre@@UAEPAXI@Z
	DD	FLAT:?buffer@PackageDataStreamObject@Ogre@@UAEPAXXZ
	DD	FLAT:?length@PackageDataStreamObject@Ogre@@UAEIXZ
	DD	FLAT:?size@PackageDataStreamObject@Ogre@@UAEIXZ
	DD	FLAT:?shift@PackageDataStreamObject@Ogre@@UAEXI@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0PackageDataStreamObject@Ogre@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0PackageDataStreamObject@Ogre@@QAE@ABV01@@Z$0
__ehfuncinfo$??0PackageDataStreamObject@Ogre@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0PackageDataStreamObject@Ogre@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0PackageDataStreamObject@Ogre@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0PackageDataStreamObject@Ogre@@QAE@ABV01@@Z PROC	; Ogre::PackageDataStreamObject::PackageDataStreamObject, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0PackageDataStreamObject@Ogre@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0DataStreamObject@Ogre@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7PackageDataStreamObject@Ogre@@6B@
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [edx+12], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR [edx+16], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0PackageDataStreamObject@Ogre@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1DataStreamObject@Ogre@@MAE@XZ	; Ogre::DataStreamObject::~DataStreamObject
__ehhandler$??0PackageDataStreamObject@Ogre@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0PackageDataStreamObject@Ogre@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0PackageDataStreamObject@Ogre@@QAE@ABV01@@Z ENDP	; Ogre::PackageDataStreamObject::PackageDataStreamObject
PUBLIC	??4PackageDataStreamObject@Ogre@@QAEAAV01@ABV01@@Z ; Ogre::PackageDataStreamObject::operator=
; Function compile flags: /Odtp
;	COMDAT ??4PackageDataStreamObject@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4PackageDataStreamObject@Ogre@@QAEAAV01@ABV01@@Z PROC	; Ogre::PackageDataStreamObject::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4DataStreamObject@Ogre@@QAEAAV01@ABV01@@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+8], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR [ecx+12], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR [ecx+16], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4PackageDataStreamObject@Ogre@@QAEAAV01@ABV01@@Z ENDP	; Ogre::PackageDataStreamObject::operator=
_TEXT	ENDS
PUBLIC	??1PackageDataStreamObject@Ogre@@UAE@XZ		; Ogre::PackageDataStreamObject::~PackageDataStreamObject
PUBLIC	??_GPackageDataStreamObject@Ogre@@UAEPAXI@Z	; Ogre::PackageDataStreamObject::`scalar deleting destructor'
; Function compile flags: /Odtp
;	COMDAT ??_GPackageDataStreamObject@Ogre@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GPackageDataStreamObject@Ogre@@UAEPAXI@Z PROC	; Ogre::PackageDataStreamObject::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1PackageDataStreamObject@Ogre@@UAE@XZ	; Ogre::PackageDataStreamObject::~PackageDataStreamObject
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@7
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@7:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GPackageDataStreamObject@Ogre@@UAEPAXI@Z ENDP	; Ogre::PackageDataStreamObject::`scalar deleting destructor'
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_EPackageDataStreamObject@Ogre@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_EPackageDataStreamObject@Ogre@@UAEPAXI@Z PROC	; Ogre::PackageDataStreamObject::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 2
	je	SHORT $LN3@vector@7
	push	OFFSET ??1PackageDataStreamObject@Ogre@@UAE@XZ ; Ogre::PackageDataStreamObject::~PackageDataStreamObject
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx-4]
	push	edx
	push	20					; 00000014H
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??_M@YGXPAXIHP6EX0@Z@Z
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN2@vector@7
	mov	edx, DWORD PTR _this$[ebp]
	sub	edx, 4
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN2@vector@7:
	mov	eax, DWORD PTR _this$[ebp]
	sub	eax, 4
	jmp	SHORT $LN4@vector@7
$LN3@vector@7:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1PackageDataStreamObject@Ogre@@UAE@XZ	; Ogre::PackageDataStreamObject::~PackageDataStreamObject
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@vector@7
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@vector@7:
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector@7:
	mov	esp, ebp
	pop	ebp
	ret	4
??_EPackageDataStreamObject@Ogre@@UAEPAXI@Z ENDP	; Ogre::PackageDataStreamObject::`vector deleting destructor'
_TEXT	ENDS
PUBLIC	??1?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::~vector<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >
PUBLIC	??1?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::~vector<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >
PUBLIC	??0?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::vector<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >
PUBLIC	??0?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::vector<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >
PUBLIC	??0FilePackage@Ogre@@QAE@XZ			; Ogre::FilePackage::FilePackage
EXTRN	??1LockSection@Ogre@@QAE@XZ:PROC		; Ogre::LockSection::~LockSection
EXTRN	??0LockSection@Ogre@@QAE@XZ:PROC		; Ogre::LockSection::LockSection
;	COMDAT xdata$x
; File i:\svnroot\client\ogremain\ogrepackagefile.h
xdata$x	SEGMENT
__ehfuncinfo$??0FilePackage@Ogre@@QAE@XZ DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$??0FilePackage@Ogre@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__unwindtable$??0FilePackage@Ogre@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0FilePackage@Ogre@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0FilePackage@Ogre@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0FilePackage@Ogre@@QAE@XZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$??0FilePackage@Ogre@@QAE@XZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$??0FilePackage@Ogre@@QAE@XZ$4
	DD	04H
	DD	FLAT:__unwindfunclet$??0FilePackage@Ogre@@QAE@XZ$5
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0FilePackage@Ogre@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0FilePackage@Ogre@@QAE@XZ PROC			; Ogre::FilePackage::FilePackage, COMDAT
; _this$ = ecx

; 60   : 		FilePackage() : m_FP(NULL), m_MaxOriginSize(0), m_MaxPackSize(0), m_PackBuffer(NULL), m_BufferObjectCount(0){}

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0FilePackage@Ogre@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??0?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::vector<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 60					; 0000003cH
	call	??0LockSection@Ogre@@QAE@XZ		; Ogre::LockSection::LockSection
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 64					; 00000040H
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+92], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+96], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+100], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 104				; 00000068H
	call	??0?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::vector<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+128], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 132				; 00000084H
	call	??0LockSection@Ogre@@QAE@XZ		; Ogre::LockSection::LockSection
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 136				; 00000088H
	call	??0LockSection@Ogre@@QAE@XZ		; Ogre::LockSection::LockSection
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0FilePackage@Ogre@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	jmp	??1?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::~vector<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >
__unwindfunclet$??0FilePackage@Ogre@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 60					; 0000003cH
	jmp	??1LockSection@Ogre@@QAE@XZ		; Ogre::LockSection::~LockSection
__unwindfunclet$??0FilePackage@Ogre@@QAE@XZ$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 64					; 00000040H
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$??0FilePackage@Ogre@@QAE@XZ$3:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 104				; 00000068H
	jmp	??1?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::~vector<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >
__unwindfunclet$??0FilePackage@Ogre@@QAE@XZ$4:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 132				; 00000084H
	jmp	??1LockSection@Ogre@@QAE@XZ		; Ogre::LockSection::~LockSection
__unwindfunclet$??0FilePackage@Ogre@@QAE@XZ$5:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 136				; 00000088H
	jmp	??1LockSection@Ogre@@QAE@XZ		; Ogre::LockSection::~LockSection
__ehhandler$??0FilePackage@Ogre@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0FilePackage@Ogre@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0FilePackage@Ogre@@QAE@XZ ENDP			; Ogre::FilePackage::FilePackage
PUBLIC	?close@FilePackage@Ogre@@QAEXXZ			; Ogre::FilePackage::close
PUBLIC	??1FilePackage@Ogre@@QAE@XZ			; Ogre::FilePackage::~FilePackage
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1FilePackage@Ogre@@QAE@XZ DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$??1FilePackage@Ogre@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__unwindtable$??1FilePackage@Ogre@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1FilePackage@Ogre@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1FilePackage@Ogre@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??1FilePackage@Ogre@@QAE@XZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$??1FilePackage@Ogre@@QAE@XZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$??1FilePackage@Ogre@@QAE@XZ$4
	DD	04H
	DD	FLAT:__unwindfunclet$??1FilePackage@Ogre@@QAE@XZ$5
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1FilePackage@Ogre@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1FilePackage@Ogre@@QAE@XZ PROC			; Ogre::FilePackage::~FilePackage, COMDAT
; _this$ = ecx

; 61   : 		~FilePackage() {close();}

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1FilePackage@Ogre@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 5
	mov	ecx, DWORD PTR _this$[ebp]
	call	?close@FilePackage@Ogre@@QAEXXZ		; Ogre::FilePackage::close
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 136				; 00000088H
	call	??1LockSection@Ogre@@QAE@XZ		; Ogre::LockSection::~LockSection
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 132				; 00000084H
	call	??1LockSection@Ogre@@QAE@XZ		; Ogre::LockSection::~LockSection
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 104				; 00000068H
	call	??1?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::~vector<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 64					; 00000040H
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 60					; 0000003cH
	call	??1LockSection@Ogre@@QAE@XZ		; Ogre::LockSection::~LockSection
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??1?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::~vector<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1FilePackage@Ogre@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	jmp	??1?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::~vector<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >
__unwindfunclet$??1FilePackage@Ogre@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 60					; 0000003cH
	jmp	??1LockSection@Ogre@@QAE@XZ		; Ogre::LockSection::~LockSection
__unwindfunclet$??1FilePackage@Ogre@@QAE@XZ$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 64					; 00000040H
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$??1FilePackage@Ogre@@QAE@XZ$3:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 104				; 00000068H
	jmp	??1?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::~vector<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >
__unwindfunclet$??1FilePackage@Ogre@@QAE@XZ$4:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 132				; 00000084H
	jmp	??1LockSection@Ogre@@QAE@XZ		; Ogre::LockSection::~LockSection
__unwindfunclet$??1FilePackage@Ogre@@QAE@XZ$5:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 136				; 00000088H
	jmp	??1LockSection@Ogre@@QAE@XZ		; Ogre::LockSection::~LockSection
__ehhandler$??1FilePackage@Ogre@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1FilePackage@Ogre@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1FilePackage@Ogre@@QAE@XZ ENDP			; Ogre::FilePackage::~FilePackage
PUBLIC	?size@?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::size
PUBLIC	?getNumFiles@FilePackage@Ogre@@QAEIXZ		; Ogre::FilePackage::getNumFiles
; Function compile flags: /Odtp
;	COMDAT ?getNumFiles@FilePackage@Ogre@@QAEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getNumFiles@FilePackage@Ogre@@QAEIXZ PROC		; Ogre::FilePackage::getNumFiles, COMDAT
; _this$ = ecx

; 67   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 68   : 			return m_FileTable.size();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	?size@?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::size

; 69   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?getNumFiles@FilePackage@Ogre@@QAEIXZ ENDP		; Ogre::FilePackage::getNumFiles
_TEXT	ENDS
PUBLIC	??A?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QAEAAUPkgFileInfo@Ogre@@I@Z ; std::vector<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::operator[]
PUBLIC	?getFileInfo@FilePackage@Ogre@@QAEABUPkgFileInfo@2@I@Z ; Ogre::FilePackage::getFileInfo
; Function compile flags: /Odtp
;	COMDAT ?getFileInfo@FilePackage@Ogre@@QAEABUPkgFileInfo@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_i$ = 8							; size = 4
?getFileInfo@FilePackage@Ogre@@QAEABUPkgFileInfo@2@I@Z PROC ; Ogre::FilePackage::getFileInfo, COMDAT
; _this$ = ecx

; 72   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 73   : 			return m_FileTable[i];

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??A?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QAEAAUPkgFileInfo@Ogre@@I@Z ; std::vector<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::operator[]

; 74   : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?getFileInfo@FilePackage@Ogre@@QAEABUPkgFileInfo@2@I@Z ENDP ; Ogre::FilePackage::getFileInfo
_TEXT	ENDS
PUBLIC	?getPackagePath@FilePackage@Ogre@@QAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ; Ogre::FilePackage::getPackagePath
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?getPackagePath@FilePackage@Ogre@@QAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?getPackagePath@FilePackage@Ogre@@QAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ$0
__ehfuncinfo$?getPackagePath@FilePackage@Ogre@@QAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?getPackagePath@FilePackage@Ogre@@QAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?getPackagePath@FilePackage@Ogre@@QAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T124057 = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
?getPackagePath@FilePackage@Ogre@@QAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ PROC ; Ogre::FilePackage::getPackagePath, COMDAT
; _this$ = ecx

; 77   : 		{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?getPackagePath@FilePackage@Ogre@@QAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T124057[ebp], 0

; 78   : 			return m_PackagePath;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 64					; 00000040H
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR $T124057[ebp]
	or	ecx, 1
	mov	DWORD PTR $T124057[ebp], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 79   : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?getPackagePath@FilePackage@Ogre@@QAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ$0:
	mov	eax, DWORD PTR $T124057[ebp]
	and	eax, 1
	je	$LN4@getPackage
	and	DWORD PTR $T124057[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN4@getPackage:
	ret	0
__ehhandler$?getPackagePath@FilePackage@Ogre@@QAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?getPackagePath@FilePackage@Ogre@@QAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?getPackagePath@FilePackage@Ogre@@QAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ENDP ; Ogre::FilePackage::getPackagePath
PUBLIC	??0?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QAE@ABV01@@Z ; std::vector<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::vector<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >
PUBLIC	??0?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QAE@ABV01@@Z ; std::vector<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::vector<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >
PUBLIC	??0FilePackage@Ogre@@QAE@ABV01@@Z		; Ogre::FilePackage::FilePackage
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0FilePackage@Ogre@@QAE@ABV01@@Z DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$??0FilePackage@Ogre@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__unwindtable$??0FilePackage@Ogre@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0FilePackage@Ogre@@QAE@ABV01@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0FilePackage@Ogre@@QAE@ABV01@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0FilePackage@Ogre@@QAE@ABV01@@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$??0FilePackage@Ogre@@QAE@ABV01@@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$??0FilePackage@Ogre@@QAE@ABV01@@Z$4
	DD	04H
	DD	FLAT:__unwindfunclet$??0FilePackage@Ogre@@QAE@ABV01@@Z$5
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0FilePackage@Ogre@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0FilePackage@Ogre@@QAE@ABV01@@Z PROC			; Ogre::FilePackage::FilePackage, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0FilePackage@Ogre@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	esi, DWORD PTR ___that$[ebp]
	add	esi, 8
	mov	edi, DWORD PTR _this$[ebp]
	add	edi, 8
	mov	ecx, 7
	rep movsd
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 36					; 00000024H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??0?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QAE@ABV01@@Z ; std::vector<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::vector<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+60]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+60], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	ecx, DWORD PTR ___that$[ebp]
	add	ecx, 64					; 00000040H
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 64					; 00000040H
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+92]
	mov	DWORD PTR [edx+92], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+96]
	mov	DWORD PTR [edx+96], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+100]
	mov	DWORD PTR [edx+100], ecx
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 104				; 00000068H
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 104				; 00000068H
	call	??0?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QAE@ABV01@@Z ; std::vector<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::vector<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+128]
	mov	DWORD PTR [eax+128], edx
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+132]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+132], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+136]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+136], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0FilePackage@Ogre@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	jmp	??1?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::~vector<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >
__unwindfunclet$??0FilePackage@Ogre@@QAE@ABV01@@Z$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 60					; 0000003cH
	jmp	??1LockSection@Ogre@@QAE@XZ		; Ogre::LockSection::~LockSection
__unwindfunclet$??0FilePackage@Ogre@@QAE@ABV01@@Z$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 64					; 00000040H
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$??0FilePackage@Ogre@@QAE@ABV01@@Z$3:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 104				; 00000068H
	jmp	??1?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::~vector<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >
__unwindfunclet$??0FilePackage@Ogre@@QAE@ABV01@@Z$4:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 132				; 00000084H
	jmp	??1LockSection@Ogre@@QAE@XZ		; Ogre::LockSection::~LockSection
__unwindfunclet$??0FilePackage@Ogre@@QAE@ABV01@@Z$5:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 136				; 00000088H
	jmp	??1LockSection@Ogre@@QAE@XZ		; Ogre::LockSection::~LockSection
__ehhandler$??0FilePackage@Ogre@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0FilePackage@Ogre@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0FilePackage@Ogre@@QAE@ABV01@@Z ENDP			; Ogre::FilePackage::FilePackage
PUBLIC	??4?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::operator=
PUBLIC	??4?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::operator=
PUBLIC	??4FilePackage@Ogre@@QAEAAV01@ABV01@@Z		; Ogre::FilePackage::operator=
; Function compile flags: /Odtp
;	COMDAT ??4FilePackage@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4FilePackage@Ogre@@QAEAAV01@ABV01@@Z PROC		; Ogre::FilePackage::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	esi, DWORD PTR ___that$[ebp]
	add	esi, 8
	mov	edi, DWORD PTR _this$[ebp]
	add	edi, 8
	mov	ecx, 7
	rep movsd
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 36					; 00000024H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??4?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::operator=
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+60]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+60], edx
	mov	ecx, DWORD PTR ___that$[ebp]
	add	ecx, 64					; 00000040H
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 64					; 00000040H
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+92]
	mov	DWORD PTR [edx+92], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+96]
	mov	DWORD PTR [edx+96], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+100]
	mov	DWORD PTR [edx+100], ecx
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 104				; 00000068H
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 104				; 00000068H
	call	??4?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::operator=
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+128]
	mov	DWORD PTR [eax+128], edx
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+132]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+132], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+136]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+136], ecx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
??4FilePackage@Ogre@@QAEAAV01@ABV01@@Z ENDP		; Ogre::FilePackage::operator=
_TEXT	ENDS
PUBLIC	??4StringUtil@Ogre@@QAEAAV01@ABV01@@Z		; Ogre::StringUtil::operator=
; Function compile flags: /Odtp
;	COMDAT ??4StringUtil@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4StringUtil@Ogre@@QAEAAV01@ABV01@@Z PROC		; Ogre::StringUtil::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4StringUtil@Ogre@@QAEAAV01@ABV01@@Z ENDP		; Ogre::StringUtil::operator=
_TEXT	ENDS
PUBLIC	??4MemoryDelegation@Ogre@@QAEAAV01@ABV01@@Z	; Ogre::MemoryDelegation::operator=
; Function compile flags: /Odtp
;	COMDAT ??4MemoryDelegation@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4MemoryDelegation@Ogre@@QAEAAV01@ABV01@@Z PROC	; Ogre::MemoryDelegation::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4MemoryDelegation@Ogre@@QAEAAV01@ABV01@@Z ENDP	; Ogre::MemoryDelegation::operator=
_TEXT	ENDS
PUBLIC	??0PackageDataStreamObject@Ogre@@QAE@PAVFilePackage@1@I@Z ; Ogre::PackageDataStreamObject::PackageDataStreamObject
EXTRN	?alloc@Ogre@@YAPAXI@Z:PROC			; Ogre::alloc
xdata$x	SEGMENT
__unwindtable$??0PackageDataStreamObject@Ogre@@QAE@PAVFilePackage@1@I@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0PackageDataStreamObject@Ogre@@QAE@PAVFilePackage@1@I@Z$0
__ehfuncinfo$??0PackageDataStreamObject@Ogre@@QAE@PAVFilePackage@1@I@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0PackageDataStreamObject@Ogre@@QAE@PAVFilePackage@1@I@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogrepackagefile.cpp
xdata$x	ENDS
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_pkg$ = 8						; size = 4
_size$ = 12						; size = 4
??0PackageDataStreamObject@Ogre@@QAE@PAVFilePackage@1@I@Z PROC ; Ogre::PackageDataStreamObject::PackageDataStreamObject
; _this$ = ecx

; 45   : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0PackageDataStreamObject@Ogre@@QAE@PAVFilePackage@1@I@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0DataStreamObject@Ogre@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7PackageDataStreamObject@Ogre@@6B@

; 46   : 		mPkg = pkg;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _pkg$[ebp]
	mov	DWORD PTR [ecx+4], edx

; 47   : 		mPtr = alloc(size);

	mov	eax, DWORD PTR _size$[ebp]
	push	eax
	call	?alloc@Ogre@@YAPAXI@Z			; Ogre::alloc
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 48   : 		mSize = size;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _size$[ebp]
	mov	DWORD PTR [edx+8], eax

; 49   : 		mLength = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 0

; 50   : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$??0PackageDataStreamObject@Ogre@@QAE@PAVFilePackage@1@I@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1DataStreamObject@Ogre@@MAE@XZ	; Ogre::DataStreamObject::~DataStreamObject
__ehhandler$??0PackageDataStreamObject@Ogre@@QAE@PAVFilePackage@1@I@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0PackageDataStreamObject@Ogre@@QAE@PAVFilePackage@1@I@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0PackageDataStreamObject@Ogre@@QAE@PAVFilePackage@1@I@Z ENDP ; Ogre::PackageDataStreamObject::PackageDataStreamObject
EXTRN	?release@Ogre@@YAXPAX@Z:PROC			; Ogre::release
xdata$x	SEGMENT
__unwindtable$??1PackageDataStreamObject@Ogre@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1PackageDataStreamObject@Ogre@@UAE@XZ$0
__ehfuncinfo$??1PackageDataStreamObject@Ogre@@UAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1PackageDataStreamObject@Ogre@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1PackageDataStreamObject@Ogre@@UAE@XZ PROC		; Ogre::PackageDataStreamObject::~PackageDataStreamObject
; _this$ = ecx

; 53   : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1PackageDataStreamObject@Ogre@@UAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7PackageDataStreamObject@Ogre@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 54   : 		Ogre::release(mPtr);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	call	?release@Ogre@@YAXPAX@Z			; Ogre::release
	add	esp, 4

; 55   : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1DataStreamObject@Ogre@@MAE@XZ	; Ogre::DataStreamObject::~DataStreamObject
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$??1PackageDataStreamObject@Ogre@@UAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1DataStreamObject@Ogre@@MAE@XZ	; Ogre::DataStreamObject::~DataStreamObject
__ehhandler$??1PackageDataStreamObject@Ogre@@UAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1PackageDataStreamObject@Ogre@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1PackageDataStreamObject@Ogre@@UAE@XZ ENDP		; Ogre::PackageDataStreamObject::~PackageDataStreamObject
PUBLIC	?freeBufferObject@FilePackage@Ogre@@QAEXPAVPackageDataStreamObject@2@@Z ; Ogre::FilePackage::freeBufferObject
; Function compile flags: /Odtp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?release@PackageDataStreamObject@Ogre@@UAEXXZ PROC	; Ogre::PackageDataStreamObject::release
; _this$ = ecx

; 58   : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 59   : 		mPkg->freeBufferObject(this);

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	call	?freeBufferObject@FilePackage@Ogre@@QAEXPAVPackageDataStreamObject@2@@Z ; Ogre::FilePackage::freeBufferObject

; 60   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?release@PackageDataStreamObject@Ogre@@UAEXXZ ENDP	; Ogre::PackageDataStreamObject::release
; Function compile flags: /Odtp
_this$ = -4						; size = 4
?buffer@PackageDataStreamObject@Ogre@@UAEPAXXZ PROC	; Ogre::PackageDataStreamObject::buffer
; _this$ = ecx

; 63   : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 64   : 		return mPtr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+16]

; 65   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?buffer@PackageDataStreamObject@Ogre@@UAEPAXXZ ENDP	; Ogre::PackageDataStreamObject::buffer
; Function compile flags: /Odtp
_this$ = -4						; size = 4
_len$ = 8						; size = 4
?buffer@PackageDataStreamObject@Ogre@@UAEPAXI@Z PROC	; Ogre::PackageDataStreamObject::buffer
; _this$ = ecx

; 68   : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 69   : 		if (len <= mSize)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _len$[ebp]
	cmp	ecx, DWORD PTR [eax+8]
	ja	SHORT $LN1@buffer

; 70   : 		{
; 71   : 			return mPtr;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	jmp	SHORT $LN2@buffer
$LN1@buffer:

; 72   : 		}
; 73   : 		return NULL;

	xor	eax, eax
$LN2@buffer:

; 74   : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
?buffer@PackageDataStreamObject@Ogre@@UAEPAXI@Z ENDP	; Ogre::PackageDataStreamObject::buffer
; Function compile flags: /Odtp
_this$ = -4						; size = 4
?length@PackageDataStreamObject@Ogre@@UAEIXZ PROC	; Ogre::PackageDataStreamObject::length
; _this$ = ecx

; 77   : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 78   : 		return mLength;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+12]

; 79   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?length@PackageDataStreamObject@Ogre@@UAEIXZ ENDP	; Ogre::PackageDataStreamObject::length
; Function compile flags: /Odtp
_this$ = -4						; size = 4
?size@PackageDataStreamObject@Ogre@@UAEIXZ PROC		; Ogre::PackageDataStreamObject::size
; _this$ = ecx

; 82   : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 83   : 		return mSize;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]

; 84   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?size@PackageDataStreamObject@Ogre@@UAEIXZ ENDP		; Ogre::PackageDataStreamObject::size
; Function compile flags: /Odtp
_this$ = -4						; size = 4
_len$ = 8						; size = 4
?shift@PackageDataStreamObject@Ogre@@UAEXI@Z PROC	; Ogre::PackageDataStreamObject::shift
; _this$ = ecx

; 87   : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 88   : 		mLength = len;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _len$[ebp]
	mov	DWORD PTR [eax+12], ecx

; 89   : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
?shift@PackageDataStreamObject@Ogre@@UAEXI@Z ENDP	; Ogre::PackageDataStreamObject::shift
_TEXT	ENDS
PUBLIC	?resize@?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QAEXI@Z ; std::vector<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::resize
PUBLIC	?open@FilePackage@Ogre@@QAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z ; Ogre::FilePackage::open
EXTRN	__imp__fseek:PROC
EXTRN	__imp__fread:PROC
EXTRN	?LogMessage@Ogre@@YAXPBDZZ:PROC			; Ogre::LogMessage
EXTRN	?LogSetCurParam@Ogre@@YAXPBDHI@Z:PROC		; Ogre::LogSetCurParam
EXTRN	__imp__fopen:PROC
EXTRN	__imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ:PROC
; Function compile flags: /Odtp
_TEXT	SEGMENT
tv71 = -16						; size = 4
_this$ = -12						; size = 4
_info$116436 = -8					; size = 4
_i$116432 = -4						; size = 4
_packpath$ = 8						; size = 4
_readonly$ = 12						; size = 1
?open@FilePackage@Ogre@@QAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z PROC ; Ogre::FilePackage::open
; _this$ = ecx

; 92   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 93   : 		m_ReadOnly = readonly;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR _readonly$[ebp]
	mov	BYTE PTR [eax], cl

; 94   : 		m_PackagePath = packpath;

	mov	edx, DWORD PTR _packpath$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 64					; 00000040H
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z

; 95   : 		m_FP = fopen(packpath.c_str(), readonly?"rb":"r+b");

	movzx	eax, BYTE PTR _readonly$[ebp]
	test	eax, eax
	je	SHORT $LN16@open
	mov	DWORD PTR tv71[ebp], OFFSET $SG116414
	jmp	SHORT $LN17@open
$LN16@open:
	mov	DWORD PTR tv71[ebp], OFFSET $SG116415
$LN17@open:
	mov	ecx, DWORD PTR tv71[ebp]
	push	ecx
	mov	ecx, DWORD PTR _packpath$[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	call	DWORD PTR __imp__fopen
	add	esp, 8
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], eax

; 96   : 		if(m_FP == NULL)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	$LN13@open

; 97   : 		{
; 98   : 			if(readonly)

	movzx	ecx, BYTE PTR _readonly$[ebp]
	test	ecx, ecx
	je	SHORT $LN12@open

; 99   : 			{
; 100  : 				LOG_SEVERE("open pkgfile error: %s", packpath.c_str());

	push	8
	push	100					; 00000064H
	push	OFFSET $SG116418
	call	?LogSetCurParam@Ogre@@YAXPBDHI@Z	; Ogre::LogSetCurParam
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR _packpath$[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	push	OFFSET $SG116419
	call	?LogMessage@Ogre@@YAXPBDZZ		; Ogre::LogMessage
	add	esp, 8

; 101  : 				return false;

	xor	al, al
	jmp	$LN14@open

; 102  : 			}
; 103  : 			else

	jmp	SHORT $LN13@open
$LN12@open:

; 104  : 			{
; 105  : 				if(!NewPackageFile(packpath.c_str())) 

	mov	ecx, DWORD PTR _packpath$[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	call	?NewPackageFile@Ogre@@YA_NPBD@Z		; Ogre::NewPackageFile
	add	esp, 4
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN10@open

; 106  : 					return false;

	xor	al, al
	jmp	$LN14@open
$LN10@open:

; 107  : 				m_FP = fopen(packpath.c_str(), "r+b");

	push	OFFSET $SG116422
	mov	ecx, DWORD PTR _packpath$[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	call	DWORD PTR __imp__fopen
	add	esp, 8
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 108  : 				if(m_FP == NULL)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+4], 0
	jne	SHORT $LN13@open

; 109  : 					return false;

	xor	al, al
	jmp	$LN14@open
$LN13@open:

; 110  : 			}
; 111  : 		} 
; 112  : 
; 113  : 		if(1 != fread(&m_PkgDesc, sizeof(m_PkgDesc), 1, m_FP))

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	push	1
	push	28					; 0000001cH
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 8
	push	edx
	call	DWORD PTR __imp__fread
	add	esp, 16					; 00000010H
	cmp	eax, 1
	je	SHORT $LN8@open

; 114  : 		{
; 115  : 			LOG_SEVERE("read pkgfile error: %s", packpath.c_str());

	push	8
	push	115					; 00000073H
	push	OFFSET $SG116425
	call	?LogSetCurParam@Ogre@@YAXPBDHI@Z	; Ogre::LogSetCurParam
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR _packpath$[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	push	OFFSET $SG116426
	call	?LogMessage@Ogre@@YAXPBDZZ		; Ogre::LogMessage
	add	esp, 8

; 116  : 			return false;

	xor	al, al
	jmp	$LN14@open
$LN8@open:

; 117  : 		}
; 118  : 
; 119  : 		m_FileTable.resize(m_PkgDesc.numfiles);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	?resize@?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QAEXI@Z ; std::vector<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::resize

; 120  : 		if(m_PkgDesc.numfiles > 0)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+16], 0
	jle	SHORT $LN7@open

; 121  : 		{
; 122  : 			fseek(m_FP, m_PkgDesc.keyoffset, SEEK_SET);

	push	0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	DWORD PTR __imp__fseek
	add	esp, 12					; 0000000cH

; 123  : 			if(1!=fread(&m_FileTable[0], m_PkgDesc.numfiles*sizeof(PkgFileInfo), 1, m_FP))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	push	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	imul	ecx, 24					; 00000018H
	push	ecx
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??A?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QAEAAUPkgFileInfo@Ogre@@I@Z ; std::vector<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::operator[]
	push	eax
	call	DWORD PTR __imp__fread
	add	esp, 16					; 00000010H
	cmp	eax, 1
	je	SHORT $LN7@open

; 124  : 			{
; 125  : 				LOG_SEVERE("read pkgfile error: %s", packpath.c_str());

	push	8
	push	125					; 0000007dH
	push	OFFSET $SG116430
	call	?LogSetCurParam@Ogre@@YAXPBDHI@Z	; Ogre::LogSetCurParam
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR _packpath$[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	push	OFFSET $SG116431
	call	?LogMessage@Ogre@@YAXPBDZZ		; Ogre::LogMessage
	add	esp, 8

; 126  : 				return false;

	xor	al, al
	jmp	$LN14@open
$LN7@open:

; 127  : 			}
; 128  : 		}
; 129  : 		m_MaxOriginSize = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+92], 0

; 130  : 		m_MaxPackSize = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+96], 0

; 131  : 		for (size_t i = 0; i < m_FileTable.size(); ++i)

	mov	DWORD PTR _i$116432[ebp], 0
	jmp	SHORT $LN5@open
$LN4@open:
	mov	ecx, DWORD PTR _i$116432[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$116432[ebp], ecx
$LN5@open:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	?size@?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::size
	cmp	DWORD PTR _i$116432[ebp], eax
	jae	SHORT $LN3@open

; 132  : 		{
; 133  : 			PkgFileInfo &info = m_FileTable[i];

	mov	edx, DWORD PTR _i$116432[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??A?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QAEAAUPkgFileInfo@Ogre@@I@Z ; std::vector<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::operator[]
	mov	DWORD PTR _info$116436[ebp], eax

; 134  : 			if (m_MaxOriginSize < info.originsize)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _info$116436[ebp]
	mov	edx, DWORD PTR [eax+92]
	cmp	edx, DWORD PTR [ecx+12]
	jae	SHORT $LN2@open

; 135  : 			{
; 136  : 				m_MaxOriginSize = info.originsize;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _info$116436[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+92], edx
$LN2@open:

; 137  : 			}
; 138  : 			if (m_MaxPackSize < info.packsize)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _info$116436[ebp]
	mov	edx, DWORD PTR [eax+96]
	cmp	edx, DWORD PTR [ecx+16]
	jae	SHORT $LN1@open

; 139  : 			{
; 140  : 				m_MaxPackSize = info.packsize;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _info$116436[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+96], edx
$LN1@open:

; 141  : 			}
; 142  : 		}

	jmp	SHORT $LN4@open
$LN3@open:

; 143  : 		m_PackBuffer = alloc(m_MaxPackSize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+96]
	push	ecx
	call	?alloc@Ogre@@YAPAXI@Z			; Ogre::alloc
	add	esp, 4
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+100], eax

; 144  : 
; 145  : 		return true;

	mov	al, 1
$LN14@open:

; 146  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?open@FilePackage@Ogre@@QAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z ENDP ; Ogre::FilePackage::open
_TEXT	ENDS
EXTRN	__imp__fclose:PROC
EXTRN	__imp__fwrite:PROC
; Function compile flags: /Odtp
_TEXT	SEGMENT
_fp$ = -32						; size = 4
_pkgheader$ = -28					; size = 28
_path$ = 8						; size = 4
?NewPackageFile@Ogre@@YA_NPBD@Z PROC			; Ogre::NewPackageFile

; 17   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H

; 18   : 		FILE *fp = fopen(path, "wb" );

	push	OFFSET $SG116374
	mov	eax, DWORD PTR _path$[ebp]
	push	eax
	call	DWORD PTR __imp__fopen
	add	esp, 8
	mov	DWORD PTR _fp$[ebp], eax

; 19   : 		if(fp == NULL)

	cmp	DWORD PTR _fp$[ebp], 0
	jne	SHORT $LN2@NewPackage

; 20   : 		{
; 21   : 			return false;

	xor	al, al
	jmp	$LN3@NewPackage
$LN2@NewPackage:

; 22   : 		}
; 23   : 
; 24   : 		PackageHeader pkgheader;
; 25   : 		pkgheader.id = 0x56789abc;

	mov	DWORD PTR _pkgheader$[ebp], 1450744508	; 56789abcH

; 26   : 		pkgheader.version = PACKAGE_VERSION;

	mov	DWORD PTR _pkgheader$[ebp+4], 100	; 00000064H

; 27   : 		pkgheader.numfiles = 0;

	mov	DWORD PTR _pkgheader$[ebp+8], 0

; 28   : 		pkgheader.keyoffset = sizeof(pkgheader);

	mov	DWORD PTR _pkgheader$[ebp+12], 28	; 0000001cH

; 29   : 		pkgheader.keylen = 0;

	mov	DWORD PTR _pkgheader$[ebp+16], 0

; 30   : 		pkgheader.dataoffset = sizeof(pkgheader);

	mov	DWORD PTR _pkgheader$[ebp+20], 28	; 0000001cH

; 31   : 		pkgheader.datalen = 0;

	mov	DWORD PTR _pkgheader$[ebp+24], 0

; 32   : 
; 33   : 		if(fwrite(&pkgheader, sizeof(pkgheader), 1, fp) != 1)

	mov	ecx, DWORD PTR _fp$[ebp]
	push	ecx
	push	1
	push	28					; 0000001cH
	lea	edx, DWORD PTR _pkgheader$[ebp]
	push	edx
	call	DWORD PTR __imp__fwrite
	add	esp, 16					; 00000010H
	cmp	eax, 1
	je	SHORT $LN1@NewPackage

; 34   : 		{
; 35   : 			LOG_SEVERE("write pkgfile error");

	push	8
	push	35					; 00000023H
	push	OFFSET $SG116378
	call	?LogSetCurParam@Ogre@@YAXPBDHI@Z	; Ogre::LogSetCurParam
	add	esp, 12					; 0000000cH
	push	OFFSET $SG116379
	call	?LogMessage@Ogre@@YAXPBDZZ		; Ogre::LogMessage
	add	esp, 4

; 36   : 			fclose(fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	call	DWORD PTR __imp__fclose
	add	esp, 4

; 37   : 			return false;

	xor	al, al
	jmp	SHORT $LN3@NewPackage
$LN1@NewPackage:

; 38   : 		}
; 39   : 
; 40   : 		fclose(fp);

	mov	ecx, DWORD PTR _fp$[ebp]
	push	ecx
	call	DWORD PTR __imp__fclose
	add	esp, 4

; 41   : 		return true;

	mov	al, 1
$LN3@NewPackage:

; 42   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?NewPackageFile@Ogre@@YA_NPBD@Z ENDP			; Ogre::NewPackageFile
_TEXT	ENDS
PUBLIC	?clear@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QAEXXZ ; std::vector<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::clear
PUBLIC	??A?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QAEAAPAVPackageDataStreamObject@Ogre@@I@Z ; std::vector<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::operator[]
PUBLIC	?size@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::size
xdata$x	SEGMENT
__unwindtable$?close@FilePackage@Ogre@@QAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?close@FilePackage@Ogre@@QAEXXZ$0
__ehfuncinfo$?close@FilePackage@Ogre@@QAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?close@FilePackage@Ogre@@QAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
_TEXT	SEGMENT
tv186 = -36						; size = 4
_this$ = -32						; size = 4
$T124110 = -28						; size = 4
$T124109 = -24						; size = 4
_i$116452 = -20						; size = 4
_functor$116451 = -16					; size = 4
__$EHRec$ = -12						; size = 12
?close@FilePackage@Ogre@@QAEXXZ PROC			; Ogre::FilePackage::close
; _this$ = ecx

; 149  : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?close@FilePackage@Ogre@@QAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 24					; 00000018H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 150  : 		if(!m_ReadOnly && m_FP!=NULL && m_PkgDesc.numfiles>0)

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	$LN7@close
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+4], 0
	je	$LN7@close
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+16], 0
	jle	$LN7@close

; 151  : 		{
; 152  : 			m_PkgDesc.keyoffset = m_PkgDesc.dataoffset + m_PkgDesc.datalen;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+32]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+20], edx

; 153  : 			m_PkgDesc.keylen = m_PkgDesc.numfiles*sizeof(PkgFileInfo);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+24], eax

; 154  : 
; 155  : 			fseek( m_FP, 0, SEEK_SET );

	push	0
	push	0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	DWORD PTR __imp__fseek
	add	esp, 12					; 0000000cH

; 156  : 			if(1 != fwrite(&m_PkgDesc, sizeof(m_PkgDesc), 1, m_FP))

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	push	1
	push	28					; 0000001cH
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	call	DWORD PTR __imp__fwrite
	add	esp, 16					; 00000010H
	cmp	eax, 1
	je	SHORT $LN6@close

; 157  : 			{
; 158  : 				LOG_SEVERE("write pkgfile error");

	push	8
	push	158					; 0000009eH
	push	OFFSET $SG116445
	call	?LogSetCurParam@Ogre@@YAXPBDHI@Z	; Ogre::LogSetCurParam
	add	esp, 12					; 0000000cH
	push	OFFSET $SG116446
	call	?LogMessage@Ogre@@YAXPBDZZ		; Ogre::LogMessage
	add	esp, 4
$LN6@close:

; 159  : 			}
; 160  : 
; 161  : 			fseek(m_FP, m_PkgDesc.keyoffset, SEEK_SET);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	DWORD PTR __imp__fseek
	add	esp, 12					; 0000000cH

; 162  : 			if(1!=fwrite(&m_FileTable[0], m_PkgDesc.keylen, 1, m_FP))

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	push	edx
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??A?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QAEAAUPkgFileInfo@Ogre@@I@Z ; std::vector<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::operator[]
	push	eax
	call	DWORD PTR __imp__fwrite
	add	esp, 16					; 00000010H
	cmp	eax, 1
	je	SHORT $LN7@close

; 163  : 			{
; 164  : 				LOG_SEVERE("write pkgfile error");

	push	8
	push	164					; 000000a4H
	push	OFFSET $SG116448
	call	?LogSetCurParam@Ogre@@YAXPBDHI@Z	; Ogre::LogSetCurParam
	add	esp, 12					; 0000000cH
	push	OFFSET $SG116449
	call	?LogMessage@Ogre@@YAXPBDZZ		; Ogre::LogMessage
	add	esp, 4
$LN7@close:

; 165  : 			}
; 166  : 		}
; 167  : 
; 168  : 		if(m_FP != NULL)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN4@close

; 169  : 		{
; 170  : 			fclose(m_FP);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	DWORD PTR __imp__fclose
	add	esp, 4

; 171  : 			m_FP = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0
$LN4@close:

; 172  : 		}
; 173  : 
; 174  : 		release(m_PackBuffer);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+100]
	push	edx
	call	?release@Ogre@@YAXPAX@Z			; Ogre::release
	add	esp, 4

; 175  : 		m_PackBuffer = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+100], 0

; 176  : 
; 177  : 		{
; 178  : 			LockFunctor functor(&m_MemListMutex);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 136				; 00000088H
	push	ecx
	lea	ecx, DWORD PTR _functor$116451[ebp]
	call	??0LockFunctor@Ogre@@QAE@PAVLockSection@1@@Z ; Ogre::LockFunctor::LockFunctor
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 179  : 			for (size_t i = 0; i < m_OriginMemList.size(); ++i)

	mov	DWORD PTR _i$116452[ebp], 0
	jmp	SHORT $LN3@close
$LN2@close:
	mov	edx, DWORD PTR _i$116452[ebp]
	add	edx, 1
	mov	DWORD PTR _i$116452[ebp], edx
$LN3@close:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 104				; 00000068H
	call	?size@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::size
	cmp	DWORD PTR _i$116452[ebp], eax
	jae	SHORT $LN1@close

; 180  : 			{
; 181  : 				delete m_OriginMemList[i];

	mov	eax, DWORD PTR _i$116452[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 104				; 00000068H
	call	??A?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QAEAAPAVPackageDataStreamObject@Ogre@@I@Z ; std::vector<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::operator[]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T124110[ebp], ecx
	mov	edx, DWORD PTR $T124110[ebp]
	mov	DWORD PTR $T124109[ebp], edx
	cmp	DWORD PTR $T124109[ebp], 0
	je	SHORT $LN10@close
	push	1
	mov	eax, DWORD PTR $T124109[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR $T124109[ebp]
	mov	eax, DWORD PTR [edx]
	call	eax
	mov	DWORD PTR tv186[ebp], eax
	jmp	SHORT $LN11@close
$LN10@close:
	mov	DWORD PTR tv186[ebp], 0
$LN11@close:

; 182  : 			}

	jmp	SHORT $LN2@close
$LN1@close:

; 183  : 			m_OriginMemList.clear();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 104				; 00000068H
	call	?clear@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QAEXXZ ; std::vector<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::clear

; 184  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _functor$116451[ebp]
	call	??1LockFunctor@Ogre@@QAE@XZ		; Ogre::LockFunctor::~LockFunctor

; 185  : 		m_BufferObjectCount = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+128], 0

; 186  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?close@FilePackage@Ogre@@QAEXXZ$0:
	lea	ecx, DWORD PTR _functor$116451[ebp]
	jmp	??1LockFunctor@Ogre@@QAE@XZ		; Ogre::LockFunctor::~LockFunctor
__ehhandler$?close@FilePackage@Ogre@@QAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-28]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?close@FilePackage@Ogre@@QAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?close@FilePackage@Ogre@@QAEXXZ ENDP			; Ogre::FilePackage::close
PUBLIC	??_7PkgFileStream@Ogre@@6B@			; Ogre::PkgFileStream::`vftable'
PUBLIC	??0PkgFileStream@Ogre@@QAE@PAVFilePackage@1@II@Z ; Ogre::PkgFileStream::PkgFileStream
PUBLIC	??_R4PkgFileStream@Ogre@@6B@			; Ogre::PkgFileStream::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVPkgFileStream@Ogre@@@8			; Ogre::PkgFileStream `RTTI Type Descriptor'
PUBLIC	??_R3PkgFileStream@Ogre@@8			; Ogre::PkgFileStream::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2PkgFileStream@Ogre@@8			; Ogre::PkgFileStream::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@PkgFileStream@Ogre@@8		; Ogre::PkgFileStream::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?read@PkgFileStream@Ogre@@UAEIPAXI@Z		; Ogre::PkgFileStream::read
PUBLIC	?write@PkgFileStream@Ogre@@UAEIPBXI@Z		; Ogre::PkgFileStream::write
PUBLIC	?skip@PkgFileStream@Ogre@@UAEXJ@Z		; Ogre::PkgFileStream::skip
PUBLIC	?seek@PkgFileStream@Ogre@@UAEXI@Z		; Ogre::PkgFileStream::seek
PUBLIC	?tell@PkgFileStream@Ogre@@UBEIXZ		; Ogre::PkgFileStream::tell
PUBLIC	?eof@PkgFileStream@Ogre@@UBE_NXZ		; Ogre::PkgFileStream::eof
PUBLIC	?close@PkgFileStream@Ogre@@UAEXXZ		; Ogre::PkgFileStream::close
PUBLIC	?getMemoryImage@PkgFileStream@Ogre@@UAEPAXXZ	; Ogre::PkgFileStream::getMemoryImage
EXTRN	??_EPkgFileStream@Ogre@@UAEPAXI@Z:PROC		; Ogre::PkgFileStream::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@PkgFileStream@Ogre@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@PkgFileStream@Ogre@@8 DD FLAT:??_R0?AVPkgFileStream@Ogre@@@8 ; Ogre::PkgFileStream::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3PkgFileStream@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R2PkgFileStream@Ogre@@8
rdata$r	SEGMENT
??_R2PkgFileStream@Ogre@@8 DD FLAT:??_R1A@?0A@EA@PkgFileStream@Ogre@@8 ; Ogre::PkgFileStream::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@DataStream@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R3PkgFileStream@Ogre@@8
rdata$r	SEGMENT
??_R3PkgFileStream@Ogre@@8 DD 00H			; Ogre::PkgFileStream::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2PkgFileStream@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVPkgFileStream@Ogre@@@8
_DATA	SEGMENT
??_R0?AVPkgFileStream@Ogre@@@8 DD FLAT:??_7type_info@@6B@ ; Ogre::PkgFileStream `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVPkgFileStream@Ogre@@', 00H
_DATA	ENDS
;	COMDAT ??_R4PkgFileStream@Ogre@@6B@
rdata$r	SEGMENT
??_R4PkgFileStream@Ogre@@6B@ DD 00H			; Ogre::PkgFileStream::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVPkgFileStream@Ogre@@@8
	DD	FLAT:??_R3PkgFileStream@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_7PkgFileStream@Ogre@@6B@
CONST	SEGMENT
??_7PkgFileStream@Ogre@@6B@ DD FLAT:??_R4PkgFileStream@Ogre@@6B@ ; Ogre::PkgFileStream::`vftable'
	DD	FLAT:??_EPkgFileStream@Ogre@@UAEPAXI@Z
	DD	FLAT:?read@PkgFileStream@Ogre@@UAEIPAXI@Z
	DD	FLAT:?write@PkgFileStream@Ogre@@UAEIPBXI@Z
	DD	FLAT:?readLine@DataStream@Ogre@@UAEIPADIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	FLAT:?getLine@DataStream@Ogre@@UAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z
	DD	FLAT:?getAsString@DataStream@Ogre@@UAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
	DD	FLAT:?skipLine@DataStream@Ogre@@UAEIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	FLAT:?skip@PkgFileStream@Ogre@@UAEXJ@Z
	DD	FLAT:?seek@PkgFileStream@Ogre@@UAEXI@Z
	DD	FLAT:?tell@PkgFileStream@Ogre@@UBEIXZ
	DD	FLAT:?eof@PkgFileStream@Ogre@@UBE_NXZ
	DD	FLAT:?size@DataStream@Ogre@@UBEIXZ
	DD	FLAT:?close@PkgFileStream@Ogre@@UAEXXZ
	DD	FLAT:?getMemoryImage@PkgFileStream@Ogre@@UAEPAXXZ
CONST	ENDS
xdata$x	SEGMENT
__unwindtable$??0PkgFileStream@Ogre@@QAE@PAVFilePackage@1@II@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0PkgFileStream@Ogre@@QAE@PAVFilePackage@1@II@Z$0
__ehfuncinfo$??0PkgFileStream@Ogre@@QAE@PAVFilePackage@1@II@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0PkgFileStream@Ogre@@QAE@PAVFilePackage@1@II@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_pkg$ = 8						; size = 4
_pkgoffset$ = 12					; size = 4
_filesize$ = 16						; size = 4
??0PkgFileStream@Ogre@@QAE@PAVFilePackage@1@II@Z PROC	; Ogre::PkgFileStream::PkgFileStream
; _this$ = ecx

; 211  : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0PkgFileStream@Ogre@@QAE@PAVFilePackage@1@II@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0DataStream@Ogre@@QAE@XZ		; Ogre::DataStream::DataStream
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7PkgFileStream@Ogre@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _pkg$[ebp]
	mov	DWORD PTR [ecx+36], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pkgoffset$[ebp]
	mov	DWORD PTR [eax+40], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+44], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+48], 0

; 212  : 		mSize = filesize;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _filesize$[ebp]
	mov	DWORD PTR [ecx+32], edx

; 213  : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$??0PkgFileStream@Ogre@@QAE@PAVFilePackage@1@II@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1DataStream@Ogre@@UAE@XZ		; Ogre::DataStream::~DataStream
__ehhandler$??0PkgFileStream@Ogre@@QAE@PAVFilePackage@1@II@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0PkgFileStream@Ogre@@QAE@PAVFilePackage@1@II@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0PkgFileStream@Ogre@@QAE@PAVFilePackage@1@II@Z ENDP	; Ogre::PkgFileStream::PkgFileStream
PUBLIC	??1PkgFileStream@Ogre@@UAE@XZ			; Ogre::PkgFileStream::~PkgFileStream
; Function compile flags: /Odtp
;	COMDAT ??_GPkgFileStream@Ogre@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GPkgFileStream@Ogre@@UAEPAXI@Z PROC			; Ogre::PkgFileStream::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1PkgFileStream@Ogre@@UAE@XZ		; Ogre::PkgFileStream::~PkgFileStream
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@8
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@8:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GPkgFileStream@Ogre@@UAEPAXI@Z ENDP			; Ogre::PkgFileStream::`scalar deleting destructor'
_TEXT	ENDS
xdata$x	SEGMENT
__unwindtable$??1PkgFileStream@Ogre@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1PkgFileStream@Ogre@@UAE@XZ$0
__ehfuncinfo$??1PkgFileStream@Ogre@@UAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1PkgFileStream@Ogre@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1PkgFileStream@Ogre@@UAE@XZ PROC			; Ogre::PkgFileStream::~PkgFileStream
; _this$ = ecx

; 216  : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1PkgFileStream@Ogre@@UAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7PkgFileStream@Ogre@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 217  : 		close();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?close@PkgFileStream@Ogre@@UAEXXZ	; Ogre::PkgFileStream::close

; 218  : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1DataStream@Ogre@@UAE@XZ		; Ogre::DataStream::~DataStream
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$??1PkgFileStream@Ogre@@UAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1DataStream@Ogre@@UAE@XZ		; Ogre::DataStream::~DataStream
__ehhandler$??1PkgFileStream@Ogre@@UAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1PkgFileStream@Ogre@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1PkgFileStream@Ogre@@UAE@XZ ENDP			; Ogre::PkgFileStream::~PkgFileStream
PUBLIC	?readFile@FilePackage@Ogre@@QAEIPAXII@Z		; Ogre::FilePackage::readFile
; Function compile flags: /Odtp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_buf$ = 8						; size = 4
_count$ = 12						; size = 4
?read@PkgFileStream@Ogre@@UAEIPAXI@Z PROC		; Ogre::PkgFileStream::read
; _this$ = ecx

; 221  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 222  : 		return m_pkg->readFile(buf, m_curPos+m_pkgOffset, (unsigned int )count);

	mov	eax, DWORD PTR _count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+40]
	push	edx
	mov	ecx, DWORD PTR _buf$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+36]
	call	?readFile@FilePackage@Ogre@@QAEIPAXII@Z	; Ogre::FilePackage::readFile

; 223  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?read@PkgFileStream@Ogre@@UAEIPAXI@Z ENDP		; Ogre::PkgFileStream::read
; Function compile flags: /Odtp
_this$ = -4						; size = 4
_buf$ = 8						; size = 4
_count$ = 12						; size = 4
?write@PkgFileStream@Ogre@@UAEIPBXI@Z PROC		; Ogre::PkgFileStream::write
; _this$ = ecx

; 226  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 227  : 		assert(0);
; 228  : 		return 0;

	xor	eax, eax

; 229  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?write@PkgFileStream@Ogre@@UAEIPBXI@Z ENDP		; Ogre::PkgFileStream::write
; Function compile flags: /Odtp
_this$ = -4						; size = 4
_count$ = 8						; size = 4
?skip@PkgFileStream@Ogre@@UAEXJ@Z PROC			; Ogre::PkgFileStream::skip
; _this$ = ecx

; 232  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 233  : 		m_curPos += count;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	add	ecx, DWORD PTR _count$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+44], ecx

; 234  : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
?skip@PkgFileStream@Ogre@@UAEXJ@Z ENDP			; Ogre::PkgFileStream::skip
; Function compile flags: /Odtp
_this$ = -4						; size = 4
_pos$ = 8						; size = 4
?seek@PkgFileStream@Ogre@@UAEXI@Z PROC			; Ogre::PkgFileStream::seek
; _this$ = ecx

; 237  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 238  : 		m_curPos = (unsigned int)pos;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pos$[ebp]
	mov	DWORD PTR [eax+44], ecx

; 239  : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
?seek@PkgFileStream@Ogre@@UAEXI@Z ENDP			; Ogre::PkgFileStream::seek
; Function compile flags: /Odtp
_this$ = -4						; size = 4
?tell@PkgFileStream@Ogre@@UBEIXZ PROC			; Ogre::PkgFileStream::tell
; _this$ = ecx

; 242  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 243  : 		return m_curPos;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+44]

; 244  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?tell@PkgFileStream@Ogre@@UBEIXZ ENDP			; Ogre::PkgFileStream::tell
; Function compile flags: /Odtp
_this$ = -4						; size = 4
?eof@PkgFileStream@Ogre@@UBE_NXZ PROC			; Ogre::PkgFileStream::eof
; _this$ = ecx

; 247  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 248  : 		return m_curPos>=mSize;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+44]
	cmp	edx, DWORD PTR [ecx+32]
	sbb	eax, eax
	add	eax, 1

; 249  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?eof@PkgFileStream@Ogre@@UBE_NXZ ENDP			; Ogre::PkgFileStream::eof
; Function compile flags: /Odtp
_this$ = -4						; size = 4
?close@PkgFileStream@Ogre@@UAEXXZ PROC			; Ogre::PkgFileStream::close
; _this$ = ecx

; 252  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 253  : 		if(m_pMemImage)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+48], 0
	je	SHORT $LN2@close@2

; 254  : 		{
; 255  : 			release(m_pMemImage);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+48]
	push	edx
	call	?release@Ogre@@YAXPAX@Z			; Ogre::release
	add	esp, 4

; 256  : 			m_pMemImage = NULL;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+48], 0
$LN2@close@2:

; 257  : 		}
; 258  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?close@PkgFileStream@Ogre@@UAEXXZ ENDP			; Ogre::PkgFileStream::close
; Function compile flags: /Odtp
_this$ = -4						; size = 4
?getMemoryImage@PkgFileStream@Ogre@@UAEPAXXZ PROC	; Ogre::PkgFileStream::getMemoryImage
; _this$ = ecx

; 261  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 262  : 		if(m_pMemImage == NULL)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+48], 0
	jne	SHORT $LN1@getMemoryI

; 263  : 		{
; 264  : 			m_pMemImage = alloc(mSize);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	push	edx
	call	?alloc@Ogre@@YAPAXI@Z			; Ogre::alloc
	add	esp, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+48], eax

; 265  : 			m_pkg->readFile(m_pMemImage, m_pkgOffset, (uint)mSize);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+32]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+36]
	call	?readFile@FilePackage@Ogre@@QAEIPAXII@Z	; Ogre::FilePackage::readFile
$LN1@getMemoryI:

; 266  : 		}
; 267  : 
; 268  : 		return m_pMemImage;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+48]

; 269  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?getMemoryImage@PkgFileStream@Ogre@@UAEPAXXZ ENDP	; Ogre::PkgFileStream::getMemoryImage
_TEXT	ENDS
PUBLIC	?newBufferObject@FilePackage@Ogre@@QAEPAVPackageDataStreamObject@2@XZ ; Ogre::FilePackage::newBufferObject
PUBLIC	?openFile@FilePackage@Ogre@@QAEPAVDataStream@2@H@Z ; Ogre::FilePackage::openFile
EXTRN	??0ObjectDataStream@Ogre@@QAE@PAVDataStreamObject@1@@Z:PROC ; Ogre::ObjectDataStream::ObjectDataStream
EXTRN	_uncompress:PROC
EXTRN	??2@YAPAXI@Z:PROC				; operator new
xdata$x	SEGMENT
__unwindtable$?openFile@FilePackage@Ogre@@QAEPAVDataStream@2@H@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?openFile@FilePackage@Ogre@@QAEPAVDataStream@2@H@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?openFile@FilePackage@Ogre@@QAEPAVDataStream@2@H@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?openFile@FilePackage@Ogre@@QAEPAVDataStream@2@H@Z$2
__ehfuncinfo$?openFile@FilePackage@Ogre@@QAEPAVDataStream@2@H@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?openFile@FilePackage@Ogre@@QAEPAVDataStream@2@H@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
_TEXT	SEGMENT
tv209 = -64						; size = 4
tv128 = -60						; size = 4
_this$ = -56						; size = 4
$T124146 = -52						; size = 4
$T124145 = -48						; size = 4
$T124142 = -44						; size = 4
$T124141 = -40						; size = 4
_destlen$116573 = -36					; size = 4
_functor$116569 = -32					; size = 4
_pobject$116564 = -28					; size = 4
_result$116565 = -21					; size = 1
_pstream$116558 = -20					; size = 4
_info$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_file_number$ = 8					; size = 4
?openFile@FilePackage@Ogre@@QAEPAVDataStream@2@H@Z PROC	; Ogre::FilePackage::openFile
; _this$ = ecx

; 272  : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?openFile@FilePackage@Ogre@@QAEPAVDataStream@2@H@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 52					; 00000034H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 273  : 		if(file_number<0 || file_number>(int)m_FileTable.size())

	cmp	DWORD PTR _file_number$[ebp], 0
	jl	SHORT $LN10@openFile
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	?size@?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::size
	cmp	DWORD PTR _file_number$[ebp], eax
	jle	SHORT $LN11@openFile
$LN10@openFile:

; 274  : 		{
; 275  : 			LOG_SEVERE("openFile wrong file_number:%d", file_number);

	push	8
	push	275					; 00000113H
	push	OFFSET $SG116554
	call	?LogSetCurParam@Ogre@@YAXPBDHI@Z	; Ogre::LogSetCurParam
	add	esp, 12					; 0000000cH
	mov	eax, DWORD PTR _file_number$[ebp]
	push	eax
	push	OFFSET $SG116555
	call	?LogMessage@Ogre@@YAXPBDZZ		; Ogre::LogMessage
	add	esp, 8

; 276  : 			return NULL;

	xor	eax, eax
	jmp	$LN12@openFile
$LN11@openFile:

; 277  : 		}
; 278  : 
; 279  : 		const PkgFileInfo &info = m_FileTable[file_number];

	mov	ecx, DWORD PTR _file_number$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??A?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QAEAAUPkgFileInfo@Ogre@@I@Z ; std::vector<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::operator[]
	mov	DWORD PTR _info$[ebp], eax

; 280  : 
; 281  : 		if((info.flags&1) == 0) //uncompressed file

	mov	edx, DWORD PTR _info$[ebp]
	mov	eax, DWORD PTR [edx+20]
	and	eax, 1
	jne	SHORT $LN9@openFile

; 282  : 		{
; 283  : 			PkgFileStream *pstream = new PkgFileStream(this, info.offset+m_PkgDesc.dataoffset, info.originsize);

	push	52					; 00000034H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T124142[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T124142[ebp], 0
	je	SHORT $LN14@openFile
	mov	ecx, DWORD PTR _info$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+28]
	push	ecx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T124142[ebp]
	call	??0PkgFileStream@Ogre@@QAE@PAVFilePackage@1@II@Z ; Ogre::PkgFileStream::PkgFileStream
	mov	DWORD PTR tv128[ebp], eax
	jmp	SHORT $LN15@openFile
$LN14@openFile:
	mov	DWORD PTR tv128[ebp], 0
$LN15@openFile:
	mov	ecx, DWORD PTR tv128[ebp]
	mov	DWORD PTR $T124141[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	edx, DWORD PTR $T124141[ebp]
	mov	DWORD PTR _pstream$116558[ebp], edx

; 284  : 			return pstream;

	mov	eax, DWORD PTR _pstream$116558[ebp]
	jmp	$LN12@openFile

; 285  : 		}
; 286  : 		else

	jmp	$LN12@openFile
$LN9@openFile:

; 287  : 		{
; 288  : 			PackageDataStreamObject *pobject = newBufferObject();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?newBufferObject@FilePackage@Ogre@@QAEPAVPackageDataStreamObject@2@XZ ; Ogre::FilePackage::newBufferObject
	mov	DWORD PTR _pobject$116564[ebp], eax

; 289  : 
; 290  : 			bool result = false;

	mov	BYTE PTR _result$116565[ebp], 0
$LN7@openFile:

; 291  : 			do 
; 292  : 			{
; 293  : 				LockFunctor functor(&m_PackMutex);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 132				; 00000084H
	push	eax
	lea	ecx, DWORD PTR _functor$116569[ebp]
	call	??0LockFunctor@Ogre@@QAE@PAVLockSection@1@@Z ; Ogre::LockFunctor::LockFunctor
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 294  : 				if(readFile(m_PackBuffer, info.offset, info.packsize) != info.packsize)

	mov	ecx, DWORD PTR _info$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+100]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?readFile@FilePackage@Ogre@@QAEIPAXII@Z	; Ogre::FilePackage::readFile
	mov	ecx, DWORD PTR _info$[ebp]
	cmp	eax, DWORD PTR [ecx+16]
	je	SHORT $LN4@openFile

; 295  : 				{
; 296  : 					LOG_SEVERE("read pkgfile error: %d,%d", info.offset, info.packsize);

	push	8
	push	296					; 00000128H
	push	OFFSET $SG116571
	call	?LogSetCurParam@Ogre@@YAXPBDHI@Z	; Ogre::LogSetCurParam
	add	esp, 12					; 0000000cH
	mov	edx, DWORD PTR _info$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR _info$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	push	OFFSET $SG116572
	call	?LogMessage@Ogre@@YAXPBDZZ		; Ogre::LogMessage
	add	esp, 12					; 0000000cH

; 297  : 					break;

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _functor$116569[ebp]
	call	??1LockFunctor@Ogre@@QAE@XZ		; Ogre::LockFunctor::~LockFunctor
	jmp	$LN5@openFile
$LN4@openFile:

; 298  : 				}
; 299  : 
; 300  : 				uLongf destlen = info.originsize;

	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _destlen$116573[ebp], ecx

; 301  : 				if(uncompress((uchar *)pobject->buffer(), &destlen, (uchar *)m_PackBuffer, info.packsize) != Z_OK || destlen!=info.originsize)

	mov	edx, DWORD PTR _info$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+100]
	push	edx
	lea	eax, DWORD PTR _destlen$116573[ebp]
	push	eax
	mov	ecx, DWORD PTR _pobject$116564[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _pobject$116564[ebp]
	mov	eax, DWORD PTR [edx+12]
	call	eax
	push	eax
	call	_uncompress
	add	esp, 16					; 00000010H
	test	eax, eax
	jne	SHORT $LN2@openFile
	mov	ecx, DWORD PTR _info$[ebp]
	mov	edx, DWORD PTR _destlen$116573[ebp]
	cmp	edx, DWORD PTR [ecx+12]
	je	SHORT $LN3@openFile
$LN2@openFile:

; 302  : 				{
; 303  : 					LOG_SEVERE("uncompress data error: %d, %d", destlen, info.originsize);

	push	8
	push	303					; 0000012fH
	push	OFFSET $SG116578
	call	?LogSetCurParam@Ogre@@YAXPBDHI@Z	; Ogre::LogSetCurParam
	add	esp, 12					; 0000000cH
	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	edx, DWORD PTR _destlen$116573[ebp]
	push	edx
	push	OFFSET $SG116579
	call	?LogMessage@Ogre@@YAXPBDZZ		; Ogre::LogMessage
	add	esp, 12					; 0000000cH

; 304  : 					break;

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _functor$116569[ebp]
	call	??1LockFunctor@Ogre@@QAE@XZ		; Ogre::LockFunctor::~LockFunctor
	jmp	SHORT $LN5@openFile
$LN3@openFile:

; 305  : 				}
; 306  : 				pobject->shift(destlen);

	mov	eax, DWORD PTR _destlen$116573[ebp]
	push	eax
	mov	ecx, DWORD PTR _pobject$116564[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _pobject$116564[ebp]
	mov	eax, DWORD PTR [edx+24]
	call	eax

; 307  : 				result = true;

	mov	BYTE PTR _result$116565[ebp], 1

; 308  : 			} while (false);

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _functor$116569[ebp]
	call	??1LockFunctor@Ogre@@QAE@XZ		; Ogre::LockFunctor::~LockFunctor
	xor	ecx, ecx
	jne	$LN7@openFile
$LN5@openFile:

; 309  : 			if (result)

	movzx	edx, BYTE PTR _result$116565[ebp]
	test	edx, edx
	je	SHORT $LN1@openFile

; 310  : 			{
; 311  : 				return new ObjectDataStream(pobject);

	push	44					; 0000002cH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T124146[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 2
	cmp	DWORD PTR $T124146[ebp], 0
	je	SHORT $LN16@openFile
	mov	eax, DWORD PTR _pobject$116564[ebp]
	push	eax
	mov	ecx, DWORD PTR $T124146[ebp]
	call	??0ObjectDataStream@Ogre@@QAE@PAVDataStreamObject@1@@Z ; Ogre::ObjectDataStream::ObjectDataStream
	mov	DWORD PTR tv209[ebp], eax
	jmp	SHORT $LN17@openFile
$LN16@openFile:
	mov	DWORD PTR tv209[ebp], 0
$LN17@openFile:
	mov	ecx, DWORD PTR tv209[ebp]
	mov	DWORD PTR $T124145[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR $T124145[ebp]
	jmp	SHORT $LN12@openFile
$LN1@openFile:

; 312  : 			}
; 313  : 			freeBufferObject(pobject);

	mov	edx, DWORD PTR _pobject$116564[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?freeBufferObject@FilePackage@Ogre@@QAEXPAVPackageDataStreamObject@2@@Z ; Ogre::FilePackage::freeBufferObject

; 314  : 			return NULL;

	xor	eax, eax
$LN12@openFile:

; 315  : 		}
; 316  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?openFile@FilePackage@Ogre@@QAEPAVDataStream@2@H@Z$0:
	mov	eax, DWORD PTR $T124142[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?openFile@FilePackage@Ogre@@QAEPAVDataStream@2@H@Z$1:
	lea	ecx, DWORD PTR _functor$116569[ebp]
	jmp	??1LockFunctor@Ogre@@QAE@XZ		; Ogre::LockFunctor::~LockFunctor
__unwindfunclet$?openFile@FilePackage@Ogre@@QAEPAVDataStream@2@H@Z$2:
	mov	eax, DWORD PTR $T124146[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?openFile@FilePackage@Ogre@@QAEPAVDataStream@2@H@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-56]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?openFile@FilePackage@Ogre@@QAEPAVDataStream@2@H@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?openFile@FilePackage@Ogre@@QAEPAVDataStream@2@H@Z ENDP	; Ogre::FilePackage::openFile
xdata$x	SEGMENT
__unwindtable$?readFile@FilePackage@Ogre@@QAEIPAXII@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?readFile@FilePackage@Ogre@@QAEIPAXII@Z$0
__ehfuncinfo$?readFile@FilePackage@Ogre@@QAEIPAXII@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?readFile@FilePackage@Ogre@@QAEIPAXII@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
_TEXT	SEGMENT
_this$ = -24						; size = 4
$T124157 = -20						; size = 4
_lockfunc$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_pbuf$ = 8						; size = 4
_offset$ = 12						; size = 4
_len$ = 16						; size = 4
?readFile@FilePackage@Ogre@@QAEIPAXII@Z PROC		; Ogre::FilePackage::readFile
; _this$ = ecx

; 319  : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?readFile@FilePackage@Ogre@@QAEIPAXII@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 12					; 0000000cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 320  : 		LockFunctor lockfunc(&m_Mutex);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 60					; 0000003cH
	push	eax
	lea	ecx, DWORD PTR _lockfunc$[ebp]
	call	??0LockFunctor@Ogre@@QAE@PAVLockSection@1@@Z ; Ogre::LockFunctor::LockFunctor
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 321  : 
; 322  : 		fseek(m_FP, offset, SEEK_SET);

	push	0
	mov	ecx, DWORD PTR _offset$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	DWORD PTR __imp__fseek
	add	esp, 12					; 0000000cH

; 323  : 		return (unsigned int)fread(pbuf, 1, len, m_FP);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR _len$[ebp]
	push	eax
	push	1
	mov	ecx, DWORD PTR _pbuf$[ebp]
	push	ecx
	call	DWORD PTR __imp__fread
	add	esp, 16					; 00000010H
	mov	DWORD PTR $T124157[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _lockfunc$[ebp]
	call	??1LockFunctor@Ogre@@QAE@XZ		; Ogre::LockFunctor::~LockFunctor
	mov	eax, DWORD PTR $T124157[ebp]

; 324  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?readFile@FilePackage@Ogre@@QAEIPAXII@Z$0:
	lea	ecx, DWORD PTR _lockfunc$[ebp]
	jmp	??1LockFunctor@Ogre@@QAE@XZ		; Ogre::LockFunctor::~LockFunctor
__ehhandler$?readFile@FilePackage@Ogre@@QAEIPAXII@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?readFile@FilePackage@Ogre@@QAEIPAXII@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?readFile@FilePackage@Ogre@@QAEIPAXII@Z ENDP		; Ogre::FilePackage::readFile
PUBLIC	?appendOrReplaceFile@FilePackage@Ogre@@QAE_NIIIPBXII@Z ; Ogre::FilePackage::appendOrReplaceFile
EXTRN	_compress:PROC
EXTRN	??_U@YAPAXI@Z:PROC				; operator new[]
EXTRN	_compressBound:PROC
xdata$x	SEGMENT
__unwindtable$?appendOrReplaceFile@FilePackage@Ogre@@QAE_NIIIPBXII@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?appendOrReplaceFile@FilePackage@Ogre@@QAE_NIIIPBXII@Z$0
__ehfuncinfo$?appendOrReplaceFile@FilePackage@Ogre@@QAE_NIIIPBXII@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?appendOrReplaceFile@FilePackage@Ogre@@QAE_NIIIPBXII@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
_TEXT	SEGMENT
_this$ = -80						; size = 4
$T124168 = -74						; size = 1
$T124167 = -73						; size = 1
$T124166 = -72						; size = 4
$T124165 = -65						; size = 1
$T124164 = -64						; size = 4
_info2$116628 = -60					; size = 4
_destlen$116607 = -56					; size = 4
_pcompressed$116608 = -52				; size = 4
_lockfunc$ = -48					; size = 4
_info$ = -44						; size = 24
_n$ = -20						; size = 4
_i$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_key1$ = 8						; size = 4
_key2$ = 12						; size = 4
_flags$ = 16						; size = 4
_pdata$ = 20						; size = 4
_originsize$ = 24					; size = 4
_packsize$ = 28						; size = 4
?appendOrReplaceFile@FilePackage@Ogre@@QAE_NIIIPBXII@Z PROC ; Ogre::FilePackage::appendOrReplaceFile
; _this$ = ecx

; 327  : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?appendOrReplaceFile@FilePackage@Ogre@@QAE_NIIIPBXII@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 328  : 		LockFunctor lockfunc(&m_Mutex);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 60					; 0000003cH
	push	eax
	lea	ecx, DWORD PTR _lockfunc$[ebp]
	call	??0LockFunctor@Ogre@@QAE@PAVLockSection@1@@Z ; Ogre::LockFunctor::LockFunctor
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 329  : 
; 330  : 		PkgFileInfo info;
; 331  : 		info.key1 = key1;

	mov	ecx, DWORD PTR _key1$[ebp]
	mov	DWORD PTR _info$[ebp], ecx

; 332  : 		info.key2 = key2;

	mov	edx, DWORD PTR _key2$[ebp]
	mov	DWORD PTR _info$[ebp+4], edx

; 333  : 		info.flags = flags;

	mov	eax, DWORD PTR _flags$[ebp]
	mov	DWORD PTR _info$[ebp+20], eax

; 334  : 		info.offset = m_PkgDesc.dataoffset + m_PkgDesc.datalen;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+32]
	mov	DWORD PTR _info$[ebp+8], edx

; 335  : 
; 336  : 		fseek(m_FP, info.offset, SEEK_SET);

	push	0
	mov	ecx, DWORD PTR _info$[ebp+8]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	DWORD PTR __imp__fseek
	add	esp, 12					; 0000000cH

; 337  : 
; 338  : 		size_t n;
; 339  : 		if((flags&1) && packsize==0)// 

	mov	ecx, DWORD PTR _flags$[ebp]
	and	ecx, 1
	je	$LN11@appendOrRe
	cmp	DWORD PTR _packsize$[ebp], 0
	jne	$LN11@appendOrRe

; 340  : 		{
; 341  : 			uLongf destlen = compressBound(originsize);

	mov	edx, DWORD PTR _originsize$[ebp]
	push	edx
	call	_compressBound
	add	esp, 4
	mov	DWORD PTR _destlen$116607[ebp], eax

; 342  : 			unsigned char *pcompressed = new unsigned char[destlen];

	mov	eax, DWORD PTR _destlen$116607[ebp]
	push	eax
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T124164[ebp], eax
	mov	ecx, DWORD PTR $T124164[ebp]
	mov	DWORD PTR _pcompressed$116608[ebp], ecx

; 343  : 			if(Z_OK != compress(pcompressed, &destlen, (const Bytef *)pdata, originsize))

	mov	edx, DWORD PTR _originsize$[ebp]
	push	edx
	mov	eax, DWORD PTR _pdata$[ebp]
	push	eax
	lea	ecx, DWORD PTR _destlen$116607[ebp]
	push	ecx
	mov	edx, DWORD PTR _pcompressed$116608[ebp]
	push	edx
	call	_compress
	add	esp, 16					; 00000010H
	test	eax, eax
	je	SHORT $LN10@appendOrRe

; 344  : 			{
; 345  : 				LOG_SEVERE("compress error");

	push	8
	push	345					; 00000159H
	push	OFFSET $SG116613
	call	?LogSetCurParam@Ogre@@YAXPBDHI@Z	; Ogre::LogSetCurParam
	add	esp, 12					; 0000000cH
	push	OFFSET $SG116614
	call	?LogMessage@Ogre@@YAXPBDZZ		; Ogre::LogMessage
	add	esp, 4

; 346  : 				return false;

	mov	BYTE PTR $T124165[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _lockfunc$[ebp]
	call	??1LockFunctor@Ogre@@QAE@XZ		; Ogre::LockFunctor::~LockFunctor
	mov	al, BYTE PTR $T124165[ebp]
	jmp	$LN12@appendOrRe
$LN10@appendOrRe:

; 347  : 			}
; 348  : 
; 349  : 			n = fwrite(pcompressed, destlen, 1, m_FP);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	push	1
	mov	edx, DWORD PTR _destlen$116607[ebp]
	push	edx
	mov	eax, DWORD PTR _pcompressed$116608[ebp]
	push	eax
	call	DWORD PTR __imp__fwrite
	add	esp, 16					; 00000010H
	mov	DWORD PTR _n$[ebp], eax

; 350  : 			info.originsize = originsize;

	mov	ecx, DWORD PTR _originsize$[ebp]
	mov	DWORD PTR _info$[ebp+12], ecx

; 351  : 			info.packsize = destlen;

	mov	edx, DWORD PTR _destlen$116607[ebp]
	mov	DWORD PTR _info$[ebp+16], edx

; 352  : 			delete[] pcompressed;

	mov	eax, DWORD PTR _pcompressed$116608[ebp]
	mov	DWORD PTR $T124166[ebp], eax
	mov	ecx, DWORD PTR $T124166[ebp]
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 353  : 		}
; 354  : 		else

	jmp	SHORT $LN9@appendOrRe
$LN11@appendOrRe:

; 355  : 		{
; 356  : 			n = fwrite(pdata, originsize, 1, m_FP);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	push	1
	mov	ecx, DWORD PTR _originsize$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pdata$[ebp]
	push	edx
	call	DWORD PTR __imp__fwrite
	add	esp, 16					; 00000010H
	mov	DWORD PTR _n$[ebp], eax

; 357  : 			info.originsize = originsize;

	mov	eax, DWORD PTR _originsize$[ebp]
	mov	DWORD PTR _info$[ebp+12], eax

; 358  : 			if(packsize == 0) info.packsize = originsize;

	cmp	DWORD PTR _packsize$[ebp], 0
	jne	SHORT $LN8@appendOrRe
	mov	ecx, DWORD PTR _originsize$[ebp]
	mov	DWORD PTR _info$[ebp+16], ecx
	jmp	SHORT $LN9@appendOrRe
$LN8@appendOrRe:

; 359  : 			else info.packsize = packsize;

	mov	edx, DWORD PTR _packsize$[ebp]
	mov	DWORD PTR _info$[ebp+16], edx
$LN9@appendOrRe:

; 360  : 		}
; 361  : 
; 362  : 		if(n != 1)

	cmp	DWORD PTR _n$[ebp], 1
	je	SHORT $LN6@appendOrRe

; 363  : 		{
; 364  : 			LOG_SEVERE("write pkgfile error: %d, %d", info.packsize, info.originsize);

	push	8
	push	364					; 0000016cH
	push	OFFSET $SG116621
	call	?LogSetCurParam@Ogre@@YAXPBDHI@Z	; Ogre::LogSetCurParam
	add	esp, 12					; 0000000cH
	mov	eax, DWORD PTR _info$[ebp+12]
	push	eax
	mov	ecx, DWORD PTR _info$[ebp+16]
	push	ecx
	push	OFFSET $SG116622
	call	?LogMessage@Ogre@@YAXPBDZZ		; Ogre::LogMessage
	add	esp, 12					; 0000000cH

; 365  : 			return false;

	mov	BYTE PTR $T124167[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _lockfunc$[ebp]
	call	??1LockFunctor@Ogre@@QAE@XZ		; Ogre::LockFunctor::~LockFunctor
	mov	al, BYTE PTR $T124167[ebp]
	jmp	$LN12@appendOrRe
$LN6@appendOrRe:

; 366  : 		}
; 367  : 
; 368  : 		m_PkgDesc.datalen += info.packsize;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+32]
	add	eax, DWORD PTR _info$[ebp+16]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+32], eax

; 369  : 
; 370  : 		size_t i;
; 371  : 		for(i=0; i<m_FileTable.size(); i++)

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN5@appendOrRe
$LN4@appendOrRe:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN5@appendOrRe:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	?size@?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::size
	cmp	DWORD PTR _i$[ebp], eax
	jae	SHORT $LN3@appendOrRe

; 372  : 		{
; 373  : 			PkgFileInfo &info2 = m_FileTable[i];

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??A?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QAEAAUPkgFileInfo@Ogre@@I@Z ; std::vector<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::operator[]
	mov	DWORD PTR _info2$116628[ebp], eax

; 374  : 			if(info2.key1==key1 && info2.key2==key2)

	mov	ecx, DWORD PTR _info2$116628[ebp]
	mov	edx, DWORD PTR [ecx]
	cmp	edx, DWORD PTR _key1$[ebp]
	jne	SHORT $LN2@appendOrRe
	mov	eax, DWORD PTR _info2$116628[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	ecx, DWORD PTR _key2$[ebp]
	jne	SHORT $LN2@appendOrRe

; 375  : 			{
; 376  : 				break;

	jmp	SHORT $LN3@appendOrRe
$LN2@appendOrRe:

; 377  : 			}
; 378  : 		}

	jmp	SHORT $LN4@appendOrRe
$LN3@appendOrRe:

; 379  : 
; 380  : 		if(i == m_FileTable.size())

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	?size@?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::size
	cmp	DWORD PTR _i$[ebp], eax
	jne	SHORT $LN1@appendOrRe

; 381  : 		{
; 382  : 			m_FileTable.resize(i+1);

	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	?resize@?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QAEXI@Z ; std::vector<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::resize

; 383  : 			m_PkgDesc.numfiles++;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+16], ecx
$LN1@appendOrRe:

; 384  : 		}
; 385  : 
; 386  : 		m_FileTable[i] = info;

	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??A?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QAEAAUPkgFileInfo@Ogre@@I@Z ; std::vector<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::operator[]
	mov	ecx, DWORD PTR _info$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _info$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _info$[ebp+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR _info$[ebp+12]
	mov	DWORD PTR [eax+12], edx
	mov	ecx, DWORD PTR _info$[ebp+16]
	mov	DWORD PTR [eax+16], ecx
	mov	edx, DWORD PTR _info$[ebp+20]
	mov	DWORD PTR [eax+20], edx

; 387  : 		return true;

	mov	BYTE PTR $T124168[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _lockfunc$[ebp]
	call	??1LockFunctor@Ogre@@QAE@XZ		; Ogre::LockFunctor::~LockFunctor
	mov	al, BYTE PTR $T124168[ebp]
$LN12@appendOrRe:

; 388  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?appendOrReplaceFile@FilePackage@Ogre@@QAE_NIIIPBXII@Z$0:
	lea	ecx, DWORD PTR _lockfunc$[ebp]
	jmp	??1LockFunctor@Ogre@@QAE@XZ		; Ogre::LockFunctor::~LockFunctor
__ehhandler$?appendOrReplaceFile@FilePackage@Ogre@@QAE_NIIIPBXII@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?appendOrReplaceFile@FilePackage@Ogre@@QAE_NIIIPBXII@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?appendOrReplaceFile@FilePackage@Ogre@@QAE_NIIIPBXII@Z ENDP ; Ogre::FilePackage::appendOrReplaceFile
PUBLIC	?appendOrReplaceFile@FilePackage@Ogre@@QAE_NPBD_N@Z ; Ogre::FilePackage::appendOrReplaceFile
EXTRN	?hash@StringUtil@Ogre@@SAIPBDIH@Z:PROC		; Ogre::StringUtil::hash
EXTRN	__imp__ftell:PROC
; Function compile flags: /Odtp
_TEXT	SEGMENT
_this$ = -36						; size = 4
$T124176 = -32						; size = 4
$T124175 = -28						; size = 4
_b$ = -21						; size = 1
_len$ = -20						; size = 4
_key2$ = -16						; size = 4
_fp$ = -12						; size = 4
_key1$ = -8						; size = 4
_pbuf$ = -4						; size = 4
_filename$ = 8						; size = 4
_do_compress$ = 12					; size = 1
?appendOrReplaceFile@FilePackage@Ogre@@QAE_NPBD_N@Z PROC ; Ogre::FilePackage::appendOrReplaceFile
; _this$ = ecx

; 391  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	mov	DWORD PTR _this$[ebp], ecx

; 392  : 		FILE *fp = fopen(filename, "rb");

	push	OFFSET $SG116638
	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	call	DWORD PTR __imp__fopen
	add	esp, 8
	mov	DWORD PTR _fp$[ebp], eax

; 393  : 		if(fp == NULL)

	cmp	DWORD PTR _fp$[ebp], 0
	jne	SHORT $LN2@appendOrRe@2

; 394  : 		{
; 395  : 			return false;

	xor	al, al
	jmp	$LN3@appendOrRe@2
$LN2@appendOrRe@2:

; 396  : 		}
; 397  : 
; 398  : 		fseek(fp, 0, SEEK_END);

	push	2
	push	0
	mov	ecx, DWORD PTR _fp$[ebp]
	push	ecx
	call	DWORD PTR __imp__fseek
	add	esp, 12					; 0000000cH

; 399  : 		long len = ftell(fp);

	mov	edx, DWORD PTR _fp$[ebp]
	push	edx
	call	DWORD PTR __imp__ftell
	add	esp, 4
	mov	DWORD PTR _len$[ebp], eax

; 400  : 		char *pbuf = new char[len];

	mov	eax, DWORD PTR _len$[ebp]
	push	eax
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T124175[ebp], eax
	mov	ecx, DWORD PTR $T124175[ebp]
	mov	DWORD PTR _pbuf$[ebp], ecx

; 401  : 		fseek(fp, 0, SEEK_SET);

	push	0
	push	0
	mov	edx, DWORD PTR _fp$[ebp]
	push	edx
	call	DWORD PTR __imp__fseek
	add	esp, 12					; 0000000cH

; 402  : 		if(fread(pbuf, len, 1, fp) != 1)

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	push	1
	mov	ecx, DWORD PTR _len$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pbuf$[ebp]
	push	edx
	call	DWORD PTR __imp__fread
	add	esp, 16					; 00000010H
	cmp	eax, 1
	je	SHORT $LN1@appendOrRe@2

; 403  : 		{
; 404  : 			fclose(fp);

	mov	eax, DWORD PTR _fp$[ebp]
	push	eax
	call	DWORD PTR __imp__fclose
	add	esp, 4

; 405  : 			return false;

	xor	al, al
	jmp	SHORT $LN3@appendOrRe@2
$LN1@appendOrRe@2:

; 406  : 		}
; 407  : 		fclose(fp);

	mov	ecx, DWORD PTR _fp$[ebp]
	push	ecx
	call	DWORD PTR __imp__fclose
	add	esp, 4

; 408  : 
; 409  : 		unsigned int key1 = StringUtil::hash(filename, 1);

	push	-1
	push	1
	mov	edx, DWORD PTR _filename$[ebp]
	push	edx
	call	?hash@StringUtil@Ogre@@SAIPBDIH@Z	; Ogre::StringUtil::hash
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _key1$[ebp], eax

; 410  : 		unsigned int key2 = StringUtil::hash(filename, 2);

	push	-1
	push	2
	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	call	?hash@StringUtil@Ogre@@SAIPBDIH@Z	; Ogre::StringUtil::hash
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _key2$[ebp], eax

; 411  : 
; 412  : 		bool b = appendOrReplaceFile(key1, key2, do_compress?1:0, pbuf, len, 0);

	push	0
	mov	ecx, DWORD PTR _len$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pbuf$[ebp]
	push	edx
	movzx	eax, BYTE PTR _do_compress$[ebp]
	neg	eax
	sbb	eax, eax
	neg	eax
	push	eax
	mov	ecx, DWORD PTR _key2$[ebp]
	push	ecx
	mov	edx, DWORD PTR _key1$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?appendOrReplaceFile@FilePackage@Ogre@@QAE_NIIIPBXII@Z ; Ogre::FilePackage::appendOrReplaceFile
	mov	BYTE PTR _b$[ebp], al

; 413  : 		delete[] pbuf;

	mov	eax, DWORD PTR _pbuf$[ebp]
	mov	DWORD PTR $T124176[ebp], eax
	mov	ecx, DWORD PTR $T124176[ebp]
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 414  : 
; 415  : 		return b;

	mov	al, BYTE PTR _b$[ebp]
$LN3@appendOrRe@2:

; 416  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?appendOrReplaceFile@FilePackage@Ogre@@QAE_NPBD_N@Z ENDP ; Ogre::FilePackage::appendOrReplaceFile
_TEXT	ENDS
PUBLIC	?pop_back@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QAEXXZ ; std::vector<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::pop_back
PUBLIC	?back@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QAEAAPAVPackageDataStreamObject@Ogre@@XZ ; std::vector<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::back
PUBLIC	?empty@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QBE_NXZ ; std::vector<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::empty
xdata$x	SEGMENT
__unwindtable$?newBufferObject@FilePackage@Ogre@@QAEPAVPackageDataStreamObject@2@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?newBufferObject@FilePackage@Ogre@@QAEPAVPackageDataStreamObject@2@XZ$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?newBufferObject@FilePackage@Ogre@@QAEPAVPackageDataStreamObject@2@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$?newBufferObject@FilePackage@Ogre@@QAEPAVPackageDataStreamObject@2@XZ$2
__ehfuncinfo$?newBufferObject@FilePackage@Ogre@@QAEPAVPackageDataStreamObject@2@XZ DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?newBufferObject@FilePackage@Ogre@@QAEPAVPackageDataStreamObject@2@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
_TEXT	SEGMENT
tv137 = -56						; size = 4
tv82 = -52						; size = 4
_this$ = -48						; size = 4
$T124187 = -44						; size = 4
$T124184 = -40						; size = 4
$T124183 = -36						; size = 4
$T124182 = -32						; size = 4
$T124179 = -28						; size = 4
$T124178 = -24						; size = 4
_pobject$116666 = -20					; size = 4
_functor$116658 = -16					; size = 4
__$EHRec$ = -12						; size = 12
?newBufferObject@FilePackage@Ogre@@QAEPAVPackageDataStreamObject@2@XZ PROC ; Ogre::FilePackage::newBufferObject
; _this$ = ecx

; 419  : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?newBufferObject@FilePackage@Ogre@@QAEPAVPackageDataStreamObject@2@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 44					; 0000002cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 420  : 		if (m_OriginMemList.empty())

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 104				; 00000068H
	call	?empty@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QBE_NXZ ; std::vector<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::empty
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN4@newBufferO

; 421  : 		{
; 422  : 			++m_BufferObjectCount;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+128]
	add	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+128], edx

; 423  : 			return new PackageDataStreamObject(this, m_MaxOriginSize);

	push	20					; 00000014H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T124179[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T124179[ebp], 0
	je	SHORT $LN7@newBufferO
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+92]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T124179[ebp]
	call	??0PackageDataStreamObject@Ogre@@QAE@PAVFilePackage@1@I@Z ; Ogre::PackageDataStreamObject::PackageDataStreamObject
	mov	DWORD PTR tv82[ebp], eax
	jmp	SHORT $LN8@newBufferO
$LN7@newBufferO:
	mov	DWORD PTR tv82[ebp], 0
$LN8@newBufferO:
	mov	ecx, DWORD PTR tv82[ebp]
	mov	DWORD PTR $T124178[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR $T124178[ebp]
	jmp	$LN5@newBufferO

; 424  : 		}
; 425  : 		else

	jmp	$LN5@newBufferO
$LN4@newBufferO:

; 426  : 		{
; 427  : 			LockFunctor functor(&m_MemListMutex);

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 136				; 00000088H
	push	edx
	lea	ecx, DWORD PTR _functor$116658[ebp]
	call	??0LockFunctor@Ogre@@QAE@PAVLockSection@1@@Z ; Ogre::LockFunctor::LockFunctor
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 428  : 			if (m_OriginMemList.empty())

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 104				; 00000068H
	call	?empty@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QBE_NXZ ; std::vector<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::empty
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@newBufferO

; 429  : 			{
; 430  : 				++m_BufferObjectCount;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+128]
	add	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+128], edx

; 431  : 				return new PackageDataStreamObject(this, m_MaxOriginSize);

	push	20					; 00000014H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T124184[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	cmp	DWORD PTR $T124184[ebp], 0
	je	SHORT $LN9@newBufferO
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+92]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T124184[ebp]
	call	??0PackageDataStreamObject@Ogre@@QAE@PAVFilePackage@1@I@Z ; Ogre::PackageDataStreamObject::PackageDataStreamObject
	mov	DWORD PTR tv137[ebp], eax
	jmp	SHORT $LN10@newBufferO
$LN9@newBufferO:
	mov	DWORD PTR tv137[ebp], 0
$LN10@newBufferO:
	mov	ecx, DWORD PTR tv137[ebp]
	mov	DWORD PTR $T124183[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	edx, DWORD PTR $T124183[ebp]
	mov	DWORD PTR $T124182[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _functor$116658[ebp]
	call	??1LockFunctor@Ogre@@QAE@XZ		; Ogre::LockFunctor::~LockFunctor
	mov	eax, DWORD PTR $T124182[ebp]
	jmp	SHORT $LN5@newBufferO

; 432  : 			}
; 433  : 			else

	jmp	SHORT $LN1@newBufferO
$LN2@newBufferO:

; 434  : 			{
; 435  : 				PackageDataStreamObject *pobject = m_OriginMemList.back();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 104				; 00000068H
	call	?back@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QAEAAPAVPackageDataStreamObject@Ogre@@XZ ; std::vector<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::back
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR _pobject$116666[ebp], eax

; 436  : 				m_OriginMemList.pop_back();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 104				; 00000068H
	call	?pop_back@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QAEXXZ ; std::vector<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::pop_back

; 437  : 				return pobject;

	mov	ecx, DWORD PTR _pobject$116666[ebp]
	mov	DWORD PTR $T124187[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _functor$116658[ebp]
	call	??1LockFunctor@Ogre@@QAE@XZ		; Ogre::LockFunctor::~LockFunctor
	mov	eax, DWORD PTR $T124187[ebp]
	jmp	SHORT $LN5@newBufferO
$LN1@newBufferO:

; 438  : 			}
; 439  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _functor$116658[ebp]
	call	??1LockFunctor@Ogre@@QAE@XZ		; Ogre::LockFunctor::~LockFunctor
$LN5@newBufferO:

; 440  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?newBufferObject@FilePackage@Ogre@@QAEPAVPackageDataStreamObject@2@XZ$0:
	mov	eax, DWORD PTR $T124179[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__unwindfunclet$?newBufferObject@FilePackage@Ogre@@QAEPAVPackageDataStreamObject@2@XZ$1:
	lea	ecx, DWORD PTR _functor$116658[ebp]
	jmp	??1LockFunctor@Ogre@@QAE@XZ		; Ogre::LockFunctor::~LockFunctor
__unwindfunclet$?newBufferObject@FilePackage@Ogre@@QAEPAVPackageDataStreamObject@2@XZ$2:
	mov	eax, DWORD PTR $T124184[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$?newBufferObject@FilePackage@Ogre@@QAEPAVPackageDataStreamObject@2@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-48]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?newBufferObject@FilePackage@Ogre@@QAEPAVPackageDataStreamObject@2@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?newBufferObject@FilePackage@Ogre@@QAEPAVPackageDataStreamObject@2@XZ ENDP ; Ogre::FilePackage::newBufferObject
PUBLIC	?push_back@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QAEXABQAVPackageDataStreamObject@Ogre@@@Z ; std::vector<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::push_back
xdata$x	SEGMENT
__unwindtable$?freeBufferObject@FilePackage@Ogre@@QAEXPAVPackageDataStreamObject@2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?freeBufferObject@FilePackage@Ogre@@QAEXPAVPackageDataStreamObject@2@@Z$0
__ehfuncinfo$?freeBufferObject@FilePackage@Ogre@@QAEXPAVPackageDataStreamObject@2@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?freeBufferObject@FilePackage@Ogre@@QAEXPAVPackageDataStreamObject@2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
_TEXT	SEGMENT
_this$ = -20						; size = 4
_functor$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_object$ = 8						; size = 4
?freeBufferObject@FilePackage@Ogre@@QAEXPAVPackageDataStreamObject@2@@Z PROC ; Ogre::FilePackage::freeBufferObject
; _this$ = ecx

; 443  : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?freeBufferObject@FilePackage@Ogre@@QAEXPAVPackageDataStreamObject@2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 444  : 		LockFunctor functor(&m_MemListMutex);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 136				; 00000088H
	push	eax
	lea	ecx, DWORD PTR _functor$[ebp]
	call	??0LockFunctor@Ogre@@QAE@PAVLockSection@1@@Z ; Ogre::LockFunctor::LockFunctor
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 445  : 		m_OriginMemList.push_back(object);

	lea	ecx, DWORD PTR _object$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 104				; 00000068H
	call	?push_back@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QAEXABQAVPackageDataStreamObject@Ogre@@@Z ; std::vector<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::push_back

; 446  : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _functor$[ebp]
	call	??1LockFunctor@Ogre@@QAE@XZ		; Ogre::LockFunctor::~LockFunctor
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?freeBufferObject@FilePackage@Ogre@@QAEXPAVPackageDataStreamObject@2@@Z$0:
	lea	ecx, DWORD PTR _functor$[ebp]
	jmp	??1LockFunctor@Ogre@@QAE@XZ		; Ogre::LockFunctor::~LockFunctor
__ehhandler$?freeBufferObject@FilePackage@Ogre@@QAEXPAVPackageDataStreamObject@2@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?freeBufferObject@FilePackage@Ogre@@QAEXPAVPackageDataStreamObject@2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?freeBufferObject@FilePackage@Ogre@@QAEXPAVPackageDataStreamObject@2@@Z ENDP ; Ogre::FilePackage::freeBufferObject
PUBLIC	??1?$_Vector_val@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QAE@XZ ; std::_Vector_val<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::~_Vector_val<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >
PUBLIC	?_Buy@?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@IAE_NI@Z ; std::vector<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::_Buy
PUBLIC	??0?$_Vector_val@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@IAE@V?$allocator@UPkgFileInfo@Ogre@@@1@@Z ; std::_Vector_val<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::_Vector_val<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >
PUBLIC	??0?$allocator@UPkgFileInfo@Ogre@@@std@@QAE@XZ	; std::allocator<Ogre::PkgFileInfo>::allocator<Ogre::PkgFileInfo>
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	SEGMENT
__unwindtable$??0?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??0?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T124202 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QAE@XZ PROC ; std::vector<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::vector<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T124202[ebp], esp
	call	??0?$allocator@UPkgFileInfo@Ogre@@@std@@QAE@XZ ; std::allocator<Ogre::PkgFileInfo>::allocator<Ogre::PkgFileInfo>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_val@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@IAE@V?$allocator@UPkgFileInfo@Ogre@@@1@@Z ; std::_Vector_val<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::_Vector_val<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 471  : 		_Buy(0);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@IAE_NI@Z ; std::vector<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::_Buy

; 472  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QAE@XZ
__ehhandler$??0?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QAE@XZ ENDP ; std::vector<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::vector<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >
PUBLIC	?_Tidy@?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@IAEXXZ ; std::vector<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::_Tidy
PUBLIC	??$_Ucopy@V?$_Vector_const_iterator@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@@?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@IAEPAUPkgFileInfo@Ogre@@V?$_Vector_const_iterator@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@1@0PAU23@@Z ; std::vector<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::_Ucopy<std::_Vector_const_iterator<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> > >
PUBLIC	?begin@?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@2@XZ ; std::vector<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::begin
PUBLIC	?end@?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@2@XZ ; std::vector<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::end
PUBLIC	??0?$allocator@UPkgFileInfo@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::PkgFileInfo>::allocator<Ogre::PkgFileInfo>
EXTRN	__CxxThrowException@8:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??0?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QAE@ABV01@@Z$3 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??0?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QAE@ABV01@@Z$0
__tryblocktable$??0?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QAE@ABV01@@Z DD 01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??0?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QAE@ABV01@@Z$3
__unwindtable$??0?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QAE@ABV01@@Z$2
	DD	00H
	DD	00H
	DD	00H
	DD	00H
__ehfuncinfo$??0?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QAE@ABV01@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QAE@ABV01@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??0?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -40						; size = 4
$T124214 = -36						; size = 8
$T124213 = -28						; size = 8
$T124212 = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Right$ = 8						; size = 4
??0?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QAE@ABV01@@Z PROC ; std::vector<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::vector<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >, COMDAT
; _this$ = ecx

; 500  : 		{	// construct by copying _Right

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 24					; 00000018H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Right$[ebp]
	add	eax, 8
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T124212[ebp], esp
	push	eax
	call	??0?$allocator@UPkgFileInfo@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::PkgFileInfo>::allocator<Ogre::PkgFileInfo>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_val@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@IAE@V?$allocator@UPkgFileInfo@Ogre@@@1@@Z ; std::_Vector_val<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::_Vector_val<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >
	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 501  : 		if (_Buy(_Right.size()))

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::size
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@IAE_NI@Z ; std::vector<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::_Buy
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN3@vector@8

; 502  : 			_TRY_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 1

; 503  : 			_Mylast = _Ucopy(_Right.begin(), _Right.end(), _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	lea	ecx, DWORD PTR $T124213[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?end@?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@2@XZ ; std::vector<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::end
	mov	edx, DWORD PTR [eax+4]
	push	edx
	mov	eax, DWORD PTR [eax]
	push	eax
	lea	ecx, DWORD PTR $T124214[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?begin@?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@2@XZ ; std::vector<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::begin
	mov	edx, DWORD PTR [eax+4]
	push	edx
	mov	eax, DWORD PTR [eax]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Ucopy@V?$_Vector_const_iterator@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@@?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@IAEPAUPkgFileInfo@Ogre@@V?$_Vector_const_iterator@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@1@0PAU23@@Z ; std::vector<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::_Ucopy<std::_Vector_const_iterator<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> > >
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax
	jmp	SHORT $LN5@vector@8
__catch$??0?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QAE@ABV01@@Z$0:

; 504  : 			_CATCH_ALL
; 505  : 			_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@IAEXXZ ; std::vector<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::_Tidy

; 506  : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 507  : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], 0
	mov	eax, $LN3@vector@8
	ret	0
$LN5@vector@8:
	mov	DWORD PTR __$EHRec$[ebp+12], 0
$LN3@vector@8:

; 508  : 		}

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector@8:
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QAE@ABV01@@Z$2:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QAE@XZ
__ehhandler$??0?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-44]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::vector<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::vector<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QAE@XZ PROC ; std::vector<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::~vector<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 559  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@IAEXXZ ; std::vector<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::_Tidy

; 560  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Vector_val@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QAE@XZ
__ehhandler$??1?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QAE@XZ ENDP ; std::vector<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::~vector<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >
PUBLIC	?deallocate@?$allocator@UPkgFileInfo@Ogre@@@std@@QAEXPAUPkgFileInfo@Ogre@@I@Z ; std::allocator<Ogre::PkgFileInfo>::deallocate
PUBLIC	??$_Ucopy@PAUPkgFileInfo@Ogre@@@?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@IAEPAUPkgFileInfo@Ogre@@PAU23@00@Z ; std::vector<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::_Ucopy<Ogre::PkgFileInfo *>
PUBLIC	?capacity@?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::capacity
PUBLIC	?_Destroy@?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@IAEXPAUPkgFileInfo@Ogre@@0@Z ; std::vector<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::_Destroy
PUBLIC	??$unchecked_copy@PAUPkgFileInfo@Ogre@@PAU12@@stdext@@YAPAUPkgFileInfo@Ogre@@PAU12@00@Z ; stdext::unchecked_copy<Ogre::PkgFileInfo *,Ogre::PkgFileInfo *>
PUBLIC	?clear@?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QAEXXZ ; std::vector<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::clear
; Function compile flags: /Odtp
;	COMDAT ??4?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
__Ptr$118177 = -8					; size = 4
__Ptr$118167 = -4					; size = 4
__Right$ = 8						; size = 4
??4?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z PROC ; std::vector<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::operator=, COMDAT
; _this$ = ecx

; 563  : 		{	// assign _Right

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 564  : 		if (this != &_Right)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR __Right$[ebp]
	je	$LN9@operator

; 565  : 			{	// worth doing
; 566  : 
; 567  :  #if _HAS_ITERATOR_DEBUGGING
; 568  : 			this->_Orphan_all();
; 569  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 570  : 
; 571  : 			if (_Right.size() == 0)

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::size
	test	eax, eax
	jne	SHORT $LN8@operator

; 572  : 				clear();	// new sequence empty, erase existing sequence

	mov	ecx, DWORD PTR _this$[ebp]
	call	?clear@?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QAEXXZ ; std::vector<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::clear
	jmp	$LN9@operator
$LN8@operator:

; 573  : 			else if (_Right.size() <= size())

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::size
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::size
	cmp	esi, eax
	ja	SHORT $LN6@operator

; 574  : 				{	// enough elements, copy new and destroy old
; 575  : 				pointer _Ptr = _STDEXT unchecked_copy(_Right._Myfirst, _Right._Mylast,
; 576  : 					_Myfirst);	// copy new

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	call	??$unchecked_copy@PAUPkgFileInfo@Ogre@@PAU12@@stdext@@YAPAUPkgFileInfo@Ogre@@PAU12@00@Z ; stdext::unchecked_copy<Ogre::PkgFileInfo *,Ogre::PkgFileInfo *>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR __Ptr$118167[ebp], eax

; 577  : 				_Destroy(_Ptr, _Mylast);	// destroy old

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR __Ptr$118167[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@IAEXPAUPkgFileInfo@Ogre@@0@Z ; std::vector<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::_Destroy

; 578  : 				_Mylast = _Myfirst + _Right.size();

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::size
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+12]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+16], eax
	jmp	$LN9@operator
$LN6@operator:

; 579  : 				}
; 580  : 			else if (_Right.size() <= capacity())

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::size
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?capacity@?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::capacity
	cmp	esi, eax
	ja	SHORT $LN4@operator

; 581  : 				{	// enough room, copy and construct new
; 582  : 				pointer _Ptr = _Right._Myfirst + size();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::size
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR __Right$[ebp]
	add	eax, DWORD PTR [ecx+12]
	mov	DWORD PTR __Ptr$118177[ebp], eax

; 583  : 				_STDEXT unchecked_copy(_Right._Myfirst, _Ptr, _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR __Ptr$118177[ebp]
	push	ecx
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	call	??$unchecked_copy@PAUPkgFileInfo@Ogre@@PAU12@@stdext@@YAPAUPkgFileInfo@Ogre@@PAU12@00@Z ; stdext::unchecked_copy<Ogre::PkgFileInfo *,Ogre::PkgFileInfo *>
	add	esp, 12					; 0000000cH

; 584  : 				_Mylast = _Ucopy(_Ptr, _Right._Mylast, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Ptr$118177[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Ucopy@PAUPkgFileInfo@Ogre@@@?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@IAEPAUPkgFileInfo@Ogre@@PAU23@00@Z ; std::vector<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::_Ucopy<Ogre::PkgFileInfo *>
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 585  : 				}
; 586  : 			else

	jmp	$LN9@operator
$LN4@operator:

; 587  : 				{	// not enough room, allocate new array and construct new
; 588  : 				if (_Myfirst != 0)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+12], 0
	je	SHORT $LN2@operator

; 589  : 					{	// discard old array
; 590  : 					_Destroy(_Myfirst, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@IAEXPAUPkgFileInfo@Ogre@@0@Z ; std::vector<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::_Destroy

; 591  : 					this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+20]
	sub	eax, DWORD PTR [edx+12]
	cdq
	mov	ecx, 24					; 00000018H
	idiv	ecx
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?deallocate@?$allocator@UPkgFileInfo@Ogre@@@std@@QAEXPAUPkgFileInfo@Ogre@@I@Z ; std::allocator<Ogre::PkgFileInfo>::deallocate
$LN2@operator:

; 592  : 					}
; 593  : 				if (_Buy(_Right.size()))

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::size
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@IAE_NI@Z ; std::vector<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::_Buy
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN9@operator

; 594  : 					_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 595  : 						_Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Ucopy@PAUPkgFileInfo@Ogre@@@?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@IAEPAUPkgFileInfo@Ogre@@PAU23@00@Z ; std::vector<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::_Ucopy<Ogre::PkgFileInfo *>
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+16], eax
$LN9@operator:

; 596  : 				}
; 597  : 			}
; 598  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 599  : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
??4?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z ENDP ; std::vector<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::operator=
_TEXT	ENDS
PUBLIC	?resize@?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QAEXIUPkgFileInfo@Ogre@@@Z ; std::vector<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::resize
; Function compile flags: /Odtp
;	COMDAT ?resize@?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -28						; size = 4
$T124243 = -24						; size = 24
__Newsize$ = 8						; size = 4
?resize@?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QAEXI@Z PROC ; std::vector<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::resize, COMDAT
; _this$ = ecx

; 712  : 		{	// determine new length, padding with _Ty() elements as needed

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR _this$[ebp], ecx

; 713  : 		resize(_Newsize, _Ty());

	xor	eax, eax
	mov	DWORD PTR $T124243[ebp], eax
	mov	DWORD PTR $T124243[ebp+4], eax
	mov	DWORD PTR $T124243[ebp+8], eax
	mov	DWORD PTR $T124243[ebp+12], eax
	mov	DWORD PTR $T124243[ebp+16], eax
	mov	DWORD PTR $T124243[ebp+20], eax
	sub	esp, 24					; 00000018H
	mov	ecx, esp
	mov	edx, DWORD PTR $T124243[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR $T124243[ebp+4]
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR $T124243[ebp+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR $T124243[ebp+12]
	mov	DWORD PTR [ecx+12], eax
	mov	edx, DWORD PTR $T124243[ebp+16]
	mov	DWORD PTR [ecx+16], edx
	mov	eax, DWORD PTR $T124243[ebp+20]
	mov	DWORD PTR [ecx+20], eax
	mov	ecx, DWORD PTR __Newsize$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?resize@?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QAEXIUPkgFileInfo@Ogre@@@Z ; std::vector<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::resize

; 714  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?resize@?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QAEXI@Z ENDP ; std::vector<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::resize
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?size@?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QBEIXZ PROC ; std::vector<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::size, COMDAT
; _this$ = ecx

; 725  : 		{	// return length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+16]
	sub	eax, DWORD PTR [ecx+12]
	cdq
	mov	ecx, 24					; 00000018H
	idiv	ecx

; 727  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?size@?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QBEIXZ ENDP ; std::vector<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::size
_TEXT	ENDS
EXTRN	__imp___invalid_parameter_noinfo:PROC
; Function compile flags: /Odtp
;	COMDAT ??A?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QAEAAUPkgFileInfo@Ogre@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pos$ = 8						; size = 4
??A?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QAEAAUPkgFileInfo@Ogre@@I@Z PROC ; std::vector<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::operator[], COMDAT
; _this$ = ecx

; 774  : 		{	// subscript mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)
; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");
; 780  : 			_SCL_SECURE_OUT_OF_RANGE;
; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::size
	cmp	DWORD PTR __Pos$[ebp], eax
	jb	SHORT $LN1@operator@2
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN1@operator@2:

; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR __Pos$[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+12]

; 786  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??A?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QAEAAUPkgFileInfo@Ogre@@I@Z ENDP ; std::vector<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::operator[]
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QAE@XZ ; std::_Vector_val<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::~_Vector_val<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >
PUBLIC	?_Buy@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@IAE_NI@Z ; std::vector<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::_Buy
PUBLIC	??0?$_Vector_val@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@IAE@V?$allocator@PAVPackageDataStreamObject@Ogre@@@1@@Z ; std::_Vector_val<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::_Vector_val<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >
PUBLIC	??0?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@QAE@XZ ; std::allocator<Ogre::PackageDataStreamObject *>::allocator<Ogre::PackageDataStreamObject *>
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??0?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T124250 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QAE@XZ PROC ; std::vector<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::vector<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >, COMDAT
; _this$ = ecx

; 470  : 		{	// construct empty vector

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T124250[ebp], esp
	call	??0?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@QAE@XZ ; std::allocator<Ogre::PackageDataStreamObject *>::allocator<Ogre::PackageDataStreamObject *>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_val@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@IAE@V?$allocator@PAVPackageDataStreamObject@Ogre@@@1@@Z ; std::_Vector_val<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::_Vector_val<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 471  : 		_Buy(0);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@IAE_NI@Z ; std::vector<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::_Buy

; 472  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QAE@XZ
__ehhandler$??0?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QAE@XZ ENDP ; std::vector<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::vector<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >
PUBLIC	?_Tidy@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@IAEXXZ ; std::vector<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::_Tidy
PUBLIC	??$_Ucopy@V?$_Vector_const_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@IAEPAPAVPackageDataStreamObject@Ogre@@V?$_Vector_const_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@1@0PAPAV23@@Z ; std::vector<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::_Ucopy<std::_Vector_const_iterator<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> > >
PUBLIC	?begin@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@2@XZ ; std::vector<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::begin
PUBLIC	?end@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@2@XZ ; std::vector<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::end
PUBLIC	??0?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::PackageDataStreamObject *>::allocator<Ogre::PackageDataStreamObject *>
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??0?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QAE@ABV01@@Z$3 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??0?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QAE@ABV01@@Z$0
__tryblocktable$??0?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QAE@ABV01@@Z DD 01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??0?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QAE@ABV01@@Z$3
__unwindtable$??0?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QAE@ABV01@@Z$2
	DD	00H
	DD	00H
	DD	00H
	DD	00H
__ehfuncinfo$??0?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QAE@ABV01@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QAE@ABV01@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??0?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -40						; size = 4
$T124262 = -36						; size = 8
$T124261 = -28						; size = 8
$T124260 = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Right$ = 8						; size = 4
??0?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QAE@ABV01@@Z PROC ; std::vector<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::vector<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >, COMDAT
; _this$ = ecx

; 500  : 		{	// construct by copying _Right

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 24					; 00000018H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Right$[ebp]
	add	eax, 8
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T124260[ebp], esp
	push	eax
	call	??0?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::PackageDataStreamObject *>::allocator<Ogre::PackageDataStreamObject *>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_val@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@IAE@V?$allocator@PAVPackageDataStreamObject@Ogre@@@1@@Z ; std::_Vector_val<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::_Vector_val<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >
	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 501  : 		if (_Buy(_Right.size()))

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::size
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@IAE_NI@Z ; std::vector<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::_Buy
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN3@vector@9

; 502  : 			_TRY_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 1

; 503  : 			_Mylast = _Ucopy(_Right.begin(), _Right.end(), _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	lea	ecx, DWORD PTR $T124261[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?end@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@2@XZ ; std::vector<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::end
	mov	edx, DWORD PTR [eax+4]
	push	edx
	mov	eax, DWORD PTR [eax]
	push	eax
	lea	ecx, DWORD PTR $T124262[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?begin@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@2@XZ ; std::vector<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::begin
	mov	edx, DWORD PTR [eax+4]
	push	edx
	mov	eax, DWORD PTR [eax]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Ucopy@V?$_Vector_const_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@IAEPAPAVPackageDataStreamObject@Ogre@@V?$_Vector_const_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@1@0PAPAV23@@Z ; std::vector<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::_Ucopy<std::_Vector_const_iterator<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> > >
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax
	jmp	SHORT $LN5@vector@9
__catch$??0?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QAE@ABV01@@Z$0:

; 504  : 			_CATCH_ALL
; 505  : 			_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@IAEXXZ ; std::vector<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::_Tidy

; 506  : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 507  : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], 0
	mov	eax, $LN3@vector@9
	ret	0
$LN5@vector@9:
	mov	DWORD PTR __$EHRec$[ebp+12], 0
$LN3@vector@9:

; 508  : 		}

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector@9:
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QAE@ABV01@@Z$2:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QAE@XZ
__ehhandler$??0?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-44]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::vector<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::vector<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QAE@XZ PROC ; std::vector<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::~vector<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 559  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@IAEXXZ ; std::vector<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::_Tidy

; 560  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Vector_val@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QAE@XZ
__ehhandler$??1?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QAE@XZ ENDP ; std::vector<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::~vector<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >
PUBLIC	?deallocate@?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@QAEXPAPAVPackageDataStreamObject@Ogre@@I@Z ; std::allocator<Ogre::PackageDataStreamObject *>::deallocate
PUBLIC	??$_Ucopy@PAPAVPackageDataStreamObject@Ogre@@@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@IAEPAPAVPackageDataStreamObject@Ogre@@PAPAV23@00@Z ; std::vector<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::_Ucopy<Ogre::PackageDataStreamObject * *>
PUBLIC	?capacity@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::capacity
PUBLIC	?_Destroy@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@IAEXPAPAVPackageDataStreamObject@Ogre@@0@Z ; std::vector<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::_Destroy
PUBLIC	??$unchecked_copy@PAPAVPackageDataStreamObject@Ogre@@PAPAV12@@stdext@@YAPAPAVPackageDataStreamObject@Ogre@@PAPAV12@00@Z ; stdext::unchecked_copy<Ogre::PackageDataStreamObject * *,Ogre::PackageDataStreamObject * *>
; Function compile flags: /Odtp
;	COMDAT ??4?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
__Ptr$118345 = -8					; size = 4
__Ptr$118335 = -4					; size = 4
__Right$ = 8						; size = 4
??4?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z PROC ; std::vector<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::operator=, COMDAT
; _this$ = ecx

; 563  : 		{	// assign _Right

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 564  : 		if (this != &_Right)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR __Right$[ebp]
	je	$LN9@operator@3

; 565  : 			{	// worth doing
; 566  : 
; 567  :  #if _HAS_ITERATOR_DEBUGGING
; 568  : 			this->_Orphan_all();
; 569  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 570  : 
; 571  : 			if (_Right.size() == 0)

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::size
	test	eax, eax
	jne	SHORT $LN8@operator@3

; 572  : 				clear();	// new sequence empty, erase existing sequence

	mov	ecx, DWORD PTR _this$[ebp]
	call	?clear@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QAEXXZ ; std::vector<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::clear
	jmp	$LN9@operator@3
$LN8@operator@3:

; 573  : 			else if (_Right.size() <= size())

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::size
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::size
	cmp	esi, eax
	ja	SHORT $LN6@operator@3

; 574  : 				{	// enough elements, copy new and destroy old
; 575  : 				pointer _Ptr = _STDEXT unchecked_copy(_Right._Myfirst, _Right._Mylast,
; 576  : 					_Myfirst);	// copy new

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	call	??$unchecked_copy@PAPAVPackageDataStreamObject@Ogre@@PAPAV12@@stdext@@YAPAPAVPackageDataStreamObject@Ogre@@PAPAV12@00@Z ; stdext::unchecked_copy<Ogre::PackageDataStreamObject * *,Ogre::PackageDataStreamObject * *>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR __Ptr$118335[ebp], eax

; 577  : 				_Destroy(_Ptr, _Mylast);	// destroy old

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR __Ptr$118335[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@IAEXPAPAVPackageDataStreamObject@Ogre@@0@Z ; std::vector<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::_Destroy

; 578  : 				_Mylast = _Myfirst + _Right.size();

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::size
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	lea	eax, DWORD PTR [edx+eax*4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax
	jmp	$LN9@operator@3
$LN6@operator@3:

; 579  : 				}
; 580  : 			else if (_Right.size() <= capacity())

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::size
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?capacity@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::capacity
	cmp	esi, eax
	ja	SHORT $LN4@operator@3

; 581  : 				{	// enough room, copy and construct new
; 582  : 				pointer _Ptr = _Right._Myfirst + size();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::size
	mov	edx, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR __Ptr$118345[ebp], edx

; 583  : 				_STDEXT unchecked_copy(_Right._Myfirst, _Ptr, _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	edx, DWORD PTR __Ptr$118345[ebp]
	push	edx
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	call	??$unchecked_copy@PAPAVPackageDataStreamObject@Ogre@@PAPAV12@@stdext@@YAPAPAVPackageDataStreamObject@Ogre@@PAPAV12@00@Z ; stdext::unchecked_copy<Ogre::PackageDataStreamObject * *,Ogre::PackageDataStreamObject * *>
	add	esp, 12					; 0000000cH

; 584  : 				_Mylast = _Ucopy(_Ptr, _Right._Mylast, _Mylast);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR __Ptr$118345[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Ucopy@PAPAVPackageDataStreamObject@Ogre@@@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@IAEPAPAVPackageDataStreamObject@Ogre@@PAPAV23@00@Z ; std::vector<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::_Ucopy<Ogre::PackageDataStreamObject * *>
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 585  : 				}
; 586  : 			else

	jmp	SHORT $LN9@operator@3
$LN4@operator@3:

; 587  : 				{	// not enough room, allocate new array and construct new
; 588  : 				if (_Myfirst != 0)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+12], 0
	je	SHORT $LN2@operator@3

; 589  : 					{	// discard old array
; 590  : 					_Destroy(_Myfirst, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@IAEXPAPAVPackageDataStreamObject@Ogre@@0@Z ; std::vector<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::_Destroy

; 591  : 					this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+20]
	sub	eax, DWORD PTR [edx+12]
	sar	eax, 2
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?deallocate@?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@QAEXPAPAVPackageDataStreamObject@Ogre@@I@Z ; std::allocator<Ogre::PackageDataStreamObject *>::deallocate
$LN2@operator@3:

; 592  : 					}
; 593  : 				if (_Buy(_Right.size()))

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::size
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@IAE_NI@Z ; std::vector<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::_Buy
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN9@operator@3

; 594  : 					_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 595  : 						_Myfirst);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Ucopy@PAPAVPackageDataStreamObject@Ogre@@@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@IAEPAPAVPackageDataStreamObject@Ogre@@PAPAV23@00@Z ; std::vector<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::_Ucopy<Ogre::PackageDataStreamObject * *>
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax
$LN9@operator@3:

; 596  : 				}
; 597  : 			}
; 598  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 599  : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
??4?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z ENDP ; std::vector<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::operator=
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?size@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QBEIXZ PROC ; std::vector<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::size, COMDAT
; _this$ = ecx

; 725  : 		{	// return length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+16]
	sub	eax, DWORD PTR [ecx+12]
	sar	eax, 2

; 727  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?size@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QBEIXZ ENDP ; std::vector<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::size
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?empty@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?empty@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QBE_NXZ PROC ; std::vector<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::empty, COMDAT
; _this$ = ecx

; 735  : 		{	// test if sequence is empty

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 736  : 		return (size() == 0);

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::size
	neg	eax
	sbb	eax, eax
	add	eax, 1

; 737  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?empty@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QBE_NXZ ENDP ; std::vector<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::empty
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??A?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QAEAAPAVPackageDataStreamObject@Ogre@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pos$ = 8						; size = 4
??A?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QAEAAPAVPackageDataStreamObject@Ogre@@I@Z PROC ; std::vector<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::operator[], COMDAT
; _this$ = ecx

; 774  : 		{	// subscript mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)
; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");
; 780  : 			_SCL_SECURE_OUT_OF_RANGE;
; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::size
	cmp	DWORD PTR __Pos$[ebp], eax
	jb	SHORT $LN1@operator@4
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN1@operator@4:

; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR __Pos$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]

; 786  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??A?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QAEAAPAVPackageDataStreamObject@Ogre@@I@Z ENDP ; std::vector<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::operator[]
_TEXT	ENDS
PUBLIC	??D?$_Vector_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QBEAAPAVPackageDataStreamObject@Ogre@@XZ ; std::_Vector_iterator<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::operator*
PUBLIC	??G?$_Vector_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::operator-
PUBLIC	?end@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@2@XZ ; std::vector<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::end
; Function compile flags: /Odtp
;	COMDAT ?back@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QAEAAPAVPackageDataStreamObject@Ogre@@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T124297 = -16						; size = 8
$T124296 = -8						; size = 8
?back@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QAEAAPAVPackageDataStreamObject@Ogre@@XZ PROC ; std::vector<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::back, COMDAT
; _this$ = ecx

; 799  : 		{	// return last element of mutable sequence

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 800  : 		return (*(end() - 1));

	push	1
	lea	eax, DWORD PTR $T124297[ebp]
	push	eax
	lea	ecx, DWORD PTR $T124296[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@2@XZ ; std::vector<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::end
	mov	ecx, eax
	call	??G?$_Vector_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::operator-
	mov	ecx, eax
	call	??D?$_Vector_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QBEAAPAVPackageDataStreamObject@Ogre@@XZ ; std::_Vector_iterator<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::operator*

; 801  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?back@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QAEAAPAVPackageDataStreamObject@Ogre@@XZ ENDP ; std::vector<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::back
_TEXT	ENDS
PUBLIC	?insert@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@2@ABQAVPackageDataStreamObject@Ogre@@@Z ; std::vector<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::insert
PUBLIC	?_Ufill@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@IAEPAPAVPackageDataStreamObject@Ogre@@PAPAV34@IABQAV34@@Z ; std::vector<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::_Ufill
; Function compile flags: /Odtp
;	COMDAT ?push_back@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QAEXABQAVPackageDataStreamObject@Ogre@@@Z
_TEXT	SEGMENT
_this$ = -28						; size = 4
$T124302 = -24						; size = 8
$T124301 = -16						; size = 8
$T124300 = -8						; size = 8
__Val$ = 8						; size = 4
?push_back@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QAEXABQAVPackageDataStreamObject@Ogre@@@Z PROC ; std::vector<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::push_back, COMDAT
; _this$ = ecx

; 809  : 		{	// insert element at end

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 810  : 		if (size() < capacity())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::size
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?capacity@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::capacity
	cmp	esi, eax
	jae	SHORT $LN2@push_back

; 811  : 
; 812  :  #if _HAS_ITERATOR_DEBUGGING
; 813  : 			{ // room at end, construct it there
; 814  : 			_Orphan_range(_Mylast, _Mylast);
; 815  : 			_Mylast = _Ufill(_Mylast, 1, _Val);
; 816  : 			}
; 817  : 
; 818  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 819  : 			_Mylast = _Ufill(_Mylast, 1, _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Ufill@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@IAEPAPAVPackageDataStreamObject@Ogre@@PAPAV34@IABQAV34@@Z ; std::vector<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::_Ufill
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 820  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 821  : 
; 822  : 		else

	jmp	SHORT $LN3@push_back
$LN2@push_back:

; 823  : 			insert(end(), _Val);

	lea	edx, DWORD PTR $T124301[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@2@XZ ; std::vector<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::end
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T124300[ebp], ecx
	mov	DWORD PTR $T124300[ebp+4], edx
	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T124300[ebp+4]
	push	ecx
	mov	edx, DWORD PTR $T124300[ebp]
	push	edx
	lea	eax, DWORD PTR $T124302[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?insert@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@2@ABQAVPackageDataStreamObject@Ogre@@@Z ; std::vector<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::insert
$LN3@push_back:

; 824  : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?push_back@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QAEXABQAVPackageDataStreamObject@Ogre@@@Z ENDP ; std::vector<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::push_back
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?pop_back@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?pop_back@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QAEXXZ PROC ; std::vector<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::pop_back, COMDAT
; _this$ = ecx

; 841  : 		{	// erase element at end

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 842  : 		if (!empty())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?empty@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QBE_NXZ ; std::vector<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::empty
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN2@pop_back

; 843  : 			{	// erase last element
; 844  : 			_Destroy(_Mylast - 1, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	sub	ecx, 4
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@IAEXPAPAVPackageDataStreamObject@Ogre@@0@Z ; std::vector<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::_Destroy

; 845  : 			--_Mylast;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	sub	eax, 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax
$LN2@pop_back:

; 846  : 			}
; 847  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?pop_back@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QAEXXZ ENDP ; std::vector<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::pop_back
_TEXT	ENDS
PUBLIC	?erase@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@2@0@Z ; std::vector<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::erase
PUBLIC	?begin@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@2@XZ ; std::vector<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::begin
; Function compile flags: /Odtp
;	COMDAT ?clear@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -44						; size = 4
$T124311 = -40						; size = 8
$T124310 = -32						; size = 8
$T124309 = -24						; size = 8
$T124308 = -16						; size = 8
$T124307 = -8						; size = 8
?clear@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QAEXXZ PROC ; std::vector<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::clear, COMDAT
; _this$ = ecx

; 1059 : 		{	// erase all

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	mov	DWORD PTR _this$[ebp], ecx

; 1060 : 		erase(begin(), end());

	lea	eax, DWORD PTR $T124308[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@2@XZ ; std::vector<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::end
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T124307[ebp], ecx
	mov	DWORD PTR $T124307[ebp+4], edx
	lea	eax, DWORD PTR $T124310[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@2@XZ ; std::vector<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::begin
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T124309[ebp], ecx
	mov	DWORD PTR $T124309[ebp+4], edx
	mov	eax, DWORD PTR $T124307[ebp+4]
	push	eax
	mov	ecx, DWORD PTR $T124307[ebp]
	push	ecx
	mov	edx, DWORD PTR $T124309[ebp+4]
	push	edx
	mov	eax, DWORD PTR $T124309[ebp]
	push	eax
	lea	ecx, DWORD PTR $T124311[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@2@0@Z ; std::vector<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::erase

; 1061 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?clear@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QAEXXZ ENDP ; std::vector<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::clear
_TEXT	ENDS
PUBLIC	??1?$_Container_base_aux_alloc_real@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::PkgFileInfo> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::PkgFileInfo> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$_Vector_val@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Vector_val@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$_Vector_val@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Vector_val@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$_Vector_val@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Vector_val@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::~_Vector_val<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Vector_val@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Container_base_aux_alloc_real@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::PkgFileInfo> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::PkgFileInfo> >
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Vector_val@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Container_base_aux_alloc_real@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::PkgFileInfo> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::PkgFileInfo> >
__ehhandler$??1?$_Vector_val@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Vector_val@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Vector_val@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::~_Vector_val<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >
PUBLIC	??1?$_Container_base_aux_alloc_real@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::PackageDataStreamObject *> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::PackageDataStreamObject *> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$_Vector_val@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Vector_val@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$_Vector_val@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Vector_val@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$_Vector_val@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Vector_val@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::~_Vector_val<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Vector_val@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Container_base_aux_alloc_real@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::PackageDataStreamObject *> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::PackageDataStreamObject *> >
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Vector_val@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Container_base_aux_alloc_real@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::PackageDataStreamObject *> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::PackageDataStreamObject *> >
__ehhandler$??1?$_Vector_val@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Vector_val@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Vector_val@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::~_Vector_val<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >
; Function compile flags: /Odtp
;	COMDAT ?capacity@?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
tv70 = -8						; size = 4
_this$ = -4						; size = 4
?capacity@?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QBEIXZ PROC ; std::vector<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::capacity, COMDAT
; _this$ = ecx

; 634  : 		{	// return current length of allocated storage

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	jne	SHORT $LN3@capacity
	mov	DWORD PTR tv70[ebp], 0
	jmp	SHORT $LN4@capacity
$LN3@capacity:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+20]
	sub	eax, DWORD PTR [edx+12]
	cdq
	mov	ecx, 24					; 00000018H
	idiv	ecx
	mov	DWORD PTR tv70[ebp], eax
$LN4@capacity:
	mov	eax, DWORD PTR tv70[ebp]

; 636  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?capacity@?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QBEIXZ ENDP ; std::vector<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::capacity
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QAE@PAUPkgFileInfo@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::_Vector_const_iterator<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >
; Function compile flags: /Odtp
;	COMDAT ?begin@?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@2@XZ PROC ; std::vector<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::begin, COMDAT
; _this$ = ecx

; 645  : 		{	// return iterator for beginning of nonmutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 646  : 		return (const_iterator(_Myfirst, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_const_iterator@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QAE@PAUPkgFileInfo@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::_Vector_const_iterator<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 647  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?begin@?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@2@XZ ENDP ; std::vector<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::begin
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?end@?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@2@XZ PROC ; std::vector<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::end, COMDAT
; _this$ = ecx

; 655  : 		{	// return iterator for end of nonmutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 656  : 		return (const_iterator(_Mylast, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_const_iterator@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QAE@PAUPkgFileInfo@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::_Vector_const_iterator<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 657  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?end@?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@2@XZ ENDP ; std::vector<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::end
_TEXT	ENDS
PUBLIC	?erase@?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@2@V?$_Vector_const_iterator@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@2@0@Z ; std::vector<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::erase
PUBLIC	??H?$_Vector_iterator@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::operator+
PUBLIC	?begin@?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@2@XZ ; std::vector<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::begin
PUBLIC	?_Insert_n@?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@2@IABUPkgFileInfo@Ogre@@@Z ; std::vector<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::_Insert_n
PUBLIC	?end@?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@2@XZ ; std::vector<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::end
; Function compile flags: /Odtp
;	COMDAT ?resize@?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QAEXIUPkgFileInfo@Ogre@@@Z
_TEXT	SEGMENT
_this$ = -68						; size = 4
$T124347 = -64						; size = 8
$T124346 = -56						; size = 8
$T124345 = -48						; size = 8
$T124344 = -40						; size = 8
$T124343 = -32						; size = 8
$T124342 = -24						; size = 8
$T124341 = -16						; size = 8
$T124340 = -8						; size = 8
__Newsize$ = 8						; size = 4
__Val$ = 12						; size = 24
?resize@?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QAEXIUPkgFileInfo@Ogre@@@Z PROC ; std::vector<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::resize, COMDAT
; _this$ = ecx

; 717  : 		{	// determine new length, padding with _Val elements as needed

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	mov	DWORD PTR _this$[ebp], ecx

; 718  : 		if (size() < _Newsize)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::size
	cmp	eax, DWORD PTR __Newsize$[ebp]
	jae	SHORT $LN3@resize

; 719  : 			_Insert_n(end(), _Newsize - size(), _Val);

	lea	eax, DWORD PTR $T124341[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@2@XZ ; std::vector<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::end
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T124340[ebp], ecx
	mov	DWORD PTR $T124340[ebp+4], edx
	lea	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::size
	mov	ecx, DWORD PTR __Newsize$[ebp]
	sub	ecx, eax
	push	ecx
	mov	edx, DWORD PTR $T124340[ebp+4]
	push	edx
	mov	eax, DWORD PTR $T124340[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert_n@?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@2@IABUPkgFileInfo@Ogre@@@Z ; std::vector<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::_Insert_n
	jmp	SHORT $LN4@resize
$LN3@resize:

; 720  : 		else if (_Newsize < size())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::size
	cmp	DWORD PTR __Newsize$[ebp], eax
	jae	SHORT $LN4@resize

; 721  : 			erase(begin() + _Newsize, end());

	lea	ecx, DWORD PTR $T124343[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@2@XZ ; std::vector<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::end
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR $T124342[ebp], edx
	mov	DWORD PTR $T124342[ebp+4], eax
	mov	ecx, DWORD PTR __Newsize$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T124346[ebp]
	push	edx
	lea	eax, DWORD PTR $T124345[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@2@XZ ; std::vector<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::begin
	mov	ecx, eax
	call	??H?$_Vector_iterator@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::operator+
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T124344[ebp], ecx
	mov	DWORD PTR $T124344[ebp+4], edx
	mov	eax, DWORD PTR $T124342[ebp+4]
	push	eax
	mov	ecx, DWORD PTR $T124342[ebp]
	push	ecx
	mov	edx, DWORD PTR $T124344[ebp+4]
	push	edx
	mov	eax, DWORD PTR $T124344[ebp]
	push	eax
	lea	ecx, DWORD PTR $T124347[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@2@V?$_Vector_const_iterator@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@2@0@Z ; std::vector<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::erase
$LN4@resize:

; 722  : 		}

	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
?resize@?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QAEXIUPkgFileInfo@Ogre@@@Z ENDP ; std::vector<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::resize
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?clear@?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -44						; size = 4
$T124354 = -40						; size = 8
$T124353 = -32						; size = 8
$T124352 = -24						; size = 8
$T124351 = -16						; size = 8
$T124350 = -8						; size = 8
?clear@?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QAEXXZ PROC ; std::vector<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::clear, COMDAT
; _this$ = ecx

; 1059 : 		{	// erase all

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	mov	DWORD PTR _this$[ebp], ecx

; 1060 : 		erase(begin(), end());

	lea	eax, DWORD PTR $T124351[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@2@XZ ; std::vector<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::end
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T124350[ebp], ecx
	mov	DWORD PTR $T124350[ebp+4], edx
	lea	eax, DWORD PTR $T124353[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@2@XZ ; std::vector<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::begin
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T124352[ebp], ecx
	mov	DWORD PTR $T124352[ebp+4], edx
	mov	eax, DWORD PTR $T124350[ebp+4]
	push	eax
	mov	ecx, DWORD PTR $T124350[ebp]
	push	ecx
	mov	edx, DWORD PTR $T124352[ebp+4]
	push	edx
	mov	eax, DWORD PTR $T124352[ebp]
	push	eax
	lea	ecx, DWORD PTR $T124354[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@2@V?$_Vector_const_iterator@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@2@0@Z ; std::vector<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::erase

; 1061 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?clear@?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QAEXXZ ENDP ; std::vector<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::clear
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@UPkgFileInfo@Ogre@@@std@@QAEPAUPkgFileInfo@Ogre@@I@Z ; std::allocator<Ogre::PkgFileInfo>::allocate
PUBLIC	?_Xlen@?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@KAXXZ ; std::vector<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::_Xlen
PUBLIC	?max_size@?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::max_size
; Function compile flags: /Odtp
;	COMDAT ?_Buy@?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Capacity$ = 8						; size = 4
?_Buy@?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@IAE_NI@Z PROC ; std::vector<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+20], 0

; 1104 : 		if (_Capacity == 0)

	cmp	DWORD PTR __Capacity$[ebp], 0
	jne	SHORT $LN4@Buy

; 1105 : 			return (false);

	xor	al, al
	jmp	SHORT $LN5@Buy
	jmp	SHORT $LN3@Buy
$LN4@Buy:

; 1106 : 		else if (max_size() < _Capacity)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::max_size
	cmp	eax, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN2@Buy

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@KAXXZ ; std::vector<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::_Xlen

; 1108 : 		else

	jmp	SHORT $LN3@Buy
$LN2@Buy:

; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	mov	eax, DWORD PTR __Capacity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?allocate@?$allocator@UPkgFileInfo@Ogre@@@std@@QAEPAUPkgFileInfo@Ogre@@I@Z ; std::allocator<Ogre::PkgFileInfo>::allocate
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [edx+16], ecx

; 1112 : 			_Myend = _Myfirst + _Capacity;

	mov	edx, DWORD PTR __Capacity$[ebp]
	imul	edx, 24					; 00000018H
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+12]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+20], edx
$LN3@Buy:

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
$LN5@Buy:

; 1115 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Buy@?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::_Buy
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@YAXPAUPkgFileInfo@Ogre@@0AAV?$allocator@UPkgFileInfo@Ogre@@@0@@Z ; std::_Destroy_range<std::allocator<Ogre::PkgFileInfo> >
; Function compile flags: /Odtp
;	COMDAT ?_Destroy@?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@IAEXPAUPkgFileInfo@Ogre@@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@IAEXPAUPkgFileInfo@Ogre@@0@Z PROC ; std::vector<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::_Destroy, COMDAT
; _this$ = ecx

; 1118 : 		{	// destroy [_First, _Last) using allocator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Destroy_range@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@YAXPAUPkgFileInfo@Ogre@@0AAV?$allocator@UPkgFileInfo@Ogre@@@0@@Z ; std::_Destroy_range<std::allocator<Ogre::PkgFileInfo> >
	add	esp, 12					; 0000000cH

; 1120 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?_Destroy@?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@IAEXPAUPkgFileInfo@Ogre@@0@Z ENDP ; std::vector<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::_Destroy
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Tidy@?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@IAEXXZ PROC ; std::vector<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	je	SHORT $LN1@Tidy

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@IAEXPAUPkgFileInfo@Ogre@@0@Z ; std::vector<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::_Destroy

; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+20]
	sub	ecx, DWORD PTR [eax+12]
	mov	eax, ecx
	cdq
	mov	ecx, 24					; 00000018H
	idiv	ecx
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?deallocate@?$allocator@UPkgFileInfo@Ogre@@@std@@QAEXPAUPkgFileInfo@Ogre@@I@Z ; std::allocator<Ogre::PkgFileInfo>::deallocate
$LN1@Tidy:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+16], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], 0

; 1135 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@IAEXXZ ENDP ; std::vector<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::_Tidy
_TEXT	ENDS
PUBLIC	??0?$_Container_base_aux_alloc_real@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@IAE@V?$allocator@UPkgFileInfo@Ogre@@@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::PkgFileInfo> >::_Container_base_aux_alloc_real<std::allocator<Ogre::PkgFileInfo> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$_Vector_val@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@IAE@V?$allocator@UPkgFileInfo@Ogre@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Vector_val@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@IAE@V?$allocator@UPkgFileInfo@Ogre@@@1@@Z$0
__ehfuncinfo$??0?$_Vector_val@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@IAE@V?$allocator@UPkgFileInfo@Ogre@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Vector_val@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@IAE@V?$allocator@UPkgFileInfo@Ogre@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Vector_val@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@IAE@V?$allocator@UPkgFileInfo@Ogre@@@1@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T124363 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 1
??0?$_Vector_val@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@IAE@V?$allocator@UPkgFileInfo@Ogre@@@1@@Z PROC ; std::_Vector_val<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::_Vector_val<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Vector_val@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@IAE@V?$allocator@UPkgFileInfo@Ogre@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T124363[ebp], esp
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	call	??0?$allocator@UPkgFileInfo@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::PkgFileInfo>::allocator<Ogre::PkgFileInfo>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Container_base_aux_alloc_real@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@IAE@V?$allocator@UPkgFileInfo@Ogre@@@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::PkgFileInfo> >::_Container_base_aux_alloc_real<std::allocator<Ogre::PkgFileInfo> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??0?$allocator@UPkgFileInfo@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::PkgFileInfo>::allocator<Ogre::PkgFileInfo>

; 426  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Vector_val@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@IAE@V?$allocator@UPkgFileInfo@Ogre@@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Container_base_aux_alloc_real@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::PkgFileInfo> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::PkgFileInfo> >
__ehhandler$??0?$_Vector_val@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@IAE@V?$allocator@UPkgFileInfo@Ogre@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Vector_val@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@IAE@V?$allocator@UPkgFileInfo@Ogre@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Vector_val@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@IAE@V?$allocator@UPkgFileInfo@Ogre@@@1@@Z ENDP ; std::_Vector_val<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::_Vector_val<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >
PUBLIC	??1_Container_base_aux@std@@QAE@XZ		; std::_Container_base_aux::~_Container_base_aux
PUBLIC	?deallocate@?$allocator@V_Aux_cont@std@@@std@@QAEXPAV_Aux_cont@2@I@Z ; std::allocator<std::_Aux_cont>::deallocate
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??1?$_Container_base_aux_alloc_real@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@IAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Container_base_aux_alloc_real@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@IAE@XZ$0
__ehfuncinfo$??1?$_Container_base_aux_alloc_real@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@IAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Container_base_aux_alloc_real@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@IAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$_Container_base_aux_alloc_real@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Container_base_aux_alloc_real@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::PkgFileInfo> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::PkgFileInfo> >, COMDAT
; _this$ = ecx

; 436  : 		{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Container_base_aux_alloc_real@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@IAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 437  : 		_Myownedaux->~_Aux_cont();
; 438  : 
; 439  : 		_Alaux.deallocate(_Myownedaux, 1);

	push	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?deallocate@?$allocator@V_Aux_cont@std@@@std@@QAEXPAV_Aux_cont@2@I@Z ; std::allocator<std::_Aux_cont>::deallocate

; 440  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Container_base_aux_alloc_real@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@IAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
__ehhandler$??1?$_Container_base_aux_alloc_real@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@IAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Container_base_aux_alloc_real@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@IAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Container_base_aux_alloc_real@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::PkgFileInfo> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::PkgFileInfo> >
; Function compile flags: /Odtp
;	COMDAT ??1_Container_base_aux@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_Container_base_aux@std@@QAE@XZ PROC			; std::_Container_base_aux::~_Container_base_aux, COMDAT
; _this$ = ecx

; 402  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 403  : 		// Do nothing: ~_Container_base_aux_alloc_real() previously destroyed the aux object.
; 404  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??1_Container_base_aux@std@@QAE@XZ ENDP			; std::_Container_base_aux::~_Container_base_aux
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@UPkgFileInfo@Ogre@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@UPkgFileInfo@Ogre@@@std@@QAE@XZ PROC	; std::allocator<Ogre::PkgFileInfo>::allocator<Ogre::PkgFileInfo>, COMDAT
; _this$ = ecx

; 119  : 	allocator() _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$allocator@UPkgFileInfo@Ogre@@@std@@QAE@XZ ENDP	; std::allocator<Ogre::PkgFileInfo>::allocator<Ogre::PkgFileInfo>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0?$allocator@UPkgFileInfo@Ogre@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$allocator@UPkgFileInfo@Ogre@@@std@@QAE@ABV01@@Z PROC ; std::allocator<Ogre::PkgFileInfo>::allocator<Ogre::PkgFileInfo>, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$allocator@UPkgFileInfo@Ogre@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<Ogre::PkgFileInfo>::allocator<Ogre::PkgFileInfo>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@UPkgFileInfo@Ogre@@@std@@QAEXPAUPkgFileInfo@Ogre@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@UPkgFileInfo@Ogre@@@std@@QAEXPAUPkgFileInfo@Ogre@@I@Z PROC ; std::allocator<Ogre::PkgFileInfo>::deallocate, COMDAT
; _this$ = ecx

; 139  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 141  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@UPkgFileInfo@Ogre@@@std@@QAEXPAUPkgFileInfo@Ogre@@I@Z ENDP ; std::allocator<Ogre::PkgFileInfo>::deallocate
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?capacity@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
tv70 = -8						; size = 4
_this$ = -4						; size = 4
?capacity@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QBEIXZ PROC ; std::vector<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::capacity, COMDAT
; _this$ = ecx

; 634  : 		{	// return current length of allocated storage

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	jne	SHORT $LN3@capacity@2
	mov	DWORD PTR tv70[ebp], 0
	jmp	SHORT $LN4@capacity@2
$LN3@capacity@2:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+20]
	sub	eax, DWORD PTR [edx+12]
	sar	eax, 2
	mov	DWORD PTR tv70[ebp], eax
$LN4@capacity@2:
	mov	eax, DWORD PTR tv70[ebp]

; 636  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?capacity@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QBEIXZ ENDP ; std::vector<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::capacity
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QAE@PAPAVPackageDataStreamObject@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::_Vector_iterator<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >
; Function compile flags: /Odtp
;	COMDAT ?begin@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@2@XZ PROC ; std::vector<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::begin, COMDAT
; _this$ = ecx

; 640  : 		{	// return iterator for beginning of mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 641  : 		return (iterator(_Myfirst, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QAE@PAPAVPackageDataStreamObject@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::_Vector_iterator<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 642  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?begin@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@2@XZ ENDP ; std::vector<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::begin
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QAE@PAPAVPackageDataStreamObject@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::_Vector_const_iterator<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >
; Function compile flags: /Odtp
;	COMDAT ?begin@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@2@XZ PROC ; std::vector<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::begin, COMDAT
; _this$ = ecx

; 645  : 		{	// return iterator for beginning of nonmutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 646  : 		return (const_iterator(_Myfirst, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_const_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QAE@PAPAVPackageDataStreamObject@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::_Vector_const_iterator<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 647  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?begin@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@2@XZ ENDP ; std::vector<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::begin
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?end@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@2@XZ PROC ; std::vector<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::end, COMDAT
; _this$ = ecx

; 650  : 		{	// return iterator for end of mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 651  : 		return (iterator(_Mylast, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QAE@PAPAVPackageDataStreamObject@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::_Vector_iterator<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 652  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?end@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@2@XZ ENDP ; std::vector<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::end
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?end@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@2@XZ PROC ; std::vector<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::end, COMDAT
; _this$ = ecx

; 655  : 		{	// return iterator for end of nonmutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 656  : 		return (const_iterator(_Mylast, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_const_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QAE@PAPAVPackageDataStreamObject@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::_Vector_const_iterator<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 657  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?end@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@2@XZ ENDP ; std::vector<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::end
_TEXT	ENDS
PUBLIC	??H?$_Vector_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::operator+
PUBLIC	?_Insert_n@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@2@IABQAVPackageDataStreamObject@Ogre@@@Z ; std::vector<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::_Insert_n
PUBLIC	??G?$_Vector_const_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QBEHABV01@@Z ; std::_Vector_const_iterator<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::operator-
; Function compile flags: /Odtp
;	COMDAT ?insert@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@2@ABQAVPackageDataStreamObject@Ogre@@@Z
_TEXT	SEGMENT
tv77 = -28						; size = 4
_this$ = -24						; size = 4
$T124405 = -20						; size = 8
$T124402 = -12						; size = 8
__Off$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 8
__Val$ = 20						; size = 4
?insert@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@2@ABQAVPackageDataStreamObject@Ogre@@@Z PROC ; std::vector<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::insert, COMDAT
; _this$ = ecx

; 875  : 		{	// insert _Val at _Where

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR _this$[ebp], ecx

; 876  : 		size_type _Off = size() == 0 ? 0 : _Where - begin();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::size
	test	eax, eax
	jne	SHORT $LN3@insert
	mov	DWORD PTR tv77[ebp], 0
	jmp	SHORT $LN4@insert
$LN3@insert:
	lea	eax, DWORD PTR $T124402[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@2@XZ ; std::vector<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::begin
	push	eax
	lea	ecx, DWORD PTR __Where$[ebp]
	call	??G?$_Vector_const_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QBEHABV01@@Z ; std::_Vector_const_iterator<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::operator-
	mov	DWORD PTR tv77[ebp], eax
$LN4@insert:
	mov	ecx, DWORD PTR tv77[ebp]
	mov	DWORD PTR __Off$[ebp], ecx

; 877  : 		_Insert_n(_Where, (size_type)1, _Val);

	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	push	1
	mov	eax, DWORD PTR __Where$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert_n@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@2@IABQAVPackageDataStreamObject@Ogre@@@Z ; std::vector<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::_Insert_n

; 878  : 		return (begin() + _Off);

	mov	edx, DWORD PTR __Off$[ebp]
	push	edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T124405[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@2@XZ ; std::vector<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::begin
	mov	ecx, eax
	call	??H?$_Vector_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::operator+
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 879  : 		}

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?insert@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@2@ABQAVPackageDataStreamObject@Ogre@@@Z ENDP ; std::vector<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::insert
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::operator!=
PUBLIC	?_Make_iter@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@2@@Z ; std::vector<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::_Make_iter
; Function compile flags: /Odtp
;	COMDAT ?erase@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@2@0@Z
_TEXT	SEGMENT
_this$ = -24						; size = 4
__Ptr$119789 = -20					; size = 4
__Last$ = -16						; size = 8
__First$ = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 8
__Last_arg$ = 20					; size = 8
?erase@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@2@0@Z PROC ; std::vector<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::erase, COMDAT
; _this$ = ecx

; 1028 : 		{	// erase [_First, _Last)

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	eax, DWORD PTR __First_arg$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __First_arg$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Make_iter@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@2@@Z ; std::vector<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::_Make_iter

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);

	mov	eax, DWORD PTR __Last_arg$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __Last_arg$[ebp]
	push	ecx
	lea	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Make_iter@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@2@@Z ; std::vector<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::_Make_iter

; 1031 : 
; 1032 : 		if (_First != _Last)

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	call	??9?$_Vector_const_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::operator!=
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@erase

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	edx, DWORD PTR __First$[ebp+4]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp+4]
	push	edx
	call	??$unchecked_copy@PAPAVPackageDataStreamObject@Ogre@@PAPAV12@@stdext@@YAPAPAVPackageDataStreamObject@Ogre@@PAPAV12@00@Z ; stdext::unchecked_copy<Ogre::PackageDataStreamObject * *,Ogre::PackageDataStreamObject * *>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR __Ptr$119789[ebp], eax

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Ptr$119789[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@IAEXPAPAVPackageDataStreamObject@Ogre@@0@Z ; std::vector<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::_Destroy

; 1049 : 			_Mylast = _Ptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Ptr$119789[ebp]
	mov	DWORD PTR [eax+16], ecx
$LN1@erase:

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);

	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR __First$[ebp+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1055 : #endif
; 1056 : 		}

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?erase@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@2@0@Z ENDP ; std::vector<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::erase
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@QAEPAPAVPackageDataStreamObject@Ogre@@I@Z ; std::allocator<Ogre::PackageDataStreamObject *>::allocate
PUBLIC	?_Xlen@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@KAXXZ ; std::vector<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::_Xlen
PUBLIC	?max_size@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::max_size
; Function compile flags: /Odtp
;	COMDAT ?_Buy@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Capacity$ = 8						; size = 4
?_Buy@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@IAE_NI@Z PROC ; std::vector<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+20], 0

; 1104 : 		if (_Capacity == 0)

	cmp	DWORD PTR __Capacity$[ebp], 0
	jne	SHORT $LN4@Buy@2

; 1105 : 			return (false);

	xor	al, al
	jmp	SHORT $LN5@Buy@2
	jmp	SHORT $LN3@Buy@2
$LN4@Buy@2:

; 1106 : 		else if (max_size() < _Capacity)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::max_size
	cmp	eax, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN2@Buy@2

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@KAXXZ ; std::vector<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::_Xlen

; 1108 : 		else

	jmp	SHORT $LN3@Buy@2
$LN2@Buy@2:

; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	mov	eax, DWORD PTR __Capacity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?allocate@?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@QAEPAPAVPackageDataStreamObject@Ogre@@I@Z ; std::allocator<Ogre::PackageDataStreamObject *>::allocate
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [edx+16], ecx

; 1112 : 			_Myend = _Myfirst + _Capacity;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR __Capacity$[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], edx
$LN3@Buy@2:

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
$LN5@Buy@2:

; 1115 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Buy@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::_Buy
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@YAXPAPAVPackageDataStreamObject@Ogre@@0AAV?$allocator@PAVPackageDataStreamObject@Ogre@@@0@@Z ; std::_Destroy_range<std::allocator<Ogre::PackageDataStreamObject *> >
; Function compile flags: /Odtp
;	COMDAT ?_Destroy@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@IAEXPAPAVPackageDataStreamObject@Ogre@@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@IAEXPAPAVPackageDataStreamObject@Ogre@@0@Z PROC ; std::vector<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::_Destroy, COMDAT
; _this$ = ecx

; 1118 : 		{	// destroy [_First, _Last) using allocator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Destroy_range@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@YAXPAPAVPackageDataStreamObject@Ogre@@0AAV?$allocator@PAVPackageDataStreamObject@Ogre@@@0@@Z ; std::_Destroy_range<std::allocator<Ogre::PackageDataStreamObject *> >
	add	esp, 12					; 0000000cH

; 1120 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?_Destroy@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@IAEXPAPAVPackageDataStreamObject@Ogre@@0@Z ENDP ; std::vector<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::_Destroy
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Tidy@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@IAEXXZ PROC ; std::vector<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	je	SHORT $LN1@Tidy@2

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@IAEXPAPAVPackageDataStreamObject@Ogre@@0@Z ; std::vector<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::_Destroy

; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+20]
	sub	ecx, DWORD PTR [eax+12]
	sar	ecx, 2
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?deallocate@?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@QAEXPAPAVPackageDataStreamObject@Ogre@@I@Z ; std::allocator<Ogre::PackageDataStreamObject *>::deallocate
$LN1@Tidy@2:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+16], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], 0

; 1135 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@IAEXXZ ENDP ; std::vector<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::_Tidy
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_fill_n@PAPAVPackageDataStreamObject@Ogre@@IPAV12@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@stdext@@YAXPAPAVPackageDataStreamObject@Ogre@@IABQAV12@AAV?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@Z ; stdext::unchecked_uninitialized_fill_n<Ogre::PackageDataStreamObject * *,unsigned int,Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >
; Function compile flags: /Odtp
;	COMDAT ?_Ufill@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@IAEPAPAVPackageDataStreamObject@Ogre@@PAPAV34@IABQAV34@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Ufill@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@IAEPAPAVPackageDataStreamObject@Ogre@@PAPAV34@IABQAV34@@Z PROC ; std::vector<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::_Ufill, COMDAT
; _this$ = ecx

; 1253 : 		{	// copy initializing _Count * _Val, using allocator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1254 : 		_STDEXT unchecked_uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??$unchecked_uninitialized_fill_n@PAPAVPackageDataStreamObject@Ogre@@IPAV12@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@stdext@@YAXPAPAVPackageDataStreamObject@Ogre@@IABQAV12@AAV?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@Z ; stdext::unchecked_uninitialized_fill_n<Ogre::PackageDataStreamObject * *,unsigned int,Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >
	add	esp, 16					; 00000010H

; 1255 : 		return (_Ptr + _Count);

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Ptr$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]

; 1256 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?_Ufill@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@IAEPAPAVPackageDataStreamObject@Ogre@@PAPAV34@IABQAV34@@Z ENDP ; std::vector<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::_Ufill
_TEXT	ENDS
PUBLIC	??0?$_Container_base_aux_alloc_real@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@IAE@V?$allocator@PAVPackageDataStreamObject@Ogre@@@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::PackageDataStreamObject *> >::_Container_base_aux_alloc_real<std::allocator<Ogre::PackageDataStreamObject *> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$_Vector_val@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@IAE@V?$allocator@PAVPackageDataStreamObject@Ogre@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Vector_val@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@IAE@V?$allocator@PAVPackageDataStreamObject@Ogre@@@1@@Z$0
__ehfuncinfo$??0?$_Vector_val@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@IAE@V?$allocator@PAVPackageDataStreamObject@Ogre@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Vector_val@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@IAE@V?$allocator@PAVPackageDataStreamObject@Ogre@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Vector_val@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@IAE@V?$allocator@PAVPackageDataStreamObject@Ogre@@@1@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T124418 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 1
??0?$_Vector_val@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@IAE@V?$allocator@PAVPackageDataStreamObject@Ogre@@@1@@Z PROC ; std::_Vector_val<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::_Vector_val<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Vector_val@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@IAE@V?$allocator@PAVPackageDataStreamObject@Ogre@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T124418[ebp], esp
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	call	??0?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::PackageDataStreamObject *>::allocator<Ogre::PackageDataStreamObject *>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Container_base_aux_alloc_real@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@IAE@V?$allocator@PAVPackageDataStreamObject@Ogre@@@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::PackageDataStreamObject *> >::_Container_base_aux_alloc_real<std::allocator<Ogre::PackageDataStreamObject *> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??0?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::PackageDataStreamObject *>::allocator<Ogre::PackageDataStreamObject *>

; 426  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Vector_val@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@IAE@V?$allocator@PAVPackageDataStreamObject@Ogre@@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Container_base_aux_alloc_real@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::PackageDataStreamObject *> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::PackageDataStreamObject *> >
__ehhandler$??0?$_Vector_val@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@IAE@V?$allocator@PAVPackageDataStreamObject@Ogre@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Vector_val@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@IAE@V?$allocator@PAVPackageDataStreamObject@Ogre@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Vector_val@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@IAE@V?$allocator@PAVPackageDataStreamObject@Ogre@@@1@@Z ENDP ; std::_Vector_val<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::_Vector_val<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??1?$_Container_base_aux_alloc_real@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@IAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Container_base_aux_alloc_real@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@IAE@XZ$0
__ehfuncinfo$??1?$_Container_base_aux_alloc_real@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@IAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Container_base_aux_alloc_real@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@IAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$_Container_base_aux_alloc_real@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Container_base_aux_alloc_real@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::PackageDataStreamObject *> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::PackageDataStreamObject *> >, COMDAT
; _this$ = ecx

; 436  : 		{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Container_base_aux_alloc_real@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@IAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 437  : 		_Myownedaux->~_Aux_cont();
; 438  : 
; 439  : 		_Alaux.deallocate(_Myownedaux, 1);

	push	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?deallocate@?$allocator@V_Aux_cont@std@@@std@@QAEXPAV_Aux_cont@2@I@Z ; std::allocator<std::_Aux_cont>::deallocate

; 440  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Container_base_aux_alloc_real@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@IAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
__ehhandler$??1?$_Container_base_aux_alloc_real@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@IAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Container_base_aux_alloc_real@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@IAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Container_base_aux_alloc_real@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::PackageDataStreamObject *> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::PackageDataStreamObject *> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@QAE@XZ PROC ; std::allocator<Ogre::PackageDataStreamObject *>::allocator<Ogre::PackageDataStreamObject *>, COMDAT
; _this$ = ecx

; 119  : 	allocator() _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@QAE@XZ ENDP ; std::allocator<Ogre::PackageDataStreamObject *>::allocator<Ogre::PackageDataStreamObject *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@QAE@ABV01@@Z PROC ; std::allocator<Ogre::PackageDataStreamObject *>::allocator<Ogre::PackageDataStreamObject *>, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<Ogre::PackageDataStreamObject *>::allocator<Ogre::PackageDataStreamObject *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@QAEXPAPAVPackageDataStreamObject@Ogre@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@QAEXPAPAVPackageDataStreamObject@Ogre@@I@Z PROC ; std::allocator<Ogre::PackageDataStreamObject *>::deallocate, COMDAT
; _this$ = ecx

; 139  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 141  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@QAEXPAPAVPackageDataStreamObject@Ogre@@I@Z ENDP ; std::allocator<Ogre::PackageDataStreamObject *>::deallocate
_TEXT	ENDS
PUBLIC	??D?$_Vector_const_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QBEABQAVPackageDataStreamObject@Ogre@@XZ ; std::_Vector_const_iterator<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::operator*
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??D?$_Vector_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QBEAAPAVPackageDataStreamObject@Ogre@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??D?$_Vector_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QBEAAPAVPackageDataStreamObject@Ogre@@XZ PROC ; std::_Vector_iterator<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::operator*, COMDAT
; _this$ = ecx

; 338  : 		{	// return designated object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 339  : 		return ((reference)**(_Mybase *)this);

	mov	ecx, DWORD PTR _this$[ebp]
	call	??D?$_Vector_const_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QBEABQAVPackageDataStreamObject@Ogre@@XZ ; std::_Vector_const_iterator<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::operator*

; 340  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??D?$_Vector_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QBEAAPAVPackageDataStreamObject@Ogre@@XZ ENDP ; std::_Vector_iterator<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::operator*
_TEXT	ENDS
PUBLIC	??Z?$_Vector_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::operator-=
; Function compile flags: /Odtp
;	COMDAT ??G?$_Vector_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
__Tmp$ = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??G?$_Vector_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::operator-, COMDAT
; _this$ = ecx

; 391  : 		{	// return this - integer

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 392  : 		_Myt _Tmp = *this;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR __Tmp$[ebp], ecx
	mov	DWORD PTR __Tmp$[ebp+4], edx

; 393  : 		return (_Tmp -= _Off);

	mov	eax, DWORD PTR __Off$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Tmp$[ebp]
	call	??Z?$_Vector_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::operator-=
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 394  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
??G?$_Vector_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::operator-
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QAE@PAUPkgFileInfo@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::_Vector_iterator<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >
; Function compile flags: /Odtp
;	COMDAT ?begin@?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@2@XZ PROC ; std::vector<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::begin, COMDAT
; _this$ = ecx

; 640  : 		{	// return iterator for beginning of mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 641  : 		return (iterator(_Myfirst, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QAE@PAUPkgFileInfo@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::_Vector_iterator<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 642  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?begin@?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@2@XZ ENDP ; std::vector<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::begin
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?end@?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@2@XZ PROC ; std::vector<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::end, COMDAT
; _this$ = ecx

; 650  : 		{	// return iterator for end of mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 651  : 		return (iterator(_Mylast, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QAE@PAUPkgFileInfo@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::_Vector_iterator<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 652  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?end@?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@2@XZ ENDP ; std::vector<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::end
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@UPkgFileInfo@Ogre@@@std@@QBEIXZ ; std::allocator<Ogre::PkgFileInfo>::max_size
; Function compile flags: /Odtp
;	COMDAT ?max_size@?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QBEIXZ PROC ; std::vector<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::max_size, COMDAT
; _this$ = ecx

; 730  : 		{	// return maximum possible length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 731  : 		return (this->_Alval.max_size());

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?max_size@?$allocator@UPkgFileInfo@Ogre@@@std@@QBEIXZ ; std::allocator<Ogre::PkgFileInfo>::max_size

; 732  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QBEIXZ ENDP ; std::vector<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::max_size
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::operator!=
PUBLIC	?_Make_iter@?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@2@V?$_Vector_const_iterator@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@2@@Z ; std::vector<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::_Make_iter
; Function compile flags: /Odtp
;	COMDAT ?erase@?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@2@V?$_Vector_const_iterator@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@2@0@Z
_TEXT	SEGMENT
_this$ = -24						; size = 4
__Ptr$120058 = -20					; size = 4
__Last$ = -16						; size = 8
__First$ = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 8
__Last_arg$ = 20					; size = 8
?erase@?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@2@V?$_Vector_const_iterator@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@2@0@Z PROC ; std::vector<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::erase, COMDAT
; _this$ = ecx

; 1028 : 		{	// erase [_First, _Last)

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	eax, DWORD PTR __First_arg$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __First_arg$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Make_iter@?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@2@V?$_Vector_const_iterator@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@2@@Z ; std::vector<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::_Make_iter

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);

	mov	eax, DWORD PTR __Last_arg$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __Last_arg$[ebp]
	push	ecx
	lea	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Make_iter@?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@2@V?$_Vector_const_iterator@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@2@@Z ; std::vector<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::_Make_iter

; 1031 : 
; 1032 : 		if (_First != _Last)

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	call	??9?$_Vector_const_iterator@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::operator!=
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@erase@2

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	edx, DWORD PTR __First$[ebp+4]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp+4]
	push	edx
	call	??$unchecked_copy@PAUPkgFileInfo@Ogre@@PAU12@@stdext@@YAPAUPkgFileInfo@Ogre@@PAU12@00@Z ; stdext::unchecked_copy<Ogre::PkgFileInfo *,Ogre::PkgFileInfo *>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR __Ptr$120058[ebp], eax

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Ptr$120058[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@IAEXPAUPkgFileInfo@Ogre@@0@Z ; std::vector<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::_Destroy

; 1049 : 			_Mylast = _Ptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Ptr$120058[ebp]
	mov	DWORD PTR [eax+16], ecx
$LN1@erase@2:

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);

	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR __First$[ebp+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1055 : #endif
; 1056 : 		}

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?erase@?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@2@V?$_Vector_const_iterator@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@2@0@Z ENDP ; std::vector<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::erase
_TEXT	ENDS
PUBLIC	??$_Unchecked_move_backward@PAUPkgFileInfo@Ogre@@PAU12@@stdext@@YAPAUPkgFileInfo@Ogre@@PAU12@00@Z ; stdext::_Unchecked_move_backward<Ogre::PkgFileInfo *,Ogre::PkgFileInfo *>
PUBLIC	??$fill@PAUPkgFileInfo@Ogre@@U12@@std@@YAXPAUPkgFileInfo@Ogre@@0ABU12@@Z ; std::fill<Ogre::PkgFileInfo *,Ogre::PkgFileInfo>
PUBLIC	??$_Umove@PAUPkgFileInfo@Ogre@@@?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@IAEPAUPkgFileInfo@Ogre@@PAU23@00@Z ; std::vector<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::_Umove<Ogre::PkgFileInfo *>
PUBLIC	?_Ufill@?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@IAEPAUPkgFileInfo@Ogre@@PAU34@IABU34@@Z ; std::vector<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::_Ufill
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Insert_n@?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@2@IABUPkgFileInfo@Ogre@@@Z$5 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@2@IABUPkgFileInfo@Ogre@@@Z$2
__catchsym$?_Insert_n@?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@2@IABUPkgFileInfo@Ogre@@@Z$4 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@2@IABUPkgFileInfo@Ogre@@@Z$0
__unwindtable$?_Insert_n@?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@2@IABUPkgFileInfo@Ogre@@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$?_Insert_n@?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@2@IABUPkgFileInfo@Ogre@@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Insert_n@?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@2@IABUPkgFileInfo@Ogre@@@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Insert_n@?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@2@IABUPkgFileInfo@Ogre@@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__tryblocktable$?_Insert_n@?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@2@IABUPkgFileInfo@Ogre@@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@2@IABUPkgFileInfo@Ogre@@@Z$4
	DD	02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@2@IABUPkgFileInfo@Ogre@@@Z$5
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?_Insert_n@?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@2@IABUPkgFileInfo@Ogre@@@Z
_TEXT	SEGMENT
tv84 = -92						; size = 4
_this$ = -88						; size = 4
__Tmp$120093 = -84					; size = 24
__Oldend$120094 = -60					; size = 4
__Tmp$120083 = -56					; size = 24
__Ncopied$120070 = -32					; size = 4
__Newvec$120068 = -28					; size = 4
__Whereoff$120069 = -24					; size = 4
__Capacity$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Where$ = 8						; size = 8
__Count$ = 16						; size = 4
__Val$ = 20						; size = 4
?_Insert_n@?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@2@IABUPkgFileInfo@Ogre@@@Z PROC ; std::vector<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::_Insert_n, COMDAT
; _this$ = ecx

; 1153 : 		{	// insert _Count * _Val at _Where

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Insert_n@?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@2@IABUPkgFileInfo@Ogre@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1154 : 
; 1155 :  #if _HAS_ITERATOR_DEBUGGING
; 1156 : 		if (_Where._Mycont != this
; 1157 : 			|| _Where._Myptr < _Myfirst || _Mylast < _Where._Myptr)
; 1158 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1159 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1160 : 
; 1161 : 		size_type _Capacity = capacity();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?capacity@?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::capacity
	mov	DWORD PTR __Capacity$[ebp], eax

; 1162 : 
; 1163 : 		if (_Count == 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN14@Insert_n
	jmp	$LN16@Insert_n
$LN14@Insert_n:

; 1164 : 			;
; 1165 : 		else if (max_size() - size() < _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::max_size
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::size
	sub	esi, eax
	cmp	esi, DWORD PTR __Count$[ebp]
	jae	SHORT $LN12@Insert_n

; 1166 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@KAXXZ ; std::vector<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::_Xlen
	jmp	$LN16@Insert_n
$LN12@Insert_n:

; 1167 : 		else if (_Capacity < size() + _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::size
	add	eax, DWORD PTR __Count$[ebp]
	cmp	DWORD PTR __Capacity$[ebp], eax
	jae	$LN10@Insert_n

; 1168 : 			{	// not enough room, reallocate
; 1169 : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1170 : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::max_size
	mov	ecx, DWORD PTR __Capacity$[ebp]
	shr	ecx, 1
	sub	eax, ecx
	cmp	eax, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN17@Insert_n
	mov	DWORD PTR tv84[ebp], 0
	jmp	SHORT $LN18@Insert_n
$LN17@Insert_n:
	mov	edx, DWORD PTR __Capacity$[ebp]
	shr	edx, 1
	add	edx, DWORD PTR __Capacity$[ebp]
	mov	DWORD PTR tv84[ebp], edx
$LN18@Insert_n:
	mov	eax, DWORD PTR tv84[ebp]
	mov	DWORD PTR __Capacity$[ebp], eax

; 1171 : 			if (_Capacity < size() + _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::size
	add	eax, DWORD PTR __Count$[ebp]
	cmp	DWORD PTR __Capacity$[ebp], eax
	jae	SHORT $LN9@Insert_n

; 1172 : 				_Capacity = size() + _Count;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::size
	add	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Capacity$[ebp], eax
$LN9@Insert_n:

; 1173 : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

	mov	ecx, DWORD PTR __Capacity$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?allocate@?$allocator@UPkgFileInfo@Ogre@@@std@@QAEPAUPkgFileInfo@Ogre@@I@Z ; std::allocator<Ogre::PkgFileInfo>::allocate
	mov	DWORD PTR __Newvec$120068[ebp], eax

; 1174 : 			size_type _Whereoff = _VEC_ITER_BASE(_Where) - _Myfirst;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Where$[ebp+4]
	sub	eax, DWORD PTR [edx+12]
	cdq
	mov	ecx, 24					; 00000018H
	idiv	ecx
	mov	DWORD PTR __Whereoff$120069[ebp], eax

; 1175 : 			int _Ncopied = 0;

	mov	DWORD PTR __Ncopied$120070[ebp], 0

; 1176 : 
; 1177 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1178 : 			_Ufill(_Newvec + _Whereoff, _Count, _Val);	// add new stuff

	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Whereoff$120069[ebp]
	imul	ecx, 24					; 00000018H
	add	ecx, DWORD PTR __Newvec$120068[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Ufill@?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@IAEPAUPkgFileInfo@Ogre@@PAU34@IABU34@@Z ; std::vector<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::_Ufill

; 1179 : 			++_Ncopied;

	mov	edx, DWORD PTR __Ncopied$120070[ebp]
	add	edx, 1
	mov	DWORD PTR __Ncopied$120070[ebp], edx

; 1180 : 			_Umove(this->_Myfirst, _VEC_ITER_BASE(_Where),
; 1181 : 				_Newvec);	// move prefix

	mov	eax, DWORD PTR __Newvec$120068[ebp]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Umove@PAUPkgFileInfo@Ogre@@@?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@IAEPAUPkgFileInfo@Ogre@@PAU23@00@Z ; std::vector<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::_Umove<Ogre::PkgFileInfo *>

; 1182 : 			++_Ncopied;

	mov	ecx, DWORD PTR __Ncopied$120070[ebp]
	add	ecx, 1
	mov	DWORD PTR __Ncopied$120070[ebp], ecx

; 1183 : 			_Umove(_VEC_ITER_BASE(_Where), this->_Mylast,
; 1184 : 				_Newvec + (_Whereoff + _Count));	// move suffix

	mov	edx, DWORD PTR __Whereoff$120069[ebp]
	add	edx, DWORD PTR __Count$[ebp]
	imul	edx, 24					; 00000018H
	add	edx, DWORD PTR __Newvec$120068[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Where$[ebp+4]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Umove@PAUPkgFileInfo@Ogre@@@?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@IAEPAUPkgFileInfo@Ogre@@PAU23@00@Z ; std::vector<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::_Umove<Ogre::PkgFileInfo *>
	jmp	SHORT $LN19@Insert_n
__catch$?_Insert_n@?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@2@IABUPkgFileInfo@Ogre@@@Z$0:

; 1185 : 			_CATCH_ALL
; 1186 : 			if (1 < _Ncopied)

	cmp	DWORD PTR __Ncopied$120070[ebp], 1
	jle	SHORT $LN7@Insert_n

; 1187 : 				_Destroy(_Newvec, _Newvec + _Whereoff);

	mov	eax, DWORD PTR __Whereoff$120069[ebp]
	imul	eax, 24					; 00000018H
	add	eax, DWORD PTR __Newvec$120068[ebp]
	push	eax
	mov	ecx, DWORD PTR __Newvec$120068[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@IAEXPAUPkgFileInfo@Ogre@@0@Z ; std::vector<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::_Destroy
$LN7@Insert_n:

; 1188 : 			if (0 < _Ncopied)

	cmp	DWORD PTR __Ncopied$120070[ebp], 0
	jle	SHORT $LN6@Insert_n

; 1189 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);

	mov	edx, DWORD PTR __Whereoff$120069[ebp]
	imul	edx, 24					; 00000018H
	add	edx, DWORD PTR __Newvec$120068[ebp]
	mov	eax, DWORD PTR __Count$[ebp]
	imul	eax, 24					; 00000018H
	add	edx, eax
	push	edx
	mov	ecx, DWORD PTR __Whereoff$120069[ebp]
	imul	ecx, 24					; 00000018H
	add	ecx, DWORD PTR __Newvec$120068[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@IAEXPAUPkgFileInfo@Ogre@@0@Z ; std::vector<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::_Destroy
$LN6@Insert_n:

; 1190 : 			this->_Alval.deallocate(_Newvec, _Capacity);

	mov	edx, DWORD PTR __Capacity$[ebp]
	push	edx
	mov	eax, DWORD PTR __Newvec$120068[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?deallocate@?$allocator@UPkgFileInfo@Ogre@@@std@@QAEXPAUPkgFileInfo@Ogre@@I@Z ; std::allocator<Ogre::PkgFileInfo>::deallocate

; 1191 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1192 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$?_Insert_n@?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@2@IABUPkgFileInfo@Ogre@@@Z$1
	ret	0
$LN19@Insert_n:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Insert_n@?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@2@IABUPkgFileInfo@Ogre@@@Z$1:

; 1193 : 
; 1194 : 			_Count += size();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::size
	add	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Count$[ebp], eax

; 1195 : 			if (_Myfirst != 0)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+12], 0
	je	SHORT $LN5@Insert_n

; 1196 : 				{	// destroy and deallocate old array
; 1197 : 				_Destroy(_Myfirst, _Mylast);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@IAEXPAUPkgFileInfo@Ogre@@0@Z ; std::vector<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::_Destroy

; 1198 : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+20]
	sub	eax, DWORD PTR [ecx+12]
	cdq
	mov	ecx, 24					; 00000018H
	idiv	ecx
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?deallocate@?$allocator@UPkgFileInfo@Ogre@@@std@@QAEXPAUPkgFileInfo@Ogre@@I@Z ; std::allocator<Ogre::PkgFileInfo>::deallocate
$LN5@Insert_n:

; 1199 : 				}
; 1200 : 
; 1201 :  #if _HAS_ITERATOR_DEBUGGING
; 1202 : 			this->_Orphan_all();
; 1203 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1204 : 
; 1205 : 			_Myend = _Newvec + _Capacity;

	mov	ecx, DWORD PTR __Capacity$[ebp]
	imul	ecx, 24					; 00000018H
	add	ecx, DWORD PTR __Newvec$120068[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+20], ecx

; 1206 : 			_Mylast = _Newvec + _Count;

	mov	eax, DWORD PTR __Count$[ebp]
	imul	eax, 24					; 00000018H
	add	eax, DWORD PTR __Newvec$120068[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 1207 : 			_Myfirst = _Newvec;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Newvec$120068[ebp]
	mov	DWORD PTR [edx+12], eax
	jmp	$LN16@Insert_n
$LN10@Insert_n:

; 1208 : 			}
; 1209 : 		else if ((size_type)(_Mylast - _VEC_ITER_BASE(_Where)) < _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+16]
	sub	eax, DWORD PTR __Where$[ebp+4]
	cdq
	mov	ecx, 24					; 00000018H
	idiv	ecx
	cmp	eax, DWORD PTR __Count$[ebp]
	jae	$LN3@Insert_n

; 1210 : 			{	// new stuff spills off end
; 1211 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	edx, DWORD PTR __Val$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR __Tmp$120083[ebp], eax
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR __Tmp$120083[ebp+4], ecx
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR __Tmp$120083[ebp+8], eax
	mov	ecx, DWORD PTR [edx+12]
	mov	DWORD PTR __Tmp$120083[ebp+12], ecx
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR __Tmp$120083[ebp+16], eax
	mov	ecx, DWORD PTR [edx+20]
	mov	DWORD PTR __Tmp$120083[ebp+20], ecx

; 1212 : 
; 1213 : 			_Umove(_VEC_ITER_BASE(_Where), _Mylast,
; 1214 : 				_VEC_ITER_BASE(_Where) + _Count);	// copy suffix

	mov	edx, DWORD PTR __Count$[ebp]
	imul	edx, 24					; 00000018H
	add	edx, DWORD PTR __Where$[ebp+4]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Where$[ebp+4]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Umove@PAUPkgFileInfo@Ogre@@@?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@IAEPAUPkgFileInfo@Ogre@@PAU23@00@Z ; std::vector<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::_Umove<Ogre::PkgFileInfo *>

; 1215 : 
; 1216 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 2

; 1217 : 			_Ufill(_Mylast, _Count - (_Mylast - _VEC_ITER_BASE(_Where)),
; 1218 : 				_Tmp);	// insert new stuff off end

	lea	eax, DWORD PTR __Tmp$120083[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+16]
	sub	eax, DWORD PTR __Where$[ebp+4]
	cdq
	mov	ecx, 24					; 00000018H
	idiv	ecx
	mov	edx, DWORD PTR __Count$[ebp]
	sub	edx, eax
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Ufill@?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@IAEPAUPkgFileInfo@Ogre@@PAU34@IABU34@@Z ; std::vector<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::_Ufill
	jmp	SHORT $LN21@Insert_n
__catch$?_Insert_n@?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@2@IABUPkgFileInfo@Ogre@@@Z$2:

; 1219 : 			_CATCH_ALL
; 1220 : 			_Destroy(_VEC_ITER_BASE(_Where) + _Count, _Mylast + _Count);

	mov	edx, DWORD PTR __Count$[ebp]
	imul	edx, 24					; 00000018H
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+16]
	push	edx
	mov	ecx, DWORD PTR __Count$[ebp]
	imul	ecx, 24					; 00000018H
	add	ecx, DWORD PTR __Where$[ebp+4]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@IAEXPAUPkgFileInfo@Ogre@@0@Z ; std::vector<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::_Destroy

; 1221 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1222 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$?_Insert_n@?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@2@IABUPkgFileInfo@Ogre@@@Z$3
	ret	0
$LN21@Insert_n:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Insert_n@?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@2@IABUPkgFileInfo@Ogre@@@Z$3:

; 1223 : 
; 1224 : 			_Mylast += _Count;

	mov	edx, DWORD PTR __Count$[ebp]
	imul	edx, 24					; 00000018H
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+16]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], edx

; 1225 : 
; 1226 :  #if _HAS_ITERATOR_DEBUGGING
; 1227 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1228 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1229 : 
; 1230 : 			std::fill(_VEC_ITER_BASE(_Where), _Mylast - _Count,
; 1231 : 				_Tmp);	// insert up to old end

	lea	edx, DWORD PTR __Tmp$120083[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	sub	edx, eax
	push	edx
	mov	eax, DWORD PTR __Where$[ebp+4]
	push	eax
	call	??$fill@PAUPkgFileInfo@Ogre@@U12@@std@@YAXPAUPkgFileInfo@Ogre@@0ABU12@@Z ; std::fill<Ogre::PkgFileInfo *,Ogre::PkgFileInfo>
	add	esp, 12					; 0000000cH

; 1232 : 			}
; 1233 : 		else

	jmp	$LN16@Insert_n
$LN3@Insert_n:

; 1234 : 			{	// new stuff can all be assigned
; 1235 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	ecx, DWORD PTR __Val$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR __Tmp$120093[ebp], edx
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR __Tmp$120093[ebp+4], eax
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR __Tmp$120093[ebp+8], edx
	mov	eax, DWORD PTR [ecx+12]
	mov	DWORD PTR __Tmp$120093[ebp+12], eax
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR __Tmp$120093[ebp+16], edx
	mov	eax, DWORD PTR [ecx+20]
	mov	DWORD PTR __Tmp$120093[ebp+20], eax

; 1236 : 
; 1237 : 			pointer _Oldend = _Mylast;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR __Oldend$120094[ebp], edx

; 1238 : 			_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1239 : 				_Mylast);	// copy suffix

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Oldend$120094[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR __Oldend$120094[ebp]
	sub	ecx, eax
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Umove@PAUPkgFileInfo@Ogre@@@?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@IAEPAUPkgFileInfo@Ogre@@PAU23@00@Z ; std::vector<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::_Umove<Ogre::PkgFileInfo *>
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+16], eax

; 1240 : 
; 1241 :  #if _HAS_ITERATOR_DEBUGGING
; 1242 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1243 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1244 : 
; 1245 : 			_STDEXT _Unchecked_move_backward(_VEC_ITER_BASE(_Where), _Oldend - _Count,
; 1246 : 				_Oldend);	// copy hole

	mov	eax, DWORD PTR __Oldend$120094[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	imul	ecx, 24					; 00000018H
	mov	edx, DWORD PTR __Oldend$120094[ebp]
	sub	edx, ecx
	push	edx
	mov	eax, DWORD PTR __Where$[ebp+4]
	push	eax
	call	??$_Unchecked_move_backward@PAUPkgFileInfo@Ogre@@PAU12@@stdext@@YAPAUPkgFileInfo@Ogre@@PAU12@00@Z ; stdext::_Unchecked_move_backward<Ogre::PkgFileInfo *,Ogre::PkgFileInfo *>
	add	esp, 12					; 0000000cH

; 1247 : 			std::fill(_VEC_ITER_BASE(_Where), _VEC_ITER_BASE(_Where) + _Count,
; 1248 : 				_Tmp);	// insert into hole

	lea	ecx, DWORD PTR __Tmp$120093[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count$[ebp]
	imul	edx, 24					; 00000018H
	add	edx, DWORD PTR __Where$[ebp+4]
	push	edx
	mov	eax, DWORD PTR __Where$[ebp+4]
	push	eax
	call	??$fill@PAUPkgFileInfo@Ogre@@U12@@std@@YAXPAUPkgFileInfo@Ogre@@0ABU12@@Z ; std::fill<Ogre::PkgFileInfo *,Ogre::PkgFileInfo>
	add	esp, 12					; 0000000cH
$LN16@Insert_n:

; 1249 : 			}
; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Insert_n@?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@2@IABUPkgFileInfo@Ogre@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-96]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Insert_n@?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@2@IABUPkgFileInfo@Ogre@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Insert_n@?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@2@IABUPkgFileInfo@Ogre@@@Z ENDP ; std::vector<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::_Insert_n
PUBLIC	__TI3?AVlength_error@std@@
PUBLIC	??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::length_error::length_error
PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	??1length_error@std@@UAE@XZ			; std::length_error::~length_error
PUBLIC	__CTA3?AVlength_error@std@@
PUBLIC	__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
PUBLIC	??_R0?AVlength_error@std@@@8			; std::length_error `RTTI Type Descriptor'
PUBLIC	??0length_error@std@@QAE@ABV01@@Z		; std::length_error::length_error
PUBLIC	__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
PUBLIC	??_R0?AVlogic_error@std@@@8			; std::logic_error `RTTI Type Descriptor'
PUBLIC	??0logic_error@std@@QAE@ABV01@@Z		; std::logic_error::logic_error
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z:PROC
EXTRN	??0exception@std@@QAE@ABV01@@Z:PROC		; std::exception::exception
;	COMDAT ??_R0?AVexception@std@@@8
_DATA	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVlogic_error@std@@@8
_DATA	SEGMENT
??_R0?AVlogic_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::logic_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlogic_error@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0logic_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVlength_error@std@@@8
_DATA	SEGMENT
??_R0?AVlength_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::length_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlength_error@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlength_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0length_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA3?AVlength_error@std@@
xdata$x	SEGMENT
__CTA3?AVlength_error@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVlength_error@std@@
xdata$x	SEGMENT
__TI3?AVlength_error@std@@ DD 00H
	DD	FLAT:??1length_error@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVlength_error@std@@
xdata$x	ENDS
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ DB 'vector<T> too long'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@KAXXZ$0
__ehfuncinfo$?_Xlen@?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@KAXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T124479 = -80						; size = 28
$T124478 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@KAXXZ PROC ; std::vector<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Xlen@?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T124479[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR $T124479[ebp]
	push	eax
	lea	ecx, DWORD PTR $T124478[ebp]
	call	??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::length_error::length_error
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T124478[ebp]
	push	ecx
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T124479[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN2@Xlen:

; 1261 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T124479[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?_Xlen@?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@KAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@KAXXZ ENDP ; std::vector<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::_Xlen
PUBLIC	??1logic_error@std@@UAE@XZ			; std::logic_error::~logic_error
PUBLIC	??_7length_error@std@@6B@			; std::length_error::`vftable'
PUBLIC	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
PUBLIC	??_R4length_error@std@@6B@			; std::length_error::`RTTI Complete Object Locator'
PUBLIC	??_R3length_error@std@@8			; std::length_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2length_error@std@@8			; std::length_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@length_error@std@@8		; std::length_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@logic_error@std@@8		; std::logic_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3logic_error@std@@8				; std::logic_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2logic_error@std@@8				; std::logic_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
PUBLIC	?what@logic_error@std@@UBEPBDXZ			; std::logic_error::what
EXTRN	??_Elength_error@std@@UAEPAXI@Z:PROC		; std::length_error::`vector deleting destructor'
;	COMDAT ??_R2exception@std@@8
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R2logic_error@std@@8
rdata$r	SEGMENT
??_R2logic_error@std@@8 DD FLAT:??_R1A@?0A@EA@logic_error@std@@8 ; std::logic_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3logic_error@std@@8
rdata$r	SEGMENT
??_R3logic_error@std@@8 DD 00H				; std::logic_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@logic_error@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@logic_error@std@@8 DD FLAT:??_R0?AVlogic_error@std@@@8 ; std::logic_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@length_error@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@length_error@std@@8 DD FLAT:??_R0?AVlength_error@std@@@8 ; std::length_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2length_error@std@@8
rdata$r	SEGMENT
??_R2length_error@std@@8 DD FLAT:??_R1A@?0A@EA@length_error@std@@8 ; std::length_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@logic_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3length_error@std@@8
rdata$r	SEGMENT
??_R3length_error@std@@8 DD 00H				; std::length_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R4length_error@std@@6B@
rdata$r	SEGMENT
??_R4length_error@std@@6B@ DD 00H			; std::length_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVlength_error@std@@@8
	DD	FLAT:??_R3length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_7length_error@std@@6B@
CONST	SEGMENT
??_7length_error@std@@6B@ DD FLAT:??_R4length_error@std@@6B@ ; std::length_error::`vftable'
	DD	FLAT:??_Elength_error@std@@UAEPAXI@Z
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0
__ehfuncinfo$??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Message$ = 8						; size = 4
??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::length_error::length_error, COMDAT
; _this$ = ecx

; 105  : 		{	// construct from message string

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Message$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7length_error@std@@6B@

; 106  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1logic_error@std@@UAE@XZ		; std::logic_error::~logic_error
__ehhandler$??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::length_error::length_error
PUBLIC	??_7logic_error@std@@6B@			; std::logic_error::`vftable'
PUBLIC	??_R4logic_error@std@@6B@			; std::logic_error::`RTTI Complete Object Locator'
EXTRN	__imp_??1exception@std@@UAE@XZ:PROC
EXTRN	__imp_??0exception@std@@QAE@XZ:PROC
EXTRN	??_Elogic_error@std@@UAEPAXI@Z:PROC		; std::logic_error::`vector deleting destructor'
;	COMDAT ??_R4logic_error@std@@6B@
rdata$r	SEGMENT
??_R4logic_error@std@@6B@ DD 00H			; std::logic_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	FLAT:??_R3logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_7logic_error@std@@6B@
CONST	SEGMENT
??_7logic_error@std@@6B@ DD FLAT:??_R4logic_error@std@@6B@ ; std::logic_error::`vftable'
	DD	FLAT:??_Elogic_error@std@@UAEPAXI@Z
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$1
__ehfuncinfo$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Message$ = 8						; size = 4
??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::logic_error::logic_error, COMDAT
; _this$ = ecx

; 26   : 		{	// construct from message string

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7logic_error@std@@6B@
	mov	ecx, DWORD PTR __Message$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 27   : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__unwindfunclet$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::logic_error::logic_error
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1logic_error@std@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1logic_error@std@@UAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1logic_error@std@@UAE@XZ$1
__ehfuncinfo$??1logic_error@std@@UAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??1logic_error@std@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1logic_error@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1logic_error@std@@UAE@XZ PROC				; std::logic_error::~logic_error, COMDAT
; _this$ = ecx

; 30   : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1logic_error@std@@UAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7logic_error@std@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 31   : 		}

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1logic_error@std@@UAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__unwindfunclet$??1logic_error@std@@UAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$??1logic_error@std@@UAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1logic_error@std@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1logic_error@std@@UAE@XZ ENDP				; std::logic_error::~logic_error
; Function compile flags: /Odtp
;	COMDAT ?what@logic_error@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?what@logic_error@std@@UBEPBDXZ PROC			; std::logic_error::what, COMDAT
; _this$ = ecx

; 34   : 		{	// return pointer to message string

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 35   : 		return (_Str.c_str());

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ

; 36   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?what@logic_error@std@@UBEPBDXZ ENDP			; std::logic_error::what
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_Glogic_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Glogic_error@std@@UAEPAXI@Z PROC			; std::logic_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1logic_error@std@@UAE@XZ		; std::logic_error::~logic_error
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@9
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@9:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Glogic_error@std@@UAEPAXI@Z ENDP			; std::logic_error::`scalar deleting destructor'
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1length_error@std@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1length_error@std@@UAE@XZ$0
__ehfuncinfo$??1length_error@std@@UAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1length_error@std@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1length_error@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1length_error@std@@UAE@XZ PROC			; std::length_error::~length_error, COMDAT
; _this$ = ecx

; 109  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1length_error@std@@UAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7length_error@std@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 110  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1logic_error@std@@UAE@XZ		; std::logic_error::~logic_error
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1length_error@std@@UAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1logic_error@std@@UAE@XZ		; std::logic_error::~logic_error
__ehhandler$??1length_error@std@@UAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1length_error@std@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1length_error@std@@UAE@XZ ENDP			; std::length_error::~length_error
; Function compile flags: /Odtp
;	COMDAT ??_Glength_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Glength_error@std@@UAEPAXI@Z PROC			; std::length_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1length_error@std@@UAE@XZ		; std::length_error::~length_error
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@10
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@10:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Glength_error@std@@UAEPAXI@Z ENDP			; std::length_error::`scalar deleting destructor'
_TEXT	ENDS
EXTRN	__imp_??0exception@std@@QAE@ABV01@@Z:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0logic_error@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$1
__ehfuncinfo$??0logic_error@std@@QAE@ABV01@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0logic_error@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0logic_error@std@@QAE@ABV01@@Z PROC			; std::logic_error::logic_error, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0logic_error@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7logic_error@std@@6B@
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 12					; 0000000cH
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$??0logic_error@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0logic_error@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0logic_error@std@@QAE@ABV01@@Z ENDP			; std::logic_error::logic_error
PUBLIC	??3@YAXPAX0@Z					; operator delete
PUBLIC	??0_Aux_cont@std@@QAE@QBV_Container_base_aux@1@@Z ; std::_Aux_cont::_Aux_cont
PUBLIC	??2@YAPAXIPAX@Z					; operator new
PUBLIC	?allocate@?$allocator@V_Aux_cont@std@@@std@@QAEPAV_Aux_cont@2@I@Z ; std::allocator<std::_Aux_cont>::allocate
PUBLIC	??$?0UPkgFileInfo@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@UPkgFileInfo@Ogre@@@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::PkgFileInfo>
PUBLIC	??0_Container_base_aux@std@@QAE@XZ		; std::_Container_base_aux::_Container_base_aux
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??0?$_Container_base_aux_alloc_real@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@IAE@V?$allocator@UPkgFileInfo@Ogre@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@IAE@V?$allocator@UPkgFileInfo@Ogre@@@1@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@IAE@V?$allocator@UPkgFileInfo@Ogre@@@1@@Z$1
__ehfuncinfo$??0?$_Container_base_aux_alloc_real@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@IAE@V?$allocator@UPkgFileInfo@Ogre@@@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0?$_Container_base_aux_alloc_real@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@IAE@V?$allocator@UPkgFileInfo@Ogre@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Container_base_aux_alloc_real@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@IAE@V?$allocator@UPkgFileInfo@Ogre@@@1@@Z
_TEXT	SEGMENT
tv133 = -32						; size = 4
_this$ = -28						; size = 4
$T124545 = -24						; size = 4
$T124544 = -20						; size = 4
$T124543 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 1
??0?$_Container_base_aux_alloc_real@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@IAE@V?$allocator@UPkgFileInfo@Ogre@@@1@@Z PROC ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::PkgFileInfo> >::_Container_base_aux_alloc_real<std::allocator<Ogre::PkgFileInfo> >, COMDAT
; _this$ = ecx

; 419  : 		{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Container_base_aux_alloc_real@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@IAE@V?$allocator@UPkgFileInfo@Ogre@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 20					; 00000014H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::_Container_base_aux
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??$?0UPkgFileInfo@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@UPkgFileInfo@Ogre@@@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::PkgFileInfo>

; 420  : 		_Myownedaux = new (_Alaux.allocate(1)) _Aux_cont(this);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?allocate@?$allocator@V_Aux_cont@std@@@std@@QAEPAV_Aux_cont@2@I@Z ; std::allocator<std::_Aux_cont>::allocate
	mov	DWORD PTR $T124545[ebp], eax
	mov	ecx, DWORD PTR $T124545[ebp]
	push	ecx
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T124544[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	cmp	DWORD PTR $T124544[ebp], 0
	je	SHORT $LN3@Container_
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T124544[ebp]
	call	??0_Aux_cont@std@@QAE@QBV_Container_base_aux@1@@Z ; std::_Aux_cont::_Aux_cont
	mov	DWORD PTR tv133[ebp], eax
	jmp	SHORT $LN4@Container_
$LN3@Container_:
	mov	DWORD PTR tv133[ebp], 0
$LN4@Container_:
	mov	eax, DWORD PTR tv133[ebp]
	mov	DWORD PTR $T124543[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T124543[ebp]
	mov	DWORD PTR [ecx], edx

; 421  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@IAE@V?$allocator@UPkgFileInfo@Ogre@@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@IAE@V?$allocator@UPkgFileInfo@Ogre@@@1@@Z$1:
	mov	eax, DWORD PTR $T124545[ebp]
	push	eax
	mov	ecx, DWORD PTR $T124544[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??0?$_Container_base_aux_alloc_real@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@IAE@V?$allocator@UPkgFileInfo@Ogre@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Container_base_aux_alloc_real@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@IAE@V?$allocator@UPkgFileInfo@Ogre@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Container_base_aux_alloc_real@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@IAE@V?$allocator@UPkgFileInfo@Ogre@@@1@@Z ENDP ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::PkgFileInfo> >::_Container_base_aux_alloc_real<std::allocator<Ogre::PkgFileInfo> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\new
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 58   : 	{	// construct array with placement at _Where

	push	ebp
	mov	ebp, esp

; 59   : 	return (_Where);

	mov	eax, DWORD PTR __Where$[ebp]

; 60   : 	}

	pop	ebp
	ret	0
??2@YAPAXIPAX@Z ENDP					; operator new
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??3@YAXPAX0@Z PROC					; operator delete, COMDAT

; 63   : 	{	// delete if placement new fails

	push	ebp
	mov	ebp, esp

; 64   : 	}

	pop	ebp
	ret	0
??3@YAXPAX0@Z ENDP					; operator delete
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??0_Aux_cont@std@@QAE@QBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pcont$ = 8						; size = 4
??0_Aux_cont@std@@QAE@QBV_Container_base_aux@1@@Z PROC	; std::_Aux_cont::_Aux_cont, COMDAT
; _this$ = ecx

; 364  : 	explicit _Aux_cont(const _Container_base_aux * const _Pcont)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Pcont$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0_Aux_cont@std@@QAE@QBV_Container_base_aux@1@@Z ENDP	; std::_Aux_cont::_Aux_cont
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0_Container_base_aux@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_Container_base_aux@std@@QAE@XZ PROC			; std::_Container_base_aux::_Container_base_aux, COMDAT
; _this$ = ecx

; 379  : 	_Container_base_aux()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 380  : 		{
; 381  : 		// Do nothing: _Container_base_aux_alloc_real() will construct the aux object.
; 382  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0_Container_base_aux@std@@QAE@XZ ENDP			; std::_Container_base_aux::_Container_base_aux
_TEXT	ENDS
PUBLIC	??$_Allocate@UPkgFileInfo@Ogre@@@std@@YAPAUPkgFileInfo@Ogre@@IPAU12@@Z ; std::_Allocate<Ogre::PkgFileInfo>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@UPkgFileInfo@Ogre@@@std@@QAEPAUPkgFileInfo@Ogre@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@UPkgFileInfo@Ogre@@@std@@QAEPAUPkgFileInfo@Ogre@@I@Z PROC ; std::allocator<Ogre::PkgFileInfo>::allocate, COMDAT
; _this$ = ecx

; 144  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@UPkgFileInfo@Ogre@@@std@@YAPAUPkgFileInfo@Ogre@@IPAU12@@Z ; std::_Allocate<Ogre::PkgFileInfo>
	add	esp, 8

; 146  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@UPkgFileInfo@Ogre@@@std@@QAEPAUPkgFileInfo@Ogre@@I@Z ENDP ; std::allocator<Ogre::PkgFileInfo>::allocate
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@V_Aux_cont@std@@@std@@QAEXPAV_Aux_cont@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@V_Aux_cont@std@@@std@@QAEXPAV_Aux_cont@2@I@Z PROC ; std::allocator<std::_Aux_cont>::deallocate, COMDAT
; _this$ = ecx

; 139  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 141  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@V_Aux_cont@std@@@std@@QAEXPAV_Aux_cont@2@I@Z ENDP ; std::allocator<std::_Aux_cont>::deallocate
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?_Make_iter@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 8
?_Make_iter@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@2@@Z PROC ; std::vector<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::_Make_iter, COMDAT
; _this$ = ecx

; 660  : 		{	// make iterator from const_iterator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 661  : 		return (iterator(_Where._Myptr, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp+4]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QAE@PAPAVPackageDataStreamObject@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::_Vector_iterator<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 662  : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?_Make_iter@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@2@@Z ENDP ; std::vector<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::_Make_iter
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@QBEIXZ ; std::allocator<Ogre::PackageDataStreamObject *>::max_size
; Function compile flags: /Odtp
;	COMDAT ?max_size@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QBEIXZ PROC ; std::vector<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::max_size, COMDAT
; _this$ = ecx

; 730  : 		{	// return maximum possible length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 731  : 		return (this->_Alval.max_size());

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?max_size@?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@QBEIXZ ; std::allocator<Ogre::PackageDataStreamObject *>::max_size

; 732  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QBEIXZ ENDP ; std::vector<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::max_size
_TEXT	ENDS
PUBLIC	??$_Unchecked_move_backward@PAPAVPackageDataStreamObject@Ogre@@PAPAV12@@stdext@@YAPAPAVPackageDataStreamObject@Ogre@@PAPAV12@00@Z ; stdext::_Unchecked_move_backward<Ogre::PackageDataStreamObject * *,Ogre::PackageDataStreamObject * *>
PUBLIC	??$fill@PAPAVPackageDataStreamObject@Ogre@@PAV12@@std@@YAXPAPAVPackageDataStreamObject@Ogre@@0ABQAV12@@Z ; std::fill<Ogre::PackageDataStreamObject * *,Ogre::PackageDataStreamObject *>
PUBLIC	??$_Umove@PAPAVPackageDataStreamObject@Ogre@@@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@IAEPAPAVPackageDataStreamObject@Ogre@@PAPAV23@00@Z ; std::vector<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::_Umove<Ogre::PackageDataStreamObject * *>
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Insert_n@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@2@IABQAVPackageDataStreamObject@Ogre@@@Z$5 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@2@IABQAVPackageDataStreamObject@Ogre@@@Z$2
__catchsym$?_Insert_n@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@2@IABQAVPackageDataStreamObject@Ogre@@@Z$4 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@2@IABQAVPackageDataStreamObject@Ogre@@@Z$0
__unwindtable$?_Insert_n@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@2@IABQAVPackageDataStreamObject@Ogre@@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$?_Insert_n@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@2@IABQAVPackageDataStreamObject@Ogre@@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Insert_n@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@2@IABQAVPackageDataStreamObject@Ogre@@@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Insert_n@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@2@IABQAVPackageDataStreamObject@Ogre@@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__tryblocktable$?_Insert_n@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@2@IABQAVPackageDataStreamObject@Ogre@@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@2@IABQAVPackageDataStreamObject@Ogre@@@Z$4
	DD	02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@2@IABQAVPackageDataStreamObject@Ogre@@@Z$5
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?_Insert_n@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@2@IABQAVPackageDataStreamObject@Ogre@@@Z
_TEXT	SEGMENT
tv84 = -52						; size = 4
_this$ = -48						; size = 4
__Tmp$120174 = -44					; size = 4
__Oldend$120175 = -40					; size = 4
__Tmp$120164 = -36					; size = 4
__Ncopied$120151 = -32					; size = 4
__Newvec$120149 = -28					; size = 4
__Whereoff$120150 = -24					; size = 4
__Capacity$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Where$ = 8						; size = 8
__Count$ = 16						; size = 4
__Val$ = 20						; size = 4
?_Insert_n@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@2@IABQAVPackageDataStreamObject@Ogre@@@Z PROC ; std::vector<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::_Insert_n, COMDAT
; _this$ = ecx

; 1153 : 		{	// insert _Count * _Val at _Where

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Insert_n@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@2@IABQAVPackageDataStreamObject@Ogre@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 36					; 00000024H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1154 : 
; 1155 :  #if _HAS_ITERATOR_DEBUGGING
; 1156 : 		if (_Where._Mycont != this
; 1157 : 			|| _Where._Myptr < _Myfirst || _Mylast < _Where._Myptr)
; 1158 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1159 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1160 : 
; 1161 : 		size_type _Capacity = capacity();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?capacity@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::capacity
	mov	DWORD PTR __Capacity$[ebp], eax

; 1162 : 
; 1163 : 		if (_Count == 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN14@Insert_n@2
	jmp	$LN16@Insert_n@2
$LN14@Insert_n@2:

; 1164 : 			;
; 1165 : 		else if (max_size() - size() < _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::max_size
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::size
	sub	esi, eax
	cmp	esi, DWORD PTR __Count$[ebp]
	jae	SHORT $LN12@Insert_n@2

; 1166 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@KAXXZ ; std::vector<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::_Xlen
	jmp	$LN16@Insert_n@2
$LN12@Insert_n@2:

; 1167 : 		else if (_Capacity < size() + _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::size
	add	eax, DWORD PTR __Count$[ebp]
	cmp	DWORD PTR __Capacity$[ebp], eax
	jae	$LN10@Insert_n@2

; 1168 : 			{	// not enough room, reallocate
; 1169 : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1170 : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::max_size
	mov	ecx, DWORD PTR __Capacity$[ebp]
	shr	ecx, 1
	sub	eax, ecx
	cmp	eax, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN17@Insert_n@2
	mov	DWORD PTR tv84[ebp], 0
	jmp	SHORT $LN18@Insert_n@2
$LN17@Insert_n@2:
	mov	edx, DWORD PTR __Capacity$[ebp]
	shr	edx, 1
	add	edx, DWORD PTR __Capacity$[ebp]
	mov	DWORD PTR tv84[ebp], edx
$LN18@Insert_n@2:
	mov	eax, DWORD PTR tv84[ebp]
	mov	DWORD PTR __Capacity$[ebp], eax

; 1171 : 			if (_Capacity < size() + _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::size
	add	eax, DWORD PTR __Count$[ebp]
	cmp	DWORD PTR __Capacity$[ebp], eax
	jae	SHORT $LN9@Insert_n@2

; 1172 : 				_Capacity = size() + _Count;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::size
	add	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Capacity$[ebp], eax
$LN9@Insert_n@2:

; 1173 : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

	mov	ecx, DWORD PTR __Capacity$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?allocate@?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@QAEPAPAVPackageDataStreamObject@Ogre@@I@Z ; std::allocator<Ogre::PackageDataStreamObject *>::allocate
	mov	DWORD PTR __Newvec$120149[ebp], eax

; 1174 : 			size_type _Whereoff = _VEC_ITER_BASE(_Where) - _Myfirst;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Where$[ebp+4]
	sub	eax, DWORD PTR [edx+12]
	sar	eax, 2
	mov	DWORD PTR __Whereoff$120150[ebp], eax

; 1175 : 			int _Ncopied = 0;

	mov	DWORD PTR __Ncopied$120151[ebp], 0

; 1176 : 
; 1177 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1178 : 			_Ufill(_Newvec + _Whereoff, _Count, _Val);	// add new stuff

	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __Whereoff$120150[ebp]
	mov	ecx, DWORD PTR __Newvec$120149[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Ufill@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@IAEPAPAVPackageDataStreamObject@Ogre@@PAPAV34@IABQAV34@@Z ; std::vector<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::_Ufill

; 1179 : 			++_Ncopied;

	mov	eax, DWORD PTR __Ncopied$120151[ebp]
	add	eax, 1
	mov	DWORD PTR __Ncopied$120151[ebp], eax

; 1180 : 			_Umove(this->_Myfirst, _VEC_ITER_BASE(_Where),
; 1181 : 				_Newvec);	// move prefix

	mov	ecx, DWORD PTR __Newvec$120149[ebp]
	push	ecx
	mov	edx, DWORD PTR __Where$[ebp+4]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Umove@PAPAVPackageDataStreamObject@Ogre@@@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@IAEPAPAVPackageDataStreamObject@Ogre@@PAPAV23@00@Z ; std::vector<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::_Umove<Ogre::PackageDataStreamObject * *>

; 1182 : 			++_Ncopied;

	mov	edx, DWORD PTR __Ncopied$120151[ebp]
	add	edx, 1
	mov	DWORD PTR __Ncopied$120151[ebp], edx

; 1183 : 			_Umove(_VEC_ITER_BASE(_Where), this->_Mylast,
; 1184 : 				_Newvec + (_Whereoff + _Count));	// move suffix

	mov	eax, DWORD PTR __Whereoff$120150[ebp]
	add	eax, DWORD PTR __Count$[ebp]
	mov	ecx, DWORD PTR __Newvec$120149[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Where$[ebp+4]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Umove@PAPAVPackageDataStreamObject@Ogre@@@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@IAEPAPAVPackageDataStreamObject@Ogre@@PAPAV23@00@Z ; std::vector<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::_Umove<Ogre::PackageDataStreamObject * *>
	jmp	SHORT $LN19@Insert_n@2
__catch$?_Insert_n@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@2@IABQAVPackageDataStreamObject@Ogre@@@Z$0:

; 1185 : 			_CATCH_ALL
; 1186 : 			if (1 < _Ncopied)

	cmp	DWORD PTR __Ncopied$120151[ebp], 1
	jle	SHORT $LN7@Insert_n@2

; 1187 : 				_Destroy(_Newvec, _Newvec + _Whereoff);

	mov	eax, DWORD PTR __Whereoff$120150[ebp]
	mov	ecx, DWORD PTR __Newvec$120149[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	push	edx
	mov	eax, DWORD PTR __Newvec$120149[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@IAEXPAPAVPackageDataStreamObject@Ogre@@0@Z ; std::vector<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::_Destroy
$LN7@Insert_n@2:

; 1188 : 			if (0 < _Ncopied)

	cmp	DWORD PTR __Ncopied$120151[ebp], 0
	jle	SHORT $LN6@Insert_n@2

; 1189 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);

	mov	ecx, DWORD PTR __Whereoff$120150[ebp]
	mov	edx, DWORD PTR __Newvec$120149[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR __Count$[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]
	push	edx
	mov	eax, DWORD PTR __Whereoff$120150[ebp]
	mov	ecx, DWORD PTR __Newvec$120149[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@IAEXPAPAVPackageDataStreamObject@Ogre@@0@Z ; std::vector<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::_Destroy
$LN6@Insert_n@2:

; 1190 : 			this->_Alval.deallocate(_Newvec, _Capacity);

	mov	eax, DWORD PTR __Capacity$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Newvec$120149[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?deallocate@?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@QAEXPAPAVPackageDataStreamObject@Ogre@@I@Z ; std::allocator<Ogre::PackageDataStreamObject *>::deallocate

; 1191 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1192 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$?_Insert_n@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@2@IABQAVPackageDataStreamObject@Ogre@@@Z$1
	ret	0
$LN19@Insert_n@2:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Insert_n@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@2@IABQAVPackageDataStreamObject@Ogre@@@Z$1:

; 1193 : 
; 1194 : 			_Count += size();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::size
	add	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Count$[ebp], eax

; 1195 : 			if (_Myfirst != 0)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+12], 0
	je	SHORT $LN5@Insert_n@2

; 1196 : 				{	// destroy and deallocate old array
; 1197 : 				_Destroy(_Myfirst, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@IAEXPAPAVPackageDataStreamObject@Ogre@@0@Z ; std::vector<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::_Destroy

; 1198 : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+20]
	sub	eax, DWORD PTR [edx+12]
	sar	eax, 2
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?deallocate@?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@QAEXPAPAVPackageDataStreamObject@Ogre@@I@Z ; std::allocator<Ogre::PackageDataStreamObject *>::deallocate
$LN5@Insert_n@2:

; 1199 : 				}
; 1200 : 
; 1201 :  #if _HAS_ITERATOR_DEBUGGING
; 1202 : 			this->_Orphan_all();
; 1203 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1204 : 
; 1205 : 			_Myend = _Newvec + _Capacity;

	mov	eax, DWORD PTR __Capacity$[ebp]
	mov	ecx, DWORD PTR __Newvec$120149[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], edx

; 1206 : 			_Mylast = _Newvec + _Count;

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Newvec$120149[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 1207 : 			_Myfirst = _Newvec;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Newvec$120149[ebp]
	mov	DWORD PTR [edx+12], eax
	jmp	$LN16@Insert_n@2
$LN10@Insert_n@2:

; 1208 : 			}
; 1209 : 		else if ((size_type)(_Mylast - _VEC_ITER_BASE(_Where)) < _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	sub	edx, DWORD PTR __Where$[ebp+4]
	sar	edx, 2
	cmp	edx, DWORD PTR __Count$[ebp]
	jae	$LN3@Insert_n@2

; 1210 : 			{	// new stuff spills off end
; 1211 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Tmp$120164[ebp], ecx

; 1212 : 
; 1213 : 			_Umove(_VEC_ITER_BASE(_Where), _Mylast,
; 1214 : 				_VEC_ITER_BASE(_Where) + _Count);	// copy suffix

	mov	edx, DWORD PTR __Count$[ebp]
	mov	eax, DWORD PTR __Where$[ebp+4]
	lea	ecx, DWORD PTR [eax+edx*4]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp+4]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Umove@PAPAVPackageDataStreamObject@Ogre@@@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@IAEPAPAVPackageDataStreamObject@Ogre@@PAPAV23@00@Z ; std::vector<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::_Umove<Ogre::PackageDataStreamObject * *>

; 1215 : 
; 1216 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 2

; 1217 : 			_Ufill(_Mylast, _Count - (_Mylast - _VEC_ITER_BASE(_Where)),
; 1218 : 				_Tmp);	// insert new stuff off end

	lea	edx, DWORD PTR __Tmp$120164[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	sub	ecx, DWORD PTR __Where$[ebp+4]
	sar	ecx, 2
	mov	edx, DWORD PTR __Count$[ebp]
	sub	edx, ecx
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Ufill@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@IAEPAPAVPackageDataStreamObject@Ogre@@PAPAV34@IABQAV34@@Z ; std::vector<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::_Ufill
	jmp	SHORT $LN21@Insert_n@2
__catch$?_Insert_n@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@2@IABQAVPackageDataStreamObject@Ogre@@@Z$2:

; 1219 : 			_CATCH_ALL
; 1220 : 			_Destroy(_VEC_ITER_BASE(_Where) + _Count, _Mylast + _Count);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR __Count$[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	mov	ecx, DWORD PTR __Where$[ebp+4]
	lea	edx, DWORD PTR [ecx+eax*4]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@IAEXPAPAVPackageDataStreamObject@Ogre@@0@Z ; std::vector<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::_Destroy

; 1221 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1222 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$?_Insert_n@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@2@IABQAVPackageDataStreamObject@Ogre@@@Z$3
	ret	0
$LN21@Insert_n@2:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Insert_n@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@2@IABQAVPackageDataStreamObject@Ogre@@@Z$3:

; 1223 : 
; 1224 : 			_Mylast += _Count;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR __Count$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 1225 : 
; 1226 :  #if _HAS_ITERATOR_DEBUGGING
; 1227 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1228 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1229 : 
; 1230 : 			std::fill(_VEC_ITER_BASE(_Where), _Mylast - _Count,
; 1231 : 				_Tmp);	// insert up to old end

	lea	edx, DWORD PTR __Tmp$120164[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 2
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	sub	edx, eax
	push	edx
	mov	eax, DWORD PTR __Where$[ebp+4]
	push	eax
	call	??$fill@PAPAVPackageDataStreamObject@Ogre@@PAV12@@std@@YAXPAPAVPackageDataStreamObject@Ogre@@0ABQAV12@@Z ; std::fill<Ogre::PackageDataStreamObject * *,Ogre::PackageDataStreamObject *>
	add	esp, 12					; 0000000cH

; 1232 : 			}
; 1233 : 		else

	jmp	SHORT $LN16@Insert_n@2
$LN3@Insert_n@2:

; 1234 : 			{	// new stuff can all be assigned
; 1235 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	ecx, DWORD PTR __Val$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR __Tmp$120174[ebp], edx

; 1236 : 
; 1237 : 			pointer _Oldend = _Mylast;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR __Oldend$120175[ebp], ecx

; 1238 : 			_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1239 : 				_Mylast);	// copy suffix

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR __Oldend$120175[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count$[ebp]
	shl	edx, 2
	mov	eax, DWORD PTR __Oldend$120175[ebp]
	sub	eax, edx
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Umove@PAPAVPackageDataStreamObject@Ogre@@@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@IAEPAPAVPackageDataStreamObject@Ogre@@PAPAV23@00@Z ; std::vector<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::_Umove<Ogre::PackageDataStreamObject * *>
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 1240 : 
; 1241 :  #if _HAS_ITERATOR_DEBUGGING
; 1242 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1243 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1244 : 
; 1245 : 			_STDEXT _Unchecked_move_backward(_VEC_ITER_BASE(_Where), _Oldend - _Count,
; 1246 : 				_Oldend);	// copy hole

	mov	edx, DWORD PTR __Oldend$120175[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 2
	mov	ecx, DWORD PTR __Oldend$120175[ebp]
	sub	ecx, eax
	push	ecx
	mov	edx, DWORD PTR __Where$[ebp+4]
	push	edx
	call	??$_Unchecked_move_backward@PAPAVPackageDataStreamObject@Ogre@@PAPAV12@@stdext@@YAPAPAVPackageDataStreamObject@Ogre@@PAPAV12@00@Z ; stdext::_Unchecked_move_backward<Ogre::PackageDataStreamObject * *,Ogre::PackageDataStreamObject * *>
	add	esp, 12					; 0000000cH

; 1247 : 			std::fill(_VEC_ITER_BASE(_Where), _VEC_ITER_BASE(_Where) + _Count,
; 1248 : 				_Tmp);	// insert into hole

	lea	eax, DWORD PTR __Tmp$120174[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Where$[ebp+4]
	lea	eax, DWORD PTR [edx+ecx*4]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp+4]
	push	ecx
	call	??$fill@PAPAVPackageDataStreamObject@Ogre@@PAV12@@std@@YAXPAPAVPackageDataStreamObject@Ogre@@0ABQAV12@@Z ; std::fill<Ogre::PackageDataStreamObject * *,Ogre::PackageDataStreamObject *>
	add	esp, 12					; 0000000cH
$LN16@Insert_n@2:

; 1249 : 			}
; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Insert_n@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@2@IABQAVPackageDataStreamObject@Ogre@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-56]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Insert_n@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@2@IABQAVPackageDataStreamObject@Ogre@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Insert_n@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@2@IABQAVPackageDataStreamObject@Ogre@@@Z ENDP ; std::vector<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::_Insert_n
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@KAXXZ$0
__ehfuncinfo$?_Xlen@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@KAXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T124598 = -80						; size = 28
$T124597 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@KAXXZ PROC ; std::vector<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Xlen@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T124598[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR $T124598[ebp]
	push	eax
	lea	ecx, DWORD PTR $T124597[ebp]
	call	??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::length_error::length_error
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T124597[ebp]
	push	ecx
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T124598[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN2@Xlen@2:

; 1261 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T124598[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?_Xlen@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@KAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@KAXXZ ENDP ; std::vector<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::_Xlen
PUBLIC	??$?0PAVPackageDataStreamObject@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@PAVPackageDataStreamObject@Ogre@@@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::PackageDataStreamObject *>
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@IAE@V?$allocator@PAVPackageDataStreamObject@Ogre@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@IAE@V?$allocator@PAVPackageDataStreamObject@Ogre@@@1@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@IAE@V?$allocator@PAVPackageDataStreamObject@Ogre@@@1@@Z$1
__ehfuncinfo$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@IAE@V?$allocator@PAVPackageDataStreamObject@Ogre@@@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@IAE@V?$allocator@PAVPackageDataStreamObject@Ogre@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Container_base_aux_alloc_real@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@IAE@V?$allocator@PAVPackageDataStreamObject@Ogre@@@1@@Z
_TEXT	SEGMENT
tv133 = -32						; size = 4
_this$ = -28						; size = 4
$T124610 = -24						; size = 4
$T124609 = -20						; size = 4
$T124608 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 1
??0?$_Container_base_aux_alloc_real@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@IAE@V?$allocator@PAVPackageDataStreamObject@Ogre@@@1@@Z PROC ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::PackageDataStreamObject *> >::_Container_base_aux_alloc_real<std::allocator<Ogre::PackageDataStreamObject *> >, COMDAT
; _this$ = ecx

; 419  : 		{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@IAE@V?$allocator@PAVPackageDataStreamObject@Ogre@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 20					; 00000014H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::_Container_base_aux
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??$?0PAVPackageDataStreamObject@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@PAVPackageDataStreamObject@Ogre@@@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::PackageDataStreamObject *>

; 420  : 		_Myownedaux = new (_Alaux.allocate(1)) _Aux_cont(this);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?allocate@?$allocator@V_Aux_cont@std@@@std@@QAEPAV_Aux_cont@2@I@Z ; std::allocator<std::_Aux_cont>::allocate
	mov	DWORD PTR $T124610[ebp], eax
	mov	ecx, DWORD PTR $T124610[ebp]
	push	ecx
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T124609[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	cmp	DWORD PTR $T124609[ebp], 0
	je	SHORT $LN3@Container_@2
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T124609[ebp]
	call	??0_Aux_cont@std@@QAE@QBV_Container_base_aux@1@@Z ; std::_Aux_cont::_Aux_cont
	mov	DWORD PTR tv133[ebp], eax
	jmp	SHORT $LN4@Container_@2
$LN3@Container_@2:
	mov	DWORD PTR tv133[ebp], 0
$LN4@Container_@2:
	mov	eax, DWORD PTR tv133[ebp]
	mov	DWORD PTR $T124608[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T124608[ebp]
	mov	DWORD PTR [ecx], edx

; 421  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@IAE@V?$allocator@PAVPackageDataStreamObject@Ogre@@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@IAE@V?$allocator@PAVPackageDataStreamObject@Ogre@@@1@@Z$1:
	mov	eax, DWORD PTR $T124610[ebp]
	push	eax
	mov	ecx, DWORD PTR $T124609[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@IAE@V?$allocator@PAVPackageDataStreamObject@Ogre@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@IAE@V?$allocator@PAVPackageDataStreamObject@Ogre@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Container_base_aux_alloc_real@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@IAE@V?$allocator@PAVPackageDataStreamObject@Ogre@@@1@@Z ENDP ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::PackageDataStreamObject *> >::_Container_base_aux_alloc_real<std::allocator<Ogre::PackageDataStreamObject *> >
PUBLIC	??$_Allocate@PAVPackageDataStreamObject@Ogre@@@std@@YAPAPAVPackageDataStreamObject@Ogre@@IPAPAV12@@Z ; std::_Allocate<Ogre::PackageDataStreamObject *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@QAEPAPAVPackageDataStreamObject@Ogre@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@QAEPAPAVPackageDataStreamObject@Ogre@@I@Z PROC ; std::allocator<Ogre::PackageDataStreamObject *>::allocate, COMDAT
; _this$ = ecx

; 144  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@PAVPackageDataStreamObject@Ogre@@@std@@YAPAPAVPackageDataStreamObject@Ogre@@IPAPAV12@@Z ; std::_Allocate<Ogre::PackageDataStreamObject *>
	add	esp, 8

; 146  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@QAEPAPAVPackageDataStreamObject@Ogre@@I@Z ENDP ; std::allocator<Ogre::PackageDataStreamObject *>::allocate
_TEXT	ENDS
PUBLIC	?_Set_container@_Iterator_base_aux@std@@QAEXQBV_Container_base_aux@2@@Z ; std::_Iterator_base_aux::_Set_container
PUBLIC	??0?$_Ranit@UPkgFileInfo@Ogre@@HPBU12@ABU12@@std@@QAE@XZ ; std::_Ranit<Ogre::PkgFileInfo,int,Ogre::PkgFileInfo const *,Ogre::PkgFileInfo const &>::_Ranit<Ogre::PkgFileInfo,int,Ogre::PkgFileInfo const *,Ogre::PkgFileInfo const &>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QAE@PAUPkgFileInfo@Ogre@@PBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QAE@PAUPkgFileInfo@Ogre@@PBV_Container_base_aux@1@@Z PROC ; std::_Vector_const_iterator<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::_Vector_const_iterator<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >, COMDAT
; _this$ = ecx

; 76   : 	_Vector_const_iterator(_Tptr _Ptr, const _Container_base *_Pvector)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Ranit@UPkgFileInfo@Ogre@@HPBU12@ABU12@@std@@QAE@XZ

; 77   : 		{	// construct with pointer _Ptr
; 78   : 		_SCL_SECURE_VALIDATE(_Pvector != NULL && ((_Myvec *)_Pvector)->_Myfirst <= _Ptr && _Ptr <= ((_Myvec *)_Pvector)->_Mylast);

	cmp	DWORD PTR __Pvector$[ebp], 0
	je	SHORT $LN1@Vector_con
	mov	eax, DWORD PTR __Pvector$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	cmp	ecx, DWORD PTR __Ptr$[ebp]
	ja	SHORT $LN1@Vector_con
	mov	edx, DWORD PTR __Pvector$[ebp]
	mov	eax, DWORD PTR __Ptr$[ebp]
	cmp	eax, DWORD PTR [edx+16]
	jbe	SHORT $LN2@Vector_con
$LN1@Vector_con:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@Vector_con:

; 79   : 		this->_Set_container(_Pvector);

	mov	ecx, DWORD PTR __Pvector$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Set_container@_Iterator_base_aux@std@@QAEXQBV_Container_base_aux@2@@Z ; std::_Iterator_base_aux::_Set_container

; 80   : 		_Myptr = _Ptr;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR [edx+4], eax

; 81   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Vector_const_iterator@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QAE@PAUPkgFileInfo@Ogre@@PBV_Container_base_aux@1@@Z ENDP ; std::_Vector_const_iterator<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::_Vector_const_iterator<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ?_Set_container@_Iterator_base_aux@std@@QAEXQBV_Container_base_aux@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pcont$ = 8						; size = 4
?_Set_container@_Iterator_base_aux@std@@QAEXQBV_Container_base_aux@2@@Z PROC ; std::_Iterator_base_aux::_Set_container, COMDAT
; _this$ = ecx

; 452  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 453  : 		_Myaux = _Pcont->_Myownedaux;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Pcont$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 454  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Set_container@_Iterator_base_aux@std@@QAEXQBV_Container_base_aux@2@@Z ENDP ; std::_Iterator_base_aux::_Set_container
_TEXT	ENDS
PUBLIC	??0?$_Ranit@PAVPackageDataStreamObject@Ogre@@HPBQAV12@ABQAV12@@std@@QAE@XZ ; std::_Ranit<Ogre::PackageDataStreamObject *,int,Ogre::PackageDataStreamObject * const *,Ogre::PackageDataStreamObject * const &>::_Ranit<Ogre::PackageDataStreamObject *,int,Ogre::PackageDataStreamObject * const *,Ogre::PackageDataStreamObject * const &>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QAE@PAPAVPackageDataStreamObject@Ogre@@PBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QAE@PAPAVPackageDataStreamObject@Ogre@@PBV_Container_base_aux@1@@Z PROC ; std::_Vector_const_iterator<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::_Vector_const_iterator<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >, COMDAT
; _this$ = ecx

; 76   : 	_Vector_const_iterator(_Tptr _Ptr, const _Container_base *_Pvector)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Ranit@PAVPackageDataStreamObject@Ogre@@HPBQAV12@ABQAV12@@std@@QAE@XZ

; 77   : 		{	// construct with pointer _Ptr
; 78   : 		_SCL_SECURE_VALIDATE(_Pvector != NULL && ((_Myvec *)_Pvector)->_Myfirst <= _Ptr && _Ptr <= ((_Myvec *)_Pvector)->_Mylast);

	cmp	DWORD PTR __Pvector$[ebp], 0
	je	SHORT $LN1@Vector_con@2
	mov	eax, DWORD PTR __Pvector$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	cmp	ecx, DWORD PTR __Ptr$[ebp]
	ja	SHORT $LN1@Vector_con@2
	mov	edx, DWORD PTR __Pvector$[ebp]
	mov	eax, DWORD PTR __Ptr$[ebp]
	cmp	eax, DWORD PTR [edx+16]
	jbe	SHORT $LN2@Vector_con@2
$LN1@Vector_con@2:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@Vector_con@2:

; 79   : 		this->_Set_container(_Pvector);

	mov	ecx, DWORD PTR __Pvector$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Set_container@_Iterator_base_aux@std@@QAEXQBV_Container_base_aux@2@@Z ; std::_Iterator_base_aux::_Set_container

; 80   : 		_Myptr = _Ptr;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR [edx+4], eax

; 81   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Vector_const_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QAE@PAPAVPackageDataStreamObject@Ogre@@PBV_Container_base_aux@1@@Z ENDP ; std::_Vector_const_iterator<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::_Vector_const_iterator<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >
_TEXT	ENDS
PUBLIC	?_Getmycont@_Iterator_base_aux@std@@QBEPBV_Container_base_aux@2@XZ ; std::_Iterator_base_aux::_Getmycont
PUBLIC	?_Has_container@_Iterator_base_aux@std@@QBE_NXZ	; std::_Iterator_base_aux::_Has_container
; Function compile flags: /Odtp
;	COMDAT ??D?$_Vector_const_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QBEABQAVPackageDataStreamObject@Ogre@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??D?$_Vector_const_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QBEABQAVPackageDataStreamObject@Ogre@@XZ PROC ; std::_Vector_const_iterator<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::operator*, COMDAT
; _this$ = ecx

; 91   : 		{	// return designated object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 92   : 
; 93   :  #if _HAS_ITERATOR_DEBUGGING
; 94   : 		if (this->_Mycont == 0
; 95   : 			|| _Myptr < ((_Myvec *)this->_Mycont)->_Myfirst
; 96   : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 97   : 			{
; 98   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 99   : 			_SCL_SECURE_OUT_OF_RANGE;
; 100  : 			}
; 101  :  #else
; 102  :  		_SCL_SECURE_VALIDATE(this->_Has_container());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Has_container@_Iterator_base_aux@std@@QBE_NXZ ; std::_Iterator_base_aux::_Has_container
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN2@operator@5
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@operator@5:

; 103  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getmycont@_Iterator_base_aux@std@@QBEPBV_Container_base_aux@2@XZ ; std::_Iterator_base_aux::_Getmycont
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, DWORD PTR [eax+16]
	jb	SHORT $LN1@operator@5
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN1@operator@5:

; 104  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 105  : 
; 106  : 		return (*_Myptr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 107  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??D?$_Vector_const_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QBEABQAVPackageDataStreamObject@Ogre@@XZ ENDP ; std::_Vector_const_iterator<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::operator*
_TEXT	ENDS
PUBLIC	?_Getcont@_Aux_cont@std@@QBEPBV_Container_base_aux@2@XZ ; std::_Aux_cont::_Getcont
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ?_Getmycont@_Iterator_base_aux@std@@QBEPBV_Container_base_aux@2@XZ
_TEXT	SEGMENT
tv67 = -8						; size = 4
_this$ = -4						; size = 4
?_Getmycont@_Iterator_base_aux@std@@QBEPBV_Container_base_aux@2@XZ PROC ; std::_Iterator_base_aux::_Getmycont, COMDAT
; _this$ = ecx

; 457  : 		{	// Go through the aux object to get the container

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 458  : 		return _Myaux ? _Myaux->_Getcont() : 0;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN3@Getmycont
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?_Getcont@_Aux_cont@std@@QBEPBV_Container_base_aux@2@XZ ; std::_Aux_cont::_Getcont
	mov	DWORD PTR tv67[ebp], eax
	jmp	SHORT $LN4@Getmycont
$LN3@Getmycont:
	mov	DWORD PTR tv67[ebp], 0
$LN4@Getmycont:
	mov	eax, DWORD PTR tv67[ebp]

; 459  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Getmycont@_Iterator_base_aux@std@@QBEPBV_Container_base_aux@2@XZ ENDP ; std::_Iterator_base_aux::_Getmycont
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Getcont@_Aux_cont@std@@QBEPBV_Container_base_aux@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Getcont@_Aux_cont@std@@QBEPBV_Container_base_aux@2@XZ PROC ; std::_Aux_cont::_Getcont, COMDAT
; _this$ = ecx

; 368  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 369  : 		return _Mycontainer;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 370  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Getcont@_Aux_cont@std@@QBEPBV_Container_base_aux@2@XZ ENDP ; std::_Aux_cont::_Getcont
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Has_container@_Iterator_base_aux@std@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Has_container@_Iterator_base_aux@std@@QBE_NXZ PROC	; std::_Iterator_base_aux::_Has_container, COMDAT
; _this$ = ecx

; 467  : 		{	// Accelerate the comparison by not going through the aux object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 468  : 		return _Myaux != 0;

	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	cmp	DWORD PTR [eax], 0
	setne	cl
	mov	al, cl

; 469  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Has_container@_Iterator_base_aux@std@@QBE_NXZ ENDP	; std::_Iterator_base_aux::_Has_container
_TEXT	ENDS
PUBLIC	?_Same_container@_Iterator_base_aux@std@@QBE_NABV12@@Z ; std::_Iterator_base_aux::_Same_container
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??G?$_Vector_const_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QBEHABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??G?$_Vector_const_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QBEHABV01@@Z PROC ; std::_Vector_const_iterator<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::operator-, COMDAT
; _this$ = ecx

; 186  : 		{	// return difference of iterators

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 187  : 
; 188  :  #if _HAS_ITERATOR_DEBUGGING
; 189  : 		_Compat(_Right);
; 190  :  #else
; 191  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Has_container@_Iterator_base_aux@std@@QBE_NXZ ; std::_Iterator_base_aux::_Has_container
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@operator@6
	mov	ecx, DWORD PTR __Right$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Same_container@_Iterator_base_aux@std@@QBE_NABV12@@Z ; std::_Iterator_base_aux::_Same_container
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN2@operator@6
$LN1@operator@6:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@operator@6:

; 192  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 193  : 
; 194  : 		return (_Myptr - _Right._Myptr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [eax+4]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 195  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??G?$_Vector_const_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QBEHABV01@@Z ENDP ; std::_Vector_const_iterator<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::operator-
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ?_Same_container@_Iterator_base_aux@std@@QBE_NABV12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Other$ = 8						; size = 4
?_Same_container@_Iterator_base_aux@std@@QBE_NABV12@@Z PROC ; std::_Iterator_base_aux::_Same_container, COMDAT
; _this$ = ecx

; 462  : 		{	// Accelerate the comparison by not going through the aux object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 463  : 		return _Myaux == _Other._Myaux;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Other$[ebp]
	mov	edx, DWORD PTR [eax]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx]
	sete	al

; 464  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Same_container@_Iterator_base_aux@std@@QBE_NABV12@@Z ENDP ; std::_Iterator_base_aux::_Same_container
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::operator==
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??9?$_Vector_const_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::operator!=, COMDAT
; _this$ = ecx

; 215  : 		{	// test for iterator inequality

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??8?$_Vector_const_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::operator==
	movzx	eax, al
	neg	eax
	sbb	eax, eax
	add	eax, 1

; 217  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??9?$_Vector_const_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::operator!=
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0?$_Vector_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QAE@PAPAVPackageDataStreamObject@Ogre@@PBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QAE@PAPAVPackageDataStreamObject@Ogre@@PBV_Container_base_aux@1@@Z PROC ; std::_Vector_iterator<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::_Vector_iterator<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >, COMDAT
; _this$ = ecx

; 327  : 		{	// construct with pointer _Ptr

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Pvector$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_const_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QAE@PAPAVPackageDataStreamObject@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::_Vector_const_iterator<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >

; 328  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Vector_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QAE@PAPAVPackageDataStreamObject@Ogre@@PBV_Container_base_aux@1@@Z ENDP ; std::_Vector_iterator<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::_Vector_iterator<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >
_TEXT	ENDS
PUBLIC	??Y?$_Vector_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::operator+=
; Function compile flags: /Odtp
;	COMDAT ??H?$_Vector_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
__Tmp$ = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Vector_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::operator+, COMDAT
; _this$ = ecx

; 380  : 		{	// return this + integer

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 381  : 		_Myt _Tmp = *this;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR __Tmp$[ebp], ecx
	mov	DWORD PTR __Tmp$[ebp+4], edx

; 382  : 		return (_Tmp += _Off);

	mov	eax, DWORD PTR __Off$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Tmp$[ebp]
	call	??Y?$_Vector_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::operator+=
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 383  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
??H?$_Vector_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::operator+
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??Z?$_Vector_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
??Z?$_Vector_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::operator-=, COMDAT
; _this$ = ecx

; 386  : 		{	// decrement by integer

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 387  : 		return (*this += -_Off);

	mov	eax, DWORD PTR __Off$[ebp]
	neg	eax
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??Y?$_Vector_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::operator+=

; 388  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??Z?$_Vector_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::operator-=
_TEXT	ENDS
PUBLIC	??Y?$_Vector_iterator@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::operator+=
; Function compile flags: /Odtp
;	COMDAT ??H?$_Vector_iterator@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
__Tmp$ = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Vector_iterator@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::operator+, COMDAT
; _this$ = ecx

; 380  : 		{	// return this + integer

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 381  : 		_Myt _Tmp = *this;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR __Tmp$[ebp], ecx
	mov	DWORD PTR __Tmp$[ebp+4], edx

; 382  : 		return (_Tmp += _Off);

	mov	eax, DWORD PTR __Off$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Tmp$[ebp]
	call	??Y?$_Vector_iterator@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::operator+=
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 383  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
??H?$_Vector_iterator@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::operator+
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0length_error@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0length_error@std@@QAE@ABV01@@Z$0
__ehfuncinfo$??0length_error@std@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0length_error@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0length_error@std@@QAE@ABV01@@Z PROC			; std::length_error::length_error, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0length_error@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0logic_error@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7length_error@std@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0length_error@std@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1logic_error@std@@UAE@XZ		; std::logic_error::~logic_error
__ehhandler$??0length_error@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0length_error@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0length_error@std@@QAE@ABV01@@Z ENDP			; std::length_error::length_error
PUBLIC	??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@UPkgFileInfo@Ogre@@HPBU34@ABU34@V_Iterator_base_aux@2@@std@@QAE@XZ ; std::_Iterator_with_base<std::random_access_iterator_tag,Ogre::PkgFileInfo,int,Ogre::PkgFileInfo const *,Ogre::PkgFileInfo const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,Ogre::PkgFileInfo,int,Ogre::PkgFileInfo const *,Ogre::PkgFileInfo const &,std::_Iterator_base_aux>
; Function compile flags: /Odtp
;	COMDAT ??0?$_Ranit@UPkgFileInfo@Ogre@@HPBU12@ABU12@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Ranit@UPkgFileInfo@Ogre@@HPBU12@ABU12@@std@@QAE@XZ PROC ; std::_Ranit<Ogre::PkgFileInfo,int,Ogre::PkgFileInfo const *,Ogre::PkgFileInfo const &>::_Ranit<Ogre::PkgFileInfo,int,Ogre::PkgFileInfo const *,Ogre::PkgFileInfo const &>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@UPkgFileInfo@Ogre@@HPBU34@ABU34@V_Iterator_base_aux@2@@std@@QAE@XZ
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Ranit@UPkgFileInfo@Ogre@@HPBU12@ABU12@@std@@QAE@XZ ENDP ; std::_Ranit<Ogre::PkgFileInfo,int,Ogre::PkgFileInfo const *,Ogre::PkgFileInfo const &>::_Ranit<Ogre::PkgFileInfo,int,Ogre::PkgFileInfo const *,Ogre::PkgFileInfo const &>
_TEXT	ENDS
PUBLIC	??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@PAVPackageDataStreamObject@Ogre@@HPBQAV34@ABQAV34@V_Iterator_base_aux@2@@std@@QAE@XZ ; std::_Iterator_with_base<std::random_access_iterator_tag,Ogre::PackageDataStreamObject *,int,Ogre::PackageDataStreamObject * const *,Ogre::PackageDataStreamObject * const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,Ogre::PackageDataStreamObject *,int,Ogre::PackageDataStreamObject * const *,Ogre::PackageDataStreamObject * const &,std::_Iterator_base_aux>
; Function compile flags: /Odtp
;	COMDAT ??0?$_Ranit@PAVPackageDataStreamObject@Ogre@@HPBQAV12@ABQAV12@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Ranit@PAVPackageDataStreamObject@Ogre@@HPBQAV12@ABQAV12@@std@@QAE@XZ PROC ; std::_Ranit<Ogre::PackageDataStreamObject *,int,Ogre::PackageDataStreamObject * const *,Ogre::PackageDataStreamObject * const &>::_Ranit<Ogre::PackageDataStreamObject *,int,Ogre::PackageDataStreamObject * const *,Ogre::PackageDataStreamObject * const &>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@PAVPackageDataStreamObject@Ogre@@HPBQAV34@ABQAV34@V_Iterator_base_aux@2@@std@@QAE@XZ
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Ranit@PAVPackageDataStreamObject@Ogre@@HPBQAV12@ABQAV12@@std@@QAE@XZ ENDP ; std::_Ranit<Ogre::PackageDataStreamObject *,int,Ogre::PackageDataStreamObject * const *,Ogre::PackageDataStreamObject * const &>::_Ranit<Ogre::PackageDataStreamObject *,int,Ogre::PackageDataStreamObject * const *,Ogre::PackageDataStreamObject * const &>
_TEXT	ENDS
PUBLIC	??0_Iterator_base_aux@std@@QAE@XZ		; std::_Iterator_base_aux::_Iterator_base_aux
; Function compile flags: /Odtp
;	COMDAT ??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@UPkgFileInfo@Ogre@@HPBU34@ABU34@V_Iterator_base_aux@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@UPkgFileInfo@Ogre@@HPBU34@ABU34@V_Iterator_base_aux@2@@std@@QAE@XZ PROC ; std::_Iterator_with_base<std::random_access_iterator_tag,Ogre::PkgFileInfo,int,Ogre::PkgFileInfo const *,Ogre::PkgFileInfo const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,Ogre::PkgFileInfo,int,Ogre::PkgFileInfo const *,Ogre::PkgFileInfo const &,std::_Iterator_base_aux>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Iterator_base_aux@std@@QAE@XZ	; std::_Iterator_base_aux::_Iterator_base_aux
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@UPkgFileInfo@Ogre@@HPBU34@ABU34@V_Iterator_base_aux@2@@std@@QAE@XZ ENDP ; std::_Iterator_with_base<std::random_access_iterator_tag,Ogre::PkgFileInfo,int,Ogre::PkgFileInfo const *,Ogre::PkgFileInfo const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,Ogre::PkgFileInfo,int,Ogre::PkgFileInfo const *,Ogre::PkgFileInfo const &,std::_Iterator_base_aux>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??0_Iterator_base_aux@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_Iterator_base_aux@std@@QAE@XZ PROC			; std::_Iterator_base_aux::_Iterator_base_aux, COMDAT
; _this$ = ecx

; 448  : 	_Iterator_base_aux()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0_Iterator_base_aux@std@@QAE@XZ ENDP			; std::_Iterator_base_aux::_Iterator_base_aux
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@PAVPackageDataStreamObject@Ogre@@HPBQAV34@ABQAV34@V_Iterator_base_aux@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@PAVPackageDataStreamObject@Ogre@@HPBQAV34@ABQAV34@V_Iterator_base_aux@2@@std@@QAE@XZ PROC ; std::_Iterator_with_base<std::random_access_iterator_tag,Ogre::PackageDataStreamObject *,int,Ogre::PackageDataStreamObject * const *,Ogre::PackageDataStreamObject * const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,Ogre::PackageDataStreamObject *,int,Ogre::PackageDataStreamObject * const *,Ogre::PackageDataStreamObject * const &,std::_Iterator_base_aux>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Iterator_base_aux@std@@QAE@XZ	; std::_Iterator_base_aux::_Iterator_base_aux
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@PAVPackageDataStreamObject@Ogre@@HPBQAV34@ABQAV34@V_Iterator_base_aux@2@@std@@QAE@XZ ENDP ; std::_Iterator_with_base<std::random_access_iterator_tag,Ogre::PackageDataStreamObject *,int,Ogre::PackageDataStreamObject * const *,Ogre::PackageDataStreamObject * const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,Ogre::PackageDataStreamObject *,int,Ogre::PackageDataStreamObject * const *,Ogre::PackageDataStreamObject * const &,std::_Iterator_base_aux>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?_Make_iter@?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@2@V?$_Vector_const_iterator@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 8
?_Make_iter@?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@2@V?$_Vector_const_iterator@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@2@@Z PROC ; std::vector<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::_Make_iter, COMDAT
; _this$ = ecx

; 660  : 		{	// make iterator from const_iterator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 661  : 		return (iterator(_Where._Myptr, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp+4]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QAE@PAUPkgFileInfo@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::_Vector_iterator<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 662  : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?_Make_iter@?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@2@V?$_Vector_const_iterator@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@2@@Z ENDP ; std::vector<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::_Make_iter
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_fill_n@PAUPkgFileInfo@Ogre@@IU12@V?$allocator@UPkgFileInfo@Ogre@@@std@@@stdext@@YAXPAUPkgFileInfo@Ogre@@IABU12@AAV?$allocator@UPkgFileInfo@Ogre@@@std@@@Z ; stdext::unchecked_uninitialized_fill_n<Ogre::PkgFileInfo *,unsigned int,Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >
; Function compile flags: /Odtp
;	COMDAT ?_Ufill@?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@IAEPAUPkgFileInfo@Ogre@@PAU34@IABU34@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Ufill@?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@IAEPAUPkgFileInfo@Ogre@@PAU34@IABU34@@Z PROC ; std::vector<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::_Ufill, COMDAT
; _this$ = ecx

; 1253 : 		{	// copy initializing _Count * _Val, using allocator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1254 : 		_STDEXT unchecked_uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??$unchecked_uninitialized_fill_n@PAUPkgFileInfo@Ogre@@IU12@V?$allocator@UPkgFileInfo@Ogre@@@std@@@stdext@@YAXPAUPkgFileInfo@Ogre@@IABU12@AAV?$allocator@UPkgFileInfo@Ogre@@@std@@@Z ; stdext::unchecked_uninitialized_fill_n<Ogre::PkgFileInfo *,unsigned int,Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >
	add	esp, 16					; 00000010H

; 1255 : 		return (_Ptr + _Count);

	mov	eax, DWORD PTR __Count$[ebp]
	imul	eax, 24					; 00000018H
	add	eax, DWORD PTR __Ptr$[ebp]

; 1256 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?_Ufill@?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@IAEPAUPkgFileInfo@Ogre@@PAU34@IABU34@@Z ENDP ; std::vector<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::_Ufill
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@UPkgFileInfo@Ogre@@@std@@QBEIXZ
_TEXT	SEGMENT
tv65 = -12						; size = 4
_this$ = -8						; size = 4
__Count$ = -4						; size = 4
?max_size@?$allocator@UPkgFileInfo@Ogre@@@std@@QBEIXZ PROC ; std::allocator<Ogre::PkgFileInfo>::max_size, COMDAT
; _this$ = ecx

; 164  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);

	mov	DWORD PTR __Count$[ebp], 178956970	; 0aaaaaaaH

; 166  : 		return (0 < _Count ? _Count : 1);

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN3@max_size
	mov	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR tv65[ebp], eax
	jmp	SHORT $LN4@max_size
$LN3@max_size:
	mov	DWORD PTR tv65[ebp], 1
$LN4@max_size:
	mov	eax, DWORD PTR tv65[ebp]

; 167  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$allocator@UPkgFileInfo@Ogre@@@std@@QBEIXZ ENDP ; std::allocator<Ogre::PkgFileInfo>::max_size
_TEXT	ENDS
PUBLIC	??$_Allocate@V_Aux_cont@std@@@std@@YAPAV_Aux_cont@0@IPAV10@@Z ; std::_Allocate<std::_Aux_cont>
; Function compile flags: /Odtp
;	COMDAT ?allocate@?$allocator@V_Aux_cont@std@@@std@@QAEPAV_Aux_cont@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@V_Aux_cont@std@@@std@@QAEPAV_Aux_cont@2@I@Z PROC ; std::allocator<std::_Aux_cont>::allocate, COMDAT
; _this$ = ecx

; 144  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@V_Aux_cont@std@@@std@@YAPAV_Aux_cont@0@IPAV10@@Z ; std::_Allocate<std::_Aux_cont>
	add	esp, 8

; 146  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@V_Aux_cont@std@@@std@@QAEPAV_Aux_cont@2@I@Z ENDP ; std::allocator<std::_Aux_cont>::allocate
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@QBEIXZ
_TEXT	SEGMENT
tv65 = -12						; size = 4
_this$ = -8						; size = 4
__Count$ = -4						; size = 4
?max_size@?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@QBEIXZ PROC ; std::allocator<Ogre::PackageDataStreamObject *>::max_size, COMDAT
; _this$ = ecx

; 164  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);

	mov	DWORD PTR __Count$[ebp], 1073741823	; 3fffffffH

; 166  : 		return (0 < _Count ? _Count : 1);

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN3@max_size@2
	mov	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR tv65[ebp], eax
	jmp	SHORT $LN4@max_size@2
$LN3@max_size@2:
	mov	DWORD PTR tv65[ebp], 1
$LN4@max_size@2:
	mov	eax, DWORD PTR tv65[ebp]

; 167  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@QBEIXZ ENDP ; std::allocator<Ogre::PackageDataStreamObject *>::max_size
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::operator==
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??9?$_Vector_const_iterator@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::operator!=, COMDAT
; _this$ = ecx

; 215  : 		{	// test for iterator inequality

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??8?$_Vector_const_iterator@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::operator==
	movzx	eax, al
	neg	eax
	sbb	eax, eax
	add	eax, 1

; 217  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??9?$_Vector_const_iterator@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::operator!=
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??8?$_Vector_const_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::operator==, COMDAT
; _this$ = ecx

; 203  : 		{	// test for iterator equality

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Has_container@_Iterator_base_aux@std@@QBE_NXZ ; std::_Iterator_base_aux::_Has_container
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@operator@7
	mov	ecx, DWORD PTR __Right$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Same_container@_Iterator_base_aux@std@@QBE_NABV12@@Z ; std::_Iterator_base_aux::_Same_container
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN2@operator@7
$LN1@operator@7:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@operator@7:

; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [eax+4]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+4]
	sete	al

; 212  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??8?$_Vector_const_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::operator==
_TEXT	ENDS
PUBLIC	??Y?$_Vector_const_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::operator+=
; Function compile flags: /Odtp
;	COMDAT ??Y?$_Vector_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
??Y?$_Vector_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::operator+=, COMDAT
; _this$ = ecx

; 374  : 		{	// increment by integer

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 375  : 		(*(_Mybase *)this) += _Off;

	mov	eax, DWORD PTR __Off$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??Y?$_Vector_const_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::operator+=

; 376  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 377  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??Y?$_Vector_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::operator+=
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0?$_Vector_iterator@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QAE@PAUPkgFileInfo@Ogre@@PBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QAE@PAUPkgFileInfo@Ogre@@PBV_Container_base_aux@1@@Z PROC ; std::_Vector_iterator<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::_Vector_iterator<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >, COMDAT
; _this$ = ecx

; 327  : 		{	// construct with pointer _Ptr

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Pvector$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_const_iterator@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QAE@PAUPkgFileInfo@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::_Vector_const_iterator<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >

; 328  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Vector_iterator@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QAE@PAUPkgFileInfo@Ogre@@PBV_Container_base_aux@1@@Z ENDP ; std::_Vector_iterator<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::_Vector_iterator<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >
_TEXT	ENDS
PUBLIC	??Y?$_Vector_const_iterator@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::operator+=
; Function compile flags: /Odtp
;	COMDAT ??Y?$_Vector_iterator@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
??Y?$_Vector_iterator@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::operator+=, COMDAT
; _this$ = ecx

; 374  : 		{	// increment by integer

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 375  : 		(*(_Mybase *)this) += _Off;

	mov	eax, DWORD PTR __Off$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??Y?$_Vector_const_iterator@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::operator+=

; 376  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 377  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??Y?$_Vector_iterator@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::operator+=
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??Y?$_Vector_const_iterator@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
??Y?$_Vector_const_iterator@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::operator+=, COMDAT
; _this$ = ecx

; 159  : 		{	// increment by integer

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 160  : 		_SCL_SECURE_VALIDATE(this->_Has_container());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Has_container@_Iterator_base_aux@std@@QBE_NXZ ; std::_Iterator_base_aux::_Has_container
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN3@operator@8
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN3@operator@8:

; 161  : 		_SCL_SECURE_VALIDATE_RANGE(

	mov	esi, DWORD PTR __Off$[ebp]
	imul	esi, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	add	esi, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getmycont@_Iterator_base_aux@std@@QBEPBV_Container_base_aux@2@XZ ; std::_Iterator_base_aux::_Getmycont
	cmp	esi, DWORD PTR [eax+16]
	ja	SHORT $LN1@operator@8
	mov	esi, DWORD PTR __Off$[ebp]
	imul	esi, 24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	add	esi, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getmycont@_Iterator_base_aux@std@@QBEPBV_Container_base_aux@2@XZ ; std::_Iterator_base_aux::_Getmycont
	cmp	esi, DWORD PTR [eax+12]
	jae	SHORT $LN2@operator@8
$LN1@operator@8:

; 162  : 			_Myptr + _Off <= ((_Myvec *)(this->_Getmycont()))->_Mylast &&
; 163  : 			_Myptr + _Off >= ((_Myvec *)(this->_Getmycont()))->_Myfirst);

	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@operator@8:

; 164  : 		_Myptr += _Off;

	mov	eax, DWORD PTR __Off$[ebp]
	imul	eax, 24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], eax

; 165  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 166  : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
??Y?$_Vector_const_iterator@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::operator+=
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??8?$_Vector_const_iterator@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::operator==, COMDAT
; _this$ = ecx

; 203  : 		{	// test for iterator equality

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Has_container@_Iterator_base_aux@std@@QBE_NXZ ; std::_Iterator_base_aux::_Has_container
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@operator@9
	mov	ecx, DWORD PTR __Right$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Same_container@_Iterator_base_aux@std@@QBE_NABV12@@Z ; std::_Iterator_base_aux::_Same_container
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN2@operator@9
$LN1@operator@9:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@operator@9:

; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [eax+4]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+4]
	sete	al

; 212  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??8?$_Vector_const_iterator@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::operator==
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??Y?$_Vector_const_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
??Y?$_Vector_const_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::operator+=, COMDAT
; _this$ = ecx

; 159  : 		{	// increment by integer

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 160  : 		_SCL_SECURE_VALIDATE(this->_Has_container());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Has_container@_Iterator_base_aux@std@@QBE_NXZ ; std::_Iterator_base_aux::_Has_container
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN3@operator@10
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN3@operator@10:

; 161  : 		_SCL_SECURE_VALIDATE_RANGE(

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR __Off$[ebp]
	lea	esi, DWORD PTR [edx+eax*4]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getmycont@_Iterator_base_aux@std@@QBEPBV_Container_base_aux@2@XZ ; std::_Iterator_base_aux::_Getmycont
	cmp	esi, DWORD PTR [eax+16]
	ja	SHORT $LN1@operator@10
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR __Off$[ebp]
	lea	esi, DWORD PTR [edx+eax*4]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getmycont@_Iterator_base_aux@std@@QBEPBV_Container_base_aux@2@XZ ; std::_Iterator_base_aux::_Getmycont
	cmp	esi, DWORD PTR [eax+12]
	jae	SHORT $LN2@operator@10
$LN1@operator@10:

; 162  : 			_Myptr + _Off <= ((_Myvec *)(this->_Getmycont()))->_Mylast &&
; 163  : 			_Myptr + _Off >= ((_Myvec *)(this->_Getmycont()))->_Myfirst);

	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@operator@10:

; 164  : 		_Myptr += _Off;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR __Off$[ebp]
	lea	ecx, DWORD PTR [edx+eax*4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 165  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 166  : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
??Y?$_Vector_const_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::operator+=
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@PAUPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@2@@stdext@@YAPAUPkgFileInfo@Ogre@@V?$_Vector_const_iterator@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@0PAU12@AAV?$allocator@UPkgFileInfo@Ogre@@@4@@Z ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >,Ogre::PkgFileInfo *,std::allocator<Ogre::PkgFileInfo> >
; Function compile flags: /Odtp
;	COMDAT ??$_Ucopy@V?$_Vector_const_iterator@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@@?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@IAEPAUPkgFileInfo@Ogre@@V?$_Vector_const_iterator@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@1@0PAU23@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 8
__Last$ = 16						; size = 8
__Ptr$ = 24						; size = 4
??$_Ucopy@V?$_Vector_const_iterator@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@@?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@IAEPAUPkgFileInfo@Ogre@@V?$_Vector_const_iterator@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@1@0PAU23@@Z PROC ; std::vector<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::_Ucopy<std::_Vector_const_iterator<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> > >, COMDAT
; _this$ = ecx

; 1138 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1139 : 		{	// copy initializing [_First, _Last), using allocator
; 1140 : 		return (_STDEXT unchecked_uninitialized_copy(_First, _Last,
; 1141 : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp+4]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@PAUPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@2@@stdext@@YAPAUPkgFileInfo@Ogre@@V?$_Vector_const_iterator@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@0PAU12@AAV?$allocator@UPkgFileInfo@Ogre@@@4@@Z ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >,Ogre::PkgFileInfo *,std::allocator<Ogre::PkgFileInfo> >
	add	esp, 24					; 00000018H

; 1142 : 		}

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
??$_Ucopy@V?$_Vector_const_iterator@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@@?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@IAEPAUPkgFileInfo@Ogre@@V?$_Vector_const_iterator@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@1@0PAU23@@Z ENDP ; std::vector<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::_Ucopy<std::_Vector_const_iterator<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> > >
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAUPkgFileInfo@Ogre@@PAU12@@std@@YAPAUPkgFileInfo@Ogre@@PAU12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<Ogre::PkgFileInfo *,Ogre::PkgFileInfo *>
PUBLIC	??$_Checked_base@PAUPkgFileInfo@Ogre@@@std@@YAPAUPkgFileInfo@Ogre@@AAPAU12@@Z ; std::_Checked_base<Ogre::PkgFileInfo *>
PUBLIC	??$_Iter_random@PAUPkgFileInfo@Ogre@@PAU12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUPkgFileInfo@Ogre@@0@Z ; std::_Iter_random<Ogre::PkgFileInfo *,Ogre::PkgFileInfo *>
PUBLIC	??$_Ptr_cat@PAUPkgFileInfo@Ogre@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUPkgFileInfo@Ogre@@0@Z ; std::_Ptr_cat<Ogre::PkgFileInfo *,Ogre::PkgFileInfo *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$unchecked_copy@PAUPkgFileInfo@Ogre@@PAU12@@stdext@@YAPAUPkgFileInfo@Ogre@@PAU12@00@Z
_TEXT	SEGMENT
$T124708 = -3						; size = 1
$T124707 = -2						; size = 1
$T124706 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAUPkgFileInfo@Ogre@@PAU12@@stdext@@YAPAUPkgFileInfo@Ogre@@PAU12@00@Z PROC ; stdext::unchecked_copy<Ogre::PkgFileInfo *,Ogre::PkgFileInfo *>, COMDAT

; 3604 : 	{	// copy [_First, _Last) to [_Dest, ...)

	push	ebp
	mov	ebp, esp
	push	ecx

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T124706[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAUPkgFileInfo@Ogre@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUPkgFileInfo@Ogre@@0@Z ; std::_Ptr_cat<Ogre::PkgFileInfo *,Ogre::PkgFileInfo *>
	add	esp, 8
	mov	BYTE PTR $T124707[ebp], al
	movzx	eax, BYTE PTR $T124706[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T124707[ebp]
	push	ecx
	lea	edx, DWORD PTR __Dest$[ebp]
	push	edx
	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T124708[ebp]
	push	ecx
	call	??$_Iter_random@PAUPkgFileInfo@Ogre@@PAU12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUPkgFileInfo@Ogre@@0@Z ; std::_Iter_random<Ogre::PkgFileInfo *,Ogre::PkgFileInfo *>
	add	esp, 12					; 0000000cH
	movzx	edx, BYTE PTR [eax]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@PAUPkgFileInfo@Ogre@@@std@@YAPAUPkgFileInfo@Ogre@@AAPAU12@@Z ; std::_Checked_base<Ogre::PkgFileInfo *>
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@PAUPkgFileInfo@Ogre@@@std@@YAPAUPkgFileInfo@Ogre@@AAPAU12@@Z ; std::_Checked_base<Ogre::PkgFileInfo *>
	add	esp, 4
	push	eax
	call	??$_Copy_opt@PAUPkgFileInfo@Ogre@@PAU12@@std@@YAPAUPkgFileInfo@Ogre@@PAU12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<Ogre::PkgFileInfo *,Ogre::PkgFileInfo *>
	add	esp, 24					; 00000018H

; 3607 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_copy@PAUPkgFileInfo@Ogre@@PAU12@@stdext@@YAPAUPkgFileInfo@Ogre@@PAU12@00@Z ENDP ; stdext::unchecked_copy<Ogre::PkgFileInfo *,Ogre::PkgFileInfo *>
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@PAUPkgFileInfo@Ogre@@PAU12@V?$allocator@UPkgFileInfo@Ogre@@@std@@@stdext@@YAPAUPkgFileInfo@Ogre@@PAU12@00AAV?$allocator@UPkgFileInfo@Ogre@@@std@@@Z ; stdext::unchecked_uninitialized_copy<Ogre::PkgFileInfo *,Ogre::PkgFileInfo *,std::allocator<Ogre::PkgFileInfo> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??$_Ucopy@PAUPkgFileInfo@Ogre@@@?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@IAEPAUPkgFileInfo@Ogre@@PAU23@00@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Ucopy@PAUPkgFileInfo@Ogre@@@?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@IAEPAUPkgFileInfo@Ogre@@PAU23@00@Z PROC ; std::vector<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::_Ucopy<Ogre::PkgFileInfo *>, COMDAT
; _this$ = ecx

; 1138 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1139 : 		{	// copy initializing [_First, _Last), using allocator
; 1140 : 		return (_STDEXT unchecked_uninitialized_copy(_First, _Last,
; 1141 : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$unchecked_uninitialized_copy@PAUPkgFileInfo@Ogre@@PAU12@V?$allocator@UPkgFileInfo@Ogre@@@std@@@stdext@@YAPAUPkgFileInfo@Ogre@@PAU12@00AAV?$allocator@UPkgFileInfo@Ogre@@@std@@@Z ; stdext::unchecked_uninitialized_copy<Ogre::PkgFileInfo *,Ogre::PkgFileInfo *,std::allocator<Ogre::PkgFileInfo> >
	add	esp, 16					; 00000010H

; 1142 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??$_Ucopy@PAUPkgFileInfo@Ogre@@@?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@IAEPAUPkgFileInfo@Ogre@@PAU23@00@Z ENDP ; std::vector<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::_Ucopy<Ogre::PkgFileInfo *>
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@PAPAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@2@@stdext@@YAPAPAVPackageDataStreamObject@Ogre@@V?$_Vector_const_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@0PAPAV12@AAV?$allocator@PAVPackageDataStreamObject@Ogre@@@4@@Z ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >,Ogre::PackageDataStreamObject * *,std::allocator<Ogre::PackageDataStreamObject *> >
; Function compile flags: /Odtp
;	COMDAT ??$_Ucopy@V?$_Vector_const_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@IAEPAPAVPackageDataStreamObject@Ogre@@V?$_Vector_const_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@1@0PAPAV23@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 8
__Last$ = 16						; size = 8
__Ptr$ = 24						; size = 4
??$_Ucopy@V?$_Vector_const_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@IAEPAPAVPackageDataStreamObject@Ogre@@V?$_Vector_const_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@1@0PAPAV23@@Z PROC ; std::vector<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::_Ucopy<std::_Vector_const_iterator<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> > >, COMDAT
; _this$ = ecx

; 1138 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1139 : 		{	// copy initializing [_First, _Last), using allocator
; 1140 : 		return (_STDEXT unchecked_uninitialized_copy(_First, _Last,
; 1141 : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp+4]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@PAPAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@2@@stdext@@YAPAPAVPackageDataStreamObject@Ogre@@V?$_Vector_const_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@0PAPAV12@AAV?$allocator@PAVPackageDataStreamObject@Ogre@@@4@@Z ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >,Ogre::PackageDataStreamObject * *,std::allocator<Ogre::PackageDataStreamObject *> >
	add	esp, 24					; 00000018H

; 1142 : 		}

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
??$_Ucopy@V?$_Vector_const_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@IAEPAPAVPackageDataStreamObject@Ogre@@V?$_Vector_const_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@1@0PAPAV23@@Z ENDP ; std::vector<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::_Ucopy<std::_Vector_const_iterator<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> > >
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAPAVPackageDataStreamObject@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@@std@@YAPAPAVPackageDataStreamObject@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<Ogre::PackageDataStreamObject * *,Ogre::PackageDataStreamObject * *,std::random_access_iterator_tag>
PUBLIC	??$_Checked_base@PAPAVPackageDataStreamObject@Ogre@@@std@@YAPAPAVPackageDataStreamObject@Ogre@@AAPAPAV12@@Z ; std::_Checked_base<Ogre::PackageDataStreamObject * *>
PUBLIC	??$_Iter_random@PAPAVPackageDataStreamObject@Ogre@@PAPAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVPackageDataStreamObject@Ogre@@0@Z ; std::_Iter_random<Ogre::PackageDataStreamObject * *,Ogre::PackageDataStreamObject * *>
PUBLIC	??$_Ptr_cat@PAPAVPackageDataStreamObject@Ogre@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVPackageDataStreamObject@Ogre@@0@Z ; std::_Ptr_cat<Ogre::PackageDataStreamObject * *,Ogre::PackageDataStreamObject * *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$unchecked_copy@PAPAVPackageDataStreamObject@Ogre@@PAPAV12@@stdext@@YAPAPAVPackageDataStreamObject@Ogre@@PAPAV12@00@Z
_TEXT	SEGMENT
$T124717 = -3						; size = 1
$T124716 = -2						; size = 1
$T124715 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAPAVPackageDataStreamObject@Ogre@@PAPAV12@@stdext@@YAPAPAVPackageDataStreamObject@Ogre@@PAPAV12@00@Z PROC ; stdext::unchecked_copy<Ogre::PackageDataStreamObject * *,Ogre::PackageDataStreamObject * *>, COMDAT

; 3604 : 	{	// copy [_First, _Last) to [_Dest, ...)

	push	ebp
	mov	ebp, esp
	push	ecx

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T124715[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAPAVPackageDataStreamObject@Ogre@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVPackageDataStreamObject@Ogre@@0@Z ; std::_Ptr_cat<Ogre::PackageDataStreamObject * *,Ogre::PackageDataStreamObject * *>
	add	esp, 8
	mov	BYTE PTR $T124716[ebp], al
	movzx	eax, BYTE PTR $T124715[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T124716[ebp]
	push	ecx
	lea	edx, DWORD PTR __Dest$[ebp]
	push	edx
	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T124717[ebp]
	push	ecx
	call	??$_Iter_random@PAPAVPackageDataStreamObject@Ogre@@PAPAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVPackageDataStreamObject@Ogre@@0@Z ; std::_Iter_random<Ogre::PackageDataStreamObject * *,Ogre::PackageDataStreamObject * *>
	add	esp, 12					; 0000000cH
	movzx	edx, BYTE PTR [eax]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@PAPAVPackageDataStreamObject@Ogre@@@std@@YAPAPAVPackageDataStreamObject@Ogre@@AAPAPAV12@@Z ; std::_Checked_base<Ogre::PackageDataStreamObject * *>
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@PAPAVPackageDataStreamObject@Ogre@@@std@@YAPAPAVPackageDataStreamObject@Ogre@@AAPAPAV12@@Z ; std::_Checked_base<Ogre::PackageDataStreamObject * *>
	add	esp, 4
	push	eax
	call	??$_Copy_opt@PAPAVPackageDataStreamObject@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@@std@@YAPAPAVPackageDataStreamObject@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<Ogre::PackageDataStreamObject * *,Ogre::PackageDataStreamObject * *,std::random_access_iterator_tag>
	add	esp, 24					; 00000018H

; 3607 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_copy@PAPAVPackageDataStreamObject@Ogre@@PAPAV12@@stdext@@YAPAPAVPackageDataStreamObject@Ogre@@PAPAV12@00@Z ENDP ; stdext::unchecked_copy<Ogre::PackageDataStreamObject * *,Ogre::PackageDataStreamObject * *>
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@PAPAVPackageDataStreamObject@Ogre@@PAPAV12@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@stdext@@YAPAPAVPackageDataStreamObject@Ogre@@PAPAV12@00AAV?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@Z ; stdext::unchecked_uninitialized_copy<Ogre::PackageDataStreamObject * *,Ogre::PackageDataStreamObject * *,std::allocator<Ogre::PackageDataStreamObject *> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??$_Ucopy@PAPAVPackageDataStreamObject@Ogre@@@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@IAEPAPAVPackageDataStreamObject@Ogre@@PAPAV23@00@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Ucopy@PAPAVPackageDataStreamObject@Ogre@@@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@IAEPAPAVPackageDataStreamObject@Ogre@@PAPAV23@00@Z PROC ; std::vector<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::_Ucopy<Ogre::PackageDataStreamObject * *>, COMDAT
; _this$ = ecx

; 1138 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1139 : 		{	// copy initializing [_First, _Last), using allocator
; 1140 : 		return (_STDEXT unchecked_uninitialized_copy(_First, _Last,
; 1141 : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$unchecked_uninitialized_copy@PAPAVPackageDataStreamObject@Ogre@@PAPAV12@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@stdext@@YAPAPAVPackageDataStreamObject@Ogre@@PAPAV12@00AAV?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@Z ; stdext::unchecked_uninitialized_copy<Ogre::PackageDataStreamObject * *,Ogre::PackageDataStreamObject * *,std::allocator<Ogre::PackageDataStreamObject *> >
	add	esp, 16					; 00000010H

; 1142 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??$_Ucopy@PAPAVPackageDataStreamObject@Ogre@@@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@IAEPAPAVPackageDataStreamObject@Ogre@@PAPAV23@00@Z ENDP ; std::vector<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::_Ucopy<Ogre::PackageDataStreamObject * *>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@YAXPAUPkgFileInfo@Ogre@@0AAV?$allocator@UPkgFileInfo@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<Ogre::PkgFileInfo> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@YAXPAUPkgFileInfo@Ogre@@0AAV?$allocator@UPkgFileInfo@Ogre@@@0@@Z
_TEXT	SEGMENT
$T124722 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@YAXPAUPkgFileInfo@Ogre@@0AAV?$allocator@UPkgFileInfo@Ogre@@@0@@Z PROC ; std::_Destroy_range<std::allocator<Ogre::PkgFileInfo> >, COMDAT

; 224  : 	{	// destroy [_First, _Last)

	push	ebp
	mov	ebp, esp
	push	ecx

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Ptr_cat@PAUPkgFileInfo@Ogre@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUPkgFileInfo@Ogre@@0@Z ; std::_Ptr_cat<Ogre::PkgFileInfo *,Ogre::PkgFileInfo *>
	add	esp, 8
	mov	BYTE PTR $T124722[ebp], al
	movzx	edx, BYTE PTR $T124722[ebp]
	push	edx
	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Destroy_range@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@YAXPAUPkgFileInfo@Ogre@@0AAV?$allocator@UPkgFileInfo@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<Ogre::PkgFileInfo> >
	add	esp, 16					; 00000010H

; 226  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Destroy_range@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@YAXPAUPkgFileInfo@Ogre@@0AAV?$allocator@UPkgFileInfo@Ogre@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<Ogre::PkgFileInfo> >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@YAXPAPAVPackageDataStreamObject@Ogre@@0AAV?$allocator@PAVPackageDataStreamObject@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<Ogre::PackageDataStreamObject *> >
; Function compile flags: /Odtp
;	COMDAT ??$_Destroy_range@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@YAXPAPAVPackageDataStreamObject@Ogre@@0AAV?$allocator@PAVPackageDataStreamObject@Ogre@@@0@@Z
_TEXT	SEGMENT
$T124725 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@YAXPAPAVPackageDataStreamObject@Ogre@@0AAV?$allocator@PAVPackageDataStreamObject@Ogre@@@0@@Z PROC ; std::_Destroy_range<std::allocator<Ogre::PackageDataStreamObject *> >, COMDAT

; 224  : 	{	// destroy [_First, _Last)

	push	ebp
	mov	ebp, esp
	push	ecx

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Ptr_cat@PAPAVPackageDataStreamObject@Ogre@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVPackageDataStreamObject@Ogre@@0@Z ; std::_Ptr_cat<Ogre::PackageDataStreamObject * *,Ogre::PackageDataStreamObject * *>
	add	esp, 8
	mov	BYTE PTR $T124725[ebp], al
	movzx	edx, BYTE PTR $T124725[ebp]
	push	edx
	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Destroy_range@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@YAXPAPAVPackageDataStreamObject@Ogre@@0AAV?$allocator@PAVPackageDataStreamObject@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<Ogre::PackageDataStreamObject *> >
	add	esp, 16					; 00000010H

; 226  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Destroy_range@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@YAXPAPAVPackageDataStreamObject@Ogre@@0AAV?$allocator@PAVPackageDataStreamObject@Ogre@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<Ogre::PackageDataStreamObject *> >
_TEXT	ENDS
PUBLIC	??$_Uninit_fill_n@PAPAVPackageDataStreamObject@Ogre@@IPAV12@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@YAXPAPAVPackageDataStreamObject@Ogre@@IABQAV12@AAV?$allocator@PAVPackageDataStreamObject@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<Ogre::PackageDataStreamObject * *,unsigned int,Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_fill_n@PAPAVPackageDataStreamObject@Ogre@@IPAV12@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@stdext@@YAXPAPAVPackageDataStreamObject@Ogre@@IABQAV12@AAV?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@Z
_TEXT	SEGMENT
$T124729 = -2						; size = 1
$T124728 = -1						; size = 1
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_fill_n@PAPAVPackageDataStreamObject@Ogre@@IPAV12@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@stdext@@YAXPAPAVPackageDataStreamObject@Ogre@@IABQAV12@AAV?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@Z PROC ; stdext::unchecked_uninitialized_fill_n<Ogre::PackageDataStreamObject * *,unsigned int,Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >, COMDAT

; 940  : 	{	// copy _Count *_Val to raw _First, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 941  : 	_STD _Uninit_fill_n(_First, _Count, _Val, _Al,
; 942  : 		_STD _Ptr_cat(_First, _First), _STD _Range_checked_iterator_tag());

	xor	eax, eax
	mov	BYTE PTR $T124728[ebp], al
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAPAVPackageDataStreamObject@Ogre@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVPackageDataStreamObject@Ogre@@0@Z ; std::_Ptr_cat<Ogre::PackageDataStreamObject * *,Ogre::PackageDataStreamObject * *>
	add	esp, 8
	mov	BYTE PTR $T124729[ebp], al
	movzx	eax, BYTE PTR $T124728[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T124729[ebp]
	push	ecx
	mov	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Uninit_fill_n@PAPAVPackageDataStreamObject@Ogre@@IPAV12@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@YAXPAPAVPackageDataStreamObject@Ogre@@IABQAV12@AAV?$allocator@PAVPackageDataStreamObject@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<Ogre::PackageDataStreamObject * *,unsigned int,Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >
	add	esp, 24					; 00000018H

; 943  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_fill_n@PAPAVPackageDataStreamObject@Ogre@@IPAV12@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@stdext@@YAXPAPAVPackageDataStreamObject@Ogre@@IABQAV12@AAV?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_fill_n<Ogre::PackageDataStreamObject * *,unsigned int,Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >
_TEXT	ENDS
PUBLIC	??$_Unchecked_uninitialized_move@PAUPkgFileInfo@Ogre@@PAU12@V?$allocator@UPkgFileInfo@Ogre@@@std@@@stdext@@YAPAUPkgFileInfo@Ogre@@PAU12@00AAV?$allocator@UPkgFileInfo@Ogre@@@std@@@Z ; stdext::_Unchecked_uninitialized_move<Ogre::PkgFileInfo *,Ogre::PkgFileInfo *,std::allocator<Ogre::PkgFileInfo> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??$_Umove@PAUPkgFileInfo@Ogre@@@?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@IAEPAUPkgFileInfo@Ogre@@PAU23@00@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Umove@PAUPkgFileInfo@Ogre@@@?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@IAEPAUPkgFileInfo@Ogre@@PAU23@00@Z PROC ; std::vector<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::_Umove<Ogre::PkgFileInfo *>, COMDAT
; _this$ = ecx

; 1145 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1146 : 		{	// move initializing [_First, _Last), using allocator
; 1147 : 		return (_STDEXT _Unchecked_uninitialized_move(_First, _Last,
; 1148 : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Unchecked_uninitialized_move@PAUPkgFileInfo@Ogre@@PAU12@V?$allocator@UPkgFileInfo@Ogre@@@std@@@stdext@@YAPAUPkgFileInfo@Ogre@@PAU12@00AAV?$allocator@UPkgFileInfo@Ogre@@@std@@@Z ; stdext::_Unchecked_uninitialized_move<Ogre::PkgFileInfo *,Ogre::PkgFileInfo *,std::allocator<Ogre::PkgFileInfo> >
	add	esp, 16					; 00000010H

; 1149 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??$_Umove@PAUPkgFileInfo@Ogre@@@?$vector@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@IAEPAUPkgFileInfo@Ogre@@PAU23@00@Z ENDP ; std::vector<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::_Umove<Ogre::PkgFileInfo *>
_TEXT	ENDS
PUBLIC	??$_Fill@PAUPkgFileInfo@Ogre@@U12@@std@@YAXPAUPkgFileInfo@Ogre@@0ABU12@@Z ; std::_Fill<Ogre::PkgFileInfo *,Ogre::PkgFileInfo>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$fill@PAUPkgFileInfo@Ogre@@U12@@std@@YAXPAUPkgFileInfo@Ogre@@0ABU12@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$fill@PAUPkgFileInfo@Ogre@@U12@@std@@YAXPAUPkgFileInfo@Ogre@@0ABU12@@Z PROC ; std::fill<Ogre::PkgFileInfo *,Ogre::PkgFileInfo>, COMDAT

; 3186 : 	{	// copy _Val through [_First, _Last)

	push	ebp
	mov	ebp, esp

; 3187 : 	_Fill(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@PAUPkgFileInfo@Ogre@@@std@@YAPAUPkgFileInfo@Ogre@@AAPAU12@@Z ; std::_Checked_base<Ogre::PkgFileInfo *>
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@PAUPkgFileInfo@Ogre@@@std@@YAPAUPkgFileInfo@Ogre@@AAPAU12@@Z ; std::_Checked_base<Ogre::PkgFileInfo *>
	add	esp, 4
	push	eax
	call	??$_Fill@PAUPkgFileInfo@Ogre@@U12@@std@@YAXPAUPkgFileInfo@Ogre@@0ABU12@@Z ; std::_Fill<Ogre::PkgFileInfo *,Ogre::PkgFileInfo>
	add	esp, 12					; 0000000cH

; 3188 : 	}

	pop	ebp
	ret	0
??$fill@PAUPkgFileInfo@Ogre@@U12@@std@@YAXPAUPkgFileInfo@Ogre@@0ABU12@@Z ENDP ; std::fill<Ogre::PkgFileInfo *,Ogre::PkgFileInfo>
_TEXT	ENDS
PUBLIC	??$_Move_backward_opt@PAUPkgFileInfo@Ogre@@PAU12@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@4@@std@@YAPAUPkgFileInfo@Ogre@@PAU12@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Move_backward_opt<Ogre::PkgFileInfo *,Ogre::PkgFileInfo *,std::random_access_iterator_tag,std::_Undefined_move_tag>
PUBLIC	??$_Move_cat@PAUPkgFileInfo@Ogre@@@std@@YA?AU_Undefined_move_tag@0@ABQAUPkgFileInfo@Ogre@@@Z ; std::_Move_cat<Ogre::PkgFileInfo *>
; Function compile flags: /Odtp
;	COMDAT ??$_Unchecked_move_backward@PAUPkgFileInfo@Ogre@@PAU12@@stdext@@YAPAUPkgFileInfo@Ogre@@PAU12@00@Z
_TEXT	SEGMENT
$T124738 = -3						; size = 1
$T124737 = -2						; size = 1
$T124736 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Unchecked_move_backward@PAUPkgFileInfo@Ogre@@PAU12@@stdext@@YAPAUPkgFileInfo@Ogre@@PAU12@00@Z PROC ; stdext::_Unchecked_move_backward<Ogre::PkgFileInfo *,Ogre::PkgFileInfo *>, COMDAT

; 3694 : 	{	// move [_First, _Last) backwards to [..., _Dest)

	push	ebp
	mov	ebp, esp
	push	ecx

; 3695 : 		return (_STD _Move_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3696 : 			_STD _Iter_random(_First, _Dest), _STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T124736[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	??$_Move_cat@PAUPkgFileInfo@Ogre@@@std@@YA?AU_Undefined_move_tag@0@ABQAUPkgFileInfo@Ogre@@@Z ; std::_Move_cat<Ogre::PkgFileInfo *>
	add	esp, 4
	mov	BYTE PTR $T124737[ebp], al
	movzx	edx, BYTE PTR $T124736[ebp]
	push	edx
	movzx	eax, BYTE PTR $T124737[ebp]
	push	eax
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	lea	eax, DWORD PTR $T124738[ebp]
	push	eax
	call	??$_Iter_random@PAUPkgFileInfo@Ogre@@PAU12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUPkgFileInfo@Ogre@@0@Z ; std::_Iter_random<Ogre::PkgFileInfo *,Ogre::PkgFileInfo *>
	add	esp, 12					; 0000000cH
	movzx	ecx, BYTE PTR [eax]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	call	??$_Checked_base@PAUPkgFileInfo@Ogre@@@std@@YAPAUPkgFileInfo@Ogre@@AAPAU12@@Z ; std::_Checked_base<Ogre::PkgFileInfo *>
	add	esp, 4
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Checked_base@PAUPkgFileInfo@Ogre@@@std@@YAPAUPkgFileInfo@Ogre@@AAPAU12@@Z ; std::_Checked_base<Ogre::PkgFileInfo *>
	add	esp, 4
	push	eax
	call	??$_Move_backward_opt@PAUPkgFileInfo@Ogre@@PAU12@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@4@@std@@YAPAUPkgFileInfo@Ogre@@PAU12@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Move_backward_opt<Ogre::PkgFileInfo *,Ogre::PkgFileInfo *,std::random_access_iterator_tag,std::_Undefined_move_tag>
	add	esp, 24					; 00000018H

; 3697 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Unchecked_move_backward@PAUPkgFileInfo@Ogre@@PAU12@@stdext@@YAPAUPkgFileInfo@Ogre@@PAU12@00@Z ENDP ; stdext::_Unchecked_move_backward<Ogre::PkgFileInfo *,Ogre::PkgFileInfo *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$?0UPkgFileInfo@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@UPkgFileInfo@Ogre@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??$?0UPkgFileInfo@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@UPkgFileInfo@Ogre@@@1@@Z PROC ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::PkgFileInfo>, COMDAT
; _this$ = ecx

; 128  : 		allocator(const allocator<_Other>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0UPkgFileInfo@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@UPkgFileInfo@Ogre@@@1@@Z ENDP ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::PkgFileInfo>
_TEXT	ENDS
PUBLIC	__TI2?AVbad_alloc@std@@
PUBLIC	??0bad_alloc@std@@QAE@PBD@Z			; std::bad_alloc::bad_alloc
PUBLIC	??1bad_alloc@std@@UAE@XZ			; std::bad_alloc::~bad_alloc
PUBLIC	__CTA2?AVbad_alloc@std@@
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
;	COMDAT ??_R0?AVbad_alloc@std@@@8
_DATA	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_alloc@std@@
xdata$x	SEGMENT
__CTA2?AVbad_alloc@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI2?AVbad_alloc@std@@
xdata$x	SEGMENT
__TI2?AVbad_alloc@std@@ DD 00H
	DD	FLAT:??1bad_alloc@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVbad_alloc@std@@
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??$_Allocate@UPkgFileInfo@Ogre@@@std@@YAPAUPkgFileInfo@Ogre@@IPAU12@@Z
_TEXT	SEGMENT
$T124743 = -12						; size = 12
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@UPkgFileInfo@Ogre@@@std@@YAPAUPkgFileInfo@Ogre@@IPAU12@@Z PROC ; std::_Allocate<Ogre::PkgFileInfo>, COMDAT

; 36   : 	{	// check for integer overflow

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 37   : 	if (_Count <= 0)

	cmp	DWORD PTR __Count$[ebp], 0
	ja	SHORT $LN3@Allocate

; 38   : 		_Count = 0;

	mov	DWORD PTR __Count$[ebp], 0
	jmp	SHORT $LN2@Allocate
$LN3@Allocate:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Count$[ebp]
	cmp	eax, 24					; 00000018H
	jae	SHORT $LN2@Allocate

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	push	0
	lea	ecx, DWORD PTR $T124743[ebp]
	call	??0bad_alloc@std@@QAE@PBD@Z		; std::bad_alloc::bad_alloc
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	eax, DWORD PTR $T124743[ebp]
	push	eax
	call	__CxxThrowException@8
$LN2@Allocate:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	mov	ecx, DWORD PTR __Count$[ebp]
	imul	ecx, 24					; 00000018H
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
$LN5@Allocate:

; 44   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@UPkgFileInfo@Ogre@@@std@@YAPAUPkgFileInfo@Ogre@@IPAU12@@Z ENDP ; std::_Allocate<Ogre::PkgFileInfo>
_TEXT	ENDS
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	__imp_??0exception@std@@QAE@ABQBD@Z:PROC
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	?what@exception@std@@UBEPBDXZ:PROC		; std::exception::what
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0bad_alloc@std@@QAE@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0bad_alloc@std@@QAE@PBD@Z$0
__ehfuncinfo$??0bad_alloc@std@@QAE@PBD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0bad_alloc@std@@QAE@PBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@PBD@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Message$ = 8						; size = 4
??0bad_alloc@std@@QAE@PBD@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx

; 371  : 		{	// construct from message string

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0bad_alloc@std@@QAE@PBD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	lea	eax, DWORD PTR __Message$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7bad_alloc@std@@6B@

; 372  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0bad_alloc@std@@QAE@PBD@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??0bad_alloc@std@@QAE@PBD@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0bad_alloc@std@@QAE@PBD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0bad_alloc@std@@QAE@PBD@Z ENDP			; std::bad_alloc::bad_alloc
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1bad_alloc@std@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1bad_alloc@std@@UAE@XZ$0
__ehfuncinfo$??1bad_alloc@std@@UAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1bad_alloc@std@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1bad_alloc@std@@UAE@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
; _this$ = ecx

; 380  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1bad_alloc@std@@UAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 381  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1bad_alloc@std@@UAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??1bad_alloc@std@@UAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1bad_alloc@std@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1bad_alloc@std@@UAE@XZ ENDP				; std::bad_alloc::~bad_alloc
; Function compile flags: /Odtp
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1bad_alloc@std@@UAE@XZ		; std::bad_alloc::~bad_alloc
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@11
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@11:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??$_Unchecked_uninitialized_move@PAPAVPackageDataStreamObject@Ogre@@PAPAV12@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@stdext@@YAPAPAVPackageDataStreamObject@Ogre@@PAPAV12@00AAV?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@Z ; stdext::_Unchecked_uninitialized_move<Ogre::PackageDataStreamObject * *,Ogre::PackageDataStreamObject * *,std::allocator<Ogre::PackageDataStreamObject *> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??$_Umove@PAPAVPackageDataStreamObject@Ogre@@@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@IAEPAPAVPackageDataStreamObject@Ogre@@PAPAV23@00@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Umove@PAPAVPackageDataStreamObject@Ogre@@@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@IAEPAPAVPackageDataStreamObject@Ogre@@PAPAV23@00@Z PROC ; std::vector<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::_Umove<Ogre::PackageDataStreamObject * *>, COMDAT
; _this$ = ecx

; 1145 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1146 : 		{	// move initializing [_First, _Last), using allocator
; 1147 : 		return (_STDEXT _Unchecked_uninitialized_move(_First, _Last,
; 1148 : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Unchecked_uninitialized_move@PAPAVPackageDataStreamObject@Ogre@@PAPAV12@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@stdext@@YAPAPAVPackageDataStreamObject@Ogre@@PAPAV12@00AAV?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@Z ; stdext::_Unchecked_uninitialized_move<Ogre::PackageDataStreamObject * *,Ogre::PackageDataStreamObject * *,std::allocator<Ogre::PackageDataStreamObject *> >
	add	esp, 16					; 00000010H

; 1149 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??$_Umove@PAPAVPackageDataStreamObject@Ogre@@@?$vector@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@IAEPAPAVPackageDataStreamObject@Ogre@@PAPAV23@00@Z ENDP ; std::vector<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::_Umove<Ogre::PackageDataStreamObject * *>
_TEXT	ENDS
PUBLIC	??$_Fill@PAPAVPackageDataStreamObject@Ogre@@PAV12@@std@@YAXPAPAVPackageDataStreamObject@Ogre@@0ABQAV12@@Z ; std::_Fill<Ogre::PackageDataStreamObject * *,Ogre::PackageDataStreamObject *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$fill@PAPAVPackageDataStreamObject@Ogre@@PAV12@@std@@YAXPAPAVPackageDataStreamObject@Ogre@@0ABQAV12@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$fill@PAPAVPackageDataStreamObject@Ogre@@PAV12@@std@@YAXPAPAVPackageDataStreamObject@Ogre@@0ABQAV12@@Z PROC ; std::fill<Ogre::PackageDataStreamObject * *,Ogre::PackageDataStreamObject *>, COMDAT

; 3186 : 	{	// copy _Val through [_First, _Last)

	push	ebp
	mov	ebp, esp

; 3187 : 	_Fill(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@PAPAVPackageDataStreamObject@Ogre@@@std@@YAPAPAVPackageDataStreamObject@Ogre@@AAPAPAV12@@Z ; std::_Checked_base<Ogre::PackageDataStreamObject * *>
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@PAPAVPackageDataStreamObject@Ogre@@@std@@YAPAPAVPackageDataStreamObject@Ogre@@AAPAPAV12@@Z ; std::_Checked_base<Ogre::PackageDataStreamObject * *>
	add	esp, 4
	push	eax
	call	??$_Fill@PAPAVPackageDataStreamObject@Ogre@@PAV12@@std@@YAXPAPAVPackageDataStreamObject@Ogre@@0ABQAV12@@Z ; std::_Fill<Ogre::PackageDataStreamObject * *,Ogre::PackageDataStreamObject *>
	add	esp, 12					; 0000000cH

; 3188 : 	}

	pop	ebp
	ret	0
??$fill@PAPAVPackageDataStreamObject@Ogre@@PAV12@@std@@YAXPAPAVPackageDataStreamObject@Ogre@@0ABQAV12@@Z ENDP ; std::fill<Ogre::PackageDataStreamObject * *,Ogre::PackageDataStreamObject *>
_TEXT	ENDS
PUBLIC	??$_Move_backward_opt@PAPAVPackageDataStreamObject@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@4@@std@@YAPAPAVPackageDataStreamObject@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Move_backward_opt<Ogre::PackageDataStreamObject * *,Ogre::PackageDataStreamObject * *,std::random_access_iterator_tag,std::_Undefined_move_tag>
PUBLIC	??$_Move_cat@PAPAVPackageDataStreamObject@Ogre@@@std@@YA?AU_Undefined_move_tag@0@ABQAPAVPackageDataStreamObject@Ogre@@@Z ; std::_Move_cat<Ogre::PackageDataStreamObject * *>
; Function compile flags: /Odtp
;	COMDAT ??$_Unchecked_move_backward@PAPAVPackageDataStreamObject@Ogre@@PAPAV12@@stdext@@YAPAPAVPackageDataStreamObject@Ogre@@PAPAV12@00@Z
_TEXT	SEGMENT
$T124772 = -3						; size = 1
$T124771 = -2						; size = 1
$T124770 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Unchecked_move_backward@PAPAVPackageDataStreamObject@Ogre@@PAPAV12@@stdext@@YAPAPAVPackageDataStreamObject@Ogre@@PAPAV12@00@Z PROC ; stdext::_Unchecked_move_backward<Ogre::PackageDataStreamObject * *,Ogre::PackageDataStreamObject * *>, COMDAT

; 3694 : 	{	// move [_First, _Last) backwards to [..., _Dest)

	push	ebp
	mov	ebp, esp
	push	ecx

; 3695 : 		return (_STD _Move_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3696 : 			_STD _Iter_random(_First, _Dest), _STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T124770[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	??$_Move_cat@PAPAVPackageDataStreamObject@Ogre@@@std@@YA?AU_Undefined_move_tag@0@ABQAPAVPackageDataStreamObject@Ogre@@@Z ; std::_Move_cat<Ogre::PackageDataStreamObject * *>
	add	esp, 4
	mov	BYTE PTR $T124771[ebp], al
	movzx	edx, BYTE PTR $T124770[ebp]
	push	edx
	movzx	eax, BYTE PTR $T124771[ebp]
	push	eax
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	lea	eax, DWORD PTR $T124772[ebp]
	push	eax
	call	??$_Iter_random@PAPAVPackageDataStreamObject@Ogre@@PAPAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVPackageDataStreamObject@Ogre@@0@Z ; std::_Iter_random<Ogre::PackageDataStreamObject * *,Ogre::PackageDataStreamObject * *>
	add	esp, 12					; 0000000cH
	movzx	ecx, BYTE PTR [eax]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	call	??$_Checked_base@PAPAVPackageDataStreamObject@Ogre@@@std@@YAPAPAVPackageDataStreamObject@Ogre@@AAPAPAV12@@Z ; std::_Checked_base<Ogre::PackageDataStreamObject * *>
	add	esp, 4
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Checked_base@PAPAVPackageDataStreamObject@Ogre@@@std@@YAPAPAVPackageDataStreamObject@Ogre@@AAPAPAV12@@Z ; std::_Checked_base<Ogre::PackageDataStreamObject * *>
	add	esp, 4
	push	eax
	call	??$_Move_backward_opt@PAPAVPackageDataStreamObject@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@4@@std@@YAPAPAVPackageDataStreamObject@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Move_backward_opt<Ogre::PackageDataStreamObject * *,Ogre::PackageDataStreamObject * *,std::random_access_iterator_tag,std::_Undefined_move_tag>
	add	esp, 24					; 00000018H

; 3697 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Unchecked_move_backward@PAPAVPackageDataStreamObject@Ogre@@PAPAV12@@stdext@@YAPAPAVPackageDataStreamObject@Ogre@@PAPAV12@00@Z ENDP ; stdext::_Unchecked_move_backward<Ogre::PackageDataStreamObject * *,Ogre::PackageDataStreamObject * *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$?0PAVPackageDataStreamObject@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@PAVPackageDataStreamObject@Ogre@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??$?0PAVPackageDataStreamObject@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@PAVPackageDataStreamObject@Ogre@@@1@@Z PROC ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::PackageDataStreamObject *>, COMDAT
; _this$ = ecx

; 128  : 		allocator(const allocator<_Other>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0PAVPackageDataStreamObject@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@PAVPackageDataStreamObject@Ogre@@@1@@Z ENDP ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::PackageDataStreamObject *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Allocate@PAVPackageDataStreamObject@Ogre@@@std@@YAPAPAVPackageDataStreamObject@Ogre@@IPAPAV12@@Z
_TEXT	SEGMENT
$T124777 = -12						; size = 12
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@PAVPackageDataStreamObject@Ogre@@@std@@YAPAPAVPackageDataStreamObject@Ogre@@IPAPAV12@@Z PROC ; std::_Allocate<Ogre::PackageDataStreamObject *>, COMDAT

; 36   : 	{	// check for integer overflow

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 37   : 	if (_Count <= 0)

	cmp	DWORD PTR __Count$[ebp], 0
	ja	SHORT $LN3@Allocate@2

; 38   : 		_Count = 0;

	mov	DWORD PTR __Count$[ebp], 0
	jmp	SHORT $LN2@Allocate@2
$LN3@Allocate@2:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Count$[ebp]
	cmp	eax, 4
	jae	SHORT $LN2@Allocate@2

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	push	0
	lea	ecx, DWORD PTR $T124777[ebp]
	call	??0bad_alloc@std@@QAE@PBD@Z		; std::bad_alloc::bad_alloc
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	eax, DWORD PTR $T124777[ebp]
	push	eax
	call	__CxxThrowException@8
$LN2@Allocate@2:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 2
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
$LN5@Allocate@2:

; 44   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@PAVPackageDataStreamObject@Ogre@@@std@@YAPAPAVPackageDataStreamObject@Ogre@@IPAPAV12@@Z ENDP ; std::_Allocate<Ogre::PackageDataStreamObject *>
_TEXT	ENDS
PUBLIC	??$_Uninit_fill_n@PAUPkgFileInfo@Ogre@@IU12@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@YAXPAUPkgFileInfo@Ogre@@IABU12@AAV?$allocator@UPkgFileInfo@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<Ogre::PkgFileInfo *,unsigned int,Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_fill_n@PAUPkgFileInfo@Ogre@@IU12@V?$allocator@UPkgFileInfo@Ogre@@@std@@@stdext@@YAXPAUPkgFileInfo@Ogre@@IABU12@AAV?$allocator@UPkgFileInfo@Ogre@@@std@@@Z
_TEXT	SEGMENT
$T124781 = -2						; size = 1
$T124780 = -1						; size = 1
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_fill_n@PAUPkgFileInfo@Ogre@@IU12@V?$allocator@UPkgFileInfo@Ogre@@@std@@@stdext@@YAXPAUPkgFileInfo@Ogre@@IABU12@AAV?$allocator@UPkgFileInfo@Ogre@@@std@@@Z PROC ; stdext::unchecked_uninitialized_fill_n<Ogre::PkgFileInfo *,unsigned int,Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >, COMDAT

; 940  : 	{	// copy _Count *_Val to raw _First, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 941  : 	_STD _Uninit_fill_n(_First, _Count, _Val, _Al,
; 942  : 		_STD _Ptr_cat(_First, _First), _STD _Range_checked_iterator_tag());

	xor	eax, eax
	mov	BYTE PTR $T124780[ebp], al
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAUPkgFileInfo@Ogre@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUPkgFileInfo@Ogre@@0@Z ; std::_Ptr_cat<Ogre::PkgFileInfo *,Ogre::PkgFileInfo *>
	add	esp, 8
	mov	BYTE PTR $T124781[ebp], al
	movzx	eax, BYTE PTR $T124780[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T124781[ebp]
	push	ecx
	mov	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Uninit_fill_n@PAUPkgFileInfo@Ogre@@IU12@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@YAXPAUPkgFileInfo@Ogre@@IABU12@AAV?$allocator@UPkgFileInfo@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<Ogre::PkgFileInfo *,unsigned int,Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >
	add	esp, 24					; 00000018H

; 943  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_fill_n@PAUPkgFileInfo@Ogre@@IU12@V?$allocator@UPkgFileInfo@Ogre@@@std@@@stdext@@YAXPAUPkgFileInfo@Ogre@@IABU12@AAV?$allocator@UPkgFileInfo@Ogre@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_fill_n<Ogre::PkgFileInfo *,unsigned int,Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Allocate@V_Aux_cont@std@@@std@@YAPAV_Aux_cont@0@IPAV10@@Z
_TEXT	SEGMENT
$T124784 = -12						; size = 12
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@V_Aux_cont@std@@@std@@YAPAV_Aux_cont@0@IPAV10@@Z PROC ; std::_Allocate<std::_Aux_cont>, COMDAT

; 36   : 	{	// check for integer overflow

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 37   : 	if (_Count <= 0)

	cmp	DWORD PTR __Count$[ebp], 0
	ja	SHORT $LN3@Allocate@3

; 38   : 		_Count = 0;

	mov	DWORD PTR __Count$[ebp], 0
	jmp	SHORT $LN2@Allocate@3
$LN3@Allocate@3:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Count$[ebp]
	cmp	eax, 4
	jae	SHORT $LN2@Allocate@3

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	push	0
	lea	ecx, DWORD PTR $T124784[ebp]
	call	??0bad_alloc@std@@QAE@PBD@Z		; std::bad_alloc::bad_alloc
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	eax, DWORD PTR $T124784[ebp]
	push	eax
	call	__CxxThrowException@8
$LN2@Allocate@3:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 2
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
$LN5@Allocate@3:

; 44   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@V_Aux_cont@std@@@std@@YAPAV_Aux_cont@0@IPAV10@@Z ENDP ; std::_Allocate<std::_Aux_cont>
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0bad_alloc@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0bad_alloc@std@@QAE@ABV01@@Z$0
__ehfuncinfo$??0bad_alloc@std@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0bad_alloc@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0bad_alloc@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7bad_alloc@std@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0bad_alloc@std@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??0bad_alloc@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0bad_alloc@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
PUBLIC	??$_Uninit_copy@PBUPkgFileInfo@Ogre@@PAU12@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@YAPAUPkgFileInfo@Ogre@@PBU12@0PAU12@AAV?$allocator@UPkgFileInfo@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Ogre::PkgFileInfo const *,Ogre::PkgFileInfo *,std::allocator<Ogre::PkgFileInfo> >
PUBLIC	??$_Checked_base@V?$_Vector_const_iterator@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@@std@@YAPBUPkgFileInfo@Ogre@@AAV?$_Vector_const_iterator@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> > >
PUBLIC	??$_Ptr_cat@V?$_Vector_const_iterator@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@PAUPkgFileInfo@Ogre@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@0@AAPAUPkgFileInfo@Ogre@@@Z ; std::_Ptr_cat<std::_Vector_const_iterator<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >,Ogre::PkgFileInfo *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@PAUPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@2@@stdext@@YAPAUPkgFileInfo@Ogre@@V?$_Vector_const_iterator@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@0PAU12@AAV?$allocator@UPkgFileInfo@Ogre@@@4@@Z
_TEXT	SEGMENT
$T124797 = -2						; size = 1
$T124796 = -1						; size = 1
__First$ = 8						; size = 8
__Last$ = 16						; size = 8
__Dest$ = 24						; size = 4
__Al$ = 28						; size = 4
??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@PAUPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@2@@stdext@@YAPAUPkgFileInfo@Ogre@@V?$_Vector_const_iterator@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@0PAU12@AAV?$allocator@UPkgFileInfo@Ogre@@@4@@Z PROC ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >,Ogre::PkgFileInfo *,std::allocator<Ogre::PkgFileInfo> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T124796[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@V?$_Vector_const_iterator@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@PAUPkgFileInfo@Ogre@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@0@AAPAUPkgFileInfo@Ogre@@@Z ; std::_Ptr_cat<std::_Vector_const_iterator<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >,Ogre::PkgFileInfo *>
	add	esp, 8
	mov	BYTE PTR $T124797[ebp], al
	movzx	eax, BYTE PTR $T124796[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T124797[ebp]
	push	ecx
	mov	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@V?$_Vector_const_iterator@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@@std@@YAPBUPkgFileInfo@Ogre@@AAV?$_Vector_const_iterator@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> > >
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@V?$_Vector_const_iterator@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@@std@@YAPBUPkgFileInfo@Ogre@@AAV?$_Vector_const_iterator@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> > >
	add	esp, 4
	push	eax
	call	??$_Uninit_copy@PBUPkgFileInfo@Ogre@@PAU12@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@YAPAUPkgFileInfo@Ogre@@PBU12@0PAU12@AAV?$allocator@UPkgFileInfo@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Ogre::PkgFileInfo const *,Ogre::PkgFileInfo *,std::allocator<Ogre::PkgFileInfo> >
	add	esp, 24					; 00000018H

; 823  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@PAUPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@2@@stdext@@YAPAUPkgFileInfo@Ogre@@V?$_Vector_const_iterator@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@0PAU12@AAV?$allocator@UPkgFileInfo@Ogre@@@4@@Z ENDP ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >,Ogre::PkgFileInfo *,std::allocator<Ogre::PkgFileInfo> >
_TEXT	ENDS
PUBLIC	??$_Checked_base@PAUPkgFileInfo@Ogre@@@std@@YAPAUPkgFileInfo@Ogre@@AAPAU12@U_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<Ogre::PkgFileInfo *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Checked_base@PAUPkgFileInfo@Ogre@@@std@@YAPAUPkgFileInfo@Ogre@@AAPAU12@@Z
_TEXT	SEGMENT
__Base_tag$ = -1					; size = 1
__It$ = 8						; size = 4
??$_Checked_base@PAUPkgFileInfo@Ogre@@@std@@YAPAUPkgFileInfo@Ogre@@AAPAU12@@Z PROC ; std::_Checked_base<Ogre::PkgFileInfo *>, COMDAT

; 1163 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1164 : 		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
; 1165 : 		return _Checked_base(_It, _Base_tag);

	movzx	eax, BYTE PTR __Base_tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR __It$[ebp]
	push	ecx
	call	??$_Checked_base@PAUPkgFileInfo@Ogre@@@std@@YAPAUPkgFileInfo@Ogre@@AAPAU12@U_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<Ogre::PkgFileInfo *>
	add	esp, 8

; 1166 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Checked_base@PAUPkgFileInfo@Ogre@@@std@@YAPAUPkgFileInfo@Ogre@@AAPAU12@@Z ENDP ; std::_Checked_base<Ogre::PkgFileInfo *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Iter_random@PAUPkgFileInfo@Ogre@@PAU12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUPkgFileInfo@Ogre@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAUPkgFileInfo@Ogre@@PAU12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUPkgFileInfo@Ogre@@0@Z PROC ; std::_Iter_random<Ogre::PkgFileInfo *,Ogre::PkgFileInfo *>, COMDAT

; 993  : 	{	// return category from iterator argument

	push	ebp
	mov	ebp, esp
	push	ecx

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 998  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Iter_random@PAUPkgFileInfo@Ogre@@PAU12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUPkgFileInfo@Ogre@@0@Z ENDP ; std::_Iter_random<Ogre::PkgFileInfo *,Ogre::PkgFileInfo *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAUPkgFileInfo@Ogre@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUPkgFileInfo@Ogre@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAUPkgFileInfo@Ogre@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUPkgFileInfo@Ogre@@0@Z PROC ; std::_Ptr_cat<Ogre::PkgFileInfo *,Ogre::PkgFileInfo *>, COMDAT

; 1509 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 1512 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Ptr_cat@PAUPkgFileInfo@Ogre@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUPkgFileInfo@Ogre@@0@Z ENDP ; std::_Ptr_cat<Ogre::PkgFileInfo *,Ogre::PkgFileInfo *>
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAUPkgFileInfo@Ogre@@PAU12@Uforward_iterator_tag@std@@@std@@YAPAUPkgFileInfo@Ogre@@PAU12@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<Ogre::PkgFileInfo *,Ogre::PkgFileInfo *,std::forward_iterator_tag>
; Function compile flags: /Odtp
;	COMDAT ??$_Copy_opt@PAUPkgFileInfo@Ogre@@PAU12@@std@@YAPAUPkgFileInfo@Ogre@@PAU12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T124808 = -7						; size = 1
$T124807 = -6						; size = 1
$T124806 = -5						; size = 1
__Result$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAUPkgFileInfo@Ogre@@PAU12@@std@@YAPAUPkgFileInfo@Ogre@@PAU12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<Ogre::PkgFileInfo *,Ogre::PkgFileInfo *>, COMDAT

; 2481 : 	{	// copy [_First, _Last) to [_Dest, ...), random_access iterators

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 2482 : 	// if _OutIt is range checked, this will make sure there is enough space for the copy
; 2483 : 	_OutIt _Result = _Dest + (_Last - _First);

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	cdq
	mov	ecx, 24					; 00000018H
	idiv	ecx
	imul	eax, 24					; 00000018H
	add	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Result$[ebp], eax

; 2484 : 	_Copy_opt(_First, _Last, _CHECKED_BASE(_Dest), 
; 2485 : 		forward_iterator_tag(), _Nonscalar_ptr_iterator_tag(), _Range_checked_iterator_tag());

	xor	edx, edx
	mov	BYTE PTR $T124806[ebp], dl
	xor	eax, eax
	mov	BYTE PTR $T124807[ebp], al
	movzx	ecx, BYTE PTR $T124806[ebp]
	push	ecx
	movzx	edx, BYTE PTR $T124807[ebp]
	push	edx
	movzx	eax, BYTE PTR $T124808[ebp]
	push	eax
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	??$_Checked_base@PAUPkgFileInfo@Ogre@@@std@@YAPAUPkgFileInfo@Ogre@@AAPAU12@@Z ; std::_Checked_base<Ogre::PkgFileInfo *>
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Copy_opt@PAUPkgFileInfo@Ogre@@PAU12@Uforward_iterator_tag@std@@@std@@YAPAUPkgFileInfo@Ogre@@PAU12@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<Ogre::PkgFileInfo *,Ogre::PkgFileInfo *,std::forward_iterator_tag>
	add	esp, 24					; 00000018H

; 2486 : 	return _Result;

	mov	eax, DWORD PTR __Result$[ebp]

; 2487 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Copy_opt@PAUPkgFileInfo@Ogre@@PAU12@@std@@YAPAUPkgFileInfo@Ogre@@PAU12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<Ogre::PkgFileInfo *,Ogre::PkgFileInfo *>
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PAUPkgFileInfo@Ogre@@PAU12@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@YAPAUPkgFileInfo@Ogre@@PAU12@00AAV?$allocator@UPkgFileInfo@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Ogre::PkgFileInfo *,Ogre::PkgFileInfo *,std::allocator<Ogre::PkgFileInfo> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_copy@PAUPkgFileInfo@Ogre@@PAU12@V?$allocator@UPkgFileInfo@Ogre@@@std@@@stdext@@YAPAUPkgFileInfo@Ogre@@PAU12@00AAV?$allocator@UPkgFileInfo@Ogre@@@std@@@Z
_TEXT	SEGMENT
$T124812 = -2						; size = 1
$T124811 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@PAUPkgFileInfo@Ogre@@PAU12@V?$allocator@UPkgFileInfo@Ogre@@@std@@@stdext@@YAPAUPkgFileInfo@Ogre@@PAU12@00AAV?$allocator@UPkgFileInfo@Ogre@@@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<Ogre::PkgFileInfo *,Ogre::PkgFileInfo *,std::allocator<Ogre::PkgFileInfo> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T124811[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAUPkgFileInfo@Ogre@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUPkgFileInfo@Ogre@@0@Z ; std::_Ptr_cat<Ogre::PkgFileInfo *,Ogre::PkgFileInfo *>
	add	esp, 8
	mov	BYTE PTR $T124812[ebp], al
	movzx	eax, BYTE PTR $T124811[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T124812[ebp]
	push	ecx
	mov	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@PAUPkgFileInfo@Ogre@@@std@@YAPAUPkgFileInfo@Ogre@@AAPAU12@@Z ; std::_Checked_base<Ogre::PkgFileInfo *>
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@PAUPkgFileInfo@Ogre@@@std@@YAPAUPkgFileInfo@Ogre@@AAPAU12@@Z ; std::_Checked_base<Ogre::PkgFileInfo *>
	add	esp, 4
	push	eax
	call	??$_Uninit_copy@PAUPkgFileInfo@Ogre@@PAU12@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@YAPAUPkgFileInfo@Ogre@@PAU12@00AAV?$allocator@UPkgFileInfo@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Ogre::PkgFileInfo *,Ogre::PkgFileInfo *,std::allocator<Ogre::PkgFileInfo> >
	add	esp, 24					; 00000018H

; 823  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_copy@PAUPkgFileInfo@Ogre@@PAU12@V?$allocator@UPkgFileInfo@Ogre@@@std@@@stdext@@YAPAUPkgFileInfo@Ogre@@PAU12@00AAV?$allocator@UPkgFileInfo@Ogre@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<Ogre::PkgFileInfo *,Ogre::PkgFileInfo *,std::allocator<Ogre::PkgFileInfo> >
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PBQAVPackageDataStreamObject@Ogre@@PAPAV12@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@YAPAPAVPackageDataStreamObject@Ogre@@PBQAV12@0PAPAV12@AAV?$allocator@PAVPackageDataStreamObject@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Ogre::PackageDataStreamObject * const *,Ogre::PackageDataStreamObject * *,std::allocator<Ogre::PackageDataStreamObject *> >
PUBLIC	??$_Checked_base@V?$_Vector_const_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@@std@@YAPBQAVPackageDataStreamObject@Ogre@@AAV?$_Vector_const_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> > >
PUBLIC	??$_Ptr_cat@V?$_Vector_const_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@PAPAVPackageDataStreamObject@Ogre@@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@0@AAPAPAVPackageDataStreamObject@Ogre@@@Z ; std::_Ptr_cat<std::_Vector_const_iterator<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >,Ogre::PackageDataStreamObject * *>
; Function compile flags: /Odtp
;	COMDAT ??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@PAPAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@2@@stdext@@YAPAPAVPackageDataStreamObject@Ogre@@V?$_Vector_const_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@0PAPAV12@AAV?$allocator@PAVPackageDataStreamObject@Ogre@@@4@@Z
_TEXT	SEGMENT
$T124816 = -2						; size = 1
$T124815 = -1						; size = 1
__First$ = 8						; size = 8
__Last$ = 16						; size = 8
__Dest$ = 24						; size = 4
__Al$ = 28						; size = 4
??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@PAPAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@2@@stdext@@YAPAPAVPackageDataStreamObject@Ogre@@V?$_Vector_const_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@0PAPAV12@AAV?$allocator@PAVPackageDataStreamObject@Ogre@@@4@@Z PROC ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >,Ogre::PackageDataStreamObject * *,std::allocator<Ogre::PackageDataStreamObject *> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T124815[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@V?$_Vector_const_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@PAPAVPackageDataStreamObject@Ogre@@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@0@AAPAPAVPackageDataStreamObject@Ogre@@@Z ; std::_Ptr_cat<std::_Vector_const_iterator<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >,Ogre::PackageDataStreamObject * *>
	add	esp, 8
	mov	BYTE PTR $T124816[ebp], al
	movzx	eax, BYTE PTR $T124815[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T124816[ebp]
	push	ecx
	mov	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@V?$_Vector_const_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@@std@@YAPBQAVPackageDataStreamObject@Ogre@@AAV?$_Vector_const_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> > >
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@V?$_Vector_const_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@@std@@YAPBQAVPackageDataStreamObject@Ogre@@AAV?$_Vector_const_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> > >
	add	esp, 4
	push	eax
	call	??$_Uninit_copy@PBQAVPackageDataStreamObject@Ogre@@PAPAV12@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@YAPAPAVPackageDataStreamObject@Ogre@@PBQAV12@0PAPAV12@AAV?$allocator@PAVPackageDataStreamObject@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Ogre::PackageDataStreamObject * const *,Ogre::PackageDataStreamObject * *,std::allocator<Ogre::PackageDataStreamObject *> >
	add	esp, 24					; 00000018H

; 823  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@PAPAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@2@@stdext@@YAPAPAVPackageDataStreamObject@Ogre@@V?$_Vector_const_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@0PAPAV12@AAV?$allocator@PAVPackageDataStreamObject@Ogre@@@4@@Z ENDP ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >,Ogre::PackageDataStreamObject * *,std::allocator<Ogre::PackageDataStreamObject *> >
_TEXT	ENDS
PUBLIC	??$_Checked_base@PAPAVPackageDataStreamObject@Ogre@@@std@@YAPAPAVPackageDataStreamObject@Ogre@@AAPAPAV12@U_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<Ogre::PackageDataStreamObject * *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Checked_base@PAPAVPackageDataStreamObject@Ogre@@@std@@YAPAPAVPackageDataStreamObject@Ogre@@AAPAPAV12@@Z
_TEXT	SEGMENT
__Base_tag$ = -1					; size = 1
__It$ = 8						; size = 4
??$_Checked_base@PAPAVPackageDataStreamObject@Ogre@@@std@@YAPAPAVPackageDataStreamObject@Ogre@@AAPAPAV12@@Z PROC ; std::_Checked_base<Ogre::PackageDataStreamObject * *>, COMDAT

; 1163 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1164 : 		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
; 1165 : 		return _Checked_base(_It, _Base_tag);

	movzx	eax, BYTE PTR __Base_tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR __It$[ebp]
	push	ecx
	call	??$_Checked_base@PAPAVPackageDataStreamObject@Ogre@@@std@@YAPAPAVPackageDataStreamObject@Ogre@@AAPAPAV12@U_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<Ogre::PackageDataStreamObject * *>
	add	esp, 8

; 1166 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Checked_base@PAPAVPackageDataStreamObject@Ogre@@@std@@YAPAPAVPackageDataStreamObject@Ogre@@AAPAPAV12@@Z ENDP ; std::_Checked_base<Ogre::PackageDataStreamObject * *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Iter_random@PAPAVPackageDataStreamObject@Ogre@@PAPAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVPackageDataStreamObject@Ogre@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAPAVPackageDataStreamObject@Ogre@@PAPAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVPackageDataStreamObject@Ogre@@0@Z PROC ; std::_Iter_random<Ogre::PackageDataStreamObject * *,Ogre::PackageDataStreamObject * *>, COMDAT

; 993  : 	{	// return category from iterator argument

	push	ebp
	mov	ebp, esp
	push	ecx

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 998  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Iter_random@PAPAVPackageDataStreamObject@Ogre@@PAPAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVPackageDataStreamObject@Ogre@@0@Z ENDP ; std::_Iter_random<Ogre::PackageDataStreamObject * *,Ogre::PackageDataStreamObject * *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAPAVPackageDataStreamObject@Ogre@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVPackageDataStreamObject@Ogre@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAPAVPackageDataStreamObject@Ogre@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVPackageDataStreamObject@Ogre@@0@Z PROC ; std::_Ptr_cat<Ogre::PackageDataStreamObject * *,Ogre::PackageDataStreamObject * *>, COMDAT

; 1509 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 1512 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Ptr_cat@PAPAVPackageDataStreamObject@Ogre@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVPackageDataStreamObject@Ogre@@0@Z ENDP ; std::_Ptr_cat<Ogre::PackageDataStreamObject * *,Ogre::PackageDataStreamObject * *>
_TEXT	ENDS
EXTRN	__imp__memmove_s:PROC
; Function compile flags: /Odtp
;	COMDAT ??$_Copy_opt@PAPAVPackageDataStreamObject@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@@std@@YAPAPAVPackageDataStreamObject@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Off$ = -8						; size = 4
__Result$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAPAVPackageDataStreamObject@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@@std@@YAPAPAVPackageDataStreamObject@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<Ogre::PackageDataStreamObject * *,Ogre::PackageDataStreamObject * *,std::random_access_iterator_tag>, COMDAT

; 2494 : 	{	// copy [_First, _Last) to [_Dest, ...), pointers to scalars

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 2495 : 
; 2496 :  #if _HAS_ITERATOR_DEBUGGING
; 2497 : 	_DEBUG_RANGE(_First, _Last);
; 2498 : 	if (_First != _Last)
; 2499 : 		_DEBUG_POINTER(_Dest);
; 2500 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2501 : 
; 2502 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 2
	mov	DWORD PTR __Off$[ebp], eax

; 2503 : 	// if _OutIt is range checked, this will make sure there is enough space for the memmove
; 2504 : 	_OutIt _Result = _Dest + _Off;

	mov	ecx, DWORD PTR __Off$[ebp]
	mov	edx, DWORD PTR __Dest$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR __Result$[ebp], eax

; 2505 : 	if (_Off > 0)

	cmp	DWORD PTR __Off$[ebp], 0
	jle	SHORT $LN1@Copy_opt

; 2506 : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Off * sizeof (*_First), &*_First, _Off * sizeof (*_First));

	mov	ecx, DWORD PTR __Off$[ebp]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	eax, DWORD PTR __Off$[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN1@Copy_opt:

; 2507 : 	return _Result;

	mov	eax, DWORD PTR __Result$[ebp]

; 2508 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Copy_opt@PAPAVPackageDataStreamObject@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@@std@@YAPAPAVPackageDataStreamObject@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<Ogre::PackageDataStreamObject * *,Ogre::PackageDataStreamObject * *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PAPAVPackageDataStreamObject@Ogre@@PAPAV12@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@YAPAPAVPackageDataStreamObject@Ogre@@PAPAV12@00AAV?$allocator@PAVPackageDataStreamObject@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Ogre::PackageDataStreamObject * *,Ogre::PackageDataStreamObject * *,std::allocator<Ogre::PackageDataStreamObject *> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_copy@PAPAVPackageDataStreamObject@Ogre@@PAPAV12@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@stdext@@YAPAPAVPackageDataStreamObject@Ogre@@PAPAV12@00AAV?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@Z
_TEXT	SEGMENT
$T124828 = -2						; size = 1
$T124827 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@PAPAVPackageDataStreamObject@Ogre@@PAPAV12@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@stdext@@YAPAPAVPackageDataStreamObject@Ogre@@PAPAV12@00AAV?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<Ogre::PackageDataStreamObject * *,Ogre::PackageDataStreamObject * *,std::allocator<Ogre::PackageDataStreamObject *> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T124827[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAPAVPackageDataStreamObject@Ogre@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVPackageDataStreamObject@Ogre@@0@Z ; std::_Ptr_cat<Ogre::PackageDataStreamObject * *,Ogre::PackageDataStreamObject * *>
	add	esp, 8
	mov	BYTE PTR $T124828[ebp], al
	movzx	eax, BYTE PTR $T124827[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T124828[ebp]
	push	ecx
	mov	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@PAPAVPackageDataStreamObject@Ogre@@@std@@YAPAPAVPackageDataStreamObject@Ogre@@AAPAPAV12@@Z ; std::_Checked_base<Ogre::PackageDataStreamObject * *>
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@PAPAVPackageDataStreamObject@Ogre@@@std@@YAPAPAVPackageDataStreamObject@Ogre@@AAPAPAV12@@Z ; std::_Checked_base<Ogre::PackageDataStreamObject * *>
	add	esp, 4
	push	eax
	call	??$_Uninit_copy@PAPAVPackageDataStreamObject@Ogre@@PAPAV12@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@YAPAPAVPackageDataStreamObject@Ogre@@PAPAV12@00AAV?$allocator@PAVPackageDataStreamObject@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Ogre::PackageDataStreamObject * *,Ogre::PackageDataStreamObject * *,std::allocator<Ogre::PackageDataStreamObject *> >
	add	esp, 24					; 00000018H

; 823  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_copy@PAPAVPackageDataStreamObject@Ogre@@PAPAV12@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@stdext@@YAPAPAVPackageDataStreamObject@Ogre@@PAPAV12@00AAV?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<Ogre::PackageDataStreamObject * *,Ogre::PackageDataStreamObject * *,std::allocator<Ogre::PackageDataStreamObject *> >
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@UPkgFileInfo@Ogre@@@std@@QAEXPAUPkgFileInfo@Ogre@@@Z ; std::allocator<Ogre::PkgFileInfo>::destroy
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@YAXPAUPkgFileInfo@Ogre@@0AAV?$allocator@UPkgFileInfo@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@YAXPAUPkgFileInfo@Ogre@@0AAV?$allocator@UPkgFileInfo@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<Ogre::PkgFileInfo> >, COMDAT

; 232  : 	{	// destroy [_First, _Last), arbitrary type

	push	ebp
	mov	ebp, esp

; 233  : 	for (; _First != _Last; ++_First)

	jmp	SHORT $LN3@Destroy_ra
$LN2@Destroy_ra:
	mov	eax, DWORD PTR __First$[ebp]
	add	eax, 24					; 00000018H
	mov	DWORD PTR __First$[ebp], eax
$LN3@Destroy_ra:
	mov	ecx, DWORD PTR __First$[ebp]
	cmp	ecx, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Destroy_ra

; 234  : 		_Al.destroy(_First);

	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?destroy@?$allocator@UPkgFileInfo@Ogre@@@std@@QAEXPAUPkgFileInfo@Ogre@@@Z ; std::allocator<Ogre::PkgFileInfo>::destroy
	jmp	SHORT $LN2@Destroy_ra
$LN4@Destroy_ra:

; 235  : 	}

	pop	ebp
	ret	0
??$_Destroy_range@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@YAXPAUPkgFileInfo@Ogre@@0AAV?$allocator@UPkgFileInfo@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<Ogre::PkgFileInfo> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@YAXPAPAVPackageDataStreamObject@Ogre@@0AAV?$allocator@PAVPackageDataStreamObject@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@YAXPAPAVPackageDataStreamObject@Ogre@@0AAV?$allocator@PAVPackageDataStreamObject@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<Ogre::PackageDataStreamObject *> >, COMDAT

; 241  : 	{	// destroy [_First, _Last), scalar type (do nothing)

	push	ebp
	mov	ebp, esp

; 242  : 	}

	pop	ebp
	ret	0
??$_Destroy_range@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@YAXPAPAVPackageDataStreamObject@Ogre@@0AAV?$allocator@PAVPackageDataStreamObject@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<Ogre::PackageDataStreamObject *> >
_TEXT	ENDS
PUBLIC	??$unchecked_fill_n@PAPAVPackageDataStreamObject@Ogre@@IPAV12@@stdext@@YAXPAPAVPackageDataStreamObject@Ogre@@IABQAV12@@Z ; stdext::unchecked_fill_n<Ogre::PackageDataStreamObject * *,unsigned int,Ogre::PackageDataStreamObject *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Uninit_fill_n@PAPAVPackageDataStreamObject@Ogre@@IPAV12@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@YAXPAPAVPackageDataStreamObject@Ogre@@IABQAV12@AAV?$allocator@PAVPackageDataStreamObject@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_fill_n@PAPAVPackageDataStreamObject@Ogre@@IPAV12@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@YAXPAPAVPackageDataStreamObject@Ogre@@IABQAV12@AAV?$allocator@PAVPackageDataStreamObject@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<Ogre::PackageDataStreamObject * *,unsigned int,Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >, COMDAT

; 418  : 	{	// copy _Count *_Val to raw _First, using _Al, scalar type

	push	ebp
	mov	ebp, esp

; 419  : 		_STDEXT unchecked_fill_n(_First, _Count, _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$unchecked_fill_n@PAPAVPackageDataStreamObject@Ogre@@IPAV12@@stdext@@YAXPAPAVPackageDataStreamObject@Ogre@@IABQAV12@@Z ; stdext::unchecked_fill_n<Ogre::PackageDataStreamObject * *,unsigned int,Ogre::PackageDataStreamObject *>
	add	esp, 12					; 0000000cH

; 420  : 	}

	pop	ebp
	ret	0
??$_Uninit_fill_n@PAPAVPackageDataStreamObject@Ogre@@IPAV12@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@YAXPAPAVPackageDataStreamObject@Ogre@@IABQAV12@AAV?$allocator@PAVPackageDataStreamObject@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<Ogre::PackageDataStreamObject * *,unsigned int,Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >
_TEXT	ENDS
PUBLIC	??$_Uninit_move@PAUPkgFileInfo@Ogre@@PAU12@V?$allocator@UPkgFileInfo@Ogre@@@std@@U_Undefined_move_tag@4@@std@@YAPAUPkgFileInfo@Ogre@@PAU12@00AAV?$allocator@UPkgFileInfo@Ogre@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<Ogre::PkgFileInfo *,Ogre::PkgFileInfo *,std::allocator<Ogre::PkgFileInfo>,std::_Undefined_move_tag>
; Function compile flags: /Odtp
;	COMDAT ??$_Unchecked_uninitialized_move@PAUPkgFileInfo@Ogre@@PAU12@V?$allocator@UPkgFileInfo@Ogre@@@std@@@stdext@@YAPAUPkgFileInfo@Ogre@@PAU12@00AAV?$allocator@UPkgFileInfo@Ogre@@@std@@@Z
_TEXT	SEGMENT
$T124838 = -2						; size = 1
$T124837 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Unchecked_uninitialized_move@PAUPkgFileInfo@Ogre@@PAU12@V?$allocator@UPkgFileInfo@Ogre@@@std@@@stdext@@YAPAUPkgFileInfo@Ogre@@PAU12@00AAV?$allocator@UPkgFileInfo@Ogre@@@std@@@Z PROC ; stdext::_Unchecked_uninitialized_move<Ogre::PkgFileInfo *,Ogre::PkgFileInfo *,std::allocator<Ogre::PkgFileInfo> >, COMDAT

; 861  : 	{	// move [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 862  : 	return (_STD _Uninit_move(_CHECKED_BASE(_First),
; 863  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 864  : 		_STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T124837[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	??$_Move_cat@PAUPkgFileInfo@Ogre@@@std@@YA?AU_Undefined_move_tag@0@ABQAUPkgFileInfo@Ogre@@@Z ; std::_Move_cat<Ogre::PkgFileInfo *>
	add	esp, 4
	mov	BYTE PTR $T124838[ebp], al
	movzx	edx, BYTE PTR $T124837[ebp]
	push	edx
	movzx	eax, BYTE PTR $T124838[ebp]
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	call	??$_Checked_base@PAUPkgFileInfo@Ogre@@@std@@YAPAUPkgFileInfo@Ogre@@AAPAU12@@Z ; std::_Checked_base<Ogre::PkgFileInfo *>
	add	esp, 4
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Checked_base@PAUPkgFileInfo@Ogre@@@std@@YAPAUPkgFileInfo@Ogre@@AAPAU12@@Z ; std::_Checked_base<Ogre::PkgFileInfo *>
	add	esp, 4
	push	eax
	call	??$_Uninit_move@PAUPkgFileInfo@Ogre@@PAU12@V?$allocator@UPkgFileInfo@Ogre@@@std@@U_Undefined_move_tag@4@@std@@YAPAUPkgFileInfo@Ogre@@PAU12@00AAV?$allocator@UPkgFileInfo@Ogre@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<Ogre::PkgFileInfo *,Ogre::PkgFileInfo *,std::allocator<Ogre::PkgFileInfo>,std::_Undefined_move_tag>
	add	esp, 24					; 00000018H

; 865  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Unchecked_uninitialized_move@PAUPkgFileInfo@Ogre@@PAU12@V?$allocator@UPkgFileInfo@Ogre@@@std@@@stdext@@YAPAUPkgFileInfo@Ogre@@PAU12@00AAV?$allocator@UPkgFileInfo@Ogre@@@std@@@Z ENDP ; stdext::_Unchecked_uninitialized_move<Ogre::PkgFileInfo *,Ogre::PkgFileInfo *,std::allocator<Ogre::PkgFileInfo> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Fill@PAUPkgFileInfo@Ogre@@U12@@std@@YAXPAUPkgFileInfo@Ogre@@0ABU12@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$_Fill@PAUPkgFileInfo@Ogre@@U12@@std@@YAXPAUPkgFileInfo@Ogre@@0ABU12@@Z PROC ; std::_Fill<Ogre::PkgFileInfo *,Ogre::PkgFileInfo>, COMDAT

; 3156 : 	{	// copy _Val through [_First, _Last)

	push	ebp
	mov	ebp, esp

; 3157 : 	_DEBUG_RANGE(_First, _Last);
; 3158 : 	for (; _First != _Last; ++_First)

	jmp	SHORT $LN3@Fill
$LN2@Fill:
	mov	eax, DWORD PTR __First$[ebp]
	add	eax, 24					; 00000018H
	mov	DWORD PTR __First$[ebp], eax
$LN3@Fill:
	mov	ecx, DWORD PTR __First$[ebp]
	cmp	ecx, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Fill

; 3159 : 		*_First = _Val;

	mov	edx, DWORD PTR __Val$[ebp]
	mov	eax, DWORD PTR __First$[ebp]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], ecx
	mov	ecx, DWORD PTR [edx+12]
	mov	DWORD PTR [eax+12], ecx
	mov	ecx, DWORD PTR [edx+16]
	mov	DWORD PTR [eax+16], ecx
	mov	edx, DWORD PTR [edx+20]
	mov	DWORD PTR [eax+20], edx
	jmp	SHORT $LN2@Fill
$LN4@Fill:

; 3160 : 	}

	pop	ebp
	ret	0
??$_Fill@PAUPkgFileInfo@Ogre@@U12@@std@@YAXPAUPkgFileInfo@Ogre@@0ABU12@@Z ENDP ; std::_Fill<Ogre::PkgFileInfo *,Ogre::PkgFileInfo>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Move_cat@PAUPkgFileInfo@Ogre@@@std@@YA?AU_Undefined_move_tag@0@ABQAUPkgFileInfo@Ogre@@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
??$_Move_cat@PAUPkgFileInfo@Ogre@@@std@@YA?AU_Undefined_move_tag@0@ABQAUPkgFileInfo@Ogre@@@Z PROC ; std::_Move_cat<Ogre::PkgFileInfo *>, COMDAT

; 1200 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1201 : 		typename _Move_operation_category<typename iterator_traits<_Iter>::value_type>::_Move_cat _Cat;
; 1202 : 		return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 1203 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Move_cat@PAUPkgFileInfo@Ogre@@@std@@YA?AU_Undefined_move_tag@0@ABQAUPkgFileInfo@Ogre@@@Z ENDP ; std::_Move_cat<Ogre::PkgFileInfo *>
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@PAUPkgFileInfo@Ogre@@PAU12@@std@@YAPAUPkgFileInfo@Ogre@@PAU12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<Ogre::PkgFileInfo *,Ogre::PkgFileInfo *>
; Function compile flags: /Odtp
;	COMDAT ??$_Move_backward_opt@PAUPkgFileInfo@Ogre@@PAU12@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@4@@std@@YAPAUPkgFileInfo@Ogre@@PAU12@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T124846 = -2						; size = 1
$T124845 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__First_dest_cat$ = 20					; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Move_backward_opt@PAUPkgFileInfo@Ogre@@PAU12@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@4@@std@@YAPAUPkgFileInfo@Ogre@@PAU12@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Move_backward_opt<Ogre::PkgFileInfo *,Ogre::PkgFileInfo *,std::random_access_iterator_tag,std::_Undefined_move_tag>, COMDAT

; 2752 : 	{	// move defaults to copy if there is not a more effecient way

	push	ebp
	mov	ebp, esp
	push	ecx

; 2753 : 	return _Copy_backward_opt(_First, _Last, _Dest,
; 2754 : 		_First_dest_cat, _Ptr_cat(_First, _Dest), _Range_checked_iterator_tag());

	xor	eax, eax
	mov	BYTE PTR $T124845[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAUPkgFileInfo@Ogre@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUPkgFileInfo@Ogre@@0@Z ; std::_Ptr_cat<Ogre::PkgFileInfo *,Ogre::PkgFileInfo *>
	add	esp, 8
	mov	BYTE PTR $T124846[ebp], al
	movzx	eax, BYTE PTR $T124845[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T124846[ebp]
	push	ecx
	movzx	edx, BYTE PTR __First_dest_cat$[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Copy_backward_opt@PAUPkgFileInfo@Ogre@@PAU12@@std@@YAPAUPkgFileInfo@Ogre@@PAU12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<Ogre::PkgFileInfo *,Ogre::PkgFileInfo *>
	add	esp, 24					; 00000018H

; 2755 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Move_backward_opt@PAUPkgFileInfo@Ogre@@PAU12@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@4@@std@@YAPAUPkgFileInfo@Ogre@@PAU12@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Move_backward_opt<Ogre::PkgFileInfo *,Ogre::PkgFileInfo *,std::random_access_iterator_tag,std::_Undefined_move_tag>
_TEXT	ENDS
PUBLIC	??$_Uninit_move@PAPAVPackageDataStreamObject@Ogre@@PAPAV12@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@U_Undefined_move_tag@4@@std@@YAPAPAVPackageDataStreamObject@Ogre@@PAPAV12@00AAV?$allocator@PAVPackageDataStreamObject@Ogre@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<Ogre::PackageDataStreamObject * *,Ogre::PackageDataStreamObject * *,std::allocator<Ogre::PackageDataStreamObject *>,std::_Undefined_move_tag>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Unchecked_uninitialized_move@PAPAVPackageDataStreamObject@Ogre@@PAPAV12@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@stdext@@YAPAPAVPackageDataStreamObject@Ogre@@PAPAV12@00AAV?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@Z
_TEXT	SEGMENT
$T124850 = -2						; size = 1
$T124849 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Unchecked_uninitialized_move@PAPAVPackageDataStreamObject@Ogre@@PAPAV12@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@stdext@@YAPAPAVPackageDataStreamObject@Ogre@@PAPAV12@00AAV?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@Z PROC ; stdext::_Unchecked_uninitialized_move<Ogre::PackageDataStreamObject * *,Ogre::PackageDataStreamObject * *,std::allocator<Ogre::PackageDataStreamObject *> >, COMDAT

; 861  : 	{	// move [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 862  : 	return (_STD _Uninit_move(_CHECKED_BASE(_First),
; 863  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 864  : 		_STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T124849[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	??$_Move_cat@PAPAVPackageDataStreamObject@Ogre@@@std@@YA?AU_Undefined_move_tag@0@ABQAPAVPackageDataStreamObject@Ogre@@@Z ; std::_Move_cat<Ogre::PackageDataStreamObject * *>
	add	esp, 4
	mov	BYTE PTR $T124850[ebp], al
	movzx	edx, BYTE PTR $T124849[ebp]
	push	edx
	movzx	eax, BYTE PTR $T124850[ebp]
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	call	??$_Checked_base@PAPAVPackageDataStreamObject@Ogre@@@std@@YAPAPAVPackageDataStreamObject@Ogre@@AAPAPAV12@@Z ; std::_Checked_base<Ogre::PackageDataStreamObject * *>
	add	esp, 4
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Checked_base@PAPAVPackageDataStreamObject@Ogre@@@std@@YAPAPAVPackageDataStreamObject@Ogre@@AAPAPAV12@@Z ; std::_Checked_base<Ogre::PackageDataStreamObject * *>
	add	esp, 4
	push	eax
	call	??$_Uninit_move@PAPAVPackageDataStreamObject@Ogre@@PAPAV12@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@U_Undefined_move_tag@4@@std@@YAPAPAVPackageDataStreamObject@Ogre@@PAPAV12@00AAV?$allocator@PAVPackageDataStreamObject@Ogre@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<Ogre::PackageDataStreamObject * *,Ogre::PackageDataStreamObject * *,std::allocator<Ogre::PackageDataStreamObject *>,std::_Undefined_move_tag>
	add	esp, 24					; 00000018H

; 865  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Unchecked_uninitialized_move@PAPAVPackageDataStreamObject@Ogre@@PAPAV12@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@stdext@@YAPAPAVPackageDataStreamObject@Ogre@@PAPAV12@00AAV?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@Z ENDP ; stdext::_Unchecked_uninitialized_move<Ogre::PackageDataStreamObject * *,Ogre::PackageDataStreamObject * *,std::allocator<Ogre::PackageDataStreamObject *> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Fill@PAPAVPackageDataStreamObject@Ogre@@PAV12@@std@@YAXPAPAVPackageDataStreamObject@Ogre@@0ABQAV12@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$_Fill@PAPAVPackageDataStreamObject@Ogre@@PAV12@@std@@YAXPAPAVPackageDataStreamObject@Ogre@@0ABQAV12@@Z PROC ; std::_Fill<Ogre::PackageDataStreamObject * *,Ogre::PackageDataStreamObject *>, COMDAT

; 3156 : 	{	// copy _Val through [_First, _Last)

	push	ebp
	mov	ebp, esp

; 3157 : 	_DEBUG_RANGE(_First, _Last);
; 3158 : 	for (; _First != _Last; ++_First)

	jmp	SHORT $LN3@Fill@2
$LN2@Fill@2:
	mov	eax, DWORD PTR __First$[ebp]
	add	eax, 4
	mov	DWORD PTR __First$[ebp], eax
$LN3@Fill@2:
	mov	ecx, DWORD PTR __First$[ebp]
	cmp	ecx, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Fill@2

; 3159 : 		*_First = _Val;

	mov	edx, DWORD PTR __First$[ebp]
	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	jmp	SHORT $LN2@Fill@2
$LN4@Fill@2:

; 3160 : 	}

	pop	ebp
	ret	0
??$_Fill@PAPAVPackageDataStreamObject@Ogre@@PAV12@@std@@YAXPAPAVPackageDataStreamObject@Ogre@@0ABQAV12@@Z ENDP ; std::_Fill<Ogre::PackageDataStreamObject * *,Ogre::PackageDataStreamObject *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Move_cat@PAPAVPackageDataStreamObject@Ogre@@@std@@YA?AU_Undefined_move_tag@0@ABQAPAVPackageDataStreamObject@Ogre@@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
??$_Move_cat@PAPAVPackageDataStreamObject@Ogre@@@std@@YA?AU_Undefined_move_tag@0@ABQAPAVPackageDataStreamObject@Ogre@@@Z PROC ; std::_Move_cat<Ogre::PackageDataStreamObject * *>, COMDAT

; 1200 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1201 : 		typename _Move_operation_category<typename iterator_traits<_Iter>::value_type>::_Move_cat _Cat;
; 1202 : 		return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 1203 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Move_cat@PAPAVPackageDataStreamObject@Ogre@@@std@@YA?AU_Undefined_move_tag@0@ABQAPAVPackageDataStreamObject@Ogre@@@Z ENDP ; std::_Move_cat<Ogre::PackageDataStreamObject * *>
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@PAPAVPackageDataStreamObject@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@@std@@YAPAPAVPackageDataStreamObject@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<Ogre::PackageDataStreamObject * *,Ogre::PackageDataStreamObject * *,std::random_access_iterator_tag>
; Function compile flags: /Odtp
;	COMDAT ??$_Move_backward_opt@PAPAVPackageDataStreamObject@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@4@@std@@YAPAPAVPackageDataStreamObject@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T124858 = -2						; size = 1
$T124857 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__First_dest_cat$ = 20					; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Move_backward_opt@PAPAVPackageDataStreamObject@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@4@@std@@YAPAPAVPackageDataStreamObject@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Move_backward_opt<Ogre::PackageDataStreamObject * *,Ogre::PackageDataStreamObject * *,std::random_access_iterator_tag,std::_Undefined_move_tag>, COMDAT

; 2752 : 	{	// move defaults to copy if there is not a more effecient way

	push	ebp
	mov	ebp, esp
	push	ecx

; 2753 : 	return _Copy_backward_opt(_First, _Last, _Dest,
; 2754 : 		_First_dest_cat, _Ptr_cat(_First, _Dest), _Range_checked_iterator_tag());

	xor	eax, eax
	mov	BYTE PTR $T124857[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAPAVPackageDataStreamObject@Ogre@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVPackageDataStreamObject@Ogre@@0@Z ; std::_Ptr_cat<Ogre::PackageDataStreamObject * *,Ogre::PackageDataStreamObject * *>
	add	esp, 8
	mov	BYTE PTR $T124858[ebp], al
	movzx	eax, BYTE PTR $T124857[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T124858[ebp]
	push	ecx
	movzx	edx, BYTE PTR __First_dest_cat$[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Copy_backward_opt@PAPAVPackageDataStreamObject@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@@std@@YAPAPAVPackageDataStreamObject@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<Ogre::PackageDataStreamObject * *,Ogre::PackageDataStreamObject * *,std::random_access_iterator_tag>
	add	esp, 24					; 00000018H

; 2755 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Move_backward_opt@PAPAVPackageDataStreamObject@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@4@@std@@YAPAPAVPackageDataStreamObject@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Move_backward_opt<Ogre::PackageDataStreamObject * *,Ogre::PackageDataStreamObject * *,std::random_access_iterator_tag,std::_Undefined_move_tag>
_TEXT	ENDS
PUBLIC	?construct@?$allocator@UPkgFileInfo@Ogre@@@std@@QAEXPAUPkgFileInfo@Ogre@@ABU34@@Z ; std::allocator<Ogre::PkgFileInfo>::construct
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	SEGMENT
__catchsym$??$_Uninit_fill_n@PAUPkgFileInfo@Ogre@@IU12@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@YAXPAUPkgFileInfo@Ogre@@IABU12@AAV?$allocator@UPkgFileInfo@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_fill_n@PAUPkgFileInfo@Ogre@@IU12@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@YAXPAUPkgFileInfo@Ogre@@IABU12@AAV?$allocator@UPkgFileInfo@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__unwindtable$??$_Uninit_fill_n@PAUPkgFileInfo@Ogre@@IU12@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@YAXPAUPkgFileInfo@Ogre@@IABU12@AAV?$allocator@UPkgFileInfo@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Uninit_fill_n@PAUPkgFileInfo@Ogre@@IU12@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@YAXPAUPkgFileInfo@Ogre@@IABU12@AAV?$allocator@UPkgFileInfo@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_fill_n@PAUPkgFileInfo@Ogre@@IU12@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@YAXPAUPkgFileInfo@Ogre@@IABU12@AAV?$allocator@UPkgFileInfo@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2
__ehfuncinfo$??$_Uninit_fill_n@PAUPkgFileInfo@Ogre@@IU12@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@YAXPAUPkgFileInfo@Ogre@@IABU12@AAV?$allocator@UPkgFileInfo@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Uninit_fill_n@PAUPkgFileInfo@Ogre@@IU12@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@YAXPAUPkgFileInfo@Ogre@@IABU12@AAV?$allocator@UPkgFileInfo@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_fill_n@PAUPkgFileInfo@Ogre@@IU12@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@YAXPAUPkgFileInfo@Ogre@@IABU12@AAV?$allocator@UPkgFileInfo@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??$_Uninit_fill_n@PAUPkgFileInfo@Ogre@@IU12@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@YAXPAUPkgFileInfo@Ogre@@IABU12@AAV?$allocator@UPkgFileInfo@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_fill_n@PAUPkgFileInfo@Ogre@@IU12@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@YAXPAUPkgFileInfo@Ogre@@IABU12@AAV?$allocator@UPkgFileInfo@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<Ogre::PkgFileInfo *,unsigned int,Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >, COMDAT

; 393  : 	{	// copy _Count *_Val to raw _First, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_fill_n@PAUPkgFileInfo@Ogre@@IU12@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@YAXPAUPkgFileInfo@Ogre@@IABU12@AAV?$allocator@UPkgFileInfo@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 394  : 
; 395  :  #if _HAS_ITERATOR_DEBUGGING
; 396  : //	if (_Count < 0)
; 397  : //		_DEBUG_ERROR("negative count in uninitialized fill");
; 398  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 399  : 
; 400  : 	_FwdIt _Next = _First;

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Next$[ebp], eax

; 401  : 
; 402  : 	_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 403  : 	for (; 0 < _Count; --_Count, ++_First)

	jmp	SHORT $LN6@Uninit_fil
$LN5@Uninit_fil:
	mov	ecx, DWORD PTR __Count$[ebp]
	sub	ecx, 1
	mov	DWORD PTR __Count$[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	add	edx, 24					; 00000018H
	mov	DWORD PTR __First$[ebp], edx
$LN6@Uninit_fil:
	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN4@Uninit_fil

; 404  : 		_Al.construct(_First, _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?construct@?$allocator@UPkgFileInfo@Ogre@@@std@@QAEXPAUPkgFileInfo@Ogre@@ABU34@@Z ; std::allocator<Ogre::PkgFileInfo>::construct
	jmp	SHORT $LN5@Uninit_fil
$LN4@Uninit_fil:
	jmp	SHORT $LN10@Uninit_fil
__catch$??$_Uninit_fill_n@PAUPkgFileInfo@Ogre@@IU12@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@YAXPAUPkgFileInfo@Ogre@@IABU12@AAV?$allocator@UPkgFileInfo@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 405  : 	_CATCH_ALL
; 406  : 	for (; _Next != _First; ++_Next)

	jmp	SHORT $LN3@Uninit_fil
$LN2@Uninit_fil:
	mov	edx, DWORD PTR __Next$[ebp]
	add	edx, 24					; 00000018H
	mov	DWORD PTR __Next$[ebp], edx
$LN3@Uninit_fil:
	mov	eax, DWORD PTR __Next$[ebp]
	cmp	eax, DWORD PTR __First$[ebp]
	je	SHORT $LN1@Uninit_fil

; 407  : 		_Al.destroy(_Next);

	mov	ecx, DWORD PTR __Next$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?destroy@?$allocator@UPkgFileInfo@Ogre@@@std@@QAEXPAUPkgFileInfo@Ogre@@@Z ; std::allocator<Ogre::PkgFileInfo>::destroy
	jmp	SHORT $LN2@Uninit_fil
$LN1@Uninit_fil:

; 408  : 	_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 409  : 	_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, $LN9@Uninit_fil
	ret	0
$LN10@Uninit_fil:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
$LN9@Uninit_fil:

; 410  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_fill_n@PAUPkgFileInfo@Ogre@@IU12@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@YAXPAUPkgFileInfo@Ogre@@IABU12@AAV?$allocator@UPkgFileInfo@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_fill_n@PAUPkgFileInfo@Ogre@@IU12@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@YAXPAUPkgFileInfo@Ogre@@IABU12@AAV?$allocator@UPkgFileInfo@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_fill_n@PAUPkgFileInfo@Ogre@@IU12@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@YAXPAUPkgFileInfo@Ogre@@IABU12@AAV?$allocator@UPkgFileInfo@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<Ogre::PkgFileInfo *,unsigned int,Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >
PUBLIC	??$_Construct@UPkgFileInfo@Ogre@@U12@@std@@YAXPAUPkgFileInfo@Ogre@@ABU12@@Z ; std::_Construct<Ogre::PkgFileInfo,Ogre::PkgFileInfo>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?construct@?$allocator@UPkgFileInfo@Ogre@@@std@@QAEXPAUPkgFileInfo@Ogre@@ABU34@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@UPkgFileInfo@Ogre@@@std@@QAEXPAUPkgFileInfo@Ogre@@ABU34@@Z PROC ; std::allocator<Ogre::PkgFileInfo>::construct, COMDAT
; _this$ = ecx

; 154  : 		{	// construct object at _Ptr with value _Val

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 155  : 		_Construct(_Ptr, _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	call	??$_Construct@UPkgFileInfo@Ogre@@U12@@std@@YAXPAUPkgFileInfo@Ogre@@ABU12@@Z ; std::_Construct<Ogre::PkgFileInfo,Ogre::PkgFileInfo>
	add	esp, 8

; 156  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?construct@?$allocator@UPkgFileInfo@Ogre@@@std@@QAEXPAUPkgFileInfo@Ogre@@ABU34@@Z ENDP ; std::allocator<Ogre::PkgFileInfo>::construct
_TEXT	ENDS
PUBLIC	??$_Destroy@UPkgFileInfo@Ogre@@@std@@YAXPAUPkgFileInfo@Ogre@@@Z ; std::_Destroy<Ogre::PkgFileInfo>
; Function compile flags: /Odtp
;	COMDAT ?destroy@?$allocator@UPkgFileInfo@Ogre@@@std@@QAEXPAUPkgFileInfo@Ogre@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?destroy@?$allocator@UPkgFileInfo@Ogre@@@std@@QAEXPAUPkgFileInfo@Ogre@@@Z PROC ; std::allocator<Ogre::PkgFileInfo>::destroy, COMDAT
; _this$ = ecx

; 159  : 		{	// destroy object at _Ptr

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 160  : 		_Destroy(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??$_Destroy@UPkgFileInfo@Ogre@@@std@@YAXPAUPkgFileInfo@Ogre@@@Z ; std::_Destroy<Ogre::PkgFileInfo>
	add	esp, 4

; 161  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?destroy@?$allocator@UPkgFileInfo@Ogre@@@std@@QAEXPAUPkgFileInfo@Ogre@@@Z ENDP ; std::allocator<Ogre::PkgFileInfo>::destroy
_TEXT	ENDS
PUBLIC	??$_Checked_base@V?$_Vector_const_iterator@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBUPkgFileInfo@Ogre@@AAV?$_Vector_const_iterator@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >,std::_Different_checked_iterator_base_type_tag>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Checked_base@V?$_Vector_const_iterator@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@@std@@YAPBUPkgFileInfo@Ogre@@AAV?$_Vector_const_iterator@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@0@@Z
_TEXT	SEGMENT
__Base_tag$ = -1					; size = 1
__It$ = 8						; size = 4
??$_Checked_base@V?$_Vector_const_iterator@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@@std@@YAPBUPkgFileInfo@Ogre@@AAV?$_Vector_const_iterator@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@0@@Z PROC ; std::_Checked_base<std::_Vector_const_iterator<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> > >, COMDAT

; 1163 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1164 : 		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
; 1165 : 		return _Checked_base(_It, _Base_tag);

	movzx	eax, BYTE PTR __Base_tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR __It$[ebp]
	push	ecx
	call	??$_Checked_base@V?$_Vector_const_iterator@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBUPkgFileInfo@Ogre@@AAV?$_Vector_const_iterator@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >,std::_Different_checked_iterator_base_type_tag>
	add	esp, 8

; 1166 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Checked_base@V?$_Vector_const_iterator@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@@std@@YAPBUPkgFileInfo@Ogre@@AAV?$_Vector_const_iterator@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@0@@Z ENDP ; std::_Checked_base<std::_Vector_const_iterator<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> > >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@V?$_Vector_const_iterator@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@PAUPkgFileInfo@Ogre@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@0@AAPAUPkgFileInfo@Ogre@@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@V?$_Vector_const_iterator@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@PAUPkgFileInfo@Ogre@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@0@AAPAUPkgFileInfo@Ogre@@@Z PROC ; std::_Ptr_cat<std::_Vector_const_iterator<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >,Ogre::PkgFileInfo *>, COMDAT

; 1509 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 1512 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Ptr_cat@V?$_Vector_const_iterator@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@PAUPkgFileInfo@Ogre@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@0@AAPAUPkgFileInfo@Ogre@@@Z ENDP ; std::_Ptr_cat<std::_Vector_const_iterator<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >,Ogre::PkgFileInfo *>
_TEXT	ENDS
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	SEGMENT
__catchsym$??$_Uninit_copy@PBUPkgFileInfo@Ogre@@PAU12@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@YAPAUPkgFileInfo@Ogre@@PBU12@0PAU12@AAV?$allocator@UPkgFileInfo@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_copy@PBUPkgFileInfo@Ogre@@PAU12@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@YAPAUPkgFileInfo@Ogre@@PBU12@0PAU12@AAV?$allocator@UPkgFileInfo@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__unwindtable$??$_Uninit_copy@PBUPkgFileInfo@Ogre@@PAU12@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@YAPAUPkgFileInfo@Ogre@@PBU12@0PAU12@AAV?$allocator@UPkgFileInfo@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Uninit_copy@PBUPkgFileInfo@Ogre@@PAU12@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@YAPAUPkgFileInfo@Ogre@@PBU12@0PAU12@AAV?$allocator@UPkgFileInfo@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_copy@PBUPkgFileInfo@Ogre@@PAU12@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@YAPAUPkgFileInfo@Ogre@@PBU12@0PAU12@AAV?$allocator@UPkgFileInfo@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2
__ehfuncinfo$??$_Uninit_copy@PBUPkgFileInfo@Ogre@@PAU12@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@YAPAUPkgFileInfo@Ogre@@PBU12@0PAU12@AAV?$allocator@UPkgFileInfo@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Uninit_copy@PBUPkgFileInfo@Ogre@@PAU12@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@YAPAUPkgFileInfo@Ogre@@PBU12@0PAU12@AAV?$allocator@UPkgFileInfo@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_copy@PBUPkgFileInfo@Ogre@@PAU12@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@YAPAUPkgFileInfo@Ogre@@PBU12@0PAU12@AAV?$allocator@UPkgFileInfo@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??$_Uninit_copy@PBUPkgFileInfo@Ogre@@PAU12@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@YAPAUPkgFileInfo@Ogre@@PBU12@0PAU12@AAV?$allocator@UPkgFileInfo@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PBUPkgFileInfo@Ogre@@PAU12@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@YAPAUPkgFileInfo@Ogre@@PBU12@0PAU12@AAV?$allocator@UPkgFileInfo@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<Ogre::PkgFileInfo const *,Ogre::PkgFileInfo *,std::allocator<Ogre::PkgFileInfo> >, COMDAT

; 124  : 	{	// copy [_First, _Last) to raw _Dest, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_copy@PBUPkgFileInfo@Ogre@@PAU12@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@YAPAUPkgFileInfo@Ogre@@PBU12@0PAU12@AAV?$allocator@UPkgFileInfo@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 125  : 	_DEBUG_RANGE(_First, _Last);
; 126  : 	_DEBUG_POINTER(_Dest);
; 127  : 	_FwdIt _Next = _Dest;

	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Next$[ebp], eax

; 128  : 
; 129  : 	_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 130  : 	for (; _First != _Last; ++_Dest, ++_First)

	jmp	SHORT $LN6@Uninit_cop
$LN5@Uninit_cop:
	mov	ecx, DWORD PTR __Dest$[ebp]
	add	ecx, 24					; 00000018H
	mov	DWORD PTR __Dest$[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	add	edx, 24					; 00000018H
	mov	DWORD PTR __First$[ebp], edx
$LN6@Uninit_cop:
	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Uninit_cop

; 131  : 		_Al.construct(_Dest, *_First);

	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?construct@?$allocator@UPkgFileInfo@Ogre@@@std@@QAEXPAUPkgFileInfo@Ogre@@ABU34@@Z ; std::allocator<Ogre::PkgFileInfo>::construct
	jmp	SHORT $LN5@Uninit_cop
$LN4@Uninit_cop:
	jmp	SHORT $LN10@Uninit_cop
__catch$??$_Uninit_copy@PBUPkgFileInfo@Ogre@@PAU12@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@YAPAUPkgFileInfo@Ogre@@PBU12@0PAU12@AAV?$allocator@UPkgFileInfo@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 132  : 	_CATCH_ALL
; 133  : 	for (; _Next != _Dest; ++_Next)

	jmp	SHORT $LN3@Uninit_cop
$LN2@Uninit_cop:
	mov	eax, DWORD PTR __Next$[ebp]
	add	eax, 24					; 00000018H
	mov	DWORD PTR __Next$[ebp], eax
$LN3@Uninit_cop:
	mov	ecx, DWORD PTR __Next$[ebp]
	cmp	ecx, DWORD PTR __Dest$[ebp]
	je	SHORT $LN1@Uninit_cop

; 134  : 		_Al.destroy(_Next);

	mov	edx, DWORD PTR __Next$[ebp]
	push	edx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?destroy@?$allocator@UPkgFileInfo@Ogre@@@std@@QAEXPAUPkgFileInfo@Ogre@@@Z ; std::allocator<Ogre::PkgFileInfo>::destroy
	jmp	SHORT $LN2@Uninit_cop
$LN1@Uninit_cop:

; 135  : 	_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 136  : 	_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$??$_Uninit_copy@PBUPkgFileInfo@Ogre@@PAU12@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@YAPAUPkgFileInfo@Ogre@@PBU12@0PAU12@AAV?$allocator@UPkgFileInfo@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1
	ret	0
$LN10@Uninit_cop:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Uninit_copy@PBUPkgFileInfo@Ogre@@PAU12@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@YAPAUPkgFileInfo@Ogre@@PBU12@0PAU12@AAV?$allocator@UPkgFileInfo@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1:

; 137  : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[ebp]
$LN9@Uninit_cop:

; 138  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_copy@PBUPkgFileInfo@Ogre@@PAU12@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@YAPAUPkgFileInfo@Ogre@@PBU12@0PAU12@AAV?$allocator@UPkgFileInfo@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_copy@PBUPkgFileInfo@Ogre@@PAU12@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@YAPAUPkgFileInfo@Ogre@@PBU12@0PAU12@AAV?$allocator@UPkgFileInfo@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_copy@PBUPkgFileInfo@Ogre@@PAU12@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@YAPAUPkgFileInfo@Ogre@@PBU12@0PAU12@AAV?$allocator@UPkgFileInfo@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<Ogre::PkgFileInfo const *,Ogre::PkgFileInfo *,std::allocator<Ogre::PkgFileInfo> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Checked_base@PAUPkgFileInfo@Ogre@@@std@@YAPAUPkgFileInfo@Ogre@@AAPAU12@U_Unchanged_checked_iterator_base_type_tag@0@@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Checked_base@PAUPkgFileInfo@Ogre@@@std@@YAPAUPkgFileInfo@Ogre@@AAPAU12@U_Unchanged_checked_iterator_base_type_tag@0@@Z PROC ; std::_Checked_base<Ogre::PkgFileInfo *>, COMDAT

; 1146 : 	{

	push	ebp
	mov	ebp, esp

; 1147 : 		return _It;

	mov	eax, DWORD PTR __It$[ebp]
	mov	eax, DWORD PTR [eax]

; 1148 : 	}

	pop	ebp
	ret	0
??$_Checked_base@PAUPkgFileInfo@Ogre@@@std@@YAPAUPkgFileInfo@Ogre@@AAPAU12@U_Unchanged_checked_iterator_base_type_tag@0@@Z ENDP ; std::_Checked_base<Ogre::PkgFileInfo *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Copy_opt@PAUPkgFileInfo@Ogre@@PAU12@Uforward_iterator_tag@std@@@std@@YAPAUPkgFileInfo@Ogre@@PAU12@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAUPkgFileInfo@Ogre@@PAU12@Uforward_iterator_tag@std@@@std@@YAPAUPkgFileInfo@Ogre@@PAU12@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<Ogre::PkgFileInfo *,Ogre::PkgFileInfo *,std::forward_iterator_tag>, COMDAT

; 2469 : 	{	// copy [_First, _Last) to [_Dest, ...), arbitrary iterators

	push	ebp
	mov	ebp, esp

; 2470 : 	_DEBUG_RANGE(_First, _Last);
; 2471 : 	for (; _First != _Last; ++_Dest, ++_First)

	jmp	SHORT $LN3@Copy_opt@2
$LN2@Copy_opt@2:
	mov	eax, DWORD PTR __Dest$[ebp]
	add	eax, 24					; 00000018H
	mov	DWORD PTR __Dest$[ebp], eax
	mov	ecx, DWORD PTR __First$[ebp]
	add	ecx, 24					; 00000018H
	mov	DWORD PTR __First$[ebp], ecx
$LN3@Copy_opt@2:
	mov	edx, DWORD PTR __First$[ebp]
	cmp	edx, DWORD PTR __Last$[ebp]
	je	SHORT $LN1@Copy_opt@2

; 2472 : 		*_Dest = *_First;

	mov	eax, DWORD PTR __First$[ebp]
	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], edx
	mov	edx, DWORD PTR [eax+16]
	mov	DWORD PTR [ecx+16], edx
	mov	eax, DWORD PTR [eax+20]
	mov	DWORD PTR [ecx+20], eax
	jmp	SHORT $LN2@Copy_opt@2
$LN1@Copy_opt@2:

; 2473 : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[ebp]

; 2474 : 	}

	pop	ebp
	ret	0
??$_Copy_opt@PAUPkgFileInfo@Ogre@@PAU12@Uforward_iterator_tag@std@@@std@@YAPAUPkgFileInfo@Ogre@@PAU12@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<Ogre::PkgFileInfo *,Ogre::PkgFileInfo *,std::forward_iterator_tag>
_TEXT	ENDS
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	SEGMENT
__catchsym$??$_Uninit_copy@PAUPkgFileInfo@Ogre@@PAU12@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@YAPAUPkgFileInfo@Ogre@@PAU12@00AAV?$allocator@UPkgFileInfo@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_copy@PAUPkgFileInfo@Ogre@@PAU12@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@YAPAUPkgFileInfo@Ogre@@PAU12@00AAV?$allocator@UPkgFileInfo@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__unwindtable$??$_Uninit_copy@PAUPkgFileInfo@Ogre@@PAU12@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@YAPAUPkgFileInfo@Ogre@@PAU12@00AAV?$allocator@UPkgFileInfo@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Uninit_copy@PAUPkgFileInfo@Ogre@@PAU12@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@YAPAUPkgFileInfo@Ogre@@PAU12@00AAV?$allocator@UPkgFileInfo@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_copy@PAUPkgFileInfo@Ogre@@PAU12@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@YAPAUPkgFileInfo@Ogre@@PAU12@00AAV?$allocator@UPkgFileInfo@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2
__ehfuncinfo$??$_Uninit_copy@PAUPkgFileInfo@Ogre@@PAU12@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@YAPAUPkgFileInfo@Ogre@@PAU12@00AAV?$allocator@UPkgFileInfo@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Uninit_copy@PAUPkgFileInfo@Ogre@@PAU12@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@YAPAUPkgFileInfo@Ogre@@PAU12@00AAV?$allocator@UPkgFileInfo@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_copy@PAUPkgFileInfo@Ogre@@PAU12@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@YAPAUPkgFileInfo@Ogre@@PAU12@00AAV?$allocator@UPkgFileInfo@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??$_Uninit_copy@PAUPkgFileInfo@Ogre@@PAU12@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@YAPAUPkgFileInfo@Ogre@@PAU12@00AAV?$allocator@UPkgFileInfo@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PAUPkgFileInfo@Ogre@@PAU12@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@YAPAUPkgFileInfo@Ogre@@PAU12@00AAV?$allocator@UPkgFileInfo@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<Ogre::PkgFileInfo *,Ogre::PkgFileInfo *,std::allocator<Ogre::PkgFileInfo> >, COMDAT

; 124  : 	{	// copy [_First, _Last) to raw _Dest, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_copy@PAUPkgFileInfo@Ogre@@PAU12@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@YAPAUPkgFileInfo@Ogre@@PAU12@00AAV?$allocator@UPkgFileInfo@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 125  : 	_DEBUG_RANGE(_First, _Last);
; 126  : 	_DEBUG_POINTER(_Dest);
; 127  : 	_FwdIt _Next = _Dest;

	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Next$[ebp], eax

; 128  : 
; 129  : 	_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 130  : 	for (; _First != _Last; ++_Dest, ++_First)

	jmp	SHORT $LN6@Uninit_cop@2
$LN5@Uninit_cop@2:
	mov	ecx, DWORD PTR __Dest$[ebp]
	add	ecx, 24					; 00000018H
	mov	DWORD PTR __Dest$[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	add	edx, 24					; 00000018H
	mov	DWORD PTR __First$[ebp], edx
$LN6@Uninit_cop@2:
	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Uninit_cop@2

; 131  : 		_Al.construct(_Dest, *_First);

	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?construct@?$allocator@UPkgFileInfo@Ogre@@@std@@QAEXPAUPkgFileInfo@Ogre@@ABU34@@Z ; std::allocator<Ogre::PkgFileInfo>::construct
	jmp	SHORT $LN5@Uninit_cop@2
$LN4@Uninit_cop@2:
	jmp	SHORT $LN10@Uninit_cop@2
__catch$??$_Uninit_copy@PAUPkgFileInfo@Ogre@@PAU12@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@YAPAUPkgFileInfo@Ogre@@PAU12@00AAV?$allocator@UPkgFileInfo@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 132  : 	_CATCH_ALL
; 133  : 	for (; _Next != _Dest; ++_Next)

	jmp	SHORT $LN3@Uninit_cop@2
$LN2@Uninit_cop@2:
	mov	eax, DWORD PTR __Next$[ebp]
	add	eax, 24					; 00000018H
	mov	DWORD PTR __Next$[ebp], eax
$LN3@Uninit_cop@2:
	mov	ecx, DWORD PTR __Next$[ebp]
	cmp	ecx, DWORD PTR __Dest$[ebp]
	je	SHORT $LN1@Uninit_cop@2

; 134  : 		_Al.destroy(_Next);

	mov	edx, DWORD PTR __Next$[ebp]
	push	edx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?destroy@?$allocator@UPkgFileInfo@Ogre@@@std@@QAEXPAUPkgFileInfo@Ogre@@@Z ; std::allocator<Ogre::PkgFileInfo>::destroy
	jmp	SHORT $LN2@Uninit_cop@2
$LN1@Uninit_cop@2:

; 135  : 	_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 136  : 	_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$??$_Uninit_copy@PAUPkgFileInfo@Ogre@@PAU12@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@YAPAUPkgFileInfo@Ogre@@PAU12@00AAV?$allocator@UPkgFileInfo@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1
	ret	0
$LN10@Uninit_cop@2:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Uninit_copy@PAUPkgFileInfo@Ogre@@PAU12@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@YAPAUPkgFileInfo@Ogre@@PAU12@00AAV?$allocator@UPkgFileInfo@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1:

; 137  : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[ebp]
$LN9@Uninit_cop@2:

; 138  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_copy@PAUPkgFileInfo@Ogre@@PAU12@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@YAPAUPkgFileInfo@Ogre@@PAU12@00AAV?$allocator@UPkgFileInfo@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_copy@PAUPkgFileInfo@Ogre@@PAU12@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@YAPAUPkgFileInfo@Ogre@@PAU12@00AAV?$allocator@UPkgFileInfo@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_copy@PAUPkgFileInfo@Ogre@@PAU12@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@YAPAUPkgFileInfo@Ogre@@PAU12@00AAV?$allocator@UPkgFileInfo@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<Ogre::PkgFileInfo *,Ogre::PkgFileInfo *,std::allocator<Ogre::PkgFileInfo> >
PUBLIC	??$_Checked_base@V?$_Vector_const_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBQAVPackageDataStreamObject@Ogre@@AAV?$_Vector_const_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >,std::_Different_checked_iterator_base_type_tag>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Checked_base@V?$_Vector_const_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@@std@@YAPBQAVPackageDataStreamObject@Ogre@@AAV?$_Vector_const_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@0@@Z
_TEXT	SEGMENT
__Base_tag$ = -1					; size = 1
__It$ = 8						; size = 4
??$_Checked_base@V?$_Vector_const_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@@std@@YAPBQAVPackageDataStreamObject@Ogre@@AAV?$_Vector_const_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@0@@Z PROC ; std::_Checked_base<std::_Vector_const_iterator<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> > >, COMDAT

; 1163 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1164 : 		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
; 1165 : 		return _Checked_base(_It, _Base_tag);

	movzx	eax, BYTE PTR __Base_tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR __It$[ebp]
	push	ecx
	call	??$_Checked_base@V?$_Vector_const_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBQAVPackageDataStreamObject@Ogre@@AAV?$_Vector_const_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >,std::_Different_checked_iterator_base_type_tag>
	add	esp, 8

; 1166 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Checked_base@V?$_Vector_const_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@@std@@YAPBQAVPackageDataStreamObject@Ogre@@AAV?$_Vector_const_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@0@@Z ENDP ; std::_Checked_base<std::_Vector_const_iterator<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> > >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@V?$_Vector_const_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@PAPAVPackageDataStreamObject@Ogre@@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@0@AAPAPAVPackageDataStreamObject@Ogre@@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@V?$_Vector_const_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@PAPAVPackageDataStreamObject@Ogre@@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@0@AAPAPAVPackageDataStreamObject@Ogre@@@Z PROC ; std::_Ptr_cat<std::_Vector_const_iterator<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >,Ogre::PackageDataStreamObject * *>, COMDAT

; 1509 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 1512 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Ptr_cat@V?$_Vector_const_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@PAPAVPackageDataStreamObject@Ogre@@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@0@AAPAPAVPackageDataStreamObject@Ogre@@@Z ENDP ; std::_Ptr_cat<std::_Vector_const_iterator<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >,Ogre::PackageDataStreamObject * *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@PBQAVPackageDataStreamObject@Ogre@@PAPAV12@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@YAPAPAVPackageDataStreamObject@Ogre@@PBQAV12@0PAPAV12@AAV?$allocator@PAVPackageDataStreamObject@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Result$ = -8						; size = 4
__Count$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PBQAVPackageDataStreamObject@Ogre@@PAPAV12@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@YAPAPAVPackageDataStreamObject@Ogre@@PBQAV12@0PAPAV12@AAV?$allocator@PAVPackageDataStreamObject@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<Ogre::PackageDataStreamObject * const *,Ogre::PackageDataStreamObject * *,std::allocator<Ogre::PackageDataStreamObject *> >, COMDAT

; 145  : 	{	// copy [_First, _Last) to raw _Dest, scalar type

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 146  : 	_DEBUG_RANGE(_First, _Last);
; 147  : 	_DEBUG_POINTER(_Dest);
; 148  : 	size_t _Count = (size_t)(_Last - _First);

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 2
	mov	DWORD PTR __Count$[ebp], eax

; 149  : 	_FwdIt _Result = _Dest + _Count;

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Dest$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR __Result$[ebp], eax

; 150  : 	if (_Count > 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN1@Uninit_cop@3

; 151  : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Count * sizeof (*_First), &*_First, _Count * sizeof (*_First));	// NB: non-overlapping move

	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN1@Uninit_cop@3:

; 152  : 	return (_Result);

	mov	eax, DWORD PTR __Result$[ebp]

; 153  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Uninit_copy@PBQAVPackageDataStreamObject@Ogre@@PAPAV12@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@YAPAPAVPackageDataStreamObject@Ogre@@PBQAV12@0PAPAV12@AAV?$allocator@PAVPackageDataStreamObject@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<Ogre::PackageDataStreamObject * const *,Ogre::PackageDataStreamObject * *,std::allocator<Ogre::PackageDataStreamObject *> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Checked_base@PAPAVPackageDataStreamObject@Ogre@@@std@@YAPAPAVPackageDataStreamObject@Ogre@@AAPAPAV12@U_Unchanged_checked_iterator_base_type_tag@0@@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Checked_base@PAPAVPackageDataStreamObject@Ogre@@@std@@YAPAPAVPackageDataStreamObject@Ogre@@AAPAPAV12@U_Unchanged_checked_iterator_base_type_tag@0@@Z PROC ; std::_Checked_base<Ogre::PackageDataStreamObject * *>, COMDAT

; 1146 : 	{

	push	ebp
	mov	ebp, esp

; 1147 : 		return _It;

	mov	eax, DWORD PTR __It$[ebp]
	mov	eax, DWORD PTR [eax]

; 1148 : 	}

	pop	ebp
	ret	0
??$_Checked_base@PAPAVPackageDataStreamObject@Ogre@@@std@@YAPAPAVPackageDataStreamObject@Ogre@@AAPAPAV12@U_Unchanged_checked_iterator_base_type_tag@0@@Z ENDP ; std::_Checked_base<Ogre::PackageDataStreamObject * *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@PAPAVPackageDataStreamObject@Ogre@@PAPAV12@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@YAPAPAVPackageDataStreamObject@Ogre@@PAPAV12@00AAV?$allocator@PAVPackageDataStreamObject@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Result$ = -8						; size = 4
__Count$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PAPAVPackageDataStreamObject@Ogre@@PAPAV12@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@YAPAPAVPackageDataStreamObject@Ogre@@PAPAV12@00AAV?$allocator@PAVPackageDataStreamObject@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<Ogre::PackageDataStreamObject * *,Ogre::PackageDataStreamObject * *,std::allocator<Ogre::PackageDataStreamObject *> >, COMDAT

; 145  : 	{	// copy [_First, _Last) to raw _Dest, scalar type

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 146  : 	_DEBUG_RANGE(_First, _Last);
; 147  : 	_DEBUG_POINTER(_Dest);
; 148  : 	size_t _Count = (size_t)(_Last - _First);

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 2
	mov	DWORD PTR __Count$[ebp], eax

; 149  : 	_FwdIt _Result = _Dest + _Count;

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Dest$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR __Result$[ebp], eax

; 150  : 	if (_Count > 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN1@Uninit_cop@4

; 151  : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Count * sizeof (*_First), &*_First, _Count * sizeof (*_First));	// NB: non-overlapping move

	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN1@Uninit_cop@4:

; 152  : 	return (_Result);

	mov	eax, DWORD PTR __Result$[ebp]

; 153  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Uninit_copy@PAPAVPackageDataStreamObject@Ogre@@PAPAV12@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@YAPAPAVPackageDataStreamObject@Ogre@@PAPAV12@00AAV?$allocator@PAVPackageDataStreamObject@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<Ogre::PackageDataStreamObject * *,Ogre::PackageDataStreamObject * *,std::allocator<Ogre::PackageDataStreamObject *> >
_TEXT	ENDS
PUBLIC	??$_Fill_n@PAPAVPackageDataStreamObject@Ogre@@IPAV12@@std@@YAXPAPAVPackageDataStreamObject@Ogre@@IABQAV12@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Fill_n<Ogre::PackageDataStreamObject * *,unsigned int,Ogre::PackageDataStreamObject *>
PUBLIC	??$_Iter_cat@PAPAVPackageDataStreamObject@Ogre@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVPackageDataStreamObject@Ogre@@@Z ; std::_Iter_cat<Ogre::PackageDataStreamObject * *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$unchecked_fill_n@PAPAVPackageDataStreamObject@Ogre@@IPAV12@@stdext@@YAXPAPAVPackageDataStreamObject@Ogre@@IABQAV12@@Z
_TEXT	SEGMENT
$T124929 = -2						; size = 1
$T124928 = -1						; size = 1
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
??$unchecked_fill_n@PAPAVPackageDataStreamObject@Ogre@@IPAV12@@stdext@@YAXPAPAVPackageDataStreamObject@Ogre@@IABQAV12@@Z PROC ; stdext::unchecked_fill_n<Ogre::PackageDataStreamObject * *,unsigned int,Ogre::PackageDataStreamObject *>, COMDAT

; 3720 : 	{	// copy _Val _Count times through [_First, ...)

	push	ebp
	mov	ebp, esp
	push	ecx

; 3721 : 		_STD _Fill_n(_First, _Count, _Val, _STD _Iter_cat(_First), _STD _Range_checked_iterator_tag());

	xor	eax, eax
	mov	BYTE PTR $T124928[ebp], al
	movzx	ecx, BYTE PTR $T124928[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	lea	eax, DWORD PTR $T124929[ebp]
	push	eax
	call	??$_Iter_cat@PAPAVPackageDataStreamObject@Ogre@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVPackageDataStreamObject@Ogre@@@Z ; std::_Iter_cat<Ogre::PackageDataStreamObject * *>
	add	esp, 8
	movzx	ecx, BYTE PTR [eax]
	push	ecx
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Fill_n@PAPAVPackageDataStreamObject@Ogre@@IPAV12@@std@@YAXPAPAVPackageDataStreamObject@Ogre@@IABQAV12@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Fill_n<Ogre::PackageDataStreamObject * *,unsigned int,Ogre::PackageDataStreamObject *>
	add	esp, 20					; 00000014H

; 3722 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_fill_n@PAPAVPackageDataStreamObject@Ogre@@IPAV12@@stdext@@YAXPAPAVPackageDataStreamObject@Ogre@@IABQAV12@@Z ENDP ; stdext::unchecked_fill_n<Ogre::PackageDataStreamObject * *,unsigned int,Ogre::PackageDataStreamObject *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$_Uninit_move@PAUPkgFileInfo@Ogre@@PAU12@V?$allocator@UPkgFileInfo@Ogre@@@std@@U_Undefined_move_tag@4@@std@@YAPAUPkgFileInfo@Ogre@@PAU12@00AAV?$allocator@UPkgFileInfo@Ogre@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_move@PAUPkgFileInfo@Ogre@@PAU12@V?$allocator@UPkgFileInfo@Ogre@@@std@@U_Undefined_move_tag@4@@std@@YAPAUPkgFileInfo@Ogre@@PAU12@00AAV?$allocator@UPkgFileInfo@Ogre@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_move<Ogre::PkgFileInfo *,Ogre::PkgFileInfo *,std::allocator<Ogre::PkgFileInfo>,std::_Undefined_move_tag>, COMDAT

; 206  : 	{	// move defaults to copy if there is not a more effecient way

	push	ebp
	mov	ebp, esp

; 207  : 	return (_STDEXT unchecked_uninitialized_copy(_First, _Last, _Dest, _Al));

	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$unchecked_uninitialized_copy@PAUPkgFileInfo@Ogre@@PAU12@V?$allocator@UPkgFileInfo@Ogre@@@std@@@stdext@@YAPAUPkgFileInfo@Ogre@@PAU12@00AAV?$allocator@UPkgFileInfo@Ogre@@@std@@@Z ; stdext::unchecked_uninitialized_copy<Ogre::PkgFileInfo *,Ogre::PkgFileInfo *,std::allocator<Ogre::PkgFileInfo> >
	add	esp, 16					; 00000010H

; 208  : 	}

	pop	ebp
	ret	0
??$_Uninit_move@PAUPkgFileInfo@Ogre@@PAU12@V?$allocator@UPkgFileInfo@Ogre@@@std@@U_Undefined_move_tag@4@@std@@YAPAUPkgFileInfo@Ogre@@PAU12@00AAV?$allocator@UPkgFileInfo@Ogre@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_move<Ogre::PkgFileInfo *,Ogre::PkgFileInfo *,std::allocator<Ogre::PkgFileInfo>,std::_Undefined_move_tag>
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@PAUPkgFileInfo@Ogre@@PAU12@Uforward_iterator_tag@std@@@std@@YAPAUPkgFileInfo@Ogre@@PAU12@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<Ogre::PkgFileInfo *,Ogre::PkgFileInfo *,std::forward_iterator_tag>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Copy_backward_opt@PAUPkgFileInfo@Ogre@@PAU12@@std@@YAPAUPkgFileInfo@Ogre@@PAU12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T124936 = -7						; size = 1
$T124935 = -6						; size = 1
$T124934 = -5						; size = 1
__Result$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_backward_opt@PAUPkgFileInfo@Ogre@@PAU12@@std@@YAPAUPkgFileInfo@Ogre@@PAU12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<Ogre::PkgFileInfo *,Ogre::PkgFileInfo *>, COMDAT

; 2685 : 	{	// copy [_First, _Last) backwards to [..., _Dest), arbitrary iterators

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 2686 : 	// if _OutIt is range checked, this will make sure there is enough space for the copy
; 2687 : 	_OutIt _Result = _Dest - (_Last - _First);

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	cdq
	mov	ecx, 24					; 00000018H
	idiv	ecx
	imul	eax, 24					; 00000018H
	mov	edx, DWORD PTR __Dest$[ebp]
	sub	edx, eax
	mov	DWORD PTR __Result$[ebp], edx

; 2688 : 	_Copy_backward_opt(_First, _Last, _CHECKED_BASE(_Dest),
; 2689 : 		forward_iterator_tag(), _Nonscalar_ptr_iterator_tag(), _Range_checked_iterator_tag());

	xor	eax, eax
	mov	BYTE PTR $T124934[ebp], al
	xor	ecx, ecx
	mov	BYTE PTR $T124935[ebp], cl
	movzx	edx, BYTE PTR $T124934[ebp]
	push	edx
	movzx	eax, BYTE PTR $T124935[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T124936[ebp]
	push	ecx
	lea	edx, DWORD PTR __Dest$[ebp]
	push	edx
	call	??$_Checked_base@PAUPkgFileInfo@Ogre@@@std@@YAPAUPkgFileInfo@Ogre@@AAPAU12@@Z ; std::_Checked_base<Ogre::PkgFileInfo *>
	add	esp, 4
	push	eax
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Copy_backward_opt@PAUPkgFileInfo@Ogre@@PAU12@Uforward_iterator_tag@std@@@std@@YAPAUPkgFileInfo@Ogre@@PAU12@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<Ogre::PkgFileInfo *,Ogre::PkgFileInfo *,std::forward_iterator_tag>
	add	esp, 24					; 00000018H

; 2690 : 	return _Result;

	mov	eax, DWORD PTR __Result$[ebp]

; 2691 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Copy_backward_opt@PAUPkgFileInfo@Ogre@@PAU12@@std@@YAPAUPkgFileInfo@Ogre@@PAU12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<Ogre::PkgFileInfo *,Ogre::PkgFileInfo *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$_Uninit_move@PAPAVPackageDataStreamObject@Ogre@@PAPAV12@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@U_Undefined_move_tag@4@@std@@YAPAPAVPackageDataStreamObject@Ogre@@PAPAV12@00AAV?$allocator@PAVPackageDataStreamObject@Ogre@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_move@PAPAVPackageDataStreamObject@Ogre@@PAPAV12@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@U_Undefined_move_tag@4@@std@@YAPAPAVPackageDataStreamObject@Ogre@@PAPAV12@00AAV?$allocator@PAVPackageDataStreamObject@Ogre@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_move<Ogre::PackageDataStreamObject * *,Ogre::PackageDataStreamObject * *,std::allocator<Ogre::PackageDataStreamObject *>,std::_Undefined_move_tag>, COMDAT

; 206  : 	{	// move defaults to copy if there is not a more effecient way

	push	ebp
	mov	ebp, esp

; 207  : 	return (_STDEXT unchecked_uninitialized_copy(_First, _Last, _Dest, _Al));

	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$unchecked_uninitialized_copy@PAPAVPackageDataStreamObject@Ogre@@PAPAV12@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@stdext@@YAPAPAVPackageDataStreamObject@Ogre@@PAPAV12@00AAV?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@Z ; stdext::unchecked_uninitialized_copy<Ogre::PackageDataStreamObject * *,Ogre::PackageDataStreamObject * *,std::allocator<Ogre::PackageDataStreamObject *> >
	add	esp, 16					; 00000010H

; 208  : 	}

	pop	ebp
	ret	0
??$_Uninit_move@PAPAVPackageDataStreamObject@Ogre@@PAPAV12@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@U_Undefined_move_tag@4@@std@@YAPAPAVPackageDataStreamObject@Ogre@@PAPAV12@00AAV?$allocator@PAVPackageDataStreamObject@Ogre@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_move<Ogre::PackageDataStreamObject * *,Ogre::PackageDataStreamObject * *,std::allocator<Ogre::PackageDataStreamObject *>,std::_Undefined_move_tag>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Copy_backward_opt@PAPAVPackageDataStreamObject@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@@std@@YAPAPAVPackageDataStreamObject@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Off$ = -8						; size = 4
__Result$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_backward_opt@PAPAVPackageDataStreamObject@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@@std@@YAPAPAVPackageDataStreamObject@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<Ogre::PackageDataStreamObject * *,Ogre::PackageDataStreamObject * *,std::random_access_iterator_tag>, COMDAT

; 2698 : 	{	// copy [_First, _Last) backwards to [..., _Dest), pointers to scalars

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 2699 : 
; 2700 :  #if _HAS_ITERATOR_DEBUGGING
; 2701 : 	_DEBUG_RANGE(_First, _Last);
; 2702 : 	if (_First != _Last)
; 2703 : 		_DEBUG_POINTER(_Dest);
; 2704 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2705 : 
; 2706 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 2
	mov	DWORD PTR __Off$[ebp], eax

; 2707 : 	/* if _OutIt is range checked, this will make sure there is enough space for 
; 2708 : 	 * the memmove
; 2709 : 	 */
; 2710 : 	_OutIt _Result = _Dest - _Off;

	mov	ecx, DWORD PTR __Off$[ebp]
	shl	ecx, 2
	mov	edx, DWORD PTR __Dest$[ebp]
	sub	edx, ecx
	mov	DWORD PTR __Result$[ebp], edx

; 2711 : 	if (_Off > 0)

	cmp	DWORD PTR __Off$[ebp], 0
	jle	SHORT $LN1@Copy_backw

; 2712 : 		_CRT_SECURE_MEMMOVE(&*_Result, _Off * sizeof (*_First), &*_First, _Off * sizeof (*_First));

	mov	eax, DWORD PTR __Off$[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Off$[ebp]
	shl	edx, 2
	push	edx
	mov	eax, DWORD PTR __Result$[ebp]
	push	eax
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN1@Copy_backw:

; 2713 : 	return _Result;

	mov	eax, DWORD PTR __Result$[ebp]

; 2714 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Copy_backward_opt@PAPAVPackageDataStreamObject@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@@std@@YAPAPAVPackageDataStreamObject@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<Ogre::PackageDataStreamObject * *,Ogre::PackageDataStreamObject * *,std::random_access_iterator_tag>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Construct@UPkgFileInfo@Ogre@@U12@@std@@YAXPAUPkgFileInfo@Ogre@@ABU12@@Z
_TEXT	SEGMENT
tv69 = -12						; size = 4
$T124943 = -8						; size = 4
__Vptr$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@UPkgFileInfo@Ogre@@U12@@std@@YAXPAUPkgFileInfo@Ogre@@ABU12@@Z PROC ; std::_Construct<Ogre::PkgFileInfo,Ogre::PkgFileInfo>, COMDAT

; 50   : 	{	// construct object at _Ptr with value _Val

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 51   : 	void _FARQ *_Vptr = _Ptr;

	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR __Vptr$[ebp], eax

; 52   : 	::new (_Vptr) _T1(_Val);

	mov	ecx, DWORD PTR __Vptr$[ebp]
	push	ecx
	push	24					; 00000018H
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T124943[ebp], eax
	cmp	DWORD PTR $T124943[ebp], 0
	je	SHORT $LN3@Construct
	mov	edx, DWORD PTR __Val$[ebp]
	mov	eax, DWORD PTR $T124943[ebp]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], ecx
	mov	ecx, DWORD PTR [edx+12]
	mov	DWORD PTR [eax+12], ecx
	mov	ecx, DWORD PTR [edx+16]
	mov	DWORD PTR [eax+16], ecx
	mov	edx, DWORD PTR [edx+20]
	mov	DWORD PTR [eax+20], edx
	mov	eax, DWORD PTR $T124943[ebp]
	mov	DWORD PTR tv69[ebp], eax
	jmp	SHORT $LN1@Construct
$LN3@Construct:
	mov	DWORD PTR tv69[ebp], 0
$LN1@Construct:

; 53   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Construct@UPkgFileInfo@Ogre@@U12@@std@@YAXPAUPkgFileInfo@Ogre@@ABU12@@Z ENDP ; std::_Construct<Ogre::PkgFileInfo,Ogre::PkgFileInfo>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Destroy@UPkgFileInfo@Ogre@@@std@@YAXPAUPkgFileInfo@Ogre@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@UPkgFileInfo@Ogre@@@std@@YAXPAUPkgFileInfo@Ogre@@@Z PROC ; std::_Destroy<Ogre::PkgFileInfo>, COMDAT

; 58   : 	{	// destroy object at _Ptr

	push	ebp
	mov	ebp, esp

; 59   : 	_DESTRUCTOR(_Ty, _Ptr);
; 60   : 	}

	pop	ebp
	ret	0
??$_Destroy@UPkgFileInfo@Ogre@@@std@@YAXPAUPkgFileInfo@Ogre@@@Z ENDP ; std::_Destroy<Ogre::PkgFileInfo>
_TEXT	ENDS
PUBLIC	?_Checked_iterator_base@?$_Vector_const_iterator@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QBEPBUPkgFileInfo@Ogre@@XZ ; std::_Vector_const_iterator<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::_Checked_iterator_base
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Checked_base@V?$_Vector_const_iterator@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBUPkgFileInfo@Ogre@@AAV?$_Vector_const_iterator@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Checked_base@V?$_Vector_const_iterator@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBUPkgFileInfo@Ogre@@AAV?$_Vector_const_iterator@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z PROC ; std::_Checked_base<std::_Vector_const_iterator<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >,std::_Different_checked_iterator_base_type_tag>, COMDAT

; 1138 : 	{

	push	ebp
	mov	ebp, esp

; 1139 : 		return _It._Checked_iterator_base();

	mov	ecx, DWORD PTR __It$[ebp]
	call	?_Checked_iterator_base@?$_Vector_const_iterator@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QBEPBUPkgFileInfo@Ogre@@XZ ; std::_Vector_const_iterator<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::_Checked_iterator_base

; 1140 : 	}

	pop	ebp
	ret	0
??$_Checked_base@V?$_Vector_const_iterator@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBUPkgFileInfo@Ogre@@AAV?$_Vector_const_iterator@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z ENDP ; std::_Checked_base<std::_Vector_const_iterator<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >,std::_Different_checked_iterator_base_type_tag>
_TEXT	ENDS
PUBLIC	?_Checked_iterator_base@?$_Vector_const_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QBEPBQAVPackageDataStreamObject@Ogre@@XZ ; std::_Vector_const_iterator<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::_Checked_iterator_base
; Function compile flags: /Odtp
;	COMDAT ??$_Checked_base@V?$_Vector_const_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBQAVPackageDataStreamObject@Ogre@@AAV?$_Vector_const_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Checked_base@V?$_Vector_const_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBQAVPackageDataStreamObject@Ogre@@AAV?$_Vector_const_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z PROC ; std::_Checked_base<std::_Vector_const_iterator<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >,std::_Different_checked_iterator_base_type_tag>, COMDAT

; 1138 : 	{

	push	ebp
	mov	ebp, esp

; 1139 : 		return _It._Checked_iterator_base();

	mov	ecx, DWORD PTR __It$[ebp]
	call	?_Checked_iterator_base@?$_Vector_const_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QBEPBQAVPackageDataStreamObject@Ogre@@XZ ; std::_Vector_const_iterator<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::_Checked_iterator_base

; 1140 : 	}

	pop	ebp
	ret	0
??$_Checked_base@V?$_Vector_const_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBQAVPackageDataStreamObject@Ogre@@AAV?$_Vector_const_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z ENDP ; std::_Checked_base<std::_Vector_const_iterator<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >,std::_Different_checked_iterator_base_type_tag>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Iter_cat@PAPAVPackageDataStreamObject@Ogre@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVPackageDataStreamObject@Ogre@@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??$_Iter_cat@PAPAVPackageDataStreamObject@Ogre@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVPackageDataStreamObject@Ogre@@@Z PROC ; std::_Iter_cat<Ogre::PackageDataStreamObject * *>, COMDAT

; 952  : 	{	// return category from iterator argument

	push	ebp
	mov	ebp, esp
	push	ecx

; 953  : 	typename iterator_traits<_Iter>::iterator_category _Cat;
; 954  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 955  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Iter_cat@PAPAVPackageDataStreamObject@Ogre@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVPackageDataStreamObject@Ogre@@@Z ENDP ; std::_Iter_cat<Ogre::PackageDataStreamObject * *>
_TEXT	ENDS
PUBLIC	??$_Fill_n@PAPAVPackageDataStreamObject@Ogre@@IPAV12@@std@@YAXPAPAVPackageDataStreamObject@Ogre@@IABQAV12@U_Range_checked_iterator_tag@0@@Z ; std::_Fill_n<Ogre::PackageDataStreamObject * *,unsigned int,Ogre::PackageDataStreamObject *>
; Function compile flags: /Odtp
;	COMDAT ??$_Fill_n@PAPAVPackageDataStreamObject@Ogre@@IPAV12@@std@@YAXPAPAVPackageDataStreamObject@Ogre@@IABQAV12@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T124956 = -5						; size = 1
__Last$ = -4						; size = 4
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
??$_Fill_n@PAPAVPackageDataStreamObject@Ogre@@IPAV12@@std@@YAXPAPAVPackageDataStreamObject@Ogre@@IABQAV12@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Fill_n<Ogre::PackageDataStreamObject * *,unsigned int,Ogre::PackageDataStreamObject *>, COMDAT

; 3250 : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 3251 : 		// if _OutIt is checked, this will ensure we have enough space
; 3252 : 		_OutIt _Last = _First + _Count; (_Last);

	mov	eax, DWORD PTR __Count$[ebp]
	mov	ecx, DWORD PTR __First$[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR __Last$[ebp], edx

; 3253 : 		_Fill_n(_CHECKED_BASE(_First), _Count, _Val,
; 3254 : 			_Range_checked_iterator_tag());

	xor	eax, eax
	mov	BYTE PTR $T124956[ebp], al
	movzx	ecx, BYTE PTR $T124956[ebp]
	push	ecx
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Checked_base@PAPAVPackageDataStreamObject@Ogre@@@std@@YAPAPAVPackageDataStreamObject@Ogre@@AAPAPAV12@@Z ; std::_Checked_base<Ogre::PackageDataStreamObject * *>
	add	esp, 4
	push	eax
	call	??$_Fill_n@PAPAVPackageDataStreamObject@Ogre@@IPAV12@@std@@YAXPAPAVPackageDataStreamObject@Ogre@@IABQAV12@U_Range_checked_iterator_tag@0@@Z ; std::_Fill_n<Ogre::PackageDataStreamObject * *,unsigned int,Ogre::PackageDataStreamObject *>
	add	esp, 16					; 00000010H

; 3255 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Fill_n@PAPAVPackageDataStreamObject@Ogre@@IPAV12@@std@@YAXPAPAVPackageDataStreamObject@Ogre@@IABQAV12@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Fill_n<Ogre::PackageDataStreamObject * *,unsigned int,Ogre::PackageDataStreamObject *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Copy_backward_opt@PAUPkgFileInfo@Ogre@@PAU12@Uforward_iterator_tag@std@@@std@@YAPAUPkgFileInfo@Ogre@@PAU12@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_backward_opt@PAUPkgFileInfo@Ogre@@PAU12@Uforward_iterator_tag@std@@@std@@YAPAUPkgFileInfo@Ogre@@PAU12@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<Ogre::PkgFileInfo *,Ogre::PkgFileInfo *,std::forward_iterator_tag>, COMDAT

; 2673 : 	{	// copy [_First, _Last) backwards to [..., _Dest), arbitrary iterators

	push	ebp
	mov	ebp, esp
$LN2@Copy_backw@2:

; 2674 : 	_DEBUG_RANGE(_First, _Last);
; 2675 : 	while (_First != _Last)

	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	SHORT $LN1@Copy_backw@2

; 2676 : 		*--_Dest = *--_Last;

	mov	ecx, DWORD PTR __Last$[ebp]
	sub	ecx, 24					; 00000018H
	mov	DWORD PTR __Last$[ebp], ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	sub	edx, 24					; 00000018H
	mov	DWORD PTR __Dest$[ebp], edx
	mov	eax, DWORD PTR __Last$[ebp]
	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], edx
	mov	edx, DWORD PTR [eax+16]
	mov	DWORD PTR [ecx+16], edx
	mov	eax, DWORD PTR [eax+20]
	mov	DWORD PTR [ecx+20], eax
	jmp	SHORT $LN2@Copy_backw@2
$LN1@Copy_backw@2:

; 2677 : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[ebp]

; 2678 : 	}

	pop	ebp
	ret	0
??$_Copy_backward_opt@PAUPkgFileInfo@Ogre@@PAU12@Uforward_iterator_tag@std@@@std@@YAPAUPkgFileInfo@Ogre@@PAU12@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<Ogre::PkgFileInfo *,Ogre::PkgFileInfo *,std::forward_iterator_tag>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?_Checked_iterator_base@?$_Vector_const_iterator@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QBEPBUPkgFileInfo@Ogre@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Checked_iterator_base@?$_Vector_const_iterator@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QBEPBUPkgFileInfo@Ogre@@XZ PROC ; std::_Vector_const_iterator<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::_Checked_iterator_base, COMDAT
; _this$ = ecx

; 46   : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 47   : 		return _Myptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 48   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Checked_iterator_base@?$_Vector_const_iterator@UPkgFileInfo@Ogre@@V?$allocator@UPkgFileInfo@Ogre@@@std@@@std@@QBEPBUPkgFileInfo@Ogre@@XZ ENDP ; std::_Vector_const_iterator<Ogre::PkgFileInfo,std::allocator<Ogre::PkgFileInfo> >::_Checked_iterator_base
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Checked_iterator_base@?$_Vector_const_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QBEPBQAVPackageDataStreamObject@Ogre@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Checked_iterator_base@?$_Vector_const_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QBEPBQAVPackageDataStreamObject@Ogre@@XZ PROC ; std::_Vector_const_iterator<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::_Checked_iterator_base, COMDAT
; _this$ = ecx

; 46   : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 47   : 		return _Myptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 48   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Checked_iterator_base@?$_Vector_const_iterator@PAVPackageDataStreamObject@Ogre@@V?$allocator@PAVPackageDataStreamObject@Ogre@@@std@@@std@@QBEPBQAVPackageDataStreamObject@Ogre@@XZ ENDP ; std::_Vector_const_iterator<Ogre::PackageDataStreamObject *,std::allocator<Ogre::PackageDataStreamObject *> >::_Checked_iterator_base
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Fill_n@PAPAVPackageDataStreamObject@Ogre@@IPAV12@@std@@YAXPAPAVPackageDataStreamObject@Ogre@@IABQAV12@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Fill_n@PAPAVPackageDataStreamObject@Ogre@@IPAV12@@std@@YAXPAPAVPackageDataStreamObject@Ogre@@IABQAV12@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Fill_n<Ogre::PackageDataStreamObject * *,unsigned int,Ogre::PackageDataStreamObject *>, COMDAT

; 3196 : 	{	// copy _Val _Count times through [_First, ...)

	push	ebp
	mov	ebp, esp

; 3197 : 	for (; 0 < _Count; --_Count, ++_First)

	jmp	SHORT $LN3@Fill_n
$LN2@Fill_n:
	mov	eax, DWORD PTR __Count$[ebp]
	sub	eax, 1
	mov	DWORD PTR __Count$[ebp], eax
	mov	ecx, DWORD PTR __First$[ebp]
	add	ecx, 4
	mov	DWORD PTR __First$[ebp], ecx
$LN3@Fill_n:
	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN4@Fill_n

; 3198 : 		*_First = _Val;

	mov	edx, DWORD PTR __First$[ebp]
	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	jmp	SHORT $LN2@Fill_n
$LN4@Fill_n:

; 3199 : 	}

	pop	ebp
	ret	0
??$_Fill_n@PAPAVPackageDataStreamObject@Ogre@@IPAV12@@std@@YAXPAPAVPackageDataStreamObject@Ogre@@IABQAV12@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Fill_n<Ogre::PackageDataStreamObject * *,unsigned int,Ogre::PackageDataStreamObject *>
_TEXT	ENDS
END

; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	i:\svnroot\client\OgreMain\OgreCharacterCodingUTF8.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	?_Value@?$_Is_swap_move@U_Swap_move_tag@std@@@std@@2_NB ; std::_Is_swap_move<std::_Swap_move_tag>::_Value
PUBLIC	?collate@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::collate
PUBLIC	?ctype@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::ctype
PUBLIC	?monetary@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::monetary
PUBLIC	?numeric@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::numeric
PUBLIC	?time@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::time
PUBLIC	?messages@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::messages
PUBLIC	?all@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::all
PUBLIC	?none@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::none
PUBLIC	?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::skipws
PUBLIC	?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::unitbuf
PUBLIC	?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::uppercase
PUBLIC	?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showbase
PUBLIC	?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpoint
PUBLIC	?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpos
PUBLIC	?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::left
PUBLIC	?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::right
PUBLIC	?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::internal
PUBLIC	?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::dec
PUBLIC	?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::oct
PUBLIC	?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::hex
PUBLIC	?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::scientific
PUBLIC	?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::fixed
PUBLIC	?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::hexfloat
PUBLIC	?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::boolalpha
PUBLIC	?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::_Stdio
PUBLIC	?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::adjustfield
PUBLIC	?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::basefield
PUBLIC	?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::floatfield
PUBLIC	?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::goodbit
PUBLIC	?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::eofbit
PUBLIC	?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::failbit
PUBLIC	?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::badbit
PUBLIC	?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::_Hardfail
PUBLIC	?in@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::in
PUBLIC	?out@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::out
PUBLIC	?ate@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::ate
PUBLIC	?app@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::app
PUBLIC	?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::trunc
PUBLIC	?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Nocreate
PUBLIC	?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Noreplace
PUBLIC	?binary@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::binary
PUBLIC	?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::beg
PUBLIC	?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::cur
PUBLIC	?end@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::end
PUBLIC	?value@?$integral_constant@_N$0A@@tr1@std@@2_NB	; std::tr1::integral_constant<bool,0>::value
PUBLIC	?value@?$integral_constant@_N$00@tr1@std@@2_NB	; std::tr1::integral_constant<bool,1>::value
;	COMDAT ?value@?$integral_constant@_N$00@tr1@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$00@tr1@std@@2_NB DB 01H	; std::tr1::integral_constant<bool,1>::value
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$0A@@tr1@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$0A@@tr1@std@@2_NB DB 00H	; std::tr1::integral_constant<bool,0>::value
CONST	ENDS
;	COMDAT ?end@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?end@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 02H		; std::_Iosb<int>::end
CONST	ENDS
;	COMDAT ?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 01H		; std::_Iosb<int>::cur
CONST	ENDS
;	COMDAT ?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 00H		; std::_Iosb<int>::beg
CONST	ENDS
;	COMDAT ?binary@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?binary@?$_Iosb@H@std@@2W4_Openmode@12@B DD 020H	; std::_Iosb<int>::binary
CONST	ENDS
;	COMDAT ?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B DD 080H	; std::_Iosb<int>::_Noreplace
CONST	ENDS
;	COMDAT ?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 040H	; std::_Iosb<int>::_Nocreate
CONST	ENDS
;	COMDAT ?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B DD 010H		; std::_Iosb<int>::trunc
CONST	ENDS
;	COMDAT ?app@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?app@?$_Iosb@H@std@@2W4_Openmode@12@B DD 08H		; std::_Iosb<int>::app
CONST	ENDS
;	COMDAT ?ate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?ate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 04H		; std::_Iosb<int>::ate
CONST	ENDS
;	COMDAT ?out@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?out@?$_Iosb@H@std@@2W4_Openmode@12@B DD 02H		; std::_Iosb<int>::out
CONST	ENDS
;	COMDAT ?in@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?in@?$_Iosb@H@std@@2W4_Openmode@12@B DD 01H		; std::_Iosb<int>::in
CONST	ENDS
;	COMDAT ?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B DD 010H	; std::_Iosb<int>::_Hardfail
CONST	ENDS
;	COMDAT ?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 04H		; std::_Iosb<int>::badbit
CONST	ENDS
;	COMDAT ?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 02H		; std::_Iosb<int>::failbit
CONST	ENDS
;	COMDAT ?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 01H		; std::_Iosb<int>::eofbit
CONST	ENDS
;	COMDAT ?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 00H		; std::_Iosb<int>::goodbit
CONST	ENDS
;	COMDAT ?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 03000H	; std::_Iosb<int>::floatfield
CONST	ENDS
;	COMDAT ?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0e00H	; std::_Iosb<int>::basefield
CONST	ENDS
;	COMDAT ?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01c0H	; std::_Iosb<int>::adjustfield
CONST	ENDS
;	COMDAT ?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08000H	; std::_Iosb<int>::_Stdio
CONST	ENDS
;	COMDAT ?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04000H	; std::_Iosb<int>::boolalpha
CONST	ENDS
;	COMDAT ?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 03000H	; std::_Iosb<int>::hexfloat
CONST	ENDS
;	COMDAT ?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02000H	; std::_Iosb<int>::fixed
CONST	ENDS
;	COMDAT ?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01000H	; std::_Iosb<int>::scientific
CONST	ENDS
;	COMDAT ?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0800H		; std::_Iosb<int>::hex
CONST	ENDS
;	COMDAT ?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0400H		; std::_Iosb<int>::oct
CONST	ENDS
;	COMDAT ?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0200H		; std::_Iosb<int>::dec
CONST	ENDS
;	COMDAT ?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0100H	; std::_Iosb<int>::internal
CONST	ENDS
;	COMDAT ?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 080H		; std::_Iosb<int>::right
CONST	ENDS
;	COMDAT ?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 040H		; std::_Iosb<int>::left
CONST	ENDS
;	COMDAT ?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 020H	; std::_Iosb<int>::showpos
CONST	ENDS
;	COMDAT ?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 010H	; std::_Iosb<int>::showpoint
CONST	ENDS
;	COMDAT ?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08H	; std::_Iosb<int>::showbase
CONST	ENDS
;	COMDAT ?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04H	; std::_Iosb<int>::uppercase
CONST	ENDS
;	COMDAT ?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02H	; std::_Iosb<int>::unitbuf
CONST	ENDS
;	COMDAT ?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01H		; std::_Iosb<int>::skipws
CONST	ENDS
;	COMDAT ?none@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?none@?$_Locbase@H@std@@2HB DD 00H			; std::_Locbase<int>::none
CONST	ENDS
;	COMDAT ?all@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?all@?$_Locbase@H@std@@2HB DD 03fH			; std::_Locbase<int>::all
CONST	ENDS
;	COMDAT ?messages@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?messages@?$_Locbase@H@std@@2HB DD 020H			; std::_Locbase<int>::messages
CONST	ENDS
;	COMDAT ?time@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?time@?$_Locbase@H@std@@2HB DD 010H			; std::_Locbase<int>::time
CONST	ENDS
;	COMDAT ?numeric@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?numeric@?$_Locbase@H@std@@2HB DD 08H			; std::_Locbase<int>::numeric
CONST	ENDS
;	COMDAT ?monetary@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?monetary@?$_Locbase@H@std@@2HB DD 04H			; std::_Locbase<int>::monetary
CONST	ENDS
;	COMDAT ?ctype@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?ctype@?$_Locbase@H@std@@2HB DD 02H			; std::_Locbase<int>::ctype
CONST	ENDS
;	COMDAT ?collate@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?collate@?$_Locbase@H@std@@2HB DD 01H			; std::_Locbase<int>::collate
CONST	ENDS
;	COMDAT ?_Value@?$_Is_swap_move@U_Swap_move_tag@std@@@std@@2_NB
CONST	SEGMENT
?_Value@?$_Is_swap_move@U_Swap_move_tag@std@@@std@@2_NB DB 01H ; std::_Is_swap_move<std::_Swap_move_tag>::_Value
CONST	ENDS
_DATA	SEGMENT
__bad_alloc_Message DD FLAT:$SG5714
_DATA	ENDS
CONST	SEGMENT
$SG5714	DB	'bad allocation', 00H
CONST	ENDS
PUBLIC	??4StringUtil@Ogre@@QAEAAV01@ABV01@@Z		; Ogre::StringUtil::operator=
; Function compile flags: /Odtp
;	COMDAT ??4StringUtil@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4StringUtil@Ogre@@QAEAAV01@ABV01@@Z PROC		; Ogre::StringUtil::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4StringUtil@Ogre@@QAEAAV01@ABV01@@Z ENDP		; Ogre::StringUtil::operator=
_TEXT	ENDS
PUBLIC	?JumpOverSpaces@CharacterCodingUtf8@Ogre@@UAEHPBD@Z ; Ogre::CharacterCodingUtf8::JumpOverSpaces
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogrecharactercodingutf8.cpp
_TEXT	SEGMENT
_this$ = -12						; size = 4
_nRet$ = -8						; size = 4
_p$ = -4						; size = 4
_pText$ = 8						; size = 4
?JumpOverSpaces@CharacterCodingUtf8@Ogre@@UAEHPBD@Z PROC ; Ogre::CharacterCodingUtf8::JumpOverSpaces
; _this$ = ecx

; 9    : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 10   : 		int nRet = 0;

	mov	DWORD PTR _nRet$[ebp], 0

; 11   : 		const unsigned char *p = (const unsigned char*)pText;

	mov	eax, DWORD PTR _pText$[ebp]
	mov	DWORD PTR _p$[ebp], eax
$LN4@JumpOverSp:

; 12   : 
; 13   : 		while(1)

	mov	ecx, 1
	test	ecx, ecx
	je	SHORT $LN3@JumpOverSp

; 14   : 		{
; 15   : 			if(*p == ' ')							//半角空格

	mov	edx, DWORD PTR _p$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 32					; 00000020H
	jne	SHORT $LN2@JumpOverSp

; 16   : 				p++ , nRet++;

	mov	ecx, DWORD PTR _p$[ebp]
	add	ecx, 1
	mov	DWORD PTR _p$[ebp], ecx
	mov	edx, DWORD PTR _nRet$[ebp]
	add	edx, 1
	mov	DWORD PTR _nRet$[ebp], edx

; 17   : 			//			else if(*p == 0xa1 && *(p+1) == 0xa1)	//全角空格
; 18   : 			//				p += 2 , nRet += 2;
; 19   : 			else

	jmp	SHORT $LN1@JumpOverSp
$LN2@JumpOverSp:

; 20   : 				break;

	jmp	SHORT $LN3@JumpOverSp
$LN1@JumpOverSp:

; 21   : 		}

	jmp	SHORT $LN4@JumpOverSp
$LN3@JumpOverSp:

; 22   : 		return nRet;

	mov	eax, DWORD PTR _nRet$[ebp]

; 23   : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
?JumpOverSpaces@CharacterCodingUtf8@Ogre@@UAEHPBD@Z ENDP ; Ogre::CharacterCodingUtf8::JumpOverSpaces
_TEXT	ENDS
PUBLIC	?GetAChar@CharacterCodingUtf8@Ogre@@UAEHPBDPAE@Z ; Ogre::CharacterCodingUtf8::GetAChar
; Function compile flags: /Odtp
_TEXT	SEGMENT
_this$ = -24						; size = 4
_i$56767 = -20						; size = 4
_i$56759 = -16						; size = 4
_nMask$56757 = -9					; size = 1
_nBytes$56758 = -8					; size = 4
_nHead$ = -1						; size = 1
_pText$ = 8						; size = 4
_pChar$ = 12						; size = 4
?GetAChar@CharacterCodingUtf8@Ogre@@UAEHPBDPAE@Z PROC	; Ogre::CharacterCodingUtf8::GetAChar
; _this$ = ecx

; 26   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 27   : 		if(!pText)

	cmp	DWORD PTR _pText$[ebp], 0
	jne	SHORT $LN14@GetAChar

; 28   : 			return 0;

	xor	eax, eax
	jmp	$LN15@GetAChar
$LN14@GetAChar:

; 29   : 
; 30   : 		unsigned char nHead = unsigned char (*pText);

	mov	eax, DWORD PTR _pText$[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR _nHead$[ebp], cl

; 31   : 
; 32   : 		if( (nHead & 0x80) == 0 )

	movzx	edx, BYTE PTR _nHead$[ebp]
	and	edx, 128				; 00000080H
	jne	SHORT $LN13@GetAChar

; 33   : 		{
; 34   : 			// 英文
; 35   : 			pChar[0] = nHead;

	mov	eax, DWORD PTR _pChar$[ebp]
	mov	cl, BYTE PTR _nHead$[ebp]
	mov	BYTE PTR [eax], cl

; 36   : 			pChar[1] = 0;

	mov	edx, DWORD PTR _pChar$[ebp]
	mov	BYTE PTR [edx+1], 0

; 37   : 			return 1;

	mov	eax, 1
	jmp	$LN15@GetAChar

; 38   : 		}
; 39   : 		else

	jmp	$LN15@GetAChar
$LN13@GetAChar:

; 40   : 		{
; 41   : 			unsigned char nMask = 0x80;

	mov	BYTE PTR _nMask$56757[ebp], 128		; 00000080H

; 42   : 			int nBytes = 0;

	mov	DWORD PTR _nBytes$56758[ebp], 0

; 43   : 
; 44   : 			for( int i=0; i<8; i++)

	mov	DWORD PTR _i$56759[ebp], 0
	jmp	SHORT $LN11@GetAChar
$LN10@GetAChar:
	mov	eax, DWORD PTR _i$56759[ebp]
	add	eax, 1
	mov	DWORD PTR _i$56759[ebp], eax
$LN11@GetAChar:
	cmp	DWORD PTR _i$56759[ebp], 8
	jge	SHORT $LN9@GetAChar

; 45   : 			{
; 46   : 				if( (nHead & nMask) == 0 )

	movzx	ecx, BYTE PTR _nHead$[ebp]
	movzx	edx, BYTE PTR _nMask$56757[ebp]
	and	ecx, edx
	jne	SHORT $LN8@GetAChar

; 47   : 					break;

	jmp	SHORT $LN9@GetAChar
$LN8@GetAChar:

; 48   : 				nBytes++;

	mov	eax, DWORD PTR _nBytes$56758[ebp]
	add	eax, 1
	mov	DWORD PTR _nBytes$56758[ebp], eax

; 49   : 				nMask >>= 1;

	mov	cl, BYTE PTR _nMask$56757[ebp]
	shr	cl, 1
	mov	BYTE PTR _nMask$56757[ebp], cl

; 50   : 			}

	jmp	SHORT $LN10@GetAChar
$LN9@GetAChar:

; 51   : 
; 52   : 			if( nBytes > 3 || nBytes < 2 )

	cmp	DWORD PTR _nBytes$56758[ebp], 3
	jg	SHORT $LN6@GetAChar
	cmp	DWORD PTR _nBytes$56758[ebp], 2
	jge	SHORT $LN7@GetAChar
$LN6@GetAChar:

; 53   : 			{
; 54   : 				// 非法的Utf8字符，转换到默认字符'?'，并把这个字节吃掉
; 55   : 				pChar[0] = 63;

	mov	edx, DWORD PTR _pChar$[ebp]
	mov	BYTE PTR [edx], 63			; 0000003fH

; 56   : 				pChar[1] = 0;

	mov	eax, DWORD PTR _pChar$[ebp]
	mov	BYTE PTR [eax+1], 0

; 57   : 				return 1;

	mov	eax, 1
	jmp	SHORT $LN15@GetAChar

; 58   : 			}
; 59   : 			else

	jmp	SHORT $LN15@GetAChar
$LN7@GetAChar:

; 60   : 			{
; 61   : 				for( int i=0; i<nBytes; i++ )

	mov	DWORD PTR _i$56767[ebp], 0
	jmp	SHORT $LN4@GetAChar
$LN3@GetAChar:
	mov	ecx, DWORD PTR _i$56767[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$56767[ebp], ecx
$LN4@GetAChar:
	mov	edx, DWORD PTR _i$56767[ebp]
	cmp	edx, DWORD PTR _nBytes$56758[ebp]
	jge	SHORT $LN2@GetAChar

; 62   : 				{
; 63   : 					// 防止分析错误的编码字串时把字串结尾的0字节吃掉
; 64   : 					if( pText[i] == 0 )

	mov	eax, DWORD PTR _pText$[ebp]
	add	eax, DWORD PTR _i$56767[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	jne	SHORT $LN1@GetAChar

; 65   : 					{
; 66   : 						pChar[i] = 0;

	mov	edx, DWORD PTR _pChar$[ebp]
	add	edx, DWORD PTR _i$56767[ebp]
	mov	BYTE PTR [edx], 0

; 67   : 						return i;

	mov	eax, DWORD PTR _i$56767[ebp]
	jmp	SHORT $LN15@GetAChar
$LN1@GetAChar:

; 68   : 					}
; 69   : 					pChar[i] = pText[i];

	mov	eax, DWORD PTR _pChar$[ebp]
	add	eax, DWORD PTR _i$56767[ebp]
	mov	ecx, DWORD PTR _pText$[ebp]
	add	ecx, DWORD PTR _i$56767[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl

; 70   : 				}

	jmp	SHORT $LN3@GetAChar
$LN2@GetAChar:

; 71   : 				pChar[nBytes] = 0;

	mov	eax, DWORD PTR _pChar$[ebp]
	add	eax, DWORD PTR _nBytes$56758[ebp]
	mov	BYTE PTR [eax], 0

; 72   : 				return nBytes;

	mov	eax, DWORD PTR _nBytes$56758[ebp]
$LN15@GetAChar:

; 73   : 			}
; 74   : 		}
; 75   : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?GetAChar@CharacterCodingUtf8@Ogre@@UAEHPBDPAE@Z ENDP	; Ogre::CharacterCodingUtf8::GetAChar
_TEXT	ENDS
PUBLIC	?GetCharBytes@CharacterCodingUtf8@Ogre@@UAEHPBE@Z ; Ogre::CharacterCodingUtf8::GetCharBytes
; Function compile flags: /Odtp
_TEXT	SEGMENT
_this$ = -20						; size = 4
_i$56782 = -16						; size = 4
_nMask$56780 = -9					; size = 1
_nBytes$56781 = -8					; size = 4
_nHead$ = -1						; size = 1
_pChar$ = 8						; size = 4
?GetCharBytes@CharacterCodingUtf8@Ogre@@UAEHPBE@Z PROC	; Ogre::CharacterCodingUtf8::GetCharBytes
; _this$ = ecx

; 78   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 79   : 		if(!pChar)

	cmp	DWORD PTR _pChar$[ebp], 0
	jne	SHORT $LN10@GetCharByt

; 80   : 			return 0;

	xor	eax, eax
	jmp	SHORT $LN11@GetCharByt
$LN10@GetCharByt:

; 81   : 
; 82   : 		unsigned char nHead = unsigned char (*pChar);

	mov	eax, DWORD PTR _pChar$[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR _nHead$[ebp], cl

; 83   : 
; 84   : 		if( (nHead & 0x80) == 0 )

	movzx	edx, BYTE PTR _nHead$[ebp]
	and	edx, 128				; 00000080H
	jne	SHORT $LN9@GetCharByt

; 85   : 		{
; 86   : 			return 1;

	mov	eax, 1
	jmp	SHORT $LN11@GetCharByt

; 87   : 		}
; 88   : 		else

	jmp	SHORT $LN11@GetCharByt
$LN9@GetCharByt:

; 89   : 		{
; 90   : 			unsigned char nMask = 0x80;

	mov	BYTE PTR _nMask$56780[ebp], 128		; 00000080H

; 91   : 			int nBytes = 0;

	mov	DWORD PTR _nBytes$56781[ebp], 0

; 92   : 
; 93   : 			for( int i=0; i<8; i++)

	mov	DWORD PTR _i$56782[ebp], 0
	jmp	SHORT $LN7@GetCharByt
$LN6@GetCharByt:
	mov	eax, DWORD PTR _i$56782[ebp]
	add	eax, 1
	mov	DWORD PTR _i$56782[ebp], eax
$LN7@GetCharByt:
	cmp	DWORD PTR _i$56782[ebp], 8
	jge	SHORT $LN5@GetCharByt

; 94   : 			{
; 95   : 				if( (nHead & nMask) == 0 )

	movzx	ecx, BYTE PTR _nHead$[ebp]
	movzx	edx, BYTE PTR _nMask$56780[ebp]
	and	ecx, edx
	jne	SHORT $LN4@GetCharByt

; 96   : 					break;

	jmp	SHORT $LN5@GetCharByt
$LN4@GetCharByt:

; 97   : 				nBytes++;

	mov	eax, DWORD PTR _nBytes$56781[ebp]
	add	eax, 1
	mov	DWORD PTR _nBytes$56781[ebp], eax

; 98   : 				nMask >>= 1;

	mov	cl, BYTE PTR _nMask$56780[ebp]
	shr	cl, 1
	mov	BYTE PTR _nMask$56780[ebp], cl

; 99   : 			}

	jmp	SHORT $LN6@GetCharByt
$LN5@GetCharByt:

; 100  : 
; 101  : 			if( nBytes > 4 || nBytes < 2 )

	cmp	DWORD PTR _nBytes$56781[ebp], 4
	jg	SHORT $LN2@GetCharByt
	cmp	DWORD PTR _nBytes$56781[ebp], 2
	jge	SHORT $LN3@GetCharByt
$LN2@GetCharByt:

; 102  : 				return 1;

	mov	eax, 1
	jmp	SHORT $LN11@GetCharByt

; 103  : 			else

	jmp	SHORT $LN11@GetCharByt
$LN3@GetCharByt:

; 104  : 				return nBytes;

	mov	eax, DWORD PTR _nBytes$56781[ebp]
$LN11@GetCharByt:

; 105  : 		}
; 106  : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
?GetCharBytes@CharacterCodingUtf8@Ogre@@UAEHPBE@Z ENDP	; Ogre::CharacterCodingUtf8::GetCharBytes
_TEXT	ENDS
PUBLIC	?GetControlCode@CharacterCodingUtf8@Ogre@@UAEHPBDAAW4EControlCode@2@_N@Z ; Ogre::CharacterCodingUtf8::GetControlCode
; Function compile flags: /Odtp
_TEXT	SEGMENT
_this$ = -12						; size = 4
_c$ = -6						; size = 1
_c1$ = -5						; size = 1
_p$ = -4						; size = 4
_pText$ = 8						; size = 4
_eCtrlCode$ = 12					; size = 4
_bDoTransfer$ = 16					; size = 1
?GetControlCode@CharacterCodingUtf8@Ogre@@UAEHPBDAAW4EControlCode@2@_N@Z PROC ; Ogre::CharacterCodingUtf8::GetControlCode
; _this$ = ecx

; 109  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 110  : 		if(!pText)

	cmp	DWORD PTR _pText$[ebp], 0
	jne	SHORT $LN11@GetControl

; 111  : 			return 0;

	xor	eax, eax
	jmp	$LN12@GetControl
$LN11@GetControl:

; 112  : 
; 113  : 		const unsigned char *p = (unsigned char *)pText;

	mov	eax, DWORD PTR _pText$[ebp]
	mov	DWORD PTR _p$[ebp], eax

; 114  : 		unsigned char c = *p;

	mov	ecx, DWORD PTR _p$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR _c$[ebp], dl

; 115  : 		unsigned char c1 = *(p + 1);

	mov	eax, DWORD PTR _p$[ebp]
	mov	cl, BYTE PTR [eax+1]
	mov	BYTE PTR _c1$[ebp], cl

; 116  : 		if(c == '\n')

	movzx	edx, BYTE PTR _c$[ebp]
	cmp	edx, 10					; 0000000aH
	jne	SHORT $LN10@GetControl

; 117  : 		{
; 118  : 			eCtrlCode = CTRLCODE_NEWLINE;

	mov	eax, DWORD PTR _eCtrlCode$[ebp]
	mov	DWORD PTR [eax], 2

; 119  : 			return 1;

	mov	eax, 1
	jmp	$LN12@GetControl
	jmp	$LN12@GetControl
$LN10@GetControl:

; 120  : 		}
; 121  : 		else if(c == '\\' && c1 == 'n')

	movzx	ecx, BYTE PTR _c$[ebp]
	cmp	ecx, 92					; 0000005cH
	jne	SHORT $LN8@GetControl
	movzx	edx, BYTE PTR _c1$[ebp]
	cmp	edx, 110				; 0000006eH
	jne	SHORT $LN8@GetControl

; 122  : 		{
; 123  : 			eCtrlCode = CTRLCODE_NEWLINE;

	mov	eax, DWORD PTR _eCtrlCode$[ebp]
	mov	DWORD PTR [eax], 2

; 124  : 			return 2;

	mov	eax, 2
	jmp	SHORT $LN12@GetControl
	jmp	SHORT $LN12@GetControl
$LN8@GetControl:

; 125  : 		}
; 126  : 		else if(c == '\r')

	movzx	ecx, BYTE PTR _c$[ebp]
	cmp	ecx, 13					; 0000000dH
	jne	SHORT $LN6@GetControl

; 127  : 		{
; 128  : 			eCtrlCode = CTRLCODE_RETURN;

	mov	edx, DWORD PTR _eCtrlCode$[ebp]
	mov	DWORD PTR [edx], 1

; 129  : 			return 1;

	mov	eax, 1
	jmp	SHORT $LN12@GetControl
	jmp	SHORT $LN12@GetControl
$LN6@GetControl:

; 130  : 		}
; 131  : 		else if(c == 0)

	movzx	eax, BYTE PTR _c$[ebp]
	test	eax, eax
	jne	SHORT $LN4@GetControl

; 132  : 		{
; 133  : 			eCtrlCode = CTRLCODE_ENDOFSTRING;

	mov	ecx, DWORD PTR _eCtrlCode$[ebp]
	mov	DWORD PTR [ecx], 3

; 134  : 			return 1;

	mov	eax, 1
	jmp	SHORT $LN12@GetControl
	jmp	SHORT $LN12@GetControl
$LN4@GetControl:

; 135  : 		}
; 136  : 		else if( bDoTransfer && c == '#' && c1 != '#')

	movzx	edx, BYTE PTR _bDoTransfer$[ebp]
	test	edx, edx
	je	SHORT $LN2@GetControl
	movzx	eax, BYTE PTR _c$[ebp]
	cmp	eax, 35					; 00000023H
	jne	SHORT $LN2@GetControl
	movzx	ecx, BYTE PTR _c1$[ebp]
	cmp	ecx, 35					; 00000023H
	je	SHORT $LN2@GetControl

; 137  : 		{
; 138  : 			eCtrlCode = CTRLCODE_TRANSFER;

	mov	edx, DWORD PTR _eCtrlCode$[ebp]
	mov	DWORD PTR [edx], 4

; 139  : 			return 1;

	mov	eax, 1
	jmp	SHORT $LN12@GetControl

; 140  : 		}
; 141  : 		else

	jmp	SHORT $LN12@GetControl
$LN2@GetControl:

; 142  : 		{
; 143  : 			eCtrlCode = CTRLCODE_CHARACTER;

	mov	eax, DWORD PTR _eCtrlCode$[ebp]
	mov	DWORD PTR [eax], 0

; 144  : 			return 0;

	xor	eax, eax
$LN12@GetControl:

; 145  : 		}
; 146  : 	}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?GetControlCode@CharacterCodingUtf8@Ogre@@UAEHPBDAAW4EControlCode@2@_N@Z ENDP ; Ogre::CharacterCodingUtf8::GetControlCode
_TEXT	ENDS
PUBLIC	?IsEnglish@CharacterCodingUtf8@Ogre@@UAE_NPBE@Z	; Ogre::CharacterCodingUtf8::IsEnglish
; Function compile flags: /Odtp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pChar$ = 8						; size = 4
?IsEnglish@CharacterCodingUtf8@Ogre@@UAE_NPBE@Z PROC	; Ogre::CharacterCodingUtf8::IsEnglish
; _this$ = ecx

; 149  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 150  : 		if( pChar[0] >= 33 && pChar[0] <= 127 )

	mov	eax, DWORD PTR _pChar$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 33					; 00000021H
	jl	SHORT $LN2@IsEnglish
	mov	edx, DWORD PTR _pChar$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 127				; 0000007fH
	jg	SHORT $LN2@IsEnglish

; 151  : 			return true;

	mov	al, 1
	jmp	SHORT $LN3@IsEnglish

; 152  : 		else

	jmp	SHORT $LN3@IsEnglish
$LN2@IsEnglish:

; 153  : 			return false;

	xor	al, al
$LN3@IsEnglish:

; 154  : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
?IsEnglish@CharacterCodingUtf8@Ogre@@UAE_NPBE@Z ENDP	; Ogre::CharacterCodingUtf8::IsEnglish
_TEXT	ENDS
PUBLIC	?IsPunctuation@CharacterCodingUtf8@Ogre@@UAE_NPBE@Z ; Ogre::CharacterCodingUtf8::IsPunctuation
; Function compile flags: /Odtp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pChar$ = 8						; size = 4
?IsPunctuation@CharacterCodingUtf8@Ogre@@UAE_NPBE@Z PROC ; Ogre::CharacterCodingUtf8::IsPunctuation
; _this$ = ecx

; 157  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 158  : 		if( pChar[0] == ',' || pChar[0] == '.' || pChar[0] == '!' || 
; 159  : 			pChar[0] == '?' || pChar[0] == ':' || pChar[0] == ';' )

	mov	eax, DWORD PTR _pChar$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 44					; 0000002cH
	je	SHORT $LN2@IsPunctuat
	mov	edx, DWORD PTR _pChar$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 46					; 0000002eH
	je	SHORT $LN2@IsPunctuat
	mov	ecx, DWORD PTR _pChar$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 33					; 00000021H
	je	SHORT $LN2@IsPunctuat
	mov	eax, DWORD PTR _pChar$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 63					; 0000003fH
	je	SHORT $LN2@IsPunctuat
	mov	edx, DWORD PTR _pChar$[ebp]
	movzx	eax, BYTE PTR [edx]
	cmp	eax, 58					; 0000003aH
	je	SHORT $LN2@IsPunctuat
	mov	ecx, DWORD PTR _pChar$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 59					; 0000003bH
	jne	SHORT $LN3@IsPunctuat
$LN2@IsPunctuat:

; 160  : 			return true;

	mov	al, 1
	jmp	SHORT $LN4@IsPunctuat

; 161  : 		else

	jmp	SHORT $LN4@IsPunctuat
$LN3@IsPunctuat:

; 162  : 			return false;

	xor	al, al
$LN4@IsPunctuat:

; 163  : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
?IsPunctuation@CharacterCodingUtf8@Ogre@@UAE_NPBE@Z ENDP ; Ogre::CharacterCodingUtf8::IsPunctuation
_TEXT	ENDS
PUBLIC	?ToUnicode@CharacterCodingUtf8@Ogre@@UAEGPBE@Z	; Ogre::CharacterCodingUtf8::ToUnicode
EXTRN	?UTF8ToUnicode@StringUtil@Ogre@@SAPB_WPBDH@Z:PROC ; Ogre::StringUtil::UTF8ToUnicode
; Function compile flags: /Odtp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pChar$ = 8						; size = 4
?ToUnicode@CharacterCodingUtf8@Ogre@@UAEGPBE@Z PROC	; Ogre::CharacterCodingUtf8::ToUnicode
; _this$ = ecx

; 166  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 167  : 		return *StringUtil::UTF8ToUnicode((const char*)pChar, GetCharBytes(pChar));

	mov	eax, DWORD PTR _pChar$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	call	eax
	push	eax
	mov	ecx, DWORD PTR _pChar$[ebp]
	push	ecx
	call	?UTF8ToUnicode@StringUtil@Ogre@@SAPB_WPBDH@Z ; Ogre::StringUtil::UTF8ToUnicode
	add	esp, 8
	mov	ax, WORD PTR [eax]

; 168  : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
?ToUnicode@CharacterCodingUtf8@Ogre@@UAEGPBE@Z ENDP	; Ogre::CharacterCodingUtf8::ToUnicode
_TEXT	ENDS
PUBLIC	?ToUniqueID@CharacterCodingUtf8@Ogre@@UAEIPBE@Z	; Ogre::CharacterCodingUtf8::ToUniqueID
EXTRN	_strlen:PROC
; Function compile flags: /Odtp
_TEXT	SEGMENT
_this$ = -12						; size = 4
_i$56834 = -8						; size = 4
_nID$ = -4						; size = 4
_pChar$ = 8						; size = 4
?ToUniqueID@CharacterCodingUtf8@Ogre@@UAEIPBE@Z PROC	; Ogre::CharacterCodingUtf8::ToUniqueID
; _this$ = ecx

; 171  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 172  : 		uint nID = 0;

	mov	DWORD PTR _nID$[ebp], 0

; 173  : 
; 174  : 		for( size_t i=0; i<strlen((const char*)pChar); i++)

	mov	DWORD PTR _i$56834[ebp], 0
	jmp	SHORT $LN3@ToUniqueID
$LN2@ToUniqueID:
	mov	eax, DWORD PTR _i$56834[ebp]
	add	eax, 1
	mov	DWORD PTR _i$56834[ebp], eax
$LN3@ToUniqueID:
	mov	ecx, DWORD PTR _pChar$[ebp]
	push	ecx
	call	_strlen
	add	esp, 4
	cmp	DWORD PTR _i$56834[ebp], eax
	jae	SHORT $LN1@ToUniqueID

; 175  : 		{
; 176  : 			nID *= 256;

	mov	edx, DWORD PTR _nID$[ebp]
	shl	edx, 8
	mov	DWORD PTR _nID$[ebp], edx

; 177  : 			nID += pChar[i];

	mov	eax, DWORD PTR _pChar$[ebp]
	add	eax, DWORD PTR _i$56834[ebp]
	movzx	ecx, BYTE PTR [eax]
	add	ecx, DWORD PTR _nID$[ebp]
	mov	DWORD PTR _nID$[ebp], ecx

; 178  : 		}

	jmp	SHORT $LN2@ToUniqueID
$LN1@ToUniqueID:

; 179  : 
; 180  : 		return nID;

	mov	eax, DWORD PTR _nID$[ebp]

; 181  : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
?ToUniqueID@CharacterCodingUtf8@Ogre@@UAEIPBE@Z ENDP	; Ogre::CharacterCodingUtf8::ToUniqueID
_TEXT	ENDS
END

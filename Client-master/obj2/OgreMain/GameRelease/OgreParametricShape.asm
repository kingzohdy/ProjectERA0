; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	i:\svnroot\client\OgreMain\OgreParametricShape.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	?_Value@?$_Is_swap_move@U_Swap_move_tag@std@@@std@@2_NB ; std::_Is_swap_move<std::_Swap_move_tag>::_Value
PUBLIC	?collate@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::collate
PUBLIC	?ctype@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::ctype
PUBLIC	?monetary@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::monetary
PUBLIC	?numeric@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::numeric
PUBLIC	?time@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::time
PUBLIC	?messages@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::messages
PUBLIC	?all@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::all
PUBLIC	?none@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::none
PUBLIC	?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::skipws
PUBLIC	?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::unitbuf
PUBLIC	?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::uppercase
PUBLIC	?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showbase
PUBLIC	?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpoint
PUBLIC	?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpos
PUBLIC	?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::left
PUBLIC	?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::right
PUBLIC	?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::internal
PUBLIC	?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::dec
PUBLIC	?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::oct
PUBLIC	?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::hex
PUBLIC	?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::scientific
PUBLIC	?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::fixed
PUBLIC	?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::hexfloat
PUBLIC	?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::boolalpha
PUBLIC	?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::_Stdio
PUBLIC	?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::adjustfield
PUBLIC	?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::basefield
PUBLIC	?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::floatfield
PUBLIC	?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::goodbit
PUBLIC	?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::eofbit
PUBLIC	?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::failbit
PUBLIC	?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::badbit
PUBLIC	?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::_Hardfail
PUBLIC	?in@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::in
PUBLIC	?out@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::out
PUBLIC	?ate@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::ate
PUBLIC	?app@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::app
PUBLIC	?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::trunc
PUBLIC	?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Nocreate
PUBLIC	?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Noreplace
PUBLIC	?binary@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::binary
PUBLIC	?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::beg
PUBLIC	?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::cur
PUBLIC	?end@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::end
PUBLIC	?value@?$integral_constant@_N$0A@@tr1@std@@2_NB	; std::tr1::integral_constant<bool,0>::value
PUBLIC	?value@?$integral_constant@_N$00@tr1@std@@2_NB	; std::tr1::integral_constant<bool,1>::value
PUBLIC	?ms_Singleton@?$Singleton@VRenderSystem@Ogre@@@Ogre@@1PAVRenderSystem@2@A ; Ogre::Singleton<Ogre::RenderSystem>::ms_Singleton
;	COMDAT ?ms_Singleton@?$Singleton@VRenderSystem@Ogre@@@Ogre@@1PAVRenderSystem@2@A
_BSS	SEGMENT
?ms_Singleton@?$Singleton@VRenderSystem@Ogre@@@Ogre@@1PAVRenderSystem@2@A DD 01H DUP (?) ; Ogre::Singleton<Ogre::RenderSystem>::ms_Singleton
_BSS	ENDS
;	COMDAT ?value@?$integral_constant@_N$00@tr1@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$00@tr1@std@@2_NB DB 01H	; std::tr1::integral_constant<bool,1>::value
CONST	ENDS
;	COMDAT ?value@?$integral_constant@_N$0A@@tr1@std@@2_NB
CONST	SEGMENT
?value@?$integral_constant@_N$0A@@tr1@std@@2_NB DB 00H	; std::tr1::integral_constant<bool,0>::value
CONST	ENDS
;	COMDAT ?end@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?end@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 02H		; std::_Iosb<int>::end
CONST	ENDS
;	COMDAT ?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 01H		; std::_Iosb<int>::cur
CONST	ENDS
;	COMDAT ?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 00H		; std::_Iosb<int>::beg
CONST	ENDS
;	COMDAT ?binary@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?binary@?$_Iosb@H@std@@2W4_Openmode@12@B DD 020H	; std::_Iosb<int>::binary
CONST	ENDS
;	COMDAT ?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B DD 080H	; std::_Iosb<int>::_Noreplace
CONST	ENDS
;	COMDAT ?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 040H	; std::_Iosb<int>::_Nocreate
CONST	ENDS
;	COMDAT ?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B DD 010H		; std::_Iosb<int>::trunc
CONST	ENDS
;	COMDAT ?app@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?app@?$_Iosb@H@std@@2W4_Openmode@12@B DD 08H		; std::_Iosb<int>::app
CONST	ENDS
;	COMDAT ?ate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?ate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 04H		; std::_Iosb<int>::ate
CONST	ENDS
;	COMDAT ?out@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?out@?$_Iosb@H@std@@2W4_Openmode@12@B DD 02H		; std::_Iosb<int>::out
CONST	ENDS
;	COMDAT ?in@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?in@?$_Iosb@H@std@@2W4_Openmode@12@B DD 01H		; std::_Iosb<int>::in
CONST	ENDS
;	COMDAT ?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B DD 010H	; std::_Iosb<int>::_Hardfail
CONST	ENDS
;	COMDAT ?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 04H		; std::_Iosb<int>::badbit
CONST	ENDS
;	COMDAT ?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 02H		; std::_Iosb<int>::failbit
CONST	ENDS
;	COMDAT ?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 01H		; std::_Iosb<int>::eofbit
CONST	ENDS
;	COMDAT ?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 00H		; std::_Iosb<int>::goodbit
CONST	ENDS
;	COMDAT ?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 03000H	; std::_Iosb<int>::floatfield
CONST	ENDS
;	COMDAT ?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0e00H	; std::_Iosb<int>::basefield
CONST	ENDS
;	COMDAT ?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01c0H	; std::_Iosb<int>::adjustfield
CONST	ENDS
;	COMDAT ?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08000H	; std::_Iosb<int>::_Stdio
CONST	ENDS
;	COMDAT ?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04000H	; std::_Iosb<int>::boolalpha
CONST	ENDS
;	COMDAT ?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 03000H	; std::_Iosb<int>::hexfloat
CONST	ENDS
;	COMDAT ?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02000H	; std::_Iosb<int>::fixed
CONST	ENDS
;	COMDAT ?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01000H	; std::_Iosb<int>::scientific
CONST	ENDS
;	COMDAT ?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0800H		; std::_Iosb<int>::hex
CONST	ENDS
;	COMDAT ?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0400H		; std::_Iosb<int>::oct
CONST	ENDS
;	COMDAT ?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0200H		; std::_Iosb<int>::dec
CONST	ENDS
;	COMDAT ?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0100H	; std::_Iosb<int>::internal
CONST	ENDS
;	COMDAT ?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 080H		; std::_Iosb<int>::right
CONST	ENDS
;	COMDAT ?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 040H		; std::_Iosb<int>::left
CONST	ENDS
;	COMDAT ?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 020H	; std::_Iosb<int>::showpos
CONST	ENDS
;	COMDAT ?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 010H	; std::_Iosb<int>::showpoint
CONST	ENDS
;	COMDAT ?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08H	; std::_Iosb<int>::showbase
CONST	ENDS
;	COMDAT ?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04H	; std::_Iosb<int>::uppercase
CONST	ENDS
;	COMDAT ?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02H	; std::_Iosb<int>::unitbuf
CONST	ENDS
;	COMDAT ?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01H		; std::_Iosb<int>::skipws
CONST	ENDS
;	COMDAT ?none@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?none@?$_Locbase@H@std@@2HB DD 00H			; std::_Locbase<int>::none
CONST	ENDS
;	COMDAT ?all@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?all@?$_Locbase@H@std@@2HB DD 03fH			; std::_Locbase<int>::all
CONST	ENDS
;	COMDAT ?messages@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?messages@?$_Locbase@H@std@@2HB DD 020H			; std::_Locbase<int>::messages
CONST	ENDS
;	COMDAT ?time@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?time@?$_Locbase@H@std@@2HB DD 010H			; std::_Locbase<int>::time
CONST	ENDS
;	COMDAT ?numeric@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?numeric@?$_Locbase@H@std@@2HB DD 08H			; std::_Locbase<int>::numeric
CONST	ENDS
;	COMDAT ?monetary@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?monetary@?$_Locbase@H@std@@2HB DD 04H			; std::_Locbase<int>::monetary
CONST	ENDS
;	COMDAT ?ctype@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?ctype@?$_Locbase@H@std@@2HB DD 02H			; std::_Locbase<int>::ctype
CONST	ENDS
;	COMDAT ?collate@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?collate@?$_Locbase@H@std@@2HB DD 01H			; std::_Locbase<int>::collate
CONST	ENDS
;	COMDAT ?_Value@?$_Is_swap_move@U_Swap_move_tag@std@@@std@@2_NB
CONST	SEGMENT
?_Value@?$_Is_swap_move@U_Swap_move_tag@std@@@std@@2_NB DB 01H ; std::_Is_swap_move<std::_Swap_move_tag>::_Value
CONST	ENDS
_DATA	SEGMENT
__bad_alloc_Message DD FLAT:$SG5716
_DATA	ENDS
CONST	SEGMENT
$SG5716	DB	'bad allocation', 00H
	ORG $+1
_MAX_FLOAT DD	07f7fffffr			; 3.40282e+038
_ONE_PI	DD	040490fd0r			; 3.14159
_EPSILON DD	03727c5acr			; 1e-005
_RADS_PER_DEG DD 03c8efa35r			; 0.0174533
_DEGS_PER_RAD DD 042652ee1r			; 57.2958
$SG69859 DB	'ParametricShape', 00H
$SG69903 DB	'g_DiffuseTex', 00H
	ORG $+3
$SG70142 DB	'g_DiffuseTex', 00H
	ORG $+3
$SG70145 DB	'g_MaskTex', 00H
CONST	ENDS
PUBLIC	??4MemoryDelegation@Ogre@@QAEAAV01@ABV01@@Z	; Ogre::MemoryDelegation::operator=
; Function compile flags: /Odtp
;	COMDAT ??4MemoryDelegation@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4MemoryDelegation@Ogre@@QAEAAV01@ABV01@@Z PROC	; Ogre::MemoryDelegation::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4MemoryDelegation@Ogre@@QAEAAV01@ABV01@@Z ENDP	; Ogre::MemoryDelegation::operator=
_TEXT	ENDS
PUBLIC	?getBaseClass@RuntimeClass@Ogre@@QBEPBV12@XZ	; Ogre::RuntimeClass::getBaseClass
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogrebaseobject.h
;	COMDAT ?getBaseClass@RuntimeClass@Ogre@@QBEPBV12@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getBaseClass@RuntimeClass@Ogre@@QBEPBV12@XZ PROC	; Ogre::RuntimeClass::getBaseClass, COMDAT
; _this$ = ecx

; 20   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 21   : 			return m_pBaseClass;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 22   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?getBaseClass@RuntimeClass@Ogre@@QBEPBV12@XZ ENDP	; Ogre::RuntimeClass::getBaseClass
_TEXT	ENDS
PUBLIC	?getClassName@RuntimeClass@Ogre@@QBEPBDXZ	; Ogre::RuntimeClass::getClassName
; Function compile flags: /Odtp
;	COMDAT ?getClassName@RuntimeClass@Ogre@@QBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getClassName@RuntimeClass@Ogre@@QBEPBDXZ PROC		; Ogre::RuntimeClass::getClassName, COMDAT
; _this$ = ecx

; 25   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 26   : 			return m_pClassName; 

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 27   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?getClassName@RuntimeClass@Ogre@@QBEPBDXZ ENDP		; Ogre::RuntimeClass::getClassName
_TEXT	ENDS
PUBLIC	?getVersion@RuntimeClass@Ogre@@QBEHXZ		; Ogre::RuntimeClass::getVersion
; Function compile flags: /Odtp
;	COMDAT ?getVersion@RuntimeClass@Ogre@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getVersion@RuntimeClass@Ogre@@QBEHXZ PROC		; Ogre::RuntimeClass::getVersion, COMDAT
; _this$ = ecx

; 30   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 31   : 			return m_Version;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]

; 32   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?getVersion@RuntimeClass@Ogre@@QBEHXZ ENDP		; Ogre::RuntimeClass::getVersion
_TEXT	ENDS
PUBLIC	?newObject@RuntimeClass@Ogre@@QAEPAVBaseObject@2@XZ ; Ogre::RuntimeClass::newObject
; Function compile flags: /Odtp
;	COMDAT ?newObject@RuntimeClass@Ogre@@QAEPAVBaseObject@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?newObject@RuntimeClass@Ogre@@QAEPAVBaseObject@2@XZ PROC ; Ogre::RuntimeClass::newObject, COMDAT
; _this$ = ecx

; 35   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 36   : 			return (*m_pNewFunc)();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	call	ecx

; 37   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?newObject@RuntimeClass@Ogre@@QAEPAVBaseObject@2@XZ ENDP ; Ogre::RuntimeClass::newObject
_TEXT	ENDS
PUBLIC	??4RuntimeClass@Ogre@@QAEAAV01@ABV01@@Z		; Ogre::RuntimeClass::operator=
; Function compile flags: /Odtp
;	COMDAT ??4RuntimeClass@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4RuntimeClass@Ogre@@QAEAAV01@ABV01@@Z PROC		; Ogre::RuntimeClass::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], edx
	mov	eax, DWORD PTR [eax+16]
	mov	DWORD PTR [ecx+16], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4RuntimeClass@Ogre@@QAEAAV01@ABV01@@Z ENDP		; Ogre::RuntimeClass::operator=
_TEXT	ENDS
PUBLIC	?getRTTI@BaseObject@Ogre@@UBEPBVRuntimeClass@2@XZ ; Ogre::BaseObject::getRTTI
EXTRN	?m_RTTI@BaseObject@Ogre@@2VRuntimeClass@2@B:BYTE ; Ogre::BaseObject::m_RTTI
; Function compile flags: /Odtp
;	COMDAT ?getRTTI@BaseObject@Ogre@@UBEPBVRuntimeClass@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getRTTI@BaseObject@Ogre@@UBEPBVRuntimeClass@2@XZ PROC	; Ogre::BaseObject::getRTTI, COMDAT
; _this$ = ecx

; 56   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 57   : 			return &m_RTTI;

	mov	eax, OFFSET ?m_RTTI@BaseObject@Ogre@@2VRuntimeClass@2@B ; Ogre::BaseObject::m_RTTI

; 58   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?getRTTI@BaseObject@Ogre@@UBEPBVRuntimeClass@2@XZ ENDP	; Ogre::BaseObject::getRTTI
_TEXT	ENDS
PUBLIC	?isExactKindOf@BaseObject@Ogre@@QBE_NPBVRuntimeClass@2@@Z ; Ogre::BaseObject::isExactKindOf
; Function compile flags: /Odtp
;	COMDAT ?isExactKindOf@BaseObject@Ogre@@QBE_NPBVRuntimeClass@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_prtti$ = 8						; size = 4
?isExactKindOf@BaseObject@Ogre@@QBE_NPBVRuntimeClass@2@@Z PROC ; Ogre::BaseObject::isExactKindOf, COMDAT
; _this$ = ecx

; 61   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 62   : 			return (getRTTI() == prtti);

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	call	eax
	xor	ecx, ecx
	cmp	eax, DWORD PTR _prtti$[ebp]
	sete	cl
	mov	al, cl

; 63   : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?isExactKindOf@BaseObject@Ogre@@QBE_NPBVRuntimeClass@2@@Z ENDP ; Ogre::BaseObject::isExactKindOf
_TEXT	ENDS
PUBLIC	?release@BaseObject@Ogre@@UAEXXZ		; Ogre::BaseObject::release
; Function compile flags: /Odtp
;	COMDAT ?release@BaseObject@Ogre@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?release@BaseObject@Ogre@@UAEXXZ PROC			; Ogre::BaseObject::release, COMDAT
; _this$ = ecx

; 68   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 69   : 			m_RefCount--;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	sub	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 70   : 			if(m_RefCount <= 0 )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jg	SHORT $LN2@release

; 71   : 			{
; 72   : 				deleteThis();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24]
	call	eax
$LN2@release:

; 73   : 			}
; 74   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?release@BaseObject@Ogre@@UAEXXZ ENDP			; Ogre::BaseObject::release
_TEXT	ENDS
PUBLIC	?addRef@BaseObject@Ogre@@UAEXXZ			; Ogre::BaseObject::addRef
; Function compile flags: /Odtp
;	COMDAT ?addRef@BaseObject@Ogre@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?addRef@BaseObject@Ogre@@UAEXXZ PROC			; Ogre::BaseObject::addRef, COMDAT
; _this$ = ecx

; 77   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 78   : 			m_RefCount++;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 79   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?addRef@BaseObject@Ogre@@UAEXXZ ENDP			; Ogre::BaseObject::addRef
_TEXT	ENDS
PUBLIC	?getRefCount@BaseObject@Ogre@@UAEHXZ		; Ogre::BaseObject::getRefCount
; Function compile flags: /Odtp
;	COMDAT ?getRefCount@BaseObject@Ogre@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getRefCount@BaseObject@Ogre@@UAEHXZ PROC		; Ogre::BaseObject::getRefCount, COMDAT
; _this$ = ecx

; 82   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 83   : 			return m_RefCount;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 84   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?getRefCount@BaseObject@Ogre@@UAEHXZ ENDP		; Ogre::BaseObject::getRefCount
_TEXT	ENDS
PUBLIC	?_serialize@BaseObject@Ogre@@UAEXAAVArchive@2@H@Z ; Ogre::BaseObject::_serialize
; Function compile flags: /Odtp
;	COMDAT ?_serialize@BaseObject@Ogre@@UAEXAAVArchive@2@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_ar$ = 8						; size = 4
_version$ = 12						; size = 4
?_serialize@BaseObject@Ogre@@UAEXAAVArchive@2@H@Z PROC	; Ogre::BaseObject::_serialize, COMDAT
; _this$ = ecx

; 87   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 88   : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?_serialize@BaseObject@Ogre@@UAEXAAVArchive@2@H@Z ENDP	; Ogre::BaseObject::_serialize
_TEXT	ENDS
PUBLIC	??_7BaseObject@Ogre@@6B@			; Ogre::BaseObject::`vftable'
PUBLIC	??0BaseObject@Ogre@@IAE@XZ			; Ogre::BaseObject::BaseObject
PUBLIC	??_R4BaseObject@Ogre@@6B@			; Ogre::BaseObject::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVBaseObject@Ogre@@@8			; Ogre::BaseObject `RTTI Type Descriptor'
PUBLIC	??_R3BaseObject@Ogre@@8				; Ogre::BaseObject::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2BaseObject@Ogre@@8				; Ogre::BaseObject::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@BaseObject@Ogre@@8		; Ogre::BaseObject::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R13?0A@EA@MemoryDelegation@Ogre@@8		; Ogre::MemoryDelegation::`RTTI Base Class Descriptor at (4,-1,0,64)'
PUBLIC	??_R0?AVMemoryDelegation@Ogre@@@8		; Ogre::MemoryDelegation `RTTI Type Descriptor'
PUBLIC	??_R3MemoryDelegation@Ogre@@8			; Ogre::MemoryDelegation::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2MemoryDelegation@Ogre@@8			; Ogre::MemoryDelegation::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@MemoryDelegation@Ogre@@8		; Ogre::MemoryDelegation::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_EBaseObject@Ogre@@MAEPAXI@Z			; Ogre::BaseObject::`vector deleting destructor'
PUBLIC	?deleteThis@BaseObject@Ogre@@MAEXXZ		; Ogre::BaseObject::deleteThis
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
;	COMDAT ??_R1A@?0A@EA@MemoryDelegation@Ogre@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@MemoryDelegation@Ogre@@8 DD FLAT:??_R0?AVMemoryDelegation@Ogre@@@8 ; Ogre::MemoryDelegation::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3MemoryDelegation@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R2MemoryDelegation@Ogre@@8
rdata$r	SEGMENT
??_R2MemoryDelegation@Ogre@@8 DD FLAT:??_R1A@?0A@EA@MemoryDelegation@Ogre@@8 ; Ogre::MemoryDelegation::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3MemoryDelegation@Ogre@@8
rdata$r	SEGMENT
??_R3MemoryDelegation@Ogre@@8 DD 00H			; Ogre::MemoryDelegation::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2MemoryDelegation@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVMemoryDelegation@Ogre@@@8
_DATA	SEGMENT
??_R0?AVMemoryDelegation@Ogre@@@8 DD FLAT:??_7type_info@@6B@ ; Ogre::MemoryDelegation `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVMemoryDelegation@Ogre@@', 00H
_DATA	ENDS
;	COMDAT ??_R13?0A@EA@MemoryDelegation@Ogre@@8
rdata$r	SEGMENT
??_R13?0A@EA@MemoryDelegation@Ogre@@8 DD FLAT:??_R0?AVMemoryDelegation@Ogre@@@8 ; Ogre::MemoryDelegation::`RTTI Base Class Descriptor at (4,-1,0,64)'
	DD	00H
	DD	04H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3MemoryDelegation@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@BaseObject@Ogre@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@BaseObject@Ogre@@8 DD FLAT:??_R0?AVBaseObject@Ogre@@@8 ; Ogre::BaseObject::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3BaseObject@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R2BaseObject@Ogre@@8
rdata$r	SEGMENT
??_R2BaseObject@Ogre@@8 DD FLAT:??_R1A@?0A@EA@BaseObject@Ogre@@8 ; Ogre::BaseObject::`RTTI Base Class Array'
	DD	FLAT:??_R13?0A@EA@MemoryDelegation@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R3BaseObject@Ogre@@8
rdata$r	SEGMENT
??_R3BaseObject@Ogre@@8 DD 00H				; Ogre::BaseObject::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2BaseObject@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVBaseObject@Ogre@@@8
_DATA	SEGMENT
??_R0?AVBaseObject@Ogre@@@8 DD FLAT:??_7type_info@@6B@	; Ogre::BaseObject `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVBaseObject@Ogre@@', 00H
_DATA	ENDS
;	COMDAT ??_R4BaseObject@Ogre@@6B@
rdata$r	SEGMENT
??_R4BaseObject@Ogre@@6B@ DD 00H			; Ogre::BaseObject::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVBaseObject@Ogre@@@8
	DD	FLAT:??_R3BaseObject@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_7BaseObject@Ogre@@6B@
CONST	SEGMENT
??_7BaseObject@Ogre@@6B@ DD FLAT:??_R4BaseObject@Ogre@@6B@ ; Ogre::BaseObject::`vftable'
	DD	FLAT:?getRTTI@BaseObject@Ogre@@UBEPBVRuntimeClass@2@XZ
	DD	FLAT:?release@BaseObject@Ogre@@UAEXXZ
	DD	FLAT:?addRef@BaseObject@Ogre@@UAEXXZ
	DD	FLAT:?getRefCount@BaseObject@Ogre@@UAEHXZ
	DD	FLAT:?_serialize@BaseObject@Ogre@@UAEXAAVArchive@2@H@Z
	DD	FLAT:??_EBaseObject@Ogre@@MAEPAXI@Z
	DD	FLAT:?deleteThis@BaseObject@Ogre@@MAEXXZ
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ??0BaseObject@Ogre@@IAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0BaseObject@Ogre@@IAE@XZ PROC				; Ogre::BaseObject::BaseObject, COMDAT
; _this$ = ecx

; 92   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7BaseObject@Ogre@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], 1

; 93   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0BaseObject@Ogre@@IAE@XZ ENDP				; Ogre::BaseObject::BaseObject
_TEXT	ENDS
PUBLIC	??1BaseObject@Ogre@@MAE@XZ			; Ogre::BaseObject::~BaseObject
; Function compile flags: /Odtp
;	COMDAT ??1BaseObject@Ogre@@MAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1BaseObject@Ogre@@MAE@XZ PROC				; Ogre::BaseObject::~BaseObject, COMDAT
; _this$ = ecx

; 96   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7BaseObject@Ogre@@6B@

; 97   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??1BaseObject@Ogre@@MAE@XZ ENDP				; Ogre::BaseObject::~BaseObject
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?deleteThis@BaseObject@Ogre@@MAEXXZ
_TEXT	SEGMENT
tv70 = -16						; size = 4
_this$ = -12						; size = 4
$T92991 = -8						; size = 4
$T92990 = -4						; size = 4
?deleteThis@BaseObject@Ogre@@MAEXXZ PROC		; Ogre::BaseObject::deleteThis, COMDAT
; _this$ = ecx

; 100  : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 101  : 			delete this;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR $T92991[ebp], eax
	mov	ecx, DWORD PTR $T92991[ebp]
	mov	DWORD PTR $T92990[ebp], ecx
	cmp	DWORD PTR $T92990[ebp], 0
	je	SHORT $LN3@deleteThis
	push	1
	mov	edx, DWORD PTR $T92990[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR $T92990[ebp]
	mov	edx, DWORD PTR [eax+20]
	call	edx
	mov	DWORD PTR tv70[ebp], eax
	jmp	SHORT $LN1@deleteThis
$LN3@deleteThis:
	mov	DWORD PTR tv70[ebp], 0
$LN1@deleteThis:

; 102  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?deleteThis@BaseObject@Ogre@@MAEXXZ ENDP		; Ogre::BaseObject::deleteThis
_TEXT	ENDS
PUBLIC	??0BaseObject@Ogre@@QAE@ABV01@@Z		; Ogre::BaseObject::BaseObject
; Function compile flags: /Odtp
;	COMDAT ??0BaseObject@Ogre@@QAE@ABV01@@Z
_TEXT	SEGMENT
tv68 = -8						; size = 4
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0BaseObject@Ogre@@QAE@ABV01@@Z PROC			; Ogre::BaseObject::BaseObject, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	cmp	DWORD PTR ___that$[ebp], 0
	je	SHORT $LN3@BaseObject
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 4
	mov	DWORD PTR tv68[ebp], eax
	jmp	SHORT $LN4@BaseObject
$LN3@BaseObject:
	mov	DWORD PTR tv68[ebp], 0
$LN4@BaseObject:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7BaseObject@Ogre@@6B@
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0BaseObject@Ogre@@QAE@ABV01@@Z ENDP			; Ogre::BaseObject::BaseObject
_TEXT	ENDS
PUBLIC	??4BaseObject@Ogre@@QAEAAV01@ABV01@@Z		; Ogre::BaseObject::operator=
; Function compile flags: /Odtp
;	COMDAT ??4BaseObject@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4BaseObject@Ogre@@QAEAAV01@ABV01@@Z PROC		; Ogre::BaseObject::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4BaseObject@Ogre@@QAEAAV01@ABV01@@Z ENDP		; Ogre::BaseObject::operator=
_TEXT	ENDS
PUBLIC	??_GBaseObject@Ogre@@MAEPAXI@Z			; Ogre::BaseObject::`scalar deleting destructor'
EXTRN	??3MemoryDelegation@Ogre@@SAXPAXI@Z:PROC	; Ogre::MemoryDelegation::operator delete
; Function compile flags: /Odtp
;	COMDAT ??_GBaseObject@Ogre@@MAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GBaseObject@Ogre@@MAEPAXI@Z PROC			; Ogre::BaseObject::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1BaseObject@Ogre@@MAE@XZ		; Ogre::BaseObject::~BaseObject
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar
	push	8
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3MemoryDelegation@Ogre@@SAXPAXI@Z	; Ogre::MemoryDelegation::operator delete
	add	esp, 8
$LN1@scalar:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GBaseObject@Ogre@@MAEPAXI@Z ENDP			; Ogre::BaseObject::`scalar deleting destructor'
_TEXT	ENDS
EXTRN	??_VMemoryDelegation@Ogre@@SAXPAXI@Z:PROC	; Ogre::MemoryDelegation::operator delete[]
EXTRN	??_M@YGXPAXIHP6EX0@Z@Z:PROC			; `eh vector destructor iterator'
; Function compile flags: /Odtp
;	COMDAT ??_EBaseObject@Ogre@@MAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_EBaseObject@Ogre@@MAEPAXI@Z PROC			; Ogre::BaseObject::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 2
	je	SHORT $LN3@vector
	push	OFFSET ??1BaseObject@Ogre@@MAE@XZ	; Ogre::BaseObject::~BaseObject
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx-4]
	push	edx
	push	8
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??_M@YGXPAXIHP6EX0@Z@Z
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN2@vector
	push	8
	mov	edx, DWORD PTR _this$[ebp]
	sub	edx, 4
	push	edx
	call	??_VMemoryDelegation@Ogre@@SAXPAXI@Z	; Ogre::MemoryDelegation::operator delete[]
	add	esp, 8
$LN2@vector:
	mov	eax, DWORD PTR _this$[ebp]
	sub	eax, 4
	jmp	SHORT $LN4@vector
$LN3@vector:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1BaseObject@Ogre@@MAE@XZ		; Ogre::BaseObject::~BaseObject
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@vector
	push	8
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3MemoryDelegation@Ogre@@SAXPAXI@Z	; Ogre::MemoryDelegation::operator delete
	add	esp, 8
$LN1@vector:
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector:
	mov	esp, ebp
	pop	ebp
	ret	4
??_EBaseObject@Ogre@@MAEPAXI@Z ENDP			; Ogre::BaseObject::`vector deleting destructor'
_TEXT	ENDS
PUBLIC	??_7DataStream@Ogre@@6B@			; Ogre::DataStream::`vftable'
PUBLIC	??0DataStream@Ogre@@QAE@XZ			; Ogre::DataStream::DataStream
PUBLIC	??_R4DataStream@Ogre@@6B@			; Ogre::DataStream::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVDataStream@Ogre@@@8			; Ogre::DataStream `RTTI Type Descriptor'
PUBLIC	??_R3DataStream@Ogre@@8				; Ogre::DataStream::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2DataStream@Ogre@@8				; Ogre::DataStream::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@DataStream@Ogre@@8		; Ogre::DataStream::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_EDataStream@Ogre@@UAEPAXI@Z			; Ogre::DataStream::`vector deleting destructor'
PUBLIC	?size@DataStream@Ogre@@UBEIXZ			; Ogre::DataStream::size
EXTRN	__imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:PROC
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:PROC
EXTRN	___security_cookie:DWORD
EXTRN	___CxxFrameHandler3:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__purecall:PROC
EXTRN	?readLine@DataStream@Ogre@@UAEIPADIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z:PROC ; Ogre::DataStream::readLine
EXTRN	?getLine@DataStream@Ogre@@UAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z:PROC ; Ogre::DataStream::getLine
EXTRN	?getAsString@DataStream@Ogre@@UAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ:PROC ; Ogre::DataStream::getAsString
EXTRN	?skipLine@DataStream@Ogre@@UAEIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z:PROC ; Ogre::DataStream::skipLine
;	COMDAT ??_R1A@?0A@EA@DataStream@Ogre@@8
; File i:\svnroot\client\ogremain\ogredatastream.h
rdata$r	SEGMENT
??_R1A@?0A@EA@DataStream@Ogre@@8 DD FLAT:??_R0?AVDataStream@Ogre@@@8 ; Ogre::DataStream::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3DataStream@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R2DataStream@Ogre@@8
rdata$r	SEGMENT
??_R2DataStream@Ogre@@8 DD FLAT:??_R1A@?0A@EA@DataStream@Ogre@@8 ; Ogre::DataStream::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3DataStream@Ogre@@8
rdata$r	SEGMENT
??_R3DataStream@Ogre@@8 DD 00H				; Ogre::DataStream::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2DataStream@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVDataStream@Ogre@@@8
_DATA	SEGMENT
??_R0?AVDataStream@Ogre@@@8 DD FLAT:??_7type_info@@6B@	; Ogre::DataStream `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVDataStream@Ogre@@', 00H
_DATA	ENDS
;	COMDAT ??_R4DataStream@Ogre@@6B@
rdata$r	SEGMENT
??_R4DataStream@Ogre@@6B@ DD 00H			; Ogre::DataStream::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVDataStream@Ogre@@@8
	DD	FLAT:??_R3DataStream@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_7DataStream@Ogre@@6B@
CONST	SEGMENT
??_7DataStream@Ogre@@6B@ DD FLAT:??_R4DataStream@Ogre@@6B@ ; Ogre::DataStream::`vftable'
	DD	FLAT:??_EDataStream@Ogre@@UAEPAXI@Z
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:?readLine@DataStream@Ogre@@UAEIPADIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	FLAT:?getLine@DataStream@Ogre@@UAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z
	DD	FLAT:?getAsString@DataStream@Ogre@@UAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
	DD	FLAT:?skipLine@DataStream@Ogre@@UAEIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:?size@DataStream@Ogre@@UBEIXZ
	DD	FLAT:__purecall
	DD	FLAT:__purecall
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0DataStream@Ogre@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0DataStream@Ogre@@QAE@XZ$0
__ehfuncinfo$??0DataStream@Ogre@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0DataStream@Ogre@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0DataStream@Ogre@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0DataStream@Ogre@@QAE@XZ PROC				; Ogre::DataStream::DataStream, COMDAT
; _this$ = ecx

; 68   : 		DataStream() : mSize(0) {}

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0DataStream@Ogre@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7DataStream@Ogre@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+32], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0DataStream@Ogre@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$??0DataStream@Ogre@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0DataStream@Ogre@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0DataStream@Ogre@@QAE@XZ ENDP				; Ogre::DataStream::DataStream
PUBLIC	??0DataStream@Ogre@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Ogre::DataStream::DataStream
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0DataStream@Ogre@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0DataStream@Ogre@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$0
__ehfuncinfo$??0DataStream@Ogre@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0DataStream@Ogre@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0DataStream@Ogre@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_name$ = 8						; size = 4
??0DataStream@Ogre@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; Ogre::DataStream::DataStream, COMDAT
; _this$ = ecx

; 70   : 		DataStream(const String& name) : mName(name), mSize(0) {}

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0DataStream@Ogre@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7DataStream@Ogre@@6B@
	mov	ecx, DWORD PTR _name$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+32], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0DataStream@Ogre@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$??0DataStream@Ogre@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0DataStream@Ogre@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0DataStream@Ogre@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; Ogre::DataStream::DataStream
PUBLIC	?getName@DataStream@Ogre@@QAEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ; Ogre::DataStream::getName
; Function compile flags: /Odtp
;	COMDAT ?getName@DataStream@Ogre@@QAEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getName@DataStream@Ogre@@QAEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ PROC ; Ogre::DataStream::getName, COMDAT
; _this$ = ecx

; 72   : 		const String& getName(void) { return mName; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4
	mov	esp, ebp
	pop	ebp
	ret	0
?getName@DataStream@Ogre@@QAEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ENDP ; Ogre::DataStream::getName
_TEXT	ENDS
PUBLIC	??1DataStream@Ogre@@UAE@XZ			; Ogre::DataStream::~DataStream
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1DataStream@Ogre@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1DataStream@Ogre@@UAE@XZ$0
__ehfuncinfo$??1DataStream@Ogre@@UAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1DataStream@Ogre@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1DataStream@Ogre@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1DataStream@Ogre@@UAE@XZ PROC				; Ogre::DataStream::~DataStream, COMDAT
; _this$ = ecx

; 73   : 		virtual ~DataStream() {}

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1DataStream@Ogre@@UAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7DataStream@Ogre@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1DataStream@Ogre@@UAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$??1DataStream@Ogre@@UAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1DataStream@Ogre@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1DataStream@Ogre@@UAE@XZ ENDP				; Ogre::DataStream::~DataStream
; Function compile flags: /Odtp
;	COMDAT ?size@DataStream@Ogre@@UBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@DataStream@Ogre@@UBEIXZ PROC			; Ogre::DataStream::size, COMDAT
; _this$ = ecx

; 157  : 		virtual size_t size(void) const { return mSize; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+32]
	mov	esp, ebp
	pop	ebp
	ret	0
?size@DataStream@Ogre@@UBEIXZ ENDP			; Ogre::DataStream::size
_TEXT	ENDS
PUBLIC	??0DataStream@Ogre@@QAE@ABV01@@Z		; Ogre::DataStream::DataStream
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0DataStream@Ogre@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0DataStream@Ogre@@QAE@ABV01@@Z$0
__ehfuncinfo$??0DataStream@Ogre@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0DataStream@Ogre@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0DataStream@Ogre@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0DataStream@Ogre@@QAE@ABV01@@Z PROC			; Ogre::DataStream::DataStream, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0DataStream@Ogre@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7DataStream@Ogre@@6B@
	mov	ecx, DWORD PTR ___that$[ebp]
	add	ecx, 4
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	DWORD PTR [edx+32], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0DataStream@Ogre@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$??0DataStream@Ogre@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0DataStream@Ogre@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0DataStream@Ogre@@QAE@ABV01@@Z ENDP			; Ogre::DataStream::DataStream
PUBLIC	??4DataStream@Ogre@@QAEAAV01@ABV01@@Z		; Ogre::DataStream::operator=
EXTRN	__imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z:PROC
; Function compile flags: /Odtp
;	COMDAT ??4DataStream@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4DataStream@Ogre@@QAEAAV01@ABV01@@Z PROC		; Ogre::DataStream::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	DWORD PTR [ecx+32], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4DataStream@Ogre@@QAEAAV01@ABV01@@Z ENDP		; Ogre::DataStream::operator=
_TEXT	ENDS
PUBLIC	??_GDataStream@Ogre@@UAEPAXI@Z			; Ogre::DataStream::`scalar deleting destructor'
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
; Function compile flags: /Odtp
;	COMDAT ??_GDataStream@Ogre@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GDataStream@Ogre@@UAEPAXI@Z PROC			; Ogre::DataStream::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1DataStream@Ogre@@UAE@XZ		; Ogre::DataStream::~DataStream
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@2
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@2:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GDataStream@Ogre@@UAEPAXI@Z ENDP			; Ogre::DataStream::`scalar deleting destructor'
_TEXT	ENDS
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
; Function compile flags: /Odtp
;	COMDAT ??_EDataStream@Ogre@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_EDataStream@Ogre@@UAEPAXI@Z PROC			; Ogre::DataStream::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 2
	je	SHORT $LN3@vector@2
	push	OFFSET ??1DataStream@Ogre@@UAE@XZ	; Ogre::DataStream::~DataStream
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx-4]
	push	edx
	push	36					; 00000024H
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??_M@YGXPAXIHP6EX0@Z@Z
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN2@vector@2
	mov	edx, DWORD PTR _this$[ebp]
	sub	edx, 4
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN2@vector@2:
	mov	eax, DWORD PTR _this$[ebp]
	sub	eax, 4
	jmp	SHORT $LN4@vector@2
$LN3@vector@2:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1DataStream@Ogre@@UAE@XZ		; Ogre::DataStream::~DataStream
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@vector@2
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@vector@2:
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector@2:
	mov	esp, ebp
	pop	ebp
	ret	4
??_EDataStream@Ogre@@UAEPAXI@Z ENDP			; Ogre::DataStream::`vector deleting destructor'
_TEXT	ENDS
PUBLIC	?getPtr@MemoryDataStream@Ogre@@QAEPAEXZ		; Ogre::MemoryDataStream::getPtr
; Function compile flags: /Odtp
;	COMDAT ?getPtr@MemoryDataStream@Ogre@@QAEPAEXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getPtr@MemoryDataStream@Ogre@@QAEPAEXZ PROC		; Ogre::MemoryDataStream::getPtr, COMDAT
; _this$ = ecx

; 267  : 		uchar* getPtr(void) { return mData; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+36]
	mov	esp, ebp
	pop	ebp
	ret	0
?getPtr@MemoryDataStream@Ogre@@QAEPAEXZ ENDP		; Ogre::MemoryDataStream::getPtr
_TEXT	ENDS
PUBLIC	?getCurrentPtr@MemoryDataStream@Ogre@@QAEPAEXZ	; Ogre::MemoryDataStream::getCurrentPtr
; Function compile flags: /Odtp
;	COMDAT ?getCurrentPtr@MemoryDataStream@Ogre@@QAEPAEXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getCurrentPtr@MemoryDataStream@Ogre@@QAEPAEXZ PROC	; Ogre::MemoryDataStream::getCurrentPtr, COMDAT
; _this$ = ecx

; 270  : 		uchar* getCurrentPtr(void) { return mPos; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+40]
	mov	esp, ebp
	pop	ebp
	ret	0
?getCurrentPtr@MemoryDataStream@Ogre@@QAEPAEXZ ENDP	; Ogre::MemoryDataStream::getCurrentPtr
_TEXT	ENDS
PUBLIC	?getMemoryImage@MemoryDataStream@Ogre@@UAEPAXXZ	; Ogre::MemoryDataStream::getMemoryImage
; Function compile flags: /Odtp
;	COMDAT ?getMemoryImage@MemoryDataStream@Ogre@@UAEPAXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getMemoryImage@MemoryDataStream@Ogre@@UAEPAXXZ PROC	; Ogre::MemoryDataStream::getMemoryImage, COMDAT
; _this$ = ecx

; 307  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 308  : 			return mData;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+36]

; 309  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?getMemoryImage@MemoryDataStream@Ogre@@UAEPAXXZ ENDP	; Ogre::MemoryDataStream::getMemoryImage
_TEXT	ENDS
PUBLIC	?setFreeOnClose@MemoryDataStream@Ogre@@QAEXP6AXPAX@Z@Z ; Ogre::MemoryDataStream::setFreeOnClose
; Function compile flags: /Odtp
;	COMDAT ?setFreeOnClose@MemoryDataStream@Ogre@@QAEXP6AXPAX@Z@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_freeOnClose$ = 8					; size = 4
?setFreeOnClose@MemoryDataStream@Ogre@@QAEXP6AXPAX@Z@Z PROC ; Ogre::MemoryDataStream::setFreeOnClose, COMDAT
; _this$ = ecx

; 313  : 		void setFreeOnClose(void (*freeOnClose)(void *)) { mFreeOnClose = freeOnClose; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _freeOnClose$[ebp]
	mov	DWORD PTR [eax+48], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?setFreeOnClose@MemoryDataStream@Ogre@@QAEXP6AXPAX@Z@Z ENDP ; Ogre::MemoryDataStream::setFreeOnClose
_TEXT	ENDS
PUBLIC	??_7MemoryDataStream@Ogre@@6B@			; Ogre::MemoryDataStream::`vftable'
PUBLIC	??0MemoryDataStream@Ogre@@QAE@ABV01@@Z		; Ogre::MemoryDataStream::MemoryDataStream
PUBLIC	??_R4MemoryDataStream@Ogre@@6B@			; Ogre::MemoryDataStream::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVMemoryDataStream@Ogre@@@8		; Ogre::MemoryDataStream `RTTI Type Descriptor'
PUBLIC	??_R3MemoryDataStream@Ogre@@8			; Ogre::MemoryDataStream::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2MemoryDataStream@Ogre@@8			; Ogre::MemoryDataStream::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@MemoryDataStream@Ogre@@8		; Ogre::MemoryDataStream::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_EMemoryDataStream@Ogre@@UAEPAXI@Z		; Ogre::MemoryDataStream::`vector deleting destructor'
EXTRN	?read@MemoryDataStream@Ogre@@UAEIPAXI@Z:PROC	; Ogre::MemoryDataStream::read
EXTRN	?write@MemoryDataStream@Ogre@@UAEIPBXI@Z:PROC	; Ogre::MemoryDataStream::write
EXTRN	?readLine@MemoryDataStream@Ogre@@UAEIPADIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z:PROC ; Ogre::MemoryDataStream::readLine
EXTRN	?skipLine@MemoryDataStream@Ogre@@UAEIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z:PROC ; Ogre::MemoryDataStream::skipLine
EXTRN	?skip@MemoryDataStream@Ogre@@UAEXJ@Z:PROC	; Ogre::MemoryDataStream::skip
EXTRN	?seek@MemoryDataStream@Ogre@@UAEXI@Z:PROC	; Ogre::MemoryDataStream::seek
EXTRN	?tell@MemoryDataStream@Ogre@@UBEIXZ:PROC	; Ogre::MemoryDataStream::tell
EXTRN	?eof@MemoryDataStream@Ogre@@UBE_NXZ:PROC	; Ogre::MemoryDataStream::eof
EXTRN	?close@MemoryDataStream@Ogre@@UAEXXZ:PROC	; Ogre::MemoryDataStream::close
;	COMDAT ??_R1A@?0A@EA@MemoryDataStream@Ogre@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@MemoryDataStream@Ogre@@8 DD FLAT:??_R0?AVMemoryDataStream@Ogre@@@8 ; Ogre::MemoryDataStream::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3MemoryDataStream@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R2MemoryDataStream@Ogre@@8
rdata$r	SEGMENT
??_R2MemoryDataStream@Ogre@@8 DD FLAT:??_R1A@?0A@EA@MemoryDataStream@Ogre@@8 ; Ogre::MemoryDataStream::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@DataStream@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R3MemoryDataStream@Ogre@@8
rdata$r	SEGMENT
??_R3MemoryDataStream@Ogre@@8 DD 00H			; Ogre::MemoryDataStream::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2MemoryDataStream@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVMemoryDataStream@Ogre@@@8
_DATA	SEGMENT
??_R0?AVMemoryDataStream@Ogre@@@8 DD FLAT:??_7type_info@@6B@ ; Ogre::MemoryDataStream `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVMemoryDataStream@Ogre@@', 00H
_DATA	ENDS
;	COMDAT ??_R4MemoryDataStream@Ogre@@6B@
rdata$r	SEGMENT
??_R4MemoryDataStream@Ogre@@6B@ DD 00H			; Ogre::MemoryDataStream::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVMemoryDataStream@Ogre@@@8
	DD	FLAT:??_R3MemoryDataStream@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_7MemoryDataStream@Ogre@@6B@
CONST	SEGMENT
??_7MemoryDataStream@Ogre@@6B@ DD FLAT:??_R4MemoryDataStream@Ogre@@6B@ ; Ogre::MemoryDataStream::`vftable'
	DD	FLAT:??_EMemoryDataStream@Ogre@@UAEPAXI@Z
	DD	FLAT:?read@MemoryDataStream@Ogre@@UAEIPAXI@Z
	DD	FLAT:?write@MemoryDataStream@Ogre@@UAEIPBXI@Z
	DD	FLAT:?readLine@MemoryDataStream@Ogre@@UAEIPADIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	FLAT:?getLine@DataStream@Ogre@@UAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z
	DD	FLAT:?getAsString@DataStream@Ogre@@UAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
	DD	FLAT:?skipLine@MemoryDataStream@Ogre@@UAEIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	FLAT:?skip@MemoryDataStream@Ogre@@UAEXJ@Z
	DD	FLAT:?seek@MemoryDataStream@Ogre@@UAEXI@Z
	DD	FLAT:?tell@MemoryDataStream@Ogre@@UBEIXZ
	DD	FLAT:?eof@MemoryDataStream@Ogre@@UBE_NXZ
	DD	FLAT:?size@DataStream@Ogre@@UBEIXZ
	DD	FLAT:?close@MemoryDataStream@Ogre@@UAEXXZ
	DD	FLAT:?getMemoryImage@MemoryDataStream@Ogre@@UAEPAXXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0MemoryDataStream@Ogre@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0MemoryDataStream@Ogre@@QAE@ABV01@@Z$0
__ehfuncinfo$??0MemoryDataStream@Ogre@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0MemoryDataStream@Ogre@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0MemoryDataStream@Ogre@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0MemoryDataStream@Ogre@@QAE@ABV01@@Z PROC		; Ogre::MemoryDataStream::MemoryDataStream, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0MemoryDataStream@Ogre@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0DataStream@Ogre@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7MemoryDataStream@Ogre@@6B@
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR [edx+36], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	DWORD PTR [edx+40], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	DWORD PTR [edx+44], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	mov	DWORD PTR [edx+48], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0MemoryDataStream@Ogre@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1DataStream@Ogre@@UAE@XZ		; Ogre::DataStream::~DataStream
__ehhandler$??0MemoryDataStream@Ogre@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0MemoryDataStream@Ogre@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0MemoryDataStream@Ogre@@QAE@ABV01@@Z ENDP		; Ogre::MemoryDataStream::MemoryDataStream
PUBLIC	??4MemoryDataStream@Ogre@@QAEAAV01@ABV01@@Z	; Ogre::MemoryDataStream::operator=
; Function compile flags: /Odtp
;	COMDAT ??4MemoryDataStream@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4MemoryDataStream@Ogre@@QAEAAV01@ABV01@@Z PROC	; Ogre::MemoryDataStream::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4DataStream@Ogre@@QAEAAV01@ABV01@@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	DWORD PTR [ecx+36], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	DWORD PTR [ecx+40], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+44]
	mov	DWORD PTR [ecx+44], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+48]
	mov	DWORD PTR [ecx+48], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4MemoryDataStream@Ogre@@QAEAAV01@ABV01@@Z ENDP	; Ogre::MemoryDataStream::operator=
_TEXT	ENDS
PUBLIC	??_GMemoryDataStream@Ogre@@UAEPAXI@Z		; Ogre::MemoryDataStream::`scalar deleting destructor'
EXTRN	??1MemoryDataStream@Ogre@@UAE@XZ:PROC		; Ogre::MemoryDataStream::~MemoryDataStream
; Function compile flags: /Odtp
;	COMDAT ??_GMemoryDataStream@Ogre@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GMemoryDataStream@Ogre@@UAEPAXI@Z PROC		; Ogre::MemoryDataStream::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1MemoryDataStream@Ogre@@UAE@XZ	; Ogre::MemoryDataStream::~MemoryDataStream
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@3
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@3:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GMemoryDataStream@Ogre@@UAEPAXI@Z ENDP		; Ogre::MemoryDataStream::`scalar deleting destructor'
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_EMemoryDataStream@Ogre@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_EMemoryDataStream@Ogre@@UAEPAXI@Z PROC		; Ogre::MemoryDataStream::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 2
	je	SHORT $LN3@vector@3
	push	OFFSET ??1MemoryDataStream@Ogre@@UAE@XZ	; Ogre::MemoryDataStream::~MemoryDataStream
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx-4]
	push	edx
	push	52					; 00000034H
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??_M@YGXPAXIHP6EX0@Z@Z
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN2@vector@3
	mov	edx, DWORD PTR _this$[ebp]
	sub	edx, 4
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN2@vector@3:
	mov	eax, DWORD PTR _this$[ebp]
	sub	eax, 4
	jmp	SHORT $LN4@vector@3
$LN3@vector@3:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1MemoryDataStream@Ogre@@UAE@XZ	; Ogre::MemoryDataStream::~MemoryDataStream
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@vector@3
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@vector@3:
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector@3:
	mov	esp, ebp
	pop	ebp
	ret	4
??_EMemoryDataStream@Ogre@@UAEPAXI@Z ENDP		; Ogre::MemoryDataStream::`vector deleting destructor'
_TEXT	ENDS
PUBLIC	??_7FileStreamDataStream@Ogre@@6B@		; Ogre::FileStreamDataStream::`vftable'
PUBLIC	??0FileStreamDataStream@Ogre@@QAE@ABV01@@Z	; Ogre::FileStreamDataStream::FileStreamDataStream
PUBLIC	??_R4FileStreamDataStream@Ogre@@6B@		; Ogre::FileStreamDataStream::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVFileStreamDataStream@Ogre@@@8		; Ogre::FileStreamDataStream `RTTI Type Descriptor'
PUBLIC	??_R3FileStreamDataStream@Ogre@@8		; Ogre::FileStreamDataStream::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2FileStreamDataStream@Ogre@@8		; Ogre::FileStreamDataStream::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@FileStreamDataStream@Ogre@@8	; Ogre::FileStreamDataStream::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_EFileStreamDataStream@Ogre@@UAEPAXI@Z	; Ogre::FileStreamDataStream::`vector deleting destructor'
EXTRN	?read@FileStreamDataStream@Ogre@@UAEIPAXI@Z:PROC ; Ogre::FileStreamDataStream::read
EXTRN	?write@FileStreamDataStream@Ogre@@UAEIPBXI@Z:PROC ; Ogre::FileStreamDataStream::write
EXTRN	?readLine@FileStreamDataStream@Ogre@@UAEIPADIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z:PROC ; Ogre::FileStreamDataStream::readLine
EXTRN	?skip@FileStreamDataStream@Ogre@@UAEXJ@Z:PROC	; Ogre::FileStreamDataStream::skip
EXTRN	?seek@FileStreamDataStream@Ogre@@UAEXI@Z:PROC	; Ogre::FileStreamDataStream::seek
EXTRN	?tell@FileStreamDataStream@Ogre@@UBEIXZ:PROC	; Ogre::FileStreamDataStream::tell
EXTRN	?eof@FileStreamDataStream@Ogre@@UBE_NXZ:PROC	; Ogre::FileStreamDataStream::eof
EXTRN	?close@FileStreamDataStream@Ogre@@UAEXXZ:PROC	; Ogre::FileStreamDataStream::close
EXTRN	?getMemoryImage@FileStreamDataStream@Ogre@@UAEPAXXZ:PROC ; Ogre::FileStreamDataStream::getMemoryImage
;	COMDAT ??_R1A@?0A@EA@FileStreamDataStream@Ogre@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@FileStreamDataStream@Ogre@@8 DD FLAT:??_R0?AVFileStreamDataStream@Ogre@@@8 ; Ogre::FileStreamDataStream::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3FileStreamDataStream@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R2FileStreamDataStream@Ogre@@8
rdata$r	SEGMENT
??_R2FileStreamDataStream@Ogre@@8 DD FLAT:??_R1A@?0A@EA@FileStreamDataStream@Ogre@@8 ; Ogre::FileStreamDataStream::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@DataStream@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R3FileStreamDataStream@Ogre@@8
rdata$r	SEGMENT
??_R3FileStreamDataStream@Ogre@@8 DD 00H		; Ogre::FileStreamDataStream::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2FileStreamDataStream@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVFileStreamDataStream@Ogre@@@8
_DATA	SEGMENT
??_R0?AVFileStreamDataStream@Ogre@@@8 DD FLAT:??_7type_info@@6B@ ; Ogre::FileStreamDataStream `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVFileStreamDataStream@Ogre@@', 00H
_DATA	ENDS
;	COMDAT ??_R4FileStreamDataStream@Ogre@@6B@
rdata$r	SEGMENT
??_R4FileStreamDataStream@Ogre@@6B@ DD 00H		; Ogre::FileStreamDataStream::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVFileStreamDataStream@Ogre@@@8
	DD	FLAT:??_R3FileStreamDataStream@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_7FileStreamDataStream@Ogre@@6B@
CONST	SEGMENT
??_7FileStreamDataStream@Ogre@@6B@ DD FLAT:??_R4FileStreamDataStream@Ogre@@6B@ ; Ogre::FileStreamDataStream::`vftable'
	DD	FLAT:??_EFileStreamDataStream@Ogre@@UAEPAXI@Z
	DD	FLAT:?read@FileStreamDataStream@Ogre@@UAEIPAXI@Z
	DD	FLAT:?write@FileStreamDataStream@Ogre@@UAEIPBXI@Z
	DD	FLAT:?readLine@FileStreamDataStream@Ogre@@UAEIPADIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	FLAT:?getLine@DataStream@Ogre@@UAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z
	DD	FLAT:?getAsString@DataStream@Ogre@@UAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
	DD	FLAT:?skipLine@DataStream@Ogre@@UAEIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	FLAT:?skip@FileStreamDataStream@Ogre@@UAEXJ@Z
	DD	FLAT:?seek@FileStreamDataStream@Ogre@@UAEXI@Z
	DD	FLAT:?tell@FileStreamDataStream@Ogre@@UBEIXZ
	DD	FLAT:?eof@FileStreamDataStream@Ogre@@UBE_NXZ
	DD	FLAT:?size@DataStream@Ogre@@UBEIXZ
	DD	FLAT:?close@FileStreamDataStream@Ogre@@UAEXXZ
	DD	FLAT:?getMemoryImage@FileStreamDataStream@Ogre@@UAEPAXXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0FileStreamDataStream@Ogre@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0FileStreamDataStream@Ogre@@QAE@ABV01@@Z$0
__ehfuncinfo$??0FileStreamDataStream@Ogre@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0FileStreamDataStream@Ogre@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0FileStreamDataStream@Ogre@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0FileStreamDataStream@Ogre@@QAE@ABV01@@Z PROC		; Ogre::FileStreamDataStream::FileStreamDataStream, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0FileStreamDataStream@Ogre@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0DataStream@Ogre@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7FileStreamDataStream@Ogre@@6B@
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR [edx+36], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	cl, BYTE PTR [eax+40]
	mov	BYTE PTR [edx+40], cl
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0FileStreamDataStream@Ogre@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1DataStream@Ogre@@UAE@XZ		; Ogre::DataStream::~DataStream
__ehhandler$??0FileStreamDataStream@Ogre@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0FileStreamDataStream@Ogre@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0FileStreamDataStream@Ogre@@QAE@ABV01@@Z ENDP		; Ogre::FileStreamDataStream::FileStreamDataStream
PUBLIC	??4FileStreamDataStream@Ogre@@QAEAAV01@ABV01@@Z	; Ogre::FileStreamDataStream::operator=
; Function compile flags: /Odtp
;	COMDAT ??4FileStreamDataStream@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4FileStreamDataStream@Ogre@@QAEAAV01@ABV01@@Z PROC	; Ogre::FileStreamDataStream::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4DataStream@Ogre@@QAEAAV01@ABV01@@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	DWORD PTR [ecx+36], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	al, BYTE PTR [edx+40]
	mov	BYTE PTR [ecx+40], al
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4FileStreamDataStream@Ogre@@QAEAAV01@ABV01@@Z ENDP	; Ogre::FileStreamDataStream::operator=
_TEXT	ENDS
PUBLIC	??_GFileStreamDataStream@Ogre@@UAEPAXI@Z	; Ogre::FileStreamDataStream::`scalar deleting destructor'
EXTRN	??1FileStreamDataStream@Ogre@@UAE@XZ:PROC	; Ogre::FileStreamDataStream::~FileStreamDataStream
; Function compile flags: /Odtp
;	COMDAT ??_GFileStreamDataStream@Ogre@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GFileStreamDataStream@Ogre@@UAEPAXI@Z PROC		; Ogre::FileStreamDataStream::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1FileStreamDataStream@Ogre@@UAE@XZ	; Ogre::FileStreamDataStream::~FileStreamDataStream
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@4
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@4:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GFileStreamDataStream@Ogre@@UAEPAXI@Z ENDP		; Ogre::FileStreamDataStream::`scalar deleting destructor'
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_EFileStreamDataStream@Ogre@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_EFileStreamDataStream@Ogre@@UAEPAXI@Z PROC		; Ogre::FileStreamDataStream::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 2
	je	SHORT $LN3@vector@4
	push	OFFSET ??1FileStreamDataStream@Ogre@@UAE@XZ ; Ogre::FileStreamDataStream::~FileStreamDataStream
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx-4]
	push	edx
	push	44					; 0000002cH
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??_M@YGXPAXIHP6EX0@Z@Z
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN2@vector@4
	mov	edx, DWORD PTR _this$[ebp]
	sub	edx, 4
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN2@vector@4:
	mov	eax, DWORD PTR _this$[ebp]
	sub	eax, 4
	jmp	SHORT $LN4@vector@4
$LN3@vector@4:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1FileStreamDataStream@Ogre@@UAE@XZ	; Ogre::FileStreamDataStream::~FileStreamDataStream
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@vector@4
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@vector@4:
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector@4:
	mov	esp, ebp
	pop	ebp
	ret	4
??_EFileStreamDataStream@Ogre@@UAEPAXI@Z ENDP		; Ogre::FileStreamDataStream::`vector deleting destructor'
_TEXT	ENDS
PUBLIC	??_7FileHandleDataStream@Ogre@@6B@		; Ogre::FileHandleDataStream::`vftable'
PUBLIC	??0FileHandleDataStream@Ogre@@QAE@ABV01@@Z	; Ogre::FileHandleDataStream::FileHandleDataStream
PUBLIC	??_R4FileHandleDataStream@Ogre@@6B@		; Ogre::FileHandleDataStream::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVFileHandleDataStream@Ogre@@@8		; Ogre::FileHandleDataStream `RTTI Type Descriptor'
PUBLIC	??_R3FileHandleDataStream@Ogre@@8		; Ogre::FileHandleDataStream::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2FileHandleDataStream@Ogre@@8		; Ogre::FileHandleDataStream::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@FileHandleDataStream@Ogre@@8	; Ogre::FileHandleDataStream::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_EFileHandleDataStream@Ogre@@UAEPAXI@Z	; Ogre::FileHandleDataStream::`vector deleting destructor'
EXTRN	?read@FileHandleDataStream@Ogre@@UAEIPAXI@Z:PROC ; Ogre::FileHandleDataStream::read
EXTRN	?write@FileHandleDataStream@Ogre@@UAEIPBXI@Z:PROC ; Ogre::FileHandleDataStream::write
EXTRN	?skip@FileHandleDataStream@Ogre@@UAEXJ@Z:PROC	; Ogre::FileHandleDataStream::skip
EXTRN	?seek@FileHandleDataStream@Ogre@@UAEXI@Z:PROC	; Ogre::FileHandleDataStream::seek
EXTRN	?tell@FileHandleDataStream@Ogre@@UBEIXZ:PROC	; Ogre::FileHandleDataStream::tell
EXTRN	?eof@FileHandleDataStream@Ogre@@UBE_NXZ:PROC	; Ogre::FileHandleDataStream::eof
EXTRN	?close@FileHandleDataStream@Ogre@@UAEXXZ:PROC	; Ogre::FileHandleDataStream::close
EXTRN	?getMemoryImage@FileHandleDataStream@Ogre@@UAEPAXXZ:PROC ; Ogre::FileHandleDataStream::getMemoryImage
;	COMDAT ??_R1A@?0A@EA@FileHandleDataStream@Ogre@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@FileHandleDataStream@Ogre@@8 DD FLAT:??_R0?AVFileHandleDataStream@Ogre@@@8 ; Ogre::FileHandleDataStream::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3FileHandleDataStream@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R2FileHandleDataStream@Ogre@@8
rdata$r	SEGMENT
??_R2FileHandleDataStream@Ogre@@8 DD FLAT:??_R1A@?0A@EA@FileHandleDataStream@Ogre@@8 ; Ogre::FileHandleDataStream::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@DataStream@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R3FileHandleDataStream@Ogre@@8
rdata$r	SEGMENT
??_R3FileHandleDataStream@Ogre@@8 DD 00H		; Ogre::FileHandleDataStream::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2FileHandleDataStream@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVFileHandleDataStream@Ogre@@@8
_DATA	SEGMENT
??_R0?AVFileHandleDataStream@Ogre@@@8 DD FLAT:??_7type_info@@6B@ ; Ogre::FileHandleDataStream `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVFileHandleDataStream@Ogre@@', 00H
_DATA	ENDS
;	COMDAT ??_R4FileHandleDataStream@Ogre@@6B@
rdata$r	SEGMENT
??_R4FileHandleDataStream@Ogre@@6B@ DD 00H		; Ogre::FileHandleDataStream::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVFileHandleDataStream@Ogre@@@8
	DD	FLAT:??_R3FileHandleDataStream@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_7FileHandleDataStream@Ogre@@6B@
CONST	SEGMENT
??_7FileHandleDataStream@Ogre@@6B@ DD FLAT:??_R4FileHandleDataStream@Ogre@@6B@ ; Ogre::FileHandleDataStream::`vftable'
	DD	FLAT:??_EFileHandleDataStream@Ogre@@UAEPAXI@Z
	DD	FLAT:?read@FileHandleDataStream@Ogre@@UAEIPAXI@Z
	DD	FLAT:?write@FileHandleDataStream@Ogre@@UAEIPBXI@Z
	DD	FLAT:?readLine@DataStream@Ogre@@UAEIPADIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	FLAT:?getLine@DataStream@Ogre@@UAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z
	DD	FLAT:?getAsString@DataStream@Ogre@@UAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
	DD	FLAT:?skipLine@DataStream@Ogre@@UAEIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	FLAT:?skip@FileHandleDataStream@Ogre@@UAEXJ@Z
	DD	FLAT:?seek@FileHandleDataStream@Ogre@@UAEXI@Z
	DD	FLAT:?tell@FileHandleDataStream@Ogre@@UBEIXZ
	DD	FLAT:?eof@FileHandleDataStream@Ogre@@UBE_NXZ
	DD	FLAT:?size@DataStream@Ogre@@UBEIXZ
	DD	FLAT:?close@FileHandleDataStream@Ogre@@UAEXXZ
	DD	FLAT:?getMemoryImage@FileHandleDataStream@Ogre@@UAEPAXXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0FileHandleDataStream@Ogre@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0FileHandleDataStream@Ogre@@QAE@ABV01@@Z$0
__ehfuncinfo$??0FileHandleDataStream@Ogre@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0FileHandleDataStream@Ogre@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0FileHandleDataStream@Ogre@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0FileHandleDataStream@Ogre@@QAE@ABV01@@Z PROC		; Ogre::FileHandleDataStream::FileHandleDataStream, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0FileHandleDataStream@Ogre@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0DataStream@Ogre@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7FileHandleDataStream@Ogre@@6B@
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR [edx+36], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	DWORD PTR [edx+40], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0FileHandleDataStream@Ogre@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1DataStream@Ogre@@UAE@XZ		; Ogre::DataStream::~DataStream
__ehhandler$??0FileHandleDataStream@Ogre@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0FileHandleDataStream@Ogre@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0FileHandleDataStream@Ogre@@QAE@ABV01@@Z ENDP		; Ogre::FileHandleDataStream::FileHandleDataStream
PUBLIC	??4FileHandleDataStream@Ogre@@QAEAAV01@ABV01@@Z	; Ogre::FileHandleDataStream::operator=
; Function compile flags: /Odtp
;	COMDAT ??4FileHandleDataStream@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4FileHandleDataStream@Ogre@@QAEAAV01@ABV01@@Z PROC	; Ogre::FileHandleDataStream::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4DataStream@Ogre@@QAEAAV01@ABV01@@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	DWORD PTR [ecx+36], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	DWORD PTR [ecx+40], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4FileHandleDataStream@Ogre@@QAEAAV01@ABV01@@Z ENDP	; Ogre::FileHandleDataStream::operator=
_TEXT	ENDS
PUBLIC	??_GFileHandleDataStream@Ogre@@UAEPAXI@Z	; Ogre::FileHandleDataStream::`scalar deleting destructor'
EXTRN	??1FileHandleDataStream@Ogre@@UAE@XZ:PROC	; Ogre::FileHandleDataStream::~FileHandleDataStream
; Function compile flags: /Odtp
;	COMDAT ??_GFileHandleDataStream@Ogre@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GFileHandleDataStream@Ogre@@UAEPAXI@Z PROC		; Ogre::FileHandleDataStream::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1FileHandleDataStream@Ogre@@UAE@XZ	; Ogre::FileHandleDataStream::~FileHandleDataStream
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@5
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@5:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GFileHandleDataStream@Ogre@@UAEPAXI@Z ENDP		; Ogre::FileHandleDataStream::`scalar deleting destructor'
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_EFileHandleDataStream@Ogre@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_EFileHandleDataStream@Ogre@@UAEPAXI@Z PROC		; Ogre::FileHandleDataStream::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 2
	je	SHORT $LN3@vector@5
	push	OFFSET ??1FileHandleDataStream@Ogre@@UAE@XZ ; Ogre::FileHandleDataStream::~FileHandleDataStream
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx-4]
	push	edx
	push	44					; 0000002cH
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??_M@YGXPAXIHP6EX0@Z@Z
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN2@vector@5
	mov	edx, DWORD PTR _this$[ebp]
	sub	edx, 4
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN2@vector@5:
	mov	eax, DWORD PTR _this$[ebp]
	sub	eax, 4
	jmp	SHORT $LN4@vector@5
$LN3@vector@5:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1FileHandleDataStream@Ogre@@UAE@XZ	; Ogre::FileHandleDataStream::~FileHandleDataStream
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@vector@5
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@vector@5:
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector@5:
	mov	esp, ebp
	pop	ebp
	ret	4
??_EFileHandleDataStream@Ogre@@UAEPAXI@Z ENDP		; Ogre::FileHandleDataStream::`vector deleting destructor'
_TEXT	ENDS
PUBLIC	??_7DataStreamObject@Ogre@@6B@			; Ogre::DataStreamObject::`vftable'
PUBLIC	??1DataStreamObject@Ogre@@MAE@XZ		; Ogre::DataStreamObject::~DataStreamObject
PUBLIC	??_R4DataStreamObject@Ogre@@6B@			; Ogre::DataStreamObject::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVDataStreamObject@Ogre@@@8		; Ogre::DataStreamObject `RTTI Type Descriptor'
PUBLIC	??_R3DataStreamObject@Ogre@@8			; Ogre::DataStreamObject::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2DataStreamObject@Ogre@@8			; Ogre::DataStreamObject::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@DataStreamObject@Ogre@@8		; Ogre::DataStreamObject::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_EDataStreamObject@Ogre@@MAEPAXI@Z		; Ogre::DataStreamObject::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@DataStreamObject@Ogre@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@DataStreamObject@Ogre@@8 DD FLAT:??_R0?AVDataStreamObject@Ogre@@@8 ; Ogre::DataStreamObject::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3DataStreamObject@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R2DataStreamObject@Ogre@@8
rdata$r	SEGMENT
??_R2DataStreamObject@Ogre@@8 DD FLAT:??_R1A@?0A@EA@DataStreamObject@Ogre@@8 ; Ogre::DataStreamObject::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3DataStreamObject@Ogre@@8
rdata$r	SEGMENT
??_R3DataStreamObject@Ogre@@8 DD 00H			; Ogre::DataStreamObject::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2DataStreamObject@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVDataStreamObject@Ogre@@@8
_DATA	SEGMENT
??_R0?AVDataStreamObject@Ogre@@@8 DD FLAT:??_7type_info@@6B@ ; Ogre::DataStreamObject `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVDataStreamObject@Ogre@@', 00H
_DATA	ENDS
;	COMDAT ??_R4DataStreamObject@Ogre@@6B@
rdata$r	SEGMENT
??_R4DataStreamObject@Ogre@@6B@ DD 00H			; Ogre::DataStreamObject::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVDataStreamObject@Ogre@@@8
	DD	FLAT:??_R3DataStreamObject@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_7DataStreamObject@Ogre@@6B@
CONST	SEGMENT
??_7DataStreamObject@Ogre@@6B@ DD FLAT:??_R4DataStreamObject@Ogre@@6B@ ; Ogre::DataStreamObject::`vftable'
	DD	FLAT:??_EDataStreamObject@Ogre@@MAEPAXI@Z
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ??1DataStreamObject@Ogre@@MAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1DataStreamObject@Ogre@@MAE@XZ PROC			; Ogre::DataStreamObject::~DataStreamObject, COMDAT
; _this$ = ecx

; 445  : 		virtual ~DataStreamObject(){}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7DataStreamObject@Ogre@@6B@
	mov	esp, ebp
	pop	ebp
	ret	0
??1DataStreamObject@Ogre@@MAE@XZ ENDP			; Ogre::DataStreamObject::~DataStreamObject
_TEXT	ENDS
PUBLIC	??0DataStreamObject@Ogre@@QAE@XZ		; Ogre::DataStreamObject::DataStreamObject
; Function compile flags: /Odtp
;	COMDAT ??0DataStreamObject@Ogre@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0DataStreamObject@Ogre@@QAE@XZ PROC			; Ogre::DataStreamObject::DataStreamObject, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7DataStreamObject@Ogre@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0DataStreamObject@Ogre@@QAE@XZ ENDP			; Ogre::DataStreamObject::DataStreamObject
_TEXT	ENDS
PUBLIC	??0DataStreamObject@Ogre@@QAE@ABV01@@Z		; Ogre::DataStreamObject::DataStreamObject
; Function compile flags: /Odtp
;	COMDAT ??0DataStreamObject@Ogre@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0DataStreamObject@Ogre@@QAE@ABV01@@Z PROC		; Ogre::DataStreamObject::DataStreamObject, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7DataStreamObject@Ogre@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0DataStreamObject@Ogre@@QAE@ABV01@@Z ENDP		; Ogre::DataStreamObject::DataStreamObject
_TEXT	ENDS
PUBLIC	??4DataStreamObject@Ogre@@QAEAAV01@ABV01@@Z	; Ogre::DataStreamObject::operator=
; Function compile flags: /Odtp
;	COMDAT ??4DataStreamObject@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4DataStreamObject@Ogre@@QAEAAV01@ABV01@@Z PROC	; Ogre::DataStreamObject::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4DataStreamObject@Ogre@@QAEAAV01@ABV01@@Z ENDP	; Ogre::DataStreamObject::operator=
_TEXT	ENDS
PUBLIC	??_GDataStreamObject@Ogre@@MAEPAXI@Z		; Ogre::DataStreamObject::`scalar deleting destructor'
; Function compile flags: /Odtp
;	COMDAT ??_GDataStreamObject@Ogre@@MAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GDataStreamObject@Ogre@@MAEPAXI@Z PROC		; Ogre::DataStreamObject::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1DataStreamObject@Ogre@@MAE@XZ	; Ogre::DataStreamObject::~DataStreamObject
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@6
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@6:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GDataStreamObject@Ogre@@MAEPAXI@Z ENDP		; Ogre::DataStreamObject::`scalar deleting destructor'
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_EDataStreamObject@Ogre@@MAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_EDataStreamObject@Ogre@@MAEPAXI@Z PROC		; Ogre::DataStreamObject::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 2
	je	SHORT $LN3@vector@6
	push	OFFSET ??1DataStreamObject@Ogre@@MAE@XZ	; Ogre::DataStreamObject::~DataStreamObject
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx-4]
	push	edx
	push	4
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??_M@YGXPAXIHP6EX0@Z@Z
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN2@vector@6
	mov	edx, DWORD PTR _this$[ebp]
	sub	edx, 4
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN2@vector@6:
	mov	eax, DWORD PTR _this$[ebp]
	sub	eax, 4
	jmp	SHORT $LN4@vector@6
$LN3@vector@6:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1DataStreamObject@Ogre@@MAE@XZ	; Ogre::DataStreamObject::~DataStreamObject
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@vector@6
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@vector@6:
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector@6:
	mov	esp, ebp
	pop	ebp
	ret	4
??_EDataStreamObject@Ogre@@MAEPAXI@Z ENDP		; Ogre::DataStreamObject::`vector deleting destructor'
_TEXT	ENDS
PUBLIC	??_7ObjectDataStream@Ogre@@6B@			; Ogre::ObjectDataStream::`vftable'
PUBLIC	??0ObjectDataStream@Ogre@@QAE@ABV01@@Z		; Ogre::ObjectDataStream::ObjectDataStream
PUBLIC	??_R4ObjectDataStream@Ogre@@6B@			; Ogre::ObjectDataStream::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVObjectDataStream@Ogre@@@8		; Ogre::ObjectDataStream `RTTI Type Descriptor'
PUBLIC	??_R3ObjectDataStream@Ogre@@8			; Ogre::ObjectDataStream::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2ObjectDataStream@Ogre@@8			; Ogre::ObjectDataStream::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@ObjectDataStream@Ogre@@8		; Ogre::ObjectDataStream::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_EObjectDataStream@Ogre@@UAEPAXI@Z		; Ogre::ObjectDataStream::`vector deleting destructor'
EXTRN	?read@ObjectDataStream@Ogre@@UAEIPAXI@Z:PROC	; Ogre::ObjectDataStream::read
EXTRN	?write@ObjectDataStream@Ogre@@UAEIPBXI@Z:PROC	; Ogre::ObjectDataStream::write
EXTRN	?skip@ObjectDataStream@Ogre@@UAEXJ@Z:PROC	; Ogre::ObjectDataStream::skip
EXTRN	?seek@ObjectDataStream@Ogre@@UAEXI@Z:PROC	; Ogre::ObjectDataStream::seek
EXTRN	?tell@ObjectDataStream@Ogre@@UBEIXZ:PROC	; Ogre::ObjectDataStream::tell
EXTRN	?eof@ObjectDataStream@Ogre@@UBE_NXZ:PROC	; Ogre::ObjectDataStream::eof
EXTRN	?size@ObjectDataStream@Ogre@@UBEIXZ:PROC	; Ogre::ObjectDataStream::size
EXTRN	?close@ObjectDataStream@Ogre@@UAEXXZ:PROC	; Ogre::ObjectDataStream::close
EXTRN	?getMemoryImage@ObjectDataStream@Ogre@@UAEPAXXZ:PROC ; Ogre::ObjectDataStream::getMemoryImage
;	COMDAT ??_R1A@?0A@EA@ObjectDataStream@Ogre@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@ObjectDataStream@Ogre@@8 DD FLAT:??_R0?AVObjectDataStream@Ogre@@@8 ; Ogre::ObjectDataStream::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3ObjectDataStream@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R2ObjectDataStream@Ogre@@8
rdata$r	SEGMENT
??_R2ObjectDataStream@Ogre@@8 DD FLAT:??_R1A@?0A@EA@ObjectDataStream@Ogre@@8 ; Ogre::ObjectDataStream::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@DataStream@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R3ObjectDataStream@Ogre@@8
rdata$r	SEGMENT
??_R3ObjectDataStream@Ogre@@8 DD 00H			; Ogre::ObjectDataStream::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2ObjectDataStream@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVObjectDataStream@Ogre@@@8
_DATA	SEGMENT
??_R0?AVObjectDataStream@Ogre@@@8 DD FLAT:??_7type_info@@6B@ ; Ogre::ObjectDataStream `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVObjectDataStream@Ogre@@', 00H
_DATA	ENDS
;	COMDAT ??_R4ObjectDataStream@Ogre@@6B@
rdata$r	SEGMENT
??_R4ObjectDataStream@Ogre@@6B@ DD 00H			; Ogre::ObjectDataStream::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVObjectDataStream@Ogre@@@8
	DD	FLAT:??_R3ObjectDataStream@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_7ObjectDataStream@Ogre@@6B@
CONST	SEGMENT
??_7ObjectDataStream@Ogre@@6B@ DD FLAT:??_R4ObjectDataStream@Ogre@@6B@ ; Ogre::ObjectDataStream::`vftable'
	DD	FLAT:??_EObjectDataStream@Ogre@@UAEPAXI@Z
	DD	FLAT:?read@ObjectDataStream@Ogre@@UAEIPAXI@Z
	DD	FLAT:?write@ObjectDataStream@Ogre@@UAEIPBXI@Z
	DD	FLAT:?readLine@DataStream@Ogre@@UAEIPADIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	FLAT:?getLine@DataStream@Ogre@@UAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z
	DD	FLAT:?getAsString@DataStream@Ogre@@UAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
	DD	FLAT:?skipLine@DataStream@Ogre@@UAEIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	FLAT:?skip@ObjectDataStream@Ogre@@UAEXJ@Z
	DD	FLAT:?seek@ObjectDataStream@Ogre@@UAEXI@Z
	DD	FLAT:?tell@ObjectDataStream@Ogre@@UBEIXZ
	DD	FLAT:?eof@ObjectDataStream@Ogre@@UBE_NXZ
	DD	FLAT:?size@ObjectDataStream@Ogre@@UBEIXZ
	DD	FLAT:?close@ObjectDataStream@Ogre@@UAEXXZ
	DD	FLAT:?getMemoryImage@ObjectDataStream@Ogre@@UAEPAXXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0ObjectDataStream@Ogre@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0ObjectDataStream@Ogre@@QAE@ABV01@@Z$0
__ehfuncinfo$??0ObjectDataStream@Ogre@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0ObjectDataStream@Ogre@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0ObjectDataStream@Ogre@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0ObjectDataStream@Ogre@@QAE@ABV01@@Z PROC		; Ogre::ObjectDataStream::ObjectDataStream, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0ObjectDataStream@Ogre@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0DataStream@Ogre@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7ObjectDataStream@Ogre@@6B@
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR [edx+36], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	DWORD PTR [edx+40], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0ObjectDataStream@Ogre@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1DataStream@Ogre@@UAE@XZ		; Ogre::DataStream::~DataStream
__ehhandler$??0ObjectDataStream@Ogre@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0ObjectDataStream@Ogre@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0ObjectDataStream@Ogre@@QAE@ABV01@@Z ENDP		; Ogre::ObjectDataStream::ObjectDataStream
PUBLIC	??4ObjectDataStream@Ogre@@QAEAAV01@ABV01@@Z	; Ogre::ObjectDataStream::operator=
; Function compile flags: /Odtp
;	COMDAT ??4ObjectDataStream@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4ObjectDataStream@Ogre@@QAEAAV01@ABV01@@Z PROC	; Ogre::ObjectDataStream::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4DataStream@Ogre@@QAEAAV01@ABV01@@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+36]
	mov	DWORD PTR [ecx+36], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	DWORD PTR [ecx+40], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4ObjectDataStream@Ogre@@QAEAAV01@ABV01@@Z ENDP	; Ogre::ObjectDataStream::operator=
_TEXT	ENDS
PUBLIC	??_GObjectDataStream@Ogre@@UAEPAXI@Z		; Ogre::ObjectDataStream::`scalar deleting destructor'
EXTRN	??1ObjectDataStream@Ogre@@UAE@XZ:PROC		; Ogre::ObjectDataStream::~ObjectDataStream
; Function compile flags: /Odtp
;	COMDAT ??_GObjectDataStream@Ogre@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GObjectDataStream@Ogre@@UAEPAXI@Z PROC		; Ogre::ObjectDataStream::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1ObjectDataStream@Ogre@@UAE@XZ	; Ogre::ObjectDataStream::~ObjectDataStream
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@7
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@7:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GObjectDataStream@Ogre@@UAEPAXI@Z ENDP		; Ogre::ObjectDataStream::`scalar deleting destructor'
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_EObjectDataStream@Ogre@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_EObjectDataStream@Ogre@@UAEPAXI@Z PROC		; Ogre::ObjectDataStream::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 2
	je	SHORT $LN3@vector@7
	push	OFFSET ??1ObjectDataStream@Ogre@@UAE@XZ	; Ogre::ObjectDataStream::~ObjectDataStream
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx-4]
	push	edx
	push	44					; 0000002cH
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??_M@YGXPAXIHP6EX0@Z@Z
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN2@vector@7
	mov	edx, DWORD PTR _this$[ebp]
	sub	edx, 4
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN2@vector@7:
	mov	eax, DWORD PTR _this$[ebp]
	sub	eax, 4
	jmp	SHORT $LN4@vector@7
$LN3@vector@7:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1ObjectDataStream@Ogre@@UAE@XZ	; Ogre::ObjectDataStream::~ObjectDataStream
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@vector@7
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@vector@7:
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector@7:
	mov	esp, ebp
	pop	ebp
	ret	4
??_EObjectDataStream@Ogre@@UAEPAXI@Z ENDP		; Ogre::ObjectDataStream::`vector deleting destructor'
_TEXT	ENDS
PUBLIC	??_7Archive@Ogre@@6B@				; Ogre::Archive::`vftable'
PUBLIC	??0Archive@Ogre@@QAE@PAVDataStream@1@H@Z	; Ogre::Archive::Archive
PUBLIC	??_R4Archive@Ogre@@6B@				; Ogre::Archive::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVArchive@Ogre@@@8			; Ogre::Archive `RTTI Type Descriptor'
PUBLIC	??_R3Archive@Ogre@@8				; Ogre::Archive::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2Archive@Ogre@@8				; Ogre::Archive::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@Archive@Ogre@@8			; Ogre::Archive::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_EArchive@Ogre@@UAEPAXI@Z			; Ogre::Archive::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@Archive@Ogre@@8
; File i:\svnroot\client\ogremain\ogrearchive.h
rdata$r	SEGMENT
??_R1A@?0A@EA@Archive@Ogre@@8 DD FLAT:??_R0?AVArchive@Ogre@@@8 ; Ogre::Archive::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3Archive@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R2Archive@Ogre@@8
rdata$r	SEGMENT
??_R2Archive@Ogre@@8 DD FLAT:??_R1A@?0A@EA@Archive@Ogre@@8 ; Ogre::Archive::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3Archive@Ogre@@8
rdata$r	SEGMENT
??_R3Archive@Ogre@@8 DD 00H				; Ogre::Archive::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2Archive@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVArchive@Ogre@@@8
_DATA	SEGMENT
??_R0?AVArchive@Ogre@@@8 DD FLAT:??_7type_info@@6B@	; Ogre::Archive `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVArchive@Ogre@@', 00H
_DATA	ENDS
;	COMDAT ??_R4Archive@Ogre@@6B@
rdata$r	SEGMENT
??_R4Archive@Ogre@@6B@ DD 00H				; Ogre::Archive::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVArchive@Ogre@@@8
	DD	FLAT:??_R3Archive@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_7Archive@Ogre@@6B@
CONST	SEGMENT
??_7Archive@Ogre@@6B@ DD FLAT:??_R4Archive@Ogre@@6B@	; Ogre::Archive::`vftable'
	DD	FLAT:??_EArchive@Ogre@@UAEPAXI@Z
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ??0Archive@Ogre@@QAE@PAVDataStream@1@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pstream$ = 8						; size = 4
_mode$ = 12						; size = 4
??0Archive@Ogre@@QAE@PAVDataStream@1@H@Z PROC		; Ogre::Archive::Archive, COMDAT
; _this$ = ecx

; 22   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7Archive@Ogre@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _pstream$[ebp]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _mode$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 23   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0Archive@Ogre@@QAE@PAVDataStream@1@H@Z ENDP		; Ogre::Archive::Archive
_TEXT	ENDS
PUBLIC	??1Archive@Ogre@@UAE@XZ				; Ogre::Archive::~Archive
; Function compile flags: /Odtp
;	COMDAT ??1Archive@Ogre@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1Archive@Ogre@@UAE@XZ PROC				; Ogre::Archive::~Archive, COMDAT
; _this$ = ecx

; 26   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7Archive@Ogre@@6B@

; 27   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??1Archive@Ogre@@UAE@XZ ENDP				; Ogre::Archive::~Archive
_TEXT	ENDS
PUBLIC	?isLoading@Archive@Ogre@@QAE_NXZ		; Ogre::Archive::isLoading
; Function compile flags: /Odtp
;	COMDAT ?isLoading@Archive@Ogre@@QAE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?isLoading@Archive@Ogre@@QAE_NXZ PROC			; Ogre::Archive::isLoading, COMDAT
; _this$ = ecx

; 30   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 31   : 			return m_Mode==MODE_LOAD;

	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	cmp	DWORD PTR [eax+8], 1
	sete	cl
	mov	al, cl

; 32   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?isLoading@Archive@Ogre@@QAE_NXZ ENDP			; Ogre::Archive::isLoading
_TEXT	ENDS
PUBLIC	?serialize@Archive@Ogre@@QAEAAV12@PAXI@Z	; Ogre::Archive::serialize
PUBLIC	??6Archive@Ogre@@QAEAAV01@AAD@Z			; Ogre::Archive::operator<<
; Function compile flags: /Odtp
;	COMDAT ??6Archive@Ogre@@QAEAAV01@AAD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_value$ = 8						; size = 4
??6Archive@Ogre@@QAEAAV01@AAD@Z PROC			; Ogre::Archive::operator<<, COMDAT
; _this$ = ecx

; 108  : 		SERIALIZE_PRIMITIVE_FUNC(char)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	push	1
	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?serialize@Archive@Ogre@@QAEAAV12@PAXI@Z ; Ogre::Archive::serialize
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??6Archive@Ogre@@QAEAAV01@AAD@Z ENDP			; Ogre::Archive::operator<<
_TEXT	ENDS
PUBLIC	??6Archive@Ogre@@QAEAAV01@AAF@Z			; Ogre::Archive::operator<<
; Function compile flags: /Odtp
;	COMDAT ??6Archive@Ogre@@QAEAAV01@AAF@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_value$ = 8						; size = 4
??6Archive@Ogre@@QAEAAV01@AAF@Z PROC			; Ogre::Archive::operator<<, COMDAT
; _this$ = ecx

; 109  : 		SERIALIZE_PRIMITIVE_FUNC(short)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	push	2
	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?serialize@Archive@Ogre@@QAEAAV12@PAXI@Z ; Ogre::Archive::serialize
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??6Archive@Ogre@@QAEAAV01@AAF@Z ENDP			; Ogre::Archive::operator<<
_TEXT	ENDS
PUBLIC	??6Archive@Ogre@@QAEAAV01@AAH@Z			; Ogre::Archive::operator<<
; Function compile flags: /Odtp
;	COMDAT ??6Archive@Ogre@@QAEAAV01@AAH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_value$ = 8						; size = 4
??6Archive@Ogre@@QAEAAV01@AAH@Z PROC			; Ogre::Archive::operator<<, COMDAT
; _this$ = ecx

; 110  : 		SERIALIZE_PRIMITIVE_FUNC(int)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	push	4
	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?serialize@Archive@Ogre@@QAEAAV12@PAXI@Z ; Ogre::Archive::serialize
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??6Archive@Ogre@@QAEAAV01@AAH@Z ENDP			; Ogre::Archive::operator<<
_TEXT	ENDS
PUBLIC	??6Archive@Ogre@@QAEAAV01@AA_J@Z		; Ogre::Archive::operator<<
; Function compile flags: /Odtp
;	COMDAT ??6Archive@Ogre@@QAEAAV01@AA_J@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_value$ = 8						; size = 4
??6Archive@Ogre@@QAEAAV01@AA_J@Z PROC			; Ogre::Archive::operator<<, COMDAT
; _this$ = ecx

; 111  : 		SERIALIZE_PRIMITIVE_FUNC(int64)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	push	8
	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?serialize@Archive@Ogre@@QAEAAV12@PAXI@Z ; Ogre::Archive::serialize
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??6Archive@Ogre@@QAEAAV01@AA_J@Z ENDP			; Ogre::Archive::operator<<
_TEXT	ENDS
PUBLIC	??6Archive@Ogre@@QAEAAV01@AAE@Z			; Ogre::Archive::operator<<
; Function compile flags: /Odtp
;	COMDAT ??6Archive@Ogre@@QAEAAV01@AAE@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_value$ = 8						; size = 4
??6Archive@Ogre@@QAEAAV01@AAE@Z PROC			; Ogre::Archive::operator<<, COMDAT
; _this$ = ecx

; 112  : 		SERIALIZE_PRIMITIVE_FUNC(uchar)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	push	1
	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?serialize@Archive@Ogre@@QAEAAV12@PAXI@Z ; Ogre::Archive::serialize
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??6Archive@Ogre@@QAEAAV01@AAE@Z ENDP			; Ogre::Archive::operator<<
_TEXT	ENDS
PUBLIC	??6Archive@Ogre@@QAEAAV01@AAG@Z			; Ogre::Archive::operator<<
; Function compile flags: /Odtp
;	COMDAT ??6Archive@Ogre@@QAEAAV01@AAG@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_value$ = 8						; size = 4
??6Archive@Ogre@@QAEAAV01@AAG@Z PROC			; Ogre::Archive::operator<<, COMDAT
; _this$ = ecx

; 113  : 		SERIALIZE_PRIMITIVE_FUNC(ushort)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	push	2
	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?serialize@Archive@Ogre@@QAEAAV12@PAXI@Z ; Ogre::Archive::serialize
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??6Archive@Ogre@@QAEAAV01@AAG@Z ENDP			; Ogre::Archive::operator<<
_TEXT	ENDS
PUBLIC	??6Archive@Ogre@@QAEAAV01@AAI@Z			; Ogre::Archive::operator<<
; Function compile flags: /Odtp
;	COMDAT ??6Archive@Ogre@@QAEAAV01@AAI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_value$ = 8						; size = 4
??6Archive@Ogre@@QAEAAV01@AAI@Z PROC			; Ogre::Archive::operator<<, COMDAT
; _this$ = ecx

; 114  : 		SERIALIZE_PRIMITIVE_FUNC(uint)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	push	4
	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?serialize@Archive@Ogre@@QAEAAV12@PAXI@Z ; Ogre::Archive::serialize
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??6Archive@Ogre@@QAEAAV01@AAI@Z ENDP			; Ogre::Archive::operator<<
_TEXT	ENDS
PUBLIC	??6Archive@Ogre@@QAEAAV01@AA_K@Z		; Ogre::Archive::operator<<
; Function compile flags: /Odtp
;	COMDAT ??6Archive@Ogre@@QAEAAV01@AA_K@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_value$ = 8						; size = 4
??6Archive@Ogre@@QAEAAV01@AA_K@Z PROC			; Ogre::Archive::operator<<, COMDAT
; _this$ = ecx

; 115  : 		SERIALIZE_PRIMITIVE_FUNC(uint64)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	push	8
	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?serialize@Archive@Ogre@@QAEAAV12@PAXI@Z ; Ogre::Archive::serialize
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??6Archive@Ogre@@QAEAAV01@AA_K@Z ENDP			; Ogre::Archive::operator<<
_TEXT	ENDS
PUBLIC	??6Archive@Ogre@@QAEAAV01@AA_N@Z		; Ogre::Archive::operator<<
; Function compile flags: /Odtp
;	COMDAT ??6Archive@Ogre@@QAEAAV01@AA_N@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_value$ = 8						; size = 4
??6Archive@Ogre@@QAEAAV01@AA_N@Z PROC			; Ogre::Archive::operator<<, COMDAT
; _this$ = ecx

; 116  : 		SERIALIZE_PRIMITIVE_FUNC(bool)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	push	1
	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?serialize@Archive@Ogre@@QAEAAV12@PAXI@Z ; Ogre::Archive::serialize
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??6Archive@Ogre@@QAEAAV01@AA_N@Z ENDP			; Ogre::Archive::operator<<
_TEXT	ENDS
PUBLIC	??6Archive@Ogre@@QAEAAV01@AAM@Z			; Ogre::Archive::operator<<
; Function compile flags: /Odtp
;	COMDAT ??6Archive@Ogre@@QAEAAV01@AAM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_value$ = 8						; size = 4
??6Archive@Ogre@@QAEAAV01@AAM@Z PROC			; Ogre::Archive::operator<<, COMDAT
; _this$ = ecx

; 117  : 		SERIALIZE_PRIMITIVE_FUNC(float)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	push	4
	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?serialize@Archive@Ogre@@QAEAAV12@PAXI@Z ; Ogre::Archive::serialize
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??6Archive@Ogre@@QAEAAV01@AAM@Z ENDP			; Ogre::Archive::operator<<
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?serialize@Archive@Ogre@@QAEAAV12@PAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pbuf$ = 8						; size = 4
_len$ = 12						; size = 4
?serialize@Archive@Ogre@@QAEAAV12@PAXI@Z PROC		; Ogre::Archive::serialize, COMDAT
; _this$ = ecx

; 155  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 156  : 			if(isLoading()) m_pStream->read(pbuf, len);

	mov	ecx, DWORD PTR _this$[ebp]
	call	?isLoading@Archive@Ogre@@QAE_NXZ	; Ogre::Archive::isLoading
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN2@serialize
	mov	ecx, DWORD PTR _len$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pbuf$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, eax
	mov	eax, DWORD PTR [edx+4]
	call	eax
	jmp	SHORT $LN1@serialize
$LN2@serialize:

; 157  : 			else m_pStream->write(pbuf, len);

	mov	ecx, DWORD PTR _len$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pbuf$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, eax
	mov	eax, DWORD PTR [edx+8]
	call	eax
$LN1@serialize:

; 158  : 
; 159  : 			return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 160  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?serialize@Archive@Ogre@@QAEAAV12@PAXI@Z ENDP		; Ogre::Archive::serialize
_TEXT	ENDS
PUBLIC	?read@Archive@Ogre@@QAEXPAXI@Z			; Ogre::Archive::read
; Function compile flags: /Odtp
;	COMDAT ?read@Archive@Ogre@@QAEXPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pbuf$ = 8						; size = 4
_len$ = 12						; size = 4
?read@Archive@Ogre@@QAEXPAXI@Z PROC			; Ogre::Archive::read, COMDAT
; _this$ = ecx

; 163  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 164  : 			m_pStream->read(pbuf, len);

	mov	eax, DWORD PTR _len$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pbuf$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [edx+4]
	call	eax

; 165  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?read@Archive@Ogre@@QAEXPAXI@Z ENDP			; Ogre::Archive::read
_TEXT	ENDS
PUBLIC	?write@Archive@Ogre@@QAEXPBXI@Z			; Ogre::Archive::write
; Function compile flags: /Odtp
;	COMDAT ?write@Archive@Ogre@@QAEXPBXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pbuf$ = 8						; size = 4
_len$ = 12						; size = 4
?write@Archive@Ogre@@QAEXPBXI@Z PROC			; Ogre::Archive::write, COMDAT
; _this$ = ecx

; 168  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 169  : 			m_pStream->write(pbuf, len);

	mov	eax, DWORD PTR _len$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pbuf$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [edx+8]
	call	eax

; 170  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?write@Archive@Ogre@@QAEXPBXI@Z ENDP			; Ogre::Archive::write
_TEXT	ENDS
PUBLIC	??0Archive@Ogre@@QAE@ABV01@@Z			; Ogre::Archive::Archive
; Function compile flags: /Odtp
;	COMDAT ??0Archive@Ogre@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0Archive@Ogre@@QAE@ABV01@@Z PROC			; Ogre::Archive::Archive, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7Archive@Ogre@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0Archive@Ogre@@QAE@ABV01@@Z ENDP			; Ogre::Archive::Archive
_TEXT	ENDS
PUBLIC	??4Archive@Ogre@@QAEAAV01@ABV01@@Z		; Ogre::Archive::operator=
; Function compile flags: /Odtp
;	COMDAT ??4Archive@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4Archive@Ogre@@QAEAAV01@ABV01@@Z PROC			; Ogre::Archive::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4Archive@Ogre@@QAEAAV01@ABV01@@Z ENDP			; Ogre::Archive::operator=
_TEXT	ENDS
PUBLIC	??_GArchive@Ogre@@UAEPAXI@Z			; Ogre::Archive::`scalar deleting destructor'
; Function compile flags: /Odtp
;	COMDAT ??_GArchive@Ogre@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GArchive@Ogre@@UAEPAXI@Z PROC			; Ogre::Archive::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1Archive@Ogre@@UAE@XZ			; Ogre::Archive::~Archive
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@8
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@8:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GArchive@Ogre@@UAEPAXI@Z ENDP			; Ogre::Archive::`scalar deleting destructor'
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_EArchive@Ogre@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_EArchive@Ogre@@UAEPAXI@Z PROC			; Ogre::Archive::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 2
	je	SHORT $LN3@vector@8
	push	OFFSET ??1Archive@Ogre@@UAE@XZ		; Ogre::Archive::~Archive
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx-4]
	push	edx
	push	12					; 0000000cH
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??_M@YGXPAXIHP6EX0@Z@Z
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN2@vector@8
	mov	edx, DWORD PTR _this$[ebp]
	sub	edx, 4
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN2@vector@8:
	mov	eax, DWORD PTR _this$[ebp]
	sub	eax, 4
	jmp	SHORT $LN4@vector@8
$LN3@vector@8:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1Archive@Ogre@@UAE@XZ			; Ogre::Archive::~Archive
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@vector@8
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@vector@8:
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector@8:
	mov	esp, ebp
	pop	ebp
	ret	4
??_EArchive@Ogre@@UAEPAXI@Z ENDP			; Ogre::Archive::`vector deleting destructor'
_TEXT	ENDS
PUBLIC	??0Vector3@Ogre@@QAE@XZ				; Ogre::Vector3::Vector3
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogrevector3.h
;	COMDAT ??0Vector3@Ogre@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0Vector3@Ogre@@QAE@XZ PROC				; Ogre::Vector3::Vector3, COMDAT
; _this$ = ecx

; 49   : 		Vector3(){}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0Vector3@Ogre@@QAE@XZ ENDP				; Ogre::Vector3::Vector3
_TEXT	ENDS
PUBLIC	??0Vector3@Ogre@@QAE@ABV01@@Z			; Ogre::Vector3::Vector3
EXTRN	__fltused:DWORD
; Function compile flags: /Odtp
;	COMDAT ??0Vector3@Ogre@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_rhs$ = 8						; size = 4
??0Vector3@Ogre@@QAE@ABV01@@Z PROC			; Ogre::Vector3::Vector3, COMDAT
; _this$ = ecx

; 50   : 		Vector3(const Vector3 &rhs)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 51   : 		{
; 52   : 			x = rhs.x;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _rhs$[ebp]
	fld	DWORD PTR [ecx]
	fstp	DWORD PTR [eax]

; 53   : 			y = rhs.y;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _rhs$[ebp]
	fld	DWORD PTR [eax+4]
	fstp	DWORD PTR [edx+4]

; 54   : 			z = rhs.z;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _rhs$[ebp]
	fld	DWORD PTR [edx+8]
	fstp	DWORD PTR [ecx+8]

; 55   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0Vector3@Ogre@@QAE@ABV01@@Z ENDP			; Ogre::Vector3::Vector3
_TEXT	ENDS
PUBLIC	??0Vector3@Ogre@@QAE@MMM@Z			; Ogre::Vector3::Vector3
; Function compile flags: /Odtp
;	COMDAT ??0Vector3@Ogre@@QAE@MMM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_x1$ = 8						; size = 4
_y1$ = 12						; size = 4
_z1$ = 16						; size = 4
??0Vector3@Ogre@@QAE@MMM@Z PROC				; Ogre::Vector3::Vector3, COMDAT
; _this$ = ecx

; 56   : 		Vector3( float x1, float y1, float z1 ) : x(x1), y(y1), z(z1){}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR _x1$[ebp]
	fstp	DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _y1$[ebp]
	fstp	DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _z1$[ebp]
	fstp	DWORD PTR [edx+8]
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??0Vector3@Ogre@@QAE@MMM@Z ENDP				; Ogre::Vector3::Vector3
_TEXT	ENDS
PUBLIC	??0Vector3@Ogre@@QAE@M@Z			; Ogre::Vector3::Vector3
; Function compile flags: /Odtp
;	COMDAT ??0Vector3@Ogre@@QAE@M@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_v$ = 8							; size = 4
??0Vector3@Ogre@@QAE@M@Z PROC				; Ogre::Vector3::Vector3, COMDAT
; _this$ = ecx

; 57   : 		Vector3(float v) : x(v), y(v), z(v){}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR _v$[ebp]
	fstp	DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _v$[ebp]
	fstp	DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _v$[ebp]
	fstp	DWORD PTR [edx+8]
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0Vector3@Ogre@@QAE@M@Z ENDP				; Ogre::Vector3::Vector3
_TEXT	ENDS
PUBLIC	??0Vector3@Ogre@@QAE@PAM@Z			; Ogre::Vector3::Vector3
; Function compile flags: /Odtp
;	COMDAT ??0Vector3@Ogre@@QAE@PAM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_v$ = 8							; size = 4
??0Vector3@Ogre@@QAE@PAM@Z PROC				; Ogre::Vector3::Vector3, COMDAT
; _this$ = ecx

; 58   : 		Vector3(float* v) : x(v[0]), y(v[1]), z(v[2]){}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [ecx]
	fstp	DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _v$[ebp]
	fld	DWORD PTR [eax+4]
	fstp	DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _v$[ebp]
	fld	DWORD PTR [edx+8]
	fstp	DWORD PTR [ecx+8]
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0Vector3@Ogre@@QAE@PAM@Z ENDP				; Ogre::Vector3::Vector3
_TEXT	ENDS
PUBLIC	??4Vector3@Ogre@@QAEABV01@ABV01@@Z		; Ogre::Vector3::operator=
; Function compile flags: /Odtp
;	COMDAT ??4Vector3@Ogre@@QAEABV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_vec$ = 8						; size = 4
??4Vector3@Ogre@@QAEABV01@ABV01@@Z PROC			; Ogre::Vector3::operator=, COMDAT
; _this$ = ecx

; 61   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 62   : 			x = vec.x;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _vec$[ebp]
	fld	DWORD PTR [ecx]
	fstp	DWORD PTR [eax]

; 63   : 			y = vec.y;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _vec$[ebp]
	fld	DWORD PTR [eax+4]
	fstp	DWORD PTR [edx+4]

; 64   : 			z = vec.z;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _vec$[ebp]
	fld	DWORD PTR [edx+8]
	fstp	DWORD PTR [ecx+8]

; 65   : 			return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 66   : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??4Vector3@Ogre@@QAEABV01@ABV01@@Z ENDP			; Ogre::Vector3::operator=
_TEXT	ENDS
PUBLIC	??YVector3@Ogre@@QAEXABV01@@Z			; Ogre::Vector3::operator+=
; Function compile flags: /Odtp
;	COMDAT ??YVector3@Ogre@@QAEXABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_vec$ = 8						; size = 4
??YVector3@Ogre@@QAEXABV01@@Z PROC			; Ogre::Vector3::operator+=, COMDAT
; _this$ = ecx

; 68   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 69   : 			x += vec.x;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax]
	mov	ecx, DWORD PTR _vec$[ebp]
	fadd	DWORD PTR [ecx]
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx]

; 70   : 			y += vec.y;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _vec$[ebp]
	fadd	DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+4]

; 71   : 			z += vec.z;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+8]
	mov	ecx, DWORD PTR _vec$[ebp]
	fadd	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+8]

; 72   : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??YVector3@Ogre@@QAEXABV01@@Z ENDP			; Ogre::Vector3::operator+=
_TEXT	ENDS
PUBLIC	??ZVector3@Ogre@@QAEXABV01@@Z			; Ogre::Vector3::operator-=
; Function compile flags: /Odtp
;	COMDAT ??ZVector3@Ogre@@QAEXABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_vec$ = 8						; size = 4
??ZVector3@Ogre@@QAEXABV01@@Z PROC			; Ogre::Vector3::operator-=, COMDAT
; _this$ = ecx

; 74   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 75   : 			x -= vec.x;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax]
	mov	ecx, DWORD PTR _vec$[ebp]
	fsub	DWORD PTR [ecx]
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx]

; 76   : 			y -= vec.y;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _vec$[ebp]
	fsub	DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+4]

; 77   : 			z -= vec.z;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+8]
	mov	ecx, DWORD PTR _vec$[ebp]
	fsub	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+8]

; 78   : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??ZVector3@Ogre@@QAEXABV01@@Z ENDP			; Ogre::Vector3::operator-=
_TEXT	ENDS
PUBLIC	??XVector3@Ogre@@QAEXM@Z			; Ogre::Vector3::operator*=
; Function compile flags: /Odtp
;	COMDAT ??XVector3@Ogre@@QAEXM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_s$ = 8							; size = 4
??XVector3@Ogre@@QAEXM@Z PROC				; Ogre::Vector3::operator*=, COMDAT
; _this$ = ecx

; 81   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 82   : 			x *= s;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax]
	fmul	DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx]

; 83   : 			y *= s;

	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+4]
	fmul	DWORD PTR _s$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [eax+4]

; 84   : 			z *= s;

	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+8]
	fmul	DWORD PTR _s$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+8]

; 85   : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??XVector3@Ogre@@QAEXM@Z ENDP				; Ogre::Vector3::operator*=
_TEXT	ENDS
PUBLIC	??XVector3@Ogre@@QAEXABV01@@Z			; Ogre::Vector3::operator*=
; Function compile flags: /Odtp
;	COMDAT ??XVector3@Ogre@@QAEXABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_vec$ = 8						; size = 4
??XVector3@Ogre@@QAEXABV01@@Z PROC			; Ogre::Vector3::operator*=, COMDAT
; _this$ = ecx

; 88   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 89   : 			x *= vec.x;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax]
	mov	ecx, DWORD PTR _vec$[ebp]
	fmul	DWORD PTR [ecx]
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx]

; 90   : 			y *= vec.y;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _vec$[ebp]
	fmul	DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+4]

; 91   : 			z *= vec.z;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+8]
	mov	ecx, DWORD PTR _vec$[ebp]
	fmul	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+8]

; 92   : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??XVector3@Ogre@@QAEXABV01@@Z ENDP			; Ogre::Vector3::operator*=
_TEXT	ENDS
PUBLIC	??_0Vector3@Ogre@@QAEXM@Z			; Ogre::Vector3::operator/=
; Function compile flags: /Odtp
;	COMDAT ??_0Vector3@Ogre@@QAEXM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_s$ = 8							; size = 4
??_0Vector3@Ogre@@QAEXM@Z PROC				; Ogre::Vector3::operator/=, COMDAT
; _this$ = ecx

; 95   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 96   : 			x /= s;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax]
	fdiv	DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx]

; 97   : 			y /= s;

	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+4]
	fdiv	DWORD PTR _s$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [eax+4]

; 98   : 			z /= s;

	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+8]
	fdiv	DWORD PTR _s$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+8]

; 99   : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??_0Vector3@Ogre@@QAEXM@Z ENDP				; Ogre::Vector3::operator/=
_TEXT	ENDS
PUBLIC	??BVector3@Ogre@@QAEPAMXZ			; Ogre::Vector3::operator float *
; Function compile flags: /Odtp
;	COMDAT ??BVector3@Ogre@@QAEPAMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??BVector3@Ogre@@QAEPAMXZ PROC				; Ogre::Vector3::operator float *, COMDAT
; _this$ = ecx

; 101  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 102  : 			return &x;

	mov	eax, DWORD PTR _this$[ebp]

; 103  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??BVector3@Ogre@@QAEPAMXZ ENDP				; Ogre::Vector3::operator float *
_TEXT	ENDS
PUBLIC	??BVector3@Ogre@@QBEPBMXZ			; Ogre::Vector3::operator float const *
; Function compile flags: /Odtp
;	COMDAT ??BVector3@Ogre@@QBEPBMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??BVector3@Ogre@@QBEPBMXZ PROC				; Ogre::Vector3::operator float const *, COMDAT
; _this$ = ecx

; 105  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 106  : 			return &x;

	mov	eax, DWORD PTR _this$[ebp]

; 107  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??BVector3@Ogre@@QBEPBMXZ ENDP				; Ogre::Vector3::operator float const *
_TEXT	ENDS
PUBLIC	??HVector3@Ogre@@QBE?AV01@XZ			; Ogre::Vector3::operator+
; Function compile flags: /Odtp
;	COMDAT ??HVector3@Ogre@@QBE?AV01@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
??HVector3@Ogre@@QBE?AV01@XZ PROC			; Ogre::Vector3::operator+, COMDAT
; _this$ = ecx

; 109  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 110  : 			return *this;

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector3@Ogre@@QAE@ABV01@@Z		; Ogre::Vector3::Vector3
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 111  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??HVector3@Ogre@@QBE?AV01@XZ ENDP			; Ogre::Vector3::operator+
_TEXT	ENDS
PUBLIC	??GVector3@Ogre@@QBE?AV01@XZ			; Ogre::Vector3::operator-
; Function compile flags: /Odtp
;	COMDAT ??GVector3@Ogre@@QBE?AV01@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
??GVector3@Ogre@@QBE?AV01@XZ PROC			; Ogre::Vector3::operator-, COMDAT
; _this$ = ecx

; 113  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 114  : 			return Vector3(-x, -y, -z);

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+8]
	fchs
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+4]
	fchs
	push	ecx
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx]
	fchs
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector3@Ogre@@QAE@MMM@Z		; Ogre::Vector3::Vector3
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 115  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??GVector3@Ogre@@QBE?AV01@XZ ENDP			; Ogre::Vector3::operator-
_TEXT	ENDS
PUBLIC	??8Vector3@Ogre@@QBE_NABV01@@Z			; Ogre::Vector3::operator==
; Function compile flags: /Odtp
;	COMDAT ??8Vector3@Ogre@@QBE_NABV01@@Z
_TEXT	SEGMENT
tv77 = -8						; size = 4
_this$ = -4						; size = 4
_vec$ = 8						; size = 4
??8Vector3@Ogre@@QBE_NABV01@@Z PROC			; Ogre::Vector3::operator==, COMDAT
; _this$ = ecx

; 117  : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 118  : 			return (x==vec.x && y==vec.y && z==vec.z);

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax]
	mov	ecx, DWORD PTR _vec$[ebp]
	fld	DWORD PTR [ecx]
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	SHORT $LN3@operator
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+4]
	mov	eax, DWORD PTR _vec$[ebp]
	fld	DWORD PTR [eax+4]
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	SHORT $LN3@operator
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _vec$[ebp]
	fld	DWORD PTR [edx+8]
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	SHORT $LN3@operator
	mov	DWORD PTR tv77[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv77[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv77[ebp]

; 119  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??8Vector3@Ogre@@QBE_NABV01@@Z ENDP			; Ogre::Vector3::operator==
_TEXT	ENDS
PUBLIC	?setElement@Vector3@Ogre@@QAEXMMM@Z		; Ogre::Vector3::setElement
; Function compile flags: /Odtp
;	COMDAT ?setElement@Vector3@Ogre@@QAEXMMM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_x1$ = 8						; size = 4
_y1$ = 12						; size = 4
_z1$ = 16						; size = 4
?setElement@Vector3@Ogre@@QAEXMMM@Z PROC		; Ogre::Vector3::setElement, COMDAT
; _this$ = ecx

; 121  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 122  : 			x = x1;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR _x1$[ebp]
	fstp	DWORD PTR [eax]

; 123  : 			y = y1;

	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _y1$[ebp]
	fstp	DWORD PTR [ecx+4]

; 124  : 			z = z1;

	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _z1$[ebp]
	fstp	DWORD PTR [edx+8]

; 125  : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?setElement@Vector3@Ogre@@QAEXMMM@Z ENDP		; Ogre::Vector3::setElement
_TEXT	ENDS
PUBLIC	?setElement@Vector3@Ogre@@QAEXPAM@Z		; Ogre::Vector3::setElement
; Function compile flags: /Odtp
;	COMDAT ?setElement@Vector3@Ogre@@QAEXPAM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_p$ = 8							; size = 4
?setElement@Vector3@Ogre@@QAEXPAM@Z PROC		; Ogre::Vector3::setElement, COMDAT
; _this$ = ecx

; 127  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 128  : 			x = p[0];

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _p$[ebp]
	fld	DWORD PTR [ecx]
	fstp	DWORD PTR [eax]

; 129  : 			y = p[1];

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _p$[ebp]
	fld	DWORD PTR [eax+4]
	fstp	DWORD PTR [edx+4]

; 130  : 			z = p[2];

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _p$[ebp]
	fld	DWORD PTR [edx+8]
	fstp	DWORD PTR [ecx+8]

; 131  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?setElement@Vector3@Ogre@@QAEXPAM@Z ENDP		; Ogre::Vector3::setElement
_TEXT	ENDS
PUBLIC	?Sqrt@Ogre@@YAMM@Z				; Ogre::Sqrt
PUBLIC	?length@Vector3@Ogre@@QBEMXZ			; Ogre::Vector3::length
; Function compile flags: /Odtp
;	COMDAT ?length@Vector3@Ogre@@QBEMXZ
_TEXT	SEGMENT
tv88 = -8						; size = 4
_this$ = -4						; size = 4
?length@Vector3@Ogre@@QBEMXZ PROC			; Ogre::Vector3::length, COMDAT
; _this$ = ecx

; 133  : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 134  : 			return (float)Sqrt(x*x+y*y+z*z);

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	fmul	DWORD PTR [ecx]
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+4]
	mov	eax, DWORD PTR _this$[ebp]
	fmul	DWORD PTR [eax+4]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _this$[ebp]
	fmul	DWORD PTR [edx+8]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR tv88[ebp]
	fld	DWORD PTR tv88[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	call	?Sqrt@Ogre@@YAMM@Z			; Ogre::Sqrt
	add	esp, 4

; 135  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?length@Vector3@Ogre@@QBEMXZ ENDP			; Ogre::Vector3::length
_TEXT	ENDS
PUBLIC	?sqrt@@YAMM@Z					; sqrt
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogremath.h
;	COMDAT ?Sqrt@Ogre@@YAMM@Z
_TEXT	SEGMENT
_x$ = 8							; size = 4
?Sqrt@Ogre@@YAMM@Z PROC					; Ogre::Sqrt, COMDAT

; 59   : 	{

	push	ebp
	mov	ebp, esp

; 60   : 		return (float)sqrt(x);

	push	ecx
	fld	DWORD PTR _x$[ebp]
	fstp	DWORD PTR [esp]
	call	?sqrt@@YAMM@Z				; sqrt
	add	esp, 4

; 61   : 	}

	pop	ebp
	ret	0
?Sqrt@Ogre@@YAMM@Z ENDP					; Ogre::Sqrt
_TEXT	ENDS
PUBLIC	_sqrtf
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\math.h
;	COMDAT ?sqrt@@YAMM@Z
_TEXT	SEGMENT
__X$ = 8						; size = 4
?sqrt@@YAMM@Z PROC					; sqrt, COMDAT

; 534  :         {return (sqrtf(_X)); }

	push	ebp
	mov	ebp, esp
	push	ecx
	fld	DWORD PTR __X$[ebp]
	fstp	DWORD PTR [esp]
	call	_sqrtf
	add	esp, 4
	pop	ebp
	ret	0
?sqrt@@YAMM@Z ENDP					; sqrt
_TEXT	ENDS
EXTRN	_sqrt:PROC
; Function compile flags: /Odtp
;	COMDAT _sqrtf
_TEXT	SEGMENT
tv73 = -4						; size = 4
__X$ = 8						; size = 4
_sqrtf	PROC						; COMDAT

; 423  :         {return ((float)sqrt((double)_X)); }

	push	ebp
	mov	ebp, esp
	push	ecx
	fld	DWORD PTR __X$[ebp]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_sqrt
	add	esp, 8
	fstp	DWORD PTR tv73[ebp]
	fld	DWORD PTR tv73[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
_sqrtf	ENDP
_TEXT	ENDS
PUBLIC	?lengthSqr@Vector3@Ogre@@QBEMXZ			; Ogre::Vector3::lengthSqr
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogrevector3.h
;	COMDAT ?lengthSqr@Vector3@Ogre@@QBEMXZ
_TEXT	SEGMENT
tv88 = -8						; size = 4
_this$ = -4						; size = 4
?lengthSqr@Vector3@Ogre@@QBEMXZ PROC			; Ogre::Vector3::lengthSqr, COMDAT
; _this$ = ecx

; 137  : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 138  : 			return (x*x+y*y+z*z);

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	fmul	DWORD PTR [ecx]
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+4]
	mov	eax, DWORD PTR _this$[ebp]
	fmul	DWORD PTR [eax+4]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _this$[ebp]
	fmul	DWORD PTR [edx+8]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR tv88[ebp]
	fld	DWORD PTR tv88[ebp]

; 139  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?lengthSqr@Vector3@Ogre@@QBEMXZ ENDP			; Ogre::Vector3::lengthSqr
_TEXT	ENDS
PUBLIC	??0WorldPos@Ogre@@QAE@XZ			; Ogre::WorldPos::WorldPos
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogreworldpos.h
;	COMDAT ??0WorldPos@Ogre@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0WorldPos@Ogre@@QAE@XZ PROC				; Ogre::WorldPos::WorldPos, COMDAT
; _this$ = ecx

; 18   : 		WorldPos()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 19   : 		{
; 20   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0WorldPos@Ogre@@QAE@XZ ENDP				; Ogre::WorldPos::WorldPos
_TEXT	ENDS
PUBLIC	??0WorldPos@Ogre@@QAE@HHH@Z			; Ogre::WorldPos::WorldPos
; Function compile flags: /Odtp
;	COMDAT ??0WorldPos@Ogre@@QAE@HHH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__x$ = 8						; size = 4
__y$ = 12						; size = 4
__z$ = 16						; size = 4
??0WorldPos@Ogre@@QAE@HHH@Z PROC			; Ogre::WorldPos::WorldPos, COMDAT
; _this$ = ecx

; 23   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __x$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __y$[ebp]
	mov	DWORD PTR [edx+4], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __z$[ebp]
	mov	DWORD PTR [ecx+8], edx

; 24   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??0WorldPos@Ogre@@QAE@HHH@Z ENDP			; Ogre::WorldPos::WorldPos
_TEXT	ENDS
PUBLIC	__real@4024000000000000
PUBLIC	??0WorldPos@Ogre@@QAE@ABVVector3@1@@Z		; Ogre::WorldPos::WorldPos
EXTRN	__ftol2_sse:PROC
;	COMDAT __real@4024000000000000
CONST	SEGMENT
__real@4024000000000000 DQ 04024000000000000r	; 10
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ??0WorldPos@Ogre@@QAE@ABVVector3@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_vec$ = 8						; size = 4
??0WorldPos@Ogre@@QAE@ABVVector3@1@@Z PROC		; Ogre::WorldPos::WorldPos, COMDAT
; _this$ = ecx

; 26   : 		WorldPos( const Vector3 &vec )

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 27   : 		{
; 28   : 			x = (WPOS_T)(vec.x * UNIT);

	mov	eax, DWORD PTR _vec$[ebp]
	fld	DWORD PTR [eax]
	fmul	QWORD PTR __real@4024000000000000
	call	__ftol2_sse
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 29   : 			y = (WPOS_T)(vec.y * UNIT);

	mov	edx, DWORD PTR _vec$[ebp]
	fld	DWORD PTR [edx+4]
	fmul	QWORD PTR __real@4024000000000000
	call	__ftol2_sse
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 30   : 			z = (WPOS_T)(vec.z * UNIT);

	mov	edx, DWORD PTR _vec$[ebp]
	fld	DWORD PTR [edx+8]
	fmul	QWORD PTR __real@4024000000000000
	call	__ftol2_sse
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 31   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0WorldPos@Ogre@@QAE@ABVVector3@1@@Z ENDP		; Ogre::WorldPos::WorldPos
_TEXT	ENDS
PUBLIC	??4WorldPos@Ogre@@QAEABV01@ABVVector3@1@@Z	; Ogre::WorldPos::operator=
; Function compile flags: /Odtp
;	COMDAT ??4WorldPos@Ogre@@QAEABV01@ABVVector3@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_vec$ = 8						; size = 4
??4WorldPos@Ogre@@QAEABV01@ABVVector3@1@@Z PROC		; Ogre::WorldPos::operator=, COMDAT
; _this$ = ecx

; 34   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 35   : 			x = (WPOS_T)(vec.x * UNIT);

	mov	eax, DWORD PTR _vec$[ebp]
	fld	DWORD PTR [eax]
	fmul	QWORD PTR __real@4024000000000000
	call	__ftol2_sse
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 36   : 			y = (WPOS_T)(vec.y * UNIT);

	mov	edx, DWORD PTR _vec$[ebp]
	fld	DWORD PTR [edx+4]
	fmul	QWORD PTR __real@4024000000000000
	call	__ftol2_sse
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 37   : 			z = (WPOS_T)(vec.z * UNIT);

	mov	edx, DWORD PTR _vec$[ebp]
	fld	DWORD PTR [edx+8]
	fmul	QWORD PTR __real@4024000000000000
	call	__ftol2_sse
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 38   : 
; 39   : 			return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 40   : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??4WorldPos@Ogre@@QAEABV01@ABVVector3@1@@Z ENDP		; Ogre::WorldPos::operator=
_TEXT	ENDS
PUBLIC	??YWorldPos@Ogre@@QAEABV01@ABVVector3@1@@Z	; Ogre::WorldPos::operator+=
; Function compile flags: /Odtp
;	COMDAT ??YWorldPos@Ogre@@QAEABV01@ABVVector3@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_vec$ = 8						; size = 4
??YWorldPos@Ogre@@QAEABV01@ABVVector3@1@@Z PROC		; Ogre::WorldPos::operator+=, COMDAT
; _this$ = ecx

; 43   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 44   : 			x += (WPOS_T)(vec.x * UNIT);

	mov	eax, DWORD PTR _vec$[ebp]
	fld	DWORD PTR [eax]
	fmul	QWORD PTR __real@4024000000000000
	call	__ftol2_sse
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], eax

; 45   : 			y += (WPOS_T)(vec.y * UNIT);

	mov	eax, DWORD PTR _vec$[ebp]
	fld	DWORD PTR [eax+4]
	fmul	QWORD PTR __real@4024000000000000
	call	__ftol2_sse
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], eax

; 46   : 			z += (WPOS_T)(vec.z * UNIT);

	mov	eax, DWORD PTR _vec$[ebp]
	fld	DWORD PTR [eax+8]
	fmul	QWORD PTR __real@4024000000000000
	call	__ftol2_sse
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], eax

; 47   : 
; 48   : 			return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 49   : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??YWorldPos@Ogre@@QAEABV01@ABVVector3@1@@Z ENDP		; Ogre::WorldPos::operator+=
_TEXT	ENDS
PUBLIC	??YWorldPos@Ogre@@QAEABV01@ABV01@@Z		; Ogre::WorldPos::operator+=
; Function compile flags: /Odtp
;	COMDAT ??YWorldPos@Ogre@@QAEABV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pos$ = 8						; size = 4
??YWorldPos@Ogre@@QAEABV01@ABV01@@Z PROC		; Ogre::WorldPos::operator+=, COMDAT
; _this$ = ecx

; 52   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 53   : 			x += pos.x;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _pos$[ebp]
	add	ecx, DWORD PTR [edx]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], ecx

; 54   : 			y += pos.y;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _pos$[ebp]
	add	edx, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], edx

; 55   : 			z += pos.z;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR _pos$[ebp]
	add	eax, DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], eax

; 56   : 
; 57   : 			return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 58   : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??YWorldPos@Ogre@@QAEABV01@ABV01@@Z ENDP		; Ogre::WorldPos::operator+=
_TEXT	ENDS
PUBLIC	??ZWorldPos@Ogre@@QAEABV01@ABVVector3@1@@Z	; Ogre::WorldPos::operator-=
; Function compile flags: /Odtp
;	COMDAT ??ZWorldPos@Ogre@@QAEABV01@ABVVector3@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_vec$ = 8						; size = 4
??ZWorldPos@Ogre@@QAEABV01@ABVVector3@1@@Z PROC		; Ogre::WorldPos::operator-=, COMDAT
; _this$ = ecx

; 61   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 62   : 			x -= (WPOS_T)(vec.x * UNIT);

	mov	eax, DWORD PTR _vec$[ebp]
	fld	DWORD PTR [eax]
	fmul	QWORD PTR __real@4024000000000000
	call	__ftol2_sse
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	sub	edx, eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], edx

; 63   : 			y -= (WPOS_T)(vec.y * UNIT);

	mov	ecx, DWORD PTR _vec$[ebp]
	fld	DWORD PTR [ecx+4]
	fmul	QWORD PTR __real@4024000000000000
	call	__ftol2_sse
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+4]
	sub	ecx, eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 64   : 			z -= (WPOS_T)(vec.z * UNIT);

	mov	eax, DWORD PTR _vec$[ebp]
	fld	DWORD PTR [eax+8]
	fmul	QWORD PTR __real@4024000000000000
	call	__ftol2_sse
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	sub	edx, eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], edx

; 65   : 
; 66   : 			return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 67   : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??ZWorldPos@Ogre@@QAEABV01@ABVVector3@1@@Z ENDP		; Ogre::WorldPos::operator-=
_TEXT	ENDS
PUBLIC	??ZWorldPos@Ogre@@QAEABV01@ABV01@@Z		; Ogre::WorldPos::operator-=
; Function compile flags: /Odtp
;	COMDAT ??ZWorldPos@Ogre@@QAEABV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pos$ = 8						; size = 4
??ZWorldPos@Ogre@@QAEABV01@ABV01@@Z PROC		; Ogre::WorldPos::operator-=, COMDAT
; _this$ = ecx

; 70   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 71   : 			x -= pos.x;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pos$[ebp]
	mov	edx, DWORD PTR [eax]
	sub	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], edx

; 72   : 			y -= pos.y;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _pos$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	sub	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 73   : 			z -= pos.z;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _pos$[ebp]
	mov	ecx, DWORD PTR [edx+8]
	sub	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 74   : 
; 75   : 			return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 76   : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??ZWorldPos@Ogre@@QAEABV01@ABV01@@Z ENDP		; Ogre::WorldPos::operator-=
_TEXT	ENDS
PUBLIC	??HWorldPos@Ogre@@QBE?AV01@ABV01@@Z		; Ogre::WorldPos::operator+
; Function compile flags: /Odtp
;	COMDAT ??HWorldPos@Ogre@@QBE?AV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_pos$ = 12						; size = 4
??HWorldPos@Ogre@@QBE?AV01@ABV01@@Z PROC		; Ogre::WorldPos::operator+, COMDAT
; _this$ = ecx

; 79   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 80   : 			return WorldPos(x+pos.x, y+pos.y, z+pos.z);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _pos$[ebp]
	add	ecx, DWORD PTR [edx+8]
	push	ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _pos$[ebp]
	add	ecx, DWORD PTR [edx+4]
	push	ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _pos$[ebp]
	add	ecx, DWORD PTR [edx]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0WorldPos@Ogre@@QAE@HHH@Z		; Ogre::WorldPos::WorldPos
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 81   : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
??HWorldPos@Ogre@@QBE?AV01@ABV01@@Z ENDP		; Ogre::WorldPos::operator+
_TEXT	ENDS
PUBLIC	??GWorldPos@Ogre@@QBE?AV01@ABV01@@Z		; Ogre::WorldPos::operator-
; Function compile flags: /Odtp
;	COMDAT ??GWorldPos@Ogre@@QBE?AV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_pos$ = 12						; size = 4
??GWorldPos@Ogre@@QBE?AV01@ABV01@@Z PROC		; Ogre::WorldPos::operator-, COMDAT
; _this$ = ecx

; 84   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 85   : 			return WorldPos(x-pos.x, y-pos.y, z-pos.z);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pos$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+8]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pos$[ebp]
	mov	edx, DWORD PTR [eax+4]
	sub	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pos$[ebp]
	mov	edx, DWORD PTR [eax]
	sub	edx, DWORD PTR [ecx]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0WorldPos@Ogre@@QAE@HHH@Z		; Ogre::WorldPos::WorldPos
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 86   : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
??GWorldPos@Ogre@@QBE?AV01@ABV01@@Z ENDP		; Ogre::WorldPos::operator-
_TEXT	ENDS
PUBLIC	??HWorldPos@Ogre@@QBE?AV01@ABVVector3@1@@Z	; Ogre::WorldPos::operator+
; Function compile flags: /Odtp
;	COMDAT ??HWorldPos@Ogre@@QBE?AV01@ABVVector3@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_pos$ = 12						; size = 4
??HWorldPos@Ogre@@QBE?AV01@ABVVector3@1@@Z PROC		; Ogre::WorldPos::operator+, COMDAT
; _this$ = ecx

; 89   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 90   : 			return WorldPos(x+(WPOS_T)(pos.x*UNIT), y+(WPOS_T)(pos.y*UNIT), z+(WPOS_T)(pos.z*UNIT));

	mov	eax, DWORD PTR _pos$[ebp]
	fld	DWORD PTR [eax+8]
	fmul	QWORD PTR __real@4024000000000000
	call	__ftol2_sse
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+8]
	push	eax
	mov	edx, DWORD PTR _pos$[ebp]
	fld	DWORD PTR [edx+4]
	fmul	QWORD PTR __real@4024000000000000
	call	__ftol2_sse
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+4]
	push	eax
	mov	edx, DWORD PTR _pos$[ebp]
	fld	DWORD PTR [edx]
	fmul	QWORD PTR __real@4024000000000000
	call	__ftol2_sse
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0WorldPos@Ogre@@QAE@HHH@Z		; Ogre::WorldPos::WorldPos
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 91   : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
??HWorldPos@Ogre@@QBE?AV01@ABVVector3@1@@Z ENDP		; Ogre::WorldPos::operator+
_TEXT	ENDS
PUBLIC	??GWorldPos@Ogre@@QBE?AV01@ABVVector3@1@@Z	; Ogre::WorldPos::operator-
; Function compile flags: /Odtp
;	COMDAT ??GWorldPos@Ogre@@QBE?AV01@ABVVector3@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_pos$ = 12						; size = 4
??GWorldPos@Ogre@@QBE?AV01@ABVVector3@1@@Z PROC		; Ogre::WorldPos::operator-, COMDAT
; _this$ = ecx

; 94   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 95   : 			return WorldPos(x-(WPOS_T)(pos.x*UNIT), y-(WPOS_T)(pos.y*UNIT), z-(WPOS_T)(pos.z*UNIT));

	mov	eax, DWORD PTR _pos$[ebp]
	fld	DWORD PTR [eax+8]
	fmul	QWORD PTR __real@4024000000000000
	call	__ftol2_sse
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	sub	edx, eax
	push	edx
	mov	eax, DWORD PTR _pos$[ebp]
	fld	DWORD PTR [eax+4]
	fmul	QWORD PTR __real@4024000000000000
	call	__ftol2_sse
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	sub	edx, eax
	push	edx
	mov	eax, DWORD PTR _pos$[ebp]
	fld	DWORD PTR [eax]
	fmul	QWORD PTR __real@4024000000000000
	call	__ftol2_sse
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	sub	edx, eax
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0WorldPos@Ogre@@QAE@HHH@Z		; Ogre::WorldPos::WorldPos
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 96   : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
??GWorldPos@Ogre@@QBE?AV01@ABVVector3@1@@Z ENDP		; Ogre::WorldPos::operator-
_TEXT	ENDS
PUBLIC	??DWorldPos@Ogre@@QBE?AV01@H@Z			; Ogre::WorldPos::operator*
; Function compile flags: /Odtp
;	COMDAT ??DWorldPos@Ogre@@QBE?AV01@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_s$ = 12						; size = 4
??DWorldPos@Ogre@@QBE?AV01@H@Z PROC			; Ogre::WorldPos::operator*, COMDAT
; _this$ = ecx

; 99   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 100  : 			return WorldPos((WPOS_T)(x*s), (WPOS_T)(y*s), (WPOS_T)(z*s));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	imul	ecx, DWORD PTR _s$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	imul	eax, DWORD PTR _s$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	imul	edx, DWORD PTR _s$[ebp]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0WorldPos@Ogre@@QAE@HHH@Z		; Ogre::WorldPos::WorldPos
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 101  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
??DWorldPos@Ogre@@QBE?AV01@H@Z ENDP			; Ogre::WorldPos::operator*
_TEXT	ENDS
PUBLIC	??DWorldPos@Ogre@@QBE?AV01@M@Z			; Ogre::WorldPos::operator*
; Function compile flags: /Odtp
;	COMDAT ??DWorldPos@Ogre@@QBE?AV01@M@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_s$ = 12						; size = 4
??DWorldPos@Ogre@@QBE?AV01@M@Z PROC			; Ogre::WorldPos::operator*, COMDAT
; _this$ = ecx

; 104  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 105  : 			return WorldPos((WPOS_T)(x*s), (WPOS_T)(y*s), (WPOS_T)(z*s));

	mov	eax, DWORD PTR _this$[ebp]
	fild	DWORD PTR [eax+8]
	fmul	DWORD PTR _s$[ebp]
	call	__ftol2_sse
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	fild	DWORD PTR [ecx+4]
	fmul	DWORD PTR _s$[ebp]
	call	__ftol2_sse
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	fild	DWORD PTR [edx]
	fmul	DWORD PTR _s$[ebp]
	call	__ftol2_sse
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0WorldPos@Ogre@@QAE@HHH@Z		; Ogre::WorldPos::WorldPos
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 106  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
??DWorldPos@Ogre@@QBE?AV01@M@Z ENDP			; Ogre::WorldPos::operator*
_TEXT	ENDS
PUBLIC	??KWorldPos@Ogre@@QBE?AV01@H@Z			; Ogre::WorldPos::operator/
; Function compile flags: /Odtp
;	COMDAT ??KWorldPos@Ogre@@QBE?AV01@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_s$ = 12						; size = 4
??KWorldPos@Ogre@@QBE?AV01@H@Z PROC			; Ogre::WorldPos::operator/, COMDAT
; _this$ = ecx

; 109  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 110  : 			return WorldPos((WPOS_T)(x/s), (WPOS_T)(y/s), (WPOS_T)(z/s));

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]
	cdq
	idiv	DWORD PTR _s$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	cdq
	idiv	DWORD PTR _s$[ebp]
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	cdq
	idiv	DWORD PTR _s$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0WorldPos@Ogre@@QAE@HHH@Z		; Ogre::WorldPos::WorldPos
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 111  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
??KWorldPos@Ogre@@QBE?AV01@H@Z ENDP			; Ogre::WorldPos::operator/
_TEXT	ENDS
PUBLIC	??8WorldPos@Ogre@@QBE_NABV01@@Z			; Ogre::WorldPos::operator==
; Function compile flags: /Odtp
;	COMDAT ??8WorldPos@Ogre@@QBE_NABV01@@Z
_TEXT	SEGMENT
tv71 = -8						; size = 4
_this$ = -4						; size = 4
_rhs$ = 8						; size = 4
??8WorldPos@Ogre@@QBE_NABV01@@Z PROC			; Ogre::WorldPos::operator==, COMDAT
; _this$ = ecx

; 114  : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 115  : 			return x==rhs.x && y==rhs.y && z==rhs.z;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _rhs$[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx]
	jne	SHORT $LN3@operator@2
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _rhs$[ebp]
	mov	edx, DWORD PTR [eax+4]
	cmp	edx, DWORD PTR [ecx+4]
	jne	SHORT $LN3@operator@2
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _rhs$[ebp]
	mov	edx, DWORD PTR [eax+8]
	cmp	edx, DWORD PTR [ecx+8]
	jne	SHORT $LN3@operator@2
	mov	DWORD PTR tv71[ebp], 1
	jmp	SHORT $LN4@operator@2
$LN3@operator@2:
	mov	DWORD PTR tv71[ebp], 0
$LN4@operator@2:
	mov	al, BYTE PTR tv71[ebp]

; 116  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??8WorldPos@Ogre@@QBE_NABV01@@Z ENDP			; Ogre::WorldPos::operator==
_TEXT	ENDS
PUBLIC	??9WorldPos@Ogre@@QBE_NABV01@@Z			; Ogre::WorldPos::operator!=
; Function compile flags: /Odtp
;	COMDAT ??9WorldPos@Ogre@@QBE_NABV01@@Z
_TEXT	SEGMENT
tv71 = -8						; size = 4
_this$ = -4						; size = 4
_rhs$ = 8						; size = 4
??9WorldPos@Ogre@@QBE_NABV01@@Z PROC			; Ogre::WorldPos::operator!=, COMDAT
; _this$ = ecx

; 119  : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 120  : 			return x!=rhs.x || y!=rhs.y || z!=rhs.z;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _rhs$[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx]
	jne	SHORT $LN3@operator@3
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _rhs$[ebp]
	mov	edx, DWORD PTR [eax+4]
	cmp	edx, DWORD PTR [ecx+4]
	jne	SHORT $LN3@operator@3
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _rhs$[ebp]
	mov	edx, DWORD PTR [eax+8]
	cmp	edx, DWORD PTR [ecx+8]
	jne	SHORT $LN3@operator@3
	mov	DWORD PTR tv71[ebp], 0
	jmp	SHORT $LN4@operator@3
$LN3@operator@3:
	mov	DWORD PTR tv71[ebp], 1
$LN4@operator@3:
	mov	al, BYTE PTR tv71[ebp]

; 121  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??9WorldPos@Ogre@@QBE_NABV01@@Z ENDP			; Ogre::WorldPos::operator!=
_TEXT	ENDS
PUBLIC	?inverse@WorldPos@Ogre@@QAEXXZ			; Ogre::WorldPos::inverse
; Function compile flags: /Odtp
;	COMDAT ?inverse@WorldPos@Ogre@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?inverse@WorldPos@Ogre@@QAEXXZ PROC			; Ogre::WorldPos::inverse, COMDAT
; _this$ = ecx

; 124  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 125  : 			x = -x;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	neg	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], ecx

; 126  : 			y = -y;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	neg	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 127  : 			z = -z;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	neg	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 128  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?inverse@WorldPos@Ogre@@QAEXXZ ENDP			; Ogre::WorldPos::inverse
_TEXT	ENDS
PUBLIC	?normalize@WorldPos@Ogre@@QBE?AVVector3@2@XZ	; Ogre::WorldPos::normalize
; Function compile flags: /Odtp
;	COMDAT ?normalize@WorldPos@Ogre@@QBE?AVVector3@2@XZ
_TEXT	SEGMENT
tv133 = -48						; size = 4
tv131 = -44						; size = 4
tv129 = -40						; size = 4
_this$ = -36						; size = 4
_fy$ = -32						; size = 8
_fz$ = -24						; size = 8
_len$ = -16						; size = 8
_fx$ = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
?normalize@WorldPos@Ogre@@QBE?AVVector3@2@XZ PROC	; Ogre::WorldPos::normalize, COMDAT
; _this$ = ecx

; 131  : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H
	mov	DWORD PTR _this$[ebp], ecx

; 132  : 			double fx = double(x);

	mov	eax, DWORD PTR _this$[ebp]
	fild	DWORD PTR [eax]
	fstp	QWORD PTR _fx$[ebp]

; 133  : 			double fy = double(y);

	mov	ecx, DWORD PTR _this$[ebp]
	fild	DWORD PTR [ecx+4]
	fstp	QWORD PTR _fy$[ebp]

; 134  : 			double fz = double(z);

	mov	edx, DWORD PTR _this$[ebp]
	fild	DWORD PTR [edx+8]
	fstp	QWORD PTR _fz$[ebp]

; 135  : 			double len = sqrt( fx*fx + fy*fy + fz*fz );

	fld	QWORD PTR _fx$[ebp]
	fmul	QWORD PTR _fx$[ebp]
	fld	QWORD PTR _fy$[ebp]
	fmul	QWORD PTR _fy$[ebp]
	faddp	ST(1), ST(0)
	fld	QWORD PTR _fz$[ebp]
	fmul	QWORD PTR _fz$[ebp]
	faddp	ST(1), ST(0)
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_sqrt
	add	esp, 8
	fstp	QWORD PTR _len$[ebp]

; 136  : 
; 137  : 			return Vector3( float(fx/len), float(fy/len), float(fz/len) );

	fld	QWORD PTR _fz$[ebp]
	fdiv	QWORD PTR _len$[ebp]
	fstp	DWORD PTR tv129[ebp]
	fld	DWORD PTR tv129[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	fld	QWORD PTR _fy$[ebp]
	fdiv	QWORD PTR _len$[ebp]
	fstp	DWORD PTR tv131[ebp]
	fld	DWORD PTR tv131[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	fld	QWORD PTR _fx$[ebp]
	fdiv	QWORD PTR _len$[ebp]
	fstp	DWORD PTR tv133[ebp]
	fld	DWORD PTR tv133[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector3@Ogre@@QAE@MMM@Z		; Ogre::Vector3::Vector3
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 138  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?normalize@WorldPos@Ogre@@QBE?AVVector3@2@XZ ENDP	; Ogre::WorldPos::normalize
_TEXT	ENDS
PUBLIC	?subtract@WorldPos@Ogre@@QBE?AVVector3@2@ABV12@@Z ; Ogre::WorldPos::subtract
PUBLIC	?toVector3@WorldPos@Ogre@@QBE?AVVector3@2@XZ	; Ogre::WorldPos::toVector3
EXTRN	?m_Origin@WorldPos@Ogre@@2V12@A:BYTE		; Ogre::WorldPos::m_Origin
; Function compile flags: /Odtp
;	COMDAT ?toVector3@WorldPos@Ogre@@QBE?AVVector3@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?toVector3@WorldPos@Ogre@@QBE?AVVector3@2@XZ PROC	; Ogre::WorldPos::toVector3, COMDAT
; _this$ = ecx

; 141  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 142  : 			return subtract(m_Origin);

	push	OFFSET ?m_Origin@WorldPos@Ogre@@2V12@A	; Ogre::WorldPos::m_Origin
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?subtract@WorldPos@Ogre@@QBE?AVVector3@2@ABV12@@Z ; Ogre::WorldPos::subtract
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 143  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?toVector3@WorldPos@Ogre@@QBE?AVVector3@2@XZ ENDP	; Ogre::WorldPos::toVector3
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?subtract@WorldPos@Ogre@@QBE?AVVector3@2@ABV12@@Z
_TEXT	SEGMENT
tv130 = -28						; size = 4
tv129 = -24						; size = 4
tv93 = -20						; size = 4
tv92 = -16						; size = 4
tv88 = -12						; size = 4
tv87 = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_pos$ = 12						; size = 4
?subtract@WorldPos@Ogre@@QBE?AVVector3@2@ABV12@@Z PROC	; Ogre::WorldPos::subtract, COMDAT
; _this$ = ecx

; 146  : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR _this$[ebp], ecx

; 147  : 			return Vector3( float(double(x-pos.x)/UNIT), float(double(y-pos.y)/UNIT), float(double(z-pos.z)/UNIT) );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pos$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR tv87[ebp], edx
	fild	DWORD PTR tv87[ebp]
	fdiv	QWORD PTR __real@4024000000000000
	fstp	DWORD PTR tv88[ebp]
	fld	DWORD PTR tv88[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pos$[ebp]
	mov	edx, DWORD PTR [eax+4]
	sub	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR tv92[ebp], edx
	fild	DWORD PTR tv92[ebp]
	fdiv	QWORD PTR __real@4024000000000000
	fstp	DWORD PTR tv93[ebp]
	fld	DWORD PTR tv93[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pos$[ebp]
	mov	edx, DWORD PTR [eax]
	sub	edx, DWORD PTR [ecx]
	mov	DWORD PTR tv129[ebp], edx
	fild	DWORD PTR tv129[ebp]
	fdiv	QWORD PTR __real@4024000000000000
	fstp	DWORD PTR tv130[ebp]
	fld	DWORD PTR tv130[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector3@Ogre@@QAE@MMM@Z		; Ogre::Vector3::Vector3
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 148  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?subtract@WorldPos@Ogre@@QBE?AVVector3@2@ABV12@@Z ENDP	; Ogre::WorldPos::subtract
_TEXT	ENDS
PUBLIC	?Flt2Fix@WorldPos@Ogre@@SAHM@Z			; Ogre::WorldPos::Flt2Fix
; Function compile flags: /Odtp
;	COMDAT ?Flt2Fix@WorldPos@Ogre@@SAHM@Z
_TEXT	SEGMENT
_x$ = 8							; size = 4
?Flt2Fix@WorldPos@Ogre@@SAHM@Z PROC			; Ogre::WorldPos::Flt2Fix, COMDAT

; 151  : 		{

	push	ebp
	mov	ebp, esp

; 152  : 			return (WPOS_T)(x*UNIT);

	fld	DWORD PTR _x$[ebp]
	fmul	QWORD PTR __real@4024000000000000
	call	__ftol2_sse

; 153  : 		}

	pop	ebp
	ret	0
?Flt2Fix@WorldPos@Ogre@@SAHM@Z ENDP			; Ogre::WorldPos::Flt2Fix
_TEXT	ENDS
PUBLIC	?Fix2Flt@WorldPos@Ogre@@SAMH@Z			; Ogre::WorldPos::Fix2Flt
; Function compile flags: /Odtp
;	COMDAT ?Fix2Flt@WorldPos@Ogre@@SAMH@Z
_TEXT	SEGMENT
tv67 = -4						; size = 4
_x$ = 8							; size = 4
?Fix2Flt@WorldPos@Ogre@@SAMH@Z PROC			; Ogre::WorldPos::Fix2Flt, COMDAT

; 156  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx

; 157  : 			return float(double(x)/UNIT);

	fild	DWORD PTR _x$[ebp]
	fdiv	QWORD PTR __real@4024000000000000
	fstp	DWORD PTR tv67[ebp]
	fld	DWORD PTR tv67[ebp]

; 158  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?Fix2Flt@WorldPos@Ogre@@SAMH@Z ENDP			; Ogre::WorldPos::Fix2Flt
_TEXT	ENDS
PUBLIC	??4WorldPos@Ogre@@QAEAAV01@ABV01@@Z		; Ogre::WorldPos::operator=
; Function compile flags: /Odtp
;	COMDAT ??4WorldPos@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4WorldPos@Ogre@@QAEAAV01@ABV01@@Z PROC		; Ogre::WorldPos::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4WorldPos@Ogre@@QAEAAV01@ABV01@@Z ENDP		; Ogre::WorldPos::operator=
_TEXT	ENDS
PUBLIC	__real@3f800000
PUBLIC	__real@00000000
PUBLIC	??0Quaternion@Ogre@@QAE@XZ			; Ogre::Quaternion::Quaternion
;	COMDAT __real@3f800000
; File i:\svnroot\client\ogremain\ogrequaternion.h
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ??0Quaternion@Ogre@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0Quaternion@Ogre@@QAE@XZ PROC				; Ogre::Quaternion::Quaternion, COMDAT
; _this$ = ecx

; 54   : 		Quaternion():x(0), y(0), z(0), w(1.0f){}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fldz
	fstp	DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	fldz
	fstp	DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _this$[ebp]
	fldz
	fstp	DWORD PTR [edx+8]
	mov	eax, DWORD PTR _this$[ebp]
	fld1
	fstp	DWORD PTR [eax+12]
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0Quaternion@Ogre@@QAE@XZ ENDP				; Ogre::Quaternion::Quaternion
_TEXT	ENDS
PUBLIC	??0Quaternion@Ogre@@QAE@MMMM@Z			; Ogre::Quaternion::Quaternion
; Function compile flags: /Odtp
;	COMDAT ??0Quaternion@Ogre@@QAE@MMMM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_x1$ = 8						; size = 4
_y1$ = 12						; size = 4
_z1$ = 16						; size = 4
_w1$ = 20						; size = 4
??0Quaternion@Ogre@@QAE@MMMM@Z PROC			; Ogre::Quaternion::Quaternion, COMDAT
; _this$ = ecx

; 55   : 		Quaternion( float x1, float y1, float z1, float w1 ) : x(x1), y(y1), z(z1), w(w1){}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR _x1$[ebp]
	fstp	DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _y1$[ebp]
	fstp	DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _z1$[ebp]
	fstp	DWORD PTR [edx+8]
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR _w1$[ebp]
	fstp	DWORD PTR [eax+12]
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
??0Quaternion@Ogre@@QAE@MMMM@Z ENDP			; Ogre::Quaternion::Quaternion
_TEXT	ENDS
PUBLIC	??4Quaternion@Ogre@@QAEAAV01@ABV01@@Z		; Ogre::Quaternion::operator=
; Function compile flags: /Odtp
;	COMDAT ??4Quaternion@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_quat$ = 8						; size = 4
??4Quaternion@Ogre@@QAEAAV01@ABV01@@Z PROC		; Ogre::Quaternion::operator=, COMDAT
; _this$ = ecx

; 59   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 60   : 			x = quat.x;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _quat$[ebp]
	fld	DWORD PTR [ecx]
	fstp	DWORD PTR [eax]

; 61   : 			y = quat.y;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _quat$[ebp]
	fld	DWORD PTR [eax+4]
	fstp	DWORD PTR [edx+4]

; 62   : 			z = quat.z;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _quat$[ebp]
	fld	DWORD PTR [edx+8]
	fstp	DWORD PTR [ecx+8]

; 63   : 			w = quat.w;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _quat$[ebp]
	fld	DWORD PTR [ecx+12]
	fstp	DWORD PTR [eax+12]

; 64   : 			return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 65   : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??4Quaternion@Ogre@@QAEAAV01@ABV01@@Z ENDP		; Ogre::Quaternion::operator=
_TEXT	ENDS
PUBLIC	??XQuaternion@Ogre@@QAEXM@Z			; Ogre::Quaternion::operator*=
; Function compile flags: /Odtp
;	COMDAT ??XQuaternion@Ogre@@QAEXM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_s$ = 8							; size = 4
??XQuaternion@Ogre@@QAEXM@Z PROC			; Ogre::Quaternion::operator*=, COMDAT
; _this$ = ecx

; 67   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 68   : 			x *= s;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax]
	fmul	DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx]

; 69   : 			y *= s;

	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+4]
	fmul	DWORD PTR _s$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [eax+4]

; 70   : 			z *= s;

	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+8]
	fmul	DWORD PTR _s$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+8]

; 71   : 			w *= s;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+12]
	fmul	DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx+12]

; 72   : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??XQuaternion@Ogre@@QAEXM@Z ENDP			; Ogre::Quaternion::operator*=
_TEXT	ENDS
PUBLIC	?norm@Quaternion@Ogre@@QAEMXZ			; Ogre::Quaternion::norm
; Function compile flags: /Odtp
;	COMDAT ?norm@Quaternion@Ogre@@QAEMXZ
_TEXT	SEGMENT
tv94 = -8						; size = 4
_this$ = -4						; size = 4
?norm@Quaternion@Ogre@@QAEMXZ PROC			; Ogre::Quaternion::norm, COMDAT
; _this$ = ecx

; 74   : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 75   : 			return x*x+y*y+z*z+w*w;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	fmul	DWORD PTR [ecx]
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+4]
	mov	eax, DWORD PTR _this$[ebp]
	fmul	DWORD PTR [eax+4]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _this$[ebp]
	fmul	DWORD PTR [edx+8]
	faddp	ST(1), ST(0)
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+12]
	mov	ecx, DWORD PTR _this$[ebp]
	fmul	DWORD PTR [ecx+12]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR tv94[ebp]
	fld	DWORD PTR tv94[ebp]

; 76   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?norm@Quaternion@Ogre@@QAEMXZ ENDP			; Ogre::Quaternion::norm
_TEXT	ENDS
PUBLIC	?identity@Quaternion@Ogre@@QAEXXZ		; Ogre::Quaternion::identity
; Function compile flags: /Odtp
;	COMDAT ?identity@Quaternion@Ogre@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?identity@Quaternion@Ogre@@QAEXXZ PROC			; Ogre::Quaternion::identity, COMDAT
; _this$ = ecx

; 78   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 79   : 			x = y = z = 0;

	mov	eax, DWORD PTR _this$[ebp]
	fldz
	fstp	DWORD PTR [eax+8]
	mov	ecx, DWORD PTR _this$[ebp]
	fldz
	fstp	DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _this$[ebp]
	fldz
	fstp	DWORD PTR [edx]

; 80   : 			w = 1.0f;

	mov	eax, DWORD PTR _this$[ebp]
	fld1
	fstp	DWORD PTR [eax+12]

; 81   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?identity@Quaternion@Ogre@@QAEXXZ ENDP			; Ogre::Quaternion::identity
_TEXT	ENDS
PUBLIC	?inverse@Quaternion@Ogre@@QAEXXZ		; Ogre::Quaternion::inverse
; Function compile flags: /Odtp
;	COMDAT ?inverse@Quaternion@Ogre@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?inverse@Quaternion@Ogre@@QAEXXZ PROC			; Ogre::Quaternion::inverse, COMDAT
; _this$ = ecx

; 83   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 84   : 			x = -x;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax]
	fchs
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx]

; 85   : 			y = -y;

	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+4]
	fchs
	mov	eax, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [eax+4]

; 86   : 			z = -z;

	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+8]
	fchs
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+8]

; 87   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?inverse@Quaternion@Ogre@@QAEXXZ ENDP			; Ogre::Quaternion::inverse
_TEXT	ENDS
PUBLIC	?inverse@Quaternion@Ogre@@QBEXAAV12@@Z		; Ogre::Quaternion::inverse
; Function compile flags: /Odtp
;	COMDAT ?inverse@Quaternion@Ogre@@QBEXAAV12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_quat$ = 8						; size = 4
?inverse@Quaternion@Ogre@@QBEXAAV12@@Z PROC		; Ogre::Quaternion::inverse, COMDAT
; _this$ = ecx

; 89   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 90   : 			quat.x = -x;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax]
	fchs
	mov	ecx, DWORD PTR _quat$[ebp]
	fstp	DWORD PTR [ecx]

; 91   : 			quat.y = -y;

	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+4]
	fchs
	mov	eax, DWORD PTR _quat$[ebp]
	fstp	DWORD PTR [eax+4]

; 92   : 			quat.z = -z;

	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+8]
	fchs
	mov	edx, DWORD PTR _quat$[ebp]
	fstp	DWORD PTR [edx+8]

; 93   : 			quat.w = w;

	mov	eax, DWORD PTR _quat$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+12]
	fstp	DWORD PTR [eax+12]

; 94   : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?inverse@Quaternion@Ogre@@QBEXAAV12@@Z ENDP		; Ogre::Quaternion::inverse
_TEXT	ENDS
PUBLIC	?setElement@Quaternion@Ogre@@QAEXMMMM@Z		; Ogre::Quaternion::setElement
; Function compile flags: /Odtp
;	COMDAT ?setElement@Quaternion@Ogre@@QAEXMMMM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_x1$ = 8						; size = 4
_y1$ = 12						; size = 4
_z1$ = 16						; size = 4
_w1$ = 20						; size = 4
?setElement@Quaternion@Ogre@@QAEXMMMM@Z PROC		; Ogre::Quaternion::setElement, COMDAT
; _this$ = ecx

; 96   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 97   : 			x = x1;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR _x1$[ebp]
	fstp	DWORD PTR [eax]

; 98   : 			y = y1;

	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _y1$[ebp]
	fstp	DWORD PTR [ecx+4]

; 99   : 			z = z1;

	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _z1$[ebp]
	fstp	DWORD PTR [edx+8]

; 100  : 			w = w1;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR _w1$[ebp]
	fstp	DWORD PTR [eax+12]

; 101  : 		}

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?setElement@Quaternion@Ogre@@QAEXMMMM@Z ENDP		; Ogre::Quaternion::setElement
_TEXT	ENDS
PUBLIC	??9Quaternion@Ogre@@QBE_NABV01@@Z		; Ogre::Quaternion::operator!=
EXTRN	??8Quaternion@Ogre@@QBE_NABV01@@Z:PROC		; Ogre::Quaternion::operator==
; Function compile flags: /Odtp
;	COMDAT ??9Quaternion@Ogre@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_quat$ = 8						; size = 4
??9Quaternion@Ogre@@QBE_NABV01@@Z PROC			; Ogre::Quaternion::operator!=, COMDAT
; _this$ = ecx

; 105  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 106  : 			return !operator==(quat);

	mov	eax, DWORD PTR _quat$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??8Quaternion@Ogre@@QBE_NABV01@@Z	; Ogre::Quaternion::operator==
	movzx	eax, al
	neg	eax
	sbb	eax, eax
	add	eax, 1

; 107  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??9Quaternion@Ogre@@QBE_NABV01@@Z ENDP			; Ogre::Quaternion::operator!=
_TEXT	ENDS
PUBLIC	?getRow3@Matrix3@Ogre@@QBE?AVVector3@2@I@Z	; Ogre::Matrix3::getRow3
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogrematrix3.h
;	COMDAT ?getRow3@Matrix3@Ogre@@QBE?AVVector3@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_i$ = 12						; size = 4
?getRow3@Matrix3@Ogre@@QBE?AVVector3@2@I@Z PROC		; Ogre::Matrix3::getRow3, COMDAT
; _this$ = ecx

; 67   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 68   : 			return Vector3(m[i][0], m[i][1], m[i][2]);

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	fld	DWORD PTR [ecx+eax+8]
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 12					; 0000000cH
	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	fld	DWORD PTR [eax+edx+4]
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR _this$[ebp]
	push	ecx
	fld	DWORD PTR [edx+ecx]
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector3@Ogre@@QAE@MMM@Z		; Ogre::Vector3::Vector3
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 69   : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?getRow3@Matrix3@Ogre@@QBE?AVVector3@2@I@Z ENDP		; Ogre::Matrix3::getRow3
_TEXT	ENDS
PUBLIC	?identity@Matrix3@Ogre@@QAEXXZ			; Ogre::Matrix3::identity
; Function compile flags: /Odtp
;	COMDAT ?identity@Matrix3@Ogre@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?identity@Matrix3@Ogre@@QAEXXZ PROC			; Ogre::Matrix3::identity, COMDAT
; _this$ = ecx

; 71   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 72   : 			_11=1.0f, _12=0.0f, _13=0.0f;

	mov	eax, DWORD PTR _this$[ebp]
	fld1
	fstp	DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	fldz
	fstp	DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _this$[ebp]
	fldz
	fstp	DWORD PTR [edx+8]

; 73   : 			_21=0.0f, _22=1.0f, _23=0.0f;

	mov	eax, DWORD PTR _this$[ebp]
	fldz
	fstp	DWORD PTR [eax+12]
	mov	ecx, DWORD PTR _this$[ebp]
	fld1
	fstp	DWORD PTR [ecx+16]
	mov	edx, DWORD PTR _this$[ebp]
	fldz
	fstp	DWORD PTR [edx+20]

; 74   : 			_31=0.0f, _32=0.0f, _33=1.0f;

	mov	eax, DWORD PTR _this$[ebp]
	fldz
	fstp	DWORD PTR [eax+24]
	mov	ecx, DWORD PTR _this$[ebp]
	fldz
	fstp	DWORD PTR [ecx+28]
	mov	edx, DWORD PTR _this$[ebp]
	fld1
	fstp	DWORD PTR [edx+32]

; 75   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?identity@Matrix3@Ogre@@QAEXXZ ENDP			; Ogre::Matrix3::identity
_TEXT	ENDS
PUBLIC	?setRow@Matrix3@Ogre@@QAEXIMMM@Z		; Ogre::Matrix3::setRow
; Function compile flags: /Odtp
;	COMDAT ?setRow@Matrix3@Ogre@@QAEXIMMM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_i$ = 8							; size = 4
_x$ = 12						; size = 4
_y$ = 16						; size = 4
_z$ = 20						; size = 4
?setRow@Matrix3@Ogre@@QAEXIMMM@Z PROC			; Ogre::Matrix3::setRow, COMDAT
; _this$ = ecx

; 77   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 78   : 			m[i][0] = x;

	mov	eax, DWORD PTR _i$[ebp]
	imul	eax, 12					; 0000000cH
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _x$[ebp]
	fstp	DWORD PTR [ecx+eax]

; 79   : 			m[i][1] = y;

	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 12					; 0000000cH
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR _y$[ebp]
	fstp	DWORD PTR [eax+edx+4]

; 80   : 			m[i][2] = z;

	mov	ecx, DWORD PTR _i$[ebp]
	imul	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _z$[ebp]
	fstp	DWORD PTR [edx+ecx+8]

; 81   : 		}

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?setRow@Matrix3@Ogre@@QAEXIMMM@Z ENDP			; Ogre::Matrix3::setRow
_TEXT	ENDS
PUBLIC	?getColumn@Matrix3@Ogre@@QBE?AVVector3@2@I@Z	; Ogre::Matrix3::getColumn
; Function compile flags: /Odtp
;	COMDAT ?getColumn@Matrix3@Ogre@@QBE?AVVector3@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_i$ = 12						; size = 4
?getColumn@Matrix3@Ogre@@QBE?AVVector3@2@I@Z PROC	; Ogre::Matrix3::getColumn, COMDAT
; _this$ = ecx

; 84   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 85   : 			return Vector3(m[0][i], m[1][i], m[2][i]);

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	fld	DWORD PTR [ecx+eax*4+24]
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	fld	DWORD PTR [eax+edx*4+12]
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	push	ecx
	fld	DWORD PTR [edx+ecx*4]
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector3@Ogre@@QAE@MMM@Z		; Ogre::Vector3::Vector3
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 86   : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?getColumn@Matrix3@Ogre@@QBE?AVVector3@2@I@Z ENDP	; Ogre::Matrix3::getColumn
_TEXT	ENDS
PUBLIC	?makeScaleMatrix@Matrix3@Ogre@@QAEXM@Z		; Ogre::Matrix3::makeScaleMatrix
EXTRN	?makeScaleMatrix@Matrix3@Ogre@@QAEXABVVector3@2@@Z:PROC ; Ogre::Matrix3::makeScaleMatrix
; Function compile flags: /Odtp
;	COMDAT ?makeScaleMatrix@Matrix3@Ogre@@QAEXM@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
$T93313 = -12						; size = 12
_s$ = 8							; size = 4
?makeScaleMatrix@Matrix3@Ogre@@QAEXM@Z PROC		; Ogre::Matrix3::makeScaleMatrix, COMDAT
; _this$ = ecx

; 93   : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 94   : 			makeScaleMatrix(Vector3(s, s, s));

	push	ecx
	fld	DWORD PTR _s$[ebp]
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR _s$[ebp]
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR _s$[ebp]
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR $T93313[ebp]
	call	??0Vector3@Ogre@@QAE@MMM@Z		; Ogre::Vector3::Vector3
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?makeScaleMatrix@Matrix3@Ogre@@QAEXABVVector3@2@@Z ; Ogre::Matrix3::makeScaleMatrix

; 95   : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?makeScaleMatrix@Matrix3@Ogre@@QAEXM@Z ENDP		; Ogre::Matrix3::makeScaleMatrix
_TEXT	ENDS
PUBLIC	??4Matrix3@Ogre@@QAEAAV01@ABV01@@Z		; Ogre::Matrix3::operator=
; Function compile flags: /Odtp
;	COMDAT ??4Matrix3@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4Matrix3@Ogre@@QAEAAV01@ABV01@@Z PROC			; Ogre::Matrix3::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	esi, DWORD PTR ___that$[ebp]
	mov	ecx, 9
	mov	edi, DWORD PTR _this$[ebp]
	rep movsd
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
??4Matrix3@Ogre@@QAEAAV01@ABV01@@Z ENDP			; Ogre::Matrix3::operator=
_TEXT	ENDS
PUBLIC	??AMatrix4@Ogre@@QBEPBMI@Z			; Ogre::Matrix4::operator[]
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogrematrix4.h
;	COMDAT ??AMatrix4@Ogre@@QBEPBMI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_irow$ = 8						; size = 4
??AMatrix4@Ogre@@QBEPBMI@Z PROC				; Ogre::Matrix4::operator[], COMDAT
; _this$ = ecx

; 88   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 89   : 			return &m[irow][0];

	mov	eax, DWORD PTR _irow$[ebp]
	shl	eax, 4
	add	eax, DWORD PTR _this$[ebp]

; 90   : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??AMatrix4@Ogre@@QBEPBMI@Z ENDP				; Ogre::Matrix4::operator[]
_TEXT	ENDS
PUBLIC	??AMatrix4@Ogre@@QAEPAMI@Z			; Ogre::Matrix4::operator[]
; Function compile flags: /Odtp
;	COMDAT ??AMatrix4@Ogre@@QAEPAMI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_irow$ = 8						; size = 4
??AMatrix4@Ogre@@QAEPAMI@Z PROC				; Ogre::Matrix4::operator[], COMDAT
; _this$ = ecx

; 92   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 93   : 			return &m[irow][0];

	mov	eax, DWORD PTR _irow$[ebp]
	shl	eax, 4
	add	eax, DWORD PTR _this$[ebp]

; 94   : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??AMatrix4@Ogre@@QAEPAMI@Z ENDP				; Ogre::Matrix4::operator[]
_TEXT	ENDS
PUBLIC	?makeScaleMatrix@Matrix4@Ogre@@QAEXM@Z		; Ogre::Matrix4::makeScaleMatrix
EXTRN	?makeScaleMatrix@Matrix4@Ogre@@QAEXABVVector3@2@@Z:PROC ; Ogre::Matrix4::makeScaleMatrix
; Function compile flags: /Odtp
;	COMDAT ?makeScaleMatrix@Matrix4@Ogre@@QAEXM@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
$T93322 = -12						; size = 12
_s$ = 8							; size = 4
?makeScaleMatrix@Matrix4@Ogre@@QAEXM@Z PROC		; Ogre::Matrix4::makeScaleMatrix, COMDAT
; _this$ = ecx

; 101  : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 102  : 			makeScaleMatrix(Vector3(s, s, s));

	push	ecx
	fld	DWORD PTR _s$[ebp]
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR _s$[ebp]
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR _s$[ebp]
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR $T93322[ebp]
	call	??0Vector3@Ogre@@QAE@MMM@Z		; Ogre::Vector3::Vector3
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?makeScaleMatrix@Matrix4@Ogre@@QAEXABVVector3@2@@Z ; Ogre::Matrix4::makeScaleMatrix

; 103  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?makeScaleMatrix@Matrix4@Ogre@@QAEXM@Z ENDP		; Ogre::Matrix4::makeScaleMatrix
_TEXT	ENDS
PUBLIC	?setRow@Matrix4@Ogre@@QAEXIMMMM@Z		; Ogre::Matrix4::setRow
; Function compile flags: /Odtp
;	COMDAT ?setRow@Matrix4@Ogre@@QAEXIMMMM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_i$ = 8							; size = 4
_x$ = 12						; size = 4
_y$ = 16						; size = 4
_z$ = 20						; size = 4
_w$ = 24						; size = 4
?setRow@Matrix4@Ogre@@QAEXIMMMM@Z PROC			; Ogre::Matrix4::setRow, COMDAT
; _this$ = ecx

; 133  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 134  : 			m[i][0] = x;

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _x$[ebp]
	fstp	DWORD PTR [ecx+eax]

; 135  : 			m[i][1] = y;

	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR _y$[ebp]
	fstp	DWORD PTR [eax+edx+4]

; 136  : 			m[i][2] = z;

	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _z$[ebp]
	fstp	DWORD PTR [edx+ecx+8]

; 137  : 			m[i][3] = w;

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _w$[ebp]
	fstp	DWORD PTR [ecx+eax+12]

; 138  : 		}

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?setRow@Matrix4@Ogre@@QAEXIMMMM@Z ENDP			; Ogre::Matrix4::setRow
_TEXT	ENDS
PUBLIC	?setColumn@Matrix4@Ogre@@QAEXIMMMM@Z		; Ogre::Matrix4::setColumn
; Function compile flags: /Odtp
;	COMDAT ?setColumn@Matrix4@Ogre@@QAEXIMMMM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_i$ = 8							; size = 4
_x$ = 12						; size = 4
_y$ = 16						; size = 4
_z$ = 20						; size = 4
_w$ = 24						; size = 4
?setColumn@Matrix4@Ogre@@QAEXIMMMM@Z PROC		; Ogre::Matrix4::setColumn, COMDAT
; _this$ = ecx

; 140  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 141  : 			m[0][i] = x;

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _x$[ebp]
	fstp	DWORD PTR [ecx+eax*4]

; 142  : 			m[1][i] = y;

	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR _y$[ebp]
	fstp	DWORD PTR [eax+edx*4+16]

; 143  : 			m[2][i] = z;

	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _z$[ebp]
	fstp	DWORD PTR [edx+ecx*4+32]

; 144  : 			m[3][i] = w;

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _w$[ebp]
	fstp	DWORD PTR [ecx+eax*4+48]

; 145  : 		}

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?setColumn@Matrix4@Ogre@@QAEXIMMMM@Z ENDP		; Ogre::Matrix4::setColumn
_TEXT	ENDS
PUBLIC	?getRow3@Matrix4@Ogre@@QBE?AVVector3@2@I@Z	; Ogre::Matrix4::getRow3
; Function compile flags: /Odtp
;	COMDAT ?getRow3@Matrix4@Ogre@@QBE?AVVector3@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_i$ = 12						; size = 4
?getRow3@Matrix4@Ogre@@QBE?AVVector3@2@I@Z PROC		; Ogre::Matrix4::getRow3, COMDAT
; _this$ = ecx

; 147  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 148  : 			return Vector3(m[i][0], m[i][1], m[i][2]);

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	fld	DWORD PTR [ecx+eax+8]
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	fld	DWORD PTR [eax+edx+4]
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR _this$[ebp]
	push	ecx
	fld	DWORD PTR [edx+ecx]
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector3@Ogre@@QAE@MMM@Z		; Ogre::Vector3::Vector3
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 149  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?getRow3@Matrix4@Ogre@@QBE?AVVector3@2@I@Z ENDP		; Ogre::Matrix4::getRow3
_TEXT	ENDS
PUBLIC	?getColumn3@Matrix4@Ogre@@QBE?AVVector3@2@I@Z	; Ogre::Matrix4::getColumn3
; Function compile flags: /Odtp
;	COMDAT ?getColumn3@Matrix4@Ogre@@QBE?AVVector3@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_i$ = 12						; size = 4
?getColumn3@Matrix4@Ogre@@QBE?AVVector3@2@I@Z PROC	; Ogre::Matrix4::getColumn3, COMDAT
; _this$ = ecx

; 151  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 152  : 			return Vector3(m[0][i], m[1][i], m[2][i]);

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	fld	DWORD PTR [ecx+eax*4+32]
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	fld	DWORD PTR [eax+edx*4+16]
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	push	ecx
	fld	DWORD PTR [edx+ecx*4]
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector3@Ogre@@QAE@MMM@Z		; Ogre::Vector3::Vector3
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 153  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?getColumn3@Matrix4@Ogre@@QBE?AVVector3@2@I@Z ENDP	; Ogre::Matrix4::getColumn3
_TEXT	ENDS
PUBLIC	??0Vector4@Ogre@@QAE@MMMM@Z			; Ogre::Vector4::Vector4
PUBLIC	?getRow4@Matrix4@Ogre@@QBE?AVVector4@2@I@Z	; Ogre::Matrix4::getRow4
; Function compile flags: /Odtp
;	COMDAT ?getRow4@Matrix4@Ogre@@QBE?AVVector4@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_i$ = 12						; size = 4
?getRow4@Matrix4@Ogre@@QBE?AVVector4@2@I@Z PROC		; Ogre::Matrix4::getRow4, COMDAT
; _this$ = ecx

; 155  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 156  : 			return Vector4(m[i][0], m[i][1], m[i][2], m[i][3]);

	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	fld	DWORD PTR [ecx+eax+12]
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _i$[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	fld	DWORD PTR [eax+edx+8]
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _i$[ebp]
	shl	ecx, 4
	mov	edx, DWORD PTR _this$[ebp]
	push	ecx
	fld	DWORD PTR [edx+ecx+4]
	fstp	DWORD PTR [esp]
	mov	eax, DWORD PTR _i$[ebp]
	shl	eax, 4
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	fld	DWORD PTR [ecx+eax]
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector4@Ogre@@QAE@MMMM@Z		; Ogre::Vector4::Vector4
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 157  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?getRow4@Matrix4@Ogre@@QBE?AVVector4@2@I@Z ENDP		; Ogre::Matrix4::getRow4
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogrevector4.h
_TEXT	ENDS
;	COMDAT ??0Vector4@Ogre@@QAE@MMMM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_x1$ = 8						; size = 4
_y1$ = 12						; size = 4
_z1$ = 16						; size = 4
_w1$ = 20						; size = 4
??0Vector4@Ogre@@QAE@MMMM@Z PROC			; Ogre::Vector4::Vector4, COMDAT
; _this$ = ecx

; 44   : 		Vector4( float x1, float y1, float z1, float w1 ) : x(x1), y(y1), z(z1), w(w1){}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR _x1$[ebp]
	fstp	DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _y1$[ebp]
	fstp	DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _z1$[ebp]
	fstp	DWORD PTR [edx+8]
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR _w1$[ebp]
	fstp	DWORD PTR [eax+12]
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
??0Vector4@Ogre@@QAE@MMMM@Z ENDP			; Ogre::Vector4::Vector4
_TEXT	ENDS
PUBLIC	?getColumn4@Matrix4@Ogre@@QBE?AVVector4@2@I@Z	; Ogre::Matrix4::getColumn4
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogrematrix4.h
;	COMDAT ?getColumn4@Matrix4@Ogre@@QBE?AVVector4@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_i$ = 12						; size = 4
?getColumn4@Matrix4@Ogre@@QBE?AVVector4@2@I@Z PROC	; Ogre::Matrix4::getColumn4, COMDAT
; _this$ = ecx

; 159  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 160  : 			return Vector4(m[0][i], m[1][i], m[2][i], m[3][i]);

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	fld	DWORD PTR [ecx+eax*4+48]
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _i$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	fld	DWORD PTR [eax+edx*4+32]
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	push	ecx
	fld	DWORD PTR [edx+ecx*4+16]
	fstp	DWORD PTR [esp]
	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	fld	DWORD PTR [ecx+eax*4]
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector4@Ogre@@QAE@MMMM@Z		; Ogre::Vector4::Vector4
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 161  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?getColumn4@Matrix4@Ogre@@QBE?AVVector4@2@I@Z ENDP	; Ogre::Matrix4::getColumn4
_TEXT	ENDS
PUBLIC	?setTranslate@Matrix4@Ogre@@QAEXMMM@Z		; Ogre::Matrix4::setTranslate
; Function compile flags: /Odtp
;	COMDAT ?setTranslate@Matrix4@Ogre@@QAEXMMM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_z$ = 16						; size = 4
?setTranslate@Matrix4@Ogre@@QAEXMMM@Z PROC		; Ogre::Matrix4::setTranslate, COMDAT
; _this$ = ecx

; 163  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 164  : 			setRow( 3, x, y, z, 1.0f );

	push	ecx
	fld1
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR _z$[ebp]
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR _y$[ebp]
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR _x$[ebp]
	fstp	DWORD PTR [esp]
	push	3
	mov	ecx, DWORD PTR _this$[ebp]
	call	?setRow@Matrix4@Ogre@@QAEXIMMMM@Z	; Ogre::Matrix4::setRow

; 165  : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?setTranslate@Matrix4@Ogre@@QAEXMMM@Z ENDP		; Ogre::Matrix4::setTranslate
_TEXT	ENDS
PUBLIC	?setTranslate@Matrix4@Ogre@@QAEXABVVector3@2@@Z	; Ogre::Matrix4::setTranslate
; Function compile flags: /Odtp
;	COMDAT ?setTranslate@Matrix4@Ogre@@QAEXABVVector3@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pos$ = 8						; size = 4
?setTranslate@Matrix4@Ogre@@QAEXABVVector3@2@@Z PROC	; Ogre::Matrix4::setTranslate, COMDAT
; _this$ = ecx

; 167  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 168  : 			setTranslate( pos.x, pos.y, pos.z );

	mov	eax, DWORD PTR _pos$[ebp]
	push	ecx
	fld	DWORD PTR [eax+8]
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _pos$[ebp]
	push	ecx
	fld	DWORD PTR [ecx+4]
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _pos$[ebp]
	push	ecx
	fld	DWORD PTR [edx]
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?setTranslate@Matrix4@Ogre@@QAEXMMM@Z	; Ogre::Matrix4::setTranslate

; 169  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?setTranslate@Matrix4@Ogre@@QAEXABVVector3@2@@Z ENDP	; Ogre::Matrix4::setTranslate
_TEXT	ENDS
PUBLIC	?getTranslate@Matrix4@Ogre@@QBE?AVVector3@2@XZ	; Ogre::Matrix4::getTranslate
; Function compile flags: /Odtp
;	COMDAT ?getTranslate@Matrix4@Ogre@@QBE?AVVector3@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?getTranslate@Matrix4@Ogre@@QBE?AVVector3@2@XZ PROC	; Ogre::Matrix4::getTranslate, COMDAT
; _this$ = ecx

; 171  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 172  : 			return getRow3(3);

	push	3
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getRow3@Matrix4@Ogre@@QBE?AVVector3@2@I@Z ; Ogre::Matrix4::getRow3
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 173  : 		};

	mov	esp, ebp
	pop	ebp
	ret	4
?getTranslate@Matrix4@Ogre@@QBE?AVVector3@2@XZ ENDP	; Ogre::Matrix4::getTranslate
_TEXT	ENDS
PUBLIC	?transformCoord@Matrix4@Ogre@@QBE?AVVector3@2@ABV32@@Z ; Ogre::Matrix4::transformCoord
; Function compile flags: /Odtp
;	COMDAT ?transformCoord@Matrix4@Ogre@@QBE?AVVector3@2@ABV32@@Z
_TEXT	SEGMENT
tv182 = -16						; size = 4
tv174 = -12						; size = 4
tv166 = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_vec$ = 12						; size = 4
?transformCoord@Matrix4@Ogre@@QBE?AVVector3@2@ABV32@@Z PROC ; Ogre::Matrix4::transformCoord, COMDAT
; _this$ = ecx

; 233  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 234  : 		return Vector3( vec.x*_11 + vec.y*_21 + vec.z*_31 + _41,
; 235  : 			vec.x*_12 + vec.y*_22 + vec.z*_32 + _42,
; 236  : 			vec.x*_13 + vec.y*_23 + vec.z*_33 + _43 );

	mov	eax, DWORD PTR _vec$[ebp]
	fld	DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	fmul	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _vec$[ebp]
	fld	DWORD PTR [edx+4]
	mov	eax, DWORD PTR _this$[ebp]
	fmul	DWORD PTR [eax+24]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _vec$[ebp]
	fld	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _this$[ebp]
	fmul	DWORD PTR [edx+40]
	faddp	ST(1), ST(0)
	mov	eax, DWORD PTR _this$[ebp]
	fadd	DWORD PTR [eax+56]
	fstp	DWORD PTR tv166[ebp]
	fld	DWORD PTR tv166[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _vec$[ebp]
	fld	DWORD PTR [ecx]
	mov	edx, DWORD PTR _this$[ebp]
	fmul	DWORD PTR [edx+4]
	mov	eax, DWORD PTR _vec$[ebp]
	fld	DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _this$[ebp]
	fmul	DWORD PTR [ecx+20]
	faddp	ST(1), ST(0)
	mov	edx, DWORD PTR _vec$[ebp]
	fld	DWORD PTR [edx+8]
	mov	eax, DWORD PTR _this$[ebp]
	fmul	DWORD PTR [eax+36]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _this$[ebp]
	fadd	DWORD PTR [ecx+52]
	fstp	DWORD PTR tv174[ebp]
	fld	DWORD PTR tv174[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _vec$[ebp]
	fld	DWORD PTR [edx]
	mov	eax, DWORD PTR _this$[ebp]
	fmul	DWORD PTR [eax]
	mov	ecx, DWORD PTR _vec$[ebp]
	fld	DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _this$[ebp]
	fmul	DWORD PTR [edx+16]
	faddp	ST(1), ST(0)
	mov	eax, DWORD PTR _vec$[ebp]
	fld	DWORD PTR [eax+8]
	mov	ecx, DWORD PTR _this$[ebp]
	fmul	DWORD PTR [ecx+32]
	faddp	ST(1), ST(0)
	mov	edx, DWORD PTR _this$[ebp]
	fadd	DWORD PTR [edx+48]
	fstp	DWORD PTR tv182[ebp]
	fld	DWORD PTR tv182[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector3@Ogre@@QAE@MMM@Z		; Ogre::Vector3::Vector3
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 237  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?transformCoord@Matrix4@Ogre@@QBE?AVVector3@2@ABV32@@Z ENDP ; Ogre::Matrix4::transformCoord
_TEXT	ENDS
PUBLIC	??0BoxBound@Ogre@@QAE@XZ			; Ogre::BoxBound::BoxBound
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogrebounding.h
;	COMDAT ??0BoxBound@Ogre@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0BoxBound@Ogre@@QAE@XZ PROC				; Ogre::BoxBound::BoxBound, COMDAT
; _this$ = ecx

; 14   : 		BoxBound() : m_isValid(false){}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0Vector3@Ogre@@QAE@XZ			; Ogre::Vector3::Vector3
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??0Vector3@Ogre@@QAE@XZ			; Ogre::Vector3::Vector3
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+24], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0BoxBound@Ogre@@QAE@XZ ENDP				; Ogre::BoxBound::BoxBound
_TEXT	ENDS
PUBLIC	??0BoxBound@Ogre@@QAE@ABVVector3@1@0@Z		; Ogre::BoxBound::BoxBound
; Function compile flags: /Odtp
;	COMDAT ??0BoxBound@Ogre@@QAE@ABVVector3@1@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_minpos$ = 8						; size = 4
_maxpos$ = 12						; size = 4
??0BoxBound@Ogre@@QAE@ABVVector3@1@0@Z PROC		; Ogre::BoxBound::BoxBound, COMDAT
; _this$ = ecx

; 15   : 		BoxBound(const Vector3 &minpos, const Vector3 &maxpos) : m_MinPos(minpos), m_MaxPos(maxpos), m_isValid(true){}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _minpos$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0Vector3@Ogre@@QAE@ABV01@@Z		; Ogre::Vector3::Vector3
	mov	ecx, DWORD PTR _maxpos$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??0Vector3@Ogre@@QAE@ABV01@@Z		; Ogre::Vector3::Vector3
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+24], 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0BoxBound@Ogre@@QAE@ABVVector3@1@0@Z ENDP		; Ogre::BoxBound::BoxBound
_TEXT	ENDS
PUBLIC	??0BoxBound@Ogre@@QAE@ABV01@@Z			; Ogre::BoxBound::BoxBound
; Function compile flags: /Odtp
;	COMDAT ??0BoxBound@Ogre@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_rhs$ = 8						; size = 4
??0BoxBound@Ogre@@QAE@ABV01@@Z PROC			; Ogre::BoxBound::BoxBound, COMDAT
; _this$ = ecx

; 16   : 		BoxBound(const BoxBound &rhs) : m_MinPos(rhs.m_MinPos), m_MaxPos(rhs.m_MaxPos), m_isValid(rhs.m_isValid){}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _rhs$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0Vector3@Ogre@@QAE@ABV01@@Z		; Ogre::Vector3::Vector3
	mov	ecx, DWORD PTR _rhs$[ebp]
	add	ecx, 12					; 0000000cH
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??0Vector3@Ogre@@QAE@ABV01@@Z		; Ogre::Vector3::Vector3
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _rhs$[ebp]
	mov	cl, BYTE PTR [eax+24]
	mov	BYTE PTR [edx+24], cl
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0BoxBound@Ogre@@QAE@ABV01@@Z ENDP			; Ogre::BoxBound::BoxBound
_TEXT	ENDS
PUBLIC	??$Max@M@Ogre@@YAMABM0@Z			; Ogre::Max<float>
PUBLIC	??$Min@M@Ogre@@YAMABM0@Z			; Ogre::Min<float>
PUBLIC	??YBoxBound@Ogre@@QAEAAV01@ABVVector3@1@@Z	; Ogre::BoxBound::operator+=
; Function compile flags: /Odtp
;	COMDAT ??YBoxBound@Ogre@@QAEAAV01@ABVVector3@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_Other$ = 8						; size = 4
??YBoxBound@Ogre@@QAEAAV01@ABVVector3@1@@Z PROC		; Ogre::BoxBound::operator+=, COMDAT
; _this$ = ecx

; 19   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 20   : 			if( m_isValid )

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+24]
	test	ecx, ecx
	je	$LN2@operator@4

; 21   : 			{
; 22   : #if ASM_x86
; 23   : 				__asm
; 24   : 				{
; 25   : 						mov		eax,[Other]
; 26   : 						mov		ecx,[this]
; 27   : 
; 28   : 						movss	xmm3,[eax]Vector3.x
; 29   : 						movss	xmm4,[eax]Vector3.y
; 30   : 						movss	xmm5,[eax]Vector3.z
; 31   : 
; 32   : 						movss	xmm0,[ecx]BoxBound.m_MinPos.x
; 33   : 						movss	xmm1,[ecx]BoxBound.m_MinPos.y
; 34   : 						movss	xmm2,[ecx]BoxBound.m_MinPos.z
; 35   : 						minss	xmm0,xmm3
; 36   : 						minss	xmm1,xmm4
; 37   : 						minss	xmm2,xmm5
; 38   : 						movss	[ecx]BoxBound.m_MinPos.x,xmm0
; 39   : 						movss	[ecx]BoxBound.m_MinPos.y,xmm1
; 40   : 						movss	[ecx]BoxBound.m_MinPos.z,xmm2
; 41   : 
; 42   : 						movss	xmm0,[ecx]BoxBound.m_MaxPos.x
; 43   : 						movss	xmm1,[ecx]BoxBound.m_MaxPos.y
; 44   : 						movss	xmm2,[ecx]BoxBound.m_MaxPos.z
; 45   : 						maxss	xmm0,xmm3
; 46   : 						maxss	xmm1,xmm4
; 47   : 						maxss	xmm2,xmm5
; 48   : 						movss	[ecx]BoxBound.m_MaxPos.x,xmm0
; 49   : 						movss	[ecx]BoxBound.m_MaxPos.y,xmm1
; 50   : 						movss	[ecx]BoxBound.m_MaxPos.z,xmm2
; 51   : 				}
; 52   : #else
; 53   : 				m_MinPos.x = Min( m_MinPos.x, Other.x );

	mov	edx, DWORD PTR _Other$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??$Min@M@Ogre@@YAMABM0@Z		; Ogre::Min<float>
	add	esp, 8
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx]

; 54   : 				m_MinPos.y = Min( m_MinPos.y, Other.y );

	mov	edx, DWORD PTR _Other$[ebp]
	add	edx, 4
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4
	push	eax
	call	??$Min@M@Ogre@@YAMABM0@Z		; Ogre::Min<float>
	add	esp, 8
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx+4]

; 55   : 				m_MinPos.z = Min( m_MinPos.z, Other.z );

	mov	edx, DWORD PTR _Other$[ebp]
	add	edx, 8
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	call	??$Min@M@Ogre@@YAMABM0@Z		; Ogre::Min<float>
	add	esp, 8
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx+8]

; 56   : 
; 57   : 				m_MaxPos.x = Max( m_MaxPos.x, Other.x );

	mov	edx, DWORD PTR _Other$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 12					; 0000000cH
	push	eax
	call	??$Max@M@Ogre@@YAMABM0@Z		; Ogre::Max<float>
	add	esp, 8
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx+12]

; 58   : 				m_MaxPos.y = Max( m_MaxPos.y, Other.y );

	mov	edx, DWORD PTR _Other$[ebp]
	add	edx, 4
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 16					; 00000010H
	push	eax
	call	??$Max@M@Ogre@@YAMABM0@Z		; Ogre::Max<float>
	add	esp, 8
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx+16]

; 59   : 				m_MaxPos.z = Max( m_MaxPos.z, Other.z );

	mov	edx, DWORD PTR _Other$[ebp]
	add	edx, 8
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 20					; 00000014H
	push	eax
	call	??$Max@M@Ogre@@YAMABM0@Z		; Ogre::Max<float>
	add	esp, 8
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx+20]

; 60   : #endif
; 61   : 			}
; 62   : 			else

	jmp	SHORT $LN1@operator@4
$LN2@operator@4:

; 63   : 			{
; 64   : 				m_MinPos = m_MaxPos = Other;

	mov	edx, DWORD PTR _Other$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??4Vector3@Ogre@@QAEABV01@ABV01@@Z	; Ogre::Vector3::operator=
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4Vector3@Ogre@@QAEABV01@ABV01@@Z	; Ogre::Vector3::operator=

; 65   : 				m_isValid = true;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+24], 1
$LN1@operator@4:

; 66   : 			}
; 67   : 			return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 68   : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??YBoxBound@Ogre@@QAEAAV01@ABVVector3@1@@Z ENDP		; Ogre::BoxBound::operator+=
_TEXT	ENDS
PUBLIC	??4BoxBound@Ogre@@QAEAAV01@ABV01@@Z		; Ogre::BoxBound::operator=
PUBLIC	??YBoxBound@Ogre@@QAEAAV01@ABV01@@Z		; Ogre::BoxBound::operator+=
; Function compile flags: /Odtp
;	COMDAT ??YBoxBound@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_Other$ = 8						; size = 4
??YBoxBound@Ogre@@QAEAAV01@ABV01@@Z PROC		; Ogre::BoxBound::operator+=, COMDAT
; _this$ = ecx

; 71   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 72   : 			if( m_isValid && Other.m_isValid )

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+24]
	test	ecx, ecx
	je	$LN3@operator@5
	mov	edx, DWORD PTR _Other$[ebp]
	movzx	eax, BYTE PTR [edx+24]
	test	eax, eax
	je	$LN3@operator@5

; 73   : 			{
; 74   : #if ASM_X86
; 75   : 				__asm
; 76   : 				{
; 77   : 						mov		eax,[Other]
; 78   : 						mov		ecx,[this]
; 79   : 
; 80   : 						movss	xmm0,[ecx]BoxBound.m_MinPos.x
; 81   : 						movss	xmm1,[ecx]BoxBound.m_MinPos.y
; 82   : 						movss	xmm2,[ecx]BoxBound.m_MinPos.z
; 83   : 						minss	xmm0,[eax]BoxBound.m_MinPos.x
; 84   : 						minss	xmm1,[eax]BoxBound.m_MinPos.y
; 85   : 						minss	xmm2,[eax]BoxBound.m_MinPos.z
; 86   : 						movss	[ecx]BoxBound.m_MinPos.x,xmm0
; 87   : 						movss	[ecx]BoxBound.m_MinPos.y,xmm1
; 88   : 						movss	[ecx]BoxBound.m_MinPos.z,xmm2
; 89   : 
; 90   : 						movss	xmm0,[ecx]BoxBound.m_MaxPos.x
; 91   : 						movss	xmm1,[ecx]BoxBound.m_MaxPos.y
; 92   : 						movss	xmm2,[ecx]BoxBound.m_MaxPos.z
; 93   : 						maxss	xmm0,[eax]BoxBound.m_MaxPos.x
; 94   : 						maxss	xmm1,[eax]BoxBound.m_MaxPos.y
; 95   : 						maxss	xmm2,[eax]BoxBound.m_MaxPos.z
; 96   : 						movss	[ecx]BoxBound.m_MaxPos.x,xmm0
; 97   : 						movss	[ecx]BoxBound.m_MaxPos.y,xmm1
; 98   : 						movss	[ecx]BoxBound.m_MaxPos.z,xmm2
; 99   : 				}
; 100  : #else
; 101  : 				m_MinPos.x = Min( m_MinPos.x, Other.m_MinPos.x );

	mov	ecx, DWORD PTR _Other$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	??$Min@M@Ogre@@YAMABM0@Z		; Ogre::Min<float>
	add	esp, 8
	mov	eax, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [eax]

; 102  : 				m_MinPos.y = Min( m_MinPos.y, Other.m_MinPos.y );

	mov	ecx, DWORD PTR _Other$[ebp]
	add	ecx, 4
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 4
	push	edx
	call	??$Min@M@Ogre@@YAMABM0@Z		; Ogre::Min<float>
	add	esp, 8
	mov	eax, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [eax+4]

; 103  : 				m_MinPos.z = Min( m_MinPos.z, Other.m_MinPos.z );

	mov	ecx, DWORD PTR _Other$[ebp]
	add	ecx, 8
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 8
	push	edx
	call	??$Min@M@Ogre@@YAMABM0@Z		; Ogre::Min<float>
	add	esp, 8
	mov	eax, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [eax+8]

; 104  : 
; 105  : 				m_MaxPos.x = Max( m_MaxPos.x, Other.m_MaxPos.x );

	mov	ecx, DWORD PTR _Other$[ebp]
	add	ecx, 12					; 0000000cH
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 12					; 0000000cH
	push	edx
	call	??$Max@M@Ogre@@YAMABM0@Z		; Ogre::Max<float>
	add	esp, 8
	mov	eax, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [eax+12]

; 106  : 				m_MaxPos.y = Max( m_MaxPos.y, Other.m_MaxPos.y );

	mov	ecx, DWORD PTR _Other$[ebp]
	add	ecx, 16					; 00000010H
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 16					; 00000010H
	push	edx
	call	??$Max@M@Ogre@@YAMABM0@Z		; Ogre::Max<float>
	add	esp, 8
	mov	eax, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [eax+16]

; 107  : 				m_MaxPos.z = Max( m_MaxPos.z, Other.m_MaxPos.z );

	mov	ecx, DWORD PTR _Other$[ebp]
	add	ecx, 20					; 00000014H
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 20					; 00000014H
	push	edx
	call	??$Max@M@Ogre@@YAMABM0@Z		; Ogre::Max<float>
	add	esp, 8
	mov	eax, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [eax+20]
	jmp	SHORT $LN1@operator@5
$LN3@operator@5:

; 108  : #endif
; 109  : 			}
; 110  : 			else if( Other.m_isValid )

	mov	ecx, DWORD PTR _Other$[ebp]
	movzx	edx, BYTE PTR [ecx+24]
	test	edx, edx
	je	SHORT $LN1@operator@5

; 111  : 			{
; 112  : 				*this = Other;

	mov	eax, DWORD PTR _Other$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4BoxBound@Ogre@@QAEAAV01@ABV01@@Z
$LN1@operator@5:

; 113  : 			}
; 114  : 			return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 115  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??YBoxBound@Ogre@@QAEAAV01@ABV01@@Z ENDP		; Ogre::BoxBound::operator+=
_TEXT	ENDS
PUBLIC	?setRange@BoxBound@Ogre@@QAEXABVVector3@2@0@Z	; Ogre::BoxBound::setRange
; Function compile flags: /Odtp
;	COMDAT ?setRange@BoxBound@Ogre@@QAEXABVVector3@2@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_minpt$ = 8						; size = 4
_maxpt$ = 12						; size = 4
?setRange@BoxBound@Ogre@@QAEXABVVector3@2@0@Z PROC	; Ogre::BoxBound::setRange, COMDAT
; _this$ = ecx

; 118  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 119  : 			m_MinPos = minpt;

	mov	eax, DWORD PTR _minpt$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4Vector3@Ogre@@QAEABV01@ABV01@@Z	; Ogre::Vector3::operator=

; 120  : 			m_MaxPos = maxpt;

	mov	ecx, DWORD PTR _maxpt$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??4Vector3@Ogre@@QAEABV01@ABV01@@Z	; Ogre::Vector3::operator=

; 121  : 			m_isValid = true;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+24], 1

; 122  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?setRange@BoxBound@Ogre@@QAEXABVVector3@2@0@Z ENDP	; Ogre::BoxBound::setRange
_TEXT	ENDS
PUBLIC	??HOgre@@YA?AVVector3@0@ABV10@0@Z		; Ogre::operator+
PUBLIC	??GOgre@@YA?AVVector3@0@ABV10@0@Z		; Ogre::operator-
PUBLIC	?setCenterExtension@BoxBound@Ogre@@QAEXABVVector3@2@0@Z ; Ogre::BoxBound::setCenterExtension
; Function compile flags: /Odtp
;	COMDAT ?setCenterExtension@BoxBound@Ogre@@QAEXABVVector3@2@0@Z
_TEXT	SEGMENT
_this$ = -28						; size = 4
$T93360 = -24						; size = 12
$T93359 = -12						; size = 12
_center$ = 8						; size = 4
_exten$ = 12						; size = 4
?setCenterExtension@BoxBound@Ogre@@QAEXABVVector3@2@0@Z PROC ; Ogre::BoxBound::setCenterExtension, COMDAT
; _this$ = ecx

; 125  : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR _this$[ebp], ecx

; 126  : 			m_MinPos = center-exten;

	mov	eax, DWORD PTR _exten$[ebp]
	push	eax
	mov	ecx, DWORD PTR _center$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T93359[ebp]
	push	edx
	call	??GOgre@@YA?AVVector3@0@ABV10@0@Z	; Ogre::operator-
	add	esp, 12					; 0000000cH
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4Vector3@Ogre@@QAEABV01@ABV01@@Z	; Ogre::Vector3::operator=

; 127  : 			m_MaxPos = center+exten;

	mov	eax, DWORD PTR _exten$[ebp]
	push	eax
	mov	ecx, DWORD PTR _center$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T93360[ebp]
	push	edx
	call	??HOgre@@YA?AVVector3@0@ABV10@0@Z	; Ogre::operator+
	add	esp, 12					; 0000000cH
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??4Vector3@Ogre@@QAEABV01@ABV01@@Z	; Ogre::Vector3::operator=

; 128  : 			m_isValid = true;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+24], 1

; 129  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?setCenterExtension@BoxBound@Ogre@@QAEXABVVector3@2@0@Z ENDP ; Ogre::BoxBound::setCenterExtension
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogrevector3.h
_TEXT	ENDS
;	COMDAT ??HOgre@@YA?AVVector3@0@ABV10@0@Z
_TEXT	SEGMENT
tv92 = -12						; size = 4
tv89 = -8						; size = 4
tv86 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_v1$ = 12						; size = 4
_v2$ = 16						; size = 4
??HOgre@@YA?AVVector3@0@ABV10@0@Z PROC			; Ogre::operator+, COMDAT

; 164  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 165  : 		return Vector3(v1.x+v2.x, v1.y+v2.y, v1.z+v2.z);

	mov	eax, DWORD PTR _v1$[ebp]
	fld	DWORD PTR [eax+8]
	mov	ecx, DWORD PTR _v2$[ebp]
	fadd	DWORD PTR [ecx+8]
	fstp	DWORD PTR tv86[ebp]
	fld	DWORD PTR tv86[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _v1$[ebp]
	fld	DWORD PTR [edx+4]
	mov	eax, DWORD PTR _v2$[ebp]
	fadd	DWORD PTR [eax+4]
	fstp	DWORD PTR tv89[ebp]
	fld	DWORD PTR tv89[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _v1$[ebp]
	fld	DWORD PTR [ecx]
	mov	edx, DWORD PTR _v2$[ebp]
	fadd	DWORD PTR [edx]
	fstp	DWORD PTR tv92[ebp]
	fld	DWORD PTR tv92[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector3@Ogre@@QAE@MMM@Z		; Ogre::Vector3::Vector3
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 166  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??HOgre@@YA?AVVector3@0@ABV10@0@Z ENDP			; Ogre::operator+
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??GOgre@@YA?AVVector3@0@ABV10@0@Z
_TEXT	SEGMENT
tv92 = -12						; size = 4
tv89 = -8						; size = 4
tv86 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_v1$ = 12						; size = 4
_v2$ = 16						; size = 4
??GOgre@@YA?AVVector3@0@ABV10@0@Z PROC			; Ogre::operator-, COMDAT

; 174  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 175  : 		return Vector3(v1.x-v2.x, v1.y-v2.y, v1.z-v2.z);

	mov	eax, DWORD PTR _v1$[ebp]
	fld	DWORD PTR [eax+8]
	mov	ecx, DWORD PTR _v2$[ebp]
	fsub	DWORD PTR [ecx+8]
	fstp	DWORD PTR tv86[ebp]
	fld	DWORD PTR tv86[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _v1$[ebp]
	fld	DWORD PTR [edx+4]
	mov	eax, DWORD PTR _v2$[ebp]
	fsub	DWORD PTR [eax+4]
	fstp	DWORD PTR tv89[ebp]
	fld	DWORD PTR tv89[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _v1$[ebp]
	fld	DWORD PTR [ecx]
	mov	edx, DWORD PTR _v2$[ebp]
	fsub	DWORD PTR [edx]
	fstp	DWORD PTR tv92[ebp]
	fld	DWORD PTR tv92[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector3@Ogre@@QAE@MMM@Z		; Ogre::Vector3::Vector3
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 176  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??GOgre@@YA?AVVector3@0@ABV10@0@Z ENDP			; Ogre::operator-
_TEXT	ENDS
PUBLIC	?expandBy@BoxBound@Ogre@@QBE?AV12@M@Z		; Ogre::BoxBound::expandBy
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogrebounding.h
;	COMDAT ?expandBy@BoxBound@Ogre@@QBE?AV12@M@Z
_TEXT	SEGMENT
_this$ = -52						; size = 4
$T93370 = -48						; size = 12
$T93369 = -36						; size = 12
$T93368 = -24						; size = 12
$T93367 = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_w$ = 12						; size = 4
?expandBy@BoxBound@Ogre@@QBE?AV12@M@Z PROC		; Ogre::BoxBound::expandBy, COMDAT
; _this$ = ecx

; 134  : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H
	mov	DWORD PTR _this$[ebp], ecx

; 135  : 			return BoxBound( m_MinPos - Vector3(w,w,w), m_MaxPos + Vector3(w,w,w) );

	push	ecx
	fld	DWORD PTR _w$[ebp]
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR _w$[ebp]
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR _w$[ebp]
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR $T93367[ebp]
	call	??0Vector3@Ogre@@QAE@MMM@Z		; Ogre::Vector3::Vector3
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 12					; 0000000cH
	push	eax
	lea	ecx, DWORD PTR $T93368[ebp]
	push	ecx
	call	??HOgre@@YA?AVVector3@0@ABV10@0@Z	; Ogre::operator+
	add	esp, 12					; 0000000cH
	push	eax
	push	ecx
	fld	DWORD PTR _w$[ebp]
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR _w$[ebp]
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR _w$[ebp]
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR $T93369[ebp]
	call	??0Vector3@Ogre@@QAE@MMM@Z		; Ogre::Vector3::Vector3
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	lea	eax, DWORD PTR $T93370[ebp]
	push	eax
	call	??GOgre@@YA?AVVector3@0@ABV10@0@Z	; Ogre::operator-
	add	esp, 12					; 0000000cH
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0BoxBound@Ogre@@QAE@ABVVector3@1@0@Z	; Ogre::BoxBound::BoxBound
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 136  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?expandBy@BoxBound@Ogre@@QBE?AV12@M@Z ENDP		; Ogre::BoxBound::expandBy
_TEXT	ENDS
PUBLIC	??DOgre@@YA?AVVector3@0@ABV10@M@Z		; Ogre::operator*
PUBLIC	__real@3f000000
PUBLIC	?getCenter@BoxBound@Ogre@@QBE?AVVector3@2@XZ	; Ogre::BoxBound::getCenter
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ?getCenter@BoxBound@Ogre@@QBE?AVVector3@2@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
$T93373 = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
?getCenter@BoxBound@Ogre@@QBE?AVVector3@2@XZ PROC	; Ogre::BoxBound::getCenter, COMDAT
; _this$ = ecx

; 144  : 		Vector3 getCenter() const{ return (m_MinPos + m_MaxPos)*0.5f; }

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	fld	DWORD PTR __real@3f000000
	fstp	DWORD PTR [esp]
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 12					; 0000000cH
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T93373[ebp]
	push	edx
	call	??HOgre@@YA?AVVector3@0@ABV10@0@Z	; Ogre::operator+
	add	esp, 12					; 0000000cH
	push	eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	eax
	call	??DOgre@@YA?AVVector3@0@ABV10@M@Z	; Ogre::operator*
	add	esp, 12					; 0000000cH
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?getCenter@BoxBound@Ogre@@QBE?AVVector3@2@XZ ENDP	; Ogre::BoxBound::getCenter
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogrevector3.h
_TEXT	ENDS
;	COMDAT ??DOgre@@YA?AVVector3@0@ABV10@M@Z
_TEXT	SEGMENT
tv87 = -12						; size = 4
tv85 = -8						; size = 4
tv83 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_v1$ = 12						; size = 4
_s$ = 16						; size = 4
??DOgre@@YA?AVVector3@0@ABV10@M@Z PROC			; Ogre::operator*, COMDAT

; 189  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 190  : 		return Vector3(v1.x*s, v1.y*s, v1.z*s);

	mov	eax, DWORD PTR _v1$[ebp]
	fld	DWORD PTR [eax+8]
	fmul	DWORD PTR _s$[ebp]
	fstp	DWORD PTR tv83[ebp]
	fld	DWORD PTR tv83[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _v1$[ebp]
	fld	DWORD PTR [ecx+4]
	fmul	DWORD PTR _s$[ebp]
	fstp	DWORD PTR tv85[ebp]
	fld	DWORD PTR tv85[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _v1$[ebp]
	fld	DWORD PTR [edx]
	fmul	DWORD PTR _s$[ebp]
	fstp	DWORD PTR tv87[ebp]
	fld	DWORD PTR tv87[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector3@Ogre@@QAE@MMM@Z		; Ogre::Vector3::Vector3
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 191  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??DOgre@@YA?AVVector3@0@ABV10@M@Z ENDP			; Ogre::operator*
_TEXT	ENDS
PUBLIC	?getExtension@BoxBound@Ogre@@QBE?AVVector3@2@XZ	; Ogre::BoxBound::getExtension
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogrebounding.h
;	COMDAT ?getExtension@BoxBound@Ogre@@QBE?AVVector3@2@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
$T93380 = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
?getExtension@BoxBound@Ogre@@QBE?AVVector3@2@XZ PROC	; Ogre::BoxBound::getExtension, COMDAT
; _this$ = ecx

; 145  : 		Vector3 getExtension() const{ return (m_MaxPos - m_MinPos)*0.5f; }

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	fld	DWORD PTR __real@3f000000
	fstp	DWORD PTR [esp]
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	push	ecx
	lea	edx, DWORD PTR $T93380[ebp]
	push	edx
	call	??GOgre@@YA?AVVector3@0@ABV10@0@Z	; Ogre::operator-
	add	esp, 12					; 0000000cH
	push	eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	eax
	call	??DOgre@@YA?AVVector3@0@ABV10@M@Z	; Ogre::operator*
	add	esp, 12					; 0000000cH
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
?getExtension@BoxBound@Ogre@@QBE?AVVector3@2@XZ ENDP	; Ogre::BoxBound::getExtension
_TEXT	ENDS
PUBLIC	?getMinPos@BoxBound@Ogre@@QBEABVVector3@2@XZ	; Ogre::BoxBound::getMinPos
; Function compile flags: /Odtp
;	COMDAT ?getMinPos@BoxBound@Ogre@@QBEABVVector3@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getMinPos@BoxBound@Ogre@@QBEABVVector3@2@XZ PROC	; Ogre::BoxBound::getMinPos, COMDAT
; _this$ = ecx

; 146  : 		const Vector3 &getMinPos() const{ return m_MinPos; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
?getMinPos@BoxBound@Ogre@@QBEABVVector3@2@XZ ENDP	; Ogre::BoxBound::getMinPos
_TEXT	ENDS
PUBLIC	?getMaxPos@BoxBound@Ogre@@QBEABVVector3@2@XZ	; Ogre::BoxBound::getMaxPos
; Function compile flags: /Odtp
;	COMDAT ?getMaxPos@BoxBound@Ogre@@QBEABVVector3@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getMaxPos@BoxBound@Ogre@@QBEABVVector3@2@XZ PROC	; Ogre::BoxBound::getMaxPos, COMDAT
; _this$ = ecx

; 147  : 		const Vector3 &getMaxPos() const{ return m_MaxPos; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 12					; 0000000cH
	mov	esp, ebp
	pop	ebp
	ret	0
?getMaxPos@BoxBound@Ogre@@QBEABVVector3@2@XZ ENDP	; Ogre::BoxBound::getMaxPos
_TEXT	ENDS
PUBLIC	??$Abs@M@Ogre@@YAMABM@Z				; Ogre::Abs<float>
PUBLIC	?getRadiusInDirection@BoxBound@Ogre@@QBEMABVVector3@2@@Z ; Ogre::BoxBound::getRadiusInDirection
; Function compile flags: /Odtp
;	COMDAT ?getRadiusInDirection@BoxBound@Ogre@@QBEMABVVector3@2@@Z
_TEXT	SEGMENT
tv143 = -48						; size = 4
tv148 = -44						; size = 8
tv146 = -36						; size = 8
_this$ = -28						; size = 4
$T93389 = -24						; size = 4
$T93388 = -20						; size = 4
$T93387 = -16						; size = 4
_extent$ = -12						; size = 12
_dir$ = 8						; size = 4
?getRadiusInDirection@BoxBound@Ogre@@QBEMABVVector3@2@@Z PROC ; Ogre::BoxBound::getRadiusInDirection, COMDAT
; _this$ = ecx

; 150  : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H
	mov	DWORD PTR _this$[ebp], ecx

; 151  : 			Vector3 extent = getExtension();

	lea	eax, DWORD PTR _extent$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getExtension@BoxBound@Ogre@@QBE?AVVector3@2@XZ ; Ogre::BoxBound::getExtension

; 152  : 			return Abs(dir.x*extent.x) + Abs(dir.y*extent.y) + Abs(dir.z*extent.z);

	mov	ecx, DWORD PTR _dir$[ebp]
	fld	DWORD PTR [ecx]
	fmul	DWORD PTR _extent$[ebp]
	fstp	DWORD PTR $T93387[ebp]
	mov	edx, DWORD PTR _dir$[ebp]
	fld	DWORD PTR [edx+4]
	fmul	DWORD PTR _extent$[ebp+4]
	fstp	DWORD PTR $T93388[ebp]
	mov	eax, DWORD PTR _dir$[ebp]
	fld	DWORD PTR [eax+8]
	fmul	DWORD PTR _extent$[ebp+8]
	fstp	DWORD PTR $T93389[ebp]
	lea	ecx, DWORD PTR $T93387[ebp]
	push	ecx
	call	??$Abs@M@Ogre@@YAMABM@Z			; Ogre::Abs<float>
	add	esp, 4
	lea	edx, DWORD PTR $T93388[ebp]
	push	edx
	fstp	QWORD PTR tv146[ebp]
	call	??$Abs@M@Ogre@@YAMABM@Z			; Ogre::Abs<float>
	add	esp, 4
	fadd	QWORD PTR tv146[ebp]
	lea	eax, DWORD PTR $T93389[ebp]
	push	eax
	fstp	QWORD PTR tv148[ebp]
	call	??$Abs@M@Ogre@@YAMABM@Z			; Ogre::Abs<float>
	add	esp, 4
	fadd	QWORD PTR tv148[ebp]
	fstp	DWORD PTR tv143[ebp]
	fld	DWORD PTR tv143[ebp]

; 153  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?getRadiusInDirection@BoxBound@Ogre@@QBEMABVVector3@2@@Z ENDP ; Ogre::BoxBound::getRadiusInDirection
_TEXT	ENDS
PUBLIC	?isPointIn@BoxBound@Ogre@@QBE_NABVVector3@2@@Z	; Ogre::BoxBound::isPointIn
; Function compile flags: /Odtp
;	COMDAT ?isPointIn@BoxBound@Ogre@@QBE_NABVVector3@2@@Z
_TEXT	SEGMENT
tv94 = -8						; size = 4
_this$ = -4						; size = 4
_vPos$ = 8						; size = 4
?isPointIn@BoxBound@Ogre@@QBE_NABVVector3@2@@Z PROC	; Ogre::BoxBound::isPointIn, COMDAT
; _this$ = ecx

; 156  : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 157  : 			return (vPos.x>m_MinPos.x && vPos.x<m_MaxPos.x 
; 158  : 				    &&vPos.y>m_MinPos.y && vPos.y<m_MaxPos.y
; 159  : 					&&vPos.z>m_MinPos.z && vPos.z<m_MaxPos.z );

	mov	eax, DWORD PTR _vPos$[ebp]
	fld	DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx]
	fcompp
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN3@isPointIn
	mov	edx, DWORD PTR _vPos$[ebp]
	fld	DWORD PTR [edx]
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+12]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN3@isPointIn
	mov	ecx, DWORD PTR _vPos$[ebp]
	fld	DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+4]
	fcompp
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN3@isPointIn
	mov	eax, DWORD PTR _vPos$[ebp]
	fld	DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+16]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN3@isPointIn
	mov	edx, DWORD PTR _vPos$[ebp]
	fld	DWORD PTR [edx+8]
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+8]
	fcompp
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN3@isPointIn
	mov	ecx, DWORD PTR _vPos$[ebp]
	fld	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+20]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN3@isPointIn
	mov	DWORD PTR tv94[ebp], 1
	jmp	SHORT $LN4@isPointIn
$LN3@isPointIn:
	mov	DWORD PTR tv94[ebp], 0
$LN4@isPointIn:
	mov	al, BYTE PTR tv94[ebp]

; 160  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?isPointIn@BoxBound@Ogre@@QBE_NABVVector3@2@@Z ENDP	; Ogre::BoxBound::isPointIn
_TEXT	ENDS
PUBLIC	?isPointInXZ@BoxBound@Ogre@@QBE_NABVVector3@2@@Z ; Ogre::BoxBound::isPointInXZ
; Function compile flags: /Odtp
;	COMDAT ?isPointInXZ@BoxBound@Ogre@@QBE_NABVVector3@2@@Z
_TEXT	SEGMENT
tv83 = -8						; size = 4
_this$ = -4						; size = 4
_vPos$ = 8						; size = 4
?isPointInXZ@BoxBound@Ogre@@QBE_NABVVector3@2@@Z PROC	; Ogre::BoxBound::isPointInXZ, COMDAT
; _this$ = ecx

; 163  : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 164  : 			return (vPos.x>m_MinPos.x && vPos.x<m_MaxPos.x 
; 165  : 				&&vPos.z>m_MinPos.z && vPos.z<m_MaxPos.z );

	mov	eax, DWORD PTR _vPos$[ebp]
	fld	DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx]
	fcompp
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN3@isPointInX
	mov	edx, DWORD PTR _vPos$[ebp]
	fld	DWORD PTR [edx]
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+12]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN3@isPointInX
	mov	ecx, DWORD PTR _vPos$[ebp]
	fld	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+8]
	fcompp
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN3@isPointInX
	mov	eax, DWORD PTR _vPos$[ebp]
	fld	DWORD PTR [eax+8]
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+20]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN3@isPointInX
	mov	DWORD PTR tv83[ebp], 1
	jmp	SHORT $LN4@isPointInX
$LN3@isPointInX:
	mov	DWORD PTR tv83[ebp], 0
$LN4@isPointInX:
	mov	al, BYTE PTR tv83[ebp]

; 166  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?isPointInXZ@BoxBound@Ogre@@QBE_NABVVector3@2@@Z ENDP	; Ogre::BoxBound::isPointInXZ
_TEXT	ENDS
PUBLIC	?intersectBoxBound@BoxBound@Ogre@@QBE_NABV12@@Z	; Ogre::BoxBound::intersectBoxBound
; Function compile flags: /Odtp
;	COMDAT ?intersectBoxBound@BoxBound@Ogre@@QBE_NABV12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_other$ = 8						; size = 4
?intersectBoxBound@BoxBound@Ogre@@QBE_NABV12@@Z PROC	; Ogre::BoxBound::intersectBoxBound, COMDAT
; _this$ = ecx

; 169  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 170  : 			if( m_MinPos.x > other.m_MaxPos.x || other.m_MinPos.x > m_MaxPos.x )

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax]
	mov	ecx, DWORD PTR _other$[ebp]
	fld	DWORD PTR [ecx+12]
	fcompp
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $LN5@intersectB
	mov	edx, DWORD PTR _other$[ebp]
	fld	DWORD PTR [edx]
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+12]
	fcompp
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN6@intersectB
$LN5@intersectB:

; 171  : 				return false;

	xor	al, al
	jmp	SHORT $LN7@intersectB
$LN6@intersectB:

; 172  : 			if( m_MinPos.y > other.m_MaxPos.y || other.m_MinPos.y > m_MaxPos.y )

	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _other$[ebp]
	fld	DWORD PTR [edx+16]
	fcompp
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $LN3@intersectB
	mov	eax, DWORD PTR _other$[ebp]
	fld	DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+16]
	fcompp
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN4@intersectB
$LN3@intersectB:

; 173  : 				return false;

	xor	al, al
	jmp	SHORT $LN7@intersectB
$LN4@intersectB:

; 174  : 			if( m_MinPos.z > other.m_MaxPos.z || other.m_MinPos.z > m_MaxPos.z )

	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+8]
	mov	eax, DWORD PTR _other$[ebp]
	fld	DWORD PTR [eax+20]
	fcompp
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $LN1@intersectB
	mov	ecx, DWORD PTR _other$[ebp]
	fld	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+20]
	fcompp
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN2@intersectB
$LN1@intersectB:

; 175  : 				return false;

	xor	al, al
	jmp	SHORT $LN7@intersectB
$LN2@intersectB:

; 176  : 			return true;

	mov	al, 1
$LN7@intersectB:

; 177  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?intersectBoxBound@BoxBound@Ogre@@QBE_NABV12@@Z ENDP	; Ogre::BoxBound::intersectBoxBound
_TEXT	ENDS
PUBLIC	?isBoxBoundIn@BoxBound@Ogre@@QAE_NABV12@@Z	; Ogre::BoxBound::isBoxBoundIn
; Function compile flags: /Odtp
;	COMDAT ?isBoxBoundIn@BoxBound@Ogre@@QAE_NABV12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_box$ = 8						; size = 4
?isBoxBoundIn@BoxBound@Ogre@@QAE_NABV12@@Z PROC		; Ogre::BoxBound::isBoxBoundIn, COMDAT
; _this$ = ecx

; 181  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 182  : 			if( box.m_MaxPos.x > m_MaxPos.x ||
; 183  : 				box.m_MinPos.x < m_MinPos.x )

	mov	eax, DWORD PTR _box$[ebp]
	fld	DWORD PTR [eax+12]
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+12]
	fcompp
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $LN5@isBoxBound
	mov	edx, DWORD PTR _box$[ebp]
	fld	DWORD PTR [edx]
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN6@isBoxBound
$LN5@isBoxBound:

; 184  : 				return false;

	xor	al, al
	jmp	SHORT $LN7@isBoxBound
$LN6@isBoxBound:

; 185  : 			if( box.m_MaxPos.y > m_MaxPos.y ||
; 186  : 				box.m_MinPos.y < m_MinPos.y )

	mov	ecx, DWORD PTR _box$[ebp]
	fld	DWORD PTR [ecx+16]
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+16]
	fcompp
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $LN3@isBoxBound
	mov	eax, DWORD PTR _box$[ebp]
	fld	DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+4]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN4@isBoxBound
$LN3@isBoxBound:

; 187  : 				return false;

	xor	al, al
	jmp	SHORT $LN7@isBoxBound
$LN4@isBoxBound:

; 188  : 			if( box.m_MaxPos.z > m_MaxPos.z ||
; 189  : 				box.m_MinPos.z < m_MinPos.z )

	mov	edx, DWORD PTR _box$[ebp]
	fld	DWORD PTR [edx+20]
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+20]
	fcompp
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $LN1@isBoxBound
	mov	ecx, DWORD PTR _box$[ebp]
	fld	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+8]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN2@isBoxBound
$LN1@isBoxBound:

; 190  : 				return false;

	xor	al, al
	jmp	SHORT $LN7@isBoxBound
$LN2@isBoxBound:

; 191  : 
; 192  : 			return true;

	mov	al, 1
$LN7@isBoxBound:

; 193  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?isBoxBoundIn@BoxBound@Ogre@@QAE_NABV12@@Z ENDP		; Ogre::BoxBound::isBoxBoundIn
_TEXT	ENDS
PUBLIC	?Abs@Ogre@@YA?AVVector3@1@ABV21@@Z		; Ogre::Abs
PUBLIC	?isBoxBoundOut@BoxBound@Ogre@@QBE_NABV12@@Z	; Ogre::BoxBound::isBoxBoundOut
; Function compile flags: /Odtp
;	COMDAT ?isBoxBoundOut@BoxBound@Ogre@@QBE_NABV12@@Z
_TEXT	SEGMENT
_this$ = -88						; size = 4
$T93408 = -84						; size = 12
$T93407 = -72						; size = 12
$T93406 = -60						; size = 12
$T93405 = -48						; size = 12
$T93404 = -36						; size = 12
_vRadius$ = -24						; size = 12
_vDis$ = -12						; size = 12
_box$ = 8						; size = 4
?isBoxBoundOut@BoxBound@Ogre@@QBE_NABV12@@Z PROC	; Ogre::BoxBound::isBoxBoundOut, COMDAT
; _this$ = ecx

; 197  : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 88					; 00000058H
	mov	DWORD PTR _this$[ebp], ecx

; 198  : 			Vector3 vDis = Abs(box.getCenter() - getCenter());

	lea	eax, DWORD PTR $T93404[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getCenter@BoxBound@Ogre@@QBE?AVVector3@2@XZ ; Ogre::BoxBound::getCenter
	push	eax
	lea	ecx, DWORD PTR $T93405[ebp]
	push	ecx
	mov	ecx, DWORD PTR _box$[ebp]
	call	?getCenter@BoxBound@Ogre@@QBE?AVVector3@2@XZ ; Ogre::BoxBound::getCenter
	push	eax
	lea	edx, DWORD PTR $T93406[ebp]
	push	edx
	call	??GOgre@@YA?AVVector3@0@ABV10@0@Z	; Ogre::operator-
	add	esp, 12					; 0000000cH
	push	eax
	lea	eax, DWORD PTR _vDis$[ebp]
	push	eax
	call	?Abs@Ogre@@YA?AVVector3@1@ABV21@@Z	; Ogre::Abs
	add	esp, 8

; 199  : 			Vector3 vRadius = box.getExtension() + getExtension();

	lea	ecx, DWORD PTR $T93407[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getExtension@BoxBound@Ogre@@QBE?AVVector3@2@XZ ; Ogre::BoxBound::getExtension
	push	eax
	lea	edx, DWORD PTR $T93408[ebp]
	push	edx
	mov	ecx, DWORD PTR _box$[ebp]
	call	?getExtension@BoxBound@Ogre@@QBE?AVVector3@2@XZ ; Ogre::BoxBound::getExtension
	push	eax
	lea	eax, DWORD PTR _vRadius$[ebp]
	push	eax
	call	??HOgre@@YA?AVVector3@0@ABV10@0@Z	; Ogre::operator+
	add	esp, 12					; 0000000cH

; 200  : 
; 201  : 			if( vDis.x > vRadius.x || vDis.y > vRadius.y || vDis.z > vRadius.z )

	fld	DWORD PTR _vDis$[ebp]
	fld	DWORD PTR _vRadius$[ebp]
	fcompp
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $LN1@isBoxBound@2
	fld	DWORD PTR _vDis$[ebp+4]
	fld	DWORD PTR _vRadius$[ebp+4]
	fcompp
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $LN1@isBoxBound@2
	fld	DWORD PTR _vDis$[ebp+8]
	fld	DWORD PTR _vRadius$[ebp+8]
	fcompp
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN2@isBoxBound@2
$LN1@isBoxBound@2:

; 202  : 				return true;

	mov	al, 1
	jmp	SHORT $LN3@isBoxBound@2
$LN2@isBoxBound@2:

; 203  : 
; 204  : 			return false;

	xor	al, al
$LN3@isBoxBound@2:

; 205  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?isBoxBoundOut@BoxBound@Ogre@@QBE_NABV12@@Z ENDP	; Ogre::BoxBound::isBoxBoundOut
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogrevector3.h
_TEXT	ENDS
;	COMDAT ?Abs@Ogre@@YA?AVVector3@1@ABV21@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_v$ = 12						; size = 4
?Abs@Ogre@@YA?AVVector3@1@ABV21@@Z PROC			; Ogre::Abs, COMDAT

; 204  : 	{

	push	ebp
	mov	ebp, esp

; 205  : 		return Vector3( Abs(v.x), Abs(v.y), Abs(v.z) );

	mov	eax, DWORD PTR _v$[ebp]
	add	eax, 8
	push	eax
	call	??$Abs@M@Ogre@@YAMABM@Z			; Ogre::Abs<float>
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _v$[ebp]
	add	ecx, 4
	push	ecx
	call	??$Abs@M@Ogre@@YAMABM@Z			; Ogre::Abs<float>
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _v$[ebp]
	push	edx
	call	??$Abs@M@Ogre@@YAMABM@Z			; Ogre::Abs<float>
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector3@Ogre@@QAE@MMM@Z		; Ogre::Vector3::Vector3
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 206  : 	}

	pop	ebp
	ret	0
?Abs@Ogre@@YA?AVVector3@1@ABV21@@Z ENDP			; Ogre::Abs
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??4BoxBound@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4BoxBound@Ogre@@QAEAAV01@ABV01@@Z PROC		; Ogre::BoxBound::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4Vector3@Ogre@@QAEABV01@ABV01@@Z	; Ogre::Vector3::operator=
	mov	ecx, DWORD PTR ___that$[ebp]
	add	ecx, 12					; 0000000cH
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??4Vector3@Ogre@@QAEABV01@ABV01@@Z	; Ogre::Vector3::operator=
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	cl, BYTE PTR [eax+24]
	mov	BYTE PTR [edx+24], cl
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4BoxBound@Ogre@@QAEAAV01@ABV01@@Z ENDP		; Ogre::BoxBound::operator=
_TEXT	ENDS
PUBLIC	??0SphereBound@Ogre@@QAE@XZ			; Ogre::SphereBound::SphereBound
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogrebounding.h
;	COMDAT ??0SphereBound@Ogre@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0SphereBound@Ogre@@QAE@XZ PROC			; Ogre::SphereBound::SphereBound, COMDAT
; _this$ = ecx

; 221  : 		SphereBound(){}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0Vector3@Ogre@@QAE@XZ			; Ogre::Vector3::Vector3
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0SphereBound@Ogre@@QAE@XZ ENDP			; Ogre::SphereBound::SphereBound
_TEXT	ENDS
PUBLIC	?getCenter@SphereBound@Ogre@@QBEABVVector3@2@XZ	; Ogre::SphereBound::getCenter
; Function compile flags: /Odtp
;	COMDAT ?getCenter@SphereBound@Ogre@@QBEABVVector3@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getCenter@SphereBound@Ogre@@QBEABVVector3@2@XZ PROC	; Ogre::SphereBound::getCenter, COMDAT
; _this$ = ecx

; 229  : 		const Vector3 &getCenter() const{ return m_Center; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
?getCenter@SphereBound@Ogre@@QBEABVVector3@2@XZ ENDP	; Ogre::SphereBound::getCenter
_TEXT	ENDS
PUBLIC	?getRadius@SphereBound@Ogre@@QBEMXZ		; Ogre::SphereBound::getRadius
; Function compile flags: /Odtp
;	COMDAT ?getRadius@SphereBound@Ogre@@QBEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getRadius@SphereBound@Ogre@@QBEMXZ PROC		; Ogre::SphereBound::getRadius, COMDAT
; _this$ = ecx

; 230  : 		float   getRadius() const{ return m_Radius; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+12]
	mov	esp, ebp
	pop	ebp
	ret	0
?getRadius@SphereBound@Ogre@@QBEMXZ ENDP		; Ogre::SphereBound::getRadius
_TEXT	ENDS
PUBLIC	?isPointIn@SphereBound@Ogre@@QBE_NABVVector3@2@@Z ; Ogre::SphereBound::isPointIn
; Function compile flags: /Odtp
;	COMDAT ?isPointIn@SphereBound@Ogre@@QBE_NABVVector3@2@@Z
_TEXT	SEGMENT
tv79 = -24						; size = 4
tv89 = -20						; size = 4
_this$ = -16						; size = 4
$T93421 = -12						; size = 12
_vPos$ = 8						; size = 4
?isPointIn@SphereBound@Ogre@@QBE_NABVVector3@2@@Z PROC	; Ogre::SphereBound::isPointIn, COMDAT
; _this$ = ecx

; 233  : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 234  : 			return ( (vPos - m_Center).lengthSqr() < m_Radius * m_Radius );

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vPos$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T93421[ebp]
	push	edx
	call	??GOgre@@YA?AVVector3@0@ABV10@0@Z	; Ogre::operator-
	add	esp, 12					; 0000000cH
	mov	ecx, eax
	call	?lengthSqr@Vector3@Ogre@@QBEMXZ		; Ogre::Vector3::lengthSqr
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+12]
	mov	ecx, DWORD PTR _this$[ebp]
	fmul	DWORD PTR [ecx+12]
	fstp	DWORD PTR tv89[ebp]
	fld	DWORD PTR tv89[ebp]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN3@isPointIn@2
	mov	DWORD PTR tv79[ebp], 1
	jmp	SHORT $LN4@isPointIn@2
$LN3@isPointIn@2:
	mov	DWORD PTR tv79[ebp], 0
$LN4@isPointIn@2:
	mov	al, BYTE PTR tv79[ebp]

; 235  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?isPointIn@SphereBound@Ogre@@QBE_NABVVector3@2@@Z ENDP	; Ogre::SphereBound::isPointIn
_TEXT	ENDS
PUBLIC	??0SphereBound@Ogre@@QAE@ABV01@@Z		; Ogre::SphereBound::SphereBound
; Function compile flags: /Odtp
;	COMDAT ??0SphereBound@Ogre@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0SphereBound@Ogre@@QAE@ABV01@@Z PROC			; Ogre::SphereBound::SphereBound, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0Vector3@Ogre@@QAE@ABV01@@Z		; Ogre::Vector3::Vector3
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	fld	DWORD PTR [edx+12]
	fstp	DWORD PTR [ecx+12]
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0SphereBound@Ogre@@QAE@ABV01@@Z ENDP			; Ogre::SphereBound::SphereBound
_TEXT	ENDS
PUBLIC	??4SphereBound@Ogre@@QAEAAV01@ABV01@@Z		; Ogre::SphereBound::operator=
; Function compile flags: /Odtp
;	COMDAT ??4SphereBound@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4SphereBound@Ogre@@QAEAAV01@ABV01@@Z PROC		; Ogre::SphereBound::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4Vector3@Ogre@@QAEABV01@ABV01@@Z	; Ogre::Vector3::operator=
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	fld	DWORD PTR [edx+12]
	fstp	DWORD PTR [ecx+12]
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4SphereBound@Ogre@@QAEAAV01@ABV01@@Z ENDP		; Ogre::SphereBound::operator=
_TEXT	ENDS
PUBLIC	??0BoxSphereBound@Ogre@@QAE@XZ			; Ogre::BoxSphereBound::BoxSphereBound
; Function compile flags: /Odtp
;	COMDAT ??0BoxSphereBound@Ogre@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0BoxSphereBound@Ogre@@QAE@XZ PROC			; Ogre::BoxSphereBound::BoxSphereBound, COMDAT
; _this$ = ecx

; 252  : 		BoxSphereBound()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0Vector3@Ogre@@QAE@XZ			; Ogre::Vector3::Vector3
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??0Vector3@Ogre@@QAE@XZ			; Ogre::Vector3::Vector3

; 253  : 		{
; 254  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0BoxSphereBound@Ogre@@QAE@XZ ENDP			; Ogre::BoxSphereBound::BoxSphereBound
_TEXT	ENDS
PUBLIC	?fromBoxBound@BoxSphereBound@Ogre@@QAEXABVBoxBound@2@@Z ; Ogre::BoxSphereBound::fromBoxBound
PUBLIC	??0BoxSphereBound@Ogre@@QAE@ABVBoxBound@1@@Z	; Ogre::BoxSphereBound::BoxSphereBound
; Function compile flags: /Odtp
;	COMDAT ??0BoxSphereBound@Ogre@@QAE@ABVBoxBound@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_box$ = 8						; size = 4
??0BoxSphereBound@Ogre@@QAE@ABVBoxBound@1@@Z PROC	; Ogre::BoxSphereBound::BoxSphereBound, COMDAT
; _this$ = ecx

; 256  : 		BoxSphereBound(const BoxBound &box)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0Vector3@Ogre@@QAE@XZ			; Ogre::Vector3::Vector3
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??0Vector3@Ogre@@QAE@XZ			; Ogre::Vector3::Vector3

; 257  : 		{
; 258  : 			fromBoxBound(box);

	mov	eax, DWORD PTR _box$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?fromBoxBound@BoxSphereBound@Ogre@@QAEXABVBoxBound@2@@Z ; Ogre::BoxSphereBound::fromBoxBound

; 259  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0BoxSphereBound@Ogre@@QAE@ABVBoxBound@1@@Z ENDP	; Ogre::BoxSphereBound::BoxSphereBound
_TEXT	ENDS
PUBLIC	?reset@BoxSphereBound@Ogre@@QAEXXZ		; Ogre::BoxSphereBound::reset
; Function compile flags: /Odtp
;	COMDAT ?reset@BoxSphereBound@Ogre@@QAEXXZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
$T93434 = -12						; size = 12
?reset@BoxSphereBound@Ogre@@QAEXXZ PROC			; Ogre::BoxSphereBound::reset, COMDAT
; _this$ = ecx

; 262  : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 263  : 			m_Center = m_Extent = Vector3(0,0,0);

	push	ecx
	fldz
	fstp	DWORD PTR [esp]
	push	ecx
	fldz
	fstp	DWORD PTR [esp]
	push	ecx
	fldz
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR $T93434[ebp]
	call	??0Vector3@Ogre@@QAE@MMM@Z		; Ogre::Vector3::Vector3
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??4Vector3@Ogre@@QAEABV01@ABV01@@Z	; Ogre::Vector3::operator=
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4Vector3@Ogre@@QAEABV01@ABV01@@Z	; Ogre::Vector3::operator=

; 264  : 			m_Radius = 0;

	mov	eax, DWORD PTR _this$[ebp]
	fldz
	fstp	DWORD PTR [eax+24]

; 265  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?reset@BoxSphereBound@Ogre@@QAEXXZ ENDP			; Ogre::BoxSphereBound::reset
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?fromBoxBound@BoxSphereBound@Ogre@@QAEXABVBoxBound@2@@Z
_TEXT	SEGMENT
_this$ = -28						; size = 4
$T93438 = -24						; size = 12
$T93437 = -12						; size = 12
_box$ = 8						; size = 4
?fromBoxBound@BoxSphereBound@Ogre@@QAEXABVBoxBound@2@@Z PROC ; Ogre::BoxSphereBound::fromBoxBound, COMDAT
; _this$ = ecx

; 268  : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	DWORD PTR _this$[ebp], ecx

; 269  : 			m_Center = box.getCenter();

	lea	eax, DWORD PTR $T93437[ebp]
	push	eax
	mov	ecx, DWORD PTR _box$[ebp]
	call	?getCenter@BoxBound@Ogre@@QBE?AVVector3@2@XZ ; Ogre::BoxBound::getCenter
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4Vector3@Ogre@@QAEABV01@ABV01@@Z	; Ogre::Vector3::operator=

; 270  : 			m_Extent = box.getExtension();

	lea	ecx, DWORD PTR $T93438[ebp]
	push	ecx
	mov	ecx, DWORD PTR _box$[ebp]
	call	?getExtension@BoxBound@Ogre@@QBE?AVVector3@2@XZ ; Ogre::BoxBound::getExtension
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??4Vector3@Ogre@@QAEABV01@ABV01@@Z	; Ogre::Vector3::operator=

; 271  : 
; 272  : 			m_Radius = m_Extent.length();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	?length@Vector3@Ogre@@QBEMXZ		; Ogre::Vector3::length
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+24]

; 273  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?fromBoxBound@BoxSphereBound@Ogre@@QAEXABVBoxBound@2@@Z ENDP ; Ogre::BoxSphereBound::fromBoxBound
_TEXT	ENDS
PUBLIC	?getSphere@BoxSphereBound@Ogre@@QBE?AVSphereBound@2@XZ ; Ogre::BoxSphereBound::getSphere
; Function compile flags: /Odtp
;	COMDAT ?getSphere@BoxSphereBound@Ogre@@QBE?AVSphereBound@2@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
_sphere$ = -16						; size = 16
___$ReturnUdt$ = 8					; size = 4
?getSphere@BoxSphereBound@Ogre@@QBE?AVSphereBound@2@XZ PROC ; Ogre::BoxSphereBound::getSphere, COMDAT
; _this$ = ecx

; 276  : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 277  : 			SphereBound sphere;

	lea	ecx, DWORD PTR _sphere$[ebp]
	call	??0SphereBound@Ogre@@QAE@XZ		; Ogre::SphereBound::SphereBound

; 278  : 			sphere.m_Center = m_Center;

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	lea	ecx, DWORD PTR _sphere$[ebp]
	call	??4Vector3@Ogre@@QAEABV01@ABV01@@Z	; Ogre::Vector3::operator=

; 279  : 			sphere.m_Radius = m_Radius;

	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+24]
	fstp	DWORD PTR _sphere$[ebp+12]

; 280  : 			return sphere;

	lea	edx, DWORD PTR _sphere$[ebp]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0SphereBound@Ogre@@QAE@ABV01@@Z
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 281  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?getSphere@BoxSphereBound@Ogre@@QBE?AVSphereBound@2@XZ ENDP ; Ogre::BoxSphereBound::getSphere
_TEXT	ENDS
PUBLIC	?getBox@BoxSphereBound@Ogre@@QBE?AVBoxBound@2@XZ ; Ogre::BoxSphereBound::getBox
; Function compile flags: /Odtp
;	COMDAT ?getBox@BoxSphereBound@Ogre@@QBE?AVBoxBound@2@XZ
_TEXT	SEGMENT
_this$ = -56						; size = 4
$T93444 = -52						; size = 12
$T93443 = -40						; size = 12
_box$ = -28						; size = 28
___$ReturnUdt$ = 8					; size = 4
?getBox@BoxSphereBound@Ogre@@QBE?AVBoxBound@2@XZ PROC	; Ogre::BoxSphereBound::getBox, COMDAT
; _this$ = ecx

; 284  : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 56					; 00000038H
	mov	DWORD PTR _this$[ebp], ecx

; 285  : 			BoxBound box;

	lea	ecx, DWORD PTR _box$[ebp]
	call	??0BoxBound@Ogre@@QAE@XZ		; Ogre::BoxBound::BoxBound

; 286  : 			box.m_MinPos = m_Center - m_Extent;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 12					; 0000000cH
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T93443[ebp]
	push	edx
	call	??GOgre@@YA?AVVector3@0@ABV10@0@Z	; Ogre::operator-
	add	esp, 12					; 0000000cH
	push	eax
	lea	ecx, DWORD PTR _box$[ebp]
	call	??4Vector3@Ogre@@QAEABV01@ABV01@@Z	; Ogre::Vector3::operator=

; 287  : 			box.m_MaxPos = m_Center + m_Extent;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 12					; 0000000cH
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T93444[ebp]
	push	edx
	call	??HOgre@@YA?AVVector3@0@ABV10@0@Z	; Ogre::operator+
	add	esp, 12					; 0000000cH
	push	eax
	lea	ecx, DWORD PTR _box$[ebp+12]
	call	??4Vector3@Ogre@@QAEABV01@ABV01@@Z	; Ogre::Vector3::operator=

; 288  : 			box.m_isValid = true;

	mov	BYTE PTR _box$[ebp+24], 1

; 289  : 			return box;

	lea	eax, DWORD PTR _box$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0BoxBound@Ogre@@QAE@ABV01@@Z		; Ogre::BoxBound::BoxBound
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 290  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?getBox@BoxSphereBound@Ogre@@QBE?AVBoxBound@2@XZ ENDP	; Ogre::BoxSphereBound::getBox
_TEXT	ENDS
PUBLIC	?getMin@BoxSphereBound@Ogre@@QBE?AVVector3@2@XZ	; Ogre::BoxSphereBound::getMin
; Function compile flags: /Odtp
;	COMDAT ?getMin@BoxSphereBound@Ogre@@QBE?AVVector3@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?getMin@BoxSphereBound@Ogre@@QBE?AVVector3@2@XZ PROC	; Ogre::BoxSphereBound::getMin, COMDAT
; _this$ = ecx

; 310  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 311  : 			return m_Center-m_Extent;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 12					; 0000000cH
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	push	edx
	call	??GOgre@@YA?AVVector3@0@ABV10@0@Z	; Ogre::operator-
	add	esp, 12					; 0000000cH
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 312  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?getMin@BoxSphereBound@Ogre@@QBE?AVVector3@2@XZ ENDP	; Ogre::BoxSphereBound::getMin
_TEXT	ENDS
PUBLIC	?getMax@BoxSphereBound@Ogre@@QBE?AVVector3@2@XZ	; Ogre::BoxSphereBound::getMax
; Function compile flags: /Odtp
;	COMDAT ?getMax@BoxSphereBound@Ogre@@QBE?AVVector3@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?getMax@BoxSphereBound@Ogre@@QBE?AVVector3@2@XZ PROC	; Ogre::BoxSphereBound::getMax, COMDAT
; _this$ = ecx

; 315  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 316  : 			return m_Center+m_Extent;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 12					; 0000000cH
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	push	edx
	call	??HOgre@@YA?AVVector3@0@ABV10@0@Z	; Ogre::operator+
	add	esp, 12					; 0000000cH
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 317  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?getMax@BoxSphereBound@Ogre@@QBE?AVVector3@2@XZ ENDP	; Ogre::BoxSphereBound::getMax
_TEXT	ENDS
PUBLIC	?getCenter@BoxSphereBound@Ogre@@QBEABVVector3@2@XZ ; Ogre::BoxSphereBound::getCenter
; Function compile flags: /Odtp
;	COMDAT ?getCenter@BoxSphereBound@Ogre@@QBEABVVector3@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getCenter@BoxSphereBound@Ogre@@QBEABVVector3@2@XZ PROC	; Ogre::BoxSphereBound::getCenter, COMDAT
; _this$ = ecx

; 320  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 321  : 			return m_Center;

	mov	eax, DWORD PTR _this$[ebp]

; 322  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?getCenter@BoxSphereBound@Ogre@@QBEABVVector3@2@XZ ENDP	; Ogre::BoxSphereBound::getCenter
_TEXT	ENDS
PUBLIC	?getExtension@BoxSphereBound@Ogre@@QBEABVVector3@2@XZ ; Ogre::BoxSphereBound::getExtension
; Function compile flags: /Odtp
;	COMDAT ?getExtension@BoxSphereBound@Ogre@@QBEABVVector3@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getExtension@BoxSphereBound@Ogre@@QBEABVVector3@2@XZ PROC ; Ogre::BoxSphereBound::getExtension, COMDAT
; _this$ = ecx

; 325  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 326  : 			return m_Extent;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 12					; 0000000cH

; 327  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?getExtension@BoxSphereBound@Ogre@@QBEABVVector3@2@XZ ENDP ; Ogre::BoxSphereBound::getExtension
_TEXT	ENDS
PUBLIC	??KOgre@@YA?AVVector3@0@ABV10@M@Z		; Ogre::operator/
PUBLIC	__real@40000000
PUBLIC	?fromBox@BoxSphereBound@Ogre@@QAEXABVVector3@2@0@Z ; Ogre::BoxSphereBound::fromBox
;	COMDAT __real@40000000
CONST	SEGMENT
__real@40000000 DD 040000000r			; 2
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ?fromBox@BoxSphereBound@Ogre@@QAEXABVVector3@2@0@Z
_TEXT	SEGMENT
_this$ = -52						; size = 4
$T93458 = -48						; size = 12
$T93457 = -36						; size = 12
$T93456 = -24						; size = 12
$T93455 = -12						; size = 12
_minpt$ = 8						; size = 4
_maxpt$ = 12						; size = 4
?fromBox@BoxSphereBound@Ogre@@QAEXABVVector3@2@0@Z PROC	; Ogre::BoxSphereBound::fromBox, COMDAT
; _this$ = ecx

; 330  : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H
	mov	DWORD PTR _this$[ebp], ecx

; 331  : 			m_Center = (minpt + maxpt)/2.0f;

	push	ecx
	fld	DWORD PTR __real@40000000
	fstp	DWORD PTR [esp]
	mov	eax, DWORD PTR _maxpt$[ebp]
	push	eax
	mov	ecx, DWORD PTR _minpt$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T93455[ebp]
	push	edx
	call	??HOgre@@YA?AVVector3@0@ABV10@0@Z	; Ogre::operator+
	add	esp, 12					; 0000000cH
	push	eax
	lea	eax, DWORD PTR $T93456[ebp]
	push	eax
	call	??KOgre@@YA?AVVector3@0@ABV10@M@Z	; Ogre::operator/
	add	esp, 12					; 0000000cH
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4Vector3@Ogre@@QAEABV01@ABV01@@Z	; Ogre::Vector3::operator=

; 332  : 			m_Extent = (maxpt - minpt)/2.0f;

	push	ecx
	fld	DWORD PTR __real@40000000
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _minpt$[ebp]
	push	ecx
	mov	edx, DWORD PTR _maxpt$[ebp]
	push	edx
	lea	eax, DWORD PTR $T93457[ebp]
	push	eax
	call	??GOgre@@YA?AVVector3@0@ABV10@0@Z	; Ogre::operator-
	add	esp, 12					; 0000000cH
	push	eax
	lea	ecx, DWORD PTR $T93458[ebp]
	push	ecx
	call	??KOgre@@YA?AVVector3@0@ABV10@M@Z	; Ogre::operator/
	add	esp, 12					; 0000000cH
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??4Vector3@Ogre@@QAEABV01@ABV01@@Z	; Ogre::Vector3::operator=

; 333  : 			m_Radius = m_Extent.length();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	?length@Vector3@Ogre@@QBEMXZ		; Ogre::Vector3::length
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+24]

; 334  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?fromBox@BoxSphereBound@Ogre@@QAEXABVVector3@2@0@Z ENDP	; Ogre::BoxSphereBound::fromBox
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogrevector3.h
_TEXT	ENDS
;	COMDAT ??KOgre@@YA?AVVector3@0@ABV10@M@Z
_TEXT	SEGMENT
tv87 = -12						; size = 4
tv85 = -8						; size = 4
tv83 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_v1$ = 12						; size = 4
_s$ = 16						; size = 4
??KOgre@@YA?AVVector3@0@ABV10@M@Z PROC			; Ogre::operator/, COMDAT

; 199  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 200  : 		return Vector3(v1.x/s, v1.y/s, v1.z/s);

	mov	eax, DWORD PTR _v1$[ebp]
	fld	DWORD PTR [eax+8]
	fdiv	DWORD PTR _s$[ebp]
	fstp	DWORD PTR tv83[ebp]
	fld	DWORD PTR tv83[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _v1$[ebp]
	fld	DWORD PTR [ecx+4]
	fdiv	DWORD PTR _s$[ebp]
	fstp	DWORD PTR tv85[ebp]
	fld	DWORD PTR tv85[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _v1$[ebp]
	fld	DWORD PTR [edx]
	fdiv	DWORD PTR _s$[ebp]
	fstp	DWORD PTR tv87[ebp]
	fld	DWORD PTR tv87[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector3@Ogre@@QAE@MMM@Z		; Ogre::Vector3::Vector3
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 201  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??KOgre@@YA?AVVector3@0@ABV10@M@Z ENDP			; Ogre::operator/
_TEXT	ENDS
PUBLIC	?intersect@BoxSphereBound@Ogre@@QBE_NABV12@@Z	; Ogre::BoxSphereBound::intersect
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogrebounding.h
;	COMDAT ?intersect@BoxSphereBound@Ogre@@QBE_NABV12@@Z
_TEXT	SEGMENT
_this$ = -60						; size = 4
_box1$ = -56						; size = 28
_box2$ = -28						; size = 28
_other$ = 8						; size = 4
?intersect@BoxSphereBound@Ogre@@QBE_NABV12@@Z PROC	; Ogre::BoxSphereBound::intersect, COMDAT
; _this$ = ecx

; 337  : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 60					; 0000003cH
	mov	DWORD PTR _this$[ebp], ecx

; 338  : 			BoxBound box1 = getBox();

	lea	eax, DWORD PTR _box1$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getBox@BoxSphereBound@Ogre@@QBE?AVBoxBound@2@XZ ; Ogre::BoxSphereBound::getBox

; 339  : 			BoxBound box2 = other.getBox();

	lea	ecx, DWORD PTR _box2$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _other$[ebp]
	call	?getBox@BoxSphereBound@Ogre@@QBE?AVBoxBound@2@XZ ; Ogre::BoxSphereBound::getBox

; 340  : 			return box1.intersectBoxBound(box2);

	lea	edx, DWORD PTR _box2$[ebp]
	push	edx
	lea	ecx, DWORD PTR _box1$[ebp]
	call	?intersectBoxBound@BoxBound@Ogre@@QBE_NABV12@@Z ; Ogre::BoxBound::intersectBoxBound

; 341  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?intersect@BoxSphereBound@Ogre@@QBE_NABV12@@Z ENDP	; Ogre::BoxSphereBound::intersect
_TEXT	ENDS
PUBLIC	??0BoxSphereBound@Ogre@@QAE@ABV01@@Z		; Ogre::BoxSphereBound::BoxSphereBound
; Function compile flags: /Odtp
;	COMDAT ??0BoxSphereBound@Ogre@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0BoxSphereBound@Ogre@@QAE@ABV01@@Z PROC		; Ogre::BoxSphereBound::BoxSphereBound, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0Vector3@Ogre@@QAE@ABV01@@Z		; Ogre::Vector3::Vector3
	mov	ecx, DWORD PTR ___that$[ebp]
	add	ecx, 12					; 0000000cH
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??0Vector3@Ogre@@QAE@ABV01@@Z		; Ogre::Vector3::Vector3
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	fld	DWORD PTR [eax+24]
	fstp	DWORD PTR [edx+24]
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0BoxSphereBound@Ogre@@QAE@ABV01@@Z ENDP		; Ogre::BoxSphereBound::BoxSphereBound
_TEXT	ENDS
PUBLIC	??4BoxSphereBound@Ogre@@QAEAAV01@ABV01@@Z	; Ogre::BoxSphereBound::operator=
; Function compile flags: /Odtp
;	COMDAT ??4BoxSphereBound@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4BoxSphereBound@Ogre@@QAEAAV01@ABV01@@Z PROC		; Ogre::BoxSphereBound::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4Vector3@Ogre@@QAEABV01@ABV01@@Z	; Ogre::Vector3::operator=
	mov	ecx, DWORD PTR ___that$[ebp]
	add	ecx, 12					; 0000000cH
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??4Vector3@Ogre@@QAEABV01@ABV01@@Z	; Ogre::Vector3::operator=
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	fld	DWORD PTR [eax+24]
	fstp	DWORD PTR [edx+24]
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4BoxSphereBound@Ogre@@QAEAAV01@ABV01@@Z ENDP		; Ogre::BoxSphereBound::operator=
_TEXT	ENDS
PUBLIC	?getRTTI@MovableObject@Ogre@@UBEPBVRuntimeClass@2@XZ ; Ogre::MovableObject::getRTTI
EXTRN	?m_RTTI@MovableObject@Ogre@@2VRuntimeClass@2@B:BYTE ; Ogre::MovableObject::m_RTTI
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogremovableobject.h
;	COMDAT ?getRTTI@MovableObject@Ogre@@UBEPBVRuntimeClass@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getRTTI@MovableObject@Ogre@@UBEPBVRuntimeClass@2@XZ PROC ; Ogre::MovableObject::getRTTI, COMDAT
; _this$ = ecx

; 16   : 		DECLARE_RTTI_VIRTUAL(MovableObject)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, OFFSET ?m_RTTI@MovableObject@Ogre@@2VRuntimeClass@2@B ; Ogre::MovableObject::m_RTTI
	mov	esp, ebp
	pop	ebp
	ret	0
?getRTTI@MovableObject@Ogre@@UBEPBVRuntimeClass@2@XZ ENDP ; Ogre::MovableObject::getRTTI
_TEXT	ENDS
PUBLIC	?enableUVMask@MovableObject@Ogre@@UAEX_N0@Z	; Ogre::MovableObject::enableUVMask
; Function compile flags: /Odtp
;	COMDAT ?enableUVMask@MovableObject@Ogre@@UAEX_N0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_enable$ = 8						; size = 1
_stdmtlUse$ = 12					; size = 1
?enableUVMask@MovableObject@Ogre@@UAEX_N0@Z PROC	; Ogre::MovableObject::enableUVMask, COMDAT
; _this$ = ecx

; 23   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 24   : 
; 25   : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?enableUVMask@MovableObject@Ogre@@UAEX_N0@Z ENDP	; Ogre::MovableObject::enableUVMask
_TEXT	ENDS
PUBLIC	?setLiuGuangTexture@MovableObject@Ogre@@UAEXPAVTextureData@2@@Z ; Ogre::MovableObject::setLiuGuangTexture
; Function compile flags: /Odtp
;	COMDAT ?setLiuGuangTexture@MovableObject@Ogre@@UAEXPAVTextureData@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_texture$ = 8						; size = 4
?setLiuGuangTexture@MovableObject@Ogre@@UAEXPAVTextureData@2@@Z PROC ; Ogre::MovableObject::setLiuGuangTexture, COMDAT
; _this$ = ecx

; 28   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 29   : 
; 30   : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?setLiuGuangTexture@MovableObject@Ogre@@UAEXPAVTextureData@2@@Z ENDP ; Ogre::MovableObject::setLiuGuangTexture
_TEXT	ENDS
PUBLIC	?setLiuGuangTexture@MovableObject@Ogre@@UAEXPBD@Z ; Ogre::MovableObject::setLiuGuangTexture
; Function compile flags: /Odtp
;	COMDAT ?setLiuGuangTexture@MovableObject@Ogre@@UAEXPBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_filename$ = 8						; size = 4
?setLiuGuangTexture@MovableObject@Ogre@@UAEXPBD@Z PROC	; Ogre::MovableObject::setLiuGuangTexture, COMDAT
; _this$ = ecx

; 33   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 34   : 
; 35   : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?setLiuGuangTexture@MovableObject@Ogre@@UAEXPBD@Z ENDP	; Ogre::MovableObject::setLiuGuangTexture
_TEXT	ENDS
PUBLIC	?SetForceShadowMapCull@MovableObject@Ogre@@UAEX_N@Z ; Ogre::MovableObject::SetForceShadowMapCull
; Function compile flags: /Odtp
;	COMDAT ?SetForceShadowMapCull@MovableObject@Ogre@@UAEX_N@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_cull$ = 8						; size = 1
?SetForceShadowMapCull@MovableObject@Ogre@@UAEX_N@Z PROC ; Ogre::MovableObject::SetForceShadowMapCull, COMDAT
; _this$ = ecx

; 39   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 40   : 			m_bForceShadowMapCull = cull;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR _cull$[ebp]
	mov	BYTE PTR [eax+208], cl

; 41   : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?SetForceShadowMapCull@MovableObject@Ogre@@UAEX_N@Z ENDP ; Ogre::MovableObject::SetForceShadowMapCull
_TEXT	ENDS
PUBLIC	?IsForceShadowMapCull@MovableObject@Ogre@@QAE_NXZ ; Ogre::MovableObject::IsForceShadowMapCull
; Function compile flags: /Odtp
;	COMDAT ?IsForceShadowMapCull@MovableObject@Ogre@@QAE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsForceShadowMapCull@MovableObject@Ogre@@QAE_NXZ PROC	; Ogre::MovableObject::IsForceShadowMapCull, COMDAT
; _this$ = ecx

; 44   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 45   : 			return m_bForceShadowMapCull;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+208]

; 46   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?IsForceShadowMapCull@MovableObject@Ogre@@QAE_NXZ ENDP	; Ogre::MovableObject::IsForceShadowMapCull
_TEXT	ENDS
PUBLIC	?resetUpdate@MovableObject@Ogre@@UAEX_NI@Z	; Ogre::MovableObject::resetUpdate
; Function compile flags: /Odtp
;	COMDAT ?resetUpdate@MovableObject@Ogre@@UAEX_NI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pause$ = 8						; size = 1
_tick$ = 12						; size = 4
?resetUpdate@MovableObject@Ogre@@UAEX_NI@Z PROC		; Ogre::MovableObject::resetUpdate, COMDAT
; _this$ = ecx

; 50   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 51   : 			m_bPause = pause;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR _pause$[ebp]
	mov	BYTE PTR [eax+184], cl

; 52   : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?resetUpdate@MovableObject@Ogre@@UAEX_NI@Z ENDP		; Ogre::MovableObject::resetUpdate
_TEXT	ENDS
PUBLIC	?getWorldMatrix@MovableObject@Ogre@@QAEABVMatrix4@2@XZ ; Ogre::MovableObject::getWorldMatrix
PUBLIC	?getAnchorWorldMatrix@MovableObject@Ogre@@UAE?AVMatrix4@2@H@Z ; Ogre::MovableObject::getAnchorWorldMatrix
EXTRN	??0Matrix4@Ogre@@QAE@ABV01@@Z:PROC		; Ogre::Matrix4::Matrix4
; Function compile flags: /Odtp
;	COMDAT ?getAnchorWorldMatrix@MovableObject@Ogre@@UAE?AVMatrix4@2@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_id$ = 12						; size = 4
?getAnchorWorldMatrix@MovableObject@Ogre@@UAE?AVMatrix4@2@H@Z PROC ; Ogre::MovableObject::getAnchorWorldMatrix, COMDAT
; _this$ = ecx

; 57   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 58   : 			return getWorldMatrix();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?getWorldMatrix@MovableObject@Ogre@@QAEABVMatrix4@2@XZ ; Ogre::MovableObject::getWorldMatrix
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Matrix4@Ogre@@QAE@ABV01@@Z		; Ogre::Matrix4::Matrix4
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 59   : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?getAnchorWorldMatrix@MovableObject@Ogre@@UAE?AVMatrix4@2@H@Z ENDP ; Ogre::MovableObject::getAnchorWorldMatrix
_TEXT	ENDS
PUBLIC	?setPosition@MovableObject@Ogre@@QAEXABVWorldPos@2@@Z ; Ogre::MovableObject::setPosition
; Function compile flags: /Odtp
;	COMDAT ?setPosition@MovableObject@Ogre@@QAEXABVWorldPos@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pos$ = 8						; size = 4
?setPosition@MovableObject@Ogre@@QAEXABVWorldPos@2@@Z PROC ; Ogre::MovableObject::setPosition, COMDAT
; _this$ = ecx

; 65   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 66   : 			m_Position = pos;

	mov	eax, DWORD PTR _pos$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax

; 67   : 			invalidWorldCache();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+68]
	call	eax

; 68   : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?setPosition@MovableObject@Ogre@@QAEXABVWorldPos@2@@Z ENDP ; Ogre::MovableObject::setPosition
_TEXT	ENDS
PUBLIC	?setScale@MovableObject@Ogre@@QAEXABVVector3@2@@Z ; Ogre::MovableObject::setScale
; Function compile flags: /Odtp
;	COMDAT ?setScale@MovableObject@Ogre@@QAEXABVVector3@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_scale$ = 8						; size = 4
?setScale@MovableObject@Ogre@@QAEXABVVector3@2@@Z PROC	; Ogre::MovableObject::setScale, COMDAT
; _this$ = ecx

; 70   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 71   : 			m_Scale = scale;

	mov	eax, DWORD PTR _scale$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??4Vector3@Ogre@@QAEABV01@ABV01@@Z	; Ogre::Vector3::operator=

; 72   : 			invalidWorldCache();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+68]
	call	eax

; 73   : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?setScale@MovableObject@Ogre@@QAEXABVVector3@2@@Z ENDP	; Ogre::MovableObject::setScale
_TEXT	ENDS
PUBLIC	?setRotation@MovableObject@Ogre@@QAEXABVQuaternion@2@@Z ; Ogre::MovableObject::setRotation
; Function compile flags: /Odtp
;	COMDAT ?setRotation@MovableObject@Ogre@@QAEXABVQuaternion@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_rot$ = 8						; size = 4
?setRotation@MovableObject@Ogre@@QAEXABVQuaternion@2@@Z PROC ; Ogre::MovableObject::setRotation, COMDAT
; _this$ = ecx

; 75   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 76   : 			m_Rotation = rot;

	mov	eax, DWORD PTR _rot$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 20					; 00000014H
	call	??4Quaternion@Ogre@@QAEAAV01@ABV01@@Z	; Ogre::Quaternion::operator=

; 77   : 			invalidWorldCache();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+68]
	call	eax

; 78   : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?setRotation@MovableObject@Ogre@@QAEXABVQuaternion@2@@Z ENDP ; Ogre::MovableObject::setRotation
_TEXT	ENDS
PUBLIC	?setRotation@MovableObject@Ogre@@QAEXMMM@Z	; Ogre::MovableObject::setRotation
EXTRN	?setEulerAngle@Quaternion@Ogre@@QAEXMMM@Z:PROC	; Ogre::Quaternion::setEulerAngle
; Function compile flags: /Odtp
;	COMDAT ?setRotation@MovableObject@Ogre@@QAEXMMM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_yaw$ = 8						; size = 4
_pitch$ = 12						; size = 4
_roll$ = 16						; size = 4
?setRotation@MovableObject@Ogre@@QAEXMMM@Z PROC		; Ogre::MovableObject::setRotation, COMDAT
; _this$ = ecx

; 80   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 81   : 			m_Rotation.setEulerAngle(yaw, pitch, roll);

	push	ecx
	fld	DWORD PTR _roll$[ebp]
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR _pitch$[ebp]
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR _yaw$[ebp]
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 20					; 00000014H
	call	?setEulerAngle@Quaternion@Ogre@@QAEXMMM@Z ; Ogre::Quaternion::setEulerAngle

; 82   : 			invalidWorldCache();

	mov	eax, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+68]
	call	eax

; 83   : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?setRotation@MovableObject@Ogre@@QAEXMMM@Z ENDP		; Ogre::MovableObject::setRotation
_TEXT	ENDS
PUBLIC	?getPosition@MovableObject@Ogre@@QBEABVWorldPos@2@XZ ; Ogre::MovableObject::getPosition
; Function compile flags: /Odtp
;	COMDAT ?getPosition@MovableObject@Ogre@@QBEABVWorldPos@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getPosition@MovableObject@Ogre@@QBEABVWorldPos@2@XZ PROC ; Ogre::MovableObject::getPosition, COMDAT
; _this$ = ecx

; 85   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 86   : 			return m_Position;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8

; 87   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?getPosition@MovableObject@Ogre@@QBEABVWorldPos@2@XZ ENDP ; Ogre::MovableObject::getPosition
_TEXT	ENDS
PUBLIC	?getScale@MovableObject@Ogre@@QBEABVVector3@2@XZ ; Ogre::MovableObject::getScale
; Function compile flags: /Odtp
;	COMDAT ?getScale@MovableObject@Ogre@@QBEABVVector3@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getScale@MovableObject@Ogre@@QBEABVVector3@2@XZ PROC	; Ogre::MovableObject::getScale, COMDAT
; _this$ = ecx

; 89   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 90   : 			return m_Scale;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 36					; 00000024H

; 91   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?getScale@MovableObject@Ogre@@QBEABVVector3@2@XZ ENDP	; Ogre::MovableObject::getScale
_TEXT	ENDS
PUBLIC	?getRotation@MovableObject@Ogre@@QBEABVQuaternion@2@XZ ; Ogre::MovableObject::getRotation
; Function compile flags: /Odtp
;	COMDAT ?getRotation@MovableObject@Ogre@@QBEABVQuaternion@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getRotation@MovableObject@Ogre@@QBEABVQuaternion@2@XZ PROC ; Ogre::MovableObject::getRotation, COMDAT
; _this$ = ecx

; 93   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 94   : 			return m_Rotation;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 20					; 00000014H

; 95   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?getRotation@MovableObject@Ogre@@QBEABVQuaternion@2@XZ ENDP ; Ogre::MovableObject::getRotation
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?getWorldMatrix@MovableObject@Ogre@@QAEABVMatrix4@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getWorldMatrix@MovableObject@Ogre@@QAEABVMatrix4@2@XZ PROC ; Ogre::MovableObject::getWorldMatrix, COMDAT
; _this$ = ecx

; 97   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 98   : 			if(m_bWorldCacheInvalid)

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+180]
	test	ecx, ecx
	je	SHORT $LN1@getWorldMa

; 99   : 			{
; 100  : 				updateWorldCache();

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+72]
	call	edx
$LN1@getWorldMa:

; 101  : 			}
; 102  : 
; 103  : 			return m_WorldTM;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 48					; 00000030H

; 104  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?getWorldMatrix@MovableObject@Ogre@@QAEABVMatrix4@2@XZ ENDP ; Ogre::MovableObject::getWorldMatrix
_TEXT	ENDS
PUBLIC	?getWorldPosition@MovableObject@Ogre@@QAE?BVVector3@2@XZ ; Ogre::MovableObject::getWorldPosition
; Function compile flags: /Odtp
;	COMDAT ?getWorldPosition@MovableObject@Ogre@@QAE?BVVector3@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?getWorldPosition@MovableObject@Ogre@@QAE?BVVector3@2@XZ PROC ; Ogre::MovableObject::getWorldPosition, COMDAT
; _this$ = ecx

; 106  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 107  : 			return getWorldMatrix().getTranslate();

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getWorldMatrix@MovableObject@Ogre@@QAEABVMatrix4@2@XZ ; Ogre::MovableObject::getWorldMatrix
	mov	ecx, eax
	call	?getTranslate@Matrix4@Ogre@@QBE?AVVector3@2@XZ ; Ogre::Matrix4::getTranslate
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 108  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?getWorldPosition@MovableObject@Ogre@@QAE?BVVector3@2@XZ ENDP ; Ogre::MovableObject::getWorldPosition
_TEXT	ENDS
PUBLIC	?getWorldBounds@MovableObject@Ogre@@QAEABVBoxSphereBound@2@XZ ; Ogre::MovableObject::getWorldBounds
; Function compile flags: /Odtp
;	COMDAT ?getWorldBounds@MovableObject@Ogre@@QAEABVBoxSphereBound@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getWorldBounds@MovableObject@Ogre@@QAEABVBoxSphereBound@2@XZ PROC ; Ogre::MovableObject::getWorldBounds, COMDAT
; _this$ = ecx

; 110  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 111  : 			if(m_bWorldCacheInvalid)

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+180]
	test	ecx, ecx
	je	SHORT $LN1@getWorldBo

; 112  : 			{
; 113  : 				updateWorldCache();

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+72]
	call	edx
$LN1@getWorldBo:

; 114  : 			}
; 115  : 
; 116  : 			return m_WorldBounds;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 140				; 0000008cH

; 117  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?getWorldBounds@MovableObject@Ogre@@QAEABVBoxSphereBound@2@XZ ENDP ; Ogre::MovableObject::getWorldBounds
_TEXT	ENDS
PUBLIC	?show@MovableObject@Ogre@@QAEX_N@Z		; Ogre::MovableObject::show
; Function compile flags: /Odtp
;	COMDAT ?show@MovableObject@Ogre@@QAEX_N@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_b$ = 8							; size = 1
?show@MovableObject@Ogre@@QAEX_N@Z PROC			; Ogre::MovableObject::show, COMDAT
; _this$ = ecx

; 119  : 		void show(bool b){m_bShow = b;}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR _b$[ebp]
	mov	BYTE PTR [eax+183], cl
	mov	esp, ebp
	pop	ebp
	ret	4
?show@MovableObject@Ogre@@QAEX_N@Z ENDP			; Ogre::MovableObject::show
_TEXT	ENDS
PUBLIC	?isShow@MovableObject@Ogre@@QAE_NXZ		; Ogre::MovableObject::isShow
; Function compile flags: /Odtp
;	COMDAT ?isShow@MovableObject@Ogre@@QAE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?isShow@MovableObject@Ogre@@QAE_NXZ PROC		; Ogre::MovableObject::isShow, COMDAT
; _this$ = ecx

; 120  : 		bool isShow(){return m_bShow;}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+183]
	mov	esp, ebp
	pop	ebp
	ret	0
?isShow@MovableObject@Ogre@@QAE_NXZ ENDP		; Ogre::MovableObject::isShow
_TEXT	ENDS
PUBLIC	?getScene@MovableObject@Ogre@@QAEPAVGameScene@2@XZ ; Ogre::MovableObject::getScene
; Function compile flags: /Odtp
;	COMDAT ?getScene@MovableObject@Ogre@@QAEPAVGameScene@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getScene@MovableObject@Ogre@@QAEPAVGameScene@2@XZ PROC	; Ogre::MovableObject::getScene, COMDAT
; _this$ = ecx

; 123  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 124  : 			return m_pScene;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+192]

; 125  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?getScene@MovableObject@Ogre@@QAEPAVGameScene@2@XZ ENDP	; Ogre::MovableObject::getScene
_TEXT	ENDS
PUBLIC	?getSceneContainer@MovableObject@Ogre@@QAEPAXXZ	; Ogre::MovableObject::getSceneContainer
; Function compile flags: /Odtp
;	COMDAT ?getSceneContainer@MovableObject@Ogre@@QAEPAXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getSceneContainer@MovableObject@Ogre@@QAEPAXXZ PROC	; Ogre::MovableObject::getSceneContainer, COMDAT
; _this$ = ecx

; 128  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 129  : 			return m_pSceneContainer;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+196]

; 130  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?getSceneContainer@MovableObject@Ogre@@QAEPAXXZ ENDP	; Ogre::MovableObject::getSceneContainer
_TEXT	ENDS
PUBLIC	?setScene@MovableObject@Ogre@@QAEXPAVGameScene@2@@Z ; Ogre::MovableObject::setScene
; Function compile flags: /Odtp
;	COMDAT ?setScene@MovableObject@Ogre@@QAEXPAVGameScene@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pscene$ = 8						; size = 4
?setScene@MovableObject@Ogre@@QAEXPAVGameScene@2@@Z PROC ; Ogre::MovableObject::setScene, COMDAT
; _this$ = ecx

; 133  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 134  : 			m_pScene = pscene;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pscene$[ebp]
	mov	DWORD PTR [eax+192], ecx

; 135  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?setScene@MovableObject@Ogre@@QAEXPAVGameScene@2@@Z ENDP ; Ogre::MovableObject::setScene
_TEXT	ENDS
PUBLIC	?setSceneContainer@MovableObject@Ogre@@QAEXPAX@Z ; Ogre::MovableObject::setSceneContainer
; Function compile flags: /Odtp
;	COMDAT ?setSceneContainer@MovableObject@Ogre@@QAEXPAX@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_p$ = 8							; size = 4
?setSceneContainer@MovableObject@Ogre@@QAEXPAX@Z PROC	; Ogre::MovableObject::setSceneContainer, COMDAT
; _this$ = ecx

; 138  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 139  : 			m_pSceneContainer = p;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _p$[ebp]
	mov	DWORD PTR [eax+196], ecx

; 140  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?setSceneContainer@MovableObject@Ogre@@QAEXPAX@Z ENDP	; Ogre::MovableObject::setSceneContainer
_TEXT	ENDS
PUBLIC	?setPickParam@MovableObject@Ogre@@QAEXIPAV12@@Z	; Ogre::MovableObject::setPickParam
; Function compile flags: /Odtp
;	COMDAT ?setPickParam@MovableObject@Ogre@@QAEXIPAV12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_type$ = 8						; size = 4
_pick_owner$ = 12					; size = 4
?setPickParam@MovableObject@Ogre@@QAEXIPAV12@@Z PROC	; Ogre::MovableObject::setPickParam, COMDAT
; _this$ = ecx

; 143  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 144  : 			m_PickType = type;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _type$[ebp]
	mov	DWORD PTR [eax+200], ecx

; 145  : 			m_pPickOwner = pick_owner;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _pick_owner$[ebp]
	mov	DWORD PTR [edx+204], eax

; 146  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?setPickParam@MovableObject@Ogre@@QAEXIPAV12@@Z ENDP	; Ogre::MovableObject::setPickParam
_TEXT	ENDS
PUBLIC	?getPickType@MovableObject@Ogre@@QAEIXZ		; Ogre::MovableObject::getPickType
; Function compile flags: /Odtp
;	COMDAT ?getPickType@MovableObject@Ogre@@QAEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getPickType@MovableObject@Ogre@@QAEIXZ PROC		; Ogre::MovableObject::getPickType, COMDAT
; _this$ = ecx

; 149  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 150  : 			return m_PickType;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+200]

; 151  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?getPickType@MovableObject@Ogre@@QAEIXZ ENDP		; Ogre::MovableObject::getPickType
_TEXT	ENDS
PUBLIC	?getPickOwner@MovableObject@Ogre@@QAEPAV12@XZ	; Ogre::MovableObject::getPickOwner
; Function compile flags: /Odtp
;	COMDAT ?getPickOwner@MovableObject@Ogre@@QAEPAV12@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getPickOwner@MovableObject@Ogre@@QAEPAV12@XZ PROC	; Ogre::MovableObject::getPickOwner, COMDAT
; _this$ = ecx

; 154  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 155  : 			return m_pPickOwner;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+204]

; 156  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?getPickOwner@MovableObject@Ogre@@QAEPAV12@XZ ENDP	; Ogre::MovableObject::getPickOwner
_TEXT	ENDS
PUBLIC	?isSceneAttached@MovableObject@Ogre@@QAE_NXZ	; Ogre::MovableObject::isSceneAttached
; Function compile flags: /Odtp
;	COMDAT ?isSceneAttached@MovableObject@Ogre@@QAE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?isSceneAttached@MovableObject@Ogre@@QAE_NXZ PROC	; Ogre::MovableObject::isSceneAttached, COMDAT
; _this$ = ecx

; 159  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 160  : 			return m_bSceneAttached;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+182]

; 161  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?isSceneAttached@MovableObject@Ogre@@QAE_NXZ ENDP	; Ogre::MovableObject::isSceneAttached
_TEXT	ENDS
PUBLIC	?setFather@MovableObject@Ogre@@QAEXPAV12@@Z	; Ogre::MovableObject::setFather
; Function compile flags: /Odtp
;	COMDAT ?setFather@MovableObject@Ogre@@QAEXPAV12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pfather$ = 8						; size = 4
?setFather@MovableObject@Ogre@@QAEXPAV12@@Z PROC	; Ogre::MovableObject::setFather, COMDAT
; _this$ = ecx

; 164  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 165  : 			m_pFather = pfather;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pfather$[ebp]
	mov	DWORD PTR [eax+176], ecx

; 166  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?setFather@MovableObject@Ogre@@QAEXPAV12@@Z ENDP	; Ogre::MovableObject::setFather
_TEXT	ENDS
PUBLIC	?getFather@MovableObject@Ogre@@QAEPAV12@XZ	; Ogre::MovableObject::getFather
; Function compile flags: /Odtp
;	COMDAT ?getFather@MovableObject@Ogre@@QAEPAV12@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getFather@MovableObject@Ogre@@QAEPAV12@XZ PROC		; Ogre::MovableObject::getFather, COMDAT
; _this$ = ecx

; 169  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 170  : 			return m_pFather;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+176]

; 171  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?getFather@MovableObject@Ogre@@QAEPAV12@XZ ENDP		; Ogre::MovableObject::getFather
_TEXT	ENDS
PUBLIC	?getSRTFather@MovableObject@Ogre@@QAEPAV12@XZ	; Ogre::MovableObject::getSRTFather
; Function compile flags: /Odtp
;	COMDAT ?getSRTFather@MovableObject@Ogre@@QAEPAV12@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getSRTFather@MovableObject@Ogre@@QAEPAV12@XZ PROC	; Ogre::MovableObject::getSRTFather, COMDAT
; _this$ = ecx

; 174  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 175  : 			return m_pSRTFather;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+168]

; 176  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?getSRTFather@MovableObject@Ogre@@QAEPAV12@XZ ENDP	; Ogre::MovableObject::getSRTFather
_TEXT	ENDS
PUBLIC	?setTransparent@MovableObject@Ogre@@QAEXM@Z	; Ogre::MovableObject::setTransparent
; Function compile flags: /Odtp
;	COMDAT ?setTransparent@MovableObject@Ogre@@QAEXM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_alpha$ = 8						; size = 4
?setTransparent@MovableObject@Ogre@@QAEXM@Z PROC	; Ogre::MovableObject::setTransparent, COMDAT
; _this$ = ecx

; 179  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 180  : 			m_Transparent = alpha;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR _alpha$[ebp]
	fstp	DWORD PTR [eax+188]

; 181  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?setTransparent@MovableObject@Ogre@@QAEXM@Z ENDP	; Ogre::MovableObject::setTransparent
_TEXT	ENDS
PUBLIC	?getLocalTransparent@MovableObject@Ogre@@QAEMXZ	; Ogre::MovableObject::getLocalTransparent
; Function compile flags: /Odtp
;	COMDAT ?getLocalTransparent@MovableObject@Ogre@@QAEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getLocalTransparent@MovableObject@Ogre@@QAEMXZ PROC	; Ogre::MovableObject::getLocalTransparent, COMDAT
; _this$ = ecx

; 184  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 185  : 			return m_Transparent;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+188]

; 186  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?getLocalTransparent@MovableObject@Ogre@@QAEMXZ ENDP	; Ogre::MovableObject::getLocalTransparent
_TEXT	ENDS
PUBLIC	?getTransparent@MovableObject@Ogre@@QAEMXZ	; Ogre::MovableObject::getTransparent
; Function compile flags: /Odtp
;	COMDAT ?getTransparent@MovableObject@Ogre@@QAEMXZ
_TEXT	SEGMENT
tv81 = -8						; size = 4
_this$ = -4						; size = 4
?getTransparent@MovableObject@Ogre@@QAEMXZ PROC		; Ogre::MovableObject::getTransparent, COMDAT
; _this$ = ecx

; 189  : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 190  : 			if(m_pFather) return m_pFather->getTransparent()*m_Transparent;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+176], 0
	je	SHORT $LN2@getTranspa
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+176]
	call	?getTransparent@MovableObject@Ogre@@QAEMXZ ; Ogre::MovableObject::getTransparent
	mov	edx, DWORD PTR _this$[ebp]
	fmul	DWORD PTR [edx+188]
	fstp	DWORD PTR tv81[ebp]
	fld	DWORD PTR tv81[ebp]
	jmp	SHORT $LN1@getTranspa
	jmp	SHORT $LN1@getTranspa
$LN2@getTranspa:

; 191  : 			else return m_Transparent;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+188]
$LN1@getTranspa:

; 192  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?getTransparent@MovableObject@Ogre@@QAEMXZ ENDP		; Ogre::MovableObject::getTransparent
_TEXT	ENDS
PUBLIC	??_7MovableObject@Ogre@@6B@			; Ogre::MovableObject::`vftable'
PUBLIC	??0MovableObject@Ogre@@QAE@ABV01@@Z		; Ogre::MovableObject::MovableObject
PUBLIC	??_R4MovableObject@Ogre@@6B@			; Ogre::MovableObject::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVMovableObject@Ogre@@@8			; Ogre::MovableObject `RTTI Type Descriptor'
PUBLIC	??_R3MovableObject@Ogre@@8			; Ogre::MovableObject::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2MovableObject@Ogre@@8			; Ogre::MovableObject::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@MovableObject@Ogre@@8		; Ogre::MovableObject::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_EMovableObject@Ogre@@UAEPAXI@Z		; Ogre::MovableObject::`vector deleting destructor'
EXTRN	?update@MovableObject@Ogre@@UAEXI@Z:PROC	; Ogre::MovableObject::update
EXTRN	?attachToScene@MovableObject@Ogre@@UAEXPAVGameScene@2@_N@Z:PROC ; Ogre::MovableObject::attachToScene
EXTRN	?detachFromScene@MovableObject@Ogre@@UAEXXZ:PROC ; Ogre::MovableObject::detachFromScene
EXTRN	?intersectRay@MovableObject@Ogre@@UAE_NW4IntersectType@2@ABVRay@2@PAM@Z:PROC ; Ogre::MovableObject::intersectRay
EXTRN	?invalidWorldCache@MovableObject@Ogre@@UAEXXZ:PROC ; Ogre::MovableObject::invalidWorldCache
EXTRN	?updateWorldCache@MovableObject@Ogre@@UAEXXZ:PROC ; Ogre::MovableObject::updateWorldCache
;	COMDAT ??_R1A@?0A@EA@MovableObject@Ogre@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@MovableObject@Ogre@@8 DD FLAT:??_R0?AVMovableObject@Ogre@@@8 ; Ogre::MovableObject::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3MovableObject@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R2MovableObject@Ogre@@8
rdata$r	SEGMENT
??_R2MovableObject@Ogre@@8 DD FLAT:??_R1A@?0A@EA@MovableObject@Ogre@@8 ; Ogre::MovableObject::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@BaseObject@Ogre@@8
	DD	FLAT:??_R13?0A@EA@MemoryDelegation@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R3MovableObject@Ogre@@8
rdata$r	SEGMENT
??_R3MovableObject@Ogre@@8 DD 00H			; Ogre::MovableObject::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2MovableObject@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVMovableObject@Ogre@@@8
_DATA	SEGMENT
??_R0?AVMovableObject@Ogre@@@8 DD FLAT:??_7type_info@@6B@ ; Ogre::MovableObject `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVMovableObject@Ogre@@', 00H
_DATA	ENDS
;	COMDAT ??_R4MovableObject@Ogre@@6B@
rdata$r	SEGMENT
??_R4MovableObject@Ogre@@6B@ DD 00H			; Ogre::MovableObject::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVMovableObject@Ogre@@@8
	DD	FLAT:??_R3MovableObject@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_7MovableObject@Ogre@@6B@
CONST	SEGMENT
??_7MovableObject@Ogre@@6B@ DD FLAT:??_R4MovableObject@Ogre@@6B@ ; Ogre::MovableObject::`vftable'
	DD	FLAT:?getRTTI@MovableObject@Ogre@@UBEPBVRuntimeClass@2@XZ
	DD	FLAT:?release@BaseObject@Ogre@@UAEXXZ
	DD	FLAT:?addRef@BaseObject@Ogre@@UAEXXZ
	DD	FLAT:?getRefCount@BaseObject@Ogre@@UAEHXZ
	DD	FLAT:?_serialize@BaseObject@Ogre@@UAEXAAVArchive@2@H@Z
	DD	FLAT:??_EMovableObject@Ogre@@UAEPAXI@Z
	DD	FLAT:?deleteThis@BaseObject@Ogre@@MAEXXZ
	DD	FLAT:?enableUVMask@MovableObject@Ogre@@UAEX_N0@Z
	DD	FLAT:?setLiuGuangTexture@MovableObject@Ogre@@UAEXPBD@Z
	DD	FLAT:?setLiuGuangTexture@MovableObject@Ogre@@UAEXPAVTextureData@2@@Z
	DD	FLAT:?SetForceShadowMapCull@MovableObject@Ogre@@UAEX_N@Z
	DD	FLAT:?update@MovableObject@Ogre@@UAEXI@Z
	DD	FLAT:?resetUpdate@MovableObject@Ogre@@UAEX_NI@Z
	DD	FLAT:?attachToScene@MovableObject@Ogre@@UAEXPAVGameScene@2@_N@Z
	DD	FLAT:?detachFromScene@MovableObject@Ogre@@UAEXXZ
	DD	FLAT:?intersectRay@MovableObject@Ogre@@UAE_NW4IntersectType@2@ABVRay@2@PAM@Z
	DD	FLAT:?getAnchorWorldMatrix@MovableObject@Ogre@@UAE?AVMatrix4@2@H@Z
	DD	FLAT:?invalidWorldCache@MovableObject@Ogre@@UAEXXZ
	DD	FLAT:?updateWorldCache@MovableObject@Ogre@@UAEXXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0MovableObject@Ogre@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0MovableObject@Ogre@@QAE@ABV01@@Z$0
__ehfuncinfo$??0MovableObject@Ogre@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0MovableObject@Ogre@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0MovableObject@Ogre@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0MovableObject@Ogre@@QAE@ABV01@@Z PROC		; Ogre::MovableObject::MovableObject, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0MovableObject@Ogre@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0BaseObject@Ogre@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7MovableObject@Ogre@@6B@
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 8
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	edx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], edx
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 20					; 00000014H
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 20					; 00000014H
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], eax
	mov	ecx, DWORD PTR ___that$[ebp]
	add	ecx, 36					; 00000024H
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??0Vector3@Ogre@@QAE@ABV01@@Z		; Ogre::Vector3::Vector3
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 48					; 00000030H
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	??0Matrix4@Ogre@@QAE@ABV01@@Z		; Ogre::Matrix4::Matrix4
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 112				; 00000070H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 112				; 00000070H
	call	??0BoxBound@Ogre@@QAE@ABV01@@Z		; Ogre::BoxBound::BoxBound
	mov	ecx, DWORD PTR ___that$[ebp]
	add	ecx, 140				; 0000008cH
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 140				; 0000008cH
	call	??0BoxSphereBound@Ogre@@QAE@ABV01@@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+168]
	mov	DWORD PTR [edx+168], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+172]
	mov	DWORD PTR [edx+172], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+176]
	mov	DWORD PTR [edx+176], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	cl, BYTE PTR [eax+180]
	mov	BYTE PTR [edx+180], cl
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	cl, BYTE PTR [eax+181]
	mov	BYTE PTR [edx+181], cl
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	cl, BYTE PTR [eax+182]
	mov	BYTE PTR [edx+182], cl
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	cl, BYTE PTR [eax+183]
	mov	BYTE PTR [edx+183], cl
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	cl, BYTE PTR [eax+184]
	mov	BYTE PTR [edx+184], cl
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	fld	DWORD PTR [eax+188]
	fstp	DWORD PTR [edx+188]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+192]
	mov	DWORD PTR [ecx+192], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+196]
	mov	DWORD PTR [ecx+196], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+200]
	mov	DWORD PTR [ecx+200], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+204]
	mov	DWORD PTR [ecx+204], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	al, BYTE PTR [edx+208]
	mov	BYTE PTR [ecx+208], al
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0MovableObject@Ogre@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1BaseObject@Ogre@@MAE@XZ		; Ogre::BaseObject::~BaseObject
__ehhandler$??0MovableObject@Ogre@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0MovableObject@Ogre@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0MovableObject@Ogre@@QAE@ABV01@@Z ENDP		; Ogre::MovableObject::MovableObject
PUBLIC	??4MovableObject@Ogre@@QAEAAV01@ABV01@@Z	; Ogre::MovableObject::operator=
EXTRN	??4Matrix4@Ogre@@QAEABV01@ABV01@@Z:PROC		; Ogre::Matrix4::operator=
; Function compile flags: /Odtp
;	COMDAT ??4MovableObject@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4MovableObject@Ogre@@QAEAAV01@ABV01@@Z PROC		; Ogre::MovableObject::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4BaseObject@Ogre@@QAEAAV01@ABV01@@Z
	mov	ecx, DWORD PTR ___that$[ebp]
	add	ecx, 8
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 8
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], ecx
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 20					; 00000014H
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 20					; 00000014H
	call	??4Quaternion@Ogre@@QAEAAV01@ABV01@@Z	; Ogre::Quaternion::operator=
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 36					; 00000024H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??4Vector3@Ogre@@QAEABV01@ABV01@@Z	; Ogre::Vector3::operator=
	mov	ecx, DWORD PTR ___that$[ebp]
	add	ecx, 48					; 00000030H
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 48					; 00000030H
	call	??4Matrix4@Ogre@@QAEABV01@ABV01@@Z	; Ogre::Matrix4::operator=
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 112				; 00000070H
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 112				; 00000070H
	call	??4BoxBound@Ogre@@QAEAAV01@ABV01@@Z
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 140				; 0000008cH
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 140				; 0000008cH
	call	??4BoxSphereBound@Ogre@@QAEAAV01@ABV01@@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+168]
	mov	DWORD PTR [ecx+168], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+172]
	mov	DWORD PTR [ecx+172], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+176]
	mov	DWORD PTR [ecx+176], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	al, BYTE PTR [edx+180]
	mov	BYTE PTR [ecx+180], al
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	al, BYTE PTR [edx+181]
	mov	BYTE PTR [ecx+181], al
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	al, BYTE PTR [edx+182]
	mov	BYTE PTR [ecx+182], al
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	al, BYTE PTR [edx+183]
	mov	BYTE PTR [ecx+183], al
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	al, BYTE PTR [edx+184]
	mov	BYTE PTR [ecx+184], al
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	fld	DWORD PTR [edx+188]
	fstp	DWORD PTR [ecx+188]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+192]
	mov	DWORD PTR [eax+192], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+196]
	mov	DWORD PTR [eax+196], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+200]
	mov	DWORD PTR [eax+200], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+204]
	mov	DWORD PTR [eax+204], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	dl, BYTE PTR [ecx+208]
	mov	BYTE PTR [eax+208], dl
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4MovableObject@Ogre@@QAEAAV01@ABV01@@Z ENDP		; Ogre::MovableObject::operator=
_TEXT	ENDS
PUBLIC	??_GMovableObject@Ogre@@UAEPAXI@Z		; Ogre::MovableObject::`scalar deleting destructor'
EXTRN	??1MovableObject@Ogre@@UAE@XZ:PROC		; Ogre::MovableObject::~MovableObject
; Function compile flags: /Odtp
;	COMDAT ??_GMovableObject@Ogre@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GMovableObject@Ogre@@UAEPAXI@Z PROC			; Ogre::MovableObject::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1MovableObject@Ogre@@UAE@XZ		; Ogre::MovableObject::~MovableObject
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@9
	push	212					; 000000d4H
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3MemoryDelegation@Ogre@@SAXPAXI@Z	; Ogre::MemoryDelegation::operator delete
	add	esp, 8
$LN1@scalar@9:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GMovableObject@Ogre@@UAEPAXI@Z ENDP			; Ogre::MovableObject::`scalar deleting destructor'
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_EMovableObject@Ogre@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_EMovableObject@Ogre@@UAEPAXI@Z PROC			; Ogre::MovableObject::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 2
	je	SHORT $LN3@vector@9
	push	OFFSET ??1MovableObject@Ogre@@UAE@XZ	; Ogre::MovableObject::~MovableObject
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx-4]
	push	edx
	push	212					; 000000d4H
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??_M@YGXPAXIHP6EX0@Z@Z
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN2@vector@9
	push	212					; 000000d4H
	mov	edx, DWORD PTR _this$[ebp]
	sub	edx, 4
	push	edx
	call	??_VMemoryDelegation@Ogre@@SAXPAXI@Z	; Ogre::MemoryDelegation::operator delete[]
	add	esp, 8
$LN2@vector@9:
	mov	eax, DWORD PTR _this$[ebp]
	sub	eax, 4
	jmp	SHORT $LN4@vector@9
$LN3@vector@9:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1MovableObject@Ogre@@UAE@XZ		; Ogre::MovableObject::~MovableObject
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@vector@9
	push	212					; 000000d4H
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3MemoryDelegation@Ogre@@SAXPAXI@Z	; Ogre::MemoryDelegation::operator delete
	add	esp, 8
$LN1@vector@9:
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector@9:
	mov	esp, ebp
	pop	ebp
	ret	4
??_EMovableObject@Ogre@@UAEPAXI@Z ENDP			; Ogre::MovableObject::`vector deleting destructor'
_TEXT	ENDS
PUBLIC	?handle2Ptr@FixedString@Ogre@@SAPBDPAX@Z	; Ogre::FixedString::handle2Ptr
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogrefixedstring.h
;	COMDAT ?handle2Ptr@FixedString@Ogre@@SAPBDPAX@Z
_TEXT	SEGMENT
_h$ = 8							; size = 4
?handle2Ptr@FixedString@Ogre@@SAPBDPAX@Z PROC		; Ogre::FixedString::handle2Ptr, COMDAT

; 22   : 		{

	push	ebp
	mov	ebp, esp

; 23   : 			return (const char *)h;

	mov	eax, DWORD PTR _h$[ebp]

; 24   : 		}

	pop	ebp
	ret	0
?handle2Ptr@FixedString@Ogre@@SAPBDPAX@Z ENDP		; Ogre::FixedString::handle2Ptr
_TEXT	ENDS
PUBLIC	??0FixedString@Ogre@@QAE@XZ			; Ogre::FixedString::FixedString
; Function compile flags: /Odtp
;	COMDAT ??0FixedString@Ogre@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0FixedString@Ogre@@QAE@XZ PROC			; Ogre::FixedString::FixedString, COMDAT
; _this$ = ecx

; 27   : 		FixedString() : m_StrHandle(NULL){}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0FixedString@Ogre@@QAE@XZ ENDP			; Ogre::FixedString::FixedString
_TEXT	ENDS
PUBLIC	??0FixedString@Ogre@@QAE@PAX@Z			; Ogre::FixedString::FixedString
EXTRN	?addRef@FixedString@Ogre@@SAXPAX@Z:PROC		; Ogre::FixedString::addRef
; Function compile flags: /Odtp
;	COMDAT ??0FixedString@Ogre@@QAE@PAX@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_h$ = 8							; size = 4
??0FixedString@Ogre@@QAE@PAX@Z PROC			; Ogre::FixedString::FixedString, COMDAT
; _this$ = ecx

; 29   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _h$[ebp]
	mov	DWORD PTR [eax], ecx

; 30   : 			addRef(h);

	mov	edx, DWORD PTR _h$[ebp]
	push	edx
	call	?addRef@FixedString@Ogre@@SAXPAX@Z	; Ogre::FixedString::addRef
	add	esp, 4

; 31   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0FixedString@Ogre@@QAE@PAX@Z ENDP			; Ogre::FixedString::FixedString
_TEXT	ENDS
PUBLIC	??0FixedString@Ogre@@QAE@ABV01@@Z		; Ogre::FixedString::FixedString
; Function compile flags: /Odtp
;	COMDAT ??0FixedString@Ogre@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_rhs$ = 8						; size = 4
??0FixedString@Ogre@@QAE@ABV01@@Z PROC			; Ogre::FixedString::FixedString, COMDAT
; _this$ = ecx

; 34   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _rhs$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 35   : 			addRef(m_StrHandle);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?addRef@FixedString@Ogre@@SAXPAX@Z	; Ogre::FixedString::addRef
	add	esp, 4

; 36   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0FixedString@Ogre@@QAE@ABV01@@Z ENDP			; Ogre::FixedString::FixedString
_TEXT	ENDS
PUBLIC	??0FixedString@Ogre@@QAE@PBD@Z			; Ogre::FixedString::FixedString
EXTRN	?insert@FixedString@Ogre@@SAPAXPBDH@Z:PROC	; Ogre::FixedString::insert
; Function compile flags: /Odtp
;	COMDAT ??0FixedString@Ogre@@QAE@PBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pstr$ = 8						; size = 4
??0FixedString@Ogre@@QAE@PBD@Z PROC			; Ogre::FixedString::FixedString, COMDAT
; _this$ = ecx

; 38   : 		FixedString(const char *pstr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 39   : 		{
; 40   : 			m_StrHandle = insert(pstr); 

	push	-1
	mov	eax, DWORD PTR _pstr$[ebp]
	push	eax
	call	?insert@FixedString@Ogre@@SAPAXPBDH@Z	; Ogre::FixedString::insert
	add	esp, 8
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], eax

; 41   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0FixedString@Ogre@@QAE@PBD@Z ENDP			; Ogre::FixedString::FixedString
_TEXT	ENDS
PUBLIC	??0FixedString@Ogre@@QAE@PBDI@Z			; Ogre::FixedString::FixedString
; Function compile flags: /Odtp
;	COMDAT ??0FixedString@Ogre@@QAE@PBDI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pstr$ = 8						; size = 4
_len$ = 12						; size = 4
??0FixedString@Ogre@@QAE@PBDI@Z PROC			; Ogre::FixedString::FixedString, COMDAT
; _this$ = ecx

; 43   : 		FixedString(const char *pstr, size_t len)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 44   : 		{
; 45   : 			m_StrHandle = insert(pstr, (int)len); 

	mov	eax, DWORD PTR _len$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pstr$[ebp]
	push	ecx
	call	?insert@FixedString@Ogre@@SAPAXPBDH@Z	; Ogre::FixedString::insert
	add	esp, 8
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], eax

; 46   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0FixedString@Ogre@@QAE@PBDI@Z ENDP			; Ogre::FixedString::FixedString
_TEXT	ENDS
PUBLIC	??1FixedString@Ogre@@QAE@XZ			; Ogre::FixedString::~FixedString
EXTRN	?release@FixedString@Ogre@@SAXPAX@Z:PROC	; Ogre::FixedString::release
; Function compile flags: /Odtp
;	COMDAT ??1FixedString@Ogre@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1FixedString@Ogre@@QAE@XZ PROC			; Ogre::FixedString::~FixedString, COMDAT
; _this$ = ecx

; 49   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 50   : 			release(m_StrHandle); 

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?release@FixedString@Ogre@@SAXPAX@Z	; Ogre::FixedString::release
	add	esp, 4

; 51   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??1FixedString@Ogre@@QAE@XZ ENDP			; Ogre::FixedString::~FixedString
_TEXT	ENDS
PUBLIC	??BFixedString@Ogre@@QBEPBDXZ			; Ogre::FixedString::operator char const *
; Function compile flags: /Odtp
;	COMDAT ??BFixedString@Ogre@@QBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??BFixedString@Ogre@@QBEPBDXZ PROC			; Ogre::FixedString::operator char const *, COMDAT
; _this$ = ecx

; 54   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 55   : 			return handle2Ptr(m_StrHandle);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	?handle2Ptr@FixedString@Ogre@@SAPBDPAX@Z ; Ogre::FixedString::handle2Ptr
	add	esp, 4

; 56   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??BFixedString@Ogre@@QBEPBDXZ ENDP			; Ogre::FixedString::operator char const *
_TEXT	ENDS
PUBLIC	?getHandle@FixedString@Ogre@@QBEPAXXZ		; Ogre::FixedString::getHandle
; Function compile flags: /Odtp
;	COMDAT ?getHandle@FixedString@Ogre@@QBEPAXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getHandle@FixedString@Ogre@@QBEPAXXZ PROC		; Ogre::FixedString::getHandle, COMDAT
; _this$ = ecx

; 59   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 60   : 			return m_StrHandle;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 61   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?getHandle@FixedString@Ogre@@QBEPAXXZ ENDP		; Ogre::FixedString::getHandle
_TEXT	ENDS
PUBLIC	?getRTTI@Resource@Ogre@@UBEPBVRuntimeClass@2@XZ	; Ogre::Resource::getRTTI
EXTRN	?m_RTTI@Resource@Ogre@@2VRuntimeClass@2@B:BYTE	; Ogre::Resource::m_RTTI
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogreresource.h
;	COMDAT ?getRTTI@Resource@Ogre@@UBEPBVRuntimeClass@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getRTTI@Resource@Ogre@@UBEPBVRuntimeClass@2@XZ PROC	; Ogre::Resource::getRTTI, COMDAT
; _this$ = ecx

; 39   : 		DECLARE_RTTI_VIRTUAL(Resource)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, OFFSET ?m_RTTI@Resource@Ogre@@2VRuntimeClass@2@B ; Ogre::Resource::m_RTTI
	mov	esp, ebp
	pop	ebp
	ret	0
?getRTTI@Resource@Ogre@@UBEPBVRuntimeClass@2@XZ ENDP	; Ogre::Resource::getRTTI
_TEXT	ENDS
PUBLIC	?getResPath@Resource@Ogre@@QAEABVFixedString@2@XZ ; Ogre::Resource::getResPath
; Function compile flags: /Odtp
;	COMDAT ?getResPath@Resource@Ogre@@QAEABVFixedString@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getResPath@Resource@Ogre@@QAEABVFixedString@2@XZ PROC	; Ogre::Resource::getResPath, COMDAT
; _this$ = ecx

; 44   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 45   : 			return m_ResPath;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8

; 46   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?getResPath@Resource@Ogre@@QAEABVFixedString@2@XZ ENDP	; Ogre::Resource::getResPath
_TEXT	ENDS
PUBLIC	?setResPath@Resource@Ogre@@QAEXABVFixedString@2@@Z ; Ogre::Resource::setResPath
EXTRN	??4FixedString@Ogre@@QAEAAV01@ABV01@@Z:PROC	; Ogre::FixedString::operator=
; Function compile flags: /Odtp
;	COMDAT ?setResPath@Resource@Ogre@@QAEXABVFixedString@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_path$ = 8						; size = 4
?setResPath@Resource@Ogre@@QAEXABVFixedString@2@@Z PROC	; Ogre::Resource::setResPath, COMDAT
; _this$ = ecx

; 48   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 49   : 			m_ResPath = path;

	mov	eax, DWORD PTR _path$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??4FixedString@Ogre@@QAEAAV01@ABV01@@Z	; Ogre::FixedString::operator=

; 50   : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?setResPath@Resource@Ogre@@QAEXABVFixedString@2@@Z ENDP	; Ogre::Resource::setResPath
_TEXT	ENDS
PUBLIC	??_7Resource@Ogre@@6B@				; Ogre::Resource::`vftable'
PUBLIC	??0Resource@Ogre@@IAE@XZ			; Ogre::Resource::Resource
PUBLIC	??_R4Resource@Ogre@@6B@				; Ogre::Resource::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVResource@Ogre@@@8			; Ogre::Resource `RTTI Type Descriptor'
PUBLIC	??_R3Resource@Ogre@@8				; Ogre::Resource::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2Resource@Ogre@@8				; Ogre::Resource::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@Resource@Ogre@@8			; Ogre::Resource::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_EResource@Ogre@@MAEPAXI@Z			; Ogre::Resource::`vector deleting destructor'
EXTRN	?release@Resource@Ogre@@UAEXXZ:PROC		; Ogre::Resource::release
EXTRN	?addRef@Resource@Ogre@@UAEXXZ:PROC		; Ogre::Resource::addRef
EXTRN	?getRefCount@Resource@Ogre@@UAEHXZ:PROC		; Ogre::Resource::getRefCount
;	COMDAT ??_R1A@?0A@EA@Resource@Ogre@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@Resource@Ogre@@8 DD FLAT:??_R0?AVResource@Ogre@@@8 ; Ogre::Resource::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3Resource@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R2Resource@Ogre@@8
rdata$r	SEGMENT
??_R2Resource@Ogre@@8 DD FLAT:??_R1A@?0A@EA@Resource@Ogre@@8 ; Ogre::Resource::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@BaseObject@Ogre@@8
	DD	FLAT:??_R13?0A@EA@MemoryDelegation@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R3Resource@Ogre@@8
rdata$r	SEGMENT
??_R3Resource@Ogre@@8 DD 00H				; Ogre::Resource::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2Resource@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVResource@Ogre@@@8
_DATA	SEGMENT
??_R0?AVResource@Ogre@@@8 DD FLAT:??_7type_info@@6B@	; Ogre::Resource `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVResource@Ogre@@', 00H
_DATA	ENDS
;	COMDAT ??_R4Resource@Ogre@@6B@
rdata$r	SEGMENT
??_R4Resource@Ogre@@6B@ DD 00H				; Ogre::Resource::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVResource@Ogre@@@8
	DD	FLAT:??_R3Resource@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_7Resource@Ogre@@6B@
CONST	SEGMENT
??_7Resource@Ogre@@6B@ DD FLAT:??_R4Resource@Ogre@@6B@	; Ogre::Resource::`vftable'
	DD	FLAT:?getRTTI@Resource@Ogre@@UBEPBVRuntimeClass@2@XZ
	DD	FLAT:?release@Resource@Ogre@@UAEXXZ
	DD	FLAT:?addRef@Resource@Ogre@@UAEXXZ
	DD	FLAT:?getRefCount@Resource@Ogre@@UAEHXZ
	DD	FLAT:?_serialize@BaseObject@Ogre@@UAEXAAVArchive@2@H@Z
	DD	FLAT:??_EResource@Ogre@@MAEPAXI@Z
	DD	FLAT:?deleteThis@BaseObject@Ogre@@MAEXXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0Resource@Ogre@@IAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0Resource@Ogre@@IAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0Resource@Ogre@@IAE@XZ$1
__ehfuncinfo$??0Resource@Ogre@@IAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0Resource@Ogre@@IAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0Resource@Ogre@@IAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0Resource@Ogre@@IAE@XZ PROC				; Ogre::Resource::Resource, COMDAT
; _this$ = ecx

; 72   : 		{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0Resource@Ogre@@IAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0BaseObject@Ogre@@IAE@XZ		; Ogre::BaseObject::BaseObject
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7Resource@Ogre@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??0FixedString@Ogre@@QAE@XZ		; Ogre::FixedString::FixedString
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 1

; 73   : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0Resource@Ogre@@IAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1BaseObject@Ogre@@MAE@XZ		; Ogre::BaseObject::~BaseObject
__unwindfunclet$??0Resource@Ogre@@IAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	jmp	??1FixedString@Ogre@@QAE@XZ		; Ogre::FixedString::~FixedString
__ehhandler$??0Resource@Ogre@@IAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0Resource@Ogre@@IAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0Resource@Ogre@@IAE@XZ ENDP				; Ogre::Resource::Resource
PUBLIC	??1Resource@Ogre@@MAE@XZ			; Ogre::Resource::~Resource
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1Resource@Ogre@@MAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1Resource@Ogre@@MAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1Resource@Ogre@@MAE@XZ$1
__ehfuncinfo$??1Resource@Ogre@@MAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??1Resource@Ogre@@MAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1Resource@Ogre@@MAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1Resource@Ogre@@MAE@XZ PROC				; Ogre::Resource::~Resource, COMDAT
; _this$ = ecx

; 76   : 		{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1Resource@Ogre@@MAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7Resource@Ogre@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 77   : 		}

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??1FixedString@Ogre@@QAE@XZ		; Ogre::FixedString::~FixedString
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1BaseObject@Ogre@@MAE@XZ		; Ogre::BaseObject::~BaseObject
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1Resource@Ogre@@MAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1BaseObject@Ogre@@MAE@XZ		; Ogre::BaseObject::~BaseObject
__unwindfunclet$??1Resource@Ogre@@MAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	jmp	??1FixedString@Ogre@@QAE@XZ		; Ogre::FixedString::~FixedString
__ehhandler$??1Resource@Ogre@@MAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1Resource@Ogre@@MAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1Resource@Ogre@@MAE@XZ ENDP				; Ogre::Resource::~Resource
PUBLIC	??0Resource@Ogre@@QAE@ABV01@@Z			; Ogre::Resource::Resource
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0Resource@Ogre@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0Resource@Ogre@@QAE@ABV01@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0Resource@Ogre@@QAE@ABV01@@Z$1
__ehfuncinfo$??0Resource@Ogre@@QAE@ABV01@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0Resource@Ogre@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0Resource@Ogre@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0Resource@Ogre@@QAE@ABV01@@Z PROC			; Ogre::Resource::Resource, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0Resource@Ogre@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0BaseObject@Ogre@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7Resource@Ogre@@6B@
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 8
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??0FixedString@Ogre@@QAE@ABV01@@Z	; Ogre::FixedString::FixedString
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+12], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0Resource@Ogre@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1BaseObject@Ogre@@MAE@XZ		; Ogre::BaseObject::~BaseObject
__unwindfunclet$??0Resource@Ogre@@QAE@ABV01@@Z$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	jmp	??1FixedString@Ogre@@QAE@XZ		; Ogre::FixedString::~FixedString
__ehhandler$??0Resource@Ogre@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0Resource@Ogre@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0Resource@Ogre@@QAE@ABV01@@Z ENDP			; Ogre::Resource::Resource
PUBLIC	??4Resource@Ogre@@QAEAAV01@ABV01@@Z		; Ogre::Resource::operator=
; Function compile flags: /Odtp
;	COMDAT ??4Resource@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4Resource@Ogre@@QAEAAV01@ABV01@@Z PROC		; Ogre::Resource::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4BaseObject@Ogre@@QAEAAV01@ABV01@@Z
	mov	ecx, DWORD PTR ___that$[ebp]
	add	ecx, 8
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??4FixedString@Ogre@@QAEAAV01@ABV01@@Z	; Ogre::FixedString::operator=
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4Resource@Ogre@@QAEAAV01@ABV01@@Z ENDP		; Ogre::Resource::operator=
_TEXT	ENDS
PUBLIC	??_GResource@Ogre@@MAEPAXI@Z			; Ogre::Resource::`scalar deleting destructor'
; Function compile flags: /Odtp
;	COMDAT ??_GResource@Ogre@@MAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GResource@Ogre@@MAEPAXI@Z PROC			; Ogre::Resource::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1Resource@Ogre@@MAE@XZ		; Ogre::Resource::~Resource
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@10
	push	16					; 00000010H
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3MemoryDelegation@Ogre@@SAXPAXI@Z	; Ogre::MemoryDelegation::operator delete
	add	esp, 8
$LN1@scalar@10:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GResource@Ogre@@MAEPAXI@Z ENDP			; Ogre::Resource::`scalar deleting destructor'
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_EResource@Ogre@@MAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_EResource@Ogre@@MAEPAXI@Z PROC			; Ogre::Resource::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 2
	je	SHORT $LN3@vector@10
	push	OFFSET ??1Resource@Ogre@@MAE@XZ		; Ogre::Resource::~Resource
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx-4]
	push	edx
	push	16					; 00000010H
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??_M@YGXPAXIHP6EX0@Z@Z
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN2@vector@10
	push	16					; 00000010H
	mov	edx, DWORD PTR _this$[ebp]
	sub	edx, 4
	push	edx
	call	??_VMemoryDelegation@Ogre@@SAXPAXI@Z	; Ogre::MemoryDelegation::operator delete[]
	add	esp, 8
$LN2@vector@10:
	mov	eax, DWORD PTR _this$[ebp]
	sub	eax, 4
	jmp	SHORT $LN4@vector@10
$LN3@vector@10:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1Resource@Ogre@@MAE@XZ		; Ogre::Resource::~Resource
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@vector@10
	push	16					; 00000010H
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3MemoryDelegation@Ogre@@SAXPAXI@Z	; Ogre::MemoryDelegation::operator delete
	add	esp, 8
$LN1@vector@10:
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector@10:
	mov	esp, ebp
	pop	ebp
	ret	4
??_EResource@Ogre@@MAEPAXI@Z ENDP			; Ogre::Resource::`vector deleting destructor'
_TEXT	ENDS
PUBLIC	?getRTTI@VertexBuffer@Ogre@@UBEPBVRuntimeClass@2@XZ ; Ogre::VertexBuffer::getRTTI
EXTRN	?m_RTTI@VertexBuffer@Ogre@@2VRuntimeClass@2@B:BYTE ; Ogre::VertexBuffer::m_RTTI
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogrerendertypes.h
;	COMDAT ?getRTTI@VertexBuffer@Ogre@@UBEPBVRuntimeClass@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getRTTI@VertexBuffer@Ogre@@UBEPBVRuntimeClass@2@XZ PROC ; Ogre::VertexBuffer::getRTTI, COMDAT
; _this$ = ecx

; 223  : 		DECLARE_RTTI_VIRTUAL(VertexBuffer)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, OFFSET ?m_RTTI@VertexBuffer@Ogre@@2VRuntimeClass@2@B ; Ogre::VertexBuffer::m_RTTI
	mov	esp, ebp
	pop	ebp
	ret	0
?getRTTI@VertexBuffer@Ogre@@UBEPBVRuntimeClass@2@XZ ENDP ; Ogre::VertexBuffer::getRTTI
_TEXT	ENDS
PUBLIC	??_7VertexBuffer@Ogre@@6B@			; Ogre::VertexBuffer::`vftable'
PUBLIC	??0VertexBuffer@Ogre@@QAE@XZ			; Ogre::VertexBuffer::VertexBuffer
PUBLIC	??_R4VertexBuffer@Ogre@@6B@			; Ogre::VertexBuffer::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVVertexBuffer@Ogre@@@8			; Ogre::VertexBuffer `RTTI Type Descriptor'
PUBLIC	??_R3VertexBuffer@Ogre@@8			; Ogre::VertexBuffer::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2VertexBuffer@Ogre@@8			; Ogre::VertexBuffer::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@VertexBuffer@Ogre@@8		; Ogre::VertexBuffer::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_EVertexBuffer@Ogre@@UAEPAXI@Z		; Ogre::VertexBuffer::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@VertexBuffer@Ogre@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@VertexBuffer@Ogre@@8 DD FLAT:??_R0?AVVertexBuffer@Ogre@@@8 ; Ogre::VertexBuffer::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3VertexBuffer@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R2VertexBuffer@Ogre@@8
rdata$r	SEGMENT
??_R2VertexBuffer@Ogre@@8 DD FLAT:??_R1A@?0A@EA@VertexBuffer@Ogre@@8 ; Ogre::VertexBuffer::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@Resource@Ogre@@8
	DD	FLAT:??_R1A@?0A@EA@BaseObject@Ogre@@8
	DD	FLAT:??_R13?0A@EA@MemoryDelegation@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R3VertexBuffer@Ogre@@8
rdata$r	SEGMENT
??_R3VertexBuffer@Ogre@@8 DD 00H			; Ogre::VertexBuffer::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	04H
	DD	FLAT:??_R2VertexBuffer@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVVertexBuffer@Ogre@@@8
_DATA	SEGMENT
??_R0?AVVertexBuffer@Ogre@@@8 DD FLAT:??_7type_info@@6B@ ; Ogre::VertexBuffer `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVVertexBuffer@Ogre@@', 00H
_DATA	ENDS
;	COMDAT ??_R4VertexBuffer@Ogre@@6B@
rdata$r	SEGMENT
??_R4VertexBuffer@Ogre@@6B@ DD 00H			; Ogre::VertexBuffer::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVVertexBuffer@Ogre@@@8
	DD	FLAT:??_R3VertexBuffer@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_7VertexBuffer@Ogre@@6B@
CONST	SEGMENT
??_7VertexBuffer@Ogre@@6B@ DD FLAT:??_R4VertexBuffer@Ogre@@6B@ ; Ogre::VertexBuffer::`vftable'
	DD	FLAT:?getRTTI@VertexBuffer@Ogre@@UBEPBVRuntimeClass@2@XZ
	DD	FLAT:?release@Resource@Ogre@@UAEXXZ
	DD	FLAT:?addRef@Resource@Ogre@@UAEXXZ
	DD	FLAT:?getRefCount@Resource@Ogre@@UAEHXZ
	DD	FLAT:?_serialize@BaseObject@Ogre@@UAEXAAVArchive@2@H@Z
	DD	FLAT:??_EVertexBuffer@Ogre@@UAEPAXI@Z
	DD	FLAT:?deleteThis@BaseObject@Ogre@@MAEXXZ
	DD	FLAT:__purecall
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0VertexBuffer@Ogre@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0VertexBuffer@Ogre@@QAE@XZ$0
__ehfuncinfo$??0VertexBuffer@Ogre@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0VertexBuffer@Ogre@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0VertexBuffer@Ogre@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0VertexBuffer@Ogre@@QAE@XZ PROC			; Ogre::VertexBuffer::VertexBuffer, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0VertexBuffer@Ogre@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0Resource@Ogre@@IAE@XZ		; Ogre::Resource::Resource
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7VertexBuffer@Ogre@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0VertexBuffer@Ogre@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1Resource@Ogre@@MAE@XZ		; Ogre::Resource::~Resource
__ehhandler$??0VertexBuffer@Ogre@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0VertexBuffer@Ogre@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0VertexBuffer@Ogre@@QAE@XZ ENDP			; Ogre::VertexBuffer::VertexBuffer
PUBLIC	??1VertexBuffer@Ogre@@UAE@XZ			; Ogre::VertexBuffer::~VertexBuffer
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1VertexBuffer@Ogre@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1VertexBuffer@Ogre@@UAE@XZ$0
__ehfuncinfo$??1VertexBuffer@Ogre@@UAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1VertexBuffer@Ogre@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1VertexBuffer@Ogre@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1VertexBuffer@Ogre@@UAE@XZ PROC			; Ogre::VertexBuffer::~VertexBuffer, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1VertexBuffer@Ogre@@UAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1Resource@Ogre@@MAE@XZ		; Ogre::Resource::~Resource
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1VertexBuffer@Ogre@@UAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1Resource@Ogre@@MAE@XZ		; Ogre::Resource::~Resource
__ehhandler$??1VertexBuffer@Ogre@@UAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1VertexBuffer@Ogre@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1VertexBuffer@Ogre@@UAE@XZ ENDP			; Ogre::VertexBuffer::~VertexBuffer
PUBLIC	??0VertexBuffer@Ogre@@QAE@ABV01@@Z		; Ogre::VertexBuffer::VertexBuffer
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0VertexBuffer@Ogre@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0VertexBuffer@Ogre@@QAE@ABV01@@Z$0
__ehfuncinfo$??0VertexBuffer@Ogre@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0VertexBuffer@Ogre@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0VertexBuffer@Ogre@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0VertexBuffer@Ogre@@QAE@ABV01@@Z PROC			; Ogre::VertexBuffer::VertexBuffer, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0VertexBuffer@Ogre@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0Resource@Ogre@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7VertexBuffer@Ogre@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0VertexBuffer@Ogre@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1Resource@Ogre@@MAE@XZ		; Ogre::Resource::~Resource
__ehhandler$??0VertexBuffer@Ogre@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0VertexBuffer@Ogre@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0VertexBuffer@Ogre@@QAE@ABV01@@Z ENDP			; Ogre::VertexBuffer::VertexBuffer
PUBLIC	??4VertexBuffer@Ogre@@QAEAAV01@ABV01@@Z		; Ogre::VertexBuffer::operator=
; Function compile flags: /Odtp
;	COMDAT ??4VertexBuffer@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4VertexBuffer@Ogre@@QAEAAV01@ABV01@@Z PROC		; Ogre::VertexBuffer::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4Resource@Ogre@@QAEAAV01@ABV01@@Z
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4VertexBuffer@Ogre@@QAEAAV01@ABV01@@Z ENDP		; Ogre::VertexBuffer::operator=
_TEXT	ENDS
PUBLIC	??_GVertexBuffer@Ogre@@UAEPAXI@Z		; Ogre::VertexBuffer::`scalar deleting destructor'
; Function compile flags: /Odtp
;	COMDAT ??_GVertexBuffer@Ogre@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GVertexBuffer@Ogre@@UAEPAXI@Z PROC			; Ogre::VertexBuffer::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1VertexBuffer@Ogre@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@11
	push	16					; 00000010H
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3MemoryDelegation@Ogre@@SAXPAXI@Z	; Ogre::MemoryDelegation::operator delete
	add	esp, 8
$LN1@scalar@11:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GVertexBuffer@Ogre@@UAEPAXI@Z ENDP			; Ogre::VertexBuffer::`scalar deleting destructor'
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_EVertexBuffer@Ogre@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_EVertexBuffer@Ogre@@UAEPAXI@Z PROC			; Ogre::VertexBuffer::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 2
	je	SHORT $LN3@vector@11
	push	OFFSET ??1VertexBuffer@Ogre@@UAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx-4]
	push	edx
	push	16					; 00000010H
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??_M@YGXPAXIHP6EX0@Z@Z
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN2@vector@11
	push	16					; 00000010H
	mov	edx, DWORD PTR _this$[ebp]
	sub	edx, 4
	push	edx
	call	??_VMemoryDelegation@Ogre@@SAXPAXI@Z	; Ogre::MemoryDelegation::operator delete[]
	add	esp, 8
$LN2@vector@11:
	mov	eax, DWORD PTR _this$[ebp]
	sub	eax, 4
	jmp	SHORT $LN4@vector@11
$LN3@vector@11:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1VertexBuffer@Ogre@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@vector@11
	push	16					; 00000010H
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3MemoryDelegation@Ogre@@SAXPAXI@Z	; Ogre::MemoryDelegation::operator delete
	add	esp, 8
$LN1@vector@11:
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector@11:
	mov	esp, ebp
	pop	ebp
	ret	4
??_EVertexBuffer@Ogre@@UAEPAXI@Z ENDP			; Ogre::VertexBuffer::`vector deleting destructor'
_TEXT	ENDS
PUBLIC	?getRTTI@IndexBuffer@Ogre@@UBEPBVRuntimeClass@2@XZ ; Ogre::IndexBuffer::getRTTI
EXTRN	?m_RTTI@IndexBuffer@Ogre@@2VRuntimeClass@2@B:BYTE ; Ogre::IndexBuffer::m_RTTI
; Function compile flags: /Odtp
;	COMDAT ?getRTTI@IndexBuffer@Ogre@@UBEPBVRuntimeClass@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getRTTI@IndexBuffer@Ogre@@UBEPBVRuntimeClass@2@XZ PROC	; Ogre::IndexBuffer::getRTTI, COMDAT
; _this$ = ecx

; 230  : 		DECLARE_RTTI_VIRTUAL(IndexBuffer)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, OFFSET ?m_RTTI@IndexBuffer@Ogre@@2VRuntimeClass@2@B ; Ogre::IndexBuffer::m_RTTI
	mov	esp, ebp
	pop	ebp
	ret	0
?getRTTI@IndexBuffer@Ogre@@UBEPBVRuntimeClass@2@XZ ENDP	; Ogre::IndexBuffer::getRTTI
_TEXT	ENDS
PUBLIC	?setVertexRange@IndexBuffer@Ogre@@QAEXII@Z	; Ogre::IndexBuffer::setVertexRange
; Function compile flags: /Odtp
;	COMDAT ?setVertexRange@IndexBuffer@Ogre@@QAEXII@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_start$ = 8						; size = 4
_num$ = 12						; size = 4
?setVertexRange@IndexBuffer@Ogre@@QAEXII@Z PROC		; Ogre::IndexBuffer::setVertexRange, COMDAT
; _this$ = ecx

; 235  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 236  : 			m_RefVertStart = start;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _start$[ebp]
	mov	DWORD PTR [eax+16], ecx

; 237  : 			m_RefVertNum = num;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _num$[ebp]
	mov	DWORD PTR [edx+20], eax

; 238  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?setVertexRange@IndexBuffer@Ogre@@QAEXII@Z ENDP		; Ogre::IndexBuffer::setVertexRange
_TEXT	ENDS
PUBLIC	??_7IndexBuffer@Ogre@@6B@			; Ogre::IndexBuffer::`vftable'
PUBLIC	??0IndexBuffer@Ogre@@QAE@XZ			; Ogre::IndexBuffer::IndexBuffer
PUBLIC	??_R4IndexBuffer@Ogre@@6B@			; Ogre::IndexBuffer::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVIndexBuffer@Ogre@@@8			; Ogre::IndexBuffer `RTTI Type Descriptor'
PUBLIC	??_R3IndexBuffer@Ogre@@8			; Ogre::IndexBuffer::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2IndexBuffer@Ogre@@8			; Ogre::IndexBuffer::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@IndexBuffer@Ogre@@8		; Ogre::IndexBuffer::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_EIndexBuffer@Ogre@@UAEPAXI@Z			; Ogre::IndexBuffer::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@IndexBuffer@Ogre@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@IndexBuffer@Ogre@@8 DD FLAT:??_R0?AVIndexBuffer@Ogre@@@8 ; Ogre::IndexBuffer::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3IndexBuffer@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R2IndexBuffer@Ogre@@8
rdata$r	SEGMENT
??_R2IndexBuffer@Ogre@@8 DD FLAT:??_R1A@?0A@EA@IndexBuffer@Ogre@@8 ; Ogre::IndexBuffer::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@Resource@Ogre@@8
	DD	FLAT:??_R1A@?0A@EA@BaseObject@Ogre@@8
	DD	FLAT:??_R13?0A@EA@MemoryDelegation@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R3IndexBuffer@Ogre@@8
rdata$r	SEGMENT
??_R3IndexBuffer@Ogre@@8 DD 00H				; Ogre::IndexBuffer::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	04H
	DD	FLAT:??_R2IndexBuffer@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVIndexBuffer@Ogre@@@8
_DATA	SEGMENT
??_R0?AVIndexBuffer@Ogre@@@8 DD FLAT:??_7type_info@@6B@	; Ogre::IndexBuffer `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVIndexBuffer@Ogre@@', 00H
_DATA	ENDS
;	COMDAT ??_R4IndexBuffer@Ogre@@6B@
rdata$r	SEGMENT
??_R4IndexBuffer@Ogre@@6B@ DD 00H			; Ogre::IndexBuffer::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVIndexBuffer@Ogre@@@8
	DD	FLAT:??_R3IndexBuffer@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_7IndexBuffer@Ogre@@6B@
CONST	SEGMENT
??_7IndexBuffer@Ogre@@6B@ DD FLAT:??_R4IndexBuffer@Ogre@@6B@ ; Ogre::IndexBuffer::`vftable'
	DD	FLAT:?getRTTI@IndexBuffer@Ogre@@UBEPBVRuntimeClass@2@XZ
	DD	FLAT:?release@Resource@Ogre@@UAEXXZ
	DD	FLAT:?addRef@Resource@Ogre@@UAEXXZ
	DD	FLAT:?getRefCount@Resource@Ogre@@UAEHXZ
	DD	FLAT:?_serialize@BaseObject@Ogre@@UAEXAAVArchive@2@H@Z
	DD	FLAT:??_EIndexBuffer@Ogre@@UAEPAXI@Z
	DD	FLAT:?deleteThis@BaseObject@Ogre@@MAEXXZ
	DD	FLAT:__purecall
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0IndexBuffer@Ogre@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0IndexBuffer@Ogre@@QAE@XZ$0
__ehfuncinfo$??0IndexBuffer@Ogre@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0IndexBuffer@Ogre@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0IndexBuffer@Ogre@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0IndexBuffer@Ogre@@QAE@XZ PROC			; Ogre::IndexBuffer::IndexBuffer, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0IndexBuffer@Ogre@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0Resource@Ogre@@IAE@XZ		; Ogre::Resource::Resource
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7IndexBuffer@Ogre@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0IndexBuffer@Ogre@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1Resource@Ogre@@MAE@XZ		; Ogre::Resource::~Resource
__ehhandler$??0IndexBuffer@Ogre@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0IndexBuffer@Ogre@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0IndexBuffer@Ogre@@QAE@XZ ENDP			; Ogre::IndexBuffer::IndexBuffer
PUBLIC	??1IndexBuffer@Ogre@@UAE@XZ			; Ogre::IndexBuffer::~IndexBuffer
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1IndexBuffer@Ogre@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1IndexBuffer@Ogre@@UAE@XZ$0
__ehfuncinfo$??1IndexBuffer@Ogre@@UAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1IndexBuffer@Ogre@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1IndexBuffer@Ogre@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1IndexBuffer@Ogre@@UAE@XZ PROC			; Ogre::IndexBuffer::~IndexBuffer, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1IndexBuffer@Ogre@@UAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1Resource@Ogre@@MAE@XZ		; Ogre::Resource::~Resource
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1IndexBuffer@Ogre@@UAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1Resource@Ogre@@MAE@XZ		; Ogre::Resource::~Resource
__ehhandler$??1IndexBuffer@Ogre@@UAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1IndexBuffer@Ogre@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1IndexBuffer@Ogre@@UAE@XZ ENDP			; Ogre::IndexBuffer::~IndexBuffer
PUBLIC	??0IndexBuffer@Ogre@@QAE@ABV01@@Z		; Ogre::IndexBuffer::IndexBuffer
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0IndexBuffer@Ogre@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0IndexBuffer@Ogre@@QAE@ABV01@@Z$0
__ehfuncinfo$??0IndexBuffer@Ogre@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0IndexBuffer@Ogre@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0IndexBuffer@Ogre@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0IndexBuffer@Ogre@@QAE@ABV01@@Z PROC			; Ogre::IndexBuffer::IndexBuffer, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0IndexBuffer@Ogre@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0Resource@Ogre@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7IndexBuffer@Ogre@@6B@
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR [edx+16], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR [edx+20], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0IndexBuffer@Ogre@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1Resource@Ogre@@MAE@XZ		; Ogre::Resource::~Resource
__ehhandler$??0IndexBuffer@Ogre@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0IndexBuffer@Ogre@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0IndexBuffer@Ogre@@QAE@ABV01@@Z ENDP			; Ogre::IndexBuffer::IndexBuffer
PUBLIC	??4IndexBuffer@Ogre@@QAEAAV01@ABV01@@Z		; Ogre::IndexBuffer::operator=
; Function compile flags: /Odtp
;	COMDAT ??4IndexBuffer@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4IndexBuffer@Ogre@@QAEAAV01@ABV01@@Z PROC		; Ogre::IndexBuffer::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4Resource@Ogre@@QAEAAV01@ABV01@@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR [ecx+16], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	DWORD PTR [ecx+20], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4IndexBuffer@Ogre@@QAEAAV01@ABV01@@Z ENDP		; Ogre::IndexBuffer::operator=
_TEXT	ENDS
PUBLIC	??_GIndexBuffer@Ogre@@UAEPAXI@Z			; Ogre::IndexBuffer::`scalar deleting destructor'
; Function compile flags: /Odtp
;	COMDAT ??_GIndexBuffer@Ogre@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GIndexBuffer@Ogre@@UAEPAXI@Z PROC			; Ogre::IndexBuffer::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1IndexBuffer@Ogre@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@12
	push	24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3MemoryDelegation@Ogre@@SAXPAXI@Z	; Ogre::MemoryDelegation::operator delete
	add	esp, 8
$LN1@scalar@12:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GIndexBuffer@Ogre@@UAEPAXI@Z ENDP			; Ogre::IndexBuffer::`scalar deleting destructor'
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_EIndexBuffer@Ogre@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_EIndexBuffer@Ogre@@UAEPAXI@Z PROC			; Ogre::IndexBuffer::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 2
	je	SHORT $LN3@vector@12
	push	OFFSET ??1IndexBuffer@Ogre@@UAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx-4]
	push	edx
	push	24					; 00000018H
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??_M@YGXPAXIHP6EX0@Z@Z
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN2@vector@12
	push	24					; 00000018H
	mov	edx, DWORD PTR _this$[ebp]
	sub	edx, 4
	push	edx
	call	??_VMemoryDelegation@Ogre@@SAXPAXI@Z	; Ogre::MemoryDelegation::operator delete[]
	add	esp, 8
$LN2@vector@12:
	mov	eax, DWORD PTR _this$[ebp]
	sub	eax, 4
	jmp	SHORT $LN4@vector@12
$LN3@vector@12:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1IndexBuffer@Ogre@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@vector@12
	push	24					; 00000018H
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3MemoryDelegation@Ogre@@SAXPAXI@Z	; Ogre::MemoryDelegation::operator delete
	add	esp, 8
$LN1@vector@12:
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector@12:
	mov	esp, ebp
	pop	ebp
	ret	4
??_EIndexBuffer@Ogre@@UAEPAXI@Z ENDP			; Ogre::IndexBuffer::`vector deleting destructor'
_TEXT	ENDS
PUBLIC	?getRTTI@Texture@Ogre@@UBEPBVRuntimeClass@2@XZ	; Ogre::Texture::getRTTI
EXTRN	?m_RTTI@Texture@Ogre@@2VRuntimeClass@2@B:BYTE	; Ogre::Texture::m_RTTI
; Function compile flags: /Odtp
;	COMDAT ?getRTTI@Texture@Ogre@@UBEPBVRuntimeClass@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getRTTI@Texture@Ogre@@UBEPBVRuntimeClass@2@XZ PROC	; Ogre::Texture::getRTTI, COMDAT
; _this$ = ecx

; 248  : 		DECLARE_RTTI_VIRTUAL(Texture)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, OFFSET ?m_RTTI@Texture@Ogre@@2VRuntimeClass@2@B ; Ogre::Texture::m_RTTI
	mov	esp, ebp
	pop	ebp
	ret	0
?getRTTI@Texture@Ogre@@UBEPBVRuntimeClass@2@XZ ENDP	; Ogre::Texture::getRTTI
_TEXT	ENDS
PUBLIC	??_7Texture@Ogre@@6B@				; Ogre::Texture::`vftable'
PUBLIC	??1Texture@Ogre@@MAE@XZ				; Ogre::Texture::~Texture
PUBLIC	??_R4Texture@Ogre@@6B@				; Ogre::Texture::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVTexture@Ogre@@@8			; Ogre::Texture `RTTI Type Descriptor'
PUBLIC	??_R3Texture@Ogre@@8				; Ogre::Texture::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2Texture@Ogre@@8				; Ogre::Texture::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@Texture@Ogre@@8			; Ogre::Texture::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_ETexture@Ogre@@MAEPAXI@Z			; Ogre::Texture::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@Texture@Ogre@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@Texture@Ogre@@8 DD FLAT:??_R0?AVTexture@Ogre@@@8 ; Ogre::Texture::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3Texture@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R2Texture@Ogre@@8
rdata$r	SEGMENT
??_R2Texture@Ogre@@8 DD FLAT:??_R1A@?0A@EA@Texture@Ogre@@8 ; Ogre::Texture::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@Resource@Ogre@@8
	DD	FLAT:??_R1A@?0A@EA@BaseObject@Ogre@@8
	DD	FLAT:??_R13?0A@EA@MemoryDelegation@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R3Texture@Ogre@@8
rdata$r	SEGMENT
??_R3Texture@Ogre@@8 DD 00H				; Ogre::Texture::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	04H
	DD	FLAT:??_R2Texture@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVTexture@Ogre@@@8
_DATA	SEGMENT
??_R0?AVTexture@Ogre@@@8 DD FLAT:??_7type_info@@6B@	; Ogre::Texture `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVTexture@Ogre@@', 00H
_DATA	ENDS
;	COMDAT ??_R4Texture@Ogre@@6B@
rdata$r	SEGMENT
??_R4Texture@Ogre@@6B@ DD 00H				; Ogre::Texture::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVTexture@Ogre@@@8
	DD	FLAT:??_R3Texture@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_7Texture@Ogre@@6B@
CONST	SEGMENT
??_7Texture@Ogre@@6B@ DD FLAT:??_R4Texture@Ogre@@6B@	; Ogre::Texture::`vftable'
	DD	FLAT:?getRTTI@Texture@Ogre@@UBEPBVRuntimeClass@2@XZ
	DD	FLAT:?release@Resource@Ogre@@UAEXXZ
	DD	FLAT:?addRef@Resource@Ogre@@UAEXXZ
	DD	FLAT:?getRefCount@Resource@Ogre@@UAEHXZ
	DD	FLAT:?_serialize@BaseObject@Ogre@@UAEXAAVArchive@2@H@Z
	DD	FLAT:??_ETexture@Ogre@@MAEPAXI@Z
	DD	FLAT:?deleteThis@BaseObject@Ogre@@MAEXXZ
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1Texture@Ogre@@MAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1Texture@Ogre@@MAE@XZ$0
__ehfuncinfo$??1Texture@Ogre@@MAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1Texture@Ogre@@MAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1Texture@Ogre@@MAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1Texture@Ogre@@MAE@XZ PROC				; Ogre::Texture::~Texture, COMDAT
; _this$ = ecx

; 257  : 		{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1Texture@Ogre@@MAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7Texture@Ogre@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 258  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1Resource@Ogre@@MAE@XZ		; Ogre::Resource::~Resource
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1Texture@Ogre@@MAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1Resource@Ogre@@MAE@XZ		; Ogre::Resource::~Resource
__ehhandler$??1Texture@Ogre@@MAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1Texture@Ogre@@MAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1Texture@Ogre@@MAE@XZ ENDP				; Ogre::Texture::~Texture
PUBLIC	??0Texture@Ogre@@QAE@XZ				; Ogre::Texture::Texture
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0Texture@Ogre@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0Texture@Ogre@@QAE@XZ$0
__ehfuncinfo$??0Texture@Ogre@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0Texture@Ogre@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0Texture@Ogre@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0Texture@Ogre@@QAE@XZ PROC				; Ogre::Texture::Texture, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0Texture@Ogre@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0Resource@Ogre@@IAE@XZ		; Ogre::Resource::Resource
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7Texture@Ogre@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0Texture@Ogre@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1Resource@Ogre@@MAE@XZ		; Ogre::Resource::~Resource
__ehhandler$??0Texture@Ogre@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0Texture@Ogre@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0Texture@Ogre@@QAE@XZ ENDP				; Ogre::Texture::Texture
PUBLIC	??0Texture@Ogre@@QAE@ABV01@@Z			; Ogre::Texture::Texture
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0Texture@Ogre@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0Texture@Ogre@@QAE@ABV01@@Z$0
__ehfuncinfo$??0Texture@Ogre@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0Texture@Ogre@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0Texture@Ogre@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0Texture@Ogre@@QAE@ABV01@@Z PROC			; Ogre::Texture::Texture, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0Texture@Ogre@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0Resource@Ogre@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7Texture@Ogre@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0Texture@Ogre@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1Resource@Ogre@@MAE@XZ		; Ogre::Resource::~Resource
__ehhandler$??0Texture@Ogre@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0Texture@Ogre@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0Texture@Ogre@@QAE@ABV01@@Z ENDP			; Ogre::Texture::Texture
PUBLIC	??4Texture@Ogre@@QAEAAV01@ABV01@@Z		; Ogre::Texture::operator=
; Function compile flags: /Odtp
;	COMDAT ??4Texture@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4Texture@Ogre@@QAEAAV01@ABV01@@Z PROC			; Ogre::Texture::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4Resource@Ogre@@QAEAAV01@ABV01@@Z
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4Texture@Ogre@@QAEAAV01@ABV01@@Z ENDP			; Ogre::Texture::operator=
_TEXT	ENDS
PUBLIC	??_GTexture@Ogre@@MAEPAXI@Z			; Ogre::Texture::`scalar deleting destructor'
; Function compile flags: /Odtp
;	COMDAT ??_GTexture@Ogre@@MAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GTexture@Ogre@@MAEPAXI@Z PROC			; Ogre::Texture::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1Texture@Ogre@@MAE@XZ			; Ogre::Texture::~Texture
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@13
	push	16					; 00000010H
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3MemoryDelegation@Ogre@@SAXPAXI@Z	; Ogre::MemoryDelegation::operator delete
	add	esp, 8
$LN1@scalar@13:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GTexture@Ogre@@MAEPAXI@Z ENDP			; Ogre::Texture::`scalar deleting destructor'
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_ETexture@Ogre@@MAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_ETexture@Ogre@@MAEPAXI@Z PROC			; Ogre::Texture::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 2
	je	SHORT $LN3@vector@13
	push	OFFSET ??1Texture@Ogre@@MAE@XZ		; Ogre::Texture::~Texture
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx-4]
	push	edx
	push	16					; 00000010H
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??_M@YGXPAXIHP6EX0@Z@Z
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN2@vector@13
	push	16					; 00000010H
	mov	edx, DWORD PTR _this$[ebp]
	sub	edx, 4
	push	edx
	call	??_VMemoryDelegation@Ogre@@SAXPAXI@Z	; Ogre::MemoryDelegation::operator delete[]
	add	esp, 8
$LN2@vector@13:
	mov	eax, DWORD PTR _this$[ebp]
	sub	eax, 4
	jmp	SHORT $LN4@vector@13
$LN3@vector@13:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1Texture@Ogre@@MAE@XZ			; Ogre::Texture::~Texture
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@vector@13
	push	16					; 00000010H
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3MemoryDelegation@Ogre@@SAXPAXI@Z	; Ogre::MemoryDelegation::operator delete
	add	esp, 8
$LN1@vector@13:
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector@13:
	mov	esp, ebp
	pop	ebp
	ret	4
??_ETexture@Ogre@@MAEPAXI@Z ENDP			; Ogre::Texture::`vector deleting destructor'
_TEXT	ENDS
PUBLIC	?getRTTI@RenderableObject@Ogre@@UBEPBVRuntimeClass@2@XZ ; Ogre::RenderableObject::getRTTI
EXTRN	?m_RTTI@RenderableObject@Ogre@@2VRuntimeClass@2@B:BYTE ; Ogre::RenderableObject::m_RTTI
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogrerenderableobject.h
;	COMDAT ?getRTTI@RenderableObject@Ogre@@UBEPBVRuntimeClass@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getRTTI@RenderableObject@Ogre@@UBEPBVRuntimeClass@2@XZ PROC ; Ogre::RenderableObject::getRTTI, COMDAT
; _this$ = ecx

; 23   : 		DECLARE_RTTI_VIRTUAL(RenderableObject)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, OFFSET ?m_RTTI@RenderableObject@Ogre@@2VRuntimeClass@2@B ; Ogre::RenderableObject::m_RTTI
	mov	esp, ebp
	pop	ebp
	ret	0
?getRTTI@RenderableObject@Ogre@@UBEPBVRuntimeClass@2@XZ ENDP ; Ogre::RenderableObject::getRTTI
_TEXT	ENDS
PUBLIC	?enableUVMask@RenderableObject@Ogre@@UAEX_N0@Z	; Ogre::RenderableObject::enableUVMask
; Function compile flags: /Odtp
;	COMDAT ?enableUVMask@RenderableObject@Ogre@@UAEX_N0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_enable$ = 8						; size = 1
_stdmtlUse$ = 12					; size = 1
?enableUVMask@RenderableObject@Ogre@@UAEX_N0@Z PROC	; Ogre::RenderableObject::enableUVMask, COMDAT
; _this$ = ecx

; 27   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 28   : 
; 29   : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?enableUVMask@RenderableObject@Ogre@@UAEX_N0@Z ENDP	; Ogre::RenderableObject::enableUVMask
_TEXT	ENDS
PUBLIC	?setLiuGuangTexture@RenderableObject@Ogre@@UAEXPAVTextureData@2@@Z ; Ogre::RenderableObject::setLiuGuangTexture
; Function compile flags: /Odtp
;	COMDAT ?setLiuGuangTexture@RenderableObject@Ogre@@UAEXPAVTextureData@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_texture$ = 8						; size = 4
?setLiuGuangTexture@RenderableObject@Ogre@@UAEXPAVTextureData@2@@Z PROC ; Ogre::RenderableObject::setLiuGuangTexture, COMDAT
; _this$ = ecx

; 32   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 33   : 
; 34   : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?setLiuGuangTexture@RenderableObject@Ogre@@UAEXPAVTextureData@2@@Z ENDP ; Ogre::RenderableObject::setLiuGuangTexture
_TEXT	ENDS
PUBLIC	?setLiuGuangTexture@RenderableObject@Ogre@@UAEXPBD@Z ; Ogre::RenderableObject::setLiuGuangTexture
; Function compile flags: /Odtp
;	COMDAT ?setLiuGuangTexture@RenderableObject@Ogre@@UAEXPBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_filename$ = 8						; size = 4
?setLiuGuangTexture@RenderableObject@Ogre@@UAEXPBD@Z PROC ; Ogre::RenderableObject::setLiuGuangTexture, COMDAT
; _this$ = ecx

; 37   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 38   : 
; 39   : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?setLiuGuangTexture@RenderableObject@Ogre@@UAEXPBD@Z ENDP ; Ogre::RenderableObject::setLiuGuangTexture
_TEXT	ENDS
PUBLIC	?setLayer@RenderableObject@Ogre@@UAEXW4RenderLayer@2@@Z ; Ogre::RenderableObject::setLayer
; Function compile flags: /Odtp
;	COMDAT ?setLayer@RenderableObject@Ogre@@UAEXW4RenderLayer@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_layer$ = 8						; size = 4
?setLayer@RenderableObject@Ogre@@UAEXW4RenderLayer@2@@Z PROC ; Ogre::RenderableObject::setLayer, COMDAT
; _this$ = ecx

; 47   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 48   : 			m_RenderLayer = layer;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _layer$[ebp]
	mov	DWORD PTR [eax+264], ecx

; 49   : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?setLayer@RenderableObject@Ogre@@UAEXW4RenderLayer@2@@Z ENDP ; Ogre::RenderableObject::setLayer
_TEXT	ENDS
PUBLIC	?BuildDecalMesh@RenderableObject@Ogre@@UAEXABVBoxBound@2@PAVVector3@2@PAGHHAAH3@Z ; Ogre::RenderableObject::BuildDecalMesh
; Function compile flags: /Odtp
;	COMDAT ?BuildDecalMesh@RenderableObject@Ogre@@UAEXABVBoxBound@2@PAVVector3@2@PAGHHAAH3@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_boxbound$ = 8						; size = 4
_pVB$ = 12						; size = 4
_pIB$ = 16						; size = 4
_nVertexBase$ = 20					; size = 4
_nFaceLimit$ = 24					; size = 4
_nVertexCount$ = 28					; size = 4
_nFaceCount$ = 32					; size = 4
?BuildDecalMesh@RenderableObject@Ogre@@UAEXABVBoxBound@2@PAVVector3@2@PAGHHAAH3@Z PROC ; Ogre::RenderableObject::BuildDecalMesh, COMDAT
; _this$ = ecx

; 54   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 55   : 			nVertexCount = 0;

	mov	eax, DWORD PTR _nVertexCount$[ebp]
	mov	DWORD PTR [eax], 0

; 56   : 			nFaceCount = 0;

	mov	ecx, DWORD PTR _nFaceCount$[ebp]
	mov	DWORD PTR [ecx], 0

; 57   : 		}

	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
?BuildDecalMesh@RenderableObject@Ogre@@UAEXABVBoxBound@2@PAVVector3@2@PAGHHAAH3@Z ENDP ; Ogre::RenderableObject::BuildDecalMesh
_TEXT	ENDS
PUBLIC	?getRenderUsageBits@RenderableObject@Ogre@@QAEIXZ ; Ogre::RenderableObject::getRenderUsageBits
; Function compile flags: /Odtp
;	COMDAT ?getRenderUsageBits@RenderableObject@Ogre@@QAEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getRenderUsageBits@RenderableObject@Ogre@@QAEIXZ PROC	; Ogre::RenderableObject::getRenderUsageBits, COMDAT
; _this$ = ecx

; 60   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 61   : 			return m_RenderUsageBits;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+272]

; 62   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?getRenderUsageBits@RenderableObject@Ogre@@QAEIXZ ENDP	; Ogre::RenderableObject::getRenderUsageBits
_TEXT	ENDS
PUBLIC	?addRenderUsageBits@RenderableObject@Ogre@@UAEXW4RenderUsage@2@@Z ; Ogre::RenderableObject::addRenderUsageBits
; Function compile flags: /Odtp
;	COMDAT ?addRenderUsageBits@RenderableObject@Ogre@@UAEXW4RenderUsage@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_usage$ = 8						; size = 4
?addRenderUsageBits@RenderableObject@Ogre@@UAEXW4RenderUsage@2@@Z PROC ; Ogre::RenderableObject::addRenderUsageBits, COMDAT
; _this$ = ecx

; 65   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 66   : 			m_RenderUsageBits |= 1<<usage;

	mov	eax, 1
	mov	ecx, DWORD PTR _usage$[ebp]
	shl	eax, cl
	mov	ecx, DWORD PTR _this$[ebp]
	or	eax, DWORD PTR [ecx+272]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+272], eax

; 67   : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?addRenderUsageBits@RenderableObject@Ogre@@UAEXW4RenderUsage@2@@Z ENDP ; Ogre::RenderableObject::addRenderUsageBits
_TEXT	ENDS
PUBLIC	?clearRenderUsageBits@RenderableObject@Ogre@@UAEXW4RenderUsage@2@@Z ; Ogre::RenderableObject::clearRenderUsageBits
; Function compile flags: /Odtp
;	COMDAT ?clearRenderUsageBits@RenderableObject@Ogre@@UAEXW4RenderUsage@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_usage$ = 8						; size = 4
?clearRenderUsageBits@RenderableObject@Ogre@@UAEXW4RenderUsage@2@@Z PROC ; Ogre::RenderableObject::clearRenderUsageBits, COMDAT
; _this$ = ecx

; 70   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 71   : 			m_RenderUsageBits &= ~(1<<usage);

	mov	eax, 1
	mov	ecx, DWORD PTR _usage$[ebp]
	shl	eax, cl
	not	eax
	mov	ecx, DWORD PTR _this$[ebp]
	and	eax, DWORD PTR [ecx+272]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+272], eax

; 72   : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?clearRenderUsageBits@RenderableObject@Ogre@@UAEXW4RenderUsage@2@@Z ENDP ; Ogre::RenderableObject::clearRenderUsageBits
_TEXT	ENDS
PUBLIC	?getRenderPassRequired@RenderableObject@Ogre@@UAEXAAURenderPassDesc@2@@Z ; Ogre::RenderableObject::getRenderPassRequired
; Function compile flags: /Odtp
;	COMDAT ?getRenderPassRequired@RenderableObject@Ogre@@UAEXAAURenderPassDesc@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_desc$ = 8						; size = 4
?getRenderPassRequired@RenderableObject@Ogre@@UAEXAAURenderPassDesc@2@@Z PROC ; Ogre::RenderableObject::getRenderPassRequired, COMDAT
; _this$ = ecx

; 75   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 76   : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?getRenderPassRequired@RenderableObject@Ogre@@UAEXAAURenderPassDesc@2@@Z ENDP ; Ogre::RenderableObject::getRenderPassRequired
_TEXT	ENDS
PUBLIC	?getUserType@RenderableObject@Ogre@@QAEIXZ	; Ogre::RenderableObject::getUserType
; Function compile flags: /Odtp
;	COMDAT ?getUserType@RenderableObject@Ogre@@QAEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getUserType@RenderableObject@Ogre@@QAEIXZ PROC		; Ogre::RenderableObject::getUserType, COMDAT
; _this$ = ecx

; 79   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 80   : 			return m_UserType;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+268]

; 81   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?getUserType@RenderableObject@Ogre@@QAEIXZ ENDP		; Ogre::RenderableObject::getUserType
_TEXT	ENDS
PUBLIC	?setUserType@RenderableObject@Ogre@@QAEXI@Z	; Ogre::RenderableObject::setUserType
; Function compile flags: /Odtp
;	COMDAT ?setUserType@RenderableObject@Ogre@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_type$ = 8						; size = 4
?setUserType@RenderableObject@Ogre@@QAEXI@Z PROC	; Ogre::RenderableObject::setUserType, COMDAT
; _this$ = ecx

; 84   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 85   : 			m_UserType = type;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _type$[ebp]
	mov	DWORD PTR [eax+268], ecx

; 86   : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?setUserType@RenderableObject@Ogre@@QAEXI@Z ENDP	; Ogre::RenderableObject::setUserType
_TEXT	ENDS
PUBLIC	?setDrawbackScene@RenderableObject@Ogre@@QAEX_N@Z ; Ogre::RenderableObject::setDrawbackScene
; Function compile flags: /Odtp
;	COMDAT ?setDrawbackScene@RenderableObject@Ogre@@QAEX_N@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_useDrawback$ = 8					; size = 1
?setDrawbackScene@RenderableObject@Ogre@@QAEX_N@Z PROC	; Ogre::RenderableObject::setDrawbackScene, COMDAT
; _this$ = ecx

; 89   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 90   : 			m_bUseDrawback = useDrawback;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR _useDrawback$[ebp]
	mov	BYTE PTR [eax+233], cl

; 91   : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?setDrawbackScene@RenderableObject@Ogre@@QAEX_N@Z ENDP	; Ogre::RenderableObject::setDrawbackScene
_TEXT	ENDS
PUBLIC	?isDrawbackScene@RenderableObject@Ogre@@QAE_NXZ	; Ogre::RenderableObject::isDrawbackScene
; Function compile flags: /Odtp
;	COMDAT ?isDrawbackScene@RenderableObject@Ogre@@QAE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?isDrawbackScene@RenderableObject@Ogre@@QAE_NXZ PROC	; Ogre::RenderableObject::isDrawbackScene, COMDAT
; _this$ = ecx

; 94   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 95   : 			return m_bUseDrawback;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+233]

; 96   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?isDrawbackScene@RenderableObject@Ogre@@QAE_NXZ ENDP	; Ogre::RenderableObject::isDrawbackScene
_TEXT	ENDS
PUBLIC	?GetBoxBound@RenderableObject@Ogre@@QAEPAVBoxBound@2@XZ ; Ogre::RenderableObject::GetBoxBound
; Function compile flags: /Odtp
;	COMDAT ?GetBoxBound@RenderableObject@Ogre@@QAEPAVBoxBound@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetBoxBound@RenderableObject@Ogre@@QAEPAVBoxBound@2@XZ PROC ; Ogre::RenderableObject::GetBoxBound, COMDAT
; _this$ = ecx

; 98   : 		BoxBound* GetBoxBound(){return &m_renderBoxBound;}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 236				; 000000ecH
	mov	esp, ebp
	pop	ebp
	ret	0
?GetBoxBound@RenderableObject@Ogre@@QAEPAVBoxBound@2@XZ ENDP ; Ogre::RenderableObject::GetBoxBound
_TEXT	ENDS
PUBLIC	??_7RenderableObject@Ogre@@6B@			; Ogre::RenderableObject::`vftable'
PUBLIC	??0RenderableObject@Ogre@@IAE@XZ		; Ogre::RenderableObject::RenderableObject
PUBLIC	??_R4RenderableObject@Ogre@@6B@			; Ogre::RenderableObject::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVRenderableObject@Ogre@@@8		; Ogre::RenderableObject `RTTI Type Descriptor'
PUBLIC	??_R3RenderableObject@Ogre@@8			; Ogre::RenderableObject::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2RenderableObject@Ogre@@8			; Ogre::RenderableObject::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@RenderableObject@Ogre@@8		; Ogre::RenderableObject::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_ERenderableObject@Ogre@@MAEPAXI@Z		; Ogre::RenderableObject::`vector deleting destructor'
EXTRN	??0MovableObject@Ogre@@QAE@XZ:PROC		; Ogre::MovableObject::MovableObject
EXTRN	?setCanSel@RenderableObject@Ogre@@UAEX_N@Z:PROC	; Ogre::RenderableObject::setCanSel
;	COMDAT ??_R1A@?0A@EA@RenderableObject@Ogre@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@RenderableObject@Ogre@@8 DD FLAT:??_R0?AVRenderableObject@Ogre@@@8 ; Ogre::RenderableObject::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3RenderableObject@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R2RenderableObject@Ogre@@8
rdata$r	SEGMENT
??_R2RenderableObject@Ogre@@8 DD FLAT:??_R1A@?0A@EA@RenderableObject@Ogre@@8 ; Ogre::RenderableObject::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@MovableObject@Ogre@@8
	DD	FLAT:??_R1A@?0A@EA@BaseObject@Ogre@@8
	DD	FLAT:??_R13?0A@EA@MemoryDelegation@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R3RenderableObject@Ogre@@8
rdata$r	SEGMENT
??_R3RenderableObject@Ogre@@8 DD 00H			; Ogre::RenderableObject::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	04H
	DD	FLAT:??_R2RenderableObject@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVRenderableObject@Ogre@@@8
_DATA	SEGMENT
??_R0?AVRenderableObject@Ogre@@@8 DD FLAT:??_7type_info@@6B@ ; Ogre::RenderableObject `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVRenderableObject@Ogre@@', 00H
_DATA	ENDS
;	COMDAT ??_R4RenderableObject@Ogre@@6B@
rdata$r	SEGMENT
??_R4RenderableObject@Ogre@@6B@ DD 00H			; Ogre::RenderableObject::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVRenderableObject@Ogre@@@8
	DD	FLAT:??_R3RenderableObject@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_7RenderableObject@Ogre@@6B@
CONST	SEGMENT
??_7RenderableObject@Ogre@@6B@ DD FLAT:??_R4RenderableObject@Ogre@@6B@ ; Ogre::RenderableObject::`vftable'
	DD	FLAT:?getRTTI@RenderableObject@Ogre@@UBEPBVRuntimeClass@2@XZ
	DD	FLAT:?release@BaseObject@Ogre@@UAEXXZ
	DD	FLAT:?addRef@BaseObject@Ogre@@UAEXXZ
	DD	FLAT:?getRefCount@BaseObject@Ogre@@UAEHXZ
	DD	FLAT:?_serialize@BaseObject@Ogre@@UAEXAAVArchive@2@H@Z
	DD	FLAT:??_ERenderableObject@Ogre@@MAEPAXI@Z
	DD	FLAT:?deleteThis@BaseObject@Ogre@@MAEXXZ
	DD	FLAT:?enableUVMask@RenderableObject@Ogre@@UAEX_N0@Z
	DD	FLAT:?setLiuGuangTexture@RenderableObject@Ogre@@UAEXPBD@Z
	DD	FLAT:?setLiuGuangTexture@RenderableObject@Ogre@@UAEXPAVTextureData@2@@Z
	DD	FLAT:?SetForceShadowMapCull@MovableObject@Ogre@@UAEX_N@Z
	DD	FLAT:?update@MovableObject@Ogre@@UAEXI@Z
	DD	FLAT:?resetUpdate@MovableObject@Ogre@@UAEX_NI@Z
	DD	FLAT:?attachToScene@MovableObject@Ogre@@UAEXPAVGameScene@2@_N@Z
	DD	FLAT:?detachFromScene@MovableObject@Ogre@@UAEXXZ
	DD	FLAT:?intersectRay@MovableObject@Ogre@@UAE_NW4IntersectType@2@ABVRay@2@PAM@Z
	DD	FLAT:?getAnchorWorldMatrix@MovableObject@Ogre@@UAE?AVMatrix4@2@H@Z
	DD	FLAT:?invalidWorldCache@MovableObject@Ogre@@UAEXXZ
	DD	FLAT:?updateWorldCache@MovableObject@Ogre@@UAEXXZ
	DD	FLAT:__purecall
	DD	FLAT:?setCanSel@RenderableObject@Ogre@@UAEX_N@Z
	DD	FLAT:?setLayer@RenderableObject@Ogre@@UAEXW4RenderLayer@2@@Z
	DD	FLAT:?BuildDecalMesh@RenderableObject@Ogre@@UAEXABVBoxBound@2@PAVVector3@2@PAGHHAAH3@Z
	DD	FLAT:?addRenderUsageBits@RenderableObject@Ogre@@UAEXW4RenderUsage@2@@Z
	DD	FLAT:?clearRenderUsageBits@RenderableObject@Ogre@@UAEXW4RenderUsage@2@@Z
	DD	FLAT:?getRenderPassRequired@RenderableObject@Ogre@@UAEXAAURenderPassDesc@2@@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0RenderableObject@Ogre@@IAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0RenderableObject@Ogre@@IAE@XZ$0
__ehfuncinfo$??0RenderableObject@Ogre@@IAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0RenderableObject@Ogre@@IAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0RenderableObject@Ogre@@IAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0RenderableObject@Ogre@@IAE@XZ PROC			; Ogre::RenderableObject::RenderableObject, COMDAT
; _this$ = ecx

; 112  : 		{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0RenderableObject@Ogre@@IAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0MovableObject@Ogre@@QAE@XZ		; Ogre::MovableObject::MovableObject
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7RenderableObject@Ogre@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 236				; 000000ecH
	call	??0BoxBound@Ogre@@QAE@XZ		; Ogre::BoxBound::BoxBound
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+264], 2
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+268], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+276], 0

; 113  : 			m_numpointlight	= 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+212], 0

; 114  : 			m_RenderUsageBits = (1<<RU_UI)|(1<<RU_GENERAL);

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+272], 3

; 115  : 
; 116  : 			m_bBakeStaticLight = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+232], 0

; 117  : 			m_bUseDrawback = false;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+233], 0

; 118  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0RenderableObject@Ogre@@IAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1MovableObject@Ogre@@UAE@XZ		; Ogre::MovableObject::~MovableObject
__ehhandler$??0RenderableObject@Ogre@@IAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0RenderableObject@Ogre@@IAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0RenderableObject@Ogre@@IAE@XZ ENDP			; Ogre::RenderableObject::RenderableObject
PUBLIC	??1RenderableObject@Ogre@@MAE@XZ		; Ogre::RenderableObject::~RenderableObject
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1RenderableObject@Ogre@@MAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1RenderableObject@Ogre@@MAE@XZ$0
__ehfuncinfo$??1RenderableObject@Ogre@@MAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1RenderableObject@Ogre@@MAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1RenderableObject@Ogre@@MAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1RenderableObject@Ogre@@MAE@XZ PROC			; Ogre::RenderableObject::~RenderableObject, COMDAT
; _this$ = ecx

; 121  : 		{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1RenderableObject@Ogre@@MAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7RenderableObject@Ogre@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 122  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1MovableObject@Ogre@@UAE@XZ		; Ogre::MovableObject::~MovableObject
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1RenderableObject@Ogre@@MAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1MovableObject@Ogre@@UAE@XZ		; Ogre::MovableObject::~MovableObject
__ehhandler$??1RenderableObject@Ogre@@MAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1RenderableObject@Ogre@@MAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1RenderableObject@Ogre@@MAE@XZ ENDP			; Ogre::RenderableObject::~RenderableObject
PUBLIC	??0RenderableObject@Ogre@@QAE@ABV01@@Z		; Ogre::RenderableObject::RenderableObject
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0RenderableObject@Ogre@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0RenderableObject@Ogre@@QAE@ABV01@@Z$0
__ehfuncinfo$??0RenderableObject@Ogre@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0RenderableObject@Ogre@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0RenderableObject@Ogre@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0RenderableObject@Ogre@@QAE@ABV01@@Z PROC		; Ogre::RenderableObject::RenderableObject, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0RenderableObject@Ogre@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0MovableObject@Ogre@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7RenderableObject@Ogre@@6B@
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+212]
	mov	DWORD PTR [edx+212], ecx
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 216				; 000000d8H
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 216				; 000000d8H
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR [edx+12]
	mov	DWORD PTR [eax+12], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	dl, BYTE PTR [ecx+232]
	mov	BYTE PTR [eax+232], dl
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	dl, BYTE PTR [ecx+233]
	mov	BYTE PTR [eax+233], dl
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 236				; 000000ecH
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 236				; 000000ecH
	call	??0BoxBound@Ogre@@QAE@ABV01@@Z		; Ogre::BoxBound::BoxBound
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+264]
	mov	DWORD PTR [ecx+264], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+268]
	mov	DWORD PTR [ecx+268], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+272]
	mov	DWORD PTR [ecx+272], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	al, BYTE PTR [edx+276]
	mov	BYTE PTR [ecx+276], al
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0RenderableObject@Ogre@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1MovableObject@Ogre@@UAE@XZ		; Ogre::MovableObject::~MovableObject
__ehhandler$??0RenderableObject@Ogre@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0RenderableObject@Ogre@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0RenderableObject@Ogre@@QAE@ABV01@@Z ENDP		; Ogre::RenderableObject::RenderableObject
PUBLIC	??4RenderableObject@Ogre@@QAEAAV01@ABV01@@Z	; Ogre::RenderableObject::operator=
; Function compile flags: /Odtp
;	COMDAT ??4RenderableObject@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_$S1$59287 = -4						; size = 4
___that$ = 8						; size = 4
??4RenderableObject@Ogre@@QAEAAV01@ABV01@@Z PROC	; Ogre::RenderableObject::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4MovableObject@Ogre@@QAEAAV01@ABV01@@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+212]
	mov	DWORD PTR [ecx+212], eax
	mov	DWORD PTR _$S1$59287[ebp], 0
	jmp	SHORT $LN3@operator@6
$LN2@operator@6:
	mov	ecx, DWORD PTR _$S1$59287[ebp]
	add	ecx, 1
	mov	DWORD PTR _$S1$59287[ebp], ecx
$LN3@operator@6:
	cmp	DWORD PTR _$S1$59287[ebp], 4
	jae	SHORT $LN1@operator@6
	mov	edx, DWORD PTR _$S1$59287[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _$S1$59287[ebp]
	mov	esi, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [esi+ecx*4+216]
	mov	DWORD PTR [eax+edx*4+216], ecx
	jmp	SHORT $LN2@operator@6
$LN1@operator@6:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	cl, BYTE PTR [eax+232]
	mov	BYTE PTR [edx+232], cl
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	cl, BYTE PTR [eax+233]
	mov	BYTE PTR [edx+233], cl
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 236				; 000000ecH
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 236				; 000000ecH
	call	??4BoxBound@Ogre@@QAEAAV01@ABV01@@Z
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+264]
	mov	DWORD PTR [eax+264], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+268]
	mov	DWORD PTR [eax+268], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+272]
	mov	DWORD PTR [eax+272], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	dl, BYTE PTR [ecx+276]
	mov	BYTE PTR [eax+276], dl
	mov	eax, DWORD PTR _this$[ebp]
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
??4RenderableObject@Ogre@@QAEAAV01@ABV01@@Z ENDP	; Ogre::RenderableObject::operator=
_TEXT	ENDS
PUBLIC	??_GRenderableObject@Ogre@@MAEPAXI@Z		; Ogre::RenderableObject::`scalar deleting destructor'
; Function compile flags: /Odtp
;	COMDAT ??_GRenderableObject@Ogre@@MAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GRenderableObject@Ogre@@MAEPAXI@Z PROC		; Ogre::RenderableObject::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1RenderableObject@Ogre@@MAE@XZ	; Ogre::RenderableObject::~RenderableObject
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@14
	push	280					; 00000118H
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3MemoryDelegation@Ogre@@SAXPAXI@Z	; Ogre::MemoryDelegation::operator delete
	add	esp, 8
$LN1@scalar@14:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GRenderableObject@Ogre@@MAEPAXI@Z ENDP		; Ogre::RenderableObject::`scalar deleting destructor'
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_ERenderableObject@Ogre@@MAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_ERenderableObject@Ogre@@MAEPAXI@Z PROC		; Ogre::RenderableObject::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 2
	je	SHORT $LN3@vector@14
	push	OFFSET ??1RenderableObject@Ogre@@MAE@XZ	; Ogre::RenderableObject::~RenderableObject
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx-4]
	push	edx
	push	280					; 00000118H
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??_M@YGXPAXIHP6EX0@Z@Z
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN2@vector@14
	push	280					; 00000118H
	mov	edx, DWORD PTR _this$[ebp]
	sub	edx, 4
	push	edx
	call	??_VMemoryDelegation@Ogre@@SAXPAXI@Z	; Ogre::MemoryDelegation::operator delete[]
	add	esp, 8
$LN2@vector@14:
	mov	eax, DWORD PTR _this$[ebp]
	sub	eax, 4
	jmp	SHORT $LN4@vector@14
$LN3@vector@14:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1RenderableObject@Ogre@@MAE@XZ	; Ogre::RenderableObject::~RenderableObject
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@vector@14
	push	280					; 00000118H
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3MemoryDelegation@Ogre@@SAXPAXI@Z	; Ogre::MemoryDelegation::operator delete
	add	esp, 8
$LN1@vector@14:
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector@14:
	mov	esp, ebp
	pop	ebp
	ret	4
??_ERenderableObject@Ogre@@MAEPAXI@Z ENDP		; Ogre::RenderableObject::`vector deleting destructor'
_TEXT	ENDS
PUBLIC	??0ColourValue@Ogre@@QAE@MMMM@Z			; Ogre::ColourValue::ColourValue
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogrecolourvalue.h
;	COMDAT ??0ColourValue@Ogre@@QAE@MMMM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_red$ = 8						; size = 4
_green$ = 12						; size = 4
_blue$ = 16						; size = 4
_alpha$ = 20						; size = 4
??0ColourValue@Ogre@@QAE@MMMM@Z PROC			; Ogre::ColourValue::ColourValue, COMDAT
; _this$ = ecx

; 68   : 		{ }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR _red$[ebp]
	fstp	DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _green$[ebp]
	fstp	DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _blue$[ebp]
	fstp	DWORD PTR [edx+8]
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR _alpha$[ebp]
	fstp	DWORD PTR [eax+12]
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
??0ColourValue@Ogre@@QAE@MMMM@Z ENDP			; Ogre::ColourValue::ColourValue
_TEXT	ENDS
PUBLIC	?set@ColourValue@Ogre@@QAEXMMMM@Z		; Ogre::ColourValue::set
; Function compile flags: /Odtp
;	COMDAT ?set@ColourValue@Ogre@@QAEXMMMM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_red$ = 8						; size = 4
_green$ = 12						; size = 4
_blue$ = 16						; size = 4
_alpha$ = 20						; size = 4
?set@ColourValue@Ogre@@QAEXMMMM@Z PROC			; Ogre::ColourValue::set, COMDAT
; _this$ = ecx

; 76   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 77   : 			r	= red;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR _red$[ebp]
	fstp	DWORD PTR [eax]

; 78   : 			g	= green;

	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _green$[ebp]
	fstp	DWORD PTR [ecx+4]

; 79   : 			b	= blue;

	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _blue$[ebp]
	fstp	DWORD PTR [edx+8]

; 80   : 			a	= alpha;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR _alpha$[ebp]
	fstp	DWORD PTR [eax+12]

; 81   : 		}

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?set@ColourValue@Ogre@@QAEXMMMM@Z ENDP			; Ogre::ColourValue::set
_TEXT	ENDS
PUBLIC	__real@3ff0000000000000
PUBLIC	__real@0000000000000000
PUBLIC	?saturate@ColourValue@Ogre@@QAEXXZ		; Ogre::ColourValue::saturate
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ?saturate@ColourValue@Ogre@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?saturate@ColourValue@Ogre@@QAEXXZ PROC			; Ogre::ColourValue::saturate, COMDAT
; _this$ = ecx

; 117  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 118  : 			if (r < 0)

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax]
	fcomp	QWORD PTR __real@0000000000000000
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN12@saturate

; 119  : 				r = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	fldz
	fstp	DWORD PTR [ecx]
	jmp	SHORT $LN10@saturate
$LN12@saturate:

; 120  : 			else if (r > 1)

	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx]
	fcomp	QWORD PTR __real@3ff0000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN10@saturate

; 121  : 				r = 1;

	mov	eax, DWORD PTR _this$[ebp]
	fld1
	fstp	DWORD PTR [eax]
$LN10@saturate:

; 122  : 
; 123  : 			if (g < 0)

	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+4]
	fcomp	QWORD PTR __real@0000000000000000
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN9@saturate

; 124  : 				g = 0;

	mov	edx, DWORD PTR _this$[ebp]
	fldz
	fstp	DWORD PTR [edx+4]
	jmp	SHORT $LN7@saturate
$LN9@saturate:

; 125  : 			else if (g > 1)

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+4]
	fcomp	QWORD PTR __real@3ff0000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN7@saturate

; 126  : 				g = 1;

	mov	ecx, DWORD PTR _this$[ebp]
	fld1
	fstp	DWORD PTR [ecx+4]
$LN7@saturate:

; 127  : 
; 128  : 			if (b < 0)

	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+8]
	fcomp	QWORD PTR __real@0000000000000000
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN6@saturate

; 129  : 				b = 0;

	mov	eax, DWORD PTR _this$[ebp]
	fldz
	fstp	DWORD PTR [eax+8]
	jmp	SHORT $LN4@saturate
$LN6@saturate:

; 130  : 			else if (b > 1)

	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+8]
	fcomp	QWORD PTR __real@3ff0000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN4@saturate

; 131  : 				b = 1;

	mov	edx, DWORD PTR _this$[ebp]
	fld1
	fstp	DWORD PTR [edx+8]
$LN4@saturate:

; 132  : 
; 133  : 			if (a < 0)

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+12]
	fcomp	QWORD PTR __real@0000000000000000
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN3@saturate

; 134  : 				a = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	fldz
	fstp	DWORD PTR [ecx+12]
	jmp	SHORT $LN1@saturate
$LN3@saturate:

; 135  : 			else if (a > 1)

	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+12]
	fcomp	QWORD PTR __real@3ff0000000000000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN1@saturate

; 136  : 				a = 1;

	mov	eax, DWORD PTR _this$[ebp]
	fld1
	fstp	DWORD PTR [eax+12]
$LN1@saturate:

; 137  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?saturate@ColourValue@Ogre@@QAEXXZ ENDP			; Ogre::ColourValue::saturate
_TEXT	ENDS
PUBLIC	?saturateCopy@ColourValue@Ogre@@QBE?AV12@XZ	; Ogre::ColourValue::saturateCopy
; Function compile flags: /Odtp
;	COMDAT ?saturateCopy@ColourValue@Ogre@@QBE?AV12@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
_ret$ = -16						; size = 16
___$ReturnUdt$ = 8					; size = 4
?saturateCopy@ColourValue@Ogre@@QBE?AV12@XZ PROC	; Ogre::ColourValue::saturateCopy, COMDAT
; _this$ = ecx

; 142  : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 143  : 			ColourValue ret = *this;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _ret$[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _ret$[ebp+4], edx
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _ret$[ebp+8], ecx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR _ret$[ebp+12], edx

; 144  : 			ret.saturate();

	lea	ecx, DWORD PTR _ret$[ebp]
	call	?saturate@ColourValue@Ogre@@QAEXXZ	; Ogre::ColourValue::saturate

; 145  : 			return ret;

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR _ret$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _ret$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _ret$[ebp+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR _ret$[ebp+12]
	mov	DWORD PTR [eax+12], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 146  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?saturateCopy@ColourValue@Ogre@@QBE?AV12@XZ ENDP	; Ogre::ColourValue::saturateCopy
_TEXT	ENDS
PUBLIC	??AColourValue@Ogre@@QBEMI@Z			; Ogre::ColourValue::operator[]
; Function compile flags: /Odtp
;	COMDAT ??AColourValue@Ogre@@QBEMI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_i$ = 8							; size = 4
??AColourValue@Ogre@@QBEMI@Z PROC			; Ogre::ColourValue::operator[], COMDAT
; _this$ = ecx

; 150  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 151  : 			assert( i < 4 );
; 152  : 
; 153  : 			return *(&r+i);

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+eax*4]

; 154  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??AColourValue@Ogre@@QBEMI@Z ENDP			; Ogre::ColourValue::operator[]
_TEXT	ENDS
PUBLIC	??AColourValue@Ogre@@QAEAAMI@Z			; Ogre::ColourValue::operator[]
; Function compile flags: /Odtp
;	COMDAT ??AColourValue@Ogre@@QAEAAMI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_i$ = 8							; size = 4
??AColourValue@Ogre@@QAEAAMI@Z PROC			; Ogre::ColourValue::operator[], COMDAT
; _this$ = ecx

; 158  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 159  : 			assert( i < 4 );
; 160  : 
; 161  : 			return *(&r+i);

	mov	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	lea	eax, DWORD PTR [ecx+eax*4]

; 162  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??AColourValue@Ogre@@QAEAAMI@Z ENDP			; Ogre::ColourValue::operator[]
_TEXT	ENDS
PUBLIC	?ptr@ColourValue@Ogre@@QAEPAMXZ			; Ogre::ColourValue::ptr
; Function compile flags: /Odtp
;	COMDAT ?ptr@ColourValue@Ogre@@QAEPAMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ptr@ColourValue@Ogre@@QAEPAMXZ PROC			; Ogre::ColourValue::ptr, COMDAT
; _this$ = ecx

; 166  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 167  : 			return &r;

	mov	eax, DWORD PTR _this$[ebp]

; 168  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?ptr@ColourValue@Ogre@@QAEPAMXZ ENDP			; Ogre::ColourValue::ptr
_TEXT	ENDS
PUBLIC	?ptr@ColourValue@Ogre@@QBEPBMXZ			; Ogre::ColourValue::ptr
; Function compile flags: /Odtp
;	COMDAT ?ptr@ColourValue@Ogre@@QBEPBMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ptr@ColourValue@Ogre@@QBEPBMXZ PROC			; Ogre::ColourValue::ptr, COMDAT
; _this$ = ecx

; 171  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 172  : 			return &r;

	mov	eax, DWORD PTR _this$[ebp]

; 173  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?ptr@ColourValue@Ogre@@QBEPBMXZ ENDP			; Ogre::ColourValue::ptr
_TEXT	ENDS
PUBLIC	??HColourValue@Ogre@@QBE?AV01@ABV01@@Z		; Ogre::ColourValue::operator+
; Function compile flags: /Odtp
;	COMDAT ??HColourValue@Ogre@@QBE?AV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
_kSum$ = -16						; size = 16
___$ReturnUdt$ = 8					; size = 4
_rkVector$ = 12						; size = 4
??HColourValue@Ogre@@QBE?AV01@ABV01@@Z PROC		; Ogre::ColourValue::operator+, COMDAT
; _this$ = ecx

; 178  : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 179  : 			ColourValue kSum;

	push	ecx
	fld1
	fstp	DWORD PTR [esp]
	push	ecx
	fld1
	fstp	DWORD PTR [esp]
	push	ecx
	fld1
	fstp	DWORD PTR [esp]
	push	ecx
	fld1
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR _kSum$[ebp]
	call	??0ColourValue@Ogre@@QAE@MMMM@Z		; Ogre::ColourValue::ColourValue

; 180  : 
; 181  : 			kSum.r = r + rkVector.r;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax]
	mov	ecx, DWORD PTR _rkVector$[ebp]
	fadd	DWORD PTR [ecx]
	fstp	DWORD PTR _kSum$[ebp]

; 182  : 			kSum.g = g + rkVector.g;

	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+4]
	mov	eax, DWORD PTR _rkVector$[ebp]
	fadd	DWORD PTR [eax+4]
	fstp	DWORD PTR _kSum$[ebp+4]

; 183  : 			kSum.b = b + rkVector.b;

	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _rkVector$[ebp]
	fadd	DWORD PTR [edx+8]
	fstp	DWORD PTR _kSum$[ebp+8]

; 184  : 			kSum.a = a + rkVector.a;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+12]
	mov	ecx, DWORD PTR _rkVector$[ebp]
	fadd	DWORD PTR [ecx+12]
	fstp	DWORD PTR _kSum$[ebp+12]

; 185  : 
; 186  : 			return kSum;

	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR _kSum$[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR _kSum$[ebp+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR _kSum$[ebp+8]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR _kSum$[ebp+12]
	mov	DWORD PTR [edx+12], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 187  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
??HColourValue@Ogre@@QBE?AV01@ABV01@@Z ENDP		; Ogre::ColourValue::operator+
_TEXT	ENDS
PUBLIC	??GColourValue@Ogre@@QBE?AV01@ABV01@@Z		; Ogre::ColourValue::operator-
; Function compile flags: /Odtp
;	COMDAT ??GColourValue@Ogre@@QBE?AV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
_kDiff$ = -16						; size = 16
___$ReturnUdt$ = 8					; size = 4
_rkVector$ = 12						; size = 4
??GColourValue@Ogre@@QBE?AV01@ABV01@@Z PROC		; Ogre::ColourValue::operator-, COMDAT
; _this$ = ecx

; 190  : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 191  : 			ColourValue kDiff;

	push	ecx
	fld1
	fstp	DWORD PTR [esp]
	push	ecx
	fld1
	fstp	DWORD PTR [esp]
	push	ecx
	fld1
	fstp	DWORD PTR [esp]
	push	ecx
	fld1
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR _kDiff$[ebp]
	call	??0ColourValue@Ogre@@QAE@MMMM@Z		; Ogre::ColourValue::ColourValue

; 192  : 
; 193  : 			kDiff.r = r - rkVector.r;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax]
	mov	ecx, DWORD PTR _rkVector$[ebp]
	fsub	DWORD PTR [ecx]
	fstp	DWORD PTR _kDiff$[ebp]

; 194  : 			kDiff.g = g - rkVector.g;

	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+4]
	mov	eax, DWORD PTR _rkVector$[ebp]
	fsub	DWORD PTR [eax+4]
	fstp	DWORD PTR _kDiff$[ebp+4]

; 195  : 			kDiff.b = b - rkVector.b;

	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _rkVector$[ebp]
	fsub	DWORD PTR [edx+8]
	fstp	DWORD PTR _kDiff$[ebp+8]

; 196  : 			kDiff.a = a - rkVector.a;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+12]
	mov	ecx, DWORD PTR _rkVector$[ebp]
	fsub	DWORD PTR [ecx+12]
	fstp	DWORD PTR _kDiff$[ebp+12]

; 197  : 
; 198  : 			return kDiff;

	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR _kDiff$[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR _kDiff$[ebp+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR _kDiff$[ebp+8]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR _kDiff$[ebp+12]
	mov	DWORD PTR [edx+12], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 199  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
??GColourValue@Ogre@@QBE?AV01@ABV01@@Z ENDP		; Ogre::ColourValue::operator-
_TEXT	ENDS
PUBLIC	??DColourValue@Ogre@@QBE?AV01@M@Z		; Ogre::ColourValue::operator*
; Function compile flags: /Odtp
;	COMDAT ??DColourValue@Ogre@@QBE?AV01@M@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
_kProd$ = -16						; size = 16
___$ReturnUdt$ = 8					; size = 4
_fScalar$ = 12						; size = 4
??DColourValue@Ogre@@QBE?AV01@M@Z PROC			; Ogre::ColourValue::operator*, COMDAT
; _this$ = ecx

; 202  : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 203  : 			ColourValue kProd;

	push	ecx
	fld1
	fstp	DWORD PTR [esp]
	push	ecx
	fld1
	fstp	DWORD PTR [esp]
	push	ecx
	fld1
	fstp	DWORD PTR [esp]
	push	ecx
	fld1
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR _kProd$[ebp]
	call	??0ColourValue@Ogre@@QAE@MMMM@Z		; Ogre::ColourValue::ColourValue

; 204  : 
; 205  : 			kProd.r = fScalar*r;

	fld	DWORD PTR _fScalar$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	fmul	DWORD PTR [eax]
	fstp	DWORD PTR _kProd$[ebp]

; 206  : 			kProd.g = fScalar*g;

	fld	DWORD PTR _fScalar$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	fmul	DWORD PTR [ecx+4]
	fstp	DWORD PTR _kProd$[ebp+4]

; 207  : 			kProd.b = fScalar*b;

	fld	DWORD PTR _fScalar$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	fmul	DWORD PTR [edx+8]
	fstp	DWORD PTR _kProd$[ebp+8]

; 208  : 			kProd.a = fScalar*a;

	fld	DWORD PTR _fScalar$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	fmul	DWORD PTR [eax+12]
	fstp	DWORD PTR _kProd$[ebp+12]

; 209  : 
; 210  : 			return kProd;

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	edx, DWORD PTR _kProd$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR _kProd$[ebp+4]
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR _kProd$[ebp+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR _kProd$[ebp+12]
	mov	DWORD PTR [ecx+12], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 211  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
??DColourValue@Ogre@@QBE?AV01@M@Z ENDP			; Ogre::ColourValue::operator*
_TEXT	ENDS
PUBLIC	??DColourValue@Ogre@@QBE?AV01@ABV01@@Z		; Ogre::ColourValue::operator*
; Function compile flags: /Odtp
;	COMDAT ??DColourValue@Ogre@@QBE?AV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
_kProd$ = -16						; size = 16
___$ReturnUdt$ = 8					; size = 4
_rhs$ = 12						; size = 4
??DColourValue@Ogre@@QBE?AV01@ABV01@@Z PROC		; Ogre::ColourValue::operator*, COMDAT
; _this$ = ecx

; 214  : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 215  : 			ColourValue kProd;

	push	ecx
	fld1
	fstp	DWORD PTR [esp]
	push	ecx
	fld1
	fstp	DWORD PTR [esp]
	push	ecx
	fld1
	fstp	DWORD PTR [esp]
	push	ecx
	fld1
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR _kProd$[ebp]
	call	??0ColourValue@Ogre@@QAE@MMMM@Z		; Ogre::ColourValue::ColourValue

; 216  : 
; 217  : 			kProd.r = rhs.r * r;

	mov	eax, DWORD PTR _rhs$[ebp]
	fld	DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	fmul	DWORD PTR [ecx]
	fstp	DWORD PTR _kProd$[ebp]

; 218  : 			kProd.g = rhs.g * g;

	mov	edx, DWORD PTR _rhs$[ebp]
	fld	DWORD PTR [edx+4]
	mov	eax, DWORD PTR _this$[ebp]
	fmul	DWORD PTR [eax+4]
	fstp	DWORD PTR _kProd$[ebp+4]

; 219  : 			kProd.b = rhs.b * b;

	mov	ecx, DWORD PTR _rhs$[ebp]
	fld	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _this$[ebp]
	fmul	DWORD PTR [edx+8]
	fstp	DWORD PTR _kProd$[ebp+8]

; 220  : 			kProd.a = rhs.a * a;

	mov	eax, DWORD PTR _rhs$[ebp]
	fld	DWORD PTR [eax+12]
	mov	ecx, DWORD PTR _this$[ebp]
	fmul	DWORD PTR [ecx+12]
	fstp	DWORD PTR _kProd$[ebp+12]

; 221  : 
; 222  : 			return kProd;

	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR _kProd$[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR _kProd$[ebp+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR _kProd$[ebp+8]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR _kProd$[ebp+12]
	mov	DWORD PTR [edx+12], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 223  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
??DColourValue@Ogre@@QBE?AV01@ABV01@@Z ENDP		; Ogre::ColourValue::operator*
_TEXT	ENDS
PUBLIC	??KColourValue@Ogre@@QBE?AV01@ABV01@@Z		; Ogre::ColourValue::operator/
; Function compile flags: /Odtp
;	COMDAT ??KColourValue@Ogre@@QBE?AV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
_kProd$ = -16						; size = 16
___$ReturnUdt$ = 8					; size = 4
_rhs$ = 12						; size = 4
??KColourValue@Ogre@@QBE?AV01@ABV01@@Z PROC		; Ogre::ColourValue::operator/, COMDAT
; _this$ = ecx

; 226  : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 227  : 			ColourValue kProd;

	push	ecx
	fld1
	fstp	DWORD PTR [esp]
	push	ecx
	fld1
	fstp	DWORD PTR [esp]
	push	ecx
	fld1
	fstp	DWORD PTR [esp]
	push	ecx
	fld1
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR _kProd$[ebp]
	call	??0ColourValue@Ogre@@QAE@MMMM@Z		; Ogre::ColourValue::ColourValue

; 228  : 
; 229  : 			kProd.r = rhs.r / r;

	mov	eax, DWORD PTR _rhs$[ebp]
	fld	DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	fdiv	DWORD PTR [ecx]
	fstp	DWORD PTR _kProd$[ebp]

; 230  : 			kProd.g = rhs.g / g;

	mov	edx, DWORD PTR _rhs$[ebp]
	fld	DWORD PTR [edx+4]
	mov	eax, DWORD PTR _this$[ebp]
	fdiv	DWORD PTR [eax+4]
	fstp	DWORD PTR _kProd$[ebp+4]

; 231  : 			kProd.b = rhs.b / b;

	mov	ecx, DWORD PTR _rhs$[ebp]
	fld	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _this$[ebp]
	fdiv	DWORD PTR [edx+8]
	fstp	DWORD PTR _kProd$[ebp+8]

; 232  : 			kProd.a = rhs.a / a;

	mov	eax, DWORD PTR _rhs$[ebp]
	fld	DWORD PTR [eax+12]
	mov	ecx, DWORD PTR _this$[ebp]
	fdiv	DWORD PTR [ecx+12]
	fstp	DWORD PTR _kProd$[ebp+12]

; 233  : 
; 234  : 			return kProd;

	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR _kProd$[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR _kProd$[ebp+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR _kProd$[ebp+8]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR _kProd$[ebp+12]
	mov	DWORD PTR [edx+12], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 235  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
??KColourValue@Ogre@@QBE?AV01@ABV01@@Z ENDP		; Ogre::ColourValue::operator/
_TEXT	ENDS
PUBLIC	??KColourValue@Ogre@@QBE?AV01@M@Z		; Ogre::ColourValue::operator/
; Function compile flags: /Odtp
;	COMDAT ??KColourValue@Ogre@@QBE?AV01@M@Z
_TEXT	SEGMENT
_this$ = -24						; size = 4
_kDiv$ = -20						; size = 16
_fInv$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_fScalar$ = 12						; size = 4
??KColourValue@Ogre@@QBE?AV01@M@Z PROC			; Ogre::ColourValue::operator/, COMDAT
; _this$ = ecx

; 238  : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 239  : 			assert( fScalar != 0.0f );
; 240  : 
; 241  : 			ColourValue kDiv;

	push	ecx
	fld1
	fstp	DWORD PTR [esp]
	push	ecx
	fld1
	fstp	DWORD PTR [esp]
	push	ecx
	fld1
	fstp	DWORD PTR [esp]
	push	ecx
	fld1
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR _kDiv$[ebp]
	call	??0ColourValue@Ogre@@QAE@MMMM@Z		; Ogre::ColourValue::ColourValue

; 242  : 
; 243  : 			float fInv = 1.0f / fScalar;

	fld	DWORD PTR _fScalar$[ebp]
	fld1
	fdivrp	ST(1), ST(0)
	fstp	DWORD PTR _fInv$[ebp]

; 244  : 			kDiv.r = r * fInv;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax]
	fmul	DWORD PTR _fInv$[ebp]
	fstp	DWORD PTR _kDiv$[ebp]

; 245  : 			kDiv.g = g * fInv;

	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+4]
	fmul	DWORD PTR _fInv$[ebp]
	fstp	DWORD PTR _kDiv$[ebp+4]

; 246  : 			kDiv.b = b * fInv;

	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+8]
	fmul	DWORD PTR _fInv$[ebp]
	fstp	DWORD PTR _kDiv$[ebp+8]

; 247  : 			kDiv.a = a * fInv;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+12]
	fmul	DWORD PTR _fInv$[ebp]
	fstp	DWORD PTR _kDiv$[ebp+12]

; 248  : 
; 249  : 			return kDiv;

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	edx, DWORD PTR _kDiv$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR _kDiv$[ebp+4]
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR _kDiv$[ebp+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR _kDiv$[ebp+12]
	mov	DWORD PTR [ecx+12], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 250  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
??KColourValue@Ogre@@QBE?AV01@M@Z ENDP			; Ogre::ColourValue::operator/
_TEXT	ENDS
PUBLIC	??YColourValue@Ogre@@QAEAAV01@ABV01@@Z		; Ogre::ColourValue::operator+=
; Function compile flags: /Odtp
;	COMDAT ??YColourValue@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_rkVector$ = 8						; size = 4
??YColourValue@Ogre@@QAEAAV01@ABV01@@Z PROC		; Ogre::ColourValue::operator+=, COMDAT
; _this$ = ecx

; 266  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 267  : 			r += rkVector.r;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax]
	mov	ecx, DWORD PTR _rkVector$[ebp]
	fadd	DWORD PTR [ecx]
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx]

; 268  : 			g += rkVector.g;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _rkVector$[ebp]
	fadd	DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+4]

; 269  : 			b += rkVector.b;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+8]
	mov	ecx, DWORD PTR _rkVector$[ebp]
	fadd	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+8]

; 270  : 			a += rkVector.a;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+12]
	mov	ecx, DWORD PTR _rkVector$[ebp]
	fadd	DWORD PTR [ecx+12]
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+12]

; 271  : 
; 272  : 			return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 273  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??YColourValue@Ogre@@QAEAAV01@ABV01@@Z ENDP		; Ogre::ColourValue::operator+=
_TEXT	ENDS
PUBLIC	??ZColourValue@Ogre@@QAEAAV01@ABV01@@Z		; Ogre::ColourValue::operator-=
; Function compile flags: /Odtp
;	COMDAT ??ZColourValue@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_rkVector$ = 8						; size = 4
??ZColourValue@Ogre@@QAEAAV01@ABV01@@Z PROC		; Ogre::ColourValue::operator-=, COMDAT
; _this$ = ecx

; 276  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 277  : 			r -= rkVector.r;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax]
	mov	ecx, DWORD PTR _rkVector$[ebp]
	fsub	DWORD PTR [ecx]
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx]

; 278  : 			g -= rkVector.g;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _rkVector$[ebp]
	fsub	DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+4]

; 279  : 			b -= rkVector.b;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+8]
	mov	ecx, DWORD PTR _rkVector$[ebp]
	fsub	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+8]

; 280  : 			a -= rkVector.a;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+12]
	mov	ecx, DWORD PTR _rkVector$[ebp]
	fsub	DWORD PTR [ecx+12]
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+12]

; 281  : 
; 282  : 			return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 283  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??ZColourValue@Ogre@@QAEAAV01@ABV01@@Z ENDP		; Ogre::ColourValue::operator-=
_TEXT	ENDS
PUBLIC	??XColourValue@Ogre@@QAEAAV01@M@Z		; Ogre::ColourValue::operator*=
; Function compile flags: /Odtp
;	COMDAT ??XColourValue@Ogre@@QAEAAV01@M@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_fScalar$ = 8						; size = 4
??XColourValue@Ogre@@QAEAAV01@M@Z PROC			; Ogre::ColourValue::operator*=, COMDAT
; _this$ = ecx

; 286  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 287  : 			r *= fScalar;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax]
	fmul	DWORD PTR _fScalar$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx]

; 288  : 			g *= fScalar;

	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+4]
	fmul	DWORD PTR _fScalar$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [eax+4]

; 289  : 			b *= fScalar;

	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+8]
	fmul	DWORD PTR _fScalar$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+8]

; 290  : 			a *= fScalar;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+12]
	fmul	DWORD PTR _fScalar$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx+12]

; 291  : 			return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 292  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??XColourValue@Ogre@@QAEAAV01@M@Z ENDP			; Ogre::ColourValue::operator*=
_TEXT	ENDS
PUBLIC	??_0ColourValue@Ogre@@QAEAAV01@M@Z		; Ogre::ColourValue::operator/=
; Function compile flags: /Odtp
;	COMDAT ??_0ColourValue@Ogre@@QAEAAV01@M@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_fInv$ = -4						; size = 4
_fScalar$ = 8						; size = 4
??_0ColourValue@Ogre@@QAEAAV01@M@Z PROC			; Ogre::ColourValue::operator/=, COMDAT
; _this$ = ecx

; 295  : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 296  : 			assert( fScalar != 0.0 );
; 297  : 
; 298  : 			float fInv = 1.0f / fScalar;

	fld	DWORD PTR _fScalar$[ebp]
	fld1
	fdivrp	ST(1), ST(0)
	fstp	DWORD PTR _fInv$[ebp]

; 299  : 
; 300  : 			r *= fInv;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax]
	fmul	DWORD PTR _fInv$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx]

; 301  : 			g *= fInv;

	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+4]
	fmul	DWORD PTR _fInv$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [eax+4]

; 302  : 			b *= fInv;

	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+8]
	fmul	DWORD PTR _fInv$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+8]

; 303  : 			a *= fInv;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+12]
	fmul	DWORD PTR _fInv$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx+12]

; 304  : 
; 305  : 			return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 306  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??_0ColourValue@Ogre@@QAEAAV01@M@Z ENDP			; Ogre::ColourValue::operator/=
_TEXT	ENDS
PUBLIC	??4ColourValue@Ogre@@QAEAAV01@ABV01@@Z		; Ogre::ColourValue::operator=
; Function compile flags: /Odtp
;	COMDAT ??4ColourValue@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4ColourValue@Ogre@@QAEAAV01@ABV01@@Z PROC		; Ogre::ColourValue::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4ColourValue@Ogre@@QAEAAV01@ABV01@@Z ENDP		; Ogre::ColourValue::operator=
_TEXT	ENDS
PUBLIC	??_FColourValue@Ogre@@QAEXXZ			; Ogre::ColourValue::`default constructor closure'
; Function compile flags: /Odtp
;	COMDAT ??_FColourValue@Ogre@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??_FColourValue@Ogre@@QAEXXZ PROC			; Ogre::ColourValue::`default constructor closure', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	fld1
	fstp	DWORD PTR [esp]
	push	ecx
	fld1
	fstp	DWORD PTR [esp]
	push	ecx
	fld1
	fstp	DWORD PTR [esp]
	push	ecx
	fld1
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0ColourValue@Ogre@@QAE@MMMM@Z		; Ogre::ColourValue::ColourValue
	mov	esp, ebp
	pop	ebp
	ret	0
??_FColourValue@Ogre@@QAEXXZ ENDP			; Ogre::ColourValue::`default constructor closure'
_TEXT	ENDS
PUBLIC	?getRTTI@ParamShapeData@Ogre@@UBEPBVRuntimeClass@2@XZ ; Ogre::ParamShapeData::getRTTI
EXTRN	?m_RTTI@ParamShapeData@Ogre@@2VRuntimeClass@2@B:BYTE ; Ogre::ParamShapeData::m_RTTI
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogreparametricshapedata.h
;	COMDAT ?getRTTI@ParamShapeData@Ogre@@UBEPBVRuntimeClass@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getRTTI@ParamShapeData@Ogre@@UBEPBVRuntimeClass@2@XZ PROC ; Ogre::ParamShapeData::getRTTI, COMDAT
; _this$ = ecx

; 23   : 		DECLARE_RTTI(ParamShapeData)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, OFFSET ?m_RTTI@ParamShapeData@Ogre@@2VRuntimeClass@2@B ; Ogre::ParamShapeData::m_RTTI
	mov	esp, ebp
	pop	ebp
	ret	0
?getRTTI@ParamShapeData@Ogre@@UBEPBVRuntimeClass@2@XZ ENDP ; Ogre::ParamShapeData::getRTTI
_TEXT	ENDS
PUBLIC	?newObject@ParamShapeData@Ogre@@SAPAVBaseObject@2@XZ ; Ogre::ParamShapeData::newObject
EXTRN	??0ParamShapeData@Ogre@@QAE@XZ:PROC		; Ogre::ParamShapeData::ParamShapeData
EXTRN	??2MemoryDelegation@Ogre@@SAPAXI@Z:PROC		; Ogre::MemoryDelegation::operator new
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?newObject@ParamShapeData@Ogre@@SAPAVBaseObject@2@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?newObject@ParamShapeData@Ogre@@SAPAVBaseObject@2@XZ$0
__ehfuncinfo$?newObject@ParamShapeData@Ogre@@SAPAVBaseObject@2@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?newObject@ParamShapeData@Ogre@@SAPAVBaseObject@2@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?newObject@ParamShapeData@Ogre@@SAPAVBaseObject@2@XZ
_TEXT	SEGMENT
tv75 = -24						; size = 4
$T93831 = -20						; size = 4
$T93830 = -16						; size = 4
__$EHRec$ = -12						; size = 12
?newObject@ParamShapeData@Ogre@@SAPAVBaseObject@2@XZ PROC ; Ogre::ParamShapeData::newObject, COMDAT

; 23   : 		DECLARE_RTTI(ParamShapeData)

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?newObject@ParamShapeData@Ogre@@SAPAVBaseObject@2@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 12					; 0000000cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	push	2020					; 000007e4H
	call	??2MemoryDelegation@Ogre@@SAPAXI@Z	; Ogre::MemoryDelegation::operator new
	add	esp, 4
	mov	DWORD PTR $T93831[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T93831[ebp], 0
	je	SHORT $LN3@newObject
	mov	ecx, DWORD PTR $T93831[ebp]
	call	??0ParamShapeData@Ogre@@QAE@XZ		; Ogre::ParamShapeData::ParamShapeData
	mov	DWORD PTR tv75[ebp], eax
	jmp	SHORT $LN4@newObject
$LN3@newObject:
	mov	DWORD PTR tv75[ebp], 0
$LN4@newObject:
	mov	eax, DWORD PTR tv75[ebp]
	mov	DWORD PTR $T93830[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR $T93830[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?newObject@ParamShapeData@Ogre@@SAPAVBaseObject@2@XZ$0:
	push	2020					; 000007e4H
	mov	eax, DWORD PTR $T93831[ebp]
	push	eax
	call	??3MemoryDelegation@Ogre@@SAXPAXI@Z	; Ogre::MemoryDelegation::operator delete
	add	esp, 8
	ret	0
__ehhandler$?newObject@ParamShapeData@Ogre@@SAPAVBaseObject@2@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?newObject@ParamShapeData@Ogre@@SAPAVBaseObject@2@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?newObject@ParamShapeData@Ogre@@SAPAVBaseObject@2@XZ ENDP ; Ogre::ParamShapeData::newObject
PUBLIC	??1?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@UAE@XZ ; Ogre::KeyFrameArray<Ogre::ColourValue>::~KeyFrameArray<Ogre::ColourValue>
PUBLIC	??1?$KeyFrameArray@M@Ogre@@UAE@XZ		; Ogre::KeyFrameArray<float>::~KeyFrameArray<float>
PUBLIC	??0?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@QAE@ABV01@@Z ; Ogre::KeyFrameArray<Ogre::ColourValue>::KeyFrameArray<Ogre::ColourValue>
PUBLIC	??0?$KeyFrameArray@M@Ogre@@QAE@ABV01@@Z		; Ogre::KeyFrameArray<float>::KeyFrameArray<float>
PUBLIC	??_7ParamShapeData@Ogre@@6B@			; Ogre::ParamShapeData::`vftable'
PUBLIC	??0ParamShapeData@Ogre@@QAE@ABV01@@Z		; Ogre::ParamShapeData::ParamShapeData
PUBLIC	??_R4ParamShapeData@Ogre@@6B@			; Ogre::ParamShapeData::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVParamShapeData@Ogre@@@8			; Ogre::ParamShapeData `RTTI Type Descriptor'
PUBLIC	??_R3ParamShapeData@Ogre@@8			; Ogre::ParamShapeData::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2ParamShapeData@Ogre@@8			; Ogre::ParamShapeData::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@ParamShapeData@Ogre@@8		; Ogre::ParamShapeData::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_EParamShapeData@Ogre@@MAEPAXI@Z		; Ogre::ParamShapeData::`vector deleting destructor'
EXTRN	?_serialize@ParamShapeData@Ogre@@MAEXAAVArchive@2@H@Z:PROC ; Ogre::ParamShapeData::_serialize
;	COMDAT ??_R1A@?0A@EA@ParamShapeData@Ogre@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@ParamShapeData@Ogre@@8 DD FLAT:??_R0?AVParamShapeData@Ogre@@@8 ; Ogre::ParamShapeData::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3ParamShapeData@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R2ParamShapeData@Ogre@@8
rdata$r	SEGMENT
??_R2ParamShapeData@Ogre@@8 DD FLAT:??_R1A@?0A@EA@ParamShapeData@Ogre@@8 ; Ogre::ParamShapeData::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@Resource@Ogre@@8
	DD	FLAT:??_R1A@?0A@EA@BaseObject@Ogre@@8
	DD	FLAT:??_R13?0A@EA@MemoryDelegation@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R3ParamShapeData@Ogre@@8
rdata$r	SEGMENT
??_R3ParamShapeData@Ogre@@8 DD 00H			; Ogre::ParamShapeData::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	04H
	DD	FLAT:??_R2ParamShapeData@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVParamShapeData@Ogre@@@8
_DATA	SEGMENT
??_R0?AVParamShapeData@Ogre@@@8 DD FLAT:??_7type_info@@6B@ ; Ogre::ParamShapeData `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVParamShapeData@Ogre@@', 00H
_DATA	ENDS
;	COMDAT ??_R4ParamShapeData@Ogre@@6B@
rdata$r	SEGMENT
??_R4ParamShapeData@Ogre@@6B@ DD 00H			; Ogre::ParamShapeData::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVParamShapeData@Ogre@@@8
	DD	FLAT:??_R3ParamShapeData@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_7ParamShapeData@Ogre@@6B@
CONST	SEGMENT
??_7ParamShapeData@Ogre@@6B@ DD FLAT:??_R4ParamShapeData@Ogre@@6B@ ; Ogre::ParamShapeData::`vftable'
	DD	FLAT:?getRTTI@ParamShapeData@Ogre@@UBEPBVRuntimeClass@2@XZ
	DD	FLAT:?release@Resource@Ogre@@UAEXXZ
	DD	FLAT:?addRef@Resource@Ogre@@UAEXXZ
	DD	FLAT:?getRefCount@Resource@Ogre@@UAEHXZ
	DD	FLAT:?_serialize@ParamShapeData@Ogre@@MAEXAAVArchive@2@H@Z
	DD	FLAT:??_EParamShapeData@Ogre@@MAEPAXI@Z
	DD	FLAT:?deleteThis@BaseObject@Ogre@@MAEXXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0ParamShapeData@Ogre@@QAE@ABV01@@Z DD 019930522H
	DD	017H
	DD	FLAT:__unwindtable$??0ParamShapeData@Ogre@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__unwindtable$??0ParamShapeData@Ogre@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0ParamShapeData@Ogre@@QAE@ABV01@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0ParamShapeData@Ogre@@QAE@ABV01@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0ParamShapeData@Ogre@@QAE@ABV01@@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$??0ParamShapeData@Ogre@@QAE@ABV01@@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$??0ParamShapeData@Ogre@@QAE@ABV01@@Z$4
	DD	04H
	DD	FLAT:__unwindfunclet$??0ParamShapeData@Ogre@@QAE@ABV01@@Z$5
	DD	05H
	DD	FLAT:__unwindfunclet$??0ParamShapeData@Ogre@@QAE@ABV01@@Z$6
	DD	06H
	DD	FLAT:__unwindfunclet$??0ParamShapeData@Ogre@@QAE@ABV01@@Z$7
	DD	07H
	DD	FLAT:__unwindfunclet$??0ParamShapeData@Ogre@@QAE@ABV01@@Z$8
	DD	08H
	DD	FLAT:__unwindfunclet$??0ParamShapeData@Ogre@@QAE@ABV01@@Z$9
	DD	09H
	DD	FLAT:__unwindfunclet$??0ParamShapeData@Ogre@@QAE@ABV01@@Z$10
	DD	0aH
	DD	FLAT:__unwindfunclet$??0ParamShapeData@Ogre@@QAE@ABV01@@Z$11
	DD	0bH
	DD	FLAT:__unwindfunclet$??0ParamShapeData@Ogre@@QAE@ABV01@@Z$12
	DD	0cH
	DD	FLAT:__unwindfunclet$??0ParamShapeData@Ogre@@QAE@ABV01@@Z$13
	DD	0dH
	DD	FLAT:__unwindfunclet$??0ParamShapeData@Ogre@@QAE@ABV01@@Z$14
	DD	0eH
	DD	FLAT:__unwindfunclet$??0ParamShapeData@Ogre@@QAE@ABV01@@Z$15
	DD	0fH
	DD	FLAT:__unwindfunclet$??0ParamShapeData@Ogre@@QAE@ABV01@@Z$16
	DD	010H
	DD	FLAT:__unwindfunclet$??0ParamShapeData@Ogre@@QAE@ABV01@@Z$17
	DD	011H
	DD	FLAT:__unwindfunclet$??0ParamShapeData@Ogre@@QAE@ABV01@@Z$18
	DD	012H
	DD	FLAT:__unwindfunclet$??0ParamShapeData@Ogre@@QAE@ABV01@@Z$19
	DD	013H
	DD	FLAT:__unwindfunclet$??0ParamShapeData@Ogre@@QAE@ABV01@@Z$20
	DD	014H
	DD	FLAT:__unwindfunclet$??0ParamShapeData@Ogre@@QAE@ABV01@@Z$21
	DD	015H
	DD	FLAT:__unwindfunclet$??0ParamShapeData@Ogre@@QAE@ABV01@@Z$22
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0ParamShapeData@Ogre@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0ParamShapeData@Ogre@@QAE@ABV01@@Z PROC		; Ogre::ParamShapeData::ParamShapeData, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0ParamShapeData@Ogre@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0Resource@Ogre@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7ParamShapeData@Ogre@@6B@
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	cl, BYTE PTR [eax+16]
	mov	BYTE PTR [edx+16], cl
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR [edx+20], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR [edx+24], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	DWORD PTR [edx+28], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	DWORD PTR [edx+32], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	fld	DWORD PTR [eax+36]
	fstp	DWORD PTR [edx+36]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	DWORD PTR [ecx+40], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+44]
	mov	DWORD PTR [ecx+44], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+48]
	mov	DWORD PTR [ecx+48], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	al, BYTE PTR [edx+52]
	mov	BYTE PTR [ecx+52], al
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+56]
	mov	DWORD PTR [ecx+56], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+60]
	mov	DWORD PTR [ecx+60], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+64]
	mov	DWORD PTR [ecx+64], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+68]
	mov	DWORD PTR [ecx+68], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+72]
	mov	DWORD PTR [ecx+72], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+76]
	mov	DWORD PTR [ecx+76], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+80]
	mov	DWORD PTR [ecx+80], eax
	mov	ecx, DWORD PTR ___that$[ebp]
	add	ecx, 84					; 00000054H
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 84					; 00000054H
	call	??0?$KeyFrameArray@M@Ogre@@QAE@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 172				; 000000acH
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 172				; 000000acH
	call	??0?$KeyFrameArray@M@Ogre@@QAE@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 260				; 00000104H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 260				; 00000104H
	call	??0?$KeyFrameArray@M@Ogre@@QAE@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	mov	ecx, DWORD PTR ___that$[ebp]
	add	ecx, 348				; 0000015cH
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 348				; 0000015cH
	call	??0?$KeyFrameArray@M@Ogre@@QAE@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 436				; 000001b4H
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 436				; 000001b4H
	call	??0?$KeyFrameArray@M@Ogre@@QAE@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 524				; 0000020cH
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 524				; 0000020cH
	call	??0?$KeyFrameArray@M@Ogre@@QAE@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 6
	mov	ecx, DWORD PTR ___that$[ebp]
	add	ecx, 612				; 00000264H
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 612				; 00000264H
	call	??0?$KeyFrameArray@M@Ogre@@QAE@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 7
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 700				; 000002bcH
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 700				; 000002bcH
	call	??0?$KeyFrameArray@M@Ogre@@QAE@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 8
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 788				; 00000314H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 788				; 00000314H
	call	??0?$KeyFrameArray@M@Ogre@@QAE@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 9
	mov	ecx, DWORD PTR ___that$[ebp]
	add	ecx, 876				; 0000036cH
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 876				; 0000036cH
	call	??0?$KeyFrameArray@M@Ogre@@QAE@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 10		; 0000000aH
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 964				; 000003c4H
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 964				; 000003c4H
	call	??0?$KeyFrameArray@M@Ogre@@QAE@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 11		; 0000000bH
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 1052				; 0000041cH
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1052				; 0000041cH
	call	??0?$KeyFrameArray@M@Ogre@@QAE@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 12		; 0000000cH
	mov	ecx, DWORD PTR ___that$[ebp]
	add	ecx, 1140				; 00000474H
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1140				; 00000474H
	call	??0?$KeyFrameArray@M@Ogre@@QAE@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 13		; 0000000dH
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 1228				; 000004ccH
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1228				; 000004ccH
	call	??0?$KeyFrameArray@M@Ogre@@QAE@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 14		; 0000000eH
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 1316				; 00000524H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1316				; 00000524H
	call	??0?$KeyFrameArray@M@Ogre@@QAE@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 15		; 0000000fH
	mov	ecx, DWORD PTR ___that$[ebp]
	add	ecx, 1404				; 0000057cH
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1404				; 0000057cH
	call	??0?$KeyFrameArray@M@Ogre@@QAE@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 16		; 00000010H
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 1492				; 000005d4H
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1492				; 000005d4H
	call	??0?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@QAE@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 17		; 00000011H
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 1580				; 0000062cH
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1580				; 0000062cH
	call	??0?$KeyFrameArray@M@Ogre@@QAE@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 18		; 00000012H
	mov	ecx, DWORD PTR ___that$[ebp]
	add	ecx, 1668				; 00000684H
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1668				; 00000684H
	call	??0?$KeyFrameArray@M@Ogre@@QAE@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 19		; 00000013H
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 1756				; 000006dcH
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1756				; 000006dcH
	call	??0?$KeyFrameArray@M@Ogre@@QAE@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 20		; 00000014H
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 1844				; 00000734H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1844				; 00000734H
	call	??0?$KeyFrameArray@M@Ogre@@QAE@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 21		; 00000015H
	mov	ecx, DWORD PTR ___that$[ebp]
	add	ecx, 1932				; 0000078cH
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1932				; 0000078cH
	call	??0?$KeyFrameArray@M@Ogre@@QAE@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 22		; 00000016H
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0ParamShapeData@Ogre@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1Resource@Ogre@@MAE@XZ		; Ogre::Resource::~Resource
__unwindfunclet$??0ParamShapeData@Ogre@@QAE@ABV01@@Z$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 84					; 00000054H
	jmp	??1?$KeyFrameArray@M@Ogre@@UAE@XZ
__unwindfunclet$??0ParamShapeData@Ogre@@QAE@ABV01@@Z$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 172				; 000000acH
	jmp	??1?$KeyFrameArray@M@Ogre@@UAE@XZ
__unwindfunclet$??0ParamShapeData@Ogre@@QAE@ABV01@@Z$3:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 260				; 00000104H
	jmp	??1?$KeyFrameArray@M@Ogre@@UAE@XZ
__unwindfunclet$??0ParamShapeData@Ogre@@QAE@ABV01@@Z$4:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 348				; 0000015cH
	jmp	??1?$KeyFrameArray@M@Ogre@@UAE@XZ
__unwindfunclet$??0ParamShapeData@Ogre@@QAE@ABV01@@Z$5:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 436				; 000001b4H
	jmp	??1?$KeyFrameArray@M@Ogre@@UAE@XZ
__unwindfunclet$??0ParamShapeData@Ogre@@QAE@ABV01@@Z$6:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 524				; 0000020cH
	jmp	??1?$KeyFrameArray@M@Ogre@@UAE@XZ
__unwindfunclet$??0ParamShapeData@Ogre@@QAE@ABV01@@Z$7:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 612				; 00000264H
	jmp	??1?$KeyFrameArray@M@Ogre@@UAE@XZ
__unwindfunclet$??0ParamShapeData@Ogre@@QAE@ABV01@@Z$8:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 700				; 000002bcH
	jmp	??1?$KeyFrameArray@M@Ogre@@UAE@XZ
__unwindfunclet$??0ParamShapeData@Ogre@@QAE@ABV01@@Z$9:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 788				; 00000314H
	jmp	??1?$KeyFrameArray@M@Ogre@@UAE@XZ
__unwindfunclet$??0ParamShapeData@Ogre@@QAE@ABV01@@Z$10:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 876				; 0000036cH
	jmp	??1?$KeyFrameArray@M@Ogre@@UAE@XZ
__unwindfunclet$??0ParamShapeData@Ogre@@QAE@ABV01@@Z$11:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 964				; 000003c4H
	jmp	??1?$KeyFrameArray@M@Ogre@@UAE@XZ
__unwindfunclet$??0ParamShapeData@Ogre@@QAE@ABV01@@Z$12:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1052				; 0000041cH
	jmp	??1?$KeyFrameArray@M@Ogre@@UAE@XZ
__unwindfunclet$??0ParamShapeData@Ogre@@QAE@ABV01@@Z$13:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1140				; 00000474H
	jmp	??1?$KeyFrameArray@M@Ogre@@UAE@XZ
__unwindfunclet$??0ParamShapeData@Ogre@@QAE@ABV01@@Z$14:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1228				; 000004ccH
	jmp	??1?$KeyFrameArray@M@Ogre@@UAE@XZ
__unwindfunclet$??0ParamShapeData@Ogre@@QAE@ABV01@@Z$15:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1316				; 00000524H
	jmp	??1?$KeyFrameArray@M@Ogre@@UAE@XZ
__unwindfunclet$??0ParamShapeData@Ogre@@QAE@ABV01@@Z$16:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1404				; 0000057cH
	jmp	??1?$KeyFrameArray@M@Ogre@@UAE@XZ
__unwindfunclet$??0ParamShapeData@Ogre@@QAE@ABV01@@Z$17:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1492				; 000005d4H
	jmp	??1?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@UAE@XZ
__unwindfunclet$??0ParamShapeData@Ogre@@QAE@ABV01@@Z$18:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1580				; 0000062cH
	jmp	??1?$KeyFrameArray@M@Ogre@@UAE@XZ
__unwindfunclet$??0ParamShapeData@Ogre@@QAE@ABV01@@Z$19:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1668				; 00000684H
	jmp	??1?$KeyFrameArray@M@Ogre@@UAE@XZ
__unwindfunclet$??0ParamShapeData@Ogre@@QAE@ABV01@@Z$20:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1756				; 000006dcH
	jmp	??1?$KeyFrameArray@M@Ogre@@UAE@XZ
__unwindfunclet$??0ParamShapeData@Ogre@@QAE@ABV01@@Z$21:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1844				; 00000734H
	jmp	??1?$KeyFrameArray@M@Ogre@@UAE@XZ
__unwindfunclet$??0ParamShapeData@Ogre@@QAE@ABV01@@Z$22:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1932				; 0000078cH
	jmp	??1?$KeyFrameArray@M@Ogre@@UAE@XZ
__ehhandler$??0ParamShapeData@Ogre@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0ParamShapeData@Ogre@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0ParamShapeData@Ogre@@QAE@ABV01@@Z ENDP		; Ogre::ParamShapeData::ParamShapeData
PUBLIC	??4?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@QAEABV01@ABV01@@Z ; Ogre::KeyFrameArray<Ogre::ColourValue>::operator=
PUBLIC	??4?$KeyFrameArray@M@Ogre@@QAEABV01@ABV01@@Z	; Ogre::KeyFrameArray<float>::operator=
PUBLIC	??4ParamShapeData@Ogre@@QAEAAV01@ABV01@@Z	; Ogre::ParamShapeData::operator=
; Function compile flags: /Odtp
;	COMDAT ??4ParamShapeData@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4ParamShapeData@Ogre@@QAEAAV01@ABV01@@Z PROC		; Ogre::ParamShapeData::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4Resource@Ogre@@QAEAAV01@ABV01@@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	al, BYTE PTR [edx+16]
	mov	BYTE PTR [ecx+16], al
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	DWORD PTR [ecx+20], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR [ecx+24], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+28]
	mov	DWORD PTR [ecx+28], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	DWORD PTR [ecx+32], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	fld	DWORD PTR [edx+36]
	fstp	DWORD PTR [ecx+36]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	mov	DWORD PTR [eax+40], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	mov	DWORD PTR [eax+44], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+48]
	mov	DWORD PTR [eax+48], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	dl, BYTE PTR [ecx+52]
	mov	BYTE PTR [eax+52], dl
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	mov	DWORD PTR [eax+56], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+60]
	mov	DWORD PTR [eax+60], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+64]
	mov	DWORD PTR [eax+64], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+68]
	mov	DWORD PTR [eax+68], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+72]
	mov	DWORD PTR [eax+72], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+76]
	mov	DWORD PTR [eax+76], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+80]
	mov	DWORD PTR [eax+80], edx
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 84					; 00000054H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 84					; 00000054H
	call	??4?$KeyFrameArray@M@Ogre@@QAEABV01@ABV01@@Z ; Ogre::KeyFrameArray<float>::operator=
	mov	ecx, DWORD PTR ___that$[ebp]
	add	ecx, 172				; 000000acH
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 172				; 000000acH
	call	??4?$KeyFrameArray@M@Ogre@@QAEABV01@ABV01@@Z ; Ogre::KeyFrameArray<float>::operator=
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 260				; 00000104H
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 260				; 00000104H
	call	??4?$KeyFrameArray@M@Ogre@@QAEABV01@ABV01@@Z ; Ogre::KeyFrameArray<float>::operator=
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 348				; 0000015cH
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 348				; 0000015cH
	call	??4?$KeyFrameArray@M@Ogre@@QAEABV01@ABV01@@Z ; Ogre::KeyFrameArray<float>::operator=
	mov	ecx, DWORD PTR ___that$[ebp]
	add	ecx, 436				; 000001b4H
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 436				; 000001b4H
	call	??4?$KeyFrameArray@M@Ogre@@QAEABV01@ABV01@@Z ; Ogre::KeyFrameArray<float>::operator=
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 524				; 0000020cH
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 524				; 0000020cH
	call	??4?$KeyFrameArray@M@Ogre@@QAEABV01@ABV01@@Z ; Ogre::KeyFrameArray<float>::operator=
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 612				; 00000264H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 612				; 00000264H
	call	??4?$KeyFrameArray@M@Ogre@@QAEABV01@ABV01@@Z ; Ogre::KeyFrameArray<float>::operator=
	mov	ecx, DWORD PTR ___that$[ebp]
	add	ecx, 700				; 000002bcH
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 700				; 000002bcH
	call	??4?$KeyFrameArray@M@Ogre@@QAEABV01@ABV01@@Z ; Ogre::KeyFrameArray<float>::operator=
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 788				; 00000314H
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 788				; 00000314H
	call	??4?$KeyFrameArray@M@Ogre@@QAEABV01@ABV01@@Z ; Ogre::KeyFrameArray<float>::operator=
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 876				; 0000036cH
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 876				; 0000036cH
	call	??4?$KeyFrameArray@M@Ogre@@QAEABV01@ABV01@@Z ; Ogre::KeyFrameArray<float>::operator=
	mov	ecx, DWORD PTR ___that$[ebp]
	add	ecx, 964				; 000003c4H
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 964				; 000003c4H
	call	??4?$KeyFrameArray@M@Ogre@@QAEABV01@ABV01@@Z ; Ogre::KeyFrameArray<float>::operator=
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 1052				; 0000041cH
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1052				; 0000041cH
	call	??4?$KeyFrameArray@M@Ogre@@QAEABV01@ABV01@@Z ; Ogre::KeyFrameArray<float>::operator=
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 1140				; 00000474H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1140				; 00000474H
	call	??4?$KeyFrameArray@M@Ogre@@QAEABV01@ABV01@@Z ; Ogre::KeyFrameArray<float>::operator=
	mov	ecx, DWORD PTR ___that$[ebp]
	add	ecx, 1228				; 000004ccH
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1228				; 000004ccH
	call	??4?$KeyFrameArray@M@Ogre@@QAEABV01@ABV01@@Z ; Ogre::KeyFrameArray<float>::operator=
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 1316				; 00000524H
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1316				; 00000524H
	call	??4?$KeyFrameArray@M@Ogre@@QAEABV01@ABV01@@Z ; Ogre::KeyFrameArray<float>::operator=
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 1404				; 0000057cH
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1404				; 0000057cH
	call	??4?$KeyFrameArray@M@Ogre@@QAEABV01@ABV01@@Z ; Ogre::KeyFrameArray<float>::operator=
	mov	ecx, DWORD PTR ___that$[ebp]
	add	ecx, 1492				; 000005d4H
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1492				; 000005d4H
	call	??4?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@QAEABV01@ABV01@@Z ; Ogre::KeyFrameArray<Ogre::ColourValue>::operator=
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 1580				; 0000062cH
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1580				; 0000062cH
	call	??4?$KeyFrameArray@M@Ogre@@QAEABV01@ABV01@@Z ; Ogre::KeyFrameArray<float>::operator=
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 1668				; 00000684H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1668				; 00000684H
	call	??4?$KeyFrameArray@M@Ogre@@QAEABV01@ABV01@@Z ; Ogre::KeyFrameArray<float>::operator=
	mov	ecx, DWORD PTR ___that$[ebp]
	add	ecx, 1756				; 000006dcH
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1756				; 000006dcH
	call	??4?$KeyFrameArray@M@Ogre@@QAEABV01@ABV01@@Z ; Ogre::KeyFrameArray<float>::operator=
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 1844				; 00000734H
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1844				; 00000734H
	call	??4?$KeyFrameArray@M@Ogre@@QAEABV01@ABV01@@Z ; Ogre::KeyFrameArray<float>::operator=
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 1932				; 0000078cH
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1932				; 0000078cH
	call	??4?$KeyFrameArray@M@Ogre@@QAEABV01@ABV01@@Z ; Ogre::KeyFrameArray<float>::operator=
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4ParamShapeData@Ogre@@QAEAAV01@ABV01@@Z ENDP		; Ogre::ParamShapeData::operator=
_TEXT	ENDS
PUBLIC	??_GParamShapeData@Ogre@@MAEPAXI@Z		; Ogre::ParamShapeData::`scalar deleting destructor'
EXTRN	??1ParamShapeData@Ogre@@MAE@XZ:PROC		; Ogre::ParamShapeData::~ParamShapeData
; Function compile flags: /Odtp
;	COMDAT ??_GParamShapeData@Ogre@@MAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GParamShapeData@Ogre@@MAEPAXI@Z PROC			; Ogre::ParamShapeData::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1ParamShapeData@Ogre@@MAE@XZ		; Ogre::ParamShapeData::~ParamShapeData
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@15
	push	2020					; 000007e4H
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3MemoryDelegation@Ogre@@SAXPAXI@Z	; Ogre::MemoryDelegation::operator delete
	add	esp, 8
$LN1@scalar@15:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GParamShapeData@Ogre@@MAEPAXI@Z ENDP			; Ogre::ParamShapeData::`scalar deleting destructor'
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_EParamShapeData@Ogre@@MAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_EParamShapeData@Ogre@@MAEPAXI@Z PROC			; Ogre::ParamShapeData::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 2
	je	SHORT $LN3@vector@15
	push	OFFSET ??1ParamShapeData@Ogre@@MAE@XZ	; Ogre::ParamShapeData::~ParamShapeData
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx-4]
	push	edx
	push	2020					; 000007e4H
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??_M@YGXPAXIHP6EX0@Z@Z
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN2@vector@15
	push	2020					; 000007e4H
	mov	edx, DWORD PTR _this$[ebp]
	sub	edx, 4
	push	edx
	call	??_VMemoryDelegation@Ogre@@SAXPAXI@Z	; Ogre::MemoryDelegation::operator delete[]
	add	esp, 8
$LN2@vector@15:
	mov	eax, DWORD PTR _this$[ebp]
	sub	eax, 4
	jmp	SHORT $LN4@vector@15
$LN3@vector@15:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1ParamShapeData@Ogre@@MAE@XZ		; Ogre::ParamShapeData::~ParamShapeData
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@vector@15
	push	2020					; 000007e4H
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3MemoryDelegation@Ogre@@SAXPAXI@Z	; Ogre::MemoryDelegation::operator delete
	add	esp, 8
$LN1@vector@15:
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector@15:
	mov	esp, ebp
	pop	ebp
	ret	4
??_EParamShapeData@Ogre@@MAEPAXI@Z ENDP			; Ogre::ParamShapeData::`vector deleting destructor'
_TEXT	ENDS
PUBLIC	??1?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::~vector<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >
PUBLIC	??1?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::~vector<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >
PUBLIC	??1BaseKeyFrameArray@Ogre@@UAE@XZ		; Ogre::BaseKeyFrameArray::~BaseKeyFrameArray
PUBLIC	??0?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAE@ABV01@@Z ; std::vector<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::vector<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >
PUBLIC	??0?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAE@ABV01@@Z ; std::vector<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::vector<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >
PUBLIC	??_7?$KeyFrameArray@M@Ogre@@6B@			; Ogre::KeyFrameArray<float>::`vftable'
PUBLIC	??0BaseKeyFrameArray@Ogre@@QAE@ABV01@@Z		; Ogre::BaseKeyFrameArray::BaseKeyFrameArray
PUBLIC	??_R4?$KeyFrameArray@M@Ogre@@6B@		; Ogre::KeyFrameArray<float>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$KeyFrameArray@M@Ogre@@@8		; Ogre::KeyFrameArray<float> `RTTI Type Descriptor'
PUBLIC	??_R3?$KeyFrameArray@M@Ogre@@8			; Ogre::KeyFrameArray<float>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$KeyFrameArray@M@Ogre@@8			; Ogre::KeyFrameArray<float>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$KeyFrameArray@M@Ogre@@8		; Ogre::KeyFrameArray<float>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@BaseKeyFrameArray@Ogre@@8		; Ogre::BaseKeyFrameArray::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVBaseKeyFrameArray@Ogre@@@8		; Ogre::BaseKeyFrameArray `RTTI Type Descriptor'
PUBLIC	??_R3BaseKeyFrameArray@Ogre@@8			; Ogre::BaseKeyFrameArray::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2BaseKeyFrameArray@Ogre@@8			; Ogre::BaseKeyFrameArray::`RTTI Base Class Array'
PUBLIC	?_serialize@?$KeyFrameArray@M@Ogre@@UAEXAAVArchive@2@H@Z ; Ogre::KeyFrameArray<float>::_serialize
PUBLIC	?getNumKey@?$KeyFrameArray@M@Ogre@@UAEIXZ	; Ogre::KeyFrameArray<float>::getNumKey
PUBLIC	?getValue@?$KeyFrameArray@M@Ogre@@UAEXHIPAX@Z	; Ogre::KeyFrameArray<float>::getValue
EXTRN	??_E?$KeyFrameArray@M@Ogre@@UAEPAXI@Z:PROC	; Ogre::KeyFrameArray<float>::`vector deleting destructor'
;	COMDAT ??_R2BaseKeyFrameArray@Ogre@@8
rdata$r	SEGMENT
??_R2BaseKeyFrameArray@Ogre@@8 DD FLAT:??_R1A@?0A@EA@BaseKeyFrameArray@Ogre@@8 ; Ogre::BaseKeyFrameArray::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@BaseObject@Ogre@@8
	DD	FLAT:??_R13?0A@EA@MemoryDelegation@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R3BaseKeyFrameArray@Ogre@@8
rdata$r	SEGMENT
??_R3BaseKeyFrameArray@Ogre@@8 DD 00H			; Ogre::BaseKeyFrameArray::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2BaseKeyFrameArray@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVBaseKeyFrameArray@Ogre@@@8
_DATA	SEGMENT
??_R0?AVBaseKeyFrameArray@Ogre@@@8 DD FLAT:??_7type_info@@6B@ ; Ogre::BaseKeyFrameArray `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVBaseKeyFrameArray@Ogre@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@BaseKeyFrameArray@Ogre@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@BaseKeyFrameArray@Ogre@@8 DD FLAT:??_R0?AVBaseKeyFrameArray@Ogre@@@8 ; Ogre::BaseKeyFrameArray::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3BaseKeyFrameArray@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$KeyFrameArray@M@Ogre@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$KeyFrameArray@M@Ogre@@8 DD FLAT:??_R0?AV?$KeyFrameArray@M@Ogre@@@8 ; Ogre::KeyFrameArray<float>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$KeyFrameArray@M@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R2?$KeyFrameArray@M@Ogre@@8
rdata$r	SEGMENT
??_R2?$KeyFrameArray@M@Ogre@@8 DD FLAT:??_R1A@?0A@EA@?$KeyFrameArray@M@Ogre@@8 ; Ogre::KeyFrameArray<float>::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@BaseKeyFrameArray@Ogre@@8
	DD	FLAT:??_R1A@?0A@EA@BaseObject@Ogre@@8
	DD	FLAT:??_R13?0A@EA@MemoryDelegation@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R3?$KeyFrameArray@M@Ogre@@8
rdata$r	SEGMENT
??_R3?$KeyFrameArray@M@Ogre@@8 DD 00H			; Ogre::KeyFrameArray<float>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	04H
	DD	FLAT:??_R2?$KeyFrameArray@M@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$KeyFrameArray@M@Ogre@@@8
_DATA	SEGMENT
??_R0?AV?$KeyFrameArray@M@Ogre@@@8 DD FLAT:??_7type_info@@6B@ ; Ogre::KeyFrameArray<float> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$KeyFrameArray@M@Ogre@@', 00H
_DATA	ENDS
;	COMDAT ??_R4?$KeyFrameArray@M@Ogre@@6B@
rdata$r	SEGMENT
??_R4?$KeyFrameArray@M@Ogre@@6B@ DD 00H			; Ogre::KeyFrameArray<float>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$KeyFrameArray@M@Ogre@@@8
	DD	FLAT:??_R3?$KeyFrameArray@M@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_7?$KeyFrameArray@M@Ogre@@6B@
CONST	SEGMENT
??_7?$KeyFrameArray@M@Ogre@@6B@ DD FLAT:??_R4?$KeyFrameArray@M@Ogre@@6B@ ; Ogre::KeyFrameArray<float>::`vftable'
	DD	FLAT:?getRTTI@BaseObject@Ogre@@UBEPBVRuntimeClass@2@XZ
	DD	FLAT:?release@BaseObject@Ogre@@UAEXXZ
	DD	FLAT:?addRef@BaseObject@Ogre@@UAEXXZ
	DD	FLAT:?getRefCount@BaseObject@Ogre@@UAEHXZ
	DD	FLAT:?_serialize@?$KeyFrameArray@M@Ogre@@UAEXAAVArchive@2@H@Z
	DD	FLAT:??_E?$KeyFrameArray@M@Ogre@@UAEPAXI@Z
	DD	FLAT:?deleteThis@BaseObject@Ogre@@MAEXXZ
	DD	FLAT:?getNumKey@?$KeyFrameArray@M@Ogre@@UAEIXZ
	DD	FLAT:?getValue@?$KeyFrameArray@M@Ogre@@UAEXHIPAX@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$KeyFrameArray@M@Ogre@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$KeyFrameArray@M@Ogre@@QAE@ABV01@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0?$KeyFrameArray@M@Ogre@@QAE@ABV01@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0?$KeyFrameArray@M@Ogre@@QAE@ABV01@@Z$2
__ehfuncinfo$??0?$KeyFrameArray@M@Ogre@@QAE@ABV01@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0?$KeyFrameArray@M@Ogre@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$KeyFrameArray@M@Ogre@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0?$KeyFrameArray@M@Ogre@@QAE@ABV01@@Z PROC		; Ogre::KeyFrameArray<float>::KeyFrameArray<float>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$KeyFrameArray@M@Ogre@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0BaseKeyFrameArray@Ogre@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7?$KeyFrameArray@M@Ogre@@6B@
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	DWORD PTR [edx+32], ecx
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 36					; 00000024H
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??0?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAE@ABV01@@Z ; std::vector<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::vector<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 60					; 0000003cH
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 60					; 0000003cH
	call	??0?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAE@ABV01@@Z ; std::vector<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::vector<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+84]
	mov	DWORD PTR [ecx+84], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$KeyFrameArray@M@Ogre@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1BaseKeyFrameArray@Ogre@@UAE@XZ	; Ogre::BaseKeyFrameArray::~BaseKeyFrameArray
__unwindfunclet$??0?$KeyFrameArray@M@Ogre@@QAE@ABV01@@Z$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	jmp	??1?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::~vector<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >
__unwindfunclet$??0?$KeyFrameArray@M@Ogre@@QAE@ABV01@@Z$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 60					; 0000003cH
	jmp	??1?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::~vector<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >
__ehhandler$??0?$KeyFrameArray@M@Ogre@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$KeyFrameArray@M@Ogre@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$KeyFrameArray@M@Ogre@@QAE@ABV01@@Z ENDP		; Ogre::KeyFrameArray<float>::KeyFrameArray<float>
PUBLIC	??1?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::~vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >
PUBLIC	??_7BaseKeyFrameArray@Ogre@@6B@			; Ogre::BaseKeyFrameArray::`vftable'
PUBLIC	??_R4BaseKeyFrameArray@Ogre@@6B@		; Ogre::BaseKeyFrameArray::`RTTI Complete Object Locator'
PUBLIC	?_serialize@BaseKeyFrameArray@Ogre@@UAEXAAVArchive@2@H@Z ; Ogre::BaseKeyFrameArray::_serialize
EXTRN	??_EBaseKeyFrameArray@Ogre@@UAEPAXI@Z:PROC	; Ogre::BaseKeyFrameArray::`vector deleting destructor'
;	COMDAT ??_R4BaseKeyFrameArray@Ogre@@6B@
; File i:\svnroot\client\ogremain\ogrekeyframearray.h
rdata$r	SEGMENT
??_R4BaseKeyFrameArray@Ogre@@6B@ DD 00H			; Ogre::BaseKeyFrameArray::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVBaseKeyFrameArray@Ogre@@@8
	DD	FLAT:??_R3BaseKeyFrameArray@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_7BaseKeyFrameArray@Ogre@@6B@
CONST	SEGMENT
??_7BaseKeyFrameArray@Ogre@@6B@ DD FLAT:??_R4BaseKeyFrameArray@Ogre@@6B@ ; Ogre::BaseKeyFrameArray::`vftable'
	DD	FLAT:?getRTTI@BaseObject@Ogre@@UBEPBVRuntimeClass@2@XZ
	DD	FLAT:?release@BaseObject@Ogre@@UAEXXZ
	DD	FLAT:?addRef@BaseObject@Ogre@@UAEXXZ
	DD	FLAT:?getRefCount@BaseObject@Ogre@@UAEHXZ
	DD	FLAT:?_serialize@BaseKeyFrameArray@Ogre@@UAEXAAVArchive@2@H@Z
	DD	FLAT:??_EBaseKeyFrameArray@Ogre@@UAEPAXI@Z
	DD	FLAT:?deleteThis@BaseObject@Ogre@@MAEXXZ
	DD	FLAT:__purecall
	DD	FLAT:__purecall
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1BaseKeyFrameArray@Ogre@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1BaseKeyFrameArray@Ogre@@UAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1BaseKeyFrameArray@Ogre@@UAE@XZ$1
__ehfuncinfo$??1BaseKeyFrameArray@Ogre@@UAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??1BaseKeyFrameArray@Ogre@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1BaseKeyFrameArray@Ogre@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1BaseKeyFrameArray@Ogre@@UAE@XZ PROC			; Ogre::BaseKeyFrameArray::~BaseKeyFrameArray, COMDAT
; _this$ = ecx

; 57   : 		{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1BaseKeyFrameArray@Ogre@@UAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7BaseKeyFrameArray@Ogre@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 58   : 		}

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??1?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::~vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1BaseObject@Ogre@@MAE@XZ		; Ogre::BaseObject::~BaseObject
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1BaseKeyFrameArray@Ogre@@UAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1BaseObject@Ogre@@MAE@XZ		; Ogre::BaseObject::~BaseObject
__unwindfunclet$??1BaseKeyFrameArray@Ogre@@UAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	jmp	??1?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::~vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >
__ehhandler$??1BaseKeyFrameArray@Ogre@@UAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1BaseKeyFrameArray@Ogre@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1BaseKeyFrameArray@Ogre@@UAE@XZ ENDP			; Ogre::BaseKeyFrameArray::~BaseKeyFrameArray
PUBLIC	??$serializeRawArray@UAnimRange@BaseKeyFrameArray@Ogre@@@Archive@Ogre@@QAEAAV01@AAV?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@@Z ; Ogre::Archive::serializeRawArray<Ogre::BaseKeyFrameArray::AnimRange>
; Function compile flags: /Odtp
;	COMDAT ?_serialize@BaseKeyFrameArray@Ogre@@UAEXAAVArchive@2@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_ar$ = 8						; size = 4
_version$ = 12						; size = 4
?_serialize@BaseKeyFrameArray@Ogre@@UAEXAAVArchive@2@H@Z PROC ; Ogre::BaseKeyFrameArray::_serialize, COMDAT
; _this$ = ecx

; 75   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 76   : 			ar.serializeRawArray(m_Ranges);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR _ar$[ebp]
	call	??$serializeRawArray@UAnimRange@BaseKeyFrameArray@Ogre@@@Archive@Ogre@@QAEAAV01@AAV?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@@Z ; Ogre::Archive::serializeRawArray<Ogre::BaseKeyFrameArray::AnimRange>

; 77   : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?_serialize@BaseKeyFrameArray@Ogre@@UAEXAAVArchive@2@H@Z ENDP ; Ogre::BaseKeyFrameArray::_serialize
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_GBaseKeyFrameArray@Ogre@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GBaseKeyFrameArray@Ogre@@UAEPAXI@Z PROC		; Ogre::BaseKeyFrameArray::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1BaseKeyFrameArray@Ogre@@UAE@XZ	; Ogre::BaseKeyFrameArray::~BaseKeyFrameArray
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@16
	push	32					; 00000020H
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3MemoryDelegation@Ogre@@SAXPAXI@Z	; Ogre::MemoryDelegation::operator delete
	add	esp, 8
$LN1@scalar@16:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GBaseKeyFrameArray@Ogre@@UAEPAXI@Z ENDP		; Ogre::BaseKeyFrameArray::`scalar deleting destructor'
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$KeyFrameArray@M@Ogre@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$KeyFrameArray@M@Ogre@@UAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1?$KeyFrameArray@M@Ogre@@UAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??1?$KeyFrameArray@M@Ogre@@UAE@XZ$2
__ehfuncinfo$??1?$KeyFrameArray@M@Ogre@@UAE@XZ DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??1?$KeyFrameArray@M@Ogre@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$KeyFrameArray@M@Ogre@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$KeyFrameArray@M@Ogre@@UAE@XZ PROC			; Ogre::KeyFrameArray<float>::~KeyFrameArray<float>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$KeyFrameArray@M@Ogre@@UAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 2
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 60					; 0000003cH
	call	??1?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::~vector<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??1?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::~vector<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1BaseKeyFrameArray@Ogre@@UAE@XZ	; Ogre::BaseKeyFrameArray::~BaseKeyFrameArray
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$KeyFrameArray@M@Ogre@@UAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1BaseKeyFrameArray@Ogre@@UAE@XZ	; Ogre::BaseKeyFrameArray::~BaseKeyFrameArray
__unwindfunclet$??1?$KeyFrameArray@M@Ogre@@UAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	jmp	??1?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::~vector<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >
__unwindfunclet$??1?$KeyFrameArray@M@Ogre@@UAE@XZ$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 60					; 0000003cH
	jmp	??1?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::~vector<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >
__ehhandler$??1?$KeyFrameArray@M@Ogre@@UAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$KeyFrameArray@M@Ogre@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$KeyFrameArray@M@Ogre@@UAE@XZ ENDP			; Ogre::KeyFrameArray<float>::~KeyFrameArray<float>
PUBLIC	??1?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::~vector<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >
PUBLIC	??1?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::~vector<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >
PUBLIC	??0?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAE@ABV01@@Z ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >
PUBLIC	??0?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAE@ABV01@@Z ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >
PUBLIC	??_7?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@6B@ ; Ogre::KeyFrameArray<Ogre::ColourValue>::`vftable'
PUBLIC	??_R4?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@6B@ ; Ogre::KeyFrameArray<Ogre::ColourValue>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@8 ; Ogre::KeyFrameArray<Ogre::ColourValue> `RTTI Type Descriptor'
PUBLIC	??_R3?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@8 ; Ogre::KeyFrameArray<Ogre::ColourValue>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@8 ; Ogre::KeyFrameArray<Ogre::ColourValue>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@8 ; Ogre::KeyFrameArray<Ogre::ColourValue>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?_serialize@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@UAEXAAVArchive@2@H@Z ; Ogre::KeyFrameArray<Ogre::ColourValue>::_serialize
PUBLIC	?getNumKey@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@UAEIXZ ; Ogre::KeyFrameArray<Ogre::ColourValue>::getNumKey
PUBLIC	?getValue@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@UAEXHIPAX@Z ; Ogre::KeyFrameArray<Ogre::ColourValue>::getValue
EXTRN	??_E?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@UAEPAXI@Z:PROC ; Ogre::KeyFrameArray<Ogre::ColourValue>::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@8 DD FLAT:??_R0?AV?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@8 ; Ogre::KeyFrameArray<Ogre::ColourValue>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R2?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@8
rdata$r	SEGMENT
??_R2?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@8 DD FLAT:??_R1A@?0A@EA@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@8 ; Ogre::KeyFrameArray<Ogre::ColourValue>::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@BaseKeyFrameArray@Ogre@@8
	DD	FLAT:??_R1A@?0A@EA@BaseObject@Ogre@@8
	DD	FLAT:??_R13?0A@EA@MemoryDelegation@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R3?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@8
rdata$r	SEGMENT
??_R3?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@8 DD 00H	; Ogre::KeyFrameArray<Ogre::ColourValue>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	04H
	DD	FLAT:??_R2?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@8
_DATA	SEGMENT
??_R0?AV?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@8 DD FLAT:??_7type_info@@6B@ ; Ogre::KeyFrameArray<Ogre::ColourValue> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@', 00H
_DATA	ENDS
;	COMDAT ??_R4?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@6B@
rdata$r	SEGMENT
??_R4?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@6B@ DD 00H ; Ogre::KeyFrameArray<Ogre::ColourValue>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@8
	DD	FLAT:??_R3?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_7?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@6B@
CONST	SEGMENT
??_7?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@6B@ DD FLAT:??_R4?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@6B@ ; Ogre::KeyFrameArray<Ogre::ColourValue>::`vftable'
	DD	FLAT:?getRTTI@BaseObject@Ogre@@UBEPBVRuntimeClass@2@XZ
	DD	FLAT:?release@BaseObject@Ogre@@UAEXXZ
	DD	FLAT:?addRef@BaseObject@Ogre@@UAEXXZ
	DD	FLAT:?getRefCount@BaseObject@Ogre@@UAEHXZ
	DD	FLAT:?_serialize@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@UAEXAAVArchive@2@H@Z
	DD	FLAT:??_E?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@UAEPAXI@Z
	DD	FLAT:?deleteThis@BaseObject@Ogre@@MAEXXZ
	DD	FLAT:?getNumKey@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@UAEIXZ
	DD	FLAT:?getValue@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@UAEXHIPAX@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@QAE@ABV01@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@QAE@ABV01@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@QAE@ABV01@@Z$2
__ehfuncinfo$??0?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@QAE@ABV01@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@QAE@ABV01@@Z PROC ; Ogre::KeyFrameArray<Ogre::ColourValue>::KeyFrameArray<Ogre::ColourValue>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0BaseKeyFrameArray@Ogre@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@6B@
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	DWORD PTR [edx+32], ecx
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 36					; 00000024H
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??0?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAE@ABV01@@Z ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 60					; 0000003cH
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 60					; 0000003cH
	call	??0?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAE@ABV01@@Z ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+84]
	mov	DWORD PTR [ecx+84], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1BaseKeyFrameArray@Ogre@@UAE@XZ	; Ogre::BaseKeyFrameArray::~BaseKeyFrameArray
__unwindfunclet$??0?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@QAE@ABV01@@Z$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	jmp	??1?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::~vector<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >
__unwindfunclet$??0?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@QAE@ABV01@@Z$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 60					; 0000003cH
	jmp	??1?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::~vector<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >
__ehhandler$??0?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@QAE@ABV01@@Z ENDP ; Ogre::KeyFrameArray<Ogre::ColourValue>::KeyFrameArray<Ogre::ColourValue>
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@UAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@UAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??1?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@UAE@XZ$2
__ehfuncinfo$??1?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@UAE@XZ DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??1?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@UAE@XZ PROC ; Ogre::KeyFrameArray<Ogre::ColourValue>::~KeyFrameArray<Ogre::ColourValue>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@UAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 2
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 60					; 0000003cH
	call	??1?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::~vector<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??1?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::~vector<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1BaseKeyFrameArray@Ogre@@UAE@XZ	; Ogre::BaseKeyFrameArray::~BaseKeyFrameArray
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@UAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1BaseKeyFrameArray@Ogre@@UAE@XZ	; Ogre::BaseKeyFrameArray::~BaseKeyFrameArray
__unwindfunclet$??1?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@UAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	jmp	??1?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::~vector<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >
__unwindfunclet$??1?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@UAE@XZ$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 60					; 0000003cH
	jmp	??1?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::~vector<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >
__ehhandler$??1?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@UAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@UAE@XZ ENDP ; Ogre::KeyFrameArray<Ogre::ColourValue>::~KeyFrameArray<Ogre::ColourValue>
; Function compile flags: /Odtp
;	COMDAT ??_G?$KeyFrameArray@M@Ogre@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G?$KeyFrameArray@M@Ogre@@UAEPAXI@Z PROC		; Ogre::KeyFrameArray<float>::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$KeyFrameArray@M@Ogre@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@17
	push	88					; 00000058H
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3MemoryDelegation@Ogre@@SAXPAXI@Z	; Ogre::MemoryDelegation::operator delete
	add	esp, 8
$LN1@scalar@17:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_G?$KeyFrameArray@M@Ogre@@UAEPAXI@Z ENDP		; Ogre::KeyFrameArray<float>::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??0?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAE@ABV01@@Z ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0BaseKeyFrameArray@Ogre@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0BaseKeyFrameArray@Ogre@@QAE@ABV01@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0BaseKeyFrameArray@Ogre@@QAE@ABV01@@Z$1
__ehfuncinfo$??0BaseKeyFrameArray@Ogre@@QAE@ABV01@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0BaseKeyFrameArray@Ogre@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0BaseKeyFrameArray@Ogre@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0BaseKeyFrameArray@Ogre@@QAE@ABV01@@Z PROC		; Ogre::BaseKeyFrameArray::BaseKeyFrameArray, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0BaseKeyFrameArray@Ogre@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0BaseObject@Ogre@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7BaseKeyFrameArray@Ogre@@6B@
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 8
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??0?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAE@ABV01@@Z ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0BaseKeyFrameArray@Ogre@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1BaseObject@Ogre@@MAE@XZ		; Ogre::BaseObject::~BaseObject
__unwindfunclet$??0BaseKeyFrameArray@Ogre@@QAE@ABV01@@Z$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	jmp	??1?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::~vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >
__ehhandler$??0BaseKeyFrameArray@Ogre@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0BaseKeyFrameArray@Ogre@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0BaseKeyFrameArray@Ogre@@QAE@ABV01@@Z ENDP		; Ogre::BaseKeyFrameArray::BaseKeyFrameArray
; Function compile flags: /Odtp
;	COMDAT ??_G?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@UAEPAXI@Z PROC ; Ogre::KeyFrameArray<Ogre::ColourValue>::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@18
	push	88					; 00000058H
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3MemoryDelegation@Ogre@@SAXPAXI@Z	; Ogre::MemoryDelegation::operator delete
	add	esp, 8
$LN1@scalar@18:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_G?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@UAEPAXI@Z ENDP ; Ogre::KeyFrameArray<Ogre::ColourValue>::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??0Vector2@Ogre@@QAE@XZ				; Ogre::Vector2::Vector2
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogrevector2.h
;	COMDAT ??0Vector2@Ogre@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0Vector2@Ogre@@QAE@XZ PROC				; Ogre::Vector2::Vector2, COMDAT
; _this$ = ecx

; 50   : 		Vector2(){}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0Vector2@Ogre@@QAE@XZ ENDP				; Ogre::Vector2::Vector2
_TEXT	ENDS
PUBLIC	??0Vector2@Ogre@@QAE@MM@Z			; Ogre::Vector2::Vector2
; Function compile flags: /Odtp
;	COMDAT ??0Vector2@Ogre@@QAE@MM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_x1$ = 8						; size = 4
_y1$ = 12						; size = 4
??0Vector2@Ogre@@QAE@MM@Z PROC				; Ogre::Vector2::Vector2, COMDAT
; _this$ = ecx

; 51   : 		Vector2( float x1, float y1 ) : x(x1), y(y1){}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR _x1$[ebp]
	fstp	DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _y1$[ebp]
	fstp	DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0Vector2@Ogre@@QAE@MM@Z ENDP				; Ogre::Vector2::Vector2
_TEXT	ENDS
PUBLIC	??0Vector2@Ogre@@QAE@M@Z			; Ogre::Vector2::Vector2
; Function compile flags: /Odtp
;	COMDAT ??0Vector2@Ogre@@QAE@M@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_v$ = 8							; size = 4
??0Vector2@Ogre@@QAE@M@Z PROC				; Ogre::Vector2::Vector2, COMDAT
; _this$ = ecx

; 52   : 		Vector2(float v) : x(v), y(v){}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR _v$[ebp]
	fstp	DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _v$[ebp]
	fstp	DWORD PTR [ecx+4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0Vector2@Ogre@@QAE@M@Z ENDP				; Ogre::Vector2::Vector2
_TEXT	ENDS
PUBLIC	??4Vector2@Ogre@@QAEABV01@ABV01@@Z		; Ogre::Vector2::operator=
; Function compile flags: /Odtp
;	COMDAT ??4Vector2@Ogre@@QAEABV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_vec$ = 8						; size = 4
??4Vector2@Ogre@@QAEABV01@ABV01@@Z PROC			; Ogre::Vector2::operator=, COMDAT
; _this$ = ecx

; 55   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 56   : 			x = vec.x;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _vec$[ebp]
	fld	DWORD PTR [ecx]
	fstp	DWORD PTR [eax]

; 57   : 			y = vec.y;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _vec$[ebp]
	fld	DWORD PTR [eax+4]
	fstp	DWORD PTR [edx+4]

; 58   : 			return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 59   : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??4Vector2@Ogre@@QAEABV01@ABV01@@Z ENDP			; Ogre::Vector2::operator=
_TEXT	ENDS
PUBLIC	??YVector2@Ogre@@QAEXABV01@@Z			; Ogre::Vector2::operator+=
; Function compile flags: /Odtp
;	COMDAT ??YVector2@Ogre@@QAEXABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_vec$ = 8						; size = 4
??YVector2@Ogre@@QAEXABV01@@Z PROC			; Ogre::Vector2::operator+=, COMDAT
; _this$ = ecx

; 61   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 62   : 			x += vec.x;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax]
	mov	ecx, DWORD PTR _vec$[ebp]
	fadd	DWORD PTR [ecx]
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx]

; 63   : 			y += vec.y;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _vec$[ebp]
	fadd	DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+4]

; 64   : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??YVector2@Ogre@@QAEXABV01@@Z ENDP			; Ogre::Vector2::operator+=
_TEXT	ENDS
PUBLIC	??ZVector2@Ogre@@QAEXABV01@@Z			; Ogre::Vector2::operator-=
; Function compile flags: /Odtp
;	COMDAT ??ZVector2@Ogre@@QAEXABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_vec$ = 8						; size = 4
??ZVector2@Ogre@@QAEXABV01@@Z PROC			; Ogre::Vector2::operator-=, COMDAT
; _this$ = ecx

; 66   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 67   : 			x -= vec.x;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax]
	mov	ecx, DWORD PTR _vec$[ebp]
	fsub	DWORD PTR [ecx]
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx]

; 68   : 			y -= vec.y;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _vec$[ebp]
	fsub	DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+4]

; 69   : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??ZVector2@Ogre@@QAEXABV01@@Z ENDP			; Ogre::Vector2::operator-=
_TEXT	ENDS
PUBLIC	??XVector2@Ogre@@QAEXM@Z			; Ogre::Vector2::operator*=
; Function compile flags: /Odtp
;	COMDAT ??XVector2@Ogre@@QAEXM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_s$ = 8							; size = 4
??XVector2@Ogre@@QAEXM@Z PROC				; Ogre::Vector2::operator*=, COMDAT
; _this$ = ecx

; 71   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 72   : 			x *= s;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax]
	fmul	DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx]

; 73   : 			y *= s;

	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+4]
	fmul	DWORD PTR _s$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [eax+4]

; 74   : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??XVector2@Ogre@@QAEXM@Z ENDP				; Ogre::Vector2::operator*=
_TEXT	ENDS
PUBLIC	??_0Vector2@Ogre@@QAEXM@Z			; Ogre::Vector2::operator/=
; Function compile flags: /Odtp
;	COMDAT ??_0Vector2@Ogre@@QAEXM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_s$ = 8							; size = 4
??_0Vector2@Ogre@@QAEXM@Z PROC				; Ogre::Vector2::operator/=, COMDAT
; _this$ = ecx

; 76   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 77   : 			x /= s;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax]
	fdiv	DWORD PTR _s$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx]

; 78   : 			y /= s;

	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+4]
	fdiv	DWORD PTR _s$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [eax+4]

; 79   : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??_0Vector2@Ogre@@QAEXM@Z ENDP				; Ogre::Vector2::operator/=
_TEXT	ENDS
PUBLIC	??8Vector2@Ogre@@QAE_NABV01@@Z			; Ogre::Vector2::operator==
; Function compile flags: /Odtp
;	COMDAT ??8Vector2@Ogre@@QAE_NABV01@@Z
_TEXT	SEGMENT
tv72 = -8						; size = 4
_this$ = -4						; size = 4
_vec$ = 8						; size = 4
??8Vector2@Ogre@@QAE_NABV01@@Z PROC			; Ogre::Vector2::operator==, COMDAT
; _this$ = ecx

; 81   : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 82   : 			return x==vec.x&&y==vec.y;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax]
	mov	ecx, DWORD PTR _vec$[ebp]
	fld	DWORD PTR [ecx]
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	SHORT $LN3@operator@7
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+4]
	mov	eax, DWORD PTR _vec$[ebp]
	fld	DWORD PTR [eax+4]
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	SHORT $LN3@operator@7
	mov	DWORD PTR tv72[ebp], 1
	jmp	SHORT $LN4@operator@7
$LN3@operator@7:
	mov	DWORD PTR tv72[ebp], 0
$LN4@operator@7:
	mov	al, BYTE PTR tv72[ebp]

; 83   : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??8Vector2@Ogre@@QAE_NABV01@@Z ENDP			; Ogre::Vector2::operator==
_TEXT	ENDS
PUBLIC	??9Vector2@Ogre@@QAE_NABV01@@Z			; Ogre::Vector2::operator!=
; Function compile flags: /Odtp
;	COMDAT ??9Vector2@Ogre@@QAE_NABV01@@Z
_TEXT	SEGMENT
tv72 = -8						; size = 4
_this$ = -4						; size = 4
_vec$ = 8						; size = 4
??9Vector2@Ogre@@QAE_NABV01@@Z PROC			; Ogre::Vector2::operator!=, COMDAT
; _this$ = ecx

; 85   : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 86   : 			return x!=vec.x||y!=vec.y;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax]
	mov	ecx, DWORD PTR _vec$[ebp]
	fld	DWORD PTR [ecx]
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	SHORT $LN3@operator@8
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+4]
	mov	eax, DWORD PTR _vec$[ebp]
	fld	DWORD PTR [eax+4]
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	SHORT $LN3@operator@8
	mov	DWORD PTR tv72[ebp], 0
	jmp	SHORT $LN4@operator@8
$LN3@operator@8:
	mov	DWORD PTR tv72[ebp], 1
$LN4@operator@8:
	mov	al, BYTE PTR tv72[ebp]

; 87   : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??9Vector2@Ogre@@QAE_NABV01@@Z ENDP			; Ogre::Vector2::operator!=
_TEXT	ENDS
PUBLIC	??BVector2@Ogre@@QAEPAMXZ			; Ogre::Vector2::operator float *
; Function compile flags: /Odtp
;	COMDAT ??BVector2@Ogre@@QAEPAMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??BVector2@Ogre@@QAEPAMXZ PROC				; Ogre::Vector2::operator float *, COMDAT
; _this$ = ecx

; 89   : 		operator float *(){ return &x; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??BVector2@Ogre@@QAEPAMXZ ENDP				; Ogre::Vector2::operator float *
_TEXT	ENDS
PUBLIC	??BVector2@Ogre@@QBEPBMXZ			; Ogre::Vector2::operator float const *
; Function compile flags: /Odtp
;	COMDAT ??BVector2@Ogre@@QBEPBMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??BVector2@Ogre@@QBEPBMXZ PROC				; Ogre::Vector2::operator float const *, COMDAT
; _this$ = ecx

; 90   : 		operator const float *() const{ return &x; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??BVector2@Ogre@@QBEPBMXZ ENDP				; Ogre::Vector2::operator float const *
_TEXT	ENDS
PUBLIC	??HVector2@Ogre@@QBE?AV01@XZ			; Ogre::Vector2::operator+
; Function compile flags: /Odtp
;	COMDAT ??HVector2@Ogre@@QBE?AV01@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
??HVector2@Ogre@@QBE?AV01@XZ PROC			; Ogre::Vector2::operator+, COMDAT
; _this$ = ecx

; 91   : 		Vector2 operator +() const{ return *this; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??HVector2@Ogre@@QBE?AV01@XZ ENDP			; Ogre::Vector2::operator+
_TEXT	ENDS
PUBLIC	??GVector2@Ogre@@QBE?AV01@XZ			; Ogre::Vector2::operator-
; Function compile flags: /Odtp
;	COMDAT ??GVector2@Ogre@@QBE?AV01@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
??GVector2@Ogre@@QBE?AV01@XZ PROC			; Ogre::Vector2::operator-, COMDAT
; _this$ = ecx

; 92   : 		Vector2 operator -() const{ return Vector2(-x,-y);}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+4]
	fchs
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx]
	fchs
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector2@Ogre@@QAE@MM@Z		; Ogre::Vector2::Vector2
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??GVector2@Ogre@@QBE?AV01@XZ ENDP			; Ogre::Vector2::operator-
_TEXT	ENDS
PUBLIC	?setElement@Vector2@Ogre@@QAEXMM@Z		; Ogre::Vector2::setElement
; Function compile flags: /Odtp
;	COMDAT ?setElement@Vector2@Ogre@@QAEXMM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_x1$ = 8						; size = 4
_y1$ = 12						; size = 4
?setElement@Vector2@Ogre@@QAEXMM@Z PROC			; Ogre::Vector2::setElement, COMDAT
; _this$ = ecx

; 95   : 		{ 

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 96   : 			x = x1;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR _x1$[ebp]
	fstp	DWORD PTR [eax]

; 97   : 			y = y1;

	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _y1$[ebp]
	fstp	DWORD PTR [ecx+4]

; 98   : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?setElement@Vector2@Ogre@@QAEXMM@Z ENDP			; Ogre::Vector2::setElement
_TEXT	ENDS
PUBLIC	?length@Vector2@Ogre@@QBEMXZ			; Ogre::Vector2::length
; Function compile flags: /Odtp
;	COMDAT ?length@Vector2@Ogre@@QBEMXZ
_TEXT	SEGMENT
tv80 = -8						; size = 4
_this$ = -4						; size = 4
?length@Vector2@Ogre@@QBEMXZ PROC			; Ogre::Vector2::length, COMDAT
; _this$ = ecx

; 100  : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 101  : 			return (float)sqrt(x*x + y*y);

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	fmul	DWORD PTR [ecx]
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+4]
	mov	eax, DWORD PTR _this$[ebp]
	fmul	DWORD PTR [eax+4]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR tv80[ebp]
	fld	DWORD PTR tv80[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	call	?sqrt@@YAMM@Z				; sqrt
	add	esp, 4

; 102  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?length@Vector2@Ogre@@QBEMXZ ENDP			; Ogre::Vector2::length
_TEXT	ENDS
PUBLIC	?lengthSqr@Vector2@Ogre@@QBEMXZ			; Ogre::Vector2::lengthSqr
; Function compile flags: /Odtp
;	COMDAT ?lengthSqr@Vector2@Ogre@@QBEMXZ
_TEXT	SEGMENT
tv78 = -8						; size = 4
_this$ = -4						; size = 4
?lengthSqr@Vector2@Ogre@@QBEMXZ PROC			; Ogre::Vector2::lengthSqr, COMDAT
; _this$ = ecx

; 104  : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 105  : 			return x*x + y*y;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	fmul	DWORD PTR [ecx]
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+4]
	mov	eax, DWORD PTR _this$[ebp]
	fmul	DWORD PTR [eax+4]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR tv78[ebp]
	fld	DWORD PTR tv78[ebp]

; 106  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?lengthSqr@Vector2@Ogre@@QBEMXZ ENDP			; Ogre::Vector2::lengthSqr
_TEXT	ENDS
PUBLIC	?size@?$vector@VVertexElement@Ogre@@V?$allocator@VVertexElement@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::VertexElement,std::allocator<Ogre::VertexElement> >::size
PUBLIC	?getNumElements@VertexFormat@Ogre@@QBEIXZ	; Ogre::VertexFormat::getNumElements
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogrevertexformat.h
;	COMDAT ?getNumElements@VertexFormat@Ogre@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getNumElements@VertexFormat@Ogre@@QBEIXZ PROC		; Ogre::VertexFormat::getNumElements, COMDAT
; _this$ = ecx

; 82   : 		uint getNumElements() const{ return (uint)m_Elements.size(); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@VVertexElement@Ogre@@V?$allocator@VVertexElement@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::VertexElement,std::allocator<Ogre::VertexElement> >::size
	mov	esp, ebp
	pop	ebp
	ret	0
?getNumElements@VertexFormat@Ogre@@QBEIXZ ENDP		; Ogre::VertexFormat::getNumElements
_TEXT	ENDS
PUBLIC	??A?$vector@VVertexElement@Ogre@@V?$allocator@VVertexElement@Ogre@@@std@@@std@@QBEABVVertexElement@Ogre@@I@Z ; std::vector<Ogre::VertexElement,std::allocator<Ogre::VertexElement> >::operator[]
PUBLIC	?getElement@VertexFormat@Ogre@@QBEABVVertexElement@2@I@Z ; Ogre::VertexFormat::getElement
; Function compile flags: /Odtp
;	COMDAT ?getElement@VertexFormat@Ogre@@QBEABVVertexElement@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_i$ = 8							; size = 4
?getElement@VertexFormat@Ogre@@QBEABVVertexElement@2@I@Z PROC ; Ogre::VertexFormat::getElement, COMDAT
; _this$ = ecx

; 83   : 		const VertexElement &getElement(uint i) const{ return m_Elements[i]; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$vector@VVertexElement@Ogre@@V?$allocator@VVertexElement@Ogre@@@std@@@std@@QBEABVVertexElement@Ogre@@I@Z ; std::vector<Ogre::VertexElement,std::allocator<Ogre::VertexElement> >::operator[]
	mov	esp, ebp
	pop	ebp
	ret	4
?getElement@VertexFormat@Ogre@@QBEABVVertexElement@2@I@Z ENDP ; Ogre::VertexFormat::getElement
_TEXT	ENDS
PUBLIC	?getRTTI@ParametricShape@Ogre@@UBEPBVRuntimeClass@2@XZ ; Ogre::ParametricShape::getRTTI
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogreparametricshape.h
;	COMDAT ?getRTTI@ParametricShape@Ogre@@UBEPBVRuntimeClass@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getRTTI@ParametricShape@Ogre@@UBEPBVRuntimeClass@2@XZ PROC ; Ogre::ParametricShape::getRTTI, COMDAT
; _this$ = ecx

; 57   : 		DECLARE_RTTI(ParametricShape)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, OFFSET ?m_RTTI@ParametricShape@Ogre@@2VRuntimeClass@2@B ; Ogre::ParametricShape::m_RTTI
	mov	esp, ebp
	pop	ebp
	ret	0
?getRTTI@ParametricShape@Ogre@@UBEPBVRuntimeClass@2@XZ ENDP ; Ogre::ParametricShape::getRTTI
_TEXT	ENDS
PUBLIC	??0ParametricShape@Ogre@@QAE@PAVParamShapeData@1@@Z ; Ogre::ParametricShape::ParametricShape
PUBLIC	?newObject@ParametricShape@Ogre@@SAPAVBaseObject@2@XZ ; Ogre::ParametricShape::newObject
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?newObject@ParametricShape@Ogre@@SAPAVBaseObject@2@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?newObject@ParametricShape@Ogre@@SAPAVBaseObject@2@XZ$0
__ehfuncinfo$?newObject@ParametricShape@Ogre@@SAPAVBaseObject@2@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?newObject@ParametricShape@Ogre@@SAPAVBaseObject@2@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?newObject@ParametricShape@Ogre@@SAPAVBaseObject@2@XZ
_TEXT	SEGMENT
tv76 = -24						; size = 4
$T93997 = -20						; size = 4
$T93996 = -16						; size = 4
__$EHRec$ = -12						; size = 12
?newObject@ParametricShape@Ogre@@SAPAVBaseObject@2@XZ PROC ; Ogre::ParametricShape::newObject, COMDAT

; 57   : 		DECLARE_RTTI(ParametricShape)

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?newObject@ParametricShape@Ogre@@SAPAVBaseObject@2@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 12					; 0000000cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	push	444					; 000001bcH
	call	??2MemoryDelegation@Ogre@@SAPAXI@Z	; Ogre::MemoryDelegation::operator new
	add	esp, 4
	mov	DWORD PTR $T93997[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T93997[ebp], 0
	je	SHORT $LN3@newObject@2
	push	0
	mov	ecx, DWORD PTR $T93997[ebp]
	call	??0ParametricShape@Ogre@@QAE@PAVParamShapeData@1@@Z ; Ogre::ParametricShape::ParametricShape
	mov	DWORD PTR tv76[ebp], eax
	jmp	SHORT $LN4@newObject@2
$LN3@newObject@2:
	mov	DWORD PTR tv76[ebp], 0
$LN4@newObject@2:
	mov	eax, DWORD PTR tv76[ebp]
	mov	DWORD PTR $T93996[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR $T93996[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?newObject@ParametricShape@Ogre@@SAPAVBaseObject@2@XZ$0:
	push	444					; 000001bcH
	mov	eax, DWORD PTR $T93997[ebp]
	push	eax
	call	??3MemoryDelegation@Ogre@@SAXPAXI@Z	; Ogre::MemoryDelegation::operator delete
	add	esp, 8
	ret	0
__ehhandler$?newObject@ParametricShape@Ogre@@SAPAVBaseObject@2@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?newObject@ParametricShape@Ogre@@SAPAVBaseObject@2@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?newObject@ParametricShape@Ogre@@SAPAVBaseObject@2@XZ ENDP ; Ogre::ParametricShape::newObject
PUBLIC	?ResetTime@ParametricShape@Ogre@@QAEXI@Z	; Ogre::ParametricShape::ResetTime
; Function compile flags: /Odtp
;	COMDAT ?ResetTime@ParametricShape@Ogre@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_tick$ = 8						; size = 4
?ResetTime@ParametricShape@Ogre@@QAEXI@Z PROC		; Ogre::ParametricShape::ResetTime, COMDAT
; _this$ = ecx

; 77   : 		void ResetTime(uint tick)			{ m_CurTick = tick; };

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _tick$[ebp]
	mov	DWORD PTR [eax+284], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?ResetTime@ParametricShape@Ogre@@QAEXI@Z ENDP		; Ogre::ParametricShape::ResetTime
_TEXT	ENDS
PUBLIC	??_7ParametricShape@Ogre@@6B@			; Ogre::ParametricShape::`vftable'
PUBLIC	??0ParametricShape@Ogre@@QAE@ABV01@@Z		; Ogre::ParametricShape::ParametricShape
PUBLIC	??_R4ParametricShape@Ogre@@6B@			; Ogre::ParametricShape::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVParametricShape@Ogre@@@8		; Ogre::ParametricShape `RTTI Type Descriptor'
PUBLIC	??_R3ParametricShape@Ogre@@8			; Ogre::ParametricShape::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2ParametricShape@Ogre@@8			; Ogre::ParametricShape::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@ParametricShape@Ogre@@8		; Ogre::ParametricShape::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_EParametricShape@Ogre@@MAEPAXI@Z		; Ogre::ParametricShape::`vector deleting destructor'
PUBLIC	?update@ParametricShape@Ogre@@UAEXI@Z		; Ogre::ParametricShape::update
PUBLIC	?resetUpdate@ParametricShape@Ogre@@UAEX_NI@Z	; Ogre::ParametricShape::resetUpdate
PUBLIC	?render@ParametricShape@Ogre@@UAEXPAVSceneRenderer@2@ABUShaderEnvData@2@@Z ; Ogre::ParametricShape::render
PUBLIC	?getRenderPassRequired@ParametricShape@Ogre@@UAEXAAURenderPassDesc@2@@Z ; Ogre::ParametricShape::getRenderPassRequired
EXTRN	??1VertexFormat@Ogre@@QAE@XZ:PROC		; Ogre::VertexFormat::~VertexFormat
EXTRN	??0VertexFormat@Ogre@@QAE@ABV01@@Z:PROC		; Ogre::VertexFormat::VertexFormat
;	COMDAT ??_R1A@?0A@EA@ParametricShape@Ogre@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@ParametricShape@Ogre@@8 DD FLAT:??_R0?AVParametricShape@Ogre@@@8 ; Ogre::ParametricShape::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	04H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3ParametricShape@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R2ParametricShape@Ogre@@8
rdata$r	SEGMENT
??_R2ParametricShape@Ogre@@8 DD FLAT:??_R1A@?0A@EA@ParametricShape@Ogre@@8 ; Ogre::ParametricShape::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@RenderableObject@Ogre@@8
	DD	FLAT:??_R1A@?0A@EA@MovableObject@Ogre@@8
	DD	FLAT:??_R1A@?0A@EA@BaseObject@Ogre@@8
	DD	FLAT:??_R13?0A@EA@MemoryDelegation@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R3ParametricShape@Ogre@@8
rdata$r	SEGMENT
??_R3ParametricShape@Ogre@@8 DD 00H			; Ogre::ParametricShape::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	05H
	DD	FLAT:??_R2ParametricShape@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVParametricShape@Ogre@@@8
_DATA	SEGMENT
??_R0?AVParametricShape@Ogre@@@8 DD FLAT:??_7type_info@@6B@ ; Ogre::ParametricShape `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVParametricShape@Ogre@@', 00H
_DATA	ENDS
;	COMDAT ??_R4ParametricShape@Ogre@@6B@
rdata$r	SEGMENT
??_R4ParametricShape@Ogre@@6B@ DD 00H			; Ogre::ParametricShape::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVParametricShape@Ogre@@@8
	DD	FLAT:??_R3ParametricShape@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_7ParametricShape@Ogre@@6B@
CONST	SEGMENT
??_7ParametricShape@Ogre@@6B@ DD FLAT:??_R4ParametricShape@Ogre@@6B@ ; Ogre::ParametricShape::`vftable'
	DD	FLAT:?getRTTI@ParametricShape@Ogre@@UBEPBVRuntimeClass@2@XZ
	DD	FLAT:?release@BaseObject@Ogre@@UAEXXZ
	DD	FLAT:?addRef@BaseObject@Ogre@@UAEXXZ
	DD	FLAT:?getRefCount@BaseObject@Ogre@@UAEHXZ
	DD	FLAT:?_serialize@BaseObject@Ogre@@UAEXAAVArchive@2@H@Z
	DD	FLAT:??_EParametricShape@Ogre@@MAEPAXI@Z
	DD	FLAT:?deleteThis@BaseObject@Ogre@@MAEXXZ
	DD	FLAT:?enableUVMask@RenderableObject@Ogre@@UAEX_N0@Z
	DD	FLAT:?setLiuGuangTexture@RenderableObject@Ogre@@UAEXPBD@Z
	DD	FLAT:?setLiuGuangTexture@RenderableObject@Ogre@@UAEXPAVTextureData@2@@Z
	DD	FLAT:?SetForceShadowMapCull@MovableObject@Ogre@@UAEX_N@Z
	DD	FLAT:?update@ParametricShape@Ogre@@UAEXI@Z
	DD	FLAT:?resetUpdate@ParametricShape@Ogre@@UAEX_NI@Z
	DD	FLAT:?attachToScene@MovableObject@Ogre@@UAEXPAVGameScene@2@_N@Z
	DD	FLAT:?detachFromScene@MovableObject@Ogre@@UAEXXZ
	DD	FLAT:?intersectRay@MovableObject@Ogre@@UAE_NW4IntersectType@2@ABVRay@2@PAM@Z
	DD	FLAT:?getAnchorWorldMatrix@MovableObject@Ogre@@UAE?AVMatrix4@2@H@Z
	DD	FLAT:?invalidWorldCache@MovableObject@Ogre@@UAEXXZ
	DD	FLAT:?updateWorldCache@MovableObject@Ogre@@UAEXXZ
	DD	FLAT:?render@ParametricShape@Ogre@@UAEXPAVSceneRenderer@2@ABUShaderEnvData@2@@Z
	DD	FLAT:?setCanSel@RenderableObject@Ogre@@UAEX_N@Z
	DD	FLAT:?setLayer@RenderableObject@Ogre@@UAEXW4RenderLayer@2@@Z
	DD	FLAT:?BuildDecalMesh@RenderableObject@Ogre@@UAEXABVBoxBound@2@PAVVector3@2@PAGHHAAH3@Z
	DD	FLAT:?addRenderUsageBits@RenderableObject@Ogre@@UAEXW4RenderUsage@2@@Z
	DD	FLAT:?clearRenderUsageBits@RenderableObject@Ogre@@UAEXW4RenderUsage@2@@Z
	DD	FLAT:?getRenderPassRequired@ParametricShape@Ogre@@UAEXAAURenderPassDesc@2@@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0ParametricShape@Ogre@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0ParametricShape@Ogre@@QAE@ABV01@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0ParametricShape@Ogre@@QAE@ABV01@@Z$1
__ehfuncinfo$??0ParametricShape@Ogre@@QAE@ABV01@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0ParametricShape@Ogre@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0ParametricShape@Ogre@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0ParametricShape@Ogre@@QAE@ABV01@@Z PROC		; Ogre::ParametricShape::ParametricShape, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0ParametricShape@Ogre@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0RenderableObject@Ogre@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7ParametricShape@Ogre@@6B@
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+280]
	mov	DWORD PTR [edx+280], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+284]
	mov	DWORD PTR [edx+284], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+288]
	mov	DWORD PTR [edx+288], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+292]
	mov	DWORD PTR [edx+292], ecx
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 296				; 00000128H
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 296				; 00000128H
	call	??0VertexFormat@Ogre@@QAE@ABV01@@Z	; Ogre::VertexFormat::VertexFormat
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+320]
	mov	DWORD PTR [eax+320], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+324]
	mov	DWORD PTR [eax+324], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+328]
	mov	DWORD PTR [eax+328], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+332]
	mov	DWORD PTR [eax+332], edx
	mov	esi, DWORD PTR ___that$[ebp]
	add	esi, 336				; 00000150H
	mov	edi, DWORD PTR _this$[ebp]
	add	edi, 336				; 00000150H
	mov	ecx, 27					; 0000001bH
	rep movsd
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0ParametricShape@Ogre@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1RenderableObject@Ogre@@MAE@XZ	; Ogre::RenderableObject::~RenderableObject
__unwindfunclet$??0ParametricShape@Ogre@@QAE@ABV01@@Z$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 296				; 00000128H
	jmp	??1VertexFormat@Ogre@@QAE@XZ		; Ogre::VertexFormat::~VertexFormat
__ehhandler$??0ParametricShape@Ogre@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0ParametricShape@Ogre@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0ParametricShape@Ogre@@QAE@ABV01@@Z ENDP		; Ogre::ParametricShape::ParametricShape
PUBLIC	??4ParametricShape@Ogre@@QAEAAV01@ABV01@@Z	; Ogre::ParametricShape::operator=
EXTRN	??4VertexFormat@Ogre@@QAEAAV01@ABV01@@Z:PROC	; Ogre::VertexFormat::operator=
; Function compile flags: /Odtp
;	COMDAT ??4ParametricShape@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4ParametricShape@Ogre@@QAEAAV01@ABV01@@Z PROC		; Ogre::ParametricShape::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4RenderableObject@Ogre@@QAEAAV01@ABV01@@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+280]
	mov	DWORD PTR [ecx+280], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+284]
	mov	DWORD PTR [ecx+284], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+288]
	mov	DWORD PTR [ecx+288], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+292]
	mov	DWORD PTR [ecx+292], eax
	mov	ecx, DWORD PTR ___that$[ebp]
	add	ecx, 296				; 00000128H
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 296				; 00000128H
	call	??4VertexFormat@Ogre@@QAEAAV01@ABV01@@Z	; Ogre::VertexFormat::operator=
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+320]
	mov	DWORD PTR [edx+320], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+324]
	mov	DWORD PTR [edx+324], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+328]
	mov	DWORD PTR [edx+328], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+332]
	mov	DWORD PTR [edx+332], ecx
	mov	esi, DWORD PTR ___that$[ebp]
	add	esi, 336				; 00000150H
	mov	edi, DWORD PTR _this$[ebp]
	add	edi, 336				; 00000150H
	mov	ecx, 27					; 0000001bH
	rep movsd
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
??4ParametricShape@Ogre@@QAEAAV01@ABV01@@Z ENDP		; Ogre::ParametricShape::operator=
_TEXT	ENDS
PUBLIC	??_FParametricShape@Ogre@@QAEXXZ		; Ogre::ParametricShape::`default constructor closure'
; Function compile flags: /Odtp
;	COMDAT ??_FParametricShape@Ogre@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??_FParametricShape@Ogre@@QAEXXZ PROC			; Ogre::ParametricShape::`default constructor closure', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0ParametricShape@Ogre@@QAE@PAVParamShapeData@1@@Z ; Ogre::ParametricShape::ParametricShape
	mov	esp, ebp
	pop	ebp
	ret	0
??_FParametricShape@Ogre@@QAEXXZ ENDP			; Ogre::ParametricShape::`default constructor closure'
_TEXT	ENDS
PUBLIC	??1ParametricShape@Ogre@@MAE@XZ			; Ogre::ParametricShape::~ParametricShape
PUBLIC	??_GParametricShape@Ogre@@MAEPAXI@Z		; Ogre::ParametricShape::`scalar deleting destructor'
; Function compile flags: /Odtp
;	COMDAT ??_GParametricShape@Ogre@@MAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GParametricShape@Ogre@@MAEPAXI@Z PROC		; Ogre::ParametricShape::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1ParametricShape@Ogre@@MAE@XZ		; Ogre::ParametricShape::~ParametricShape
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@19
	push	444					; 000001bcH
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3MemoryDelegation@Ogre@@SAXPAXI@Z	; Ogre::MemoryDelegation::operator delete
	add	esp, 8
$LN1@scalar@19:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GParametricShape@Ogre@@MAEPAXI@Z ENDP		; Ogre::ParametricShape::`scalar deleting destructor'
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_EParametricShape@Ogre@@MAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_EParametricShape@Ogre@@MAEPAXI@Z PROC		; Ogre::ParametricShape::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 2
	je	SHORT $LN3@vector@16
	push	OFFSET ??1ParametricShape@Ogre@@MAE@XZ	; Ogre::ParametricShape::~ParametricShape
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx-4]
	push	edx
	push	444					; 000001bcH
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??_M@YGXPAXIHP6EX0@Z@Z
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN2@vector@16
	push	444					; 000001bcH
	mov	edx, DWORD PTR _this$[ebp]
	sub	edx, 4
	push	edx
	call	??_VMemoryDelegation@Ogre@@SAXPAXI@Z	; Ogre::MemoryDelegation::operator delete[]
	add	esp, 8
$LN2@vector@16:
	mov	eax, DWORD PTR _this$[ebp]
	sub	eax, 4
	jmp	SHORT $LN4@vector@16
$LN3@vector@16:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1ParametricShape@Ogre@@MAE@XZ		; Ogre::ParametricShape::~ParametricShape
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@vector@16
	push	444					; 000001bcH
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3MemoryDelegation@Ogre@@SAXPAXI@Z	; Ogre::MemoryDelegation::operator delete
	add	esp, 8
$LN1@vector@16:
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector@16:
	mov	esp, ebp
	pop	ebp
	ret	4
??_EParametricShape@Ogre@@MAEPAXI@Z ENDP		; Ogre::ParametricShape::`vector deleting destructor'
_TEXT	ENDS
PUBLIC	?getCapabilities@RenderSystem@Ogre@@QBEPBVRenderSystemCapabilities@2@XZ ; Ogre::RenderSystem::getCapabilities
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogrerendersystem.h
;	COMDAT ?getCapabilities@RenderSystem@Ogre@@QBEPBVRenderSystemCapabilities@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getCapabilities@RenderSystem@Ogre@@QBEPBVRenderSystemCapabilities@2@XZ PROC ; Ogre::RenderSystem::getCapabilities, COMDAT
; _this$ = ecx

; 126  : 		const RenderSystemCapabilities* getCapabilities(void) const { return m_Capabilities; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+48]
	mov	esp, ebp
	pop	ebp
	ret	0
?getCapabilities@RenderSystem@Ogre@@QBEPBVRenderSystemCapabilities@2@XZ ENDP ; Ogre::RenderSystem::getCapabilities
_TEXT	ENDS
PUBLIC	?getWireframeShader@RenderSystem@Ogre@@QAEPAVShaderTechnique@2@XZ ; Ogre::RenderSystem::getWireframeShader
; Function compile flags: /Odtp
;	COMDAT ?getWireframeShader@RenderSystem@Ogre@@QAEPAVShaderTechnique@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getWireframeShader@RenderSystem@Ogre@@QAEPAVShaderTechnique@2@XZ PROC ; Ogre::RenderSystem::getWireframeShader, COMDAT
; _this$ = ecx

; 129  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 130  : 			return m_pWireframeShader;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+52]

; 131  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?getWireframeShader@RenderSystem@Ogre@@QAEPAVShaderTechnique@2@XZ ENDP ; Ogre::RenderSystem::getWireframeShader
_TEXT	ENDS
PUBLIC	?GetRenderLevel@RenderSystem@Ogre@@QAEHXZ	; Ogre::RenderSystem::GetRenderLevel
; Function compile flags: /Odtp
;	COMDAT ?GetRenderLevel@RenderSystem@Ogre@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetRenderLevel@RenderSystem@Ogre@@QAEHXZ PROC		; Ogre::RenderSystem::GetRenderLevel, COMDAT
; _this$ = ecx

; 134  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 135  : 			return m_iLevel;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+56]

; 136  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?GetRenderLevel@RenderSystem@Ogre@@QAEHXZ ENDP		; Ogre::RenderSystem::GetRenderLevel
_TEXT	ENDS
PUBLIC	?SetSaveCompiledShaders@RenderSystem@Ogre@@QAEX_N@Z ; Ogre::RenderSystem::SetSaveCompiledShaders
; Function compile flags: /Odtp
;	COMDAT ?SetSaveCompiledShaders@RenderSystem@Ogre@@QAEX_N@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_bSave$ = 8						; size = 1
?SetSaveCompiledShaders@RenderSystem@Ogre@@QAEX_N@Z PROC ; Ogre::RenderSystem::SetSaveCompiledShaders, COMDAT
; _this$ = ecx

; 139  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 140  : 			m_bSaveCompiledShader = bSave;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR _bSave$[ebp]
	mov	BYTE PTR [eax+60], cl

; 141  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?SetSaveCompiledShaders@RenderSystem@Ogre@@QAEX_N@Z ENDP ; Ogre::RenderSystem::SetSaveCompiledShaders
_TEXT	ENDS
PUBLIC	?IsSaveCompiledShaders@RenderSystem@Ogre@@QAE_NXZ ; Ogre::RenderSystem::IsSaveCompiledShaders
; Function compile flags: /Odtp
;	COMDAT ?IsSaveCompiledShaders@RenderSystem@Ogre@@QAE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsSaveCompiledShaders@RenderSystem@Ogre@@QAE_NXZ PROC	; Ogre::RenderSystem::IsSaveCompiledShaders, COMDAT
; _this$ = ecx

; 144  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 145  : 			return m_bSaveCompiledShader;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+60]

; 146  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?IsSaveCompiledShaders@RenderSystem@Ogre@@QAE_NXZ ENDP	; Ogre::RenderSystem::IsSaveCompiledShaders
_TEXT	ENDS
PUBLIC	?SetRestoreLostDeviceCallBack@RenderSystem@Ogre@@QAEXP6AXXZ@Z ; Ogre::RenderSystem::SetRestoreLostDeviceCallBack
; Function compile flags: /Odtp
;	COMDAT ?SetRestoreLostDeviceCallBack@RenderSystem@Ogre@@QAEXP6AXXZ@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pCallBack$ = 8						; size = 4
?SetRestoreLostDeviceCallBack@RenderSystem@Ogre@@QAEXP6AXXZ@Z PROC ; Ogre::RenderSystem::SetRestoreLostDeviceCallBack, COMDAT
; _this$ = ecx

; 148  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 149  : 			m_restoreDeviceCallBack = pCallBack;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pCallBack$[ebp]
	mov	DWORD PTR [eax+92], ecx

; 150  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?SetRestoreLostDeviceCallBack@RenderSystem@Ogre@@QAEXP6AXXZ@Z ENDP ; Ogre::RenderSystem::SetRestoreLostDeviceCallBack
_TEXT	ENDS
PUBLIC	??4?$Singleton@VRenderSystem@Ogre@@@Ogre@@QAEAAV01@ABV01@@Z ; Ogre::Singleton<Ogre::RenderSystem>::operator=
; Function compile flags: /Odtp
;	COMDAT ??4?$Singleton@VRenderSystem@Ogre@@@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4?$Singleton@VRenderSystem@Ogre@@@Ogre@@QAEAAV01@ABV01@@Z PROC ; Ogre::Singleton<Ogre::RenderSystem>::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4?$Singleton@VRenderSystem@Ogre@@@Ogre@@QAEAAV01@ABV01@@Z ENDP ; Ogre::Singleton<Ogre::RenderSystem>::operator=
_TEXT	ENDS
PUBLIC	??1?$Singleton@VRenderSystem@Ogre@@@Ogre@@QAE@XZ ; Ogre::Singleton<Ogre::RenderSystem>::~Singleton<Ogre::RenderSystem>
PUBLIC	??_7RenderSystem@Ogre@@6B@			; Ogre::RenderSystem::`vftable'
PUBLIC	??0RenderSystem@Ogre@@QAE@ABV01@@Z		; Ogre::RenderSystem::RenderSystem
PUBLIC	??_R4RenderSystem@Ogre@@6B@			; Ogre::RenderSystem::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVRenderSystem@Ogre@@@8			; Ogre::RenderSystem `RTTI Type Descriptor'
PUBLIC	??_R3RenderSystem@Ogre@@8			; Ogre::RenderSystem::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2RenderSystem@Ogre@@8			; Ogre::RenderSystem::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@RenderSystem@Ogre@@8		; Ogre::RenderSystem::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R13?0A@EA@?$Singleton@VRenderSystem@Ogre@@@Ogre@@8 ; Ogre::Singleton<Ogre::RenderSystem>::`RTTI Base Class Descriptor at (4,-1,0,64)'
PUBLIC	??_R0?AV?$Singleton@VRenderSystem@Ogre@@@Ogre@@@8 ; Ogre::Singleton<Ogre::RenderSystem> `RTTI Type Descriptor'
PUBLIC	??_R3?$Singleton@VRenderSystem@Ogre@@@Ogre@@8	; Ogre::Singleton<Ogre::RenderSystem>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$Singleton@VRenderSystem@Ogre@@@Ogre@@8	; Ogre::Singleton<Ogre::RenderSystem>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$Singleton@VRenderSystem@Ogre@@@Ogre@@8 ; Ogre::Singleton<Ogre::RenderSystem>::`RTTI Base Class Descriptor at (0,-1,0,64)'
;	COMDAT ??_R1A@?0A@EA@?$Singleton@VRenderSystem@Ogre@@@Ogre@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$Singleton@VRenderSystem@Ogre@@@Ogre@@8 DD FLAT:??_R0?AV?$Singleton@VRenderSystem@Ogre@@@Ogre@@@8 ; Ogre::Singleton<Ogre::RenderSystem>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$Singleton@VRenderSystem@Ogre@@@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R2?$Singleton@VRenderSystem@Ogre@@@Ogre@@8
rdata$r	SEGMENT
??_R2?$Singleton@VRenderSystem@Ogre@@@Ogre@@8 DD FLAT:??_R1A@?0A@EA@?$Singleton@VRenderSystem@Ogre@@@Ogre@@8 ; Ogre::Singleton<Ogre::RenderSystem>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3?$Singleton@VRenderSystem@Ogre@@@Ogre@@8
rdata$r	SEGMENT
??_R3?$Singleton@VRenderSystem@Ogre@@@Ogre@@8 DD 00H	; Ogre::Singleton<Ogre::RenderSystem>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$Singleton@VRenderSystem@Ogre@@@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$Singleton@VRenderSystem@Ogre@@@Ogre@@@8
_DATA	SEGMENT
??_R0?AV?$Singleton@VRenderSystem@Ogre@@@Ogre@@@8 DD FLAT:??_7type_info@@6B@ ; Ogre::Singleton<Ogre::RenderSystem> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$Singleton@VRenderSystem@Ogre@@@Ogre@@', 00H
_DATA	ENDS
;	COMDAT ??_R13?0A@EA@?$Singleton@VRenderSystem@Ogre@@@Ogre@@8
rdata$r	SEGMENT
??_R13?0A@EA@?$Singleton@VRenderSystem@Ogre@@@Ogre@@8 DD FLAT:??_R0?AV?$Singleton@VRenderSystem@Ogre@@@Ogre@@@8 ; Ogre::Singleton<Ogre::RenderSystem>::`RTTI Base Class Descriptor at (4,-1,0,64)'
	DD	00H
	DD	04H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$Singleton@VRenderSystem@Ogre@@@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@RenderSystem@Ogre@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@RenderSystem@Ogre@@8 DD FLAT:??_R0?AVRenderSystem@Ogre@@@8 ; Ogre::RenderSystem::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3RenderSystem@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R2RenderSystem@Ogre@@8
rdata$r	SEGMENT
??_R2RenderSystem@Ogre@@8 DD FLAT:??_R1A@?0A@EA@RenderSystem@Ogre@@8 ; Ogre::RenderSystem::`RTTI Base Class Array'
	DD	FLAT:??_R13?0A@EA@?$Singleton@VRenderSystem@Ogre@@@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R3RenderSystem@Ogre@@8
rdata$r	SEGMENT
??_R3RenderSystem@Ogre@@8 DD 00H			; Ogre::RenderSystem::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2RenderSystem@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVRenderSystem@Ogre@@@8
_DATA	SEGMENT
??_R0?AVRenderSystem@Ogre@@@8 DD FLAT:??_7type_info@@6B@ ; Ogre::RenderSystem `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVRenderSystem@Ogre@@', 00H
_DATA	ENDS
;	COMDAT ??_R4RenderSystem@Ogre@@6B@
rdata$r	SEGMENT
??_R4RenderSystem@Ogre@@6B@ DD 00H			; Ogre::RenderSystem::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVRenderSystem@Ogre@@@8
	DD	FLAT:??_R3RenderSystem@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_7RenderSystem@Ogre@@6B@
CONST	SEGMENT
??_7RenderSystem@Ogre@@6B@ DD FLAT:??_R4RenderSystem@Ogre@@6B@ ; Ogre::RenderSystem::`vftable'
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0RenderSystem@Ogre@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0RenderSystem@Ogre@@QAE@ABV01@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0RenderSystem@Ogre@@QAE@ABV01@@Z$1
__ehfuncinfo$??0RenderSystem@Ogre@@QAE@ABV01@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0RenderSystem@Ogre@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0RenderSystem@Ogre@@QAE@ABV01@@Z
_TEXT	SEGMENT
tv68 = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0RenderSystem@Ogre@@QAE@ABV01@@Z PROC			; Ogre::RenderSystem::RenderSystem, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0RenderSystem@Ogre@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	cmp	DWORD PTR ___that$[ebp], 0
	je	SHORT $LN3@RenderSyst
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 4
	mov	DWORD PTR tv68[ebp], eax
	jmp	SHORT $LN4@RenderSyst
$LN3@RenderSyst:
	mov	DWORD PTR tv68[ebp], 0
$LN4@RenderSyst:
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7RenderSystem@Ogre@@6B@
	mov	esi, DWORD PTR ___that$[ebp]
	add	esi, 4
	mov	edi, DWORD PTR _this$[ebp]
	add	edi, 4
	mov	ecx, 10					; 0000000aH
	rep movsd
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	cl, BYTE PTR [eax+44]
	mov	BYTE PTR [edx+44], cl
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	mov	DWORD PTR [edx+48], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	mov	DWORD PTR [edx+52], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+56]
	mov	DWORD PTR [edx+56], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	cl, BYTE PTR [eax+60]
	mov	BYTE PTR [edx+60], cl
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 64					; 00000040H
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 64					; 00000040H
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+92]
	mov	DWORD PTR [eax+92], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0RenderSystem@Ogre@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	jmp	??1?$Singleton@VRenderSystem@Ogre@@@Ogre@@QAE@XZ ; Ogre::Singleton<Ogre::RenderSystem>::~Singleton<Ogre::RenderSystem>
__unwindfunclet$??0RenderSystem@Ogre@@QAE@ABV01@@Z$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 64					; 00000040H
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$??0RenderSystem@Ogre@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0RenderSystem@Ogre@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0RenderSystem@Ogre@@QAE@ABV01@@Z ENDP			; Ogre::RenderSystem::RenderSystem
PUBLIC	??4RenderSystem@Ogre@@QAEAAV01@ABV01@@Z		; Ogre::RenderSystem::operator=
; Function compile flags: /Odtp
;	COMDAT ??4RenderSystem@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4RenderSystem@Ogre@@QAEAAV01@ABV01@@Z PROC		; Ogre::RenderSystem::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	esi, DWORD PTR ___that$[ebp]
	add	esi, 4
	mov	edi, DWORD PTR _this$[ebp]
	add	edi, 4
	mov	ecx, 10					; 0000000aH
	rep movsd
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	dl, BYTE PTR [ecx+44]
	mov	BYTE PTR [eax+44], dl
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+48]
	mov	DWORD PTR [eax+48], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+52]
	mov	DWORD PTR [eax+52], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+56]
	mov	DWORD PTR [eax+56], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	dl, BYTE PTR [ecx+60]
	mov	BYTE PTR [eax+60], dl
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 64					; 00000040H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 64					; 00000040H
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+92]
	mov	DWORD PTR [ecx+92], eax
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
??4RenderSystem@Ogre@@QAEAAV01@ABV01@@Z ENDP		; Ogre::RenderSystem::operator=
_TEXT	ENDS
PUBLIC	??__G@YGXPAX0IHP6EPAX00@Z@Z			; `vector copy constructor iterator'
PUBLIC	??0ShaderEnvData@Ogre@@QAE@ABU01@@Z		; Ogre::ShaderEnvData::ShaderEnvData
; Function compile flags: /Odtp
;	COMDAT ??0ShaderEnvData@Ogre@@QAE@ABU01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0ShaderEnvData@Ogre@@QAE@ABU01@@Z PROC		; Ogre::ShaderEnvData::ShaderEnvData, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	esi, DWORD PTR ___that$[ebp]
	add	esi, 8
	mov	edi, DWORD PTR _this$[ebp]
	add	edi, 8
	mov	ecx, 32					; 00000020H
	rep movsd
	mov	ecx, DWORD PTR ___that$[ebp]
	add	ecx, 136				; 00000088H
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 136				; 00000088H
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+12], ecx
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 152				; 00000098H
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 152				; 00000098H
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR [edx+12]
	mov	DWORD PTR [eax+12], edx
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 168				; 000000a8H
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 168				; 000000a8H
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], eax
	mov	ecx, DWORD PTR ___that$[ebp]
	add	ecx, 184				; 000000b8H
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 184				; 000000b8H
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+12], ecx
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 200				; 000000c8H
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 200				; 000000c8H
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR [edx+12]
	mov	DWORD PTR [eax+12], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+216]
	mov	DWORD PTR [eax+216], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+220]
	mov	DWORD PTR [eax+220], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+224]
	mov	DWORD PTR [eax+224], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+228]
	mov	DWORD PTR [eax+228], edx
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 232				; 000000e8H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 232				; 000000e8H
	call	??0Vector3@Ogre@@QAE@ABV01@@Z		; Ogre::Vector3::Vector3
	mov	ecx, DWORD PTR ___that$[ebp]
	add	ecx, 244				; 000000f4H
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 244				; 000000f4H
	call	??0Matrix4@Ogre@@QAE@ABV01@@Z		; Ogre::Matrix4::Matrix4
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 308				; 00000134H
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 308				; 00000134H
	call	??0Matrix4@Ogre@@QAE@ABV01@@Z		; Ogre::Matrix4::Matrix4
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 372				; 00000174H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 372				; 00000174H
	call	??0Matrix4@Ogre@@QAE@ABV01@@Z		; Ogre::Matrix4::Matrix4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	fld	DWORD PTR [edx+436]
	fstp	DWORD PTR [ecx+436]
	push	OFFSET ??0Matrix4@Ogre@@QAE@ABV01@@Z	; Ogre::Matrix4::Matrix4
	push	8
	push	64					; 00000040H
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 440				; 000001b8H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 440				; 000001b8H
	push	ecx
	call	??__G@YGXPAX0IHP6EPAX00@Z@Z
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 952				; 000003b8H
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 952				; 000003b8H
	call	??0Matrix4@Ogre@@QAE@ABV01@@Z		; Ogre::Matrix4::Matrix4
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 1016				; 000003f8H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1016				; 000003f8H
	call	??0Matrix4@Ogre@@QAE@ABV01@@Z		; Ogre::Matrix4::Matrix4
	mov	ecx, DWORD PTR ___that$[ebp]
	add	ecx, 1080				; 00000438H
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1080				; 00000438H
	call	??0Matrix4@Ogre@@QAE@ABV01@@Z		; Ogre::Matrix4::Matrix4
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 1144				; 00000478H
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1144				; 00000478H
	call	??0Vector3@Ogre@@QAE@ABV01@@Z		; Ogre::Vector3::Vector3
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 1156				; 00000484H
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1156				; 00000484H
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], eax
	mov	esi, DWORD PTR ___that$[ebp]
	add	esi, 1172				; 00000494H
	mov	edi, DWORD PTR _this$[ebp]
	add	edi, 1172				; 00000494H
	mov	ecx, 16					; 00000010H
	rep movsd
	mov	ecx, DWORD PTR ___that$[ebp]
	add	ecx, 1236				; 000004d4H
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1236				; 000004d4H
	call	??0Vector3@Ogre@@QAE@ABV01@@Z		; Ogre::Vector3::Vector3
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 1248				; 000004e0H
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1248				; 000004e0H
	call	??0Vector3@Ogre@@QAE@ABV01@@Z		; Ogre::Vector3::Vector3
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
??0ShaderEnvData@Ogre@@QAE@ABU01@@Z ENDP		; Ogre::ShaderEnvData::ShaderEnvData
_TEXT	ENDS
PUBLIC	??4Vector4@Ogre@@QAEABV01@ABV01@@Z		; Ogre::Vector4::operator=
PUBLIC	??4SED_LightData@Ogre@@QAEAAU01@ABU01@@Z	; Ogre::SED_LightData::operator=
PUBLIC	??4ShaderEnvData@Ogre@@QAEAAU01@ABU01@@Z	; Ogre::ShaderEnvData::operator=
; Function compile flags: /Odtp
;	COMDAT ??4ShaderEnvData@Ogre@@QAEAAU01@ABU01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
_$S4$62585 = -12					; size = 4
_$S3$62581 = -8						; size = 4
_$S2$62577 = -4						; size = 4
___that$ = 8						; size = 4
??4ShaderEnvData@Ogre@@QAEAAU01@ABU01@@Z PROC		; Ogre::ShaderEnvData::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	esi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	DWORD PTR _$S2$62577[ebp], 0
	jmp	SHORT $LN9@operator@9
$LN8@operator@9:
	mov	ecx, DWORD PTR _$S2$62577[ebp]
	add	ecx, 1
	mov	DWORD PTR _$S2$62577[ebp], ecx
$LN9@operator@9:
	cmp	DWORD PTR _$S2$62577[ebp], 4
	jae	SHORT $LN7@operator@9
	mov	edx, DWORD PTR _$S2$62577[ebp]
	shl	edx, 5
	mov	eax, DWORD PTR ___that$[ebp]
	lea	ecx, DWORD PTR [eax+edx+8]
	push	ecx
	mov	edx, DWORD PTR _$S2$62577[ebp]
	shl	edx, 5
	mov	eax, DWORD PTR _this$[ebp]
	lea	ecx, DWORD PTR [eax+edx+8]
	call	??4SED_LightData@Ogre@@QAEAAU01@ABU01@@Z
	jmp	SHORT $LN8@operator@9
$LN7@operator@9:
	mov	ecx, DWORD PTR ___that$[ebp]
	add	ecx, 136				; 00000088H
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 136				; 00000088H
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+12], ecx
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 152				; 00000098H
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 152				; 00000098H
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR [edx+12]
	mov	DWORD PTR [eax+12], edx
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 168				; 000000a8H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 168				; 000000a8H
	call	??4Vector4@Ogre@@QAEABV01@ABV01@@Z	; Ogre::Vector4::operator=
	mov	ecx, DWORD PTR ___that$[ebp]
	add	ecx, 184				; 000000b8H
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 184				; 000000b8H
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+12], ecx
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 200				; 000000c8H
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 200				; 000000c8H
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR [edx+12]
	mov	DWORD PTR [eax+12], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+216]
	mov	DWORD PTR [eax+216], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+220]
	mov	DWORD PTR [eax+220], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+224]
	mov	DWORD PTR [eax+224], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+228]
	mov	DWORD PTR [eax+228], edx
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 232				; 000000e8H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 232				; 000000e8H
	call	??4Vector3@Ogre@@QAEABV01@ABV01@@Z	; Ogre::Vector3::operator=
	mov	ecx, DWORD PTR ___that$[ebp]
	add	ecx, 244				; 000000f4H
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 244				; 000000f4H
	call	??4Matrix4@Ogre@@QAEABV01@ABV01@@Z	; Ogre::Matrix4::operator=
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 308				; 00000134H
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 308				; 00000134H
	call	??4Matrix4@Ogre@@QAEABV01@ABV01@@Z	; Ogre::Matrix4::operator=
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 372				; 00000174H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 372				; 00000174H
	call	??4Matrix4@Ogre@@QAEABV01@ABV01@@Z	; Ogre::Matrix4::operator=
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	fld	DWORD PTR [edx+436]
	fstp	DWORD PTR [ecx+436]
	mov	DWORD PTR _$S3$62581[ebp], 0
	jmp	SHORT $LN6@operator@9
$LN5@operator@9:
	mov	eax, DWORD PTR _$S3$62581[ebp]
	add	eax, 1
	mov	DWORD PTR _$S3$62581[ebp], eax
$LN6@operator@9:
	cmp	DWORD PTR _$S3$62581[ebp], 8
	jae	SHORT $LN4@operator@9
	mov	ecx, DWORD PTR _$S3$62581[ebp]
	shl	ecx, 6
	mov	edx, DWORD PTR ___that$[ebp]
	lea	eax, DWORD PTR [edx+ecx+440]
	push	eax
	mov	ecx, DWORD PTR _$S3$62581[ebp]
	shl	ecx, 6
	mov	edx, DWORD PTR _this$[ebp]
	lea	ecx, DWORD PTR [edx+ecx+440]
	call	??4Matrix4@Ogre@@QAEABV01@ABV01@@Z	; Ogre::Matrix4::operator=
	jmp	SHORT $LN5@operator@9
$LN4@operator@9:
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 952				; 000003b8H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 952				; 000003b8H
	call	??4Matrix4@Ogre@@QAEABV01@ABV01@@Z	; Ogre::Matrix4::operator=
	mov	ecx, DWORD PTR ___that$[ebp]
	add	ecx, 1016				; 000003f8H
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1016				; 000003f8H
	call	??4Matrix4@Ogre@@QAEABV01@ABV01@@Z	; Ogre::Matrix4::operator=
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 1080				; 00000438H
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1080				; 00000438H
	call	??4Matrix4@Ogre@@QAEABV01@ABV01@@Z	; Ogre::Matrix4::operator=
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 1144				; 00000478H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1144				; 00000478H
	call	??4Vector3@Ogre@@QAEABV01@ABV01@@Z	; Ogre::Vector3::operator=
	mov	ecx, DWORD PTR ___that$[ebp]
	add	ecx, 1156				; 00000484H
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1156				; 00000484H
	call	??4Vector4@Ogre@@QAEABV01@ABV01@@Z	; Ogre::Vector4::operator=
	mov	DWORD PTR _$S4$62585[ebp], 0
	jmp	SHORT $LN3@operator@9
$LN2@operator@9:
	mov	edx, DWORD PTR _$S4$62585[ebp]
	add	edx, 1
	mov	DWORD PTR _$S4$62585[ebp], edx
$LN3@operator@9:
	cmp	DWORD PTR _$S4$62585[ebp], 16		; 00000010H
	jae	SHORT $LN1@operator@9
	mov	eax, DWORD PTR _$S4$62585[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _$S4$62585[ebp]
	mov	esi, DWORD PTR ___that$[ebp]
	fld	DWORD PTR [esi+edx*4+1172]
	fstp	DWORD PTR [ecx+eax*4+1172]
	jmp	SHORT $LN2@operator@9
$LN1@operator@9:
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 1236				; 000004d4H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1236				; 000004d4H
	call	??4Vector3@Ogre@@QAEABV01@ABV01@@Z	; Ogre::Vector3::operator=
	mov	ecx, DWORD PTR ___that$[ebp]
	add	ecx, 1248				; 000004e0H
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 1248				; 000004e0H
	call	??4Vector3@Ogre@@QAEABV01@ABV01@@Z	; Ogre::Vector3::operator=
	mov	eax, DWORD PTR _this$[ebp]
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
??4ShaderEnvData@Ogre@@QAEAAU01@ABU01@@Z ENDP		; Ogre::ShaderEnvData::operator=
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogrevector4.h
_TEXT	ENDS
;	COMDAT ??4Vector4@Ogre@@QAEABV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_vec$ = 8						; size = 4
??4Vector4@Ogre@@QAEABV01@ABV01@@Z PROC			; Ogre::Vector4::operator=, COMDAT
; _this$ = ecx

; 49   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 50   : 			x = vec.x;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _vec$[ebp]
	fld	DWORD PTR [ecx]
	fstp	DWORD PTR [eax]

; 51   : 			y = vec.y;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _vec$[ebp]
	fld	DWORD PTR [eax+4]
	fstp	DWORD PTR [edx+4]

; 52   : 			z = vec.z;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _vec$[ebp]
	fld	DWORD PTR [edx+8]
	fstp	DWORD PTR [ecx+8]

; 53   : 			w = vec.w;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _vec$[ebp]
	fld	DWORD PTR [ecx+12]
	fstp	DWORD PTR [eax+12]

; 54   : 			return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 55   : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??4Vector4@Ogre@@QAEABV01@ABV01@@Z ENDP			; Ogre::Vector4::operator=
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??4SED_LightData@Ogre@@QAEAAU01@ABU01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4SED_LightData@Ogre@@QAEAAU01@ABU01@@Z PROC		; Ogre::SED_LightData::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], eax
	mov	ecx, DWORD PTR ___that$[ebp]
	add	ecx, 16					; 00000010H
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??4Vector4@Ogre@@QAEABV01@ABV01@@Z	; Ogre::Vector4::operator=
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4SED_LightData@Ogre@@QAEAAU01@ABU01@@Z ENDP		; Ogre::SED_LightData::operator=
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??__G@YGXPAX0IHP6EPAX00@Z@Z
_TEXT	SEGMENT
___t$ = 8						; size = 4
___u$ = 12						; size = 4
___s$ = 16						; size = 4
___n$ = 20						; size = 4
___f$ = 24						; size = 4
??__G@YGXPAX0IHP6EPAX00@Z@Z PROC			; `vector copy constructor iterator', COMDAT
	push	ebp
	mov	ebp, esp
$LN2@vector@17:
	mov	eax, DWORD PTR ___n$[ebp]
	sub	eax, 1
	mov	DWORD PTR ___n$[ebp], eax
	js	SHORT $LN3@vector@17
	mov	ecx, DWORD PTR ___u$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ___t$[ebp]
	call	DWORD PTR ___f$[ebp]
	mov	edx, DWORD PTR ___t$[ebp]
	add	edx, DWORD PTR ___s$[ebp]
	mov	DWORD PTR ___t$[ebp], edx
	mov	eax, DWORD PTR ___u$[ebp]
	add	eax, DWORD PTR ___s$[ebp]
	mov	DWORD PTR ___u$[ebp], eax
	jmp	SHORT $LN2@vector@17
$LN3@vector@17:
	pop	ebp
	ret	20					; 00000014H
??__G@YGXPAX0IHP6EPAX00@Z@Z ENDP			; `vector copy constructor iterator'
_TEXT	ENDS
PUBLIC	?setLayer@ShaderContext@Ogre@@QAEXW4RenderLayer@2@@Z ; Ogre::ShaderContext::setLayer
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogreshadercontext.h
;	COMDAT ?setLayer@ShaderContext@Ogre@@QAEXW4RenderLayer@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_layer$ = 8						; size = 4
?setLayer@ShaderContext@Ogre@@QAEXW4RenderLayer@2@@Z PROC ; Ogre::ShaderContext::setLayer, COMDAT
; _this$ = ecx

; 27   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 28   : 			m_SortIndex = (layer<<16) | (m_SortIndex&0xff00ffff);

	mov	eax, DWORD PTR _layer$[ebp]
	shl	eax, 16					; 00000010H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	and	edx, -16711681				; ff00ffffH
	or	eax, edx
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+24], eax

; 29   : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?setLayer@ShaderContext@Ogre@@QAEXW4RenderLayer@2@@Z ENDP ; Ogre::ShaderContext::setLayer
_TEXT	ENDS
PUBLIC	?setTransparent@ShaderContext@Ogre@@QAEX_N@Z	; Ogre::ShaderContext::setTransparent
; Function compile flags: /Odtp
;	COMDAT ?setTransparent@ShaderContext@Ogre@@QAEX_N@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_b$ = 8							; size = 1
?setTransparent@ShaderContext@Ogre@@QAEX_N@Z PROC	; Ogre::ShaderContext::setTransparent, COMDAT
; _this$ = ecx

; 32   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 33   : 			m_SortIndex = (m_SortIndex&0xffff0000) | (b?1:0);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	and	ecx, -65536				; ffff0000H
	movzx	edx, BYTE PTR _b$[ebp]
	neg	edx
	sbb	edx, edx
	neg	edx
	or	ecx, edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+24], ecx

; 34   : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?setTransparent@ShaderContext@Ogre@@QAEX_N@Z ENDP	; Ogre::ShaderContext::setTransparent
_TEXT	ENDS
PUBLIC	?setSkyBox@ShaderContext@Ogre@@QAEX_N@Z		; Ogre::ShaderContext::setSkyBox
; Function compile flags: /Odtp
;	COMDAT ?setSkyBox@ShaderContext@Ogre@@QAEX_N@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_b$ = 8							; size = 1
?setSkyBox@ShaderContext@Ogre@@QAEX_N@Z PROC		; Ogre::ShaderContext::setSkyBox, COMDAT
; _this$ = ecx

; 37   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 38   : 			m_SortIndex = (m_SortIndex&0x7fffffff) | (b ? 0 : 0x80000000);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	and	ecx, 2147483647				; 7fffffffH
	movzx	edx, BYTE PTR _b$[ebp]
	neg	edx
	sbb	edx, edx
	and	edx, -2147483648			; 80000000H
	add	edx, -2147483648			; 80000000H
	or	ecx, edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+24], ecx

; 39   : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?setSkyBox@ShaderContext@Ogre@@QAEX_N@Z ENDP		; Ogre::ShaderContext::setSkyBox
_TEXT	ENDS
PUBLIC	?isTransparent@ShaderContext@Ogre@@QBE_NXZ	; Ogre::ShaderContext::isTransparent
; Function compile flags: /Odtp
;	COMDAT ?isTransparent@ShaderContext@Ogre@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?isTransparent@ShaderContext@Ogre@@QBE_NXZ PROC		; Ogre::ShaderContext::isTransparent, COMDAT
; _this$ = ecx

; 45   : 		bool isTransparent() const{ return m_SortIndex & 1; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+24]
	and	eax, 1
	mov	esp, ebp
	pop	ebp
	ret	0
?isTransparent@ShaderContext@Ogre@@QBE_NXZ ENDP		; Ogre::ShaderContext::isTransparent
_TEXT	ENDS
PUBLIC	??4ShaderContext@Ogre@@QAEAAV01@ABV01@@Z	; Ogre::ShaderContext::operator=
; Function compile flags: /Odtp
;	COMDAT ??4ShaderContext@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4ShaderContext@Ogre@@QAEAAV01@ABV01@@Z PROC		; Ogre::ShaderContext::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	esi, DWORD PTR ___that$[ebp]
	mov	ecx, 26					; 0000001aH
	mov	edi, DWORD PTR _this$[ebp]
	rep movsd
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
??4ShaderContext@Ogre@@QAEAAV01@ABV01@@Z ENDP		; Ogre::ShaderContext::operator=
_TEXT	ENDS
PUBLIC	?getNumContext@ShaderContextPool@Ogre@@QAEIXZ	; Ogre::ShaderContextPool::getNumContext
; Function compile flags: /Odtp
;	COMDAT ?getNumContext@ShaderContextPool@Ogre@@QAEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getNumContext@ShaderContextPool@Ogre@@QAEIXZ PROC	; Ogre::ShaderContextPool::getNumContext, COMDAT
; _this$ = ecx

; 128  : 		{ 

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 129  : 			return m_nUsedContext; 

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+2076]

; 130  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?getNumContext@ShaderContextPool@Ogre@@QAEIXZ ENDP	; Ogre::ShaderContextPool::getNumContext
_TEXT	ENDS
PUBLIC	??A?$vector@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@QAEAAPAVShaderContext@Ogre@@I@Z ; std::vector<Ogre::ShaderContext *,std::allocator<Ogre::ShaderContext *> >::operator[]
PUBLIC	?getContext@ShaderContextPool@Ogre@@QAEPAVShaderContext@2@I@Z ; Ogre::ShaderContextPool::getContext
; Function compile flags: /Odtp
;	COMDAT ?getContext@ShaderContextPool@Ogre@@QAEPAVShaderContext@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_i$ = 8							; size = 4
?getContext@ShaderContextPool@Ogre@@QAEPAVShaderContext@2@I@Z PROC ; Ogre::ShaderContextPool::getContext, COMDAT
; _this$ = ecx

; 132  : 		ShaderContext *getContext(size_t i){ return m_Contexts[i]; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _i$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2052				; 00000804H
	call	??A?$vector@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@QAEAAPAVShaderContext@Ogre@@I@Z ; std::vector<Ogre::ShaderContext *,std::allocator<Ogre::ShaderContext *> >::operator[]
	mov	eax, DWORD PTR [eax]
	mov	esp, ebp
	pop	ebp
	ret	4
?getContext@ShaderContextPool@Ogre@@QAEPAVShaderContext@2@I@Z ENDP ; Ogre::ShaderContextPool::getContext
_TEXT	ENDS
PUBLIC	?SetContextQueDesc@ShaderContextPool@Ogre@@QAEXUContextQueDesc@2@@Z ; Ogre::ShaderContextPool::SetContextQueDesc
; Function compile flags: /Odtp
;	COMDAT ?SetContextQueDesc@ShaderContextPool@Ogre@@QAEXUContextQueDesc@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_contextquedesc$ = 8					; size = 156
?SetContextQueDesc@ShaderContextPool@Ogre@@QAEXUContextQueDesc@2@@Z PROC ; Ogre::ShaderContextPool::SetContextQueDesc, COMDAT
; _this$ = ecx

; 158  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 159  : 			m_ContextQueDesc = contextquedesc;

	mov	edi, DWORD PTR _this$[ebp]
	add	edi, 2104				; 00000838H
	mov	ecx, 39					; 00000027H
	lea	esi, DWORD PTR _contextquedesc$[ebp]
	rep movsd

; 160  : 		}

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	156					; 0000009cH
?SetContextQueDesc@ShaderContextPool@Ogre@@QAEXUContextQueDesc@2@@Z ENDP ; Ogre::ShaderContextPool::SetContextQueDesc
_TEXT	ENDS
PUBLIC	??1?$vector@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::ShaderContextPool::TexParam,std::allocator<Ogre::ShaderContextPool::TexParam> >::~vector<Ogre::ShaderContextPool::TexParam,std::allocator<Ogre::ShaderContextPool::TexParam> >
PUBLIC	??1?$vector@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::ShaderContextPool::ValueParam,std::allocator<Ogre::ShaderContextPool::ValueParam> >::~vector<Ogre::ShaderContextPool::ValueParam,std::allocator<Ogre::ShaderContextPool::ValueParam> >
PUBLIC	??1?$vector@EV?$allocator@E@std@@@std@@QAE@XZ	; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >
PUBLIC	??1?$vector@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::ContextQueDesc,std::allocator<Ogre::ContextQueDesc> >::~vector<Ogre::ContextQueDesc,std::allocator<Ogre::ContextQueDesc> >
PUBLIC	??1?$vector@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::ShaderContext *,std::allocator<Ogre::ShaderContext *> >::~vector<Ogre::ShaderContext *,std::allocator<Ogre::ShaderContext *> >
PUBLIC	??0?$vector@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@QAE@ABV01@@Z ; std::vector<Ogre::ShaderContextPool::TexParam,std::allocator<Ogre::ShaderContextPool::TexParam> >::vector<Ogre::ShaderContextPool::TexParam,std::allocator<Ogre::ShaderContextPool::TexParam> >
PUBLIC	??0?$vector@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@QAE@ABV01@@Z ; std::vector<Ogre::ShaderContextPool::ValueParam,std::allocator<Ogre::ShaderContextPool::ValueParam> >::vector<Ogre::ShaderContextPool::ValueParam,std::allocator<Ogre::ShaderContextPool::ValueParam> >
PUBLIC	??0?$vector@EV?$allocator@E@std@@@std@@QAE@ABV01@@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::vector<unsigned char,std::allocator<unsigned char> >
PUBLIC	??0?$vector@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@QAE@ABV01@@Z ; std::vector<Ogre::ContextQueDesc,std::allocator<Ogre::ContextQueDesc> >::vector<Ogre::ContextQueDesc,std::allocator<Ogre::ContextQueDesc> >
PUBLIC	??0?$vector@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@QAE@ABV01@@Z ; std::vector<Ogre::ShaderContext *,std::allocator<Ogre::ShaderContext *> >::vector<Ogre::ShaderContext *,std::allocator<Ogre::ShaderContext *> >
PUBLIC	??0ShaderContextPool@Ogre@@QAE@ABV01@@Z		; Ogre::ShaderContextPool::ShaderContextPool
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0ShaderContextPool@Ogre@@QAE@ABV01@@Z DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$??0ShaderContextPool@Ogre@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__unwindtable$??0ShaderContextPool@Ogre@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0ShaderContextPool@Ogre@@QAE@ABV01@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0ShaderContextPool@Ogre@@QAE@ABV01@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0ShaderContextPool@Ogre@@QAE@ABV01@@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$??0ShaderContextPool@Ogre@@QAE@ABV01@@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$??0ShaderContextPool@Ogre@@QAE@ABV01@@Z$4
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0ShaderContextPool@Ogre@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0ShaderContextPool@Ogre@@QAE@ABV01@@Z PROC		; Ogre::ShaderContextPool::ShaderContextPool, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0ShaderContextPool@Ogre@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	fld	DWORD PTR [ecx]
	fstp	DWORD PTR [eax]
	mov	esi, DWORD PTR ___that$[ebp]
	add	esi, 4
	mov	edi, DWORD PTR _this$[ebp]
	add	edi, 4
	mov	ecx, 512				; 00000200H
	rep movsd
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 2052				; 00000804H
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2052				; 00000804H
	call	??0?$vector@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@QAE@ABV01@@Z ; std::vector<Ogre::ShaderContext *,std::allocator<Ogre::ShaderContext *> >::vector<Ogre::ShaderContext *,std::allocator<Ogre::ShaderContext *> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+2076]
	mov	DWORD PTR [eax+2076], edx
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 2080				; 00000820H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2080				; 00000820H
	call	??0?$vector@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@QAE@ABV01@@Z ; std::vector<Ogre::ContextQueDesc,std::allocator<Ogre::ContextQueDesc> >::vector<Ogre::ContextQueDesc,std::allocator<Ogre::ContextQueDesc> >
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	esi, DWORD PTR ___that$[ebp]
	add	esi, 2104				; 00000838H
	mov	edi, DWORD PTR _this$[ebp]
	add	edi, 2104				; 00000838H
	mov	ecx, 39					; 00000027H
	rep movsd
	mov	ecx, DWORD PTR ___that$[ebp]
	add	ecx, 2260				; 000008d4H
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2260				; 000008d4H
	call	??0?$vector@EV?$allocator@E@std@@@std@@QAE@ABV01@@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::vector<unsigned char,std::allocator<unsigned char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+2284]
	mov	DWORD PTR [edx+2284], ecx
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 2288				; 000008f0H
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2288				; 000008f0H
	call	??0?$vector@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@QAE@ABV01@@Z ; std::vector<Ogre::ShaderContextPool::ValueParam,std::allocator<Ogre::ShaderContextPool::ValueParam> >::vector<Ogre::ShaderContextPool::ValueParam,std::allocator<Ogre::ShaderContextPool::ValueParam> >
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+2312]
	mov	DWORD PTR [eax+2312], edx
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 2316				; 0000090cH
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2316				; 0000090cH
	call	??0?$vector@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@QAE@ABV01@@Z ; std::vector<Ogre::ShaderContextPool::TexParam,std::allocator<Ogre::ShaderContextPool::TexParam> >::vector<Ogre::ShaderContextPool::TexParam,std::allocator<Ogre::ShaderContextPool::TexParam> >
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+2340]
	mov	DWORD PTR [ecx+2340], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0ShaderContextPool@Ogre@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2052				; 00000804H
	jmp	??1?$vector@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::ShaderContext *,std::allocator<Ogre::ShaderContext *> >::~vector<Ogre::ShaderContext *,std::allocator<Ogre::ShaderContext *> >
__unwindfunclet$??0ShaderContextPool@Ogre@@QAE@ABV01@@Z$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2080				; 00000820H
	jmp	??1?$vector@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::ContextQueDesc,std::allocator<Ogre::ContextQueDesc> >::~vector<Ogre::ContextQueDesc,std::allocator<Ogre::ContextQueDesc> >
__unwindfunclet$??0ShaderContextPool@Ogre@@QAE@ABV01@@Z$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2260				; 000008d4H
	jmp	??1?$vector@EV?$allocator@E@std@@@std@@QAE@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >
__unwindfunclet$??0ShaderContextPool@Ogre@@QAE@ABV01@@Z$3:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2288				; 000008f0H
	jmp	??1?$vector@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::ShaderContextPool::ValueParam,std::allocator<Ogre::ShaderContextPool::ValueParam> >::~vector<Ogre::ShaderContextPool::ValueParam,std::allocator<Ogre::ShaderContextPool::ValueParam> >
__unwindfunclet$??0ShaderContextPool@Ogre@@QAE@ABV01@@Z$4:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2316				; 0000090cH
	jmp	??1?$vector@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::ShaderContextPool::TexParam,std::allocator<Ogre::ShaderContextPool::TexParam> >::~vector<Ogre::ShaderContextPool::TexParam,std::allocator<Ogre::ShaderContextPool::TexParam> >
__ehhandler$??0ShaderContextPool@Ogre@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0ShaderContextPool@Ogre@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0ShaderContextPool@Ogre@@QAE@ABV01@@Z ENDP		; Ogre::ShaderContextPool::ShaderContextPool
PUBLIC	??4?$vector@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<Ogre::ShaderContextPool::TexParam,std::allocator<Ogre::ShaderContextPool::TexParam> >::operator=
PUBLIC	??4?$vector@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<Ogre::ShaderContextPool::ValueParam,std::allocator<Ogre::ShaderContextPool::ValueParam> >::operator=
PUBLIC	??4?$vector@EV?$allocator@E@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::operator=
PUBLIC	??4?$vector@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<Ogre::ContextQueDesc,std::allocator<Ogre::ContextQueDesc> >::operator=
PUBLIC	??4?$vector@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<Ogre::ShaderContext *,std::allocator<Ogre::ShaderContext *> >::operator=
PUBLIC	??4ShaderContextPool@Ogre@@QAEAAV01@ABV01@@Z	; Ogre::ShaderContextPool::operator=
; Function compile flags: /Odtp
;	COMDAT ??4ShaderContextPool@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_$S5$64519 = -4						; size = 4
___that$ = 8						; size = 4
??4ShaderContextPool@Ogre@@QAEAAV01@ABV01@@Z PROC	; Ogre::ShaderContextPool::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	fld	DWORD PTR [ecx]
	fstp	DWORD PTR [eax]
	mov	DWORD PTR _$S5$64519[ebp], 0
	jmp	SHORT $LN3@operator@10
$LN2@operator@10:
	mov	edx, DWORD PTR _$S5$64519[ebp]
	add	edx, 1
	mov	DWORD PTR _$S5$64519[ebp], edx
$LN3@operator@10:
	cmp	DWORD PTR _$S5$64519[ebp], 2048		; 00000800H
	jae	SHORT $LN1@operator@10
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR _$S5$64519[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	add	ecx, DWORD PTR _$S5$64519[ebp]
	mov	dl, BYTE PTR [ecx+4]
	mov	BYTE PTR [eax+4], dl
	jmp	SHORT $LN2@operator@10
$LN1@operator@10:
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 2052				; 00000804H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2052				; 00000804H
	call	??4?$vector@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<Ogre::ShaderContext *,std::allocator<Ogre::ShaderContext *> >::operator=
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+2076]
	mov	DWORD PTR [ecx+2076], eax
	mov	ecx, DWORD PTR ___that$[ebp]
	add	ecx, 2080				; 00000820H
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2080				; 00000820H
	call	??4?$vector@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<Ogre::ContextQueDesc,std::allocator<Ogre::ContextQueDesc> >::operator=
	mov	esi, DWORD PTR ___that$[ebp]
	add	esi, 2104				; 00000838H
	mov	edi, DWORD PTR _this$[ebp]
	add	edi, 2104				; 00000838H
	mov	ecx, 39					; 00000027H
	rep movsd
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 2260				; 000008d4H
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2260				; 000008d4H
	call	??4?$vector@EV?$allocator@E@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::operator=
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+2284]
	mov	DWORD PTR [eax+2284], edx
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 2288				; 000008f0H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2288				; 000008f0H
	call	??4?$vector@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<Ogre::ShaderContextPool::ValueParam,std::allocator<Ogre::ShaderContextPool::ValueParam> >::operator=
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+2312]
	mov	DWORD PTR [ecx+2312], eax
	mov	ecx, DWORD PTR ___that$[ebp]
	add	ecx, 2316				; 0000090cH
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 2316				; 0000090cH
	call	??4?$vector@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<Ogre::ShaderContextPool::TexParam,std::allocator<Ogre::ShaderContextPool::TexParam> >::operator=
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+2340]
	mov	DWORD PTR [edx+2340], ecx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
??4ShaderContextPool@Ogre@@QAEAAV01@ABV01@@Z ENDP	; Ogre::ShaderContextPool::operator=
_TEXT	ENDS
PUBLIC	??_FShaderContextPool@Ogre@@QAEXXZ		; Ogre::ShaderContextPool::`default constructor closure'
EXTRN	??0ShaderContextPool@Ogre@@QAE@I@Z:PROC		; Ogre::ShaderContextPool::ShaderContextPool
; Function compile flags: /Odtp
;	COMDAT ??_FShaderContextPool@Ogre@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??_FShaderContextPool@Ogre@@QAEXXZ PROC			; Ogre::ShaderContextPool::`default constructor closure', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0ShaderContextPool@Ogre@@QAE@I@Z	; Ogre::ShaderContextPool::ShaderContextPool
	mov	esp, ebp
	pop	ebp
	ret	0
??_FShaderContextPool@Ogre@@QAEXXZ ENDP			; Ogre::ShaderContextPool::`default constructor closure'
_TEXT	ENDS
PUBLIC	??0Plane@Ogre@@QAE@XZ				; Ogre::Plane::Plane
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogreplane.h
;	COMDAT ??0Plane@Ogre@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0Plane@Ogre@@QAE@XZ PROC				; Ogre::Plane::Plane, COMDAT
; _this$ = ecx

; 71   : 		Plane()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0Vector3@Ogre@@QAE@XZ			; Ogre::Vector3::Vector3

; 72   : 		{
; 73   : 			//assert(0);
; 74   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0Plane@Ogre@@QAE@XZ ENDP				; Ogre::Plane::Plane
_TEXT	ENDS
PUBLIC	?setFromNormalAndPoint@Plane@Ogre@@QAEXABVVector3@2@0@Z ; Ogre::Plane::setFromNormalAndPoint
PUBLIC	??0Plane@Ogre@@QAE@ABVVector3@1@0@Z		; Ogre::Plane::Plane
; Function compile flags: /Odtp
;	COMDAT ??0Plane@Ogre@@QAE@ABVVector3@1@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_normal$ = 8						; size = 4
_point$ = 12						; size = 4
??0Plane@Ogre@@QAE@ABVVector3@1@0@Z PROC		; Ogre::Plane::Plane, COMDAT
; _this$ = ecx

; 76   : 		Plane( const Vector3 &normal, const Vector3 &point )

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0Vector3@Ogre@@QAE@XZ			; Ogre::Vector3::Vector3

; 77   : 		{
; 78   : 			setFromNormalAndPoint(normal,point);

	mov	eax, DWORD PTR _point$[ebp]
	push	eax
	mov	ecx, DWORD PTR _normal$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?setFromNormalAndPoint@Plane@Ogre@@QAEXABVVector3@2@0@Z ; Ogre::Plane::setFromNormalAndPoint

; 79   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0Plane@Ogre@@QAE@ABVVector3@1@0@Z ENDP		; Ogre::Plane::Plane
_TEXT	ENDS
PUBLIC	??0Plane@Ogre@@QAE@ABVVector3@1@M@Z		; Ogre::Plane::Plane
; Function compile flags: /Odtp
;	COMDAT ??0Plane@Ogre@@QAE@ABVVector3@1@M@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_normal$ = 8						; size = 4
_offset$ = 12						; size = 4
??0Plane@Ogre@@QAE@ABVVector3@1@M@Z PROC		; Ogre::Plane::Plane, COMDAT
; _this$ = ecx

; 82   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _normal$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0Vector3@Ogre@@QAE@ABV01@@Z		; Ogre::Vector3::Vector3
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _offset$[ebp]
	fstp	DWORD PTR [ecx+12]

; 83   : 			assert( isValid() );
; 84   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0Plane@Ogre@@QAE@ABVVector3@1@M@Z ENDP		; Ogre::Plane::Plane
_TEXT	ENDS
PUBLIC	?isValid@Plane@Ogre@@QBE_NXZ			; Ogre::Plane::isValid
; Function compile flags: /Odtp
;	COMDAT ?isValid@Plane@Ogre@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?isValid@Plane@Ogre@@QBE_NXZ PROC			; Ogre::Plane::isValid, COMDAT
; _this$ = ecx

; 92   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 93   : 			assert( IsFloatValid(m_offset) );
; 94   : 			return true;

	mov	al, 1

; 95   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?isValid@Plane@Ogre@@QBE_NXZ ENDP			; Ogre::Plane::isValid
_TEXT	ENDS
PUBLIC	?setFromPlaneParam@Plane@Ogre@@QAEXQBM@Z	; Ogre::Plane::setFromPlaneParam
; Function compile flags: /Odtp
;	COMDAT ?setFromPlaneParam@Plane@Ogre@@QAEXQBM@Z
_TEXT	SEGMENT
tv142 = -12						; size = 4
_this$ = -8						; size = 4
_len$ = -4						; size = 4
_plane$ = 8						; size = 4
?setFromPlaneParam@Plane@Ogre@@QAEXQBM@Z PROC		; Ogre::Plane::setFromPlaneParam, COMDAT
; _this$ = ecx

; 100  : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 101  : 			float len = (float)Sqrt( plane[0]*plane[0] + plane[1]*plane[1] + plane[2]*plane[2] );

	mov	eax, DWORD PTR _plane$[ebp]
	fld	DWORD PTR [eax]
	mov	ecx, DWORD PTR _plane$[ebp]
	fmul	DWORD PTR [ecx]
	mov	edx, DWORD PTR _plane$[ebp]
	fld	DWORD PTR [edx+4]
	mov	eax, DWORD PTR _plane$[ebp]
	fmul	DWORD PTR [eax+4]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _plane$[ebp]
	fld	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _plane$[ebp]
	fmul	DWORD PTR [edx+8]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR tv142[ebp]
	fld	DWORD PTR tv142[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	call	?Sqrt@Ogre@@YAMM@Z			; Ogre::Sqrt
	add	esp, 4
	fstp	DWORD PTR _len$[ebp]

; 102  : 			m_normal.x = plane[0] / len;

	mov	eax, DWORD PTR _plane$[ebp]
	fld	DWORD PTR [eax]
	fdiv	DWORD PTR _len$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx]

; 103  : 			m_normal.y = plane[1] / len;

	mov	edx, DWORD PTR _plane$[ebp]
	fld	DWORD PTR [edx+4]
	fdiv	DWORD PTR _len$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [eax+4]

; 104  : 			m_normal.z = plane[2] / len;

	mov	ecx, DWORD PTR _plane$[ebp]
	fld	DWORD PTR [ecx+8]
	fdiv	DWORD PTR _len$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [edx+8]

; 105  : 			m_offset   = plane[3] / len;

	mov	eax, DWORD PTR _plane$[ebp]
	fld	DWORD PTR [eax+12]
	fdiv	DWORD PTR _len$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx+12]

; 106  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?setFromPlaneParam@Plane@Ogre@@QAEXQBM@Z ENDP		; Ogre::Plane::setFromPlaneParam
_TEXT	ENDS
PUBLIC	?DotProduct@Ogre@@YAMABVVector3@1@0@Z		; Ogre::DotProduct
; Function compile flags: /Odtp
;	COMDAT ?setFromNormalAndPoint@Plane@Ogre@@QAEXABVVector3@2@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_normal$ = 8						; size = 4
_point$ = 12						; size = 4
?setFromNormalAndPoint@Plane@Ogre@@QAEXABVVector3@2@0@Z PROC ; Ogre::Plane::setFromNormalAndPoint, COMDAT
; _this$ = ecx

; 109  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 110  : 			m_normal = normal;

	mov	eax, DWORD PTR _normal$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4Vector3@Ogre@@QAEABV01@ABV01@@Z	; Ogre::Vector3::operator=

; 111  : 			m_offset = - DotProduct( m_normal, point );

	mov	ecx, DWORD PTR _point$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	?DotProduct@Ogre@@YAMABVVector3@1@0@Z	; Ogre::DotProduct
	add	esp, 8
	fchs
	mov	eax, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [eax+12]

; 112  : 
; 113  : 			assert(isValid());
; 114  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?setFromNormalAndPoint@Plane@Ogre@@QAEXABVVector3@2@0@Z ENDP ; Ogre::Plane::setFromNormalAndPoint
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogrevector3.h
_TEXT	ENDS
;	COMDAT ?DotProduct@Ogre@@YAMABVVector3@1@0@Z
_TEXT	SEGMENT
tv86 = -4						; size = 4
_v1$ = 8						; size = 4
_v2$ = 12						; size = 4
?DotProduct@Ogre@@YAMABVVector3@1@0@Z PROC		; Ogre::DotProduct, COMDAT

; 263  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 264  : 		return v1.x*v2.x + v1.y*v2.y + v1.z*v2.z;

	mov	eax, DWORD PTR _v1$[ebp]
	fld	DWORD PTR [eax]
	mov	ecx, DWORD PTR _v2$[ebp]
	fmul	DWORD PTR [ecx]
	mov	edx, DWORD PTR _v1$[ebp]
	fld	DWORD PTR [edx+4]
	mov	eax, DWORD PTR _v2$[ebp]
	fmul	DWORD PTR [eax+4]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _v1$[ebp]
	fld	DWORD PTR [ecx+8]
	mov	edx, DWORD PTR _v2$[ebp]
	fmul	DWORD PTR [edx+8]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR tv86[ebp]
	fld	DWORD PTR tv86[ebp]

; 265  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?DotProduct@Ogre@@YAMABVVector3@1@0@Z ENDP		; Ogre::DotProduct
_TEXT	ENDS
PUBLIC	?distanceToPoint@Plane@Ogre@@QBEMABVVector3@2@@Z ; Ogre::Plane::distanceToPoint
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogreplane.h
;	COMDAT ?distanceToPoint@Plane@Ogre@@QBEMABVVector3@2@@Z
_TEXT	SEGMENT
tv78 = -8						; size = 4
_this$ = -4						; size = 4
_point$ = 8						; size = 4
?distanceToPoint@Plane@Ogre@@QBEMABVVector3@2@@Z PROC	; Ogre::Plane::distanceToPoint, COMDAT
; _this$ = ecx

; 122  : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 123  : 			assert(isValid());
; 124  : 			return DotProduct(m_normal, point) + m_offset;

	mov	eax, DWORD PTR _point$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	?DotProduct@Ogre@@YAMABVVector3@1@0@Z	; Ogre::DotProduct
	add	esp, 8
	mov	edx, DWORD PTR _this$[ebp]
	fadd	DWORD PTR [edx+12]
	fstp	DWORD PTR tv78[ebp]
	fld	DWORD PTR tv78[ebp]

; 125  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?distanceToPoint@Plane@Ogre@@QBEMABVVector3@2@@Z ENDP	; Ogre::Plane::distanceToPoint
_TEXT	ENDS
PUBLIC	?pointSideGE@Plane@Ogre@@QBE?AW4ESIDE_T@12@ABVVector3@2@@Z ; Ogre::Plane::pointSideGE
; Function compile flags: /Odtp
;	COMDAT ?pointSideGE@Plane@Ogre@@QBE?AW4ESIDE_T@12@ABVVector3@2@@Z
_TEXT	SEGMENT
tv69 = -12						; size = 4
_this$ = -8						; size = 4
_d$ = -4						; size = 4
_point$ = 8						; size = 4
?pointSideGE@Plane@Ogre@@QBE?AW4ESIDE_T@12@ABVVector3@2@@Z PROC ; Ogre::Plane::pointSideGE, COMDAT
; _this$ = ecx

; 128  : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 129  : 			assert(isValid());
; 130  : 			const float d = distanceToPoint(point);

	mov	eax, DWORD PTR _point$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?distanceToPoint@Plane@Ogre@@QBEMABVVector3@2@@Z ; Ogre::Plane::distanceToPoint
	fstp	DWORD PTR _d$[ebp]

; 131  : 			return ( d >= 0.f ) ? FRONT : BACK;

	fld	DWORD PTR _d$[ebp]
	fcomp	QWORD PTR __real@0000000000000000
	fnstsw	ax
	test	ah, 1
	jne	SHORT $LN3@pointSideG
	mov	DWORD PTR tv69[ebp], 0
	jmp	SHORT $LN4@pointSideG
$LN3@pointSideG:
	mov	DWORD PTR tv69[ebp], 1
$LN4@pointSideG:
	mov	eax, DWORD PTR tv69[ebp]

; 132  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?pointSideGE@Plane@Ogre@@QBE?AW4ESIDE_T@12@ABVVector3@2@@Z ENDP ; Ogre::Plane::pointSideGE
_TEXT	ENDS
PUBLIC	?pointSideOrOn@Plane@Ogre@@QBE?AW4ESIDE_T@12@ABVVector3@2@M@Z ; Ogre::Plane::pointSideOrOn
; Function compile flags: /Odtp
;	COMDAT ?pointSideOrOn@Plane@Ogre@@QBE?AW4ESIDE_T@12@ABVVector3@2@M@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_d$ = -4						; size = 4
_point$ = 8						; size = 4
_rOnTolerance$ = 12					; size = 4
?pointSideOrOn@Plane@Ogre@@QBE?AW4ESIDE_T@12@ABVVector3@2@M@Z PROC ; Ogre::Plane::pointSideOrOn, COMDAT
; _this$ = ecx

; 135  : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 136  : 			assert(isValid());
; 137  : 			const float d = distanceToPoint(point);

	mov	eax, DWORD PTR _point$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?distanceToPoint@Plane@Ogre@@QBEMABVVector3@2@@Z ; Ogre::Plane::distanceToPoint
	fstp	DWORD PTR _d$[ebp]

; 138  : 			if ( d > rOnTolerance )

	fld	DWORD PTR _d$[ebp]
	fld	DWORD PTR _rOnTolerance$[ebp]
	fcompp
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN2@pointSideO

; 139  : 				return FRONT;

	xor	eax, eax
	jmp	SHORT $LN3@pointSideO
$LN2@pointSideO:

; 140  : 			if ( d <-rOnTolerance )

	fld	DWORD PTR _rOnTolerance$[ebp]
	fchs
	fld	DWORD PTR _d$[ebp]
	fcompp
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN1@pointSideO

; 141  : 				return BACK;

	mov	eax, 1
	jmp	SHORT $LN3@pointSideO
$LN1@pointSideO:

; 142  : 			return INTERSECT;

	mov	eax, 2
$LN3@pointSideO:

; 143  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?pointSideOrOn@Plane@Ogre@@QBE?AW4ESIDE_T@12@ABVVector3@2@M@Z ENDP ; Ogre::Plane::pointSideOrOn
_TEXT	ENDS
PUBLIC	?translate@Plane@Ogre@@QAEXABVVector3@2@@Z	; Ogre::Plane::translate
; Function compile flags: /Odtp
;	COMDAT ?translate@Plane@Ogre@@QAEXABVVector3@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_v$ = 8							; size = 4
?translate@Plane@Ogre@@QAEXABVVector3@2@@Z PROC		; Ogre::Plane::translate, COMDAT
; _this$ = ecx

; 160  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 161  : 			assert(isValid());
; 162  : 			// slide the offset
; 163  : 			m_offset -= DotProduct( v, m_normal );

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _v$[ebp]
	push	ecx
	call	?DotProduct@Ogre@@YAMABVVector3@1@0@Z	; Ogre::DotProduct
	add	esp, 8
	mov	edx, DWORD PTR _this$[ebp]
	fsubr	DWORD PTR [edx+12]
	mov	eax, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [eax+12]

; 164  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?translate@Plane@Ogre@@QAEXABVVector3@2@@Z ENDP		; Ogre::Plane::translate
_TEXT	ENDS
PUBLIC	?moveForwards@Plane@Ogre@@QAEXM@Z		; Ogre::Plane::moveForwards
; Function compile flags: /Odtp
;	COMDAT ?moveForwards@Plane@Ogre@@QAEXM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_rDelta$ = 8						; size = 4
?moveForwards@Plane@Ogre@@QAEXM@Z PROC			; Ogre::Plane::moveForwards, COMDAT
; _this$ = ecx

; 170  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 171  : 			assert(isValid());
; 172  : 			m_offset -= rDelta;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+12]
	fsub	DWORD PTR _rDelta$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx+12]

; 173  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?moveForwards@Plane@Ogre@@QAEXM@Z ENDP			; Ogre::Plane::moveForwards
_TEXT	ENDS
PUBLIC	__real@bff0000000000000
PUBLIC	__real@bf800000
PUBLIC	?flipNormal@Plane@Ogre@@QAEXXZ			; Ogre::Plane::flipNormal
;	COMDAT __real@bff0000000000000
CONST	SEGMENT
__real@bff0000000000000 DQ 0bff0000000000000r	; -1
CONST	ENDS
;	COMDAT __real@bf800000
CONST	SEGMENT
__real@bf800000 DD 0bf800000r			; -1
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ?flipNormal@Plane@Ogre@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?flipNormal@Plane@Ogre@@QAEXXZ PROC			; Ogre::Plane::flipNormal, COMDAT
; _this$ = ecx

; 176  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 177  : 			assert(isValid());
; 178  : 			m_normal *= -1.0f;

	push	ecx
	fld	DWORD PTR __real@bf800000
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	??XVector3@Ogre@@QAEXM@Z		; Ogre::Vector3::operator*=

; 179  : 			m_offset *= -1;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+12]
	fmul	QWORD PTR __real@bff0000000000000
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx+12]

; 180  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?flipNormal@Plane@Ogre@@QAEXXZ ENDP			; Ogre::Plane::flipNormal
_TEXT	ENDS
PUBLIC	?solveForX@Plane@Ogre@@QBEMMM@Z			; Ogre::Plane::solveForX
; Function compile flags: /Odtp
;	COMDAT ?solveForX@Plane@Ogre@@QBEMMM@Z
_TEXT	SEGMENT
tv92 = -8						; size = 4
_this$ = -4						; size = 4
_y$ = 8							; size = 4
_z$ = 12						; size = 4
?solveForX@Plane@Ogre@@QBEMMM@Z PROC			; Ogre::Plane::solveForX, COMDAT
; _this$ = ecx

; 183  : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 184  : 			if( m_normal.x ) return -(m_normal.y*y + m_normal.z*z + m_offset)/m_normal.x;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax]
	fcomp	QWORD PTR __real@0000000000000000
	fnstsw	ax
	test	ah, 68					; 00000044H
	jnp	SHORT $LN2@solveForX
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+4]
	fmul	DWORD PTR _y$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+8]
	fmul	DWORD PTR _z$[ebp]
	faddp	ST(1), ST(0)
	mov	eax, DWORD PTR _this$[ebp]
	fadd	DWORD PTR [eax+12]
	fchs
	mov	ecx, DWORD PTR _this$[ebp]
	fdiv	DWORD PTR [ecx]
	fstp	DWORD PTR tv92[ebp]
	fld	DWORD PTR tv92[ebp]
	jmp	SHORT $LN1@solveForX

; 185  : 			else

	jmp	SHORT $LN1@solveForX
$LN2@solveForX:

; 186  : 			{
; 187  : 				assert(0);
; 188  : 				return 0;

	fldz
$LN1@solveForX:

; 189  : 			}
; 190  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?solveForX@Plane@Ogre@@QBEMMM@Z ENDP			; Ogre::Plane::solveForX
_TEXT	ENDS
PUBLIC	?solveForY@Plane@Ogre@@QBEMMM@Z			; Ogre::Plane::solveForY
; Function compile flags: /Odtp
;	COMDAT ?solveForY@Plane@Ogre@@QBEMMM@Z
_TEXT	SEGMENT
tv93 = -8						; size = 4
_this$ = -4						; size = 4
_x$ = 8							; size = 4
_z$ = 12						; size = 4
?solveForY@Plane@Ogre@@QBEMMM@Z PROC			; Ogre::Plane::solveForY, COMDAT
; _this$ = ecx

; 192  : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 193  : 			if( m_normal.y ) return -(m_normal.x*x + m_normal.z*z + m_offset)/m_normal.y;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+4]
	fcomp	QWORD PTR __real@0000000000000000
	fnstsw	ax
	test	ah, 68					; 00000044H
	jnp	SHORT $LN2@solveForY
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx]
	fmul	DWORD PTR _x$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+8]
	fmul	DWORD PTR _z$[ebp]
	faddp	ST(1), ST(0)
	mov	eax, DWORD PTR _this$[ebp]
	fadd	DWORD PTR [eax+12]
	fchs
	mov	ecx, DWORD PTR _this$[ebp]
	fdiv	DWORD PTR [ecx+4]
	fstp	DWORD PTR tv93[ebp]
	fld	DWORD PTR tv93[ebp]
	jmp	SHORT $LN1@solveForY

; 194  : 			else

	jmp	SHORT $LN1@solveForY
$LN2@solveForY:

; 195  : 			{
; 196  : 				assert(0);
; 197  : 				return 0;

	fldz
$LN1@solveForY:

; 198  : 			}
; 199  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?solveForY@Plane@Ogre@@QBEMMM@Z ENDP			; Ogre::Plane::solveForY
_TEXT	ENDS
PUBLIC	?solveForZ@Plane@Ogre@@QBEMMM@Z			; Ogre::Plane::solveForZ
; Function compile flags: /Odtp
;	COMDAT ?solveForZ@Plane@Ogre@@QBEMMM@Z
_TEXT	SEGMENT
tv93 = -8						; size = 4
_this$ = -4						; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
?solveForZ@Plane@Ogre@@QBEMMM@Z PROC			; Ogre::Plane::solveForZ, COMDAT
; _this$ = ecx

; 201  : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 202  : 			if( m_normal.z ) return -(m_normal.x*x + m_normal.y*y + m_offset)/m_normal.z;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+8]
	fcomp	QWORD PTR __real@0000000000000000
	fnstsw	ax
	test	ah, 68					; 00000044H
	jnp	SHORT $LN2@solveForZ
	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx]
	fmul	DWORD PTR _x$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+4]
	fmul	DWORD PTR _y$[ebp]
	faddp	ST(1), ST(0)
	mov	eax, DWORD PTR _this$[ebp]
	fadd	DWORD PTR [eax+12]
	fchs
	mov	ecx, DWORD PTR _this$[ebp]
	fdiv	DWORD PTR [ecx+8]
	fstp	DWORD PTR tv93[ebp]
	fld	DWORD PTR tv93[ebp]
	jmp	SHORT $LN1@solveForZ

; 203  : 			else

	jmp	SHORT $LN1@solveForZ
$LN2@solveForZ:

; 204  : 			{
; 205  : 				assert(0);
; 206  : 				return 0;

	fldz
$LN1@solveForZ:

; 207  : 			}
; 208  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?solveForZ@Plane@Ogre@@QBEMMM@Z ENDP			; Ogre::Plane::solveForZ
_TEXT	ENDS
PUBLIC	?segmentIntersec@Plane@Ogre@@QBE_NAAVVector3@2@ABV32@1@Z ; Ogre::Plane::segmentIntersec
; Function compile flags: /Odtp
;	COMDAT ?segmentIntersec@Plane@Ogre@@QBE_NAAVVector3@2@ABV32@1@Z
_TEXT	SEGMENT
tv140 = -64						; size = 4
_this$ = -60						; size = 4
$T94141 = -56						; size = 12
$T94140 = -44						; size = 12
$T94139 = -32						; size = 12
$T94138 = -20						; size = 12
_fDis0$ = -8						; size = 4
_fDis1$ = -4						; size = 4
_vOut$ = 8						; size = 4
_vP0$ = 12						; size = 4
_vP1$ = 16						; size = 4
?segmentIntersec@Plane@Ogre@@QBE_NAAVVector3@2@ABV32@1@Z PROC ; Ogre::Plane::segmentIntersec, COMDAT
; _this$ = ecx

; 212  : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	mov	DWORD PTR _this$[ebp], ecx

; 213  : 			float fDis0 = distanceToPoint(vP0);

	mov	eax, DWORD PTR _vP0$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?distanceToPoint@Plane@Ogre@@QBEMABVVector3@2@@Z ; Ogre::Plane::distanceToPoint
	fstp	DWORD PTR _fDis0$[ebp]

; 214  : 			float fDis1 = distanceToPoint(vP1);

	mov	ecx, DWORD PTR _vP1$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?distanceToPoint@Plane@Ogre@@QBEMABVVector3@2@@Z ; Ogre::Plane::distanceToPoint
	fstp	DWORD PTR _fDis1$[ebp]

; 215  : 			if( fDis0 * fDis1 >= 0 )

	fld	DWORD PTR _fDis0$[ebp]
	fmul	DWORD PTR _fDis1$[ebp]
	fcomp	QWORD PTR __real@0000000000000000
	fnstsw	ax
	test	ah, 1
	jne	SHORT $LN1@segmentInt

; 216  : 				return false;

	xor	al, al
	jmp	SHORT $LN2@segmentInt
$LN1@segmentInt:

; 217  : 
; 218  : 			vOut = vP0 + (vP1 - vP0) * fDis0 / (fDis0 - fDis1);

	fld	DWORD PTR _fDis0$[ebp]
	fsub	DWORD PTR _fDis1$[ebp]
	fstp	DWORD PTR tv140[ebp]
	fld	DWORD PTR tv140[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR _fDis0$[ebp]
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _vP0$[ebp]
	push	edx
	mov	eax, DWORD PTR _vP1$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T94138[ebp]
	push	ecx
	call	??GOgre@@YA?AVVector3@0@ABV10@0@Z	; Ogre::operator-
	add	esp, 12					; 0000000cH
	push	eax
	lea	edx, DWORD PTR $T94139[ebp]
	push	edx
	call	??DOgre@@YA?AVVector3@0@ABV10@M@Z	; Ogre::operator*
	add	esp, 12					; 0000000cH
	push	eax
	lea	eax, DWORD PTR $T94140[ebp]
	push	eax
	call	??KOgre@@YA?AVVector3@0@ABV10@M@Z	; Ogre::operator/
	add	esp, 12					; 0000000cH
	push	eax
	mov	ecx, DWORD PTR _vP0$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T94141[ebp]
	push	edx
	call	??HOgre@@YA?AVVector3@0@ABV10@0@Z	; Ogre::operator+
	add	esp, 12					; 0000000cH
	push	eax
	mov	ecx, DWORD PTR _vOut$[ebp]
	call	??4Vector3@Ogre@@QAEABV01@ABV01@@Z	; Ogre::Vector3::operator=

; 219  : 			return true;

	mov	al, 1
$LN2@segmentInt:

; 220  : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?segmentIntersec@Plane@Ogre@@QBE_NAAVVector3@2@ABV32@1@Z ENDP ; Ogre::Plane::segmentIntersec
_TEXT	ENDS
PUBLIC	_fabsf
PUBLIC	?segmentSide@Plane@Ogre@@QBE?AW4ESIDE_T@12@ABVVector3@2@0M@Z ; Ogre::Plane::segmentSide
; Function compile flags: /Odtp
;	COMDAT ?segmentSide@Plane@Ogre@@QBE?AW4ESIDE_T@12@ABVVector3@2@0M@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
_dFm$ = -8						; size = 4
_dTo$ = -4						; size = 4
_fm$ = 8						; size = 4
_to$ = 12						; size = 4
_radius$ = 16						; size = 4
?segmentSide@Plane@Ogre@@QBE?AW4ESIDE_T@12@ABVVector3@2@0M@Z PROC ; Ogre::Plane::segmentSide, COMDAT
; _this$ = ecx

; 223  : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 224  : 			assert(isValid());
; 225  : 
; 226  : 			const float dFm = distanceToPoint(fm);

	mov	eax, DWORD PTR _fm$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?distanceToPoint@Plane@Ogre@@QBEMABVVector3@2@@Z ; Ogre::Plane::distanceToPoint
	fstp	DWORD PTR _dFm$[ebp]

; 227  : 			const float dTo = distanceToPoint(to);

	mov	ecx, DWORD PTR _to$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?distanceToPoint@Plane@Ogre@@QBEMABVVector3@2@@Z ; Ogre::Plane::distanceToPoint
	fstp	DWORD PTR _dTo$[ebp]

; 228  : 
; 229  : 			if ( fabsf(dFm) <= EPSILON && fabsf(dTo) <= EPSILON )

	push	ecx
	fld	DWORD PTR _dFm$[ebp]
	fstp	DWORD PTR [esp]
	call	_fabsf
	add	esp, 4
	fld	DWORD PTR _EPSILON
	fcompp
	fnstsw	ax
	test	ah, 1
	jne	SHORT $LN6@segmentSid
	push	ecx
	fld	DWORD PTR _dTo$[ebp]
	fstp	DWORD PTR [esp]
	call	_fabsf
	add	esp, 4
	fld	DWORD PTR _EPSILON
	fcompp
	fnstsw	ax
	test	ah, 1
	jne	SHORT $LN6@segmentSid

; 230  : 			{
; 231  : 				return ON;

	mov	eax, 3
	jmp	SHORT $LN1@segmentSid
	jmp	SHORT $LN1@segmentSid
$LN6@segmentSid:

; 232  : 			}
; 233  : 			else if ( dFm < -radius && dTo < -radius )

	fld	DWORD PTR _radius$[ebp]
	fchs
	fld	DWORD PTR _dFm$[ebp]
	fcompp
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN4@segmentSid
	fld	DWORD PTR _radius$[ebp]
	fchs
	fld	DWORD PTR _dTo$[ebp]
	fcompp
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN4@segmentSid

; 234  : 			{
; 235  : 				return BACK;

	mov	eax, 1
	jmp	SHORT $LN1@segmentSid
	jmp	SHORT $LN1@segmentSid
$LN4@segmentSid:

; 236  : 			}
; 237  : 			else if ( dFm >  radius && dTo >  radius )

	fld	DWORD PTR _dFm$[ebp]
	fld	DWORD PTR _radius$[ebp]
	fcompp
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN2@segmentSid
	fld	DWORD PTR _dTo$[ebp]
	fld	DWORD PTR _radius$[ebp]
	fcompp
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN2@segmentSid

; 238  : 			{
; 239  : 				return FRONT;

	xor	eax, eax
	jmp	SHORT $LN1@segmentSid

; 240  : 			}
; 241  : 			else

	jmp	SHORT $LN1@segmentSid
$LN2@segmentSid:

; 242  : 			{
; 243  : 				return INTERSECT;

	mov	eax, 2
$LN1@segmentSid:

; 244  : 			}
; 245  : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?segmentSide@Plane@Ogre@@QBE?AW4ESIDE_T@12@ABVVector3@2@0M@Z ENDP ; Ogre::Plane::segmentSide
_TEXT	ENDS
EXTRN	_fabs:PROC
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\math.h
;	COMDAT _fabsf
_TEXT	SEGMENT
tv73 = -4						; size = 4
__X$ = 8						; size = 4
_fabsf	PROC						; COMDAT

; 384  :         {return ((float)fabs((double)_X)); }

	push	ebp
	mov	ebp, esp
	push	ecx
	fld	DWORD PTR __X$[ebp]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_fabs
	add	esp, 8
	fstp	DWORD PTR tv73[ebp]
	fld	DWORD PTR tv73[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
_fabsf	ENDP
_TEXT	ENDS
PUBLIC	?getVec4@Plane@Ogre@@QBEABVVector4@2@XZ		; Ogre::Plane::getVec4
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogreplane.h
;	COMDAT ?getVec4@Plane@Ogre@@QBEABVVector4@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getVec4@Plane@Ogre@@QBEABVVector4@2@XZ PROC		; Ogre::Plane::getVec4, COMDAT
; _this$ = ecx

; 251  : 		{ return *((Vector4 *)&m_normal); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
?getVec4@Plane@Ogre@@QBEABVVector4@2@XZ ENDP		; Ogre::Plane::getVec4
_TEXT	ENDS
PUBLIC	?getNormal@Plane@Ogre@@QBEABVVector3@2@XZ	; Ogre::Plane::getNormal
; Function compile flags: /Odtp
;	COMDAT ?getNormal@Plane@Ogre@@QBEABVVector3@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getNormal@Plane@Ogre@@QBEABVVector3@2@XZ PROC		; Ogre::Plane::getNormal, COMDAT
; _this$ = ecx

; 254  : 		{ return m_normal; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
?getNormal@Plane@Ogre@@QBEABVVector3@2@XZ ENDP		; Ogre::Plane::getNormal
_TEXT	ENDS
PUBLIC	?getOffset@Plane@Ogre@@QBE?BMXZ			; Ogre::Plane::getOffset
; Function compile flags: /Odtp
;	COMDAT ?getOffset@Plane@Ogre@@QBE?BMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getOffset@Plane@Ogre@@QBE?BMXZ PROC			; Ogre::Plane::getOffset, COMDAT
; _this$ = ecx

; 257  : 		{ return(m_offset); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR [eax+12]
	mov	esp, ebp
	pop	ebp
	ret	0
?getOffset@Plane@Ogre@@QBE?BMXZ ENDP			; Ogre::Plane::getOffset
_TEXT	ENDS
PUBLIC	??0Plane@Ogre@@QAE@ABV01@@Z			; Ogre::Plane::Plane
; Function compile flags: /Odtp
;	COMDAT ??0Plane@Ogre@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0Plane@Ogre@@QAE@ABV01@@Z PROC			; Ogre::Plane::Plane, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0Vector3@Ogre@@QAE@ABV01@@Z		; Ogre::Vector3::Vector3
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	fld	DWORD PTR [edx+12]
	fstp	DWORD PTR [ecx+12]
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0Plane@Ogre@@QAE@ABV01@@Z ENDP			; Ogre::Plane::Plane
_TEXT	ENDS
PUBLIC	??4Plane@Ogre@@QAEAAV01@ABV01@@Z		; Ogre::Plane::operator=
; Function compile flags: /Odtp
;	COMDAT ??4Plane@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4Plane@Ogre@@QAEAAV01@ABV01@@Z PROC			; Ogre::Plane::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4Vector3@Ogre@@QAEABV01@ABV01@@Z	; Ogre::Vector3::operator=
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	fld	DWORD PTR [edx+12]
	fstp	DWORD PTR [ecx+12]
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4Plane@Ogre@@QAEAAV01@ABV01@@Z ENDP			; Ogre::Plane::operator=
_TEXT	ENDS
PUBLIC	??0WorldPlane@Ogre@@QAE@XZ			; Ogre::WorldPlane::WorldPlane
; Function compile flags: /Odtp
;	COMDAT ??0WorldPlane@Ogre@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0WorldPlane@Ogre@@QAE@XZ PROC				; Ogre::WorldPlane::WorldPlane, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0Vector3@Ogre@@QAE@XZ			; Ogre::Vector3::Vector3
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??0WorldPos@Ogre@@QAE@XZ		; Ogre::WorldPos::WorldPos
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0WorldPlane@Ogre@@QAE@XZ ENDP				; Ogre::WorldPlane::WorldPlane
_TEXT	ENDS
PUBLIC	??0WorldPlane@Ogre@@QAE@ABV01@@Z		; Ogre::WorldPlane::WorldPlane
; Function compile flags: /Odtp
;	COMDAT ??0WorldPlane@Ogre@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0WorldPlane@Ogre@@QAE@ABV01@@Z PROC			; Ogre::WorldPlane::WorldPlane, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0Vector3@Ogre@@QAE@ABV01@@Z		; Ogre::Vector3::Vector3
	mov	ecx, DWORD PTR ___that$[ebp]
	add	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 12					; 0000000cH
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0WorldPlane@Ogre@@QAE@ABV01@@Z ENDP			; Ogre::WorldPlane::WorldPlane
_TEXT	ENDS
PUBLIC	??4WorldPlane@Ogre@@QAEAAV01@ABV01@@Z		; Ogre::WorldPlane::operator=
; Function compile flags: /Odtp
;	COMDAT ??4WorldPlane@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4WorldPlane@Ogre@@QAEAAV01@ABV01@@Z PROC		; Ogre::WorldPlane::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4Vector3@Ogre@@QAEABV01@ABV01@@Z	; Ogre::Vector3::operator=
	mov	ecx, DWORD PTR ___that$[ebp]
	add	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 12					; 0000000cH
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4WorldPlane@Ogre@@QAEAAV01@ABV01@@Z ENDP		; Ogre::WorldPlane::operator=
_TEXT	ENDS
PUBLIC	?getBounding@CullFrustum@Ogre@@QAEABVBoxSphereBound@2@XZ ; Ogre::CullFrustum::getBounding
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogrecullfrustum.h
;	COMDAT ?getBounding@CullFrustum@Ogre@@QAEABVBoxSphereBound@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getBounding@CullFrustum@Ogre@@QAEABVBoxSphereBound@2@XZ PROC ; Ogre::CullFrustum::getBounding, COMDAT
; _this$ = ecx

; 34   : 		const BoxSphereBound &getBounding(){ return m_Bounding; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 516				; 00000204H
	mov	esp, ebp
	pop	ebp
	ret	0
?getBounding@CullFrustum@Ogre@@QAEABVBoxSphereBound@2@XZ ENDP ; Ogre::CullFrustum::getBounding
_TEXT	ENDS
PUBLIC	??0CullFrustum@Ogre@@QAE@ABV01@@Z		; Ogre::CullFrustum::CullFrustum
; Function compile flags: /Odtp
;	COMDAT ??0CullFrustum@Ogre@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0CullFrustum@Ogre@@QAE@ABV01@@Z PROC			; Ogre::CullFrustum::CullFrustum, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	push	OFFSET ??0Plane@Ogre@@QAE@ABV01@@Z
	push	32					; 00000020H
	push	16					; 00000010H
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??__G@YGXPAX0IHP6EPAX00@Z@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+512]
	mov	DWORD PTR [edx+512], ecx
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 516				; 00000204H
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 516				; 00000204H
	call	??0BoxSphereBound@Ogre@@QAE@ABV01@@Z
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0CullFrustum@Ogre@@QAE@ABV01@@Z ENDP			; Ogre::CullFrustum::CullFrustum
_TEXT	ENDS
PUBLIC	??4CullFrustum@Ogre@@QAEAAV01@ABV01@@Z		; Ogre::CullFrustum::operator=
; Function compile flags: /Odtp
;	COMDAT ??4CullFrustum@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_$S6$64764 = -4						; size = 4
___that$ = 8						; size = 4
??4CullFrustum@Ogre@@QAEAAV01@ABV01@@Z PROC		; Ogre::CullFrustum::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR _$S6$64764[ebp], 0
	jmp	SHORT $LN3@operator@11
$LN2@operator@11:
	mov	eax, DWORD PTR _$S6$64764[ebp]
	add	eax, 1
	mov	DWORD PTR _$S6$64764[ebp], eax
$LN3@operator@11:
	cmp	DWORD PTR _$S6$64764[ebp], 32		; 00000020H
	jae	SHORT $LN1@operator@11
	mov	ecx, DWORD PTR _$S6$64764[ebp]
	shl	ecx, 4
	add	ecx, DWORD PTR ___that$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _$S6$64764[ebp]
	shl	ecx, 4
	add	ecx, DWORD PTR _this$[ebp]
	call	??4Plane@Ogre@@QAEAAV01@ABV01@@Z
	jmp	SHORT $LN2@operator@11
$LN1@operator@11:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+512]
	mov	DWORD PTR [edx+512], ecx
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 516				; 00000204H
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 516				; 00000204H
	call	??4BoxSphereBound@Ogre@@QAEAAV01@ABV01@@Z
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4CullFrustum@Ogre@@QAEAAV01@ABV01@@Z ENDP		; Ogre::CullFrustum::operator=
_TEXT	ENDS
PUBLIC	?setShaderLevel@SceneRenderer@Ogre@@QAEXH@Z	; Ogre::SceneRenderer::setShaderLevel
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogrescenerenderer.h
;	COMDAT ?setShaderLevel@SceneRenderer@Ogre@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_nShaderLevel$ = 8					; size = 4
?setShaderLevel@SceneRenderer@Ogre@@QAEXH@Z PROC	; Ogre::SceneRenderer::setShaderLevel, COMDAT
; _this$ = ecx

; 23   : 		void setShaderLevel(int nShaderLevel){m_nShaderLevel = nShaderLevel;}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _nShaderLevel$[ebp]
	mov	DWORD PTR [eax+16], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?setShaderLevel@SceneRenderer@Ogre@@QAEXH@Z ENDP	; Ogre::SceneRenderer::setShaderLevel
_TEXT	ENDS
PUBLIC	?setSceneDebugger@SceneRenderer@Ogre@@QAEXPAVSceneDebugger@2@@Z ; Ogre::SceneRenderer::setSceneDebugger
; Function compile flags: /Odtp
;	COMDAT ?setSceneDebugger@SceneRenderer@Ogre@@QAEXPAVSceneDebugger@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pSceneDebugger$ = 8					; size = 4
?setSceneDebugger@SceneRenderer@Ogre@@QAEXPAVSceneDebugger@2@@Z PROC ; Ogre::SceneRenderer::setSceneDebugger, COMDAT
; _this$ = ecx

; 24   : 		void setSceneDebugger(SceneDebugger* pSceneDebugger){ m_pSceneDebugger = pSceneDebugger; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pSceneDebugger$[ebp]
	mov	DWORD PTR [eax+576], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?setSceneDebugger@SceneRenderer@Ogre@@QAEXPAVSceneDebugger@2@@Z ENDP ; Ogre::SceneRenderer::setSceneDebugger
_TEXT	ENDS
PUBLIC	?setCamera@SceneRenderer@Ogre@@QAEXPAVCamera@2@@Z ; Ogre::SceneRenderer::setCamera
; Function compile flags: /Odtp
;	COMDAT ?setCamera@SceneRenderer@Ogre@@QAEXPAVCamera@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pcamera$ = 8						; size = 4
?setCamera@SceneRenderer@Ogre@@QAEXPAVCamera@2@@Z PROC	; Ogre::SceneRenderer::setCamera, COMDAT
; _this$ = ecx

; 32   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 33   : 			m_pCamera = pcamera;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pcamera$[ebp]
	mov	DWORD PTR [eax+580], ecx

; 34   : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?setCamera@SceneRenderer@Ogre@@QAEXPAVCamera@2@@Z ENDP	; Ogre::SceneRenderer::setCamera
_TEXT	ENDS
PUBLIC	?getCamera@SceneRenderer@Ogre@@QAEPAVCamera@2@XZ ; Ogre::SceneRenderer::getCamera
; Function compile flags: /Odtp
;	COMDAT ?getCamera@SceneRenderer@Ogre@@QAEPAVCamera@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getCamera@SceneRenderer@Ogre@@QAEPAVCamera@2@XZ PROC	; Ogre::SceneRenderer::getCamera, COMDAT
; _this$ = ecx

; 37   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 38   : 			return m_pCamera;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+580]

; 39   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?getCamera@SceneRenderer@Ogre@@QAEPAVCamera@2@XZ ENDP	; Ogre::SceneRenderer::getCamera
_TEXT	ENDS
PUBLIC	?setRenderTarget@SceneRenderer@Ogre@@QAEXPAVRenderTarget@2@@Z ; Ogre::SceneRenderer::setRenderTarget
; Function compile flags: /Odtp
;	COMDAT ?setRenderTarget@SceneRenderer@Ogre@@QAEXPAVRenderTarget@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_ptarget$ = 8						; size = 4
?setRenderTarget@SceneRenderer@Ogre@@QAEXPAVRenderTarget@2@@Z PROC ; Ogre::SceneRenderer::setRenderTarget, COMDAT
; _this$ = ecx

; 42   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 43   : 			m_pTarget = ptarget;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _ptarget$[ebp]
	mov	DWORD PTR [eax+608], ecx

; 44   : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?setRenderTarget@SceneRenderer@Ogre@@QAEXPAVRenderTarget@2@@Z ENDP ; Ogre::SceneRenderer::setRenderTarget
_TEXT	ENDS
PUBLIC	?setRenderScene@SceneRenderer@Ogre@@QAEXPAVGameScene@2@@Z ; Ogre::SceneRenderer::setRenderScene
; Function compile flags: /Odtp
;	COMDAT ?setRenderScene@SceneRenderer@Ogre@@QAEXPAVGameScene@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pscene$ = 8						; size = 4
?setRenderScene@SceneRenderer@Ogre@@QAEXPAVGameScene@2@@Z PROC ; Ogre::SceneRenderer::setRenderScene, COMDAT
; _this$ = ecx

; 47   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 48   : 			m_pScene = pscene;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pscene$[ebp]
	mov	DWORD PTR [eax+612], ecx

; 49   : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?setRenderScene@SceneRenderer@Ogre@@QAEXPAVGameScene@2@@Z ENDP ; Ogre::SceneRenderer::setRenderScene
_TEXT	ENDS
PUBLIC	?setClearParams@SceneRenderer@Ogre@@QAEXIIMI@Z	; Ogre::SceneRenderer::setClearParams
; Function compile flags: /Odtp
;	COMDAT ?setClearParams@SceneRenderer@Ogre@@QAEXIIMI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_flags$ = 8						; size = 4
_color$ = 12						; size = 4
_depth$ = 16						; size = 4
_stencil$ = 20						; size = 4
?setClearParams@SceneRenderer@Ogre@@QAEXIIMI@Z PROC	; Ogre::SceneRenderer::setClearParams, COMDAT
; _this$ = ecx

; 52   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 53   : 			m_ClearFlags = flags;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _flags$[ebp]
	mov	DWORD PTR [eax+616], ecx

; 54   : 			m_ClearColor = color;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _color$[ebp]
	mov	DWORD PTR [edx+620], eax

; 55   : 			m_ClearDepth = depth;

	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _depth$[ebp]
	fstp	DWORD PTR [ecx+624]

; 56   : 			m_ClearStencil = stencil;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _stencil$[ebp]
	mov	DWORD PTR [edx+628], eax

; 57   : 		}

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?setClearParams@SceneRenderer@Ogre@@QAEXIIMI@Z ENDP	; Ogre::SceneRenderer::setClearParams
_TEXT	ENDS
PUBLIC	?setRenderPool@SceneRenderer@Ogre@@QAEXPAVShaderContextPool@2@PAVDynamicBufferPool@2@@Z ; Ogre::SceneRenderer::setRenderPool
; Function compile flags: /Odtp
;	COMDAT ?setRenderPool@SceneRenderer@Ogre@@QAEXPAVShaderContextPool@2@PAVDynamicBufferPool@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pcontextpool$ = 8					; size = 4
_pbufferpool$ = 12					; size = 4
?setRenderPool@SceneRenderer@Ogre@@QAEXPAVShaderContextPool@2@PAVDynamicBufferPool@2@@Z PROC ; Ogre::SceneRenderer::setRenderPool, COMDAT
; _this$ = ecx

; 60   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 61   : 			m_pContextPool = pcontextpool;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pcontextpool$[ebp]
	mov	DWORD PTR [eax+568], ecx

; 62   : 			m_pDynBufferPool = pbufferpool;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _pbufferpool$[ebp]
	mov	DWORD PTR [edx+572], eax

; 63   : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?setRenderPool@SceneRenderer@Ogre@@QAEXPAVShaderContextPool@2@PAVDynamicBufferPool@2@@Z ENDP ; Ogre::SceneRenderer::setRenderPool
_TEXT	ENDS
PUBLIC	?onLostDevice@SceneRenderer@Ogre@@UAEXXZ	; Ogre::SceneRenderer::onLostDevice
; Function compile flags: /Odtp
;	COMDAT ?onLostDevice@SceneRenderer@Ogre@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?onLostDevice@SceneRenderer@Ogre@@UAEXXZ PROC		; Ogre::SceneRenderer::onLostDevice, COMDAT
; _this$ = ecx

; 66   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 67   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?onLostDevice@SceneRenderer@Ogre@@UAEXXZ ENDP		; Ogre::SceneRenderer::onLostDevice
_TEXT	ENDS
PUBLIC	?onRestoreDevice@SceneRenderer@Ogre@@UAEXXZ	; Ogre::SceneRenderer::onRestoreDevice
; Function compile flags: /Odtp
;	COMDAT ?onRestoreDevice@SceneRenderer@Ogre@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?onRestoreDevice@SceneRenderer@Ogre@@UAEXXZ PROC	; Ogre::SceneRenderer::onRestoreDevice, COMDAT
; _this$ = ecx

; 70   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 71   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?onRestoreDevice@SceneRenderer@Ogre@@UAEXXZ ENDP	; Ogre::SceneRenderer::onRestoreDevice
_TEXT	ENDS
PUBLIC	?getGameScene@SceneRenderer@Ogre@@QAEPAVGameScene@2@XZ ; Ogre::SceneRenderer::getGameScene
; Function compile flags: /Odtp
;	COMDAT ?getGameScene@SceneRenderer@Ogre@@QAEPAVGameScene@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getGameScene@SceneRenderer@Ogre@@QAEPAVGameScene@2@XZ PROC ; Ogre::SceneRenderer::getGameScene, COMDAT
; _this$ = ecx

; 76   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 77   : 			return m_pScene;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+612]

; 78   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?getGameScene@SceneRenderer@Ogre@@QAEPAVGameScene@2@XZ ENDP ; Ogre::SceneRenderer::getGameScene
_TEXT	ENDS
PUBLIC	??_7SceneRenderer@Ogre@@6B@			; Ogre::SceneRenderer::`vftable'
PUBLIC	??0SceneRenderer@Ogre@@QAE@ABV01@@Z		; Ogre::SceneRenderer::SceneRenderer
PUBLIC	??_R4SceneRenderer@Ogre@@6B@			; Ogre::SceneRenderer::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVSceneRenderer@Ogre@@@8			; Ogre::SceneRenderer `RTTI Type Descriptor'
PUBLIC	??_R3SceneRenderer@Ogre@@8			; Ogre::SceneRenderer::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2SceneRenderer@Ogre@@8			; Ogre::SceneRenderer::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@SceneRenderer@Ogre@@8		; Ogre::SceneRenderer::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_ESceneRenderer@Ogre@@UAEPAXI@Z		; Ogre::SceneRenderer::`vector deleting destructor'
EXTRN	??1CullFrustum@Ogre@@QAE@XZ:PROC		; Ogre::CullFrustum::~CullFrustum
;	COMDAT ??_R1A@?0A@EA@SceneRenderer@Ogre@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@SceneRenderer@Ogre@@8 DD FLAT:??_R0?AVSceneRenderer@Ogre@@@8 ; Ogre::SceneRenderer::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3SceneRenderer@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R2SceneRenderer@Ogre@@8
rdata$r	SEGMENT
??_R2SceneRenderer@Ogre@@8 DD FLAT:??_R1A@?0A@EA@SceneRenderer@Ogre@@8 ; Ogre::SceneRenderer::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3SceneRenderer@Ogre@@8
rdata$r	SEGMENT
??_R3SceneRenderer@Ogre@@8 DD 00H			; Ogre::SceneRenderer::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2SceneRenderer@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVSceneRenderer@Ogre@@@8
_DATA	SEGMENT
??_R0?AVSceneRenderer@Ogre@@@8 DD FLAT:??_7type_info@@6B@ ; Ogre::SceneRenderer `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVSceneRenderer@Ogre@@', 00H
_DATA	ENDS
;	COMDAT ??_R4SceneRenderer@Ogre@@6B@
rdata$r	SEGMENT
??_R4SceneRenderer@Ogre@@6B@ DD 00H			; Ogre::SceneRenderer::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVSceneRenderer@Ogre@@@8
	DD	FLAT:??_R3SceneRenderer@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_7SceneRenderer@Ogre@@6B@
CONST	SEGMENT
??_7SceneRenderer@Ogre@@6B@ DD FLAT:??_R4SceneRenderer@Ogre@@6B@ ; Ogre::SceneRenderer::`vftable'
	DD	FLAT:??_ESceneRenderer@Ogre@@UAEPAXI@Z
	DD	FLAT:?onLostDevice@SceneRenderer@Ogre@@UAEXXZ
	DD	FLAT:?onRestoreDevice@SceneRenderer@Ogre@@UAEXXZ
	DD	FLAT:__purecall
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0SceneRenderer@Ogre@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0SceneRenderer@Ogre@@QAE@ABV01@@Z$0
__ehfuncinfo$??0SceneRenderer@Ogre@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0SceneRenderer@Ogre@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0SceneRenderer@Ogre@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0SceneRenderer@Ogre@@QAE@ABV01@@Z PROC		; Ogre::SceneRenderer::SceneRenderer, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0SceneRenderer@Ogre@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7SceneRenderer@Ogre@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+4], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+8], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR [ecx+12], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR [ecx+16], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	DWORD PTR [ecx+20], eax
	mov	ecx, DWORD PTR ___that$[ebp]
	add	ecx, 24					; 00000018H
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	??0CullFrustum@Ogre@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+568]
	mov	DWORD PTR [edx+568], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+572]
	mov	DWORD PTR [edx+572], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+576]
	mov	DWORD PTR [edx+576], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+580]
	mov	DWORD PTR [edx+580], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+584]
	mov	DWORD PTR [edx+584], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+588]
	mov	DWORD PTR [edx+588], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+592]
	mov	DWORD PTR [edx+592], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+596]
	mov	DWORD PTR [edx+596], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+600]
	mov	DWORD PTR [edx+600], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+604]
	mov	DWORD PTR [edx+604], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+608]
	mov	DWORD PTR [edx+608], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+612]
	mov	DWORD PTR [edx+612], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+616]
	mov	DWORD PTR [edx+616], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+620]
	mov	DWORD PTR [edx+620], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	fld	DWORD PTR [eax+624]
	fstp	DWORD PTR [edx+624]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+628]
	mov	DWORD PTR [ecx+628], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	al, BYTE PTR [edx+632]
	mov	BYTE PTR [ecx+632], al
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0SceneRenderer@Ogre@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	jmp	??1CullFrustum@Ogre@@QAE@XZ		; Ogre::CullFrustum::~CullFrustum
__ehhandler$??0SceneRenderer@Ogre@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0SceneRenderer@Ogre@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0SceneRenderer@Ogre@@QAE@ABV01@@Z ENDP		; Ogre::SceneRenderer::SceneRenderer
PUBLIC	??4SceneRenderer@Ogre@@QAEAAV01@ABV01@@Z	; Ogre::SceneRenderer::operator=
; Function compile flags: /Odtp
;	COMDAT ??4SceneRenderer@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4SceneRenderer@Ogre@@QAEAAV01@ABV01@@Z PROC		; Ogre::SceneRenderer::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax+12], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR [eax+16], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR [eax+20], edx
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 24					; 00000018H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	??4CullFrustum@Ogre@@QAEAAV01@ABV01@@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+568]
	mov	DWORD PTR [ecx+568], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+572]
	mov	DWORD PTR [ecx+572], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+576]
	mov	DWORD PTR [ecx+576], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+580]
	mov	DWORD PTR [ecx+580], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+584]
	mov	DWORD PTR [ecx+584], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+588]
	mov	DWORD PTR [ecx+588], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+592]
	mov	DWORD PTR [ecx+592], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+596]
	mov	DWORD PTR [ecx+596], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+600]
	mov	DWORD PTR [ecx+600], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+604]
	mov	DWORD PTR [ecx+604], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+608]
	mov	DWORD PTR [ecx+608], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+612]
	mov	DWORD PTR [ecx+612], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+616]
	mov	DWORD PTR [ecx+616], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+620]
	mov	DWORD PTR [ecx+620], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	fld	DWORD PTR [edx+624]
	fstp	DWORD PTR [ecx+624]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+628]
	mov	DWORD PTR [eax+628], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	dl, BYTE PTR [ecx+632]
	mov	BYTE PTR [eax+632], dl
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4SceneRenderer@Ogre@@QAEAAV01@ABV01@@Z ENDP		; Ogre::SceneRenderer::operator=
_TEXT	ENDS
PUBLIC	??_GSceneRenderer@Ogre@@UAEPAXI@Z		; Ogre::SceneRenderer::`scalar deleting destructor'
EXTRN	??1SceneRenderer@Ogre@@UAE@XZ:PROC		; Ogre::SceneRenderer::~SceneRenderer
; Function compile flags: /Odtp
;	COMDAT ??_GSceneRenderer@Ogre@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GSceneRenderer@Ogre@@UAEPAXI@Z PROC			; Ogre::SceneRenderer::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1SceneRenderer@Ogre@@UAE@XZ		; Ogre::SceneRenderer::~SceneRenderer
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@20
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@20:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GSceneRenderer@Ogre@@UAEPAXI@Z ENDP			; Ogre::SceneRenderer::`scalar deleting destructor'
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_ESceneRenderer@Ogre@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_ESceneRenderer@Ogre@@UAEPAXI@Z PROC			; Ogre::SceneRenderer::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 2
	je	SHORT $LN3@vector@18
	push	OFFSET ??1SceneRenderer@Ogre@@UAE@XZ	; Ogre::SceneRenderer::~SceneRenderer
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx-4]
	push	edx
	push	636					; 0000027cH
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??_M@YGXPAXIHP6EX0@Z@Z
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN2@vector@18
	mov	edx, DWORD PTR _this$[ebp]
	sub	edx, 4
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN2@vector@18:
	mov	eax, DWORD PTR _this$[ebp]
	sub	eax, 4
	jmp	SHORT $LN4@vector@18
$LN3@vector@18:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1SceneRenderer@Ogre@@UAE@XZ		; Ogre::SceneRenderer::~SceneRenderer
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@vector@18
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@vector@18:
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector@18:
	mov	esp, ebp
	pop	ebp
	ret	4
??_ESceneRenderer@Ogre@@UAEPAXI@Z ENDP			; Ogre::SceneRenderer::`vector deleting destructor'
_TEXT	ENDS
PUBLIC	??0CameraShakeSource@NormalSceneRenderer@Ogre@@QAE@ABU012@@Z ; Ogre::NormalSceneRenderer::CameraShakeSource::CameraShakeSource
PUBLIC	??_7NormalSceneRenderer@Ogre@@6B@		; Ogre::NormalSceneRenderer::`vftable'
PUBLIC	??0NormalSceneRenderer@Ogre@@QAE@ABV01@@Z	; Ogre::NormalSceneRenderer::NormalSceneRenderer
PUBLIC	??_R4NormalSceneRenderer@Ogre@@6B@		; Ogre::NormalSceneRenderer::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVNormalSceneRenderer@Ogre@@@8		; Ogre::NormalSceneRenderer `RTTI Type Descriptor'
PUBLIC	??_R3NormalSceneRenderer@Ogre@@8		; Ogre::NormalSceneRenderer::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2NormalSceneRenderer@Ogre@@8		; Ogre::NormalSceneRenderer::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@NormalSceneRenderer@Ogre@@8	; Ogre::NormalSceneRenderer::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_ENormalSceneRenderer@Ogre@@UAEPAXI@Z		; Ogre::NormalSceneRenderer::`vector deleting destructor'
EXTRN	?onLostDevice@NormalSceneRenderer@Ogre@@UAEXXZ:PROC ; Ogre::NormalSceneRenderer::onLostDevice
EXTRN	?onRestoreDevice@NormalSceneRenderer@Ogre@@UAEXXZ:PROC ; Ogre::NormalSceneRenderer::onRestoreDevice
EXTRN	?doRender@NormalSceneRenderer@Ogre@@UAEXXZ:PROC	; Ogre::NormalSceneRenderer::doRender
;	COMDAT ??_R1A@?0A@EA@NormalSceneRenderer@Ogre@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@NormalSceneRenderer@Ogre@@8 DD FLAT:??_R0?AVNormalSceneRenderer@Ogre@@@8 ; Ogre::NormalSceneRenderer::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3NormalSceneRenderer@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R2NormalSceneRenderer@Ogre@@8
rdata$r	SEGMENT
??_R2NormalSceneRenderer@Ogre@@8 DD FLAT:??_R1A@?0A@EA@NormalSceneRenderer@Ogre@@8 ; Ogre::NormalSceneRenderer::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@SceneRenderer@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R3NormalSceneRenderer@Ogre@@8
rdata$r	SEGMENT
??_R3NormalSceneRenderer@Ogre@@8 DD 00H			; Ogre::NormalSceneRenderer::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2NormalSceneRenderer@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVNormalSceneRenderer@Ogre@@@8
_DATA	SEGMENT
??_R0?AVNormalSceneRenderer@Ogre@@@8 DD FLAT:??_7type_info@@6B@ ; Ogre::NormalSceneRenderer `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVNormalSceneRenderer@Ogre@@', 00H
_DATA	ENDS
;	COMDAT ??_R4NormalSceneRenderer@Ogre@@6B@
rdata$r	SEGMENT
??_R4NormalSceneRenderer@Ogre@@6B@ DD 00H		; Ogre::NormalSceneRenderer::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVNormalSceneRenderer@Ogre@@@8
	DD	FLAT:??_R3NormalSceneRenderer@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_7NormalSceneRenderer@Ogre@@6B@
CONST	SEGMENT
??_7NormalSceneRenderer@Ogre@@6B@ DD FLAT:??_R4NormalSceneRenderer@Ogre@@6B@ ; Ogre::NormalSceneRenderer::`vftable'
	DD	FLAT:??_ENormalSceneRenderer@Ogre@@UAEPAXI@Z
	DD	FLAT:?onLostDevice@NormalSceneRenderer@Ogre@@UAEXXZ
	DD	FLAT:?onRestoreDevice@NormalSceneRenderer@Ogre@@UAEXXZ
	DD	FLAT:?doRender@NormalSceneRenderer@Ogre@@UAEXXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0NormalSceneRenderer@Ogre@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0NormalSceneRenderer@Ogre@@QAE@ABV01@@Z$0
__ehfuncinfo$??0NormalSceneRenderer@Ogre@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0NormalSceneRenderer@Ogre@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0NormalSceneRenderer@Ogre@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0NormalSceneRenderer@Ogre@@QAE@ABV01@@Z PROC		; Ogre::NormalSceneRenderer::NormalSceneRenderer, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0NormalSceneRenderer@Ogre@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0SceneRenderer@Ogre@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7NormalSceneRenderer@Ogre@@6B@
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+636]
	mov	DWORD PTR [edx+636], ecx
	mov	esi, DWORD PTR ___that$[ebp]
	add	esi, 640				; 00000280H
	mov	edi, DWORD PTR _this$[ebp]
	add	edi, 640				; 00000280H
	mov	ecx, 24					; 00000018H
	rep movsd
	push	OFFSET ??0CameraShakeSource@NormalSceneRenderer@Ogre@@QAE@ABU012@@Z
	push	16					; 00000010H
	push	20					; 00000014H
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 736				; 000002e0H
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 736				; 000002e0H
	push	eax
	call	??__G@YGXPAX0IHP6EPAX00@Z@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+1056]
	mov	DWORD PTR [ecx+1056], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+1060]
	mov	DWORD PTR [ecx+1060], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+1064]
	mov	DWORD PTR [ecx+1064], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0NormalSceneRenderer@Ogre@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1SceneRenderer@Ogre@@UAE@XZ		; Ogre::SceneRenderer::~SceneRenderer
__ehhandler$??0NormalSceneRenderer@Ogre@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0NormalSceneRenderer@Ogre@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0NormalSceneRenderer@Ogre@@QAE@ABV01@@Z ENDP		; Ogre::NormalSceneRenderer::NormalSceneRenderer
PUBLIC	??4CameraShakeSource@NormalSceneRenderer@Ogre@@QAEAAU012@ABU012@@Z ; Ogre::NormalSceneRenderer::CameraShakeSource::operator=
PUBLIC	??4NormalSceneRenderer@Ogre@@QAEAAV01@ABV01@@Z	; Ogre::NormalSceneRenderer::operator=
; Function compile flags: /Odtp
;	COMDAT ??4NormalSceneRenderer@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
_$S8$64967 = -8						; size = 4
_$S7$64963 = -4						; size = 4
___that$ = 8						; size = 4
??4NormalSceneRenderer@Ogre@@QAEAAV01@ABV01@@Z PROC	; Ogre::NormalSceneRenderer::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4SceneRenderer@Ogre@@QAEAAV01@ABV01@@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+636]
	mov	DWORD PTR [ecx+636], eax
	mov	DWORD PTR _$S7$64963[ebp], 0
	jmp	SHORT $LN6@operator@12
$LN5@operator@12:
	mov	ecx, DWORD PTR _$S7$64963[ebp]
	add	ecx, 1
	mov	DWORD PTR _$S7$64963[ebp], ecx
$LN6@operator@12:
	cmp	DWORD PTR _$S7$64963[ebp], 24		; 00000018H
	jae	SHORT $LN4@operator@12
	mov	edx, DWORD PTR _$S7$64963[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _$S7$64963[ebp]
	mov	esi, DWORD PTR ___that$[ebp]
	fld	DWORD PTR [esi+ecx*4+640]
	fstp	DWORD PTR [eax+edx*4+640]
	jmp	SHORT $LN5@operator@12
$LN4@operator@12:
	mov	DWORD PTR _$S8$64967[ebp], 0
	jmp	SHORT $LN3@operator@12
$LN2@operator@12:
	mov	edx, DWORD PTR _$S8$64967[ebp]
	add	edx, 1
	mov	DWORD PTR _$S8$64967[ebp], edx
$LN3@operator@12:
	cmp	DWORD PTR _$S8$64967[ebp], 16		; 00000010H
	jae	SHORT $LN1@operator@12
	mov	eax, DWORD PTR _$S8$64967[ebp]
	imul	eax, 20					; 00000014H
	mov	ecx, DWORD PTR ___that$[ebp]
	lea	edx, DWORD PTR [ecx+eax+736]
	push	edx
	mov	eax, DWORD PTR _$S8$64967[ebp]
	imul	eax, 20					; 00000014H
	mov	ecx, DWORD PTR _this$[ebp]
	lea	ecx, DWORD PTR [ecx+eax+736]
	call	??4CameraShakeSource@NormalSceneRenderer@Ogre@@QAEAAU012@ABU012@@Z
	jmp	SHORT $LN2@operator@12
$LN1@operator@12:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+1056]
	mov	DWORD PTR [edx+1056], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+1060]
	mov	DWORD PTR [edx+1060], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+1064]
	mov	DWORD PTR [edx+1064], ecx
	mov	eax, DWORD PTR _this$[ebp]
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
??4NormalSceneRenderer@Ogre@@QAEAAV01@ABV01@@Z ENDP	; Ogre::NormalSceneRenderer::operator=
_TEXT	ENDS
PUBLIC	??_GNormalSceneRenderer@Ogre@@UAEPAXI@Z		; Ogre::NormalSceneRenderer::`scalar deleting destructor'
EXTRN	??1NormalSceneRenderer@Ogre@@UAE@XZ:PROC	; Ogre::NormalSceneRenderer::~NormalSceneRenderer
; Function compile flags: /Odtp
;	COMDAT ??_GNormalSceneRenderer@Ogre@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GNormalSceneRenderer@Ogre@@UAEPAXI@Z PROC		; Ogre::NormalSceneRenderer::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1NormalSceneRenderer@Ogre@@UAE@XZ	; Ogre::NormalSceneRenderer::~NormalSceneRenderer
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@21
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@21:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GNormalSceneRenderer@Ogre@@UAEPAXI@Z ENDP		; Ogre::NormalSceneRenderer::`scalar deleting destructor'
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_ENormalSceneRenderer@Ogre@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_ENormalSceneRenderer@Ogre@@UAEPAXI@Z PROC		; Ogre::NormalSceneRenderer::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 2
	je	SHORT $LN3@vector@19
	push	OFFSET ??1NormalSceneRenderer@Ogre@@UAE@XZ ; Ogre::NormalSceneRenderer::~NormalSceneRenderer
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx-4]
	push	edx
	push	1068					; 0000042cH
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??_M@YGXPAXIHP6EX0@Z@Z
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN2@vector@19
	mov	edx, DWORD PTR _this$[ebp]
	sub	edx, 4
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN2@vector@19:
	mov	eax, DWORD PTR _this$[ebp]
	sub	eax, 4
	jmp	SHORT $LN4@vector@19
$LN3@vector@19:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1NormalSceneRenderer@Ogre@@UAE@XZ	; Ogre::NormalSceneRenderer::~NormalSceneRenderer
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@vector@19
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@vector@19:
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector@19:
	mov	esp, ebp
	pop	ebp
	ret	4
??_ENormalSceneRenderer@Ogre@@UAEPAXI@Z ENDP		; Ogre::NormalSceneRenderer::`vector deleting destructor'
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0CameraShakeSource@NormalSceneRenderer@Ogre@@QAE@ABU012@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0CameraShakeSource@NormalSceneRenderer@Ogre@@QAE@ABU012@@Z PROC ; Ogre::NormalSceneRenderer::CameraShakeSource::CameraShakeSource, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0Vector3@Ogre@@QAE@ABV01@@Z		; Ogre::Vector3::Vector3
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	fld	DWORD PTR [edx+12]
	fstp	DWORD PTR [ecx+12]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	fld	DWORD PTR [ecx+16]
	fstp	DWORD PTR [eax+16]
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0CameraShakeSource@NormalSceneRenderer@Ogre@@QAE@ABU012@@Z ENDP ; Ogre::NormalSceneRenderer::CameraShakeSource::CameraShakeSource
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??4CameraShakeSource@NormalSceneRenderer@Ogre@@QAEAAU012@ABU012@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4CameraShakeSource@NormalSceneRenderer@Ogre@@QAEAAU012@ABU012@@Z PROC ; Ogre::NormalSceneRenderer::CameraShakeSource::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4Vector3@Ogre@@QAEABV01@ABV01@@Z	; Ogre::Vector3::operator=
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	fld	DWORD PTR [edx+12]
	fstp	DWORD PTR [ecx+12]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	fld	DWORD PTR [ecx+16]
	fstp	DWORD PTR [eax+16]
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4CameraShakeSource@NormalSceneRenderer@Ogre@@QAEAAU012@ABU012@@Z ENDP ; Ogre::NormalSceneRenderer::CameraShakeSource::operator=
_TEXT	ENDS
PUBLIC	?getRTTI@Material@Ogre@@UBEPBVRuntimeClass@2@XZ	; Ogre::Material::getRTTI
EXTRN	?m_RTTI@Material@Ogre@@2VRuntimeClass@2@B:BYTE	; Ogre::Material::m_RTTI
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogrematerial.h
;	COMDAT ?getRTTI@Material@Ogre@@UBEPBVRuntimeClass@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getRTTI@Material@Ogre@@UBEPBVRuntimeClass@2@XZ PROC	; Ogre::Material::getRTTI, COMDAT
; _this$ = ecx

; 57   : 		DECLARE_RTTI(Material)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, OFFSET ?m_RTTI@Material@Ogre@@2VRuntimeClass@2@B ; Ogre::Material::m_RTTI
	mov	esp, ebp
	pop	ebp
	ret	0
?getRTTI@Material@Ogre@@UBEPBVRuntimeClass@2@XZ ENDP	; Ogre::Material::getRTTI
_TEXT	ENDS
PUBLIC	?newObject@Material@Ogre@@SAPAVBaseObject@2@XZ	; Ogre::Material::newObject
EXTRN	??0Material@Ogre@@QAE@XZ:PROC			; Ogre::Material::Material
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?newObject@Material@Ogre@@SAPAVBaseObject@2@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?newObject@Material@Ogre@@SAPAVBaseObject@2@XZ$0
__ehfuncinfo$?newObject@Material@Ogre@@SAPAVBaseObject@2@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?newObject@Material@Ogre@@SAPAVBaseObject@2@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?newObject@Material@Ogre@@SAPAVBaseObject@2@XZ
_TEXT	SEGMENT
tv75 = -24						; size = 4
$T94229 = -20						; size = 4
$T94228 = -16						; size = 4
__$EHRec$ = -12						; size = 12
?newObject@Material@Ogre@@SAPAVBaseObject@2@XZ PROC	; Ogre::Material::newObject, COMDAT

; 57   : 		DECLARE_RTTI(Material)

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?newObject@Material@Ogre@@SAPAVBaseObject@2@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 12					; 0000000cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	push	56					; 00000038H
	call	??2MemoryDelegation@Ogre@@SAPAXI@Z	; Ogre::MemoryDelegation::operator new
	add	esp, 4
	mov	DWORD PTR $T94229[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T94229[ebp], 0
	je	SHORT $LN3@newObject@3
	mov	ecx, DWORD PTR $T94229[ebp]
	call	??0Material@Ogre@@QAE@XZ		; Ogre::Material::Material
	mov	DWORD PTR tv75[ebp], eax
	jmp	SHORT $LN4@newObject@3
$LN3@newObject@3:
	mov	DWORD PTR tv75[ebp], 0
$LN4@newObject@3:
	mov	eax, DWORD PTR tv75[ebp]
	mov	DWORD PTR $T94228[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR $T94228[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?newObject@Material@Ogre@@SAPAVBaseObject@2@XZ$0:
	push	56					; 00000038H
	mov	eax, DWORD PTR $T94229[ebp]
	push	eax
	call	??3MemoryDelegation@Ogre@@SAXPAXI@Z	; Ogre::MemoryDelegation::operator delete
	add	esp, 8
	ret	0
__ehhandler$?newObject@Material@Ogre@@SAPAVBaseObject@2@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?newObject@Material@Ogre@@SAPAVBaseObject@2@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?newObject@Material@Ogre@@SAPAVBaseObject@2@XZ ENDP	; Ogre::Material::newObject
PUBLIC	?getName@Material@Ogre@@QAEAAVFixedString@2@XZ	; Ogre::Material::getName
; Function compile flags: /Odtp
;	COMDAT ?getName@Material@Ogre@@QAEAAVFixedString@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getName@Material@Ogre@@QAEAAVFixedString@2@XZ PROC	; Ogre::Material::getName, COMDAT
; _this$ = ecx

; 66   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 67   : 			return m_MtlName;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 16					; 00000010H

; 68   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?getName@Material@Ogre@@QAEAAVFixedString@2@XZ ENDP	; Ogre::Material::getName
_TEXT	ENDS
PUBLIC	?getMtlTemplate@Material@Ogre@@QAEPAVMaterialTemplate@2@XZ ; Ogre::Material::getMtlTemplate
; Function compile flags: /Odtp
;	COMDAT ?getMtlTemplate@Material@Ogre@@QAEPAVMaterialTemplate@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getMtlTemplate@Material@Ogre@@QAEPAVMaterialTemplate@2@XZ PROC ; Ogre::Material::getMtlTemplate, COMDAT
; _this$ = ecx

; 71   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 72   : 			return m_pMtlTemplate;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+24]

; 73   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?getMtlTemplate@Material@Ogre@@QAEPAVMaterialTemplate@2@XZ ENDP ; Ogre::Material::getMtlTemplate
_TEXT	ENDS
PUBLIC	?setReplaceDiffuseTex@Material@Ogre@@QAEX_N@Z	; Ogre::Material::setReplaceDiffuseTex
; Function compile flags: /Odtp
;	COMDAT ?setReplaceDiffuseTex@Material@Ogre@@QAEX_N@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_bReplace$ = 8						; size = 1
?setReplaceDiffuseTex@Material@Ogre@@QAEX_N@Z PROC	; Ogre::Material::setReplaceDiffuseTex, COMDAT
; _this$ = ecx

; 77   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 78   : 			m_bNeedRelpaceDiffuseTexture = bReplace;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR _bReplace$[ebp]
	mov	BYTE PTR [eax+29], cl

; 79   : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?setReplaceDiffuseTex@Material@Ogre@@QAEX_N@Z ENDP	; Ogre::Material::setReplaceDiffuseTex
_TEXT	ENDS
PUBLIC	?needReplaceDiffuseTexture@Material@Ogre@@QAE_NXZ ; Ogre::Material::needReplaceDiffuseTexture
; Function compile flags: /Odtp
;	COMDAT ?needReplaceDiffuseTexture@Material@Ogre@@QAE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?needReplaceDiffuseTexture@Material@Ogre@@QAE_NXZ PROC	; Ogre::Material::needReplaceDiffuseTexture, COMDAT
; _this$ = ecx

; 82   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 83   : 			return m_bNeedRelpaceDiffuseTexture;

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+29]

; 84   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?needReplaceDiffuseTexture@Material@Ogre@@QAE_NXZ ENDP	; Ogre::Material::needReplaceDiffuseTexture
_TEXT	ENDS
PUBLIC	?isTransparent@Material@Ogre@@QAE_NXZ		; Ogre::Material::isTransparent
; Function compile flags: /Odtp
;	COMDAT ?isTransparent@Material@Ogre@@QAE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?isTransparent@Material@Ogre@@QAE_NXZ PROC		; Ogre::Material::isTransparent, COMDAT
; _this$ = ecx

; 100  : 		bool isTransparent () { return m_bTransparent; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+28]
	mov	esp, ebp
	pop	ebp
	ret	0
?isTransparent@Material@Ogre@@QAE_NXZ ENDP		; Ogre::Material::isTransparent
_TEXT	ENDS
PUBLIC	??4?$vector@PAVMaterialParam@Ogre@@V?$allocator@PAVMaterialParam@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<Ogre::MaterialParam *,std::allocator<Ogre::MaterialParam *> >::operator=
PUBLIC	??4Material@Ogre@@QAEAAV01@ABV01@@Z		; Ogre::Material::operator=
; Function compile flags: /Odtp
;	COMDAT ??4Material@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4Material@Ogre@@QAEAAV01@ABV01@@Z PROC		; Ogre::Material::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4Resource@Ogre@@QAEAAV01@ABV01@@Z
	mov	ecx, DWORD PTR ___that$[ebp]
	add	ecx, 16					; 00000010H
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??4FixedString@Ogre@@QAEAAV01@ABV01@@Z	; Ogre::FixedString::operator=
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 20					; 00000014H
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 20					; 00000014H
	call	??4FixedString@Ogre@@QAEAAV01@ABV01@@Z	; Ogre::FixedString::operator=
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR [eax+24], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	dl, BYTE PTR [ecx+28]
	mov	BYTE PTR [eax+28], dl
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	dl, BYTE PTR [ecx+29]
	mov	BYTE PTR [eax+29], dl
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 32					; 00000020H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??4?$vector@PAVMaterialParam@Ogre@@V?$allocator@PAVMaterialParam@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<Ogre::MaterialParam *,std::allocator<Ogre::MaterialParam *> >::operator=
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4Material@Ogre@@QAEAAV01@ABV01@@Z ENDP		; Ogre::Material::operator=
_TEXT	ENDS
PUBLIC	??0?$TBox@H@Ogre@@QAE@XZ			; Ogre::TBox<int>::TBox<int>
PUBLIC	??0PixelBox@Ogre@@QAE@XZ			; Ogre::PixelBox::PixelBox
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogrepixelformat.h
;	COMDAT ??0PixelBox@Ogre@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0PixelBox@Ogre@@QAE@XZ PROC				; Ogre::PixelBox::PixelBox, COMDAT
; _this$ = ecx

; 183  : 		PixelBox() {}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$TBox@H@Ogre@@QAE@XZ		; Ogre::TBox<int>::TBox<int>
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0PixelBox@Ogre@@QAE@XZ ENDP				; Ogre::PixelBox::PixelBox
_TEXT	ENDS
PUBLIC	?setConsecutive@PixelBox@Ogre@@QAEXXZ		; Ogre::PixelBox::setConsecutive
PUBLIC	??0PixelBox@Ogre@@QAE@ABV?$TBox@H@1@W4PixelFormat@1@PAX@Z ; Ogre::PixelBox::PixelBox
; Function compile flags: /Odtp
;	COMDAT ??0PixelBox@Ogre@@QAE@ABV?$TBox@H@1@W4PixelFormat@1@PAX@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_extents$ = 8						; size = 4
_pixelFormat$ = 12					; size = 4
_pixelData$ = 16					; size = 4
??0PixelBox@Ogre@@QAE@ABV?$TBox@H@1@W4PixelFormat@1@PAX@Z PROC ; Ogre::PixelBox::PixelBox, COMDAT
; _this$ = ecx

; 193  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _extents$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], edx
	mov	edx, DWORD PTR [eax+16]
	mov	DWORD PTR [ecx+16], edx
	mov	eax, DWORD PTR [eax+20]
	mov	DWORD PTR [ecx+20], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _pixelData$[ebp]
	mov	DWORD PTR [ecx+24], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pixelFormat$[ebp]
	mov	DWORD PTR [eax+28], ecx

; 194  : 			setConsecutive();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?setConsecutive@PixelBox@Ogre@@QAEXXZ	; Ogre::PixelBox::setConsecutive

; 195  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??0PixelBox@Ogre@@QAE@ABV?$TBox@H@1@W4PixelFormat@1@PAX@Z ENDP ; Ogre::PixelBox::PixelBox
_TEXT	ENDS
PUBLIC	??0?$TBox@H@Ogre@@QAE@HHHHHH@Z			; Ogre::TBox<int>::TBox<int>
PUBLIC	??0PixelBox@Ogre@@QAE@IIIW4PixelFormat@1@PAX@Z	; Ogre::PixelBox::PixelBox
; Function compile flags: /Odtp
;	COMDAT ??0PixelBox@Ogre@@QAE@IIIW4PixelFormat@1@PAX@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_width$ = 8						; size = 4
_height$ = 12						; size = 4
_depth$ = 16						; size = 4
_pixelFormat$ = 20					; size = 4
_pixelData$ = 24					; size = 4
??0PixelBox@Ogre@@QAE@IIIW4PixelFormat@1@PAX@Z PROC	; Ogre::PixelBox::PixelBox, COMDAT
; _this$ = ecx

; 208  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _depth$[ebp]
	push	eax
	mov	ecx, DWORD PTR _height$[ebp]
	push	ecx
	mov	edx, DWORD PTR _width$[ebp]
	push	edx
	push	0
	push	0
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$TBox@H@Ogre@@QAE@HHHHHH@Z		; Ogre::TBox<int>::TBox<int>
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pixelData$[ebp]
	mov	DWORD PTR [eax+24], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _pixelFormat$[ebp]
	mov	DWORD PTR [edx+28], eax

; 209  : 			setConsecutive();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?setConsecutive@PixelBox@Ogre@@QAEXXZ	; Ogre::PixelBox::setConsecutive

; 210  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
??0PixelBox@Ogre@@QAE@IIIW4PixelFormat@1@PAX@Z ENDP	; Ogre::PixelBox::PixelBox
_TEXT	ENDS
PUBLIC	?getHeight@?$TBox@H@Ogre@@QBEHXZ		; Ogre::TBox<int>::getHeight
PUBLIC	?getWidth@?$TBox@H@Ogre@@QBEHXZ			; Ogre::TBox<int>::getWidth
; Function compile flags: /Odtp
;	COMDAT ?setConsecutive@PixelBox@Ogre@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?setConsecutive@PixelBox@Ogre@@QAEXXZ PROC		; Ogre::PixelBox::setConsecutive, COMDAT
; _this$ = ecx

; 232  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 233  : 			rowPitch = getWidth();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?getWidth@?$TBox@H@Ogre@@QBEHXZ		; Ogre::TBox<int>::getWidth
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+32], eax

; 234  : 			slicePitch = getWidth()*getHeight();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?getWidth@?$TBox@H@Ogre@@QBEHXZ		; Ogre::TBox<int>::getWidth
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getHeight@?$TBox@H@Ogre@@QBEHXZ	; Ogre::TBox<int>::getHeight
	imul	esi, eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+36], esi

; 235  : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?setConsecutive@PixelBox@Ogre@@QAEXXZ ENDP		; Ogre::PixelBox::setConsecutive
_TEXT	ENDS
PUBLIC	?getRowSkip@PixelBox@Ogre@@QBEIXZ		; Ogre::PixelBox::getRowSkip
; Function compile flags: /Odtp
;	COMDAT ?getRowSkip@PixelBox@Ogre@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getRowSkip@PixelBox@Ogre@@QBEIXZ PROC			; Ogre::PixelBox::getRowSkip, COMDAT
; _this$ = ecx

; 240  : 		size_t getRowSkip() const { return rowPitch - getWidth(); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getWidth@?$TBox@H@Ogre@@QBEHXZ		; Ogre::TBox<int>::getWidth
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	sub	edx, eax
	mov	eax, edx
	mov	esp, ebp
	pop	ebp
	ret	0
?getRowSkip@PixelBox@Ogre@@QBEIXZ ENDP			; Ogre::PixelBox::getRowSkip
_TEXT	ENDS
PUBLIC	?getSliceSkip@PixelBox@Ogre@@QBEIXZ		; Ogre::PixelBox::getSliceSkip
; Function compile flags: /Odtp
;	COMDAT ?getSliceSkip@PixelBox@Ogre@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getSliceSkip@PixelBox@Ogre@@QBEIXZ PROC		; Ogre::PixelBox::getSliceSkip, COMDAT
; _this$ = ecx

; 245  : 		size_t getSliceSkip() const { return slicePitch - (getHeight() * rowPitch); }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getHeight@?$TBox@H@Ogre@@QBEHXZ	; Ogre::TBox<int>::getHeight
	mov	ecx, DWORD PTR _this$[ebp]
	imul	eax, DWORD PTR [ecx+32]
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+36]
	sub	ecx, eax
	mov	eax, ecx
	mov	esp, ebp
	pop	ebp
	ret	0
?getSliceSkip@PixelBox@Ogre@@QBEIXZ ENDP		; Ogre::PixelBox::getSliceSkip
_TEXT	ENDS
PUBLIC	?isConsecutive@PixelBox@Ogre@@QBE_NXZ		; Ogre::PixelBox::isConsecutive
; Function compile flags: /Odtp
;	COMDAT ?isConsecutive@PixelBox@Ogre@@QBE_NXZ
_TEXT	SEGMENT
tv87 = -8						; size = 4
_this$ = -4						; size = 4
?isConsecutive@PixelBox@Ogre@@QBE_NXZ PROC		; Ogre::PixelBox::isConsecutive, COMDAT
; _this$ = ecx

; 251  : 		{ 

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 252  : 			return rowPitch == getWidth() && slicePitch == getWidth()*getHeight(); 

	mov	ecx, DWORD PTR _this$[ebp]
	call	?getWidth@?$TBox@H@Ogre@@QBEHXZ		; Ogre::TBox<int>::getWidth
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+32], eax
	jne	SHORT $LN3@isConsecut
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getWidth@?$TBox@H@Ogre@@QBEHXZ		; Ogre::TBox<int>::getWidth
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getHeight@?$TBox@H@Ogre@@QBEHXZ	; Ogre::TBox<int>::getHeight
	imul	esi, eax
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+36], esi
	jne	SHORT $LN3@isConsecut
	mov	DWORD PTR tv87[ebp], 1
	jmp	SHORT $LN4@isConsecut
$LN3@isConsecut:
	mov	DWORD PTR tv87[ebp], 0
$LN4@isConsecut:
	mov	al, BYTE PTR tv87[ebp]

; 253  : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?isConsecutive@PixelBox@Ogre@@QBE_NXZ ENDP		; Ogre::PixelBox::isConsecutive
_TEXT	ENDS
PUBLIC	??4?$TBox@H@Ogre@@QAEAAV01@ABV01@@Z		; Ogre::TBox<int>::operator=
; Function compile flags: /Odtp
;	COMDAT ??4?$TBox@H@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4?$TBox@H@Ogre@@QAEAAV01@ABV01@@Z PROC		; Ogre::TBox<int>::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], edx
	mov	edx, DWORD PTR [eax+16]
	mov	DWORD PTR [ecx+16], edx
	mov	eax, DWORD PTR [eax+20]
	mov	DWORD PTR [ecx+20], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4?$TBox@H@Ogre@@QAEAAV01@ABV01@@Z ENDP		; Ogre::TBox<int>::operator=
_TEXT	ENDS
PUBLIC	??4PixelBox@Ogre@@QAEAAV01@ABV01@@Z		; Ogre::PixelBox::operator=
; Function compile flags: /Odtp
;	COMDAT ??4PixelBox@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4PixelBox@Ogre@@QAEAAV01@ABV01@@Z PROC		; Ogre::PixelBox::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	esi, DWORD PTR ___that$[ebp]
	mov	ecx, 10					; 0000000aH
	mov	edi, DWORD PTR _this$[ebp]
	rep movsd
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
??4PixelBox@Ogre@@QAEAAV01@ABV01@@Z ENDP		; Ogre::PixelBox::operator=
_TEXT	ENDS
PUBLIC	??4PixelUtil@Ogre@@QAEAAV01@ABV01@@Z		; Ogre::PixelUtil::operator=
; Function compile flags: /Odtp
;	COMDAT ??4PixelUtil@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4PixelUtil@Ogre@@QAEAAV01@ABV01@@Z PROC		; Ogre::PixelUtil::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4PixelUtil@Ogre@@QAEAAV01@ABV01@@Z ENDP		; Ogre::PixelUtil::operator=
_TEXT	ENDS
PUBLIC	??4LockSection@Ogre@@QAEAAV01@ABV01@@Z		; Ogre::LockSection::operator=
; Function compile flags: /Odtp
;	COMDAT ??4LockSection@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4LockSection@Ogre@@QAEAAV01@ABV01@@Z PROC		; Ogre::LockSection::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4LockSection@Ogre@@QAEAAV01@ABV01@@Z ENDP		; Ogre::LockSection::operator=
_TEXT	ENDS
PUBLIC	??0LockFunctor@Ogre@@QAE@PAVLockSection@1@@Z	; Ogre::LockFunctor::LockFunctor
EXTRN	?Lock@LockSection@Ogre@@QAEXXZ:PROC		; Ogre::LockSection::Lock
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogrelocker.h
;	COMDAT ??0LockFunctor@Ogre@@QAE@PAVLockSection@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pSection$ = 8						; size = 4
??0LockFunctor@Ogre@@QAE@PAVLockSection@1@@Z PROC	; Ogre::LockFunctor::LockFunctor, COMDAT
; _this$ = ecx

; 26   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pSection$[ebp]
	mov	DWORD PTR [eax], ecx

; 27   : 			if(m_pSection == NULL) return;

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx], 0
	jne	SHORT $LN1@LockFuncto
	jmp	SHORT $LN2@LockFuncto
$LN1@LockFuncto:

; 28   : 			assert( m_pSection );
; 29   : 			m_pSection->Lock();

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?Lock@LockSection@Ogre@@QAEXXZ		; Ogre::LockSection::Lock
$LN2@LockFuncto:

; 30   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0LockFunctor@Ogre@@QAE@PAVLockSection@1@@Z ENDP	; Ogre::LockFunctor::LockFunctor
_TEXT	ENDS
PUBLIC	??1LockFunctor@Ogre@@QAE@XZ			; Ogre::LockFunctor::~LockFunctor
EXTRN	?Unlock@LockSection@Ogre@@QAEXXZ:PROC		; Ogre::LockSection::Unlock
; Function compile flags: /Odtp
;	COMDAT ??1LockFunctor@Ogre@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1LockFunctor@Ogre@@QAE@XZ PROC			; Ogre::LockFunctor::~LockFunctor, COMDAT
; _this$ = ecx

; 33   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 34   : 			if( m_pSection )

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN2@LockFuncto@2

; 35   : 			{
; 36   : 				m_pSection->Unlock();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?Unlock@LockSection@Ogre@@QAEXXZ	; Ogre::LockSection::Unlock
$LN2@LockFuncto@2:

; 37   : 			}			
; 38   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??1LockFunctor@Ogre@@QAE@XZ ENDP			; Ogre::LockFunctor::~LockFunctor
_TEXT	ENDS
PUBLIC	??4LockFunctor@Ogre@@QAEAAV01@ABV01@@Z		; Ogre::LockFunctor::operator=
; Function compile flags: /Odtp
;	COMDAT ??4LockFunctor@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4LockFunctor@Ogre@@QAEAAV01@ABV01@@Z PROC		; Ogre::LockFunctor::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4LockFunctor@Ogre@@QAEAAV01@ABV01@@Z ENDP		; Ogre::LockFunctor::operator=
_TEXT	ENDS
PUBLIC	?getRTTI@SurfaceData@Ogre@@UBEPBVRuntimeClass@2@XZ ; Ogre::SurfaceData::getRTTI
EXTRN	?m_RTTI@SurfaceData@Ogre@@2VRuntimeClass@2@B:BYTE ; Ogre::SurfaceData::m_RTTI
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogretexture.h
;	COMDAT ?getRTTI@SurfaceData@Ogre@@UBEPBVRuntimeClass@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getRTTI@SurfaceData@Ogre@@UBEPBVRuntimeClass@2@XZ PROC	; Ogre::SurfaceData::getRTTI, COMDAT
; _this$ = ecx

; 32   : 		DECLARE_RTTI(SurfaceData)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, OFFSET ?m_RTTI@SurfaceData@Ogre@@2VRuntimeClass@2@B ; Ogre::SurfaceData::m_RTTI
	mov	esp, ebp
	pop	ebp
	ret	0
?getRTTI@SurfaceData@Ogre@@UBEPBVRuntimeClass@2@XZ ENDP	; Ogre::SurfaceData::getRTTI
_TEXT	ENDS
PUBLIC	?newObject@SurfaceData@Ogre@@SAPAVBaseObject@2@XZ ; Ogre::SurfaceData::newObject
EXTRN	??0SurfaceData@Ogre@@QAE@XZ:PROC		; Ogre::SurfaceData::SurfaceData
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?newObject@SurfaceData@Ogre@@SAPAVBaseObject@2@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?newObject@SurfaceData@Ogre@@SAPAVBaseObject@2@XZ$0
__ehfuncinfo$?newObject@SurfaceData@Ogre@@SAPAVBaseObject@2@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?newObject@SurfaceData@Ogre@@SAPAVBaseObject@2@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?newObject@SurfaceData@Ogre@@SAPAVBaseObject@2@XZ
_TEXT	SEGMENT
tv75 = -24						; size = 4
$T94286 = -20						; size = 4
$T94285 = -16						; size = 4
__$EHRec$ = -12						; size = 12
?newObject@SurfaceData@Ogre@@SAPAVBaseObject@2@XZ PROC	; Ogre::SurfaceData::newObject, COMDAT

; 32   : 		DECLARE_RTTI(SurfaceData)

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?newObject@SurfaceData@Ogre@@SAPAVBaseObject@2@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 12					; 0000000cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	push	60					; 0000003cH
	call	??2MemoryDelegation@Ogre@@SAPAXI@Z	; Ogre::MemoryDelegation::operator new
	add	esp, 4
	mov	DWORD PTR $T94286[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T94286[ebp], 0
	je	SHORT $LN3@newObject@4
	mov	ecx, DWORD PTR $T94286[ebp]
	call	??0SurfaceData@Ogre@@QAE@XZ		; Ogre::SurfaceData::SurfaceData
	mov	DWORD PTR tv75[ebp], eax
	jmp	SHORT $LN4@newObject@4
$LN3@newObject@4:
	mov	DWORD PTR tv75[ebp], 0
$LN4@newObject@4:
	mov	eax, DWORD PTR tv75[ebp]
	mov	DWORD PTR $T94285[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR $T94285[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?newObject@SurfaceData@Ogre@@SAPAVBaseObject@2@XZ$0:
	push	60					; 0000003cH
	mov	eax, DWORD PTR $T94286[ebp]
	push	eax
	call	??3MemoryDelegation@Ogre@@SAXPAXI@Z	; Ogre::MemoryDelegation::operator delete
	add	esp, 8
	ret	0
__ehhandler$?newObject@SurfaceData@Ogre@@SAPAVBaseObject@2@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?newObject@SurfaceData@Ogre@@SAPAVBaseObject@2@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?newObject@SurfaceData@Ogre@@SAPAVBaseObject@2@XZ ENDP	; Ogre::SurfaceData::newObject
PUBLIC	??A?$vector@DV?$allocator@D@std@@@std@@QAEAADI@Z ; std::vector<char,std::allocator<char> >::operator[]
PUBLIC	?getBits@SurfaceData@Ogre@@QAEPAXXZ		; Ogre::SurfaceData::getBits
; Function compile flags: /Odtp
;	COMDAT ?getBits@SurfaceData@Ogre@@QAEPAXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getBits@SurfaceData@Ogre@@QAEPAXXZ PROC		; Ogre::SurfaceData::getBits, COMDAT
; _this$ = ecx

; 38   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 39   : 			return &m_Pixels[0];

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??A?$vector@DV?$allocator@D@std@@@std@@QAEAADI@Z ; std::vector<char,std::allocator<char> >::operator[]

; 40   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?getBits@SurfaceData@Ogre@@QAEPAXXZ ENDP		; Ogre::SurfaceData::getBits
_TEXT	ENDS
PUBLIC	??1?$vector@DV?$allocator@D@std@@@std@@QAE@XZ	; std::vector<char,std::allocator<char> >::~vector<char,std::allocator<char> >
PUBLIC	??1SurfaceData@Ogre@@UAE@XZ			; Ogre::SurfaceData::~SurfaceData
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1SurfaceData@Ogre@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1SurfaceData@Ogre@@UAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1SurfaceData@Ogre@@UAE@XZ$1
__ehfuncinfo$??1SurfaceData@Ogre@@UAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??1SurfaceData@Ogre@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1SurfaceData@Ogre@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1SurfaceData@Ogre@@UAE@XZ PROC			; Ogre::SurfaceData::~SurfaceData, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1SurfaceData@Ogre@@UAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??1?$vector@DV?$allocator@D@std@@@std@@QAE@XZ ; std::vector<char,std::allocator<char> >::~vector<char,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1BaseObject@Ogre@@MAE@XZ		; Ogre::BaseObject::~BaseObject
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1SurfaceData@Ogre@@UAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1BaseObject@Ogre@@MAE@XZ		; Ogre::BaseObject::~BaseObject
__unwindfunclet$??1SurfaceData@Ogre@@UAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	jmp	??1?$vector@DV?$allocator@D@std@@@std@@QAE@XZ ; std::vector<char,std::allocator<char> >::~vector<char,std::allocator<char> >
__ehhandler$??1SurfaceData@Ogre@@UAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1SurfaceData@Ogre@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1SurfaceData@Ogre@@UAE@XZ ENDP			; Ogre::SurfaceData::~SurfaceData
PUBLIC	??0?$vector@DV?$allocator@D@std@@@std@@QAE@ABV01@@Z ; std::vector<char,std::allocator<char> >::vector<char,std::allocator<char> >
PUBLIC	??_7SurfaceData@Ogre@@6B@			; Ogre::SurfaceData::`vftable'
PUBLIC	??0SurfaceData@Ogre@@QAE@ABV01@@Z		; Ogre::SurfaceData::SurfaceData
PUBLIC	??_R4SurfaceData@Ogre@@6B@			; Ogre::SurfaceData::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVSurfaceData@Ogre@@@8			; Ogre::SurfaceData `RTTI Type Descriptor'
PUBLIC	??_R3SurfaceData@Ogre@@8			; Ogre::SurfaceData::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2SurfaceData@Ogre@@8			; Ogre::SurfaceData::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@SurfaceData@Ogre@@8		; Ogre::SurfaceData::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_ESurfaceData@Ogre@@UAEPAXI@Z			; Ogre::SurfaceData::`vector deleting destructor'
EXTRN	?_serialize@SurfaceData@Ogre@@EAEXAAVArchive@2@H@Z:PROC ; Ogre::SurfaceData::_serialize
;	COMDAT ??_R1A@?0A@EA@SurfaceData@Ogre@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@SurfaceData@Ogre@@8 DD FLAT:??_R0?AVSurfaceData@Ogre@@@8 ; Ogre::SurfaceData::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3SurfaceData@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R2SurfaceData@Ogre@@8
rdata$r	SEGMENT
??_R2SurfaceData@Ogre@@8 DD FLAT:??_R1A@?0A@EA@SurfaceData@Ogre@@8 ; Ogre::SurfaceData::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@BaseObject@Ogre@@8
	DD	FLAT:??_R13?0A@EA@MemoryDelegation@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R3SurfaceData@Ogre@@8
rdata$r	SEGMENT
??_R3SurfaceData@Ogre@@8 DD 00H				; Ogre::SurfaceData::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2SurfaceData@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVSurfaceData@Ogre@@@8
_DATA	SEGMENT
??_R0?AVSurfaceData@Ogre@@@8 DD FLAT:??_7type_info@@6B@	; Ogre::SurfaceData `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVSurfaceData@Ogre@@', 00H
_DATA	ENDS
;	COMDAT ??_R4SurfaceData@Ogre@@6B@
rdata$r	SEGMENT
??_R4SurfaceData@Ogre@@6B@ DD 00H			; Ogre::SurfaceData::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVSurfaceData@Ogre@@@8
	DD	FLAT:??_R3SurfaceData@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_7SurfaceData@Ogre@@6B@
CONST	SEGMENT
??_7SurfaceData@Ogre@@6B@ DD FLAT:??_R4SurfaceData@Ogre@@6B@ ; Ogre::SurfaceData::`vftable'
	DD	FLAT:?getRTTI@SurfaceData@Ogre@@UBEPBVRuntimeClass@2@XZ
	DD	FLAT:?release@BaseObject@Ogre@@UAEXXZ
	DD	FLAT:?addRef@BaseObject@Ogre@@UAEXXZ
	DD	FLAT:?getRefCount@BaseObject@Ogre@@UAEHXZ
	DD	FLAT:?_serialize@SurfaceData@Ogre@@EAEXAAVArchive@2@H@Z
	DD	FLAT:??_ESurfaceData@Ogre@@UAEPAXI@Z
	DD	FLAT:?deleteThis@BaseObject@Ogre@@MAEXXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0SurfaceData@Ogre@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0SurfaceData@Ogre@@QAE@ABV01@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0SurfaceData@Ogre@@QAE@ABV01@@Z$1
__ehfuncinfo$??0SurfaceData@Ogre@@QAE@ABV01@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0SurfaceData@Ogre@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0SurfaceData@Ogre@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0SurfaceData@Ogre@@QAE@ABV01@@Z PROC			; Ogre::SurfaceData::SurfaceData, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0SurfaceData@Ogre@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0BaseObject@Ogre@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7SurfaceData@Ogre@@6B@
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR [edx+8], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [edx+12], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR [edx+16], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR [edx+20], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR [edx+24], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	DWORD PTR [edx+28], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	DWORD PTR [edx+32], ecx
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 36					; 00000024H
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??0?$vector@DV?$allocator@D@std@@@std@@QAE@ABV01@@Z ; std::vector<char,std::allocator<char> >::vector<char,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0SurfaceData@Ogre@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1BaseObject@Ogre@@MAE@XZ		; Ogre::BaseObject::~BaseObject
__unwindfunclet$??0SurfaceData@Ogre@@QAE@ABV01@@Z$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	jmp	??1?$vector@DV?$allocator@D@std@@@std@@QAE@XZ ; std::vector<char,std::allocator<char> >::~vector<char,std::allocator<char> >
__ehhandler$??0SurfaceData@Ogre@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0SurfaceData@Ogre@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0SurfaceData@Ogre@@QAE@ABV01@@Z ENDP			; Ogre::SurfaceData::SurfaceData
PUBLIC	??4?$vector@DV?$allocator@D@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<char,std::allocator<char> >::operator=
PUBLIC	??4SurfaceData@Ogre@@QAEAAV01@ABV01@@Z		; Ogre::SurfaceData::operator=
; Function compile flags: /Odtp
;	COMDAT ??4SurfaceData@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4SurfaceData@Ogre@@QAEAAV01@ABV01@@Z PROC		; Ogre::SurfaceData::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4BaseObject@Ogre@@QAEAAV01@ABV01@@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+8], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR [ecx+12], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR [ecx+16], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	DWORD PTR [ecx+20], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR [ecx+24], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+28]
	mov	DWORD PTR [ecx+28], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	DWORD PTR [ecx+32], eax
	mov	ecx, DWORD PTR ___that$[ebp]
	add	ecx, 36					; 00000024H
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??4?$vector@DV?$allocator@D@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<char,std::allocator<char> >::operator=
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4SurfaceData@Ogre@@QAEAAV01@ABV01@@Z ENDP		; Ogre::SurfaceData::operator=
_TEXT	ENDS
PUBLIC	??_GSurfaceData@Ogre@@UAEPAXI@Z			; Ogre::SurfaceData::`scalar deleting destructor'
; Function compile flags: /Odtp
;	COMDAT ??_GSurfaceData@Ogre@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GSurfaceData@Ogre@@UAEPAXI@Z PROC			; Ogre::SurfaceData::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1SurfaceData@Ogre@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@22
	push	60					; 0000003cH
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3MemoryDelegation@Ogre@@SAXPAXI@Z	; Ogre::MemoryDelegation::operator delete
	add	esp, 8
$LN1@scalar@22:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GSurfaceData@Ogre@@UAEPAXI@Z ENDP			; Ogre::SurfaceData::`scalar deleting destructor'
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_ESurfaceData@Ogre@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_ESurfaceData@Ogre@@UAEPAXI@Z PROC			; Ogre::SurfaceData::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 2
	je	SHORT $LN3@vector@20
	push	OFFSET ??1SurfaceData@Ogre@@UAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx-4]
	push	edx
	push	60					; 0000003cH
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??_M@YGXPAXIHP6EX0@Z@Z
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN2@vector@20
	push	60					; 0000003cH
	mov	edx, DWORD PTR _this$[ebp]
	sub	edx, 4
	push	edx
	call	??_VMemoryDelegation@Ogre@@SAXPAXI@Z	; Ogre::MemoryDelegation::operator delete[]
	add	esp, 8
$LN2@vector@20:
	mov	eax, DWORD PTR _this$[ebp]
	sub	eax, 4
	jmp	SHORT $LN4@vector@20
$LN3@vector@20:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1SurfaceData@Ogre@@UAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@vector@20
	push	60					; 0000003cH
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3MemoryDelegation@Ogre@@SAXPAXI@Z	; Ogre::MemoryDelegation::operator delete
	add	esp, 8
$LN1@vector@20:
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector@20:
	mov	esp, ebp
	pop	ebp
	ret	4
??_ESurfaceData@Ogre@@UAEPAXI@Z ENDP			; Ogre::SurfaceData::`vector deleting destructor'
_TEXT	ENDS
PUBLIC	?getRTTI@DummyTexture@Ogre@@UBEPBVRuntimeClass@2@XZ ; Ogre::DummyTexture::getRTTI
EXTRN	?m_RTTI@DummyTexture@Ogre@@2VRuntimeClass@2@B:BYTE ; Ogre::DummyTexture::m_RTTI
; Function compile flags: /Odtp
;	COMDAT ?getRTTI@DummyTexture@Ogre@@UBEPBVRuntimeClass@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getRTTI@DummyTexture@Ogre@@UBEPBVRuntimeClass@2@XZ PROC ; Ogre::DummyTexture::getRTTI, COMDAT
; _this$ = ecx

; 64   : 		DECLARE_RTTI(DummyTexture)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, OFFSET ?m_RTTI@DummyTexture@Ogre@@2VRuntimeClass@2@B ; Ogre::DummyTexture::m_RTTI
	mov	esp, ebp
	pop	ebp
	ret	0
?getRTTI@DummyTexture@Ogre@@UBEPBVRuntimeClass@2@XZ ENDP ; Ogre::DummyTexture::getRTTI
_TEXT	ENDS
PUBLIC	??0DummyTexture@Ogre@@QAE@XZ			; Ogre::DummyTexture::DummyTexture
PUBLIC	?newObject@DummyTexture@Ogre@@SAPAVBaseObject@2@XZ ; Ogre::DummyTexture::newObject
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?newObject@DummyTexture@Ogre@@SAPAVBaseObject@2@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?newObject@DummyTexture@Ogre@@SAPAVBaseObject@2@XZ$0
__ehfuncinfo$?newObject@DummyTexture@Ogre@@SAPAVBaseObject@2@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?newObject@DummyTexture@Ogre@@SAPAVBaseObject@2@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?newObject@DummyTexture@Ogre@@SAPAVBaseObject@2@XZ
_TEXT	SEGMENT
tv75 = -24						; size = 4
$T94329 = -20						; size = 4
$T94328 = -16						; size = 4
__$EHRec$ = -12						; size = 12
?newObject@DummyTexture@Ogre@@SAPAVBaseObject@2@XZ PROC	; Ogre::DummyTexture::newObject, COMDAT

; 64   : 		DECLARE_RTTI(DummyTexture)

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?newObject@DummyTexture@Ogre@@SAPAVBaseObject@2@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 12					; 0000000cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	push	16					; 00000010H
	call	??2MemoryDelegation@Ogre@@SAPAXI@Z	; Ogre::MemoryDelegation::operator new
	add	esp, 4
	mov	DWORD PTR $T94329[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T94329[ebp], 0
	je	SHORT $LN3@newObject@5
	mov	ecx, DWORD PTR $T94329[ebp]
	call	??0DummyTexture@Ogre@@QAE@XZ
	mov	DWORD PTR tv75[ebp], eax
	jmp	SHORT $LN4@newObject@5
$LN3@newObject@5:
	mov	DWORD PTR tv75[ebp], 0
$LN4@newObject@5:
	mov	eax, DWORD PTR tv75[ebp]
	mov	DWORD PTR $T94328[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR $T94328[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?newObject@DummyTexture@Ogre@@SAPAVBaseObject@2@XZ$0:
	push	16					; 00000010H
	mov	eax, DWORD PTR $T94329[ebp]
	push	eax
	call	??3MemoryDelegation@Ogre@@SAXPAXI@Z	; Ogre::MemoryDelegation::operator delete
	add	esp, 8
	ret	0
__ehhandler$?newObject@DummyTexture@Ogre@@SAPAVBaseObject@2@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?newObject@DummyTexture@Ogre@@SAPAVBaseObject@2@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?newObject@DummyTexture@Ogre@@SAPAVBaseObject@2@XZ ENDP	; Ogre::DummyTexture::newObject
PUBLIC	?getDesc@DummyTexture@Ogre@@UAEXAAUTextureDesc@2@@Z ; Ogre::DummyTexture::getDesc
; Function compile flags: /Odtp
;	COMDAT ?getDesc@DummyTexture@Ogre@@UAEXAAUTextureDesc@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_desc$ = 8						; size = 4
?getDesc@DummyTexture@Ogre@@UAEXAAUTextureDesc@2@@Z PROC ; Ogre::DummyTexture::getDesc, COMDAT
; _this$ = ecx

; 67   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 68   : 			assert(0);
; 69   : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?getDesc@DummyTexture@Ogre@@UAEXAAUTextureDesc@2@@Z ENDP ; Ogre::DummyTexture::getDesc
_TEXT	ENDS
PUBLIC	?getHardwareTexture@DummyTexture@Ogre@@UAEPAVHardwarePixelBuffer@2@XZ ; Ogre::DummyTexture::getHardwareTexture
; Function compile flags: /Odtp
;	COMDAT ?getHardwareTexture@DummyTexture@Ogre@@UAEPAVHardwarePixelBuffer@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getHardwareTexture@DummyTexture@Ogre@@UAEPAVHardwarePixelBuffer@2@XZ PROC ; Ogre::DummyTexture::getHardwareTexture, COMDAT
; _this$ = ecx

; 72   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 73   : 			return NULL;

	xor	eax, eax

; 74   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?getHardwareTexture@DummyTexture@Ogre@@UAEPAVHardwarePixelBuffer@2@XZ ENDP ; Ogre::DummyTexture::getHardwareTexture
_TEXT	ENDS
PUBLIC	?lock@DummyTexture@Ogre@@UAEPAXII_NAAULockResult@2@@Z ; Ogre::DummyTexture::lock
; Function compile flags: /Odtp
;	COMDAT ?lock@DummyTexture@Ogre@@UAEPAXII_NAAULockResult@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_face$ = 8						; size = 4
_level$ = 12						; size = 4
_readonly$ = 16						; size = 1
_lockresult$ = 20					; size = 4
?lock@DummyTexture@Ogre@@UAEPAXII_NAAULockResult@2@@Z PROC ; Ogre::DummyTexture::lock, COMDAT
; _this$ = ecx

; 77   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 78   : 			return NULL;

	xor	eax, eax

; 79   : 		}

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?lock@DummyTexture@Ogre@@UAEPAXII_NAAULockResult@2@@Z ENDP ; Ogre::DummyTexture::lock
_TEXT	ENDS
PUBLIC	?unlock@DummyTexture@Ogre@@UAEXII@Z		; Ogre::DummyTexture::unlock
; Function compile flags: /Odtp
;	COMDAT ?unlock@DummyTexture@Ogre@@UAEXII@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_face$ = 8						; size = 4
_level$ = 12						; size = 4
?unlock@DummyTexture@Ogre@@UAEXII@Z PROC		; Ogre::DummyTexture::unlock, COMDAT
; _this$ = ecx

; 82   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 83   : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?unlock@DummyTexture@Ogre@@UAEXII@Z ENDP		; Ogre::DummyTexture::unlock
_TEXT	ENDS
PUBLIC	??_7DummyTexture@Ogre@@6B@			; Ogre::DummyTexture::`vftable'
PUBLIC	??1DummyTexture@Ogre@@EAE@XZ			; Ogre::DummyTexture::~DummyTexture
PUBLIC	??_R4DummyTexture@Ogre@@6B@			; Ogre::DummyTexture::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVDummyTexture@Ogre@@@8			; Ogre::DummyTexture `RTTI Type Descriptor'
PUBLIC	??_R3DummyTexture@Ogre@@8			; Ogre::DummyTexture::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2DummyTexture@Ogre@@8			; Ogre::DummyTexture::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@DummyTexture@Ogre@@8		; Ogre::DummyTexture::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_EDummyTexture@Ogre@@EAEPAXI@Z		; Ogre::DummyTexture::`vector deleting destructor'
;	COMDAT ??_R1A@?0A@EA@DummyTexture@Ogre@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@DummyTexture@Ogre@@8 DD FLAT:??_R0?AVDummyTexture@Ogre@@@8 ; Ogre::DummyTexture::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	04H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3DummyTexture@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R2DummyTexture@Ogre@@8
rdata$r	SEGMENT
??_R2DummyTexture@Ogre@@8 DD FLAT:??_R1A@?0A@EA@DummyTexture@Ogre@@8 ; Ogre::DummyTexture::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@Texture@Ogre@@8
	DD	FLAT:??_R1A@?0A@EA@Resource@Ogre@@8
	DD	FLAT:??_R1A@?0A@EA@BaseObject@Ogre@@8
	DD	FLAT:??_R13?0A@EA@MemoryDelegation@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R3DummyTexture@Ogre@@8
rdata$r	SEGMENT
??_R3DummyTexture@Ogre@@8 DD 00H			; Ogre::DummyTexture::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	05H
	DD	FLAT:??_R2DummyTexture@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVDummyTexture@Ogre@@@8
_DATA	SEGMENT
??_R0?AVDummyTexture@Ogre@@@8 DD FLAT:??_7type_info@@6B@ ; Ogre::DummyTexture `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVDummyTexture@Ogre@@', 00H
_DATA	ENDS
;	COMDAT ??_R4DummyTexture@Ogre@@6B@
rdata$r	SEGMENT
??_R4DummyTexture@Ogre@@6B@ DD 00H			; Ogre::DummyTexture::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVDummyTexture@Ogre@@@8
	DD	FLAT:??_R3DummyTexture@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_7DummyTexture@Ogre@@6B@
CONST	SEGMENT
??_7DummyTexture@Ogre@@6B@ DD FLAT:??_R4DummyTexture@Ogre@@6B@ ; Ogre::DummyTexture::`vftable'
	DD	FLAT:?getRTTI@DummyTexture@Ogre@@UBEPBVRuntimeClass@2@XZ
	DD	FLAT:?release@Resource@Ogre@@UAEXXZ
	DD	FLAT:?addRef@Resource@Ogre@@UAEXXZ
	DD	FLAT:?getRefCount@Resource@Ogre@@UAEHXZ
	DD	FLAT:?_serialize@BaseObject@Ogre@@UAEXAAVArchive@2@H@Z
	DD	FLAT:??_EDummyTexture@Ogre@@EAEPAXI@Z
	DD	FLAT:?deleteThis@BaseObject@Ogre@@MAEXXZ
	DD	FLAT:?getDesc@DummyTexture@Ogre@@UAEXAAUTextureDesc@2@@Z
	DD	FLAT:?getHardwareTexture@DummyTexture@Ogre@@UAEPAVHardwarePixelBuffer@2@XZ
	DD	FLAT:?lock@DummyTexture@Ogre@@UAEPAXII_NAAULockResult@2@@Z
	DD	FLAT:?unlock@DummyTexture@Ogre@@UAEXII@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1DummyTexture@Ogre@@EAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1DummyTexture@Ogre@@EAE@XZ$0
__ehfuncinfo$??1DummyTexture@Ogre@@EAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1DummyTexture@Ogre@@EAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1DummyTexture@Ogre@@EAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1DummyTexture@Ogre@@EAE@XZ PROC			; Ogre::DummyTexture::~DummyTexture, COMDAT
; _this$ = ecx

; 87   : 		{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1DummyTexture@Ogre@@EAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7DummyTexture@Ogre@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 88   : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1Texture@Ogre@@MAE@XZ			; Ogre::Texture::~Texture
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1DummyTexture@Ogre@@EAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1Texture@Ogre@@MAE@XZ			; Ogre::Texture::~Texture
__ehhandler$??1DummyTexture@Ogre@@EAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1DummyTexture@Ogre@@EAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1DummyTexture@Ogre@@EAE@XZ ENDP			; Ogre::DummyTexture::~DummyTexture
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0DummyTexture@Ogre@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0DummyTexture@Ogre@@QAE@XZ$0
__ehfuncinfo$??0DummyTexture@Ogre@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0DummyTexture@Ogre@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0DummyTexture@Ogre@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0DummyTexture@Ogre@@QAE@XZ PROC			; Ogre::DummyTexture::DummyTexture, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0DummyTexture@Ogre@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0Texture@Ogre@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7DummyTexture@Ogre@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0DummyTexture@Ogre@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1Texture@Ogre@@MAE@XZ			; Ogre::Texture::~Texture
__ehhandler$??0DummyTexture@Ogre@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0DummyTexture@Ogre@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0DummyTexture@Ogre@@QAE@XZ ENDP			; Ogre::DummyTexture::DummyTexture
PUBLIC	??0DummyTexture@Ogre@@QAE@ABV01@@Z		; Ogre::DummyTexture::DummyTexture
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0DummyTexture@Ogre@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0DummyTexture@Ogre@@QAE@ABV01@@Z$0
__ehfuncinfo$??0DummyTexture@Ogre@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0DummyTexture@Ogre@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0DummyTexture@Ogre@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0DummyTexture@Ogre@@QAE@ABV01@@Z PROC			; Ogre::DummyTexture::DummyTexture, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0DummyTexture@Ogre@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0Texture@Ogre@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7DummyTexture@Ogre@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0DummyTexture@Ogre@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1Texture@Ogre@@MAE@XZ			; Ogre::Texture::~Texture
__ehhandler$??0DummyTexture@Ogre@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0DummyTexture@Ogre@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0DummyTexture@Ogre@@QAE@ABV01@@Z ENDP			; Ogre::DummyTexture::DummyTexture
PUBLIC	??4DummyTexture@Ogre@@QAEAAV01@ABV01@@Z		; Ogre::DummyTexture::operator=
; Function compile flags: /Odtp
;	COMDAT ??4DummyTexture@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4DummyTexture@Ogre@@QAEAAV01@ABV01@@Z PROC		; Ogre::DummyTexture::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4Texture@Ogre@@QAEAAV01@ABV01@@Z
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4DummyTexture@Ogre@@QAEAAV01@ABV01@@Z ENDP		; Ogre::DummyTexture::operator=
_TEXT	ENDS
PUBLIC	??_GDummyTexture@Ogre@@EAEPAXI@Z		; Ogre::DummyTexture::`scalar deleting destructor'
; Function compile flags: /Odtp
;	COMDAT ??_GDummyTexture@Ogre@@EAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GDummyTexture@Ogre@@EAEPAXI@Z PROC			; Ogre::DummyTexture::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1DummyTexture@Ogre@@EAE@XZ		; Ogre::DummyTexture::~DummyTexture
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@23
	push	16					; 00000010H
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3MemoryDelegation@Ogre@@SAXPAXI@Z	; Ogre::MemoryDelegation::operator delete
	add	esp, 8
$LN1@scalar@23:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GDummyTexture@Ogre@@EAEPAXI@Z ENDP			; Ogre::DummyTexture::`scalar deleting destructor'
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_EDummyTexture@Ogre@@EAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_EDummyTexture@Ogre@@EAEPAXI@Z PROC			; Ogre::DummyTexture::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 2
	je	SHORT $LN3@vector@21
	push	OFFSET ??1DummyTexture@Ogre@@EAE@XZ	; Ogre::DummyTexture::~DummyTexture
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx-4]
	push	edx
	push	16					; 00000010H
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??_M@YGXPAXIHP6EX0@Z@Z
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN2@vector@21
	push	16					; 00000010H
	mov	edx, DWORD PTR _this$[ebp]
	sub	edx, 4
	push	edx
	call	??_VMemoryDelegation@Ogre@@SAXPAXI@Z	; Ogre::MemoryDelegation::operator delete[]
	add	esp, 8
$LN2@vector@21:
	mov	eax, DWORD PTR _this$[ebp]
	sub	eax, 4
	jmp	SHORT $LN4@vector@21
$LN3@vector@21:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1DummyTexture@Ogre@@EAE@XZ		; Ogre::DummyTexture::~DummyTexture
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@vector@21
	push	16					; 00000010H
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3MemoryDelegation@Ogre@@SAXPAXI@Z	; Ogre::MemoryDelegation::operator delete
	add	esp, 8
$LN1@vector@21:
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector@21:
	mov	esp, ebp
	pop	ebp
	ret	4
??_EDummyTexture@Ogre@@EAEPAXI@Z ENDP			; Ogre::DummyTexture::`vector deleting destructor'
_TEXT	ENDS
PUBLIC	?getRTTI@TextureData@Ogre@@UBEPBVRuntimeClass@2@XZ ; Ogre::TextureData::getRTTI
EXTRN	?m_RTTI@TextureData@Ogre@@2VRuntimeClass@2@B:BYTE ; Ogre::TextureData::m_RTTI
; Function compile flags: /Odtp
;	COMDAT ?getRTTI@TextureData@Ogre@@UBEPBVRuntimeClass@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getRTTI@TextureData@Ogre@@UBEPBVRuntimeClass@2@XZ PROC	; Ogre::TextureData::getRTTI, COMDAT
; _this$ = ecx

; 93   : 		DECLARE_RTTI(TextureData)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, OFFSET ?m_RTTI@TextureData@Ogre@@2VRuntimeClass@2@B ; Ogre::TextureData::m_RTTI
	mov	esp, ebp
	pop	ebp
	ret	0
?getRTTI@TextureData@Ogre@@UBEPBVRuntimeClass@2@XZ ENDP	; Ogre::TextureData::getRTTI
_TEXT	ENDS
PUBLIC	?newObject@TextureData@Ogre@@SAPAVBaseObject@2@XZ ; Ogre::TextureData::newObject
EXTRN	??0TextureData@Ogre@@QAE@XZ:PROC		; Ogre::TextureData::TextureData
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?newObject@TextureData@Ogre@@SAPAVBaseObject@2@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?newObject@TextureData@Ogre@@SAPAVBaseObject@2@XZ$0
__ehfuncinfo$?newObject@TextureData@Ogre@@SAPAVBaseObject@2@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?newObject@TextureData@Ogre@@SAPAVBaseObject@2@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?newObject@TextureData@Ogre@@SAPAVBaseObject@2@XZ
_TEXT	SEGMENT
tv75 = -24						; size = 4
$T94385 = -20						; size = 4
$T94384 = -16						; size = 4
__$EHRec$ = -12						; size = 12
?newObject@TextureData@Ogre@@SAPAVBaseObject@2@XZ PROC	; Ogre::TextureData::newObject, COMDAT

; 93   : 		DECLARE_RTTI(TextureData)

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?newObject@TextureData@Ogre@@SAPAVBaseObject@2@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 12					; 0000000cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	push	108					; 0000006cH
	call	??2MemoryDelegation@Ogre@@SAPAXI@Z	; Ogre::MemoryDelegation::operator new
	add	esp, 4
	mov	DWORD PTR $T94385[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T94385[ebp], 0
	je	SHORT $LN3@newObject@6
	mov	ecx, DWORD PTR $T94385[ebp]
	call	??0TextureData@Ogre@@QAE@XZ		; Ogre::TextureData::TextureData
	mov	DWORD PTR tv75[ebp], eax
	jmp	SHORT $LN4@newObject@6
$LN3@newObject@6:
	mov	DWORD PTR tv75[ebp], 0
$LN4@newObject@6:
	mov	eax, DWORD PTR tv75[ebp]
	mov	DWORD PTR $T94384[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR $T94384[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?newObject@TextureData@Ogre@@SAPAVBaseObject@2@XZ$0:
	push	108					; 0000006cH
	mov	eax, DWORD PTR $T94385[ebp]
	push	eax
	call	??3MemoryDelegation@Ogre@@SAXPAXI@Z	; Ogre::MemoryDelegation::operator delete
	add	esp, 8
	ret	0
__ehhandler$?newObject@TextureData@Ogre@@SAPAVBaseObject@2@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?newObject@TextureData@Ogre@@SAPAVBaseObject@2@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?newObject@TextureData@Ogre@@SAPAVBaseObject@2@XZ ENDP	; Ogre::TextureData::newObject
PUBLIC	?getDesc@TextureData@Ogre@@UAEXAAUTextureDesc@2@@Z ; Ogre::TextureData::getDesc
; Function compile flags: /Odtp
;	COMDAT ?getDesc@TextureData@Ogre@@UAEXAAUTextureDesc@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_desc$ = 8						; size = 4
?getDesc@TextureData@Ogre@@UAEXAAUTextureDesc@2@@Z PROC	; Ogre::TextureData::getDesc, COMDAT
; _this$ = ecx

; 107  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 108  : 			desc = m_Desc;

	mov	esi, DWORD PTR _this$[ebp]
	add	esi, 16					; 00000010H
	mov	ecx, 7
	mov	edi, DWORD PTR _desc$[ebp]
	rep movsd

; 109  : 		}

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?getDesc@TextureData@Ogre@@UAEXAAUTextureDesc@2@@Z ENDP	; Ogre::TextureData::getDesc
_TEXT	ENDS
PUBLIC	?getWidth@TextureData@Ogre@@QAEIXZ		; Ogre::TextureData::getWidth
; Function compile flags: /Odtp
;	COMDAT ?getWidth@TextureData@Ogre@@QAEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getWidth@TextureData@Ogre@@QAEIXZ PROC			; Ogre::TextureData::getWidth, COMDAT
; _this$ = ecx

; 112  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 113  : 			return m_Desc.width;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+20]

; 114  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?getWidth@TextureData@Ogre@@QAEIXZ ENDP			; Ogre::TextureData::getWidth
_TEXT	ENDS
PUBLIC	?getHeight@TextureData@Ogre@@QAEIXZ		; Ogre::TextureData::getHeight
; Function compile flags: /Odtp
;	COMDAT ?getHeight@TextureData@Ogre@@QAEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getHeight@TextureData@Ogre@@QAEIXZ PROC		; Ogre::TextureData::getHeight, COMDAT
; _this$ = ecx

; 117  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 118  : 			return m_Desc.height;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+24]

; 119  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?getHeight@TextureData@Ogre@@QAEIXZ ENDP		; Ogre::TextureData::getHeight
_TEXT	ENDS
PUBLIC	?getFormat@TextureData@Ogre@@QAE?AW4PixelFormat@2@XZ ; Ogre::TextureData::getFormat
; Function compile flags: /Odtp
;	COMDAT ?getFormat@TextureData@Ogre@@QAE?AW4PixelFormat@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getFormat@TextureData@Ogre@@QAE?AW4PixelFormat@2@XZ PROC ; Ogre::TextureData::getFormat, COMDAT
; _this$ = ecx

; 122  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 123  : 			return m_Desc.format;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+36]

; 124  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?getFormat@TextureData@Ogre@@QAE?AW4PixelFormat@2@XZ ENDP ; Ogre::TextureData::getFormat
_TEXT	ENDS
PUBLIC	?setStatic@TextureData@Ogre@@QAEX_N@Z		; Ogre::TextureData::setStatic
; Function compile flags: /Odtp
;	COMDAT ?setStatic@TextureData@Ogre@@QAEX_N@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_is_static$ = 8						; size = 1
?setStatic@TextureData@Ogre@@QAEX_N@Z PROC		; Ogre::TextureData::setStatic, COMDAT
; _this$ = ecx

; 142  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 143  : 			m_isStatic = is_static;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR _is_static$[ebp]
	mov	BYTE PTR [eax+76], cl

; 144  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?setStatic@TextureData@Ogre@@QAEX_N@Z ENDP		; Ogre::TextureData::setStatic
_TEXT	ENDS
PUBLIC	??1?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::~vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >
PUBLIC	??0?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE@ABV01@@Z ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >
PUBLIC	??_7TextureData@Ogre@@6B@			; Ogre::TextureData::`vftable'
PUBLIC	??0TextureData@Ogre@@QAE@ABV01@@Z		; Ogre::TextureData::TextureData
PUBLIC	??_R4TextureData@Ogre@@6B@			; Ogre::TextureData::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVTextureData@Ogre@@@8			; Ogre::TextureData `RTTI Type Descriptor'
PUBLIC	??_R3TextureData@Ogre@@8			; Ogre::TextureData::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2TextureData@Ogre@@8			; Ogre::TextureData::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@TextureData@Ogre@@8		; Ogre::TextureData::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_ETextureData@Ogre@@MAEPAXI@Z			; Ogre::TextureData::`vector deleting destructor'
EXTRN	?_serialize@TextureData@Ogre@@EAEXAAVArchive@2@H@Z:PROC ; Ogre::TextureData::_serialize
EXTRN	?getHardwareTexture@TextureData@Ogre@@UAEPAVHardwarePixelBuffer@2@XZ:PROC ; Ogre::TextureData::getHardwareTexture
EXTRN	?lock@TextureData@Ogre@@UAEPAXII_NAAULockResult@2@@Z:PROC ; Ogre::TextureData::lock
EXTRN	?unlock@TextureData@Ogre@@UAEXII@Z:PROC		; Ogre::TextureData::unlock
;	COMDAT ??_R1A@?0A@EA@TextureData@Ogre@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@TextureData@Ogre@@8 DD FLAT:??_R0?AVTextureData@Ogre@@@8 ; Ogre::TextureData::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	04H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3TextureData@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R2TextureData@Ogre@@8
rdata$r	SEGMENT
??_R2TextureData@Ogre@@8 DD FLAT:??_R1A@?0A@EA@TextureData@Ogre@@8 ; Ogre::TextureData::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@Texture@Ogre@@8
	DD	FLAT:??_R1A@?0A@EA@Resource@Ogre@@8
	DD	FLAT:??_R1A@?0A@EA@BaseObject@Ogre@@8
	DD	FLAT:??_R13?0A@EA@MemoryDelegation@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R3TextureData@Ogre@@8
rdata$r	SEGMENT
??_R3TextureData@Ogre@@8 DD 00H				; Ogre::TextureData::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	05H
	DD	FLAT:??_R2TextureData@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVTextureData@Ogre@@@8
_DATA	SEGMENT
??_R0?AVTextureData@Ogre@@@8 DD FLAT:??_7type_info@@6B@	; Ogre::TextureData `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVTextureData@Ogre@@', 00H
_DATA	ENDS
;	COMDAT ??_R4TextureData@Ogre@@6B@
rdata$r	SEGMENT
??_R4TextureData@Ogre@@6B@ DD 00H			; Ogre::TextureData::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVTextureData@Ogre@@@8
	DD	FLAT:??_R3TextureData@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_7TextureData@Ogre@@6B@
CONST	SEGMENT
??_7TextureData@Ogre@@6B@ DD FLAT:??_R4TextureData@Ogre@@6B@ ; Ogre::TextureData::`vftable'
	DD	FLAT:?getRTTI@TextureData@Ogre@@UBEPBVRuntimeClass@2@XZ
	DD	FLAT:?release@Resource@Ogre@@UAEXXZ
	DD	FLAT:?addRef@Resource@Ogre@@UAEXXZ
	DD	FLAT:?getRefCount@Resource@Ogre@@UAEHXZ
	DD	FLAT:?_serialize@TextureData@Ogre@@EAEXAAVArchive@2@H@Z
	DD	FLAT:??_ETextureData@Ogre@@MAEPAXI@Z
	DD	FLAT:?deleteThis@BaseObject@Ogre@@MAEXXZ
	DD	FLAT:?getDesc@TextureData@Ogre@@UAEXAAUTextureDesc@2@@Z
	DD	FLAT:?getHardwareTexture@TextureData@Ogre@@UAEPAVHardwarePixelBuffer@2@XZ
	DD	FLAT:?lock@TextureData@Ogre@@UAEPAXII_NAAULockResult@2@@Z
	DD	FLAT:?unlock@TextureData@Ogre@@UAEXII@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0TextureData@Ogre@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0TextureData@Ogre@@QAE@ABV01@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0TextureData@Ogre@@QAE@ABV01@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0TextureData@Ogre@@QAE@ABV01@@Z$2
__ehfuncinfo$??0TextureData@Ogre@@QAE@ABV01@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0TextureData@Ogre@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0TextureData@Ogre@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0TextureData@Ogre@@QAE@ABV01@@Z PROC			; Ogre::TextureData::TextureData, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0TextureData@Ogre@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0Texture@Ogre@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7TextureData@Ogre@@6B@
	mov	esi, DWORD PTR ___that$[ebp]
	add	esi, 16					; 00000010H
	mov	edi, DWORD PTR _this$[ebp]
	add	edi, 16					; 00000010H
	mov	ecx, 7
	rep movsd
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 44					; 0000002cH
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 44					; 0000002cH
	call	??0?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE@ABV01@@Z ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+68]
	mov	DWORD PTR [eax+68], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+72]
	mov	DWORD PTR [eax+72], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	dl, BYTE PTR [ecx+76]
	mov	BYTE PTR [eax+76], dl
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 80					; 00000050H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 80					; 00000050H
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0TextureData@Ogre@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1Texture@Ogre@@MAE@XZ			; Ogre::Texture::~Texture
__unwindfunclet$??0TextureData@Ogre@@QAE@ABV01@@Z$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 44					; 0000002cH
	jmp	??1?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::~vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >
__unwindfunclet$??0TextureData@Ogre@@QAE@ABV01@@Z$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 80					; 00000050H
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$??0TextureData@Ogre@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0TextureData@Ogre@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0TextureData@Ogre@@QAE@ABV01@@Z ENDP			; Ogre::TextureData::TextureData
PUBLIC	??4?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::operator=
PUBLIC	??4TextureData@Ogre@@QAEAAV01@ABV01@@Z		; Ogre::TextureData::operator=
; Function compile flags: /Odtp
;	COMDAT ??4TextureData@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4TextureData@Ogre@@QAEAAV01@ABV01@@Z PROC		; Ogre::TextureData::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4Texture@Ogre@@QAEAAV01@ABV01@@Z
	mov	esi, DWORD PTR ___that$[ebp]
	add	esi, 16					; 00000010H
	mov	edi, DWORD PTR _this$[ebp]
	add	edi, 16					; 00000010H
	mov	ecx, 7
	rep movsd
	mov	ecx, DWORD PTR ___that$[ebp]
	add	ecx, 44					; 0000002cH
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 44					; 0000002cH
	call	??4?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::operator=
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+68]
	mov	DWORD PTR [edx+68], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+72]
	mov	DWORD PTR [edx+72], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	cl, BYTE PTR [eax+76]
	mov	BYTE PTR [edx+76], cl
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 80					; 00000050H
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 80					; 00000050H
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
??4TextureData@Ogre@@QAEAAV01@ABV01@@Z ENDP		; Ogre::TextureData::operator=
_TEXT	ENDS
PUBLIC	??_GTextureData@Ogre@@MAEPAXI@Z			; Ogre::TextureData::`scalar deleting destructor'
EXTRN	??1TextureData@Ogre@@MAE@XZ:PROC		; Ogre::TextureData::~TextureData
; Function compile flags: /Odtp
;	COMDAT ??_GTextureData@Ogre@@MAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GTextureData@Ogre@@MAEPAXI@Z PROC			; Ogre::TextureData::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1TextureData@Ogre@@MAE@XZ		; Ogre::TextureData::~TextureData
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@24
	push	108					; 0000006cH
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3MemoryDelegation@Ogre@@SAXPAXI@Z	; Ogre::MemoryDelegation::operator delete
	add	esp, 8
$LN1@scalar@24:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GTextureData@Ogre@@MAEPAXI@Z ENDP			; Ogre::TextureData::`scalar deleting destructor'
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_ETextureData@Ogre@@MAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_ETextureData@Ogre@@MAEPAXI@Z PROC			; Ogre::TextureData::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 2
	je	SHORT $LN3@vector@22
	push	OFFSET ??1TextureData@Ogre@@MAE@XZ	; Ogre::TextureData::~TextureData
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx-4]
	push	edx
	push	108					; 0000006cH
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??_M@YGXPAXIHP6EX0@Z@Z
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN2@vector@22
	push	108					; 0000006cH
	mov	edx, DWORD PTR _this$[ebp]
	sub	edx, 4
	push	edx
	call	??_VMemoryDelegation@Ogre@@SAXPAXI@Z	; Ogre::MemoryDelegation::operator delete[]
	add	esp, 8
$LN2@vector@22:
	mov	eax, DWORD PTR _this$[ebp]
	sub	eax, 4
	jmp	SHORT $LN4@vector@22
$LN3@vector@22:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1TextureData@Ogre@@MAE@XZ		; Ogre::TextureData::~TextureData
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@vector@22
	push	108					; 0000006cH
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3MemoryDelegation@Ogre@@SAXPAXI@Z	; Ogre::MemoryDelegation::operator delete
	add	esp, 8
$LN1@vector@22:
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector@22:
	mov	esp, ebp
	pop	ebp
	ret	4
??_ETextureData@Ogre@@MAEPAXI@Z ENDP			; Ogre::TextureData::`vector deleting destructor'
_TEXT	ENDS
PUBLIC	?getRTTI@RT_TEXTURE@Ogre@@UBEPBVRuntimeClass@2@XZ ; Ogre::RT_TEXTURE::getRTTI
EXTRN	?m_RTTI@RT_TEXTURE@Ogre@@2VRuntimeClass@2@B:BYTE ; Ogre::RT_TEXTURE::m_RTTI
; Function compile flags: /Odtp
;	COMDAT ?getRTTI@RT_TEXTURE@Ogre@@UBEPBVRuntimeClass@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getRTTI@RT_TEXTURE@Ogre@@UBEPBVRuntimeClass@2@XZ PROC	; Ogre::RT_TEXTURE::getRTTI, COMDAT
; _this$ = ecx

; 179  : 		DECLARE_RTTI(RT_TEXTURE)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, OFFSET ?m_RTTI@RT_TEXTURE@Ogre@@2VRuntimeClass@2@B ; Ogre::RT_TEXTURE::m_RTTI
	mov	esp, ebp
	pop	ebp
	ret	0
?getRTTI@RT_TEXTURE@Ogre@@UBEPBVRuntimeClass@2@XZ ENDP	; Ogre::RT_TEXTURE::getRTTI
_TEXT	ENDS
PUBLIC	??0RT_TEXTURE@Ogre@@QAE@XZ			; Ogre::RT_TEXTURE::RT_TEXTURE
PUBLIC	?newObject@RT_TEXTURE@Ogre@@SAPAVBaseObject@2@XZ ; Ogre::RT_TEXTURE::newObject
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?newObject@RT_TEXTURE@Ogre@@SAPAVBaseObject@2@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?newObject@RT_TEXTURE@Ogre@@SAPAVBaseObject@2@XZ$0
__ehfuncinfo$?newObject@RT_TEXTURE@Ogre@@SAPAVBaseObject@2@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?newObject@RT_TEXTURE@Ogre@@SAPAVBaseObject@2@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?newObject@RT_TEXTURE@Ogre@@SAPAVBaseObject@2@XZ
_TEXT	SEGMENT
tv75 = -24						; size = 4
$T94427 = -20						; size = 4
$T94426 = -16						; size = 4
__$EHRec$ = -12						; size = 12
?newObject@RT_TEXTURE@Ogre@@SAPAVBaseObject@2@XZ PROC	; Ogre::RT_TEXTURE::newObject, COMDAT

; 179  : 		DECLARE_RTTI(RT_TEXTURE)

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?newObject@RT_TEXTURE@Ogre@@SAPAVBaseObject@2@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 12					; 0000000cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	push	48					; 00000030H
	call	??2MemoryDelegation@Ogre@@SAPAXI@Z	; Ogre::MemoryDelegation::operator new
	add	esp, 4
	mov	DWORD PTR $T94427[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T94427[ebp], 0
	je	SHORT $LN3@newObject@7
	mov	ecx, DWORD PTR $T94427[ebp]
	call	??0RT_TEXTURE@Ogre@@QAE@XZ		; Ogre::RT_TEXTURE::RT_TEXTURE
	mov	DWORD PTR tv75[ebp], eax
	jmp	SHORT $LN4@newObject@7
$LN3@newObject@7:
	mov	DWORD PTR tv75[ebp], 0
$LN4@newObject@7:
	mov	eax, DWORD PTR tv75[ebp]
	mov	DWORD PTR $T94426[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR $T94426[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?newObject@RT_TEXTURE@Ogre@@SAPAVBaseObject@2@XZ$0:
	push	48					; 00000030H
	mov	eax, DWORD PTR $T94427[ebp]
	push	eax
	call	??3MemoryDelegation@Ogre@@SAXPAXI@Z	; Ogre::MemoryDelegation::operator delete
	add	esp, 8
	ret	0
__ehhandler$?newObject@RT_TEXTURE@Ogre@@SAPAVBaseObject@2@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?newObject@RT_TEXTURE@Ogre@@SAPAVBaseObject@2@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?newObject@RT_TEXTURE@Ogre@@SAPAVBaseObject@2@XZ ENDP	; Ogre::RT_TEXTURE::newObject
PUBLIC	??_7RT_TEXTURE@Ogre@@6B@			; Ogre::RT_TEXTURE::`vftable'
PUBLIC	??_R4RT_TEXTURE@Ogre@@6B@			; Ogre::RT_TEXTURE::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVRT_TEXTURE@Ogre@@@8			; Ogre::RT_TEXTURE `RTTI Type Descriptor'
PUBLIC	??_R3RT_TEXTURE@Ogre@@8				; Ogre::RT_TEXTURE::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2RT_TEXTURE@Ogre@@8				; Ogre::RT_TEXTURE::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@RT_TEXTURE@Ogre@@8		; Ogre::RT_TEXTURE::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_ERT_TEXTURE@Ogre@@MAEPAXI@Z			; Ogre::RT_TEXTURE::`vector deleting destructor'
PUBLIC	?getDesc@RT_TEXTURE@Ogre@@UAEXAAUTextureDesc@2@@Z ; Ogre::RT_TEXTURE::getDesc
PUBLIC	?getHardwareTexture@RT_TEXTURE@Ogre@@UAEPAVHardwarePixelBuffer@2@XZ ; Ogre::RT_TEXTURE::getHardwareTexture
EXTRN	?lock@RT_TEXTURE@Ogre@@UAEPAXII_NAAULockResult@2@@Z:PROC ; Ogre::RT_TEXTURE::lock
EXTRN	?unlock@RT_TEXTURE@Ogre@@UAEXII@Z:PROC		; Ogre::RT_TEXTURE::unlock
;	COMDAT ??_R1A@?0A@EA@RT_TEXTURE@Ogre@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@RT_TEXTURE@Ogre@@8 DD FLAT:??_R0?AVRT_TEXTURE@Ogre@@@8 ; Ogre::RT_TEXTURE::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	04H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3RT_TEXTURE@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R2RT_TEXTURE@Ogre@@8
rdata$r	SEGMENT
??_R2RT_TEXTURE@Ogre@@8 DD FLAT:??_R1A@?0A@EA@RT_TEXTURE@Ogre@@8 ; Ogre::RT_TEXTURE::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@Texture@Ogre@@8
	DD	FLAT:??_R1A@?0A@EA@Resource@Ogre@@8
	DD	FLAT:??_R1A@?0A@EA@BaseObject@Ogre@@8
	DD	FLAT:??_R13?0A@EA@MemoryDelegation@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R3RT_TEXTURE@Ogre@@8
rdata$r	SEGMENT
??_R3RT_TEXTURE@Ogre@@8 DD 00H				; Ogre::RT_TEXTURE::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	05H
	DD	FLAT:??_R2RT_TEXTURE@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVRT_TEXTURE@Ogre@@@8
_DATA	SEGMENT
??_R0?AVRT_TEXTURE@Ogre@@@8 DD FLAT:??_7type_info@@6B@	; Ogre::RT_TEXTURE `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVRT_TEXTURE@Ogre@@', 00H
_DATA	ENDS
;	COMDAT ??_R4RT_TEXTURE@Ogre@@6B@
rdata$r	SEGMENT
??_R4RT_TEXTURE@Ogre@@6B@ DD 00H			; Ogre::RT_TEXTURE::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVRT_TEXTURE@Ogre@@@8
	DD	FLAT:??_R3RT_TEXTURE@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_7RT_TEXTURE@Ogre@@6B@
CONST	SEGMENT
??_7RT_TEXTURE@Ogre@@6B@ DD FLAT:??_R4RT_TEXTURE@Ogre@@6B@ ; Ogre::RT_TEXTURE::`vftable'
	DD	FLAT:?getRTTI@RT_TEXTURE@Ogre@@UBEPBVRuntimeClass@2@XZ
	DD	FLAT:?release@Resource@Ogre@@UAEXXZ
	DD	FLAT:?addRef@Resource@Ogre@@UAEXXZ
	DD	FLAT:?getRefCount@Resource@Ogre@@UAEHXZ
	DD	FLAT:?_serialize@BaseObject@Ogre@@UAEXAAVArchive@2@H@Z
	DD	FLAT:??_ERT_TEXTURE@Ogre@@MAEPAXI@Z
	DD	FLAT:?deleteThis@BaseObject@Ogre@@MAEXXZ
	DD	FLAT:?getDesc@RT_TEXTURE@Ogre@@UAEXAAUTextureDesc@2@@Z
	DD	FLAT:?getHardwareTexture@RT_TEXTURE@Ogre@@UAEPAVHardwarePixelBuffer@2@XZ
	DD	FLAT:?lock@RT_TEXTURE@Ogre@@UAEPAXII_NAAULockResult@2@@Z
	DD	FLAT:?unlock@RT_TEXTURE@Ogre@@UAEXII@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0RT_TEXTURE@Ogre@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0RT_TEXTURE@Ogre@@QAE@XZ$0
__ehfuncinfo$??0RT_TEXTURE@Ogre@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0RT_TEXTURE@Ogre@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0RT_TEXTURE@Ogre@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0RT_TEXTURE@Ogre@@QAE@XZ PROC				; Ogre::RT_TEXTURE::RT_TEXTURE, COMDAT
; _this$ = ecx

; 181  : 		RT_TEXTURE() : m_pTexture(NULL){}

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0RT_TEXTURE@Ogre@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0Texture@Ogre@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7RT_TEXTURE@Ogre@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+44], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0RT_TEXTURE@Ogre@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1Texture@Ogre@@MAE@XZ			; Ogre::Texture::~Texture
__ehhandler$??0RT_TEXTURE@Ogre@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0RT_TEXTURE@Ogre@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0RT_TEXTURE@Ogre@@QAE@XZ ENDP				; Ogre::RT_TEXTURE::RT_TEXTURE
; Function compile flags: /Odtp
;	COMDAT ?getHardwareTexture@RT_TEXTURE@Ogre@@UAEPAVHardwarePixelBuffer@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getHardwareTexture@RT_TEXTURE@Ogre@@UAEPAVHardwarePixelBuffer@2@XZ PROC ; Ogre::RT_TEXTURE::getHardwareTexture, COMDAT
; _this$ = ecx

; 184  : 		virtual HardwareTexture *getHardwareTexture(){return m_pTexture;}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+44]
	mov	esp, ebp
	pop	ebp
	ret	0
?getHardwareTexture@RT_TEXTURE@Ogre@@UAEPAVHardwarePixelBuffer@2@XZ ENDP ; Ogre::RT_TEXTURE::getHardwareTexture
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?getDesc@RT_TEXTURE@Ogre@@UAEXAAUTextureDesc@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_desc$ = 8						; size = 4
?getDesc@RT_TEXTURE@Ogre@@UAEXAAUTextureDesc@2@@Z PROC	; Ogre::RT_TEXTURE::getDesc, COMDAT
; _this$ = ecx

; 189  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 190  : 			desc = m_Desc;

	mov	esi, DWORD PTR _this$[ebp]
	add	esi, 16					; 00000010H
	mov	ecx, 7
	mov	edi, DWORD PTR _desc$[ebp]
	rep movsd

; 191  : 		}

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?getDesc@RT_TEXTURE@Ogre@@UAEXAAUTextureDesc@2@@Z ENDP	; Ogre::RT_TEXTURE::getDesc
_TEXT	ENDS
PUBLIC	??0RT_TEXTURE@Ogre@@QAE@ABV01@@Z		; Ogre::RT_TEXTURE::RT_TEXTURE
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0RT_TEXTURE@Ogre@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0RT_TEXTURE@Ogre@@QAE@ABV01@@Z$0
__ehfuncinfo$??0RT_TEXTURE@Ogre@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0RT_TEXTURE@Ogre@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0RT_TEXTURE@Ogre@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0RT_TEXTURE@Ogre@@QAE@ABV01@@Z PROC			; Ogre::RT_TEXTURE::RT_TEXTURE, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0RT_TEXTURE@Ogre@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0Texture@Ogre@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7RT_TEXTURE@Ogre@@6B@
	mov	esi, DWORD PTR ___that$[ebp]
	add	esi, 16					; 00000010H
	mov	edi, DWORD PTR _this$[ebp]
	add	edi, 16					; 00000010H
	mov	ecx, 7
	rep movsd
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	DWORD PTR [edx+44], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0RT_TEXTURE@Ogre@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1Texture@Ogre@@MAE@XZ			; Ogre::Texture::~Texture
__ehhandler$??0RT_TEXTURE@Ogre@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0RT_TEXTURE@Ogre@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0RT_TEXTURE@Ogre@@QAE@ABV01@@Z ENDP			; Ogre::RT_TEXTURE::RT_TEXTURE
PUBLIC	??4RT_TEXTURE@Ogre@@QAEAAV01@ABV01@@Z		; Ogre::RT_TEXTURE::operator=
; Function compile flags: /Odtp
;	COMDAT ??4RT_TEXTURE@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4RT_TEXTURE@Ogre@@QAEAAV01@ABV01@@Z PROC		; Ogre::RT_TEXTURE::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4Texture@Ogre@@QAEAAV01@ABV01@@Z
	mov	esi, DWORD PTR ___that$[ebp]
	add	esi, 16					; 00000010H
	mov	edi, DWORD PTR _this$[ebp]
	add	edi, 16					; 00000010H
	mov	ecx, 7
	rep movsd
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+44]
	mov	DWORD PTR [ecx+44], eax
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
??4RT_TEXTURE@Ogre@@QAEAAV01@ABV01@@Z ENDP		; Ogre::RT_TEXTURE::operator=
_TEXT	ENDS
PUBLIC	??_GRT_TEXTURE@Ogre@@MAEPAXI@Z			; Ogre::RT_TEXTURE::`scalar deleting destructor'
EXTRN	??1RT_TEXTURE@Ogre@@MAE@XZ:PROC			; Ogre::RT_TEXTURE::~RT_TEXTURE
; Function compile flags: /Odtp
;	COMDAT ??_GRT_TEXTURE@Ogre@@MAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GRT_TEXTURE@Ogre@@MAEPAXI@Z PROC			; Ogre::RT_TEXTURE::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1RT_TEXTURE@Ogre@@MAE@XZ		; Ogre::RT_TEXTURE::~RT_TEXTURE
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@25
	push	48					; 00000030H
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3MemoryDelegation@Ogre@@SAXPAXI@Z	; Ogre::MemoryDelegation::operator delete
	add	esp, 8
$LN1@scalar@25:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GRT_TEXTURE@Ogre@@MAEPAXI@Z ENDP			; Ogre::RT_TEXTURE::`scalar deleting destructor'
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_ERT_TEXTURE@Ogre@@MAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_ERT_TEXTURE@Ogre@@MAEPAXI@Z PROC			; Ogre::RT_TEXTURE::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 2
	je	SHORT $LN3@vector@23
	push	OFFSET ??1RT_TEXTURE@Ogre@@MAE@XZ	; Ogre::RT_TEXTURE::~RT_TEXTURE
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx-4]
	push	edx
	push	48					; 00000030H
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??_M@YGXPAXIHP6EX0@Z@Z
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN2@vector@23
	push	48					; 00000030H
	mov	edx, DWORD PTR _this$[ebp]
	sub	edx, 4
	push	edx
	call	??_VMemoryDelegation@Ogre@@SAXPAXI@Z	; Ogre::MemoryDelegation::operator delete[]
	add	esp, 8
$LN2@vector@23:
	mov	eax, DWORD PTR _this$[ebp]
	sub	eax, 4
	jmp	SHORT $LN4@vector@23
$LN3@vector@23:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1RT_TEXTURE@Ogre@@MAE@XZ		; Ogre::RT_TEXTURE::~RT_TEXTURE
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@vector@23
	push	48					; 00000030H
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3MemoryDelegation@Ogre@@SAXPAXI@Z	; Ogre::MemoryDelegation::operator delete
	add	esp, 8
$LN1@vector@23:
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector@23:
	mov	esp, ebp
	pop	ebp
	ret	4
??_ERT_TEXTURE@Ogre@@MAEPAXI@Z ENDP			; Ogre::RT_TEXTURE::`vector deleting destructor'
_TEXT	ENDS
PUBLIC	?getRTTI@VertexData@Ogre@@UBEPBVRuntimeClass@2@XZ ; Ogre::VertexData::getRTTI
EXTRN	?m_RTTI@VertexData@Ogre@@2VRuntimeClass@2@B:BYTE ; Ogre::VertexData::m_RTTI
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogrevertexindexdata.h
;	COMDAT ?getRTTI@VertexData@Ogre@@UBEPBVRuntimeClass@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getRTTI@VertexData@Ogre@@UBEPBVRuntimeClass@2@XZ PROC	; Ogre::VertexData::getRTTI, COMDAT
; _this$ = ecx

; 15   : 		DECLARE_RTTI(VertexData);

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, OFFSET ?m_RTTI@VertexData@Ogre@@2VRuntimeClass@2@B ; Ogre::VertexData::m_RTTI
	mov	esp, ebp
	pop	ebp
	ret	0
?getRTTI@VertexData@Ogre@@UBEPBVRuntimeClass@2@XZ ENDP	; Ogre::VertexData::getRTTI
_TEXT	ENDS
PUBLIC	?newObject@VertexData@Ogre@@SAPAVBaseObject@2@XZ ; Ogre::VertexData::newObject
EXTRN	??0VertexData@Ogre@@QAE@XZ:PROC			; Ogre::VertexData::VertexData
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?newObject@VertexData@Ogre@@SAPAVBaseObject@2@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?newObject@VertexData@Ogre@@SAPAVBaseObject@2@XZ$0
__ehfuncinfo$?newObject@VertexData@Ogre@@SAPAVBaseObject@2@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?newObject@VertexData@Ogre@@SAPAVBaseObject@2@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?newObject@VertexData@Ogre@@SAPAVBaseObject@2@XZ
_TEXT	SEGMENT
tv75 = -24						; size = 4
$T94470 = -20						; size = 4
$T94469 = -16						; size = 4
__$EHRec$ = -12						; size = 12
?newObject@VertexData@Ogre@@SAPAVBaseObject@2@XZ PROC	; Ogre::VertexData::newObject, COMDAT

; 15   : 		DECLARE_RTTI(VertexData);

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?newObject@VertexData@Ogre@@SAPAVBaseObject@2@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 12					; 0000000cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	push	104					; 00000068H
	call	??2MemoryDelegation@Ogre@@SAPAXI@Z	; Ogre::MemoryDelegation::operator new
	add	esp, 4
	mov	DWORD PTR $T94470[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T94470[ebp], 0
	je	SHORT $LN3@newObject@8
	mov	ecx, DWORD PTR $T94470[ebp]
	call	??0VertexData@Ogre@@QAE@XZ		; Ogre::VertexData::VertexData
	mov	DWORD PTR tv75[ebp], eax
	jmp	SHORT $LN4@newObject@8
$LN3@newObject@8:
	mov	DWORD PTR tv75[ebp], 0
$LN4@newObject@8:
	mov	eax, DWORD PTR tv75[ebp]
	mov	DWORD PTR $T94469[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR $T94469[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?newObject@VertexData@Ogre@@SAPAVBaseObject@2@XZ$0:
	push	104					; 00000068H
	mov	eax, DWORD PTR $T94470[ebp]
	push	eax
	call	??3MemoryDelegation@Ogre@@SAXPAXI@Z	; Ogre::MemoryDelegation::operator delete
	add	esp, 8
	ret	0
__ehhandler$?newObject@VertexData@Ogre@@SAPAVBaseObject@2@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?newObject@VertexData@Ogre@@SAPAVBaseObject@2@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?newObject@VertexData@Ogre@@SAPAVBaseObject@2@XZ ENDP	; Ogre::VertexData::newObject
PUBLIC	?getNumVertex@VertexData@Ogre@@QAEIXZ		; Ogre::VertexData::getNumVertex
; Function compile flags: /Odtp
;	COMDAT ?getNumVertex@VertexData@Ogre@@QAEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getNumVertex@VertexData@Ogre@@QAEIXZ PROC		; Ogre::VertexData::getNumVertex, COMDAT
; _this$ = ecx

; 28   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 29   : 			return m_nVertex;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+64]

; 30   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?getNumVertex@VertexData@Ogre@@QAEIXZ ENDP		; Ogre::VertexData::getNumVertex
_TEXT	ENDS
PUBLIC	?getVertexElement@VertexData@Ogre@@QAEPADIW4VertexElementSemantic@2@@Z ; Ogre::VertexData::getVertexElement
EXTRN	?getElementBySemantic@VertexFormat@Ogre@@QBEPBVVertexElement@2@W4VertexElementSemantic@2@H@Z:PROC ; Ogre::VertexFormat::getElementBySemantic
; Function compile flags: /Odtp
;	COMDAT ?getVertexElement@VertexData@Ogre@@QAEPADIW4VertexElementSemantic@2@@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
_offset$ = -8						; size = 4
_pelement$ = -4						; size = 4
_ivert$ = 8						; size = 4
_ves$ = 12						; size = 4
?getVertexElement@VertexData@Ogre@@QAEPADIW4VertexElementSemantic@2@@Z PROC ; Ogre::VertexData::getVertexElement, COMDAT
; _this$ = ecx

; 33   : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 34   : 			const VertexElement *pelement = m_VertFormat.getElementBySemantic(ves);

	push	-1
	mov	eax, DWORD PTR _ves$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	?getElementBySemantic@VertexFormat@Ogre@@QBEPBVVertexElement@2@W4VertexElementSemantic@2@H@Z ; Ogre::VertexFormat::getElementBySemantic
	mov	DWORD PTR _pelement$[ebp], eax

; 35   : 			if(pelement == NULL) return NULL;

	cmp	DWORD PTR _pelement$[ebp], 0
	jne	SHORT $LN1@getVertexE
	xor	eax, eax
	jmp	SHORT $LN2@getVertexE
$LN1@getVertexE:

; 36   : 
; 37   : 			uint offset = (uint)ivert*m_Stride + pelement->m_Offset;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _ivert$[ebp]
	imul	edx, DWORD PTR [ecx+68]
	mov	eax, DWORD PTR _pelement$[ebp]
	mov	ecx, DWORD PTR [eax]
	shr	ecx, 4
	and	ecx, 255				; 000000ffH
	add	edx, ecx
	mov	DWORD PTR _offset$[ebp], edx

; 38   : 			return &m_VertData[0] + offset;

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 72					; 00000048H
	call	??A?$vector@DV?$allocator@D@std@@@std@@QAEAADI@Z ; std::vector<char,std::allocator<char> >::operator[]
	add	eax, DWORD PTR _offset$[ebp]
$LN2@getVertexE:

; 39   : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?getVertexElement@VertexData@Ogre@@QAEPADIW4VertexElementSemantic@2@@Z ENDP ; Ogre::VertexData::getVertexElement
_TEXT	ENDS
PUBLIC	?getPosition@VertexData@Ogre@@QAEPADI@Z		; Ogre::VertexData::getPosition
; Function compile flags: /Odtp
;	COMDAT ?getPosition@VertexData@Ogre@@QAEPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_ivert$ = 8						; size = 4
?getPosition@VertexData@Ogre@@QAEPADI@Z PROC		; Ogre::VertexData::getPosition, COMDAT
; _this$ = ecx

; 42   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 43   : 			return getVertexElement(ivert, VES_POSITION);

	push	1
	mov	eax, DWORD PTR _ivert$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getVertexElement@VertexData@Ogre@@QAEPADIW4VertexElementSemantic@2@@Z ; Ogre::VertexData::getVertexElement

; 44   : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?getPosition@VertexData@Ogre@@QAEPADI@Z ENDP		; Ogre::VertexData::getPosition
_TEXT	ENDS
PUBLIC	?getNormal@VertexData@Ogre@@QAEPADI@Z		; Ogre::VertexData::getNormal
; Function compile flags: /Odtp
;	COMDAT ?getNormal@VertexData@Ogre@@QAEPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_ivert$ = 8						; size = 4
?getNormal@VertexData@Ogre@@QAEPADI@Z PROC		; Ogre::VertexData::getNormal, COMDAT
; _this$ = ecx

; 47   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 48   : 			return getVertexElement(ivert, VES_NORMAL);

	push	4
	mov	eax, DWORD PTR _ivert$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getVertexElement@VertexData@Ogre@@QAEPADIW4VertexElementSemantic@2@@Z ; Ogre::VertexData::getVertexElement

; 49   : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?getNormal@VertexData@Ogre@@QAEPADI@Z ENDP		; Ogre::VertexData::getNormal
_TEXT	ENDS
PUBLIC	?getColor@VertexData@Ogre@@QAEPADI@Z		; Ogre::VertexData::getColor
; Function compile flags: /Odtp
;	COMDAT ?getColor@VertexData@Ogre@@QAEPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_ivert$ = 8						; size = 4
?getColor@VertexData@Ogre@@QAEPADI@Z PROC		; Ogre::VertexData::getColor, COMDAT
; _this$ = ecx

; 52   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 53   : 			return getVertexElement(ivert, VES_COLOR);

	push	5
	mov	eax, DWORD PTR _ivert$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getVertexElement@VertexData@Ogre@@QAEPADIW4VertexElementSemantic@2@@Z ; Ogre::VertexData::getVertexElement

; 54   : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?getColor@VertexData@Ogre@@QAEPADI@Z ENDP		; Ogre::VertexData::getColor
_TEXT	ENDS
PUBLIC	??4VertexData@Ogre@@QAEAAV01@ABV01@@Z		; Ogre::VertexData::operator=
; Function compile flags: /Odtp
;	COMDAT ??4VertexData@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4VertexData@Ogre@@QAEAAV01@ABV01@@Z PROC		; Ogre::VertexData::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4VertexBuffer@Ogre@@QAEAAV01@ABV01@@Z
	mov	ecx, DWORD PTR ___that$[ebp]
	add	ecx, 16					; 00000010H
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??4VertexFormat@Ogre@@QAEAAV01@ABV01@@Z	; Ogre::VertexFormat::operator=
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 40					; 00000028H
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 40					; 00000028H
	call	??4Vector3@Ogre@@QAEABV01@ABV01@@Z	; Ogre::Vector3::operator=
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 52					; 00000034H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 52					; 00000034H
	call	??4Vector3@Ogre@@QAEABV01@ABV01@@Z	; Ogre::Vector3::operator=
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+64]
	mov	DWORD PTR [ecx+64], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+68]
	mov	DWORD PTR [ecx+68], eax
	mov	ecx, DWORD PTR ___that$[ebp]
	add	ecx, 72					; 00000048H
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 72					; 00000048H
	call	??4?$vector@DV?$allocator@D@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<char,std::allocator<char> >::operator=
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+96]
	mov	DWORD PTR [edx+96], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+100]
	mov	DWORD PTR [edx+100], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4VertexData@Ogre@@QAEAAV01@ABV01@@Z ENDP		; Ogre::VertexData::operator=
_TEXT	ENDS
PUBLIC	?getRTTI@IndexData@Ogre@@UBEPBVRuntimeClass@2@XZ ; Ogre::IndexData::getRTTI
EXTRN	?m_RTTI@IndexData@Ogre@@2VRuntimeClass@2@B:BYTE	; Ogre::IndexData::m_RTTI
; Function compile flags: /Odtp
;	COMDAT ?getRTTI@IndexData@Ogre@@UBEPBVRuntimeClass@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getRTTI@IndexData@Ogre@@UBEPBVRuntimeClass@2@XZ PROC	; Ogre::IndexData::getRTTI, COMDAT
; _this$ = ecx

; 91   : 		DECLARE_RTTI(IndexData)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, OFFSET ?m_RTTI@IndexData@Ogre@@2VRuntimeClass@2@B ; Ogre::IndexData::m_RTTI
	mov	esp, ebp
	pop	ebp
	ret	0
?getRTTI@IndexData@Ogre@@UBEPBVRuntimeClass@2@XZ ENDP	; Ogre::IndexData::getRTTI
_TEXT	ENDS
PUBLIC	?newObject@IndexData@Ogre@@SAPAVBaseObject@2@XZ	; Ogre::IndexData::newObject
EXTRN	??0IndexData@Ogre@@QAE@XZ:PROC			; Ogre::IndexData::IndexData
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?newObject@IndexData@Ogre@@SAPAVBaseObject@2@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?newObject@IndexData@Ogre@@SAPAVBaseObject@2@XZ$0
__ehfuncinfo$?newObject@IndexData@Ogre@@SAPAVBaseObject@2@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?newObject@IndexData@Ogre@@SAPAVBaseObject@2@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?newObject@IndexData@Ogre@@SAPAVBaseObject@2@XZ
_TEXT	SEGMENT
tv75 = -24						; size = 4
$T94497 = -20						; size = 4
$T94496 = -16						; size = 4
__$EHRec$ = -12						; size = 12
?newObject@IndexData@Ogre@@SAPAVBaseObject@2@XZ PROC	; Ogre::IndexData::newObject, COMDAT

; 91   : 		DECLARE_RTTI(IndexData)

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?newObject@IndexData@Ogre@@SAPAVBaseObject@2@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 12					; 0000000cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	push	52					; 00000034H
	call	??2MemoryDelegation@Ogre@@SAPAXI@Z	; Ogre::MemoryDelegation::operator new
	add	esp, 4
	mov	DWORD PTR $T94497[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T94497[ebp], 0
	je	SHORT $LN3@newObject@9
	mov	ecx, DWORD PTR $T94497[ebp]
	call	??0IndexData@Ogre@@QAE@XZ		; Ogre::IndexData::IndexData
	mov	DWORD PTR tv75[ebp], eax
	jmp	SHORT $LN4@newObject@9
$LN3@newObject@9:
	mov	DWORD PTR tv75[ebp], 0
$LN4@newObject@9:
	mov	eax, DWORD PTR tv75[ebp]
	mov	DWORD PTR $T94496[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR $T94496[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?newObject@IndexData@Ogre@@SAPAVBaseObject@2@XZ$0:
	push	52					; 00000034H
	mov	eax, DWORD PTR $T94497[ebp]
	push	eax
	call	??3MemoryDelegation@Ogre@@SAXPAXI@Z	; Ogre::MemoryDelegation::operator delete
	add	esp, 8
	ret	0
__ehhandler$?newObject@IndexData@Ogre@@SAPAVBaseObject@2@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?newObject@IndexData@Ogre@@SAPAVBaseObject@2@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?newObject@IndexData@Ogre@@SAPAVBaseObject@2@XZ ENDP	; Ogre::IndexData::newObject
PUBLIC	?size@?$vector@GV?$allocator@G@std@@@std@@QBEIXZ ; std::vector<unsigned short,std::allocator<unsigned short> >::size
PUBLIC	?isUsed@IndexData@Ogre@@QAE_NXZ			; Ogre::IndexData::isUsed
; Function compile flags: /Odtp
;	COMDAT ?isUsed@IndexData@Ogre@@QAE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?isUsed@IndexData@Ogre@@QAE_NXZ PROC			; Ogre::IndexData::isUsed, COMDAT
; _this$ = ecx

; 101  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 102  : 			return m_IndexData.size() > 0;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	?size@?$vector@GV?$allocator@G@std@@@std@@QBEIXZ ; std::vector<unsigned short,std::allocator<unsigned short> >::size
	xor	ecx, ecx
	cmp	ecx, eax
	sbb	eax, eax
	neg	eax

; 103  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?isUsed@IndexData@Ogre@@QAE_NXZ ENDP			; Ogre::IndexData::isUsed
_TEXT	ENDS
PUBLIC	?getNumIndex@IndexData@Ogre@@QAEIXZ		; Ogre::IndexData::getNumIndex
; Function compile flags: /Odtp
;	COMDAT ?getNumIndex@IndexData@Ogre@@QAEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getNumIndex@IndexData@Ogre@@QAEIXZ PROC		; Ogre::IndexData::getNumIndex, COMDAT
; _this$ = ecx

; 106  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 107  : 			return m_IndexData.size();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	?size@?$vector@GV?$allocator@G@std@@@std@@QBEIXZ ; std::vector<unsigned short,std::allocator<unsigned short> >::size

; 108  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?getNumIndex@IndexData@Ogre@@QAEIXZ ENDP		; Ogre::IndexData::getNumIndex
_TEXT	ENDS
PUBLIC	??4?$vector@GV?$allocator@G@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<unsigned short,std::allocator<unsigned short> >::operator=
PUBLIC	??4IndexData@Ogre@@QAEAAV01@ABV01@@Z		; Ogre::IndexData::operator=
; Function compile flags: /Odtp
;	COMDAT ??4IndexData@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4IndexData@Ogre@@QAEAAV01@ABV01@@Z PROC		; Ogre::IndexData::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4IndexBuffer@Ogre@@QAEAAV01@ABV01@@Z
	mov	ecx, DWORD PTR ___that$[ebp]
	add	ecx, 24					; 00000018H
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 24					; 00000018H
	call	??4?$vector@GV?$allocator@G@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<unsigned short,std::allocator<unsigned short> >::operator=
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	mov	DWORD PTR [edx+48], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4IndexData@Ogre@@QAEAAV01@ABV01@@Z ENDP		; Ogre::IndexData::operator=
_TEXT	ENDS
PUBLIC	?getRTTI@DynamicVertexBuffer@Ogre@@UBEPBVRuntimeClass@2@XZ ; Ogre::DynamicVertexBuffer::getRTTI
EXTRN	?m_RTTI@DynamicVertexBuffer@Ogre@@2VRuntimeClass@2@B:BYTE ; Ogre::DynamicVertexBuffer::m_RTTI
; Function compile flags: /Odtp
;	COMDAT ?getRTTI@DynamicVertexBuffer@Ogre@@UBEPBVRuntimeClass@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getRTTI@DynamicVertexBuffer@Ogre@@UBEPBVRuntimeClass@2@XZ PROC ; Ogre::DynamicVertexBuffer::getRTTI, COMDAT
; _this$ = ecx

; 126  : 		DECLARE_RTTI(DynamicVertexBuffer)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, OFFSET ?m_RTTI@DynamicVertexBuffer@Ogre@@2VRuntimeClass@2@B ; Ogre::DynamicVertexBuffer::m_RTTI
	mov	esp, ebp
	pop	ebp
	ret	0
?getRTTI@DynamicVertexBuffer@Ogre@@UBEPBVRuntimeClass@2@XZ ENDP ; Ogre::DynamicVertexBuffer::getRTTI
_TEXT	ENDS
PUBLIC	??0DynamicVertexBuffer@Ogre@@QAE@XZ		; Ogre::DynamicVertexBuffer::DynamicVertexBuffer
PUBLIC	?newObject@DynamicVertexBuffer@Ogre@@SAPAVBaseObject@2@XZ ; Ogre::DynamicVertexBuffer::newObject
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?newObject@DynamicVertexBuffer@Ogre@@SAPAVBaseObject@2@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?newObject@DynamicVertexBuffer@Ogre@@SAPAVBaseObject@2@XZ$0
__ehfuncinfo$?newObject@DynamicVertexBuffer@Ogre@@SAPAVBaseObject@2@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?newObject@DynamicVertexBuffer@Ogre@@SAPAVBaseObject@2@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?newObject@DynamicVertexBuffer@Ogre@@SAPAVBaseObject@2@XZ
_TEXT	SEGMENT
tv75 = -24						; size = 4
$T94518 = -20						; size = 4
$T94517 = -16						; size = 4
__$EHRec$ = -12						; size = 12
?newObject@DynamicVertexBuffer@Ogre@@SAPAVBaseObject@2@XZ PROC ; Ogre::DynamicVertexBuffer::newObject, COMDAT

; 126  : 		DECLARE_RTTI(DynamicVertexBuffer)

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?newObject@DynamicVertexBuffer@Ogre@@SAPAVBaseObject@2@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 12					; 0000000cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	push	56					; 00000038H
	call	??2MemoryDelegation@Ogre@@SAPAXI@Z	; Ogre::MemoryDelegation::operator new
	add	esp, 4
	mov	DWORD PTR $T94518[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T94518[ebp], 0
	je	SHORT $LN3@newObject@10
	mov	ecx, DWORD PTR $T94518[ebp]
	call	??0DynamicVertexBuffer@Ogre@@QAE@XZ	; Ogre::DynamicVertexBuffer::DynamicVertexBuffer
	mov	DWORD PTR tv75[ebp], eax
	jmp	SHORT $LN4@newObject@10
$LN3@newObject@10:
	mov	DWORD PTR tv75[ebp], 0
$LN4@newObject@10:
	mov	eax, DWORD PTR tv75[ebp]
	mov	DWORD PTR $T94517[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR $T94517[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?newObject@DynamicVertexBuffer@Ogre@@SAPAVBaseObject@2@XZ$0:
	push	56					; 00000038H
	mov	eax, DWORD PTR $T94518[ebp]
	push	eax
	call	??3MemoryDelegation@Ogre@@SAXPAXI@Z	; Ogre::MemoryDelegation::operator delete
	add	esp, 8
	ret	0
__ehhandler$?newObject@DynamicVertexBuffer@Ogre@@SAPAVBaseObject@2@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?newObject@DynamicVertexBuffer@Ogre@@SAPAVBaseObject@2@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?newObject@DynamicVertexBuffer@Ogre@@SAPAVBaseObject@2@XZ ENDP ; Ogre::DynamicVertexBuffer::newObject
PUBLIC	??_7DynamicVertexBuffer@Ogre@@6B@		; Ogre::DynamicVertexBuffer::`vftable'
PUBLIC	??_R4DynamicVertexBuffer@Ogre@@6B@		; Ogre::DynamicVertexBuffer::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVDynamicVertexBuffer@Ogre@@@8		; Ogre::DynamicVertexBuffer `RTTI Type Descriptor'
PUBLIC	??_R3DynamicVertexBuffer@Ogre@@8		; Ogre::DynamicVertexBuffer::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2DynamicVertexBuffer@Ogre@@8		; Ogre::DynamicVertexBuffer::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@DynamicVertexBuffer@Ogre@@8	; Ogre::DynamicVertexBuffer::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_EDynamicVertexBuffer@Ogre@@EAEPAXI@Z		; Ogre::DynamicVertexBuffer::`vector deleting destructor'
EXTRN	??0VertexFormat@Ogre@@QAE@XZ:PROC		; Ogre::VertexFormat::VertexFormat
EXTRN	?getHBuf@DynamicVertexBuffer@Ogre@@UAEPAVHardwareVertexBuffer@2@XZ:PROC ; Ogre::DynamicVertexBuffer::getHBuf
;	COMDAT ??_R1A@?0A@EA@DynamicVertexBuffer@Ogre@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@DynamicVertexBuffer@Ogre@@8 DD FLAT:??_R0?AVDynamicVertexBuffer@Ogre@@@8 ; Ogre::DynamicVertexBuffer::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	04H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3DynamicVertexBuffer@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R2DynamicVertexBuffer@Ogre@@8
rdata$r	SEGMENT
??_R2DynamicVertexBuffer@Ogre@@8 DD FLAT:??_R1A@?0A@EA@DynamicVertexBuffer@Ogre@@8 ; Ogre::DynamicVertexBuffer::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@VertexBuffer@Ogre@@8
	DD	FLAT:??_R1A@?0A@EA@Resource@Ogre@@8
	DD	FLAT:??_R1A@?0A@EA@BaseObject@Ogre@@8
	DD	FLAT:??_R13?0A@EA@MemoryDelegation@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R3DynamicVertexBuffer@Ogre@@8
rdata$r	SEGMENT
??_R3DynamicVertexBuffer@Ogre@@8 DD 00H			; Ogre::DynamicVertexBuffer::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	05H
	DD	FLAT:??_R2DynamicVertexBuffer@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVDynamicVertexBuffer@Ogre@@@8
_DATA	SEGMENT
??_R0?AVDynamicVertexBuffer@Ogre@@@8 DD FLAT:??_7type_info@@6B@ ; Ogre::DynamicVertexBuffer `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVDynamicVertexBuffer@Ogre@@', 00H
_DATA	ENDS
;	COMDAT ??_R4DynamicVertexBuffer@Ogre@@6B@
rdata$r	SEGMENT
??_R4DynamicVertexBuffer@Ogre@@6B@ DD 00H		; Ogre::DynamicVertexBuffer::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVDynamicVertexBuffer@Ogre@@@8
	DD	FLAT:??_R3DynamicVertexBuffer@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_7DynamicVertexBuffer@Ogre@@6B@
CONST	SEGMENT
??_7DynamicVertexBuffer@Ogre@@6B@ DD FLAT:??_R4DynamicVertexBuffer@Ogre@@6B@ ; Ogre::DynamicVertexBuffer::`vftable'
	DD	FLAT:?getRTTI@DynamicVertexBuffer@Ogre@@UBEPBVRuntimeClass@2@XZ
	DD	FLAT:?release@Resource@Ogre@@UAEXXZ
	DD	FLAT:?addRef@Resource@Ogre@@UAEXXZ
	DD	FLAT:?getRefCount@Resource@Ogre@@UAEHXZ
	DD	FLAT:?_serialize@BaseObject@Ogre@@UAEXAAVArchive@2@H@Z
	DD	FLAT:??_EDynamicVertexBuffer@Ogre@@EAEPAXI@Z
	DD	FLAT:?deleteThis@BaseObject@Ogre@@MAEXXZ
	DD	FLAT:?getHBuf@DynamicVertexBuffer@Ogre@@UAEPAVHardwareVertexBuffer@2@XZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0DynamicVertexBuffer@Ogre@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0DynamicVertexBuffer@Ogre@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0DynamicVertexBuffer@Ogre@@QAE@XZ$1
__ehfuncinfo$??0DynamicVertexBuffer@Ogre@@QAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0DynamicVertexBuffer@Ogre@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0DynamicVertexBuffer@Ogre@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0DynamicVertexBuffer@Ogre@@QAE@XZ PROC		; Ogre::DynamicVertexBuffer::DynamicVertexBuffer, COMDAT
; _this$ = ecx

; 128  : 		DynamicVertexBuffer()

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0DynamicVertexBuffer@Ogre@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0VertexBuffer@Ogre@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7DynamicVertexBuffer@Ogre@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??0VertexFormat@Ogre@@QAE@XZ		; Ogre::VertexFormat::VertexFormat
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 129  : 		{
; 130  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0DynamicVertexBuffer@Ogre@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1VertexBuffer@Ogre@@UAE@XZ
__unwindfunclet$??0DynamicVertexBuffer@Ogre@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	jmp	??1VertexFormat@Ogre@@QAE@XZ		; Ogre::VertexFormat::~VertexFormat
__ehhandler$??0DynamicVertexBuffer@Ogre@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0DynamicVertexBuffer@Ogre@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0DynamicVertexBuffer@Ogre@@QAE@XZ ENDP		; Ogre::DynamicVertexBuffer::DynamicVertexBuffer
PUBLIC	?unlock@DynamicVertexBuffer@Ogre@@QAEXXZ	; Ogre::DynamicVertexBuffer::unlock
; Function compile flags: /Odtp
;	COMDAT ?unlock@DynamicVertexBuffer@Ogre@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?unlock@DynamicVertexBuffer@Ogre@@QAEXXZ PROC		; Ogre::DynamicVertexBuffer::unlock, COMDAT
; _this$ = ecx

; 137  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 138  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?unlock@DynamicVertexBuffer@Ogre@@QAEXXZ ENDP		; Ogre::DynamicVertexBuffer::unlock
_TEXT	ENDS
PUBLIC	??1DynamicVertexBuffer@Ogre@@EAE@XZ		; Ogre::DynamicVertexBuffer::~DynamicVertexBuffer
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1DynamicVertexBuffer@Ogre@@EAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1DynamicVertexBuffer@Ogre@@EAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1DynamicVertexBuffer@Ogre@@EAE@XZ$1
__ehfuncinfo$??1DynamicVertexBuffer@Ogre@@EAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??1DynamicVertexBuffer@Ogre@@EAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1DynamicVertexBuffer@Ogre@@EAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1DynamicVertexBuffer@Ogre@@EAE@XZ PROC		; Ogre::DynamicVertexBuffer::~DynamicVertexBuffer, COMDAT
; _this$ = ecx

; 144  : 		{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1DynamicVertexBuffer@Ogre@@EAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7DynamicVertexBuffer@Ogre@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 145  : 		}

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??1VertexFormat@Ogre@@QAE@XZ		; Ogre::VertexFormat::~VertexFormat
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1VertexBuffer@Ogre@@UAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1DynamicVertexBuffer@Ogre@@EAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1VertexBuffer@Ogre@@UAE@XZ
__unwindfunclet$??1DynamicVertexBuffer@Ogre@@EAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	jmp	??1VertexFormat@Ogre@@QAE@XZ		; Ogre::VertexFormat::~VertexFormat
__ehhandler$??1DynamicVertexBuffer@Ogre@@EAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1DynamicVertexBuffer@Ogre@@EAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1DynamicVertexBuffer@Ogre@@EAE@XZ ENDP		; Ogre::DynamicVertexBuffer::~DynamicVertexBuffer
PUBLIC	??0DynamicVertexBuffer@Ogre@@QAE@ABV01@@Z	; Ogre::DynamicVertexBuffer::DynamicVertexBuffer
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0DynamicVertexBuffer@Ogre@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0DynamicVertexBuffer@Ogre@@QAE@ABV01@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0DynamicVertexBuffer@Ogre@@QAE@ABV01@@Z$1
__ehfuncinfo$??0DynamicVertexBuffer@Ogre@@QAE@ABV01@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0DynamicVertexBuffer@Ogre@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0DynamicVertexBuffer@Ogre@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0DynamicVertexBuffer@Ogre@@QAE@ABV01@@Z PROC		; Ogre::DynamicVertexBuffer::DynamicVertexBuffer, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0DynamicVertexBuffer@Ogre@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0VertexBuffer@Ogre@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7DynamicVertexBuffer@Ogre@@6B@
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 16					; 00000010H
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??0VertexFormat@Ogre@@QAE@ABV01@@Z	; Ogre::VertexFormat::VertexFormat
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	mov	DWORD PTR [eax+40], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+44]
	mov	DWORD PTR [eax+44], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+48]
	mov	DWORD PTR [eax+48], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+52]
	mov	DWORD PTR [eax+52], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0DynamicVertexBuffer@Ogre@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1VertexBuffer@Ogre@@UAE@XZ
__unwindfunclet$??0DynamicVertexBuffer@Ogre@@QAE@ABV01@@Z$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	jmp	??1VertexFormat@Ogre@@QAE@XZ		; Ogre::VertexFormat::~VertexFormat
__ehhandler$??0DynamicVertexBuffer@Ogre@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0DynamicVertexBuffer@Ogre@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0DynamicVertexBuffer@Ogre@@QAE@ABV01@@Z ENDP		; Ogre::DynamicVertexBuffer::DynamicVertexBuffer
PUBLIC	??4DynamicVertexBuffer@Ogre@@QAEAAV01@ABV01@@Z	; Ogre::DynamicVertexBuffer::operator=
; Function compile flags: /Odtp
;	COMDAT ??4DynamicVertexBuffer@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4DynamicVertexBuffer@Ogre@@QAEAAV01@ABV01@@Z PROC	; Ogre::DynamicVertexBuffer::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4VertexBuffer@Ogre@@QAEAAV01@ABV01@@Z
	mov	ecx, DWORD PTR ___that$[ebp]
	add	ecx, 16					; 00000010H
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??4VertexFormat@Ogre@@QAEAAV01@ABV01@@Z	; Ogre::VertexFormat::operator=
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	DWORD PTR [edx+40], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+44]
	mov	DWORD PTR [edx+44], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+48]
	mov	DWORD PTR [edx+48], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+52]
	mov	DWORD PTR [edx+52], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4DynamicVertexBuffer@Ogre@@QAEAAV01@ABV01@@Z ENDP	; Ogre::DynamicVertexBuffer::operator=
_TEXT	ENDS
PUBLIC	??_GDynamicVertexBuffer@Ogre@@EAEPAXI@Z		; Ogre::DynamicVertexBuffer::`scalar deleting destructor'
; Function compile flags: /Odtp
;	COMDAT ??_GDynamicVertexBuffer@Ogre@@EAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GDynamicVertexBuffer@Ogre@@EAEPAXI@Z PROC		; Ogre::DynamicVertexBuffer::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1DynamicVertexBuffer@Ogre@@EAE@XZ	; Ogre::DynamicVertexBuffer::~DynamicVertexBuffer
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@26
	push	56					; 00000038H
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3MemoryDelegation@Ogre@@SAXPAXI@Z	; Ogre::MemoryDelegation::operator delete
	add	esp, 8
$LN1@scalar@26:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GDynamicVertexBuffer@Ogre@@EAEPAXI@Z ENDP		; Ogre::DynamicVertexBuffer::`scalar deleting destructor'
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_EDynamicVertexBuffer@Ogre@@EAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_EDynamicVertexBuffer@Ogre@@EAEPAXI@Z PROC		; Ogre::DynamicVertexBuffer::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 2
	je	SHORT $LN3@vector@24
	push	OFFSET ??1DynamicVertexBuffer@Ogre@@EAE@XZ ; Ogre::DynamicVertexBuffer::~DynamicVertexBuffer
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx-4]
	push	edx
	push	56					; 00000038H
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??_M@YGXPAXIHP6EX0@Z@Z
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN2@vector@24
	push	56					; 00000038H
	mov	edx, DWORD PTR _this$[ebp]
	sub	edx, 4
	push	edx
	call	??_VMemoryDelegation@Ogre@@SAXPAXI@Z	; Ogre::MemoryDelegation::operator delete[]
	add	esp, 8
$LN2@vector@24:
	mov	eax, DWORD PTR _this$[ebp]
	sub	eax, 4
	jmp	SHORT $LN4@vector@24
$LN3@vector@24:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1DynamicVertexBuffer@Ogre@@EAE@XZ	; Ogre::DynamicVertexBuffer::~DynamicVertexBuffer
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@vector@24
	push	56					; 00000038H
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3MemoryDelegation@Ogre@@SAXPAXI@Z	; Ogre::MemoryDelegation::operator delete
	add	esp, 8
$LN1@vector@24:
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector@24:
	mov	esp, ebp
	pop	ebp
	ret	4
??_EDynamicVertexBuffer@Ogre@@EAEPAXI@Z ENDP		; Ogre::DynamicVertexBuffer::`vector deleting destructor'
_TEXT	ENDS
PUBLIC	?getRTTI@DynamicIndexBuffer@Ogre@@UBEPBVRuntimeClass@2@XZ ; Ogre::DynamicIndexBuffer::getRTTI
EXTRN	?m_RTTI@DynamicIndexBuffer@Ogre@@2VRuntimeClass@2@B:BYTE ; Ogre::DynamicIndexBuffer::m_RTTI
; Function compile flags: /Odtp
;	COMDAT ?getRTTI@DynamicIndexBuffer@Ogre@@UBEPBVRuntimeClass@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getRTTI@DynamicIndexBuffer@Ogre@@UBEPBVRuntimeClass@2@XZ PROC ; Ogre::DynamicIndexBuffer::getRTTI, COMDAT
; _this$ = ecx

; 157  : 		DECLARE_RTTI(DynamicIndexBuffer)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, OFFSET ?m_RTTI@DynamicIndexBuffer@Ogre@@2VRuntimeClass@2@B ; Ogre::DynamicIndexBuffer::m_RTTI
	mov	esp, ebp
	pop	ebp
	ret	0
?getRTTI@DynamicIndexBuffer@Ogre@@UBEPBVRuntimeClass@2@XZ ENDP ; Ogre::DynamicIndexBuffer::getRTTI
_TEXT	ENDS
PUBLIC	??0DynamicIndexBuffer@Ogre@@QAE@XZ		; Ogre::DynamicIndexBuffer::DynamicIndexBuffer
PUBLIC	?newObject@DynamicIndexBuffer@Ogre@@SAPAVBaseObject@2@XZ ; Ogre::DynamicIndexBuffer::newObject
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?newObject@DynamicIndexBuffer@Ogre@@SAPAVBaseObject@2@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?newObject@DynamicIndexBuffer@Ogre@@SAPAVBaseObject@2@XZ$0
__ehfuncinfo$?newObject@DynamicIndexBuffer@Ogre@@SAPAVBaseObject@2@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?newObject@DynamicIndexBuffer@Ogre@@SAPAVBaseObject@2@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?newObject@DynamicIndexBuffer@Ogre@@SAPAVBaseObject@2@XZ
_TEXT	SEGMENT
tv75 = -24						; size = 4
$T94571 = -20						; size = 4
$T94570 = -16						; size = 4
__$EHRec$ = -12						; size = 12
?newObject@DynamicIndexBuffer@Ogre@@SAPAVBaseObject@2@XZ PROC ; Ogre::DynamicIndexBuffer::newObject, COMDAT

; 157  : 		DECLARE_RTTI(DynamicIndexBuffer)

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?newObject@DynamicIndexBuffer@Ogre@@SAPAVBaseObject@2@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 12					; 0000000cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	push	36					; 00000024H
	call	??2MemoryDelegation@Ogre@@SAPAXI@Z	; Ogre::MemoryDelegation::operator new
	add	esp, 4
	mov	DWORD PTR $T94571[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T94571[ebp], 0
	je	SHORT $LN3@newObject@11
	mov	ecx, DWORD PTR $T94571[ebp]
	call	??0DynamicIndexBuffer@Ogre@@QAE@XZ	; Ogre::DynamicIndexBuffer::DynamicIndexBuffer
	mov	DWORD PTR tv75[ebp], eax
	jmp	SHORT $LN4@newObject@11
$LN3@newObject@11:
	mov	DWORD PTR tv75[ebp], 0
$LN4@newObject@11:
	mov	eax, DWORD PTR tv75[ebp]
	mov	DWORD PTR $T94570[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR $T94570[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?newObject@DynamicIndexBuffer@Ogre@@SAPAVBaseObject@2@XZ$0:
	push	36					; 00000024H
	mov	eax, DWORD PTR $T94571[ebp]
	push	eax
	call	??3MemoryDelegation@Ogre@@SAXPAXI@Z	; Ogre::MemoryDelegation::operator delete
	add	esp, 8
	ret	0
__ehhandler$?newObject@DynamicIndexBuffer@Ogre@@SAPAVBaseObject@2@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?newObject@DynamicIndexBuffer@Ogre@@SAPAVBaseObject@2@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?newObject@DynamicIndexBuffer@Ogre@@SAPAVBaseObject@2@XZ ENDP ; Ogre::DynamicIndexBuffer::newObject
PUBLIC	??_7DynamicIndexBuffer@Ogre@@6B@		; Ogre::DynamicIndexBuffer::`vftable'
PUBLIC	??_R4DynamicIndexBuffer@Ogre@@6B@		; Ogre::DynamicIndexBuffer::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVDynamicIndexBuffer@Ogre@@@8		; Ogre::DynamicIndexBuffer `RTTI Type Descriptor'
PUBLIC	??_R3DynamicIndexBuffer@Ogre@@8			; Ogre::DynamicIndexBuffer::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2DynamicIndexBuffer@Ogre@@8			; Ogre::DynamicIndexBuffer::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@DynamicIndexBuffer@Ogre@@8	; Ogre::DynamicIndexBuffer::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_EDynamicIndexBuffer@Ogre@@EAEPAXI@Z		; Ogre::DynamicIndexBuffer::`vector deleting destructor'
EXTRN	?getHBuf@DynamicIndexBuffer@Ogre@@UAEPAVHardwareIndexBuffer@2@XZ:PROC ; Ogre::DynamicIndexBuffer::getHBuf
;	COMDAT ??_R1A@?0A@EA@DynamicIndexBuffer@Ogre@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@DynamicIndexBuffer@Ogre@@8 DD FLAT:??_R0?AVDynamicIndexBuffer@Ogre@@@8 ; Ogre::DynamicIndexBuffer::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	04H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3DynamicIndexBuffer@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R2DynamicIndexBuffer@Ogre@@8
rdata$r	SEGMENT
??_R2DynamicIndexBuffer@Ogre@@8 DD FLAT:??_R1A@?0A@EA@DynamicIndexBuffer@Ogre@@8 ; Ogre::DynamicIndexBuffer::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@IndexBuffer@Ogre@@8
	DD	FLAT:??_R1A@?0A@EA@Resource@Ogre@@8
	DD	FLAT:??_R1A@?0A@EA@BaseObject@Ogre@@8
	DD	FLAT:??_R13?0A@EA@MemoryDelegation@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R3DynamicIndexBuffer@Ogre@@8
rdata$r	SEGMENT
??_R3DynamicIndexBuffer@Ogre@@8 DD 00H			; Ogre::DynamicIndexBuffer::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	05H
	DD	FLAT:??_R2DynamicIndexBuffer@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVDynamicIndexBuffer@Ogre@@@8
_DATA	SEGMENT
??_R0?AVDynamicIndexBuffer@Ogre@@@8 DD FLAT:??_7type_info@@6B@ ; Ogre::DynamicIndexBuffer `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVDynamicIndexBuffer@Ogre@@', 00H
_DATA	ENDS
;	COMDAT ??_R4DynamicIndexBuffer@Ogre@@6B@
rdata$r	SEGMENT
??_R4DynamicIndexBuffer@Ogre@@6B@ DD 00H		; Ogre::DynamicIndexBuffer::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVDynamicIndexBuffer@Ogre@@@8
	DD	FLAT:??_R3DynamicIndexBuffer@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_7DynamicIndexBuffer@Ogre@@6B@
CONST	SEGMENT
??_7DynamicIndexBuffer@Ogre@@6B@ DD FLAT:??_R4DynamicIndexBuffer@Ogre@@6B@ ; Ogre::DynamicIndexBuffer::`vftable'
	DD	FLAT:?getRTTI@DynamicIndexBuffer@Ogre@@UBEPBVRuntimeClass@2@XZ
	DD	FLAT:?release@Resource@Ogre@@UAEXXZ
	DD	FLAT:?addRef@Resource@Ogre@@UAEXXZ
	DD	FLAT:?getRefCount@Resource@Ogre@@UAEHXZ
	DD	FLAT:?_serialize@BaseObject@Ogre@@UAEXAAVArchive@2@H@Z
	DD	FLAT:??_EDynamicIndexBuffer@Ogre@@EAEPAXI@Z
	DD	FLAT:?deleteThis@BaseObject@Ogre@@MAEXXZ
	DD	FLAT:?getHBuf@DynamicIndexBuffer@Ogre@@UAEPAVHardwareIndexBuffer@2@XZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0DynamicIndexBuffer@Ogre@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0DynamicIndexBuffer@Ogre@@QAE@XZ$0
__ehfuncinfo$??0DynamicIndexBuffer@Ogre@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0DynamicIndexBuffer@Ogre@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0DynamicIndexBuffer@Ogre@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0DynamicIndexBuffer@Ogre@@QAE@XZ PROC			; Ogre::DynamicIndexBuffer::DynamicIndexBuffer, COMDAT
; _this$ = ecx

; 159  : 		DynamicIndexBuffer()

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0DynamicIndexBuffer@Ogre@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0IndexBuffer@Ogre@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7DynamicIndexBuffer@Ogre@@6B@

; 160  : 		{
; 161  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0DynamicIndexBuffer@Ogre@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1IndexBuffer@Ogre@@UAE@XZ
__ehhandler$??0DynamicIndexBuffer@Ogre@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0DynamicIndexBuffer@Ogre@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0DynamicIndexBuffer@Ogre@@QAE@XZ ENDP			; Ogre::DynamicIndexBuffer::DynamicIndexBuffer
PUBLIC	?unlock@DynamicIndexBuffer@Ogre@@QAEXXZ		; Ogre::DynamicIndexBuffer::unlock
; Function compile flags: /Odtp
;	COMDAT ?unlock@DynamicIndexBuffer@Ogre@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?unlock@DynamicIndexBuffer@Ogre@@QAEXXZ PROC		; Ogre::DynamicIndexBuffer::unlock, COMDAT
; _this$ = ecx

; 168  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 169  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?unlock@DynamicIndexBuffer@Ogre@@QAEXXZ ENDP		; Ogre::DynamicIndexBuffer::unlock
_TEXT	ENDS
PUBLIC	?reset@DynamicIndexBuffer@Ogre@@QAEXPAVDynamicBufferPool@2@II@Z ; Ogre::DynamicIndexBuffer::reset
; Function compile flags: /Odtp
;	COMDAT ?reset@DynamicIndexBuffer@Ogre@@QAEXPAVDynamicBufferPool@2@II@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pool$ = 8						; size = 4
_offset$ = 12						; size = 4
_nindex$ = 16						; size = 4
?reset@DynamicIndexBuffer@Ogre@@QAEXPAVDynamicBufferPool@2@II@Z PROC ; Ogre::DynamicIndexBuffer::reset, COMDAT
; _this$ = ecx

; 172  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 173  : 			m_pPool = pool;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pool$[ebp]
	mov	DWORD PTR [eax+24], ecx

; 174  : 			m_PoolOffset = offset;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _offset$[ebp]
	mov	DWORD PTR [edx+28], eax

; 175  : 			m_nIndex = nindex;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _nindex$[ebp]
	mov	DWORD PTR [ecx+32], edx

; 176  : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?reset@DynamicIndexBuffer@Ogre@@QAEXPAVDynamicBufferPool@2@II@Z ENDP ; Ogre::DynamicIndexBuffer::reset
_TEXT	ENDS
PUBLIC	??1DynamicIndexBuffer@Ogre@@EAE@XZ		; Ogre::DynamicIndexBuffer::~DynamicIndexBuffer
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1DynamicIndexBuffer@Ogre@@EAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1DynamicIndexBuffer@Ogre@@EAE@XZ$0
__ehfuncinfo$??1DynamicIndexBuffer@Ogre@@EAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1DynamicIndexBuffer@Ogre@@EAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1DynamicIndexBuffer@Ogre@@EAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1DynamicIndexBuffer@Ogre@@EAE@XZ PROC			; Ogre::DynamicIndexBuffer::~DynamicIndexBuffer, COMDAT
; _this$ = ecx

; 180  : 		{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1DynamicIndexBuffer@Ogre@@EAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7DynamicIndexBuffer@Ogre@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 181  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1IndexBuffer@Ogre@@UAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1DynamicIndexBuffer@Ogre@@EAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1IndexBuffer@Ogre@@UAE@XZ
__ehhandler$??1DynamicIndexBuffer@Ogre@@EAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1DynamicIndexBuffer@Ogre@@EAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1DynamicIndexBuffer@Ogre@@EAE@XZ ENDP			; Ogre::DynamicIndexBuffer::~DynamicIndexBuffer
PUBLIC	??0DynamicIndexBuffer@Ogre@@QAE@ABV01@@Z	; Ogre::DynamicIndexBuffer::DynamicIndexBuffer
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0DynamicIndexBuffer@Ogre@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0DynamicIndexBuffer@Ogre@@QAE@ABV01@@Z$0
__ehfuncinfo$??0DynamicIndexBuffer@Ogre@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0DynamicIndexBuffer@Ogre@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0DynamicIndexBuffer@Ogre@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0DynamicIndexBuffer@Ogre@@QAE@ABV01@@Z PROC		; Ogre::DynamicIndexBuffer::DynamicIndexBuffer, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0DynamicIndexBuffer@Ogre@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0IndexBuffer@Ogre@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7DynamicIndexBuffer@Ogre@@6B@
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR [edx+24], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	DWORD PTR [edx+28], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	mov	DWORD PTR [edx+32], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0DynamicIndexBuffer@Ogre@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1IndexBuffer@Ogre@@UAE@XZ
__ehhandler$??0DynamicIndexBuffer@Ogre@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0DynamicIndexBuffer@Ogre@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0DynamicIndexBuffer@Ogre@@QAE@ABV01@@Z ENDP		; Ogre::DynamicIndexBuffer::DynamicIndexBuffer
PUBLIC	??4DynamicIndexBuffer@Ogre@@QAEAAV01@ABV01@@Z	; Ogre::DynamicIndexBuffer::operator=
; Function compile flags: /Odtp
;	COMDAT ??4DynamicIndexBuffer@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4DynamicIndexBuffer@Ogre@@QAEAAV01@ABV01@@Z PROC	; Ogre::DynamicIndexBuffer::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4IndexBuffer@Ogre@@QAEAAV01@ABV01@@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	DWORD PTR [ecx+24], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+28]
	mov	DWORD PTR [ecx+28], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	DWORD PTR [ecx+32], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4DynamicIndexBuffer@Ogre@@QAEAAV01@ABV01@@Z ENDP	; Ogre::DynamicIndexBuffer::operator=
_TEXT	ENDS
PUBLIC	??_GDynamicIndexBuffer@Ogre@@EAEPAXI@Z		; Ogre::DynamicIndexBuffer::`scalar deleting destructor'
; Function compile flags: /Odtp
;	COMDAT ??_GDynamicIndexBuffer@Ogre@@EAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GDynamicIndexBuffer@Ogre@@EAEPAXI@Z PROC		; Ogre::DynamicIndexBuffer::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1DynamicIndexBuffer@Ogre@@EAE@XZ	; Ogre::DynamicIndexBuffer::~DynamicIndexBuffer
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@27
	push	36					; 00000024H
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3MemoryDelegation@Ogre@@SAXPAXI@Z	; Ogre::MemoryDelegation::operator delete
	add	esp, 8
$LN1@scalar@27:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GDynamicIndexBuffer@Ogre@@EAEPAXI@Z ENDP		; Ogre::DynamicIndexBuffer::`scalar deleting destructor'
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_EDynamicIndexBuffer@Ogre@@EAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_EDynamicIndexBuffer@Ogre@@EAEPAXI@Z PROC		; Ogre::DynamicIndexBuffer::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 2
	je	SHORT $LN3@vector@25
	push	OFFSET ??1DynamicIndexBuffer@Ogre@@EAE@XZ ; Ogre::DynamicIndexBuffer::~DynamicIndexBuffer
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx-4]
	push	edx
	push	36					; 00000024H
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??_M@YGXPAXIHP6EX0@Z@Z
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN2@vector@25
	push	36					; 00000024H
	mov	edx, DWORD PTR _this$[ebp]
	sub	edx, 4
	push	edx
	call	??_VMemoryDelegation@Ogre@@SAXPAXI@Z	; Ogre::MemoryDelegation::operator delete[]
	add	esp, 8
$LN2@vector@25:
	mov	eax, DWORD PTR _this$[ebp]
	sub	eax, 4
	jmp	SHORT $LN4@vector@25
$LN3@vector@25:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1DynamicIndexBuffer@Ogre@@EAE@XZ	; Ogre::DynamicIndexBuffer::~DynamicIndexBuffer
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@vector@25
	push	36					; 00000024H
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3MemoryDelegation@Ogre@@SAXPAXI@Z	; Ogre::MemoryDelegation::operator delete
	add	esp, 8
$LN1@vector@25:
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector@25:
	mov	esp, ebp
	pop	ebp
	ret	4
??_EDynamicIndexBuffer@Ogre@@EAEPAXI@Z ENDP		; Ogre::DynamicIndexBuffer::`vector deleting destructor'
_TEXT	ENDS
PUBLIC	??1?$vector@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::CullResult::Record,std::allocator<Ogre::CullResult::Record> >::~vector<Ogre::CullResult::Record,std::allocator<Ogre::CullResult::Record> >
PUBLIC	??0?$vector@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@QAE@ABV01@@Z ; std::vector<Ogre::CullResult::Record,std::allocator<Ogre::CullResult::Record> >::vector<Ogre::CullResult::Record,std::allocator<Ogre::CullResult::Record> >
PUBLIC	??0CullResult@Ogre@@QAE@ABV01@@Z		; Ogre::CullResult::CullResult
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0CullResult@Ogre@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CullResult@Ogre@@QAE@ABV01@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0CullResult@Ogre@@QAE@ABV01@@Z$1
__ehfuncinfo$??0CullResult@Ogre@@QAE@ABV01@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0CullResult@Ogre@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0CullResult@Ogre@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0CullResult@Ogre@@QAE@ABV01@@Z PROC			; Ogre::CullResult::CullResult, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0CullResult@Ogre@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??0CullFrustum@Ogre@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR ___that$[ebp]
	add	ecx, 548				; 00000224H
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 548				; 00000224H
	call	??0?$vector@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@QAE@ABV01@@Z ; std::vector<Ogre::CullResult::Record,std::allocator<Ogre::CullResult::Record> >::vector<Ogre::CullResult::Record,std::allocator<Ogre::CullResult::Record> >
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CullResult@Ogre@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	jmp	??1CullFrustum@Ogre@@QAE@XZ		; Ogre::CullFrustum::~CullFrustum
__unwindfunclet$??0CullResult@Ogre@@QAE@ABV01@@Z$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 548				; 00000224H
	jmp	??1?$vector@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::CullResult::Record,std::allocator<Ogre::CullResult::Record> >::~vector<Ogre::CullResult::Record,std::allocator<Ogre::CullResult::Record> >
__ehhandler$??0CullResult@Ogre@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0CullResult@Ogre@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0CullResult@Ogre@@QAE@ABV01@@Z ENDP			; Ogre::CullResult::CullResult
PUBLIC	??4?$vector@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<Ogre::CullResult::Record,std::allocator<Ogre::CullResult::Record> >::operator=
PUBLIC	??4CullResult@Ogre@@QAEAAV01@ABV01@@Z		; Ogre::CullResult::operator=
; Function compile flags: /Odtp
;	COMDAT ??4CullResult@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4CullResult@Ogre@@QAEAAV01@ABV01@@Z PROC		; Ogre::CullResult::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??4CullFrustum@Ogre@@QAEAAV01@ABV01@@Z
	mov	ecx, DWORD PTR ___that$[ebp]
	add	ecx, 548				; 00000224H
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 548				; 00000224H
	call	??4?$vector@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<Ogre::CullResult::Record,std::allocator<Ogre::CullResult::Record> >::operator=
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4CullResult@Ogre@@QAEAAV01@ABV01@@Z ENDP		; Ogre::CullResult::operator=
_TEXT	ENDS
PUBLIC	?getRTTI@GameScene@Ogre@@UBEPBVRuntimeClass@2@XZ ; Ogre::GameScene::getRTTI
EXTRN	?m_RTTI@GameScene@Ogre@@2VRuntimeClass@2@B:BYTE	; Ogre::GameScene::m_RTTI
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogregamescene.h
;	COMDAT ?getRTTI@GameScene@Ogre@@UBEPBVRuntimeClass@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getRTTI@GameScene@Ogre@@UBEPBVRuntimeClass@2@XZ PROC	; Ogre::GameScene::getRTTI, COMDAT
; _this$ = ecx

; 68   : 		DECLARE_RTTI_VIRTUAL(GameScene)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, OFFSET ?m_RTTI@GameScene@Ogre@@2VRuntimeClass@2@B ; Ogre::GameScene::m_RTTI
	mov	esp, ebp
	pop	ebp
	ret	0
?getRTTI@GameScene@Ogre@@UBEPBVRuntimeClass@2@XZ ENDP	; Ogre::GameScene::getRTTI
_TEXT	ENDS
PUBLIC	?onCull@GameScene@Ogre@@UAEXPAVCamera@2@@Z	; Ogre::GameScene::onCull
; Function compile flags: /Odtp
;	COMDAT ?onCull@GameScene@Ogre@@UAEXPAVCamera@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pcamera$ = 8						; size = 4
?onCull@GameScene@Ogre@@UAEXPAVCamera@2@@Z PROC		; Ogre::GameScene::onCull, COMDAT
; _this$ = ecx

; 85   : 		virtual void onCull(Camera *pcamera){}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	esp, ebp
	pop	ebp
	ret	4
?onCull@GameScene@Ogre@@UAEXPAVCamera@2@@Z ENDP		; Ogre::GameScene::onCull
_TEXT	ENDS
PUBLIC	?getReflecteffect@GameScene@Ogre@@UAEPAVReflectEffect@2@XZ ; Ogre::GameScene::getReflecteffect
; Function compile flags: /Odtp
;	COMDAT ?getReflecteffect@GameScene@Ogre@@UAEPAVReflectEffect@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getReflecteffect@GameScene@Ogre@@UAEPAVReflectEffect@2@XZ PROC ; Ogre::GameScene::getReflecteffect, COMDAT
; _this$ = ecx

; 95   : 		virtual ReflectEffect* getReflecteffect(){return NULL;};

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?getReflecteffect@GameScene@Ogre@@UAEPAVReflectEffect@2@XZ ENDP ; Ogre::GameScene::getReflecteffect
_TEXT	ENDS
PUBLIC	?pickGround@GameScene@Ogre@@QAE_NMMPAM@Z	; Ogre::GameScene::pickGround
; Function compile flags: /Odtp
;	COMDAT ?pickGround@GameScene@Ogre@@QAE_NMMPAM@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
_b$ = -5						; size = 1
_wy$ = -4						; size = 4
_x$ = 8							; size = 4
_z$ = 12						; size = 4
_y$ = 16						; size = 4
?pickGround@GameScene@Ogre@@QAE_NMMPAM@Z PROC		; Ogre::GameScene::pickGround, COMDAT
; _this$ = ecx

; 98   : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 99   : 			WPOS_T wy;
; 100  : 			bool b = pickGround(WorldPos::Flt2Fix(x), WorldPos::Flt2Fix(z), &wy);

	push	0
	push	0
	lea	eax, DWORD PTR _wy$[ebp]
	push	eax
	push	ecx
	fld	DWORD PTR _z$[ebp]
	fstp	DWORD PTR [esp]
	call	?Flt2Fix@WorldPos@Ogre@@SAHM@Z		; Ogre::WorldPos::Flt2Fix
	add	esp, 4
	push	eax
	push	ecx
	fld	DWORD PTR _x$[ebp]
	fstp	DWORD PTR [esp]
	call	?Flt2Fix@WorldPos@Ogre@@SAHM@Z		; Ogre::WorldPos::Flt2Fix
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+68]
	call	eax
	mov	BYTE PTR _b$[ebp], al

; 101  : 			if(y) *y = WorldPos::Fix2Flt(wy);

	cmp	DWORD PTR _y$[ebp], 0
	je	SHORT $LN1@pickGround
	mov	ecx, DWORD PTR _wy$[ebp]
	push	ecx
	call	?Fix2Flt@WorldPos@Ogre@@SAMH@Z		; Ogre::WorldPos::Fix2Flt
	add	esp, 4
	mov	edx, DWORD PTR _y$[ebp]
	fstp	DWORD PTR [edx]
$LN1@pickGround:

; 102  : 
; 103  : 			return b;

	mov	al, BYTE PTR _b$[ebp]

; 104  : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?pickGround@GameScene@Ogre@@QAE_NMMPAM@Z ENDP		; Ogre::GameScene::pickGround
_TEXT	ENDS
PUBLIC	?setViewpoint@GameScene@Ogre@@QAEXABVWorldPos@2@@Z ; Ogre::GameScene::setViewpoint
; Function compile flags: /Odtp
;	COMDAT ?setViewpoint@GameScene@Ogre@@QAEXABVWorldPos@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_vp$ = 8						; size = 4
?setViewpoint@GameScene@Ogre@@QAEXABVWorldPos@2@@Z PROC	; Ogre::GameScene::setViewpoint, COMDAT
; _this$ = ecx

; 107  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 108  : 			m_Viewpoint = vp;

	mov	eax, DWORD PTR _vp$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 68					; 00000044H
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax

; 109  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?setViewpoint@GameScene@Ogre@@QAEXABVWorldPos@2@@Z ENDP	; Ogre::GameScene::setViewpoint
_TEXT	ENDS
PUBLIC	?getViewpoint@GameScene@Ogre@@QAEABVWorldPos@2@XZ ; Ogre::GameScene::getViewpoint
; Function compile flags: /Odtp
;	COMDAT ?getViewpoint@GameScene@Ogre@@QAEABVWorldPos@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getViewpoint@GameScene@Ogre@@QAEABVWorldPos@2@XZ PROC	; Ogre::GameScene::getViewpoint, COMDAT
; _this$ = ecx

; 112  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 113  : 			return m_Viewpoint;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 68					; 00000044H

; 114  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?getViewpoint@GameScene@Ogre@@QAEABVWorldPos@2@XZ ENDP	; Ogre::GameScene::getViewpoint
_TEXT	ENDS
PUBLIC	?getPhysicsScene@GameScene@Ogre@@QAEPAVPhysicsScene@2@XZ ; Ogre::GameScene::getPhysicsScene
; Function compile flags: /Odtp
;	COMDAT ?getPhysicsScene@GameScene@Ogre@@QAEPAVPhysicsScene@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getPhysicsScene@GameScene@Ogre@@QAEPAVPhysicsScene@2@XZ PROC ; Ogre::GameScene::getPhysicsScene, COMDAT
; _this$ = ecx

; 117  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 118  : 			return m_pPhysicsScene;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+60]

; 119  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?getPhysicsScene@GameScene@Ogre@@QAEPAVPhysicsScene@2@XZ ENDP ; Ogre::GameScene::getPhysicsScene
_TEXT	ENDS
PUBLIC	?getPhysicsScene2@GameScene@Ogre@@QAEPAVPhysicsScene2@2@XZ ; Ogre::GameScene::getPhysicsScene2
; Function compile flags: /Odtp
;	COMDAT ?getPhysicsScene2@GameScene@Ogre@@QAEPAVPhysicsScene2@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getPhysicsScene2@GameScene@Ogre@@QAEPAVPhysicsScene2@2@XZ PROC ; Ogre::GameScene::getPhysicsScene2, COMDAT
; _this$ = ecx

; 122  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 123  : 			return m_pPhysicsScene2;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+64]

; 124  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?getPhysicsScene2@GameScene@Ogre@@QAEPAVPhysicsScene2@2@XZ ENDP ; Ogre::GameScene::getPhysicsScene2
_TEXT	ENDS
PUBLIC	??1?$vector@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::SoundNode *,std::allocator<Ogre::SoundNode *> >::~vector<Ogre::SoundNode *,std::allocator<Ogre::SoundNode *> >
PUBLIC	??1?$vector@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::EffectObject *,std::allocator<Ogre::EffectObject *> >::~vector<Ogre::EffectObject *,std::allocator<Ogre::EffectObject *> >
PUBLIC	??0?$vector@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@QAE@ABV01@@Z ; std::vector<Ogre::SoundNode *,std::allocator<Ogre::SoundNode *> >::vector<Ogre::SoundNode *,std::allocator<Ogre::SoundNode *> >
PUBLIC	??0?$vector@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@QAE@ABV01@@Z ; std::vector<Ogre::EffectObject *,std::allocator<Ogre::EffectObject *> >::vector<Ogre::EffectObject *,std::allocator<Ogre::EffectObject *> >
PUBLIC	??_7GameScene@Ogre@@6B@				; Ogre::GameScene::`vftable'
PUBLIC	??0GameScene@Ogre@@QAE@ABV01@@Z			; Ogre::GameScene::GameScene
PUBLIC	??_R4GameScene@Ogre@@6B@			; Ogre::GameScene::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVGameScene@Ogre@@@8			; Ogre::GameScene `RTTI Type Descriptor'
PUBLIC	??_R3GameScene@Ogre@@8				; Ogre::GameScene::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2GameScene@Ogre@@8				; Ogre::GameScene::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@GameScene@Ogre@@8			; Ogre::GameScene::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_EGameScene@Ogre@@MAEPAXI@Z			; Ogre::GameScene::`vector deleting destructor'
EXTRN	?getEffectObjects@GameScene@Ogre@@UAEXAAV?$vector@URenderableEffectInfo@Ogre@@V?$allocator@URenderableEffectInfo@Ogre@@@std@@@std@@PAVRenderableObject@2@@Z:PROC ; Ogre::GameScene::getEffectObjects
EXTRN	?caculateShadowCamera@GameScene@Ogre@@UAEXPAVCamera@2@0@Z:PROC ; Ogre::GameScene::caculateShadowCamera
;	COMDAT ??_R1A@?0A@EA@GameScene@Ogre@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@GameScene@Ogre@@8 DD FLAT:??_R0?AVGameScene@Ogre@@@8 ; Ogre::GameScene::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3GameScene@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R2GameScene@Ogre@@8
rdata$r	SEGMENT
??_R2GameScene@Ogre@@8 DD FLAT:??_R1A@?0A@EA@GameScene@Ogre@@8 ; Ogre::GameScene::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@BaseObject@Ogre@@8
	DD	FLAT:??_R13?0A@EA@MemoryDelegation@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R3GameScene@Ogre@@8
rdata$r	SEGMENT
??_R3GameScene@Ogre@@8 DD 00H				; Ogre::GameScene::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2GameScene@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVGameScene@Ogre@@@8
_DATA	SEGMENT
??_R0?AVGameScene@Ogre@@@8 DD FLAT:??_7type_info@@6B@	; Ogre::GameScene `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVGameScene@Ogre@@', 00H
_DATA	ENDS
;	COMDAT ??_R4GameScene@Ogre@@6B@
rdata$r	SEGMENT
??_R4GameScene@Ogre@@6B@ DD 00H				; Ogre::GameScene::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVGameScene@Ogre@@@8
	DD	FLAT:??_R3GameScene@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_7GameScene@Ogre@@6B@
CONST	SEGMENT
??_7GameScene@Ogre@@6B@ DD FLAT:??_R4GameScene@Ogre@@6B@ ; Ogre::GameScene::`vftable'
	DD	FLAT:?getRTTI@GameScene@Ogre@@UBEPBVRuntimeClass@2@XZ
	DD	FLAT:?release@BaseObject@Ogre@@UAEXXZ
	DD	FLAT:?addRef@BaseObject@Ogre@@UAEXXZ
	DD	FLAT:?getRefCount@BaseObject@Ogre@@UAEHXZ
	DD	FLAT:?_serialize@BaseObject@Ogre@@UAEXAAVArchive@2@H@Z
	DD	FLAT:??_EGameScene@Ogre@@MAEPAXI@Z
	DD	FLAT:?deleteThis@BaseObject@Ogre@@MAEXXZ
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:?getEffectObjects@GameScene@Ogre@@UAEXAAV?$vector@URenderableEffectInfo@Ogre@@V?$allocator@URenderableEffectInfo@Ogre@@@std@@@std@@PAVRenderableObject@2@@Z
	DD	FLAT:?onCull@GameScene@Ogre@@UAEXPAVCamera@2@@Z
	DD	FLAT:?caculateShadowCamera@GameScene@Ogre@@UAEXPAVCamera@2@0@Z
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:?getReflecteffect@GameScene@Ogre@@UAEPAVReflectEffect@2@XZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0GameScene@Ogre@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0GameScene@Ogre@@QAE@ABV01@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0GameScene@Ogre@@QAE@ABV01@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0GameScene@Ogre@@QAE@ABV01@@Z$2
__ehfuncinfo$??0GameScene@Ogre@@QAE@ABV01@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0GameScene@Ogre@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0GameScene@Ogre@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0GameScene@Ogre@@QAE@ABV01@@Z PROC			; Ogre::GameScene::GameScene, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0GameScene@Ogre@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0BaseObject@Ogre@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7GameScene@Ogre@@6B@
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 8
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??0?$vector@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@QAE@ABV01@@Z ; std::vector<Ogre::EffectObject *,std::allocator<Ogre::EffectObject *> >::vector<Ogre::EffectObject *,std::allocator<Ogre::EffectObject *> >
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 32					; 00000020H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??0?$vector@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@QAE@ABV01@@Z ; std::vector<Ogre::SoundNode *,std::allocator<Ogre::SoundNode *> >::vector<Ogre::SoundNode *,std::allocator<Ogre::SoundNode *> >
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	al, BYTE PTR [edx+56]
	mov	BYTE PTR [ecx+56], al
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+60]
	mov	DWORD PTR [ecx+60], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+64]
	mov	DWORD PTR [ecx+64], eax
	mov	ecx, DWORD PTR ___that$[ebp]
	add	ecx, 68					; 00000044H
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 68					; 00000044H
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0GameScene@Ogre@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1BaseObject@Ogre@@MAE@XZ		; Ogre::BaseObject::~BaseObject
__unwindfunclet$??0GameScene@Ogre@@QAE@ABV01@@Z$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	jmp	??1?$vector@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::EffectObject *,std::allocator<Ogre::EffectObject *> >::~vector<Ogre::EffectObject *,std::allocator<Ogre::EffectObject *> >
__unwindfunclet$??0GameScene@Ogre@@QAE@ABV01@@Z$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	jmp	??1?$vector@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::SoundNode *,std::allocator<Ogre::SoundNode *> >::~vector<Ogre::SoundNode *,std::allocator<Ogre::SoundNode *> >
__ehhandler$??0GameScene@Ogre@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0GameScene@Ogre@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0GameScene@Ogre@@QAE@ABV01@@Z ENDP			; Ogre::GameScene::GameScene
PUBLIC	??4?$vector@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<Ogre::SoundNode *,std::allocator<Ogre::SoundNode *> >::operator=
PUBLIC	??4?$vector@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<Ogre::EffectObject *,std::allocator<Ogre::EffectObject *> >::operator=
PUBLIC	??4GameScene@Ogre@@QAEAAV01@ABV01@@Z		; Ogre::GameScene::operator=
; Function compile flags: /Odtp
;	COMDAT ??4GameScene@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4GameScene@Ogre@@QAEAAV01@ABV01@@Z PROC		; Ogre::GameScene::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4BaseObject@Ogre@@QAEAAV01@ABV01@@Z
	mov	ecx, DWORD PTR ___that$[ebp]
	add	ecx, 8
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??4?$vector@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<Ogre::EffectObject *,std::allocator<Ogre::EffectObject *> >::operator=
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 32					; 00000020H
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??4?$vector@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<Ogre::SoundNode *,std::allocator<Ogre::SoundNode *> >::operator=
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	dl, BYTE PTR [ecx+56]
	mov	BYTE PTR [eax+56], dl
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+60]
	mov	DWORD PTR [eax+60], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+64]
	mov	DWORD PTR [eax+64], edx
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 68					; 00000044H
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 68					; 00000044H
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4GameScene@Ogre@@QAEAAV01@ABV01@@Z ENDP		; Ogre::GameScene::operator=
_TEXT	ENDS
PUBLIC	??_GGameScene@Ogre@@MAEPAXI@Z			; Ogre::GameScene::`scalar deleting destructor'
EXTRN	??1GameScene@Ogre@@MAE@XZ:PROC			; Ogre::GameScene::~GameScene
; Function compile flags: /Odtp
;	COMDAT ??_GGameScene@Ogre@@MAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GGameScene@Ogre@@MAEPAXI@Z PROC			; Ogre::GameScene::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1GameScene@Ogre@@MAE@XZ		; Ogre::GameScene::~GameScene
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@28
	push	80					; 00000050H
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3MemoryDelegation@Ogre@@SAXPAXI@Z	; Ogre::MemoryDelegation::operator delete
	add	esp, 8
$LN1@scalar@28:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GGameScene@Ogre@@MAEPAXI@Z ENDP			; Ogre::GameScene::`scalar deleting destructor'
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_EGameScene@Ogre@@MAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_EGameScene@Ogre@@MAEPAXI@Z PROC			; Ogre::GameScene::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 2
	je	SHORT $LN3@vector@26
	push	OFFSET ??1GameScene@Ogre@@MAE@XZ	; Ogre::GameScene::~GameScene
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx-4]
	push	edx
	push	80					; 00000050H
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??_M@YGXPAXIHP6EX0@Z@Z
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN2@vector@26
	push	80					; 00000050H
	mov	edx, DWORD PTR _this$[ebp]
	sub	edx, 4
	push	edx
	call	??_VMemoryDelegation@Ogre@@SAXPAXI@Z	; Ogre::MemoryDelegation::operator delete[]
	add	esp, 8
$LN2@vector@26:
	mov	eax, DWORD PTR _this$[ebp]
	sub	eax, 4
	jmp	SHORT $LN4@vector@26
$LN3@vector@26:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1GameScene@Ogre@@MAE@XZ		; Ogre::GameScene::~GameScene
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@vector@26
	push	80					; 00000050H
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3MemoryDelegation@Ogre@@SAXPAXI@Z	; Ogre::MemoryDelegation::operator delete
	add	esp, 8
$LN1@vector@26:
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector@26:
	mov	esp, ebp
	pop	ebp
	ret	4
??_EGameScene@Ogre@@MAEPAXI@Z ENDP			; Ogre::GameScene::`vector deleting destructor'
_TEXT	ENDS
PUBLIC	?getRTTI@SimpleGameScene@Ogre@@UBEPBVRuntimeClass@2@XZ ; Ogre::SimpleGameScene::getRTTI
EXTRN	?m_RTTI@SimpleGameScene@Ogre@@2VRuntimeClass@2@B:BYTE ; Ogre::SimpleGameScene::m_RTTI
; Function compile flags: /Odtp
;	COMDAT ?getRTTI@SimpleGameScene@Ogre@@UBEPBVRuntimeClass@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getRTTI@SimpleGameScene@Ogre@@UBEPBVRuntimeClass@2@XZ PROC ; Ogre::SimpleGameScene::getRTTI, COMDAT
; _this$ = ecx

; 142  : 		DECLARE_RTTI(SimpleGameScene)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, OFFSET ?m_RTTI@SimpleGameScene@Ogre@@2VRuntimeClass@2@B ; Ogre::SimpleGameScene::m_RTTI
	mov	esp, ebp
	pop	ebp
	ret	0
?getRTTI@SimpleGameScene@Ogre@@UBEPBVRuntimeClass@2@XZ ENDP ; Ogre::SimpleGameScene::getRTTI
_TEXT	ENDS
PUBLIC	?newObject@SimpleGameScene@Ogre@@SAPAVBaseObject@2@XZ ; Ogre::SimpleGameScene::newObject
EXTRN	??0SimpleGameScene@Ogre@@QAE@XZ:PROC		; Ogre::SimpleGameScene::SimpleGameScene
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?newObject@SimpleGameScene@Ogre@@SAPAVBaseObject@2@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?newObject@SimpleGameScene@Ogre@@SAPAVBaseObject@2@XZ$0
__ehfuncinfo$?newObject@SimpleGameScene@Ogre@@SAPAVBaseObject@2@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?newObject@SimpleGameScene@Ogre@@SAPAVBaseObject@2@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?newObject@SimpleGameScene@Ogre@@SAPAVBaseObject@2@XZ
_TEXT	SEGMENT
tv75 = -24						; size = 4
$T94668 = -20						; size = 4
$T94667 = -16						; size = 4
__$EHRec$ = -12						; size = 12
?newObject@SimpleGameScene@Ogre@@SAPAVBaseObject@2@XZ PROC ; Ogre::SimpleGameScene::newObject, COMDAT

; 142  : 		DECLARE_RTTI(SimpleGameScene)

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?newObject@SimpleGameScene@Ogre@@SAPAVBaseObject@2@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 12					; 0000000cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	push	140					; 0000008cH
	call	??2MemoryDelegation@Ogre@@SAPAXI@Z	; Ogre::MemoryDelegation::operator new
	add	esp, 4
	mov	DWORD PTR $T94668[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T94668[ebp], 0
	je	SHORT $LN3@newObject@12
	mov	ecx, DWORD PTR $T94668[ebp]
	call	??0SimpleGameScene@Ogre@@QAE@XZ		; Ogre::SimpleGameScene::SimpleGameScene
	mov	DWORD PTR tv75[ebp], eax
	jmp	SHORT $LN4@newObject@12
$LN3@newObject@12:
	mov	DWORD PTR tv75[ebp], 0
$LN4@newObject@12:
	mov	eax, DWORD PTR tv75[ebp]
	mov	DWORD PTR $T94667[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR $T94667[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?newObject@SimpleGameScene@Ogre@@SAPAVBaseObject@2@XZ$0:
	push	140					; 0000008cH
	mov	eax, DWORD PTR $T94668[ebp]
	push	eax
	call	??3MemoryDelegation@Ogre@@SAXPAXI@Z	; Ogre::MemoryDelegation::operator delete
	add	esp, 8
	ret	0
__ehhandler$?newObject@SimpleGameScene@Ogre@@SAPAVBaseObject@2@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?newObject@SimpleGameScene@Ogre@@SAPAVBaseObject@2@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?newObject@SimpleGameScene@Ogre@@SAPAVBaseObject@2@XZ ENDP ; Ogre::SimpleGameScene::newObject
PUBLIC	?updateFocusArea@SimpleGameScene@Ogre@@UAEXVWorldPos@2@M@Z ; Ogre::SimpleGameScene::updateFocusArea
; Function compile flags: /Odtp
;	COMDAT ?updateFocusArea@SimpleGameScene@Ogre@@UAEXVWorldPos@2@M@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_center$ = 8						; size = 12
_radius$ = 20						; size = 4
?updateFocusArea@SimpleGameScene@Ogre@@UAEXVWorldPos@2@M@Z PROC ; Ogre::SimpleGameScene::updateFocusArea, COMDAT
; _this$ = ecx

; 162  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 163  : 		}

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?updateFocusArea@SimpleGameScene@Ogre@@UAEXVWorldPos@2@M@Z ENDP ; Ogre::SimpleGameScene::updateFocusArea
_TEXT	ENDS
PUBLIC	?getTerrainTile@SimpleGameScene@Ogre@@UAEPAVTerrainTile@2@XZ ; Ogre::SimpleGameScene::getTerrainTile
; Function compile flags: /Odtp
;	COMDAT ?getTerrainTile@SimpleGameScene@Ogre@@UAEPAVTerrainTile@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getTerrainTile@SimpleGameScene@Ogre@@UAEPAVTerrainTile@2@XZ PROC ; Ogre::SimpleGameScene::getTerrainTile, COMDAT
; _this$ = ecx

; 164  : 		virtual TerrainTile * getTerrainTile() { return NULL;}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	xor	eax, eax
	mov	esp, ebp
	pop	ebp
	ret	0
?getTerrainTile@SimpleGameScene@Ogre@@UAEPAVTerrainTile@2@XZ ENDP ; Ogre::SimpleGameScene::getTerrainTile
_TEXT	ENDS
PUBLIC	??1?$vector@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::Light *,std::allocator<Ogre::Light *> >::~vector<Ogre::Light *,std::allocator<Ogre::Light *> >
PUBLIC	??1?$vector@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::RenderableObject *,std::allocator<Ogre::RenderableObject *> >::~vector<Ogre::RenderableObject *,std::allocator<Ogre::RenderableObject *> >
PUBLIC	??0?$vector@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@QAE@ABV01@@Z ; std::vector<Ogre::Light *,std::allocator<Ogre::Light *> >::vector<Ogre::Light *,std::allocator<Ogre::Light *> >
PUBLIC	??0?$vector@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@QAE@ABV01@@Z ; std::vector<Ogre::RenderableObject *,std::allocator<Ogre::RenderableObject *> >::vector<Ogre::RenderableObject *,std::allocator<Ogre::RenderableObject *> >
PUBLIC	??_7SimpleGameScene@Ogre@@6B@			; Ogre::SimpleGameScene::`vftable'
PUBLIC	??0SimpleGameScene@Ogre@@QAE@ABV01@@Z		; Ogre::SimpleGameScene::SimpleGameScene
PUBLIC	??_R4SimpleGameScene@Ogre@@6B@			; Ogre::SimpleGameScene::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVSimpleGameScene@Ogre@@@8		; Ogre::SimpleGameScene `RTTI Type Descriptor'
PUBLIC	??_R3SimpleGameScene@Ogre@@8			; Ogre::SimpleGameScene::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2SimpleGameScene@Ogre@@8			; Ogre::SimpleGameScene::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@SimpleGameScene@Ogre@@8		; Ogre::SimpleGameScene::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_ESimpleGameScene@Ogre@@MAEPAXI@Z		; Ogre::SimpleGameScene::`vector deleting destructor'
EXTRN	?update@SimpleGameScene@Ogre@@UAEXI@Z:PROC	; Ogre::SimpleGameScene::update
EXTRN	?onAttachObject@SimpleGameScene@Ogre@@UAEXPAVMovableObject@2@@Z:PROC ; Ogre::SimpleGameScene::onAttachObject
EXTRN	?onDetachObject@SimpleGameScene@Ogre@@UAEXPAVMovableObject@2@@Z:PROC ; Ogre::SimpleGameScene::onDetachObject
EXTRN	?onObjectPosChange@SimpleGameScene@Ogre@@UAEXPAVMovableObject@2@@Z:PROC ; Ogre::SimpleGameScene::onObjectPosChange
EXTRN	?onRender@SimpleGameScene@Ogre@@UAEXPAVSceneRenderer@2@@Z:PROC ; Ogre::SimpleGameScene::onRender
EXTRN	?onCull@SimpleGameScene@Ogre@@UAEXPAVCamera@2@@Z:PROC ; Ogre::SimpleGameScene::onCull
EXTRN	?pickObject@SimpleGameScene@Ogre@@UAEPAVMovableObject@2@W4IntersectType@2@ABVWorldRay@2@PAMI@Z:PROC ; Ogre::SimpleGameScene::pickObject
EXTRN	?pickGround@SimpleGameScene@Ogre@@UAE_NHHPAHPAVVector3@2@PAM@Z:PROC ; Ogre::SimpleGameScene::pickGround
EXTRN	?pickGround@SimpleGameScene@Ogre@@UAE_NABVWorldRay@2@PAM@Z:PROC ; Ogre::SimpleGameScene::pickGround
;	COMDAT ??_R1A@?0A@EA@SimpleGameScene@Ogre@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@SimpleGameScene@Ogre@@8 DD FLAT:??_R0?AVSimpleGameScene@Ogre@@@8 ; Ogre::SimpleGameScene::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3SimpleGameScene@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R2SimpleGameScene@Ogre@@8
rdata$r	SEGMENT
??_R2SimpleGameScene@Ogre@@8 DD FLAT:??_R1A@?0A@EA@SimpleGameScene@Ogre@@8 ; Ogre::SimpleGameScene::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@GameScene@Ogre@@8
	DD	FLAT:??_R1A@?0A@EA@BaseObject@Ogre@@8
	DD	FLAT:??_R13?0A@EA@MemoryDelegation@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R3SimpleGameScene@Ogre@@8
rdata$r	SEGMENT
??_R3SimpleGameScene@Ogre@@8 DD 00H			; Ogre::SimpleGameScene::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	04H
	DD	FLAT:??_R2SimpleGameScene@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVSimpleGameScene@Ogre@@@8
_DATA	SEGMENT
??_R0?AVSimpleGameScene@Ogre@@@8 DD FLAT:??_7type_info@@6B@ ; Ogre::SimpleGameScene `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVSimpleGameScene@Ogre@@', 00H
_DATA	ENDS
;	COMDAT ??_R4SimpleGameScene@Ogre@@6B@
rdata$r	SEGMENT
??_R4SimpleGameScene@Ogre@@6B@ DD 00H			; Ogre::SimpleGameScene::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVSimpleGameScene@Ogre@@@8
	DD	FLAT:??_R3SimpleGameScene@Ogre@@8
rdata$r	ENDS
;	COMDAT ??_7SimpleGameScene@Ogre@@6B@
CONST	SEGMENT
??_7SimpleGameScene@Ogre@@6B@ DD FLAT:??_R4SimpleGameScene@Ogre@@6B@ ; Ogre::SimpleGameScene::`vftable'
	DD	FLAT:?getRTTI@SimpleGameScene@Ogre@@UBEPBVRuntimeClass@2@XZ
	DD	FLAT:?release@BaseObject@Ogre@@UAEXXZ
	DD	FLAT:?addRef@BaseObject@Ogre@@UAEXXZ
	DD	FLAT:?getRefCount@BaseObject@Ogre@@UAEHXZ
	DD	FLAT:?_serialize@BaseObject@Ogre@@UAEXAAVArchive@2@H@Z
	DD	FLAT:??_ESimpleGameScene@Ogre@@MAEPAXI@Z
	DD	FLAT:?deleteThis@BaseObject@Ogre@@MAEXXZ
	DD	FLAT:?update@SimpleGameScene@Ogre@@UAEXI@Z
	DD	FLAT:?onAttachObject@SimpleGameScene@Ogre@@UAEXPAVMovableObject@2@@Z
	DD	FLAT:?onDetachObject@SimpleGameScene@Ogre@@UAEXPAVMovableObject@2@@Z
	DD	FLAT:?onObjectPosChange@SimpleGameScene@Ogre@@UAEXPAVMovableObject@2@@Z
	DD	FLAT:?onRender@SimpleGameScene@Ogre@@UAEXPAVSceneRenderer@2@@Z
	DD	FLAT:?getTerrainTile@SimpleGameScene@Ogre@@UAEPAVTerrainTile@2@XZ
	DD	FLAT:?getEffectObjects@GameScene@Ogre@@UAEXAAV?$vector@URenderableEffectInfo@Ogre@@V?$allocator@URenderableEffectInfo@Ogre@@@std@@@std@@PAVRenderableObject@2@@Z
	DD	FLAT:?onCull@SimpleGameScene@Ogre@@UAEXPAVCamera@2@@Z
	DD	FLAT:?caculateShadowCamera@GameScene@Ogre@@UAEXPAVCamera@2@0@Z
	DD	FLAT:?pickObject@SimpleGameScene@Ogre@@UAEPAVMovableObject@2@W4IntersectType@2@ABVWorldRay@2@PAMI@Z
	DD	FLAT:?pickGround@SimpleGameScene@Ogre@@UAE_NHHPAHPAVVector3@2@PAM@Z
	DD	FLAT:?pickGround@SimpleGameScene@Ogre@@UAE_NABVWorldRay@2@PAM@Z
	DD	FLAT:?updateFocusArea@SimpleGameScene@Ogre@@UAEXVWorldPos@2@M@Z
	DD	FLAT:?getReflecteffect@GameScene@Ogre@@UAEPAVReflectEffect@2@XZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0SimpleGameScene@Ogre@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0SimpleGameScene@Ogre@@QAE@ABV01@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0SimpleGameScene@Ogre@@QAE@ABV01@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0SimpleGameScene@Ogre@@QAE@ABV01@@Z$2
__ehfuncinfo$??0SimpleGameScene@Ogre@@QAE@ABV01@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0SimpleGameScene@Ogre@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0SimpleGameScene@Ogre@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0SimpleGameScene@Ogre@@QAE@ABV01@@Z PROC		; Ogre::SimpleGameScene::SimpleGameScene, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0SimpleGameScene@Ogre@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0GameScene@Ogre@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7SimpleGameScene@Ogre@@6B@
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 80					; 00000050H
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 80					; 00000050H
	call	??0?$vector@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@QAE@ABV01@@Z ; std::vector<Ogre::RenderableObject *,std::allocator<Ogre::RenderableObject *> >::vector<Ogre::RenderableObject *,std::allocator<Ogre::RenderableObject *> >
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 104				; 00000068H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 104				; 00000068H
	call	??0?$vector@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@QAE@ABV01@@Z ; std::vector<Ogre::Light *,std::allocator<Ogre::Light *> >::vector<Ogre::Light *,std::allocator<Ogre::Light *> >
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+128]
	mov	DWORD PTR [ecx+128], eax
	mov	edx, DWORD PTR [edx+132]
	mov	DWORD PTR [ecx+132], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+136]
	mov	DWORD PTR [eax+136], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0SimpleGameScene@Ogre@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1GameScene@Ogre@@MAE@XZ		; Ogre::GameScene::~GameScene
__unwindfunclet$??0SimpleGameScene@Ogre@@QAE@ABV01@@Z$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 80					; 00000050H
	jmp	??1?$vector@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::RenderableObject *,std::allocator<Ogre::RenderableObject *> >::~vector<Ogre::RenderableObject *,std::allocator<Ogre::RenderableObject *> >
__unwindfunclet$??0SimpleGameScene@Ogre@@QAE@ABV01@@Z$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 104				; 00000068H
	jmp	??1?$vector@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@QAE@XZ ; std::vector<Ogre::Light *,std::allocator<Ogre::Light *> >::~vector<Ogre::Light *,std::allocator<Ogre::Light *> >
__ehhandler$??0SimpleGameScene@Ogre@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0SimpleGameScene@Ogre@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0SimpleGameScene@Ogre@@QAE@ABV01@@Z ENDP		; Ogre::SimpleGameScene::SimpleGameScene
PUBLIC	??4?$vector@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<Ogre::Light *,std::allocator<Ogre::Light *> >::operator=
PUBLIC	??4?$vector@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<Ogre::RenderableObject *,std::allocator<Ogre::RenderableObject *> >::operator=
PUBLIC	??4SimpleGameScene@Ogre@@QAEAAV01@ABV01@@Z	; Ogre::SimpleGameScene::operator=
; Function compile flags: /Odtp
;	COMDAT ??4SimpleGameScene@Ogre@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_$S9$69844 = -4						; size = 4
___that$ = 8						; size = 4
??4SimpleGameScene@Ogre@@QAEAAV01@ABV01@@Z PROC		; Ogre::SimpleGameScene::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4GameScene@Ogre@@QAEAAV01@ABV01@@Z
	mov	ecx, DWORD PTR ___that$[ebp]
	add	ecx, 80					; 00000050H
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 80					; 00000050H
	call	??4?$vector@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<Ogre::RenderableObject *,std::allocator<Ogre::RenderableObject *> >::operator=
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 104				; 00000068H
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 104				; 00000068H
	call	??4?$vector@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<Ogre::Light *,std::allocator<Ogre::Light *> >::operator=
	mov	DWORD PTR _$S9$69844[ebp], 0
	jmp	SHORT $LN3@operator@13
$LN2@operator@13:
	mov	eax, DWORD PTR _$S9$69844[ebp]
	add	eax, 1
	mov	DWORD PTR _$S9$69844[ebp], eax
$LN3@operator@13:
	cmp	DWORD PTR _$S9$69844[ebp], 2
	jae	SHORT $LN1@operator@13
	mov	ecx, DWORD PTR _$S9$69844[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _$S9$69844[ebp]
	mov	esi, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [esi+eax*4+128]
	mov	DWORD PTR [edx+ecx*4+128], eax
	jmp	SHORT $LN2@operator@13
$LN1@operator@13:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+136]
	mov	DWORD PTR [ecx+136], eax
	mov	eax, DWORD PTR _this$[ebp]
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
??4SimpleGameScene@Ogre@@QAEAAV01@ABV01@@Z ENDP		; Ogre::SimpleGameScene::operator=
_TEXT	ENDS
PUBLIC	??_GSimpleGameScene@Ogre@@MAEPAXI@Z		; Ogre::SimpleGameScene::`scalar deleting destructor'
EXTRN	??1SimpleGameScene@Ogre@@MAE@XZ:PROC		; Ogre::SimpleGameScene::~SimpleGameScene
; Function compile flags: /Odtp
;	COMDAT ??_GSimpleGameScene@Ogre@@MAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GSimpleGameScene@Ogre@@MAEPAXI@Z PROC		; Ogre::SimpleGameScene::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1SimpleGameScene@Ogre@@MAE@XZ		; Ogre::SimpleGameScene::~SimpleGameScene
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@29
	push	140					; 0000008cH
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3MemoryDelegation@Ogre@@SAXPAXI@Z	; Ogre::MemoryDelegation::operator delete
	add	esp, 8
$LN1@scalar@29:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GSimpleGameScene@Ogre@@MAEPAXI@Z ENDP		; Ogre::SimpleGameScene::`scalar deleting destructor'
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_ESimpleGameScene@Ogre@@MAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_ESimpleGameScene@Ogre@@MAEPAXI@Z PROC		; Ogre::SimpleGameScene::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 2
	je	SHORT $LN3@vector@27
	push	OFFSET ??1SimpleGameScene@Ogre@@MAE@XZ	; Ogre::SimpleGameScene::~SimpleGameScene
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx-4]
	push	edx
	push	140					; 0000008cH
	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	??_M@YGXPAXIHP6EX0@Z@Z
	mov	ecx, DWORD PTR ___flags$[ebp]
	and	ecx, 1
	je	SHORT $LN2@vector@27
	push	140					; 0000008cH
	mov	edx, DWORD PTR _this$[ebp]
	sub	edx, 4
	push	edx
	call	??_VMemoryDelegation@Ogre@@SAXPAXI@Z	; Ogre::MemoryDelegation::operator delete[]
	add	esp, 8
$LN2@vector@27:
	mov	eax, DWORD PTR _this$[ebp]
	sub	eax, 4
	jmp	SHORT $LN4@vector@27
$LN3@vector@27:
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1SimpleGameScene@Ogre@@MAE@XZ		; Ogre::SimpleGameScene::~SimpleGameScene
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@vector@27
	push	140					; 0000008cH
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3MemoryDelegation@Ogre@@SAXPAXI@Z	; Ogre::MemoryDelegation::operator delete
	add	esp, 8
$LN1@vector@27:
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector@27:
	mov	esp, ebp
	pop	ebp
	ret	4
??_ESimpleGameScene@Ogre@@MAEPAXI@Z ENDP		; Ogre::SimpleGameScene::`vector deleting destructor'
_TEXT	ENDS
PUBLIC	__real@c2c80000
PUBLIC	__real@42c80000
PUBLIC	?getSingleton@?$Singleton@VRenderSystem@Ogre@@@Ogre@@SAAAVRenderSystem@2@XZ ; Ogre::Singleton<Ogre::RenderSystem>::getSingleton
PUBLIC	??0ParamShapeFrameData@Ogre@@QAE@XZ		; Ogre::ParamShapeFrameData::ParamShapeFrameData
EXTRN	?CreateParticleMaterial@Ogre@@YAPAVMaterial@1@HPAVTexture@1@0HH@Z:PROC ; Ogre::CreateParticleMaterial
EXTRN	?addElement@VertexFormat@Ogre@@QAEXW4VertexElementType@2@W4VertexElementSemantic@2@III@Z:PROC ; Ogre::VertexFormat::addElement
;	COMDAT __real@c2c80000
; File i:\svnroot\client\ogremain\ogreparametricshape.cpp
CONST	SEGMENT
__real@c2c80000 DD 0c2c80000r			; -100
CONST	ENDS
;	COMDAT __real@42c80000
CONST	SEGMENT
__real@42c80000 DD 042c80000r			; 100
CONST	ENDS
xdata$x	SEGMENT
__unwindtable$??0ParametricShape@Ogre@@QAE@PAVParamShapeData@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0ParametricShape@Ogre@@QAE@PAVParamShapeData@1@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0ParametricShape@Ogre@@QAE@PAVParamShapeData@1@@Z$1
__ehfuncinfo$??0ParametricShape@Ogre@@QAE@PAVParamShapeData@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0ParametricShape@Ogre@@QAE@PAVParamShapeData@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
_TEXT	SEGMENT
tv181 = -44						; size = 4
_this$ = -40						; size = 4
$T94702 = -36						; size = 12
$T94701 = -24						; size = 12
__$EHRec$ = -12						; size = 12
_pSource$ = 8						; size = 4
??0ParametricShape@Ogre@@QAE@PAVParamShapeData@1@@Z PROC ; Ogre::ParametricShape::ParametricShape
; _this$ = ecx

; 16   : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0ParametricShape@Ogre@@QAE@PAVParamShapeData@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 32					; 00000020H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0RenderableObject@Ogre@@IAE@XZ	; Ogre::RenderableObject::RenderableObject
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7ParametricShape@Ogre@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 296				; 00000128H
	call	??0VertexFormat@Ogre@@QAE@XZ		; Ogre::VertexFormat::VertexFormat
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+324], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+328], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 336				; 00000150H
	call	??0ParamShapeFrameData@Ogre@@QAE@XZ

; 17   : 		m_pSource = pSource;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _pSource$[ebp]
	mov	DWORD PTR [eax+280], ecx

; 18   : 
; 19   : 		if( m_pSource->m_nUSeg > 32 )

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+280]
	cmp	DWORD PTR [eax+56], 32			; 00000020H
	jle	SHORT $LN6@Parametric

; 20   : 		{
; 21   : 			m_pSource->m_nUSeg = 32;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+280]
	mov	DWORD PTR [edx+56], 32			; 00000020H
$LN6@Parametric:

; 22   : 		}
; 23   : 		if(m_pSource->m_nVSeg > 32 )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+280]
	cmp	DWORD PTR [ecx+60], 32			; 00000020H
	jle	SHORT $LN5@Parametric

; 24   : 		{
; 25   : 			m_pSource->m_nVSeg = 32;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+280]
	mov	DWORD PTR [eax+60], 32			; 00000020H
$LN5@Parametric:

; 26   : 		}
; 27   : 
; 28   : 		m_bPause = false;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+184], 0

; 29   : 		if(m_pSource) m_pSource->addRef();

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+280], 0
	je	SHORT $LN4@Parametric
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+280]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+280]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, eax
	mov	eax, DWORD PTR [edx+8]
	call	eax
$LN4@Parametric:

; 30   : 
; 31   : 		m_VertFmt.addElement(VET_FLOAT3, VES_POSITION);

	push	-1
	push	0
	push	0
	push	1
	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 296				; 00000128H
	call	?addElement@VertexFormat@Ogre@@QAEXW4VertexElementType@2@W4VertexElementSemantic@2@III@Z ; Ogre::VertexFormat::addElement

; 32   : 		m_VertFmt.addElement(VET_COLOUR, VES_COLOR);

	push	-1
	push	0
	push	0
	push	5
	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 296				; 00000128H
	call	?addElement@VertexFormat@Ogre@@QAEXW4VertexElementType@2@W4VertexElementSemantic@2@III@Z ; Ogre::VertexFormat::addElement

; 33   : 		m_VertFmt.addElement(VET_FLOAT2, VES_TEXCOORD);

	push	-1
	push	0
	push	0
	push	7
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 296				; 00000128H
	call	?addElement@VertexFormat@Ogre@@QAEXW4VertexElementType@2@W4VertexElementSemantic@2@III@Z ; Ogre::VertexFormat::addElement

; 34   : 		m_VertFmt.addElement(VET_FLOAT2, VES_TEXCOORD, 1);

	push	-1
	push	0
	push	1
	push	7
	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 296				; 00000128H
	call	?addElement@VertexFormat@Ogre@@QAEXW4VertexElementType@2@W4VertexElementSemantic@2@III@Z ; Ogre::VertexFormat::addElement

; 35   : 		m_VertDecl = RenderSystem::getSingleton().getInputLayout(m_VertFmt);

	call	?getSingleton@?$Singleton@VRenderSystem@Ogre@@@Ogre@@SAAAVRenderSystem@2@XZ ; Ogre::Singleton<Ogre::RenderSystem>::getSingleton
	mov	DWORD PTR tv181[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 296				; 00000128H
	push	ecx
	mov	edx, DWORD PTR tv181[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv181[ebp]
	mov	edx, DWORD PTR [eax+36]
	call	edx
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+320], eax

; 36   : 
; 37   : 		if(m_pSource == NULL)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+280], 0
	jne	SHORT $LN3@Parametric

; 38   : 		{
; 39   : 			return;

	jmp	$LN7@Parametric
$LN3@Parametric:

; 40   : 		}
; 41   : 
; 42   : 		m_pCurTex = m_pSource->m_pTextureRes;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+280]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+76]
	mov	DWORD PTR [edx+324], eax

; 43   : 		m_pCurMaskTex = m_pSource->m_pMaskTextureRes;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+280]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+80]
	mov	DWORD PTR [eax+328], ecx

; 44   : 
; 45   : 		// bug
; 46   : 		if (m_pSource->m_iUVAddressMode > 0)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+280]
	cmp	DWORD PTR [eax+40], 0
	jle	SHORT $LN2@Parametric

; 47   : 			m_pSource->m_iUVAddressMode = 1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+280]
	mov	DWORD PTR [edx+40], 1
$LN2@Parametric:

; 48   : 
; 49   : 		m_pMtl = CreateParticleMaterial(m_pSource->m_iBlendMode, m_pSource->m_pTextureRes, m_pSource->m_pMaskTextureRes, m_pSource->m_iUVAddressMode, m_pSource->m_iMaskUVAddressMode);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+280]
	mov	edx, DWORD PTR [ecx+72]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+280]
	mov	edx, DWORD PTR [ecx+40]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+280]
	mov	edx, DWORD PTR [ecx+80]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+280]
	mov	edx, DWORD PTR [ecx+76]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+280]
	mov	edx, DWORD PTR [ecx+24]
	push	edx
	call	?CreateParticleMaterial@Ogre@@YAPAVMaterial@1@HPAVTexture@1@0HH@Z ; Ogre::CreateParticleMaterial
	add	esp, 20					; 00000014H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+332], eax

; 50   : 
; 51   : 		m_CurTick = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+284], 0

; 52   : 
; 53   : 		m_WorldBounds.fromBox(Vector3(-100.0f, -100.0f, -100.0f), Vector3(100.0f, 100.0f, 100.0f));

	push	ecx
	fld	DWORD PTR __real@42c80000
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR __real@42c80000
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR __real@42c80000
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR $T94701[ebp]
	call	??0Vector3@Ogre@@QAE@MMM@Z		; Ogre::Vector3::Vector3
	push	eax
	push	ecx
	fld	DWORD PTR __real@c2c80000
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR __real@c2c80000
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR __real@c2c80000
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR $T94702[ebp]
	call	??0Vector3@Ogre@@QAE@MMM@Z		; Ogre::Vector3::Vector3
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 140				; 0000008cH
	call	?fromBox@BoxSphereBound@Ogre@@QAEXABVVector3@2@0@Z ; Ogre::BoxSphereBound::fromBox

; 54   : 		if(m_pSource->m_bDistort)  m_RenderUsageBits = 1<<RU_DISTORT;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+280]
	movzx	edx, BYTE PTR [ecx+52]
	test	edx, edx
	je	SHORT $LN1@Parametric
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+272], 32			; 00000020H
$LN1@Parametric:

; 55   : 
; 56   : 		update(0);

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?update@ParametricShape@Ogre@@UAEXI@Z	; Ogre::ParametricShape::update
$LN7@Parametric:

; 57   : 	}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$??0ParametricShape@Ogre@@QAE@PAVParamShapeData@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1RenderableObject@Ogre@@MAE@XZ	; Ogre::RenderableObject::~RenderableObject
__unwindfunclet$??0ParametricShape@Ogre@@QAE@PAVParamShapeData@1@@Z$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 296				; 00000128H
	jmp	??1VertexFormat@Ogre@@QAE@XZ		; Ogre::VertexFormat::~VertexFormat
__ehhandler$??0ParametricShape@Ogre@@QAE@PAVParamShapeData@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-36]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0ParametricShape@Ogre@@QAE@PAVParamShapeData@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0ParametricShape@Ogre@@QAE@PAVParamShapeData@1@@Z ENDP ; Ogre::ParametricShape::ParametricShape
; Function compile flags: /Odtp
;	COMDAT ??0ParamShapeFrameData@Ogre@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0ParamShapeFrameData@Ogre@@QAE@XZ PROC		; Ogre::ParamShapeFrameData::ParamShapeFrameData, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	fld1
	fstp	DWORD PTR [esp]
	push	ecx
	fld1
	fstp	DWORD PTR [esp]
	push	ecx
	fld1
	fstp	DWORD PTR [esp]
	push	ecx
	fld1
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 40					; 00000028H
	call	??0ColourValue@Ogre@@QAE@MMMM@Z		; Ogre::ColourValue::ColourValue
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0ParamShapeFrameData@Ogre@@QAE@XZ ENDP		; Ogre::ParamShapeFrameData::ParamShapeFrameData
; Function compile flags: /Odtp
_TEXT	ENDS
_TEXT	SEGMENT
_this$ = -4						; size = 4
_desc$ = 8						; size = 4
?getRenderPassRequired@ParametricShape@Ogre@@UAEXAAURenderPassDesc@2@@Z PROC ; Ogre::ParametricShape::getRenderPassRequired
; _this$ = ecx

; 60   : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 61   : 		if(m_pSource->m_bDistort) desc.pass_usages |= (1<<RU_DISTORT);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+280]
	movzx	edx, BYTE PTR [ecx+52]
	test	edx, edx
	je	SHORT $LN2@getRenderP
	mov	eax, DWORD PTR _desc$[ebp]
	mov	ecx, DWORD PTR [eax]
	or	ecx, 32					; 00000020H
	mov	edx, DWORD PTR _desc$[ebp]
	mov	DWORD PTR [edx], ecx
$LN2@getRenderP:

; 62   : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
?getRenderPassRequired@ParametricShape@Ogre@@UAEXAAURenderPassDesc@2@@Z ENDP ; Ogre::ParametricShape::getRenderPassRequired
_TEXT	ENDS
PUBLIC	?SetAABB@ParametricShape@Ogre@@QAEXXZ		; Ogre::ParametricShape::SetAABB
; Function compile flags: /Odtp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?SetAABB@ParametricShape@Ogre@@QAEXXZ PROC		; Ogre::ParametricShape::SetAABB
; _this$ = ecx

; 65   : 	{/*

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 66   : 	 if( m_pSource->m_GeoType == GEO_SPHERE )	
; 67   : 	 {
; 68   : 	 m_aabbBox.m_Extent.SetElement(m_pSource->m_fSphereRadius, m_pSource->m_fSphereRadius, m_pSource->m_fSphereRadius);
; 69   : 	 }
; 70   : 	 else if(m_pSource->m_GeoType == GEO_TORUS )
; 71   : 	 {
; 72   : 	 m_aabbBox.m_Extent.SetElement(m_pSource->m_fTorusNRadius + m_pSource->m_fTorusLRadius
; 73   : 	 , m_pSource->m_fTorusLRadius
; 74   : 	 , m_pSource->m_fTorusNRadius + m_pSource->m_fTorusLRadius);
; 75   : 	 }
; 76   : 	 else if(m_pSource->m_GeoType == GEO_TUBE )
; 77   : 	 {
; 78   : 	 m_aabbBox.m_Extent.SetElement(m_pSource->m_fTubeNRadius, m_pSource->m_fTubeHeight, m_pSource->m_fTubeNRadius);
; 79   : 	 }
; 80   : 	 else if(m_pSource->m_GeoType == GEO_COLUMN )
; 81   : 	 {
; 82   : 	 float r = 
; 83   : 	 m_pSource->m_fColumnDownRadius > m_pSource->m_fColumnUpRadius 
; 84   : 	 ? m_pSource->m_fColumnDownRadius : m_pSource->m_fColumnUpRadius;
; 85   : 
; 86   : 	 m_aabbBox.m_Extent.SetElement(r, m_pSource->m_fColumnHeight, r);
; 87   : 	 }
; 88   : 	 */
; 89   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?SetAABB@ParametricShape@Ogre@@QAEXXZ ENDP		; Ogre::ParametricShape::SetAABB
_TEXT	ENDS
PUBLIC	?SetSphereRadius@ParametricShape@Ogre@@QAEXM@Z	; Ogre::ParametricShape::SetSphereRadius
; Function compile flags: /Odtp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_fRadius$ = 8						; size = 4
?SetSphereRadius@ParametricShape@Ogre@@QAEXM@Z PROC	; Ogre::ParametricShape::SetSphereRadius
; _this$ = ecx

; 92   : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 93   : 		m_FrameData.m_fSphereRadius	=	fRadius;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR _fRadius$[ebp]
	fstp	DWORD PTR [eax+336]

; 94   : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
?SetSphereRadius@ParametricShape@Ogre@@QAEXM@Z ENDP	; Ogre::ParametricShape::SetSphereRadius
_TEXT	ENDS
PUBLIC	?SetTubeRadius@ParametricShape@Ogre@@QAEXMMM@Z	; Ogre::ParametricShape::SetTubeRadius
; Function compile flags: /Odtp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_fTubeNRadius$ = 8					; size = 4
_fTubeLRadius$ = 12					; size = 4
_fTubeHeight$ = 16					; size = 4
?SetTubeRadius@ParametricShape@Ogre@@QAEXMMM@Z PROC	; Ogre::ParametricShape::SetTubeRadius
; _this$ = ecx

; 97   : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 98   : 		m_FrameData.m_fTubeNRadius	=	fTubeNRadius;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR _fTubeNRadius$[ebp]
	fstp	DWORD PTR [eax+352]

; 99   : 		m_FrameData.m_fTubeLRadius	=	fTubeLRadius;

	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _fTubeLRadius$[ebp]
	fstp	DWORD PTR [ecx+356]

; 100  : 		m_FrameData.m_fTubeHeight	=	fTubeHeight;

	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _fTubeHeight$[ebp]
	fstp	DWORD PTR [edx+360]

; 101  : 	}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?SetTubeRadius@ParametricShape@Ogre@@QAEXMMM@Z ENDP	; Ogre::ParametricShape::SetTubeRadius
_TEXT	ENDS
PUBLIC	?SetTorusRadius@ParametricShape@Ogre@@QAEXMM@Z	; Ogre::ParametricShape::SetTorusRadius
; Function compile flags: /Odtp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_fTorusNRadius$ = 8					; size = 4
_fTorusLRadius$ = 12					; size = 4
?SetTorusRadius@ParametricShape@Ogre@@QAEXMM@Z PROC	; Ogre::ParametricShape::SetTorusRadius
; _this$ = ecx

; 104  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 105  : 		m_FrameData.m_fTorusNRadius	=	fTorusNRadius;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR _fTorusNRadius$[ebp]
	fstp	DWORD PTR [eax+344]

; 106  : 		m_FrameData.m_fTorusLRadius	=	fTorusLRadius;

	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _fTorusLRadius$[ebp]
	fstp	DWORD PTR [ecx+348]

; 107  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?SetTorusRadius@ParametricShape@Ogre@@QAEXMM@Z ENDP	; Ogre::ParametricShape::SetTorusRadius
_TEXT	ENDS
PUBLIC	?SetTextureRes@ParametricShape@Ogre@@QAEXPAVTextureData@2@@Z ; Ogre::ParametricShape::SetTextureRes
EXTRN	?setParamTexture@Material@Ogre@@QAEXABVFixedString@2@PAVTexture@2@@Z:PROC ; Ogre::Material::setParamTexture
xdata$x	SEGMENT
__unwindtable$?SetTextureRes@ParametricShape@Ogre@@QAEXPAVTextureData@2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?SetTextureRes@ParametricShape@Ogre@@QAEXPAVTextureData@2@@Z$0
__ehfuncinfo$?SetTextureRes@ParametricShape@Ogre@@QAEXPAVTextureData@2@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?SetTextureRes@ParametricShape@Ogre@@QAEXPAVTextureData@2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T94721 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_pTexRes$ = 8						; size = 4
?SetTextureRes@ParametricShape@Ogre@@QAEXPAVTextureData@2@@Z PROC ; Ogre::ParametricShape::SetTextureRes
; _this$ = ecx

; 110  : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?SetTextureRes@ParametricShape@Ogre@@QAEXPAVTextureData@2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 111  : 		m_pMtl->setParamTexture("g_DiffuseTex", pTexRes);

	push	OFFSET $SG69903
	lea	ecx, DWORD PTR $T94721[ebp]
	call	??0FixedString@Ogre@@QAE@PBD@Z		; Ogre::FixedString::FixedString
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _pTexRes$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T94721[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+332]
	call	?setParamTexture@Material@Ogre@@QAEXABVFixedString@2@PAVTexture@2@@Z ; Ogre::Material::setParamTexture
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T94721[ebp]
	call	??1FixedString@Ogre@@QAE@XZ		; Ogre::FixedString::~FixedString

; 112  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?SetTextureRes@ParametricShape@Ogre@@QAEXPAVTextureData@2@@Z$0:
	lea	ecx, DWORD PTR $T94721[ebp]
	jmp	??1FixedString@Ogre@@QAE@XZ		; Ogre::FixedString::~FixedString
__ehhandler$?SetTextureRes@ParametricShape@Ogre@@QAEXPAVTextureData@2@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?SetTextureRes@ParametricShape@Ogre@@QAEXPAVTextureData@2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?SetTextureRes@ParametricShape@Ogre@@QAEXPAVTextureData@2@@Z ENDP ; Ogre::ParametricShape::SetTextureRes
PUBLIC	?SetBlendMode@ParametricShape@Ogre@@QAEXH@Z	; Ogre::ParametricShape::SetBlendMode
; Function compile flags: /Odtp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_BlendMode$ = 8						; size = 4
?SetBlendMode@ParametricShape@Ogre@@QAEXH@Z PROC	; Ogre::ParametricShape::SetBlendMode
; _this$ = ecx

; 115  : 	{/*

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 116  : 	 Variant var;
; 117  : 	 var.SetInt(BlendMode);
; 118  : 	 m_pMtl->SetLocalParam("BLEND_MODE", var);*/
; 119  : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
?SetBlendMode@ParametricShape@Ogre@@QAEXH@Z ENDP	; Ogre::ParametricShape::SetBlendMode
_TEXT	ENDS
xdata$x	SEGMENT
__unwindtable$??1ParametricShape@Ogre@@MAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1ParametricShape@Ogre@@MAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1ParametricShape@Ogre@@MAE@XZ$1
__ehfuncinfo$??1ParametricShape@Ogre@@MAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??1ParametricShape@Ogre@@MAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1ParametricShape@Ogre@@MAE@XZ PROC			; Ogre::ParametricShape::~ParametricShape
; _this$ = ecx

; 122  : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1ParametricShape@Ogre@@MAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7ParametricShape@Ogre@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 123  : 		OGRE_RELEASE(m_pSource);

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+280], 0
	je	SHORT $LN2@Parametric@2
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+280]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+280]
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [edx+4]
	call	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+280], 0
$LN2@Parametric@2:

; 124  : 		OGRE_RELEASE(m_pMtl);

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+332], 0
	je	SHORT $LN3@Parametric@2
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+332]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+332]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, eax
	mov	eax, DWORD PTR [edx+4]
	call	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+332], 0
$LN3@Parametric@2:

; 125  : 	}

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 296				; 00000128H
	call	??1VertexFormat@Ogre@@QAE@XZ		; Ogre::VertexFormat::~VertexFormat
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1RenderableObject@Ogre@@MAE@XZ	; Ogre::RenderableObject::~RenderableObject
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$??1ParametricShape@Ogre@@MAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1RenderableObject@Ogre@@MAE@XZ	; Ogre::RenderableObject::~RenderableObject
__unwindfunclet$??1ParametricShape@Ogre@@MAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 296				; 00000128H
	jmp	??1VertexFormat@Ogre@@QAE@XZ		; Ogre::VertexFormat::~VertexFormat
__ehhandler$??1ParametricShape@Ogre@@MAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1ParametricShape@Ogre@@MAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1ParametricShape@Ogre@@MAE@XZ ENDP			; Ogre::ParametricShape::~ParametricShape
PUBLIC	?Lerp@Ogre@@YAMMMM@Z				; Ogre::Lerp
PUBLIC	__real@4000000000000000
PUBLIC	?TransformUV@Ogre@@YAXAAVVector2@1@ABV21@11ABVVector4@1@@Z ; Ogre::TransformUV
PUBLIC	__real@4076800000000000
PUBLIC	__real@4066800000000000
PUBLIC	??0ColorQuad@Ogre@@QAE@ABVColourValue@1@@Z	; Ogre::ColorQuad::ColorQuad
PUBLIC	?setElement@Vector4@Ogre@@QAEXMMMM@Z		; Ogre::Vector4::setElement
PUBLIC	??0Vector4@Ogre@@QAE@XZ				; Ogre::Vector4::Vector4
PUBLIC	?fillContext@ParametricShape@Ogre@@QAEXPAVSceneRenderer@2@PAVShaderContext@2@W4PARAMSHAPE_TYPE@2@II@Z ; Ogre::ParametricShape::fillContext
EXTRN	?setVB@ShaderContext@Ogre@@QAEXPAVVertexBuffer@2@@Z:PROC ; Ogre::ShaderContext::setVB
EXTRN	?setIB@ShaderContext@Ogre@@QAEXPAVIndexBuffer@2@@Z:PROC ; Ogre::ShaderContext::setIB
EXTRN	?GetTransparentColor@Ogre@@YAABVColourValue@1@ABV21@MH@Z:PROC ; Ogre::GetTransparentColor
EXTRN	?fastSin@Ogre@@YAMM@Z:PROC			; Ogre::fastSin
EXTRN	?fastCos@Ogre@@YAMM@Z:PROC			; Ogre::fastCos
EXTRN	?lock@DynamicIndexBuffer@Ogre@@QAEPAXXZ:PROC	; Ogre::DynamicIndexBuffer::lock
EXTRN	?lock@DynamicVertexBuffer@Ogre@@QAEPAXXZ:PROC	; Ogre::DynamicVertexBuffer::lock
EXTRN	?newDynamicIB@SceneRenderer@Ogre@@QAEPAVDynamicIndexBuffer@2@I@Z:PROC ; Ogre::SceneRenderer::newDynamicIB
EXTRN	?newDynamicVB@SceneRenderer@Ogre@@QAEPAVDynamicVertexBuffer@2@ABVVertexFormat@2@I@Z:PROC ; Ogre::SceneRenderer::newDynamicVB
;	COMDAT ?radius@?BG@??fillContext@ParametricShape@Ogre@@QAEXPAVSceneRenderer@3@PAVShaderContext@3@W4PARAMSHAPE_TYPE@3@II@Z@4VVector4@3@A
_BSS	SEGMENT
?radius@?BG@??fillContext@ParametricShape@Ogre@@QAEXPAVSceneRenderer@3@PAVShaderContext@3@W4PARAMSHAPE_TYPE@3@II@Z@4VVector4@3@A DB 010H DUP (?) ; `Ogre::ParametricShape::fillContext'::`22'::radius
_BSS	ENDS
;	COMDAT ?maskUvRoate@?1??fillContext@ParametricShape@Ogre@@QAEXPAVSceneRenderer@3@PAVShaderContext@3@W4PARAMSHAPE_TYPE@3@II@Z@4VVector2@3@A
_BSS	SEGMENT
?maskUvRoate@?1??fillContext@ParametricShape@Ogre@@QAEXPAVSceneRenderer@3@PAVShaderContext@3@W4PARAMSHAPE_TYPE@3@II@Z@4VVector2@3@A DQ 01H DUP (?) ; `Ogre::ParametricShape::fillContext'::`2'::maskUvRoate
_BSS	ENDS
;	COMDAT ?maskUvScale@?1??fillContext@ParametricShape@Ogre@@QAEXPAVSceneRenderer@3@PAVShaderContext@3@W4PARAMSHAPE_TYPE@3@II@Z@4VVector2@3@A
_BSS	SEGMENT
?maskUvScale@?1??fillContext@ParametricShape@Ogre@@QAEXPAVSceneRenderer@3@PAVShaderContext@3@W4PARAMSHAPE_TYPE@3@II@Z@4VVector2@3@A DQ 01H DUP (?) ; `Ogre::ParametricShape::fillContext'::`2'::maskUvScale
_BSS	ENDS
;	COMDAT ?maskUvOffset@?1??fillContext@ParametricShape@Ogre@@QAEXPAVSceneRenderer@3@PAVShaderContext@3@W4PARAMSHAPE_TYPE@3@II@Z@4VVector2@3@A
_BSS	SEGMENT
?maskUvOffset@?1??fillContext@ParametricShape@Ogre@@QAEXPAVSceneRenderer@3@PAVShaderContext@3@W4PARAMSHAPE_TYPE@3@II@Z@4VVector2@3@A DQ 01H DUP (?) ; `Ogre::ParametricShape::fillContext'::`2'::maskUvOffset
_BSS	ENDS
;	COMDAT ?maskUvTile@?1??fillContext@ParametricShape@Ogre@@QAEXPAVSceneRenderer@3@PAVShaderContext@3@W4PARAMSHAPE_TYPE@3@II@Z@4VVector4@3@A
_BSS	SEGMENT
?maskUvTile@?1??fillContext@ParametricShape@Ogre@@QAEXPAVSceneRenderer@3@PAVShaderContext@3@W4PARAMSHAPE_TYPE@3@II@Z@4VVector4@3@A DB 010H DUP (?) ; `Ogre::ParametricShape::fillContext'::`2'::maskUvTile
_BSS	ENDS
;	COMDAT ?uvTile@?1??fillContext@ParametricShape@Ogre@@QAEXPAVSceneRenderer@3@PAVShaderContext@3@W4PARAMSHAPE_TYPE@3@II@Z@4VVector4@3@A
_BSS	SEGMENT
?uvTile@?1??fillContext@ParametricShape@Ogre@@QAEXPAVSceneRenderer@3@PAVShaderContext@3@W4PARAMSHAPE_TYPE@3@II@Z@4VVector4@3@A DB 010H DUP (?) ; `Ogre::ParametricShape::fillContext'::`2'::uvTile
_BSS	ENDS
;	COMDAT ?uvRotate@?1??fillContext@ParametricShape@Ogre@@QAEXPAVSceneRenderer@3@PAVShaderContext@3@W4PARAMSHAPE_TYPE@3@II@Z@4VVector2@3@A
_BSS	SEGMENT
?uvRotate@?1??fillContext@ParametricShape@Ogre@@QAEXPAVSceneRenderer@3@PAVShaderContext@3@W4PARAMSHAPE_TYPE@3@II@Z@4VVector2@3@A DQ 01H DUP (?) ; `Ogre::ParametricShape::fillContext'::`2'::uvRotate
_BSS	ENDS
;	COMDAT ?uvScale@?1??fillContext@ParametricShape@Ogre@@QAEXPAVSceneRenderer@3@PAVShaderContext@3@W4PARAMSHAPE_TYPE@3@II@Z@4VVector2@3@A
_BSS	SEGMENT
?uvScale@?1??fillContext@ParametricShape@Ogre@@QAEXPAVSceneRenderer@3@PAVShaderContext@3@W4PARAMSHAPE_TYPE@3@II@Z@4VVector2@3@A DQ 01H DUP (?) ; `Ogre::ParametricShape::fillContext'::`2'::uvScale
_BSS	ENDS
;	COMDAT ?uvOffset@?1??fillContext@ParametricShape@Ogre@@QAEXPAVSceneRenderer@3@PAVShaderContext@3@W4PARAMSHAPE_TYPE@3@II@Z@4VVector2@3@A
_BSS	SEGMENT
?uvOffset@?1??fillContext@ParametricShape@Ogre@@QAEXPAVSceneRenderer@3@PAVShaderContext@3@W4PARAMSHAPE_TYPE@3@II@Z@4VVector2@3@A DQ 01H DUP (?) ; `Ogre::ParametricShape::fillContext'::`2'::uvOffset
_BSS	ENDS
;	COMDAT ?$S10@?1??fillContext@ParametricShape@Ogre@@QAEXPAVSceneRenderer@3@PAVShaderContext@3@W4PARAMSHAPE_TYPE@3@II@Z@4IA
_BSS	SEGMENT
?$S10@?1??fillContext@ParametricShape@Ogre@@QAEXPAVSceneRenderer@3@PAVShaderContext@3@W4PARAMSHAPE_TYPE@3@II@Z@4IA DD 01H DUP (?) ; `Ogre::ParametricShape::fillContext'::`2'::$S10
_BSS	ENDS
;	COMDAT __real@4000000000000000
CONST	SEGMENT
__real@4000000000000000 DQ 04000000000000000r	; 2
CONST	ENDS
;	COMDAT __real@4076800000000000
CONST	SEGMENT
__real@4076800000000000 DQ 04076800000000000r	; 360
CONST	ENDS
;	COMDAT __real@4066800000000000
CONST	SEGMENT
__real@4066800000000000 DQ 04066800000000000r	; 180
CONST	ENDS
xdata$x	SEGMENT
__ehfuncinfo$?fillContext@ParametricShape@Ogre@@QAEXPAVSceneRenderer@2@PAVShaderContext@2@W4PARAMSHAPE_TYPE@2@II@Z DD 019930522H
	DD	09H
	DD	FLAT:__unwindtable$?fillContext@ParametricShape@Ogre@@QAEXPAVSceneRenderer@2@PAVShaderContext@2@W4PARAMSHAPE_TYPE@2@II@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__unwindtable$?fillContext@ParametricShape@Ogre@@QAEXPAVSceneRenderer@2@PAVShaderContext@2@W4PARAMSHAPE_TYPE@2@II@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?fillContext@ParametricShape@Ogre@@QAEXPAVSceneRenderer@2@PAVShaderContext@2@W4PARAMSHAPE_TYPE@2@II@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?fillContext@ParametricShape@Ogre@@QAEXPAVSceneRenderer@2@PAVShaderContext@2@W4PARAMSHAPE_TYPE@2@II@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?fillContext@ParametricShape@Ogre@@QAEXPAVSceneRenderer@2@PAVShaderContext@2@W4PARAMSHAPE_TYPE@2@II@Z$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?fillContext@ParametricShape@Ogre@@QAEXPAVSceneRenderer@2@PAVShaderContext@2@W4PARAMSHAPE_TYPE@2@II@Z$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?fillContext@ParametricShape@Ogre@@QAEXPAVSceneRenderer@2@PAVShaderContext@2@W4PARAMSHAPE_TYPE@2@II@Z$4
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?fillContext@ParametricShape@Ogre@@QAEXPAVSceneRenderer@2@PAVShaderContext@2@W4PARAMSHAPE_TYPE@2@II@Z$5
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?fillContext@ParametricShape@Ogre@@QAEXPAVSceneRenderer@2@PAVShaderContext@2@W4PARAMSHAPE_TYPE@2@II@Z$6
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?fillContext@ParametricShape@Ogre@@QAEXPAVSceneRenderer@2@PAVShaderContext@2@W4PARAMSHAPE_TYPE@2@II@Z$7
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?fillContext@ParametricShape@Ogre@@QAEXPAVSceneRenderer@2@PAVShaderContext@2@W4PARAMSHAPE_TYPE@2@II@Z$8
; Function compile flags: /Odtp
xdata$x	ENDS
_TEXT	SEGMENT
tv1866 = -688						; size = 4
tv1862 = -684						; size = 8
tv1860 = -676						; size = 4
tv1856 = -672						; size = 8
tv1849 = -664						; size = 4
tv1845 = -660						; size = 8
tv1843 = -652						; size = 4
tv1839 = -648						; size = 8
tv1830 = -640						; size = 4
tv1824 = -636						; size = 4
tv1822 = -632						; size = 4
tv1798 = -628						; size = 8
tv1792 = -620						; size = 8
tv1779 = -612						; size = 8
tv1772 = -604						; size = 8
tv1726 = -596						; size = 4
tv1722 = -592						; size = 8
tv1720 = -584						; size = 4
tv1716 = -580						; size = 8
tv1709 = -572						; size = 4
tv1705 = -568						; size = 8
tv1703 = -560						; size = 4
tv1699 = -556						; size = 8
tv1690 = -548						; size = 4
tv1684 = -544						; size = 4
tv1682 = -540						; size = 4
tv1660 = -536						; size = 8
tv1650 = -528						; size = 8
tv1633 = -520						; size = 8
tv1620 = -512						; size = 8
tv1613 = -504						; size = 8
tv1606 = -496						; size = 8
tv1560 = -488						; size = 4
tv1556 = -484						; size = 8
tv1554 = -476						; size = 4
tv1550 = -472						; size = 8
tv1543 = -464						; size = 4
tv1539 = -460						; size = 8
tv1537 = -452						; size = 4
tv1533 = -448						; size = 8
tv1524 = -440						; size = 4
tv1922 = -436						; size = 8
tv1516 = -428						; size = 4
tv1510 = -424						; size = 4
tv1504 = -420						; size = 4
tv1502 = -416						; size = 4
tv1920 = -412						; size = 8
tv1494 = -404						; size = 4
tv1471 = -400						; size = 8
tv1465 = -392						; size = 8
tv1452 = -384						; size = 8
tv1445 = -376						; size = 8
tv1397 = -368						; size = 4
tv1393 = -364						; size = 8
tv1391 = -356						; size = 4
tv1387 = -352						; size = 8
tv1380 = -344						; size = 4
tv1376 = -340						; size = 8
tv1374 = -332						; size = 4
tv1370 = -328						; size = 8
tv1358 = -320						; size = 4
tv1918 = -316						; size = 8
tv1343 = -308						; size = 4
tv1916 = -304						; size = 8
tv1323 = -296						; size = 8
tv1317 = -288						; size = 8
tv1304 = -280						; size = 8
tv1297 = -272						; size = 8
tv1278 = -264						; size = 4
tv1274 = -260						; size = 4
tv1210 = -256						; size = 4
tv1206 = -252						; size = 4
_this$ = -248						; size = 4
_beta$70116 = -244					; size = 4
_oneVertexUvMask$70120 = -240				; size = 4
_oneVertex$70113 = -236					; size = 4
_radius$70117 = -232					; size = 4
_oneVertexPos$70118 = -228				; size = 4
_thita$70114 = -224					; size = 4
_alpha$70115 = -220					; size = 4
_oneVertexUv$70119 = -216				; size = 4
_nCurColumn$70109 = -212				; size = 4
_nCurRow$70105 = -208					; size = 4
_du$70103 = -204					; size = 4
_dv$70104 = -200					; size = 4
_nCurIndexBufferIndex$70102 = -196			; size = 4
_beta$70085 = -192					; size = 4
_oneVertexUvMask$70091 = -188				; size = 4
_oneVertex$70082 = -184					; size = 4
_radius$70088 = -180					; size = 4
_oneVertexPos$70089 = -176				; size = 4
_thita$70083 = -172					; size = 4
_alpha$70084 = -168					; size = 4
_oneVertexUv$70090 = -164				; size = 4
_nCurColumn$70078 = -160				; size = 4
_nCurRow$70074 = -156					; size = 4
_du$70070 = -152					; size = 4
_dv$70071 = -148					; size = 4
_nCurIndexBufferIndex$70073 = -144			; size = 4
_dvv$70072 = -140					; size = 4
_oneVertexUvMask$70059 = -136				; size = 4
_oneVertex$70054 = -132					; size = 4
_oneVertexPos$70057 = -128				; size = 4
_thita$70055 = -124					; size = 4
_alpha$70056 = -120					; size = 4
_oneVertexUv$70058 = -116				; size = 4
_nCurColumn$70050 = -112				; size = 4
_nCurRow$70046 = -108					; size = 4
_du$70044 = -104					; size = 4
_dv$70045 = -100					; size = 4
_nCurIndexBufferIndex$70043 = -96			; size = 4
_oneVertexUvMask$70029 = -92				; size = 4
_oneVertex$70024 = -88					; size = 4
_oneVertexPos$70027 = -84				; size = 4
_thita$70025 = -80					; size = 4
_alpha$70026 = -76					; size = 4
_oneVertexUv$70028 = -72				; size = 4
_nCurColumn$70020 = -68					; size = 4
_nCurRow$70016 = -64					; size = 4
_du$70014 = -60						; size = 4
_dv$70015 = -56						; size = 4
_nCurIndexBufferIndex$70013 = -52			; size = 4
_iTotalTile$ = -48					; size = 4
_iRow$ = -44						; size = 4
_pVertices$ = -40					; size = 4
_pVertexBuffer$ = -36					; size = 4
_iCol$ = -32						; size = 4
_$S11$ = -28						; size = 4
_color$ = -24						; size = 4
_pIndexBuffer$ = -20					; size = 4
_pIndices$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_pRenderer$ = 8						; size = 4
_pcontext$ = 12						; size = 4
_GeoType$ = 16						; size = 4
_nSegu$ = 20						; size = 4
_nSegv$ = 24						; size = 4
?fillContext@ParametricShape@Ogre@@QAEXPAVSceneRenderer@2@PAVShaderContext@2@W4PARAMSHAPE_TYPE@2@II@Z PROC ; Ogre::ParametricShape::fillContext
; _this$ = ecx

; 177  : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?fillContext@ParametricShape@Ogre@@QAEXPAVSceneRenderer@2@PAVShaderContext@2@W4PARAMSHAPE_TYPE@2@II@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 676				; 000002a4H
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 178  : 		DynamicVertexBuffer*	pVertexBuffer	= pRenderer->newDynamicVB( m_VertFmt, m_nVerts );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+292]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 296				; 00000128H
	push	edx
	mov	ecx, DWORD PTR _pRenderer$[ebp]
	call	?newDynamicVB@SceneRenderer@Ogre@@QAEPAVDynamicVertexBuffer@2@ABVVertexFormat@2@I@Z ; Ogre::SceneRenderer::newDynamicVB
	mov	DWORD PTR _pVertexBuffer$[ebp], eax

; 179  : 		DynamicIndexBuffer*		pIndexBuffer	= pRenderer->newDynamicIB( m_nIndex );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+288]
	push	ecx
	mov	ecx, DWORD PTR _pRenderer$[ebp]
	call	?newDynamicIB@SceneRenderer@Ogre@@QAEPAVDynamicIndexBuffer@2@I@Z ; Ogre::SceneRenderer::newDynamicIB
	mov	DWORD PTR _pIndexBuffer$[ebp], eax

; 180  : 		GEOMETRY_VERT*			pVertices		= ( GEOMETRY_VERT* )pVertexBuffer->lock();

	mov	ecx, DWORD PTR _pVertexBuffer$[ebp]
	call	?lock@DynamicVertexBuffer@Ogre@@QAEPAXXZ ; Ogre::DynamicVertexBuffer::lock
	mov	DWORD PTR _pVertices$[ebp], eax

; 181  : 		ushort*					pIndices		= ( ushort* )pIndexBuffer->lock();

	mov	ecx, DWORD PTR _pIndexBuffer$[ebp]
	call	?lock@DynamicIndexBuffer@Ogre@@QAEPAXXZ	; Ogre::DynamicIndexBuffer::lock
	mov	DWORD PTR _pIndices$[ebp], eax

; 182  : 
; 183  : 		static Vector2 uvOffset;

	mov	edx, DWORD PTR ?$S10@?1??fillContext@ParametricShape@Ogre@@QAEXPAVSceneRenderer@3@PAVShaderContext@3@W4PARAMSHAPE_TYPE@3@II@Z@4IA
	and	edx, 1
	jne	SHORT $LN51@fillContex
	mov	eax, DWORD PTR ?$S10@?1??fillContext@ParametricShape@Ogre@@QAEXPAVSceneRenderer@3@PAVShaderContext@3@W4PARAMSHAPE_TYPE@3@II@Z@4IA
	or	eax, 1
	mov	DWORD PTR ?$S10@?1??fillContext@ParametricShape@Ogre@@QAEXPAVSceneRenderer@3@PAVShaderContext@3@W4PARAMSHAPE_TYPE@3@II@Z@4IA, eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, OFFSET ?uvOffset@?1??fillContext@ParametricShape@Ogre@@QAEXPAVSceneRenderer@3@PAVShaderContext@3@W4PARAMSHAPE_TYPE@3@II@Z@4VVector2@3@A
	call	??0Vector2@Ogre@@QAE@XZ			; Ogre::Vector2::Vector2
	mov	DWORD PTR __$EHRec$[ebp+8], -1
$LN51@fillContex:

; 184  : 		static Vector2 uvScale;

	mov	ecx, DWORD PTR ?$S10@?1??fillContext@ParametricShape@Ogre@@QAEXPAVSceneRenderer@3@PAVShaderContext@3@W4PARAMSHAPE_TYPE@3@II@Z@4IA
	and	ecx, 2
	jne	SHORT $LN50@fillContex
	mov	edx, DWORD PTR ?$S10@?1??fillContext@ParametricShape@Ogre@@QAEXPAVSceneRenderer@3@PAVShaderContext@3@W4PARAMSHAPE_TYPE@3@II@Z@4IA
	or	edx, 2
	mov	DWORD PTR ?$S10@?1??fillContext@ParametricShape@Ogre@@QAEXPAVSceneRenderer@3@PAVShaderContext@3@W4PARAMSHAPE_TYPE@3@II@Z@4IA, edx
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	mov	ecx, OFFSET ?uvScale@?1??fillContext@ParametricShape@Ogre@@QAEXPAVSceneRenderer@3@PAVShaderContext@3@W4PARAMSHAPE_TYPE@3@II@Z@4VVector2@3@A
	call	??0Vector2@Ogre@@QAE@XZ			; Ogre::Vector2::Vector2
	mov	DWORD PTR __$EHRec$[ebp+8], -1
$LN50@fillContex:

; 185  : 		static Vector2 uvRotate;

	mov	eax, DWORD PTR ?$S10@?1??fillContext@ParametricShape@Ogre@@QAEXPAVSceneRenderer@3@PAVShaderContext@3@W4PARAMSHAPE_TYPE@3@II@Z@4IA
	and	eax, 4
	jne	SHORT $LN49@fillContex
	mov	ecx, DWORD PTR ?$S10@?1??fillContext@ParametricShape@Ogre@@QAEXPAVSceneRenderer@3@PAVShaderContext@3@W4PARAMSHAPE_TYPE@3@II@Z@4IA
	or	ecx, 4
	mov	DWORD PTR ?$S10@?1??fillContext@ParametricShape@Ogre@@QAEXPAVSceneRenderer@3@PAVShaderContext@3@W4PARAMSHAPE_TYPE@3@II@Z@4IA, ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 2
	mov	ecx, OFFSET ?uvRotate@?1??fillContext@ParametricShape@Ogre@@QAEXPAVSceneRenderer@3@PAVShaderContext@3@W4PARAMSHAPE_TYPE@3@II@Z@4VVector2@3@A
	call	??0Vector2@Ogre@@QAE@XZ			; Ogre::Vector2::Vector2
	mov	DWORD PTR __$EHRec$[ebp+8], -1
$LN49@fillContex:

; 186  : 		static Vector4 uvTile;

	mov	edx, DWORD PTR ?$S10@?1??fillContext@ParametricShape@Ogre@@QAEXPAVSceneRenderer@3@PAVShaderContext@3@W4PARAMSHAPE_TYPE@3@II@Z@4IA
	and	edx, 8
	jne	SHORT $LN48@fillContex
	mov	eax, DWORD PTR ?$S10@?1??fillContext@ParametricShape@Ogre@@QAEXPAVSceneRenderer@3@PAVShaderContext@3@W4PARAMSHAPE_TYPE@3@II@Z@4IA
	or	eax, 8
	mov	DWORD PTR ?$S10@?1??fillContext@ParametricShape@Ogre@@QAEXPAVSceneRenderer@3@PAVShaderContext@3@W4PARAMSHAPE_TYPE@3@II@Z@4IA, eax
	mov	DWORD PTR __$EHRec$[ebp+8], 3
	mov	ecx, OFFSET ?uvTile@?1??fillContext@ParametricShape@Ogre@@QAEXPAVSceneRenderer@3@PAVShaderContext@3@W4PARAMSHAPE_TYPE@3@II@Z@4VVector4@3@A
	call	??0Vector4@Ogre@@QAE@XZ			; Ogre::Vector4::Vector4
	mov	DWORD PTR __$EHRec$[ebp+8], -1
$LN48@fillContex:

; 187  : 
; 188  : 		uvOffset.setElement( m_FrameData.m_UOffset,	m_FrameData.m_VOffset );

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	fld	DWORD PTR [ecx+396]
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _this$[ebp]
	push	ecx
	fld	DWORD PTR [edx+392]
	fstp	DWORD PTR [esp]
	mov	ecx, OFFSET ?uvOffset@?1??fillContext@ParametricShape@Ogre@@QAEXPAVSceneRenderer@3@PAVShaderContext@3@W4PARAMSHAPE_TYPE@3@II@Z@4VVector2@3@A
	call	?setElement@Vector2@Ogre@@QAEXMM@Z	; Ogre::Vector2::setElement

; 189  : 		uvScale.setElement( m_FrameData.m_UScale,	m_FrameData.m_VScale );

	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	fld	DWORD PTR [eax+408]
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	fld	DWORD PTR [ecx+404]
	fstp	DWORD PTR [esp]
	mov	ecx, OFFSET ?uvScale@?1??fillContext@ParametricShape@Ogre@@QAEXPAVSceneRenderer@3@PAVShaderContext@3@W4PARAMSHAPE_TYPE@3@II@Z@4VVector2@3@A
	call	?setElement@Vector2@Ogre@@QAEXMM@Z	; Ogre::Vector2::setElement

; 190  : 		uvRotate.setElement( fastSin( m_FrameData.m_UVRotate ), fastCos( m_FrameData.m_UVRotate ) );

	mov	edx, DWORD PTR _this$[ebp]
	push	ecx
	fld	DWORD PTR [edx+412]
	fstp	DWORD PTR [esp]
	call	?fastCos@Ogre@@YAMM@Z			; Ogre::fastCos
	fstp	DWORD PTR [esp]
	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	fld	DWORD PTR [eax+412]
	fstp	DWORD PTR [esp]
	call	?fastSin@Ogre@@YAMM@Z			; Ogre::fastSin
	fstp	DWORD PTR [esp]
	mov	ecx, OFFSET ?uvRotate@?1??fillContext@ParametricShape@Ogre@@QAEXPAVSceneRenderer@3@PAVShaderContext@3@W4PARAMSHAPE_TYPE@3@II@Z@4VVector2@3@A
	call	?setElement@Vector2@Ogre@@QAEXMM@Z	; Ogre::Vector2::setElement

; 191  : 
; 192  : 		int iTotalTile	= m_pSource->m_iTexCol * m_pSource->m_iTexRow;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+280]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+280]
	mov	edx, DWORD PTR [edx+28]
	imul	edx, DWORD PTR [ecx+32]
	mov	DWORD PTR _iTotalTile$[ebp], edx

; 193  : 		int iCol		= m_FrameData.m_iCurrTile / m_pSource->m_iTexCol;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+280]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+436]
	cdq
	idiv	DWORD PTR [ecx+28]
	mov	DWORD PTR _iCol$[ebp], eax

; 194  : 		int iRow		= m_FrameData.m_iCurrTile % m_pSource->m_iTexCol;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+280]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+436]
	cdq
	idiv	DWORD PTR [ecx+28]
	mov	DWORD PTR _iRow$[ebp], edx

; 195  : 
; 196  : 		uvTile.setElement(	( float )iCol / ( float )m_pSource->m_iTexCol, 
; 197  : 			( float )iRow / ( float )m_pSource->m_iTexRow, 
; 198  : 			( float )m_pSource->m_iTexCol, 
; 199  : 			( float )m_pSource->m_iTexRow 
; 200  : 			);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+280]
	fild	DWORD PTR [ecx+32]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+280]
	fild	DWORD PTR [eax+28]
	push	ecx
	fstp	DWORD PTR [esp]
	fild	DWORD PTR _iRow$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+280]
	fidiv	DWORD PTR [edx+32]
	fstp	DWORD PTR tv1206[ebp]
	fld	DWORD PTR tv1206[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	fild	DWORD PTR _iCol$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+280]
	fidiv	DWORD PTR [ecx+28]
	fstp	DWORD PTR tv1210[ebp]
	fld	DWORD PTR tv1210[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, OFFSET ?uvTile@?1??fillContext@ParametricShape@Ogre@@QAEXPAVSceneRenderer@3@PAVShaderContext@3@W4PARAMSHAPE_TYPE@3@II@Z@4VVector4@3@A
	call	?setElement@Vector4@Ogre@@QAEXMMMM@Z	; Ogre::Vector4::setElement

; 201  : 
; 202  : 		static Vector4 maskUvTile;

	mov	edx, DWORD PTR ?$S10@?1??fillContext@ParametricShape@Ogre@@QAEXPAVSceneRenderer@3@PAVShaderContext@3@W4PARAMSHAPE_TYPE@3@II@Z@4IA
	and	edx, 16					; 00000010H
	jne	SHORT $LN47@fillContex
	mov	eax, DWORD PTR ?$S10@?1??fillContext@ParametricShape@Ogre@@QAEXPAVSceneRenderer@3@PAVShaderContext@3@W4PARAMSHAPE_TYPE@3@II@Z@4IA
	or	eax, 16					; 00000010H
	mov	DWORD PTR ?$S10@?1??fillContext@ParametricShape@Ogre@@QAEXPAVSceneRenderer@3@PAVShaderContext@3@W4PARAMSHAPE_TYPE@3@II@Z@4IA, eax
	mov	DWORD PTR __$EHRec$[ebp+8], 4
	mov	ecx, OFFSET ?maskUvTile@?1??fillContext@ParametricShape@Ogre@@QAEXPAVSceneRenderer@3@PAVShaderContext@3@W4PARAMSHAPE_TYPE@3@II@Z@4VVector4@3@A
	call	??0Vector4@Ogre@@QAE@XZ			; Ogre::Vector4::Vector4
	mov	DWORD PTR __$EHRec$[ebp+8], -1
$LN47@fillContex:

; 203  : 		static Vector2 maskUvOffset;

	mov	ecx, DWORD PTR ?$S10@?1??fillContext@ParametricShape@Ogre@@QAEXPAVSceneRenderer@3@PAVShaderContext@3@W4PARAMSHAPE_TYPE@3@II@Z@4IA
	and	ecx, 32					; 00000020H
	jne	SHORT $LN46@fillContex
	mov	edx, DWORD PTR ?$S10@?1??fillContext@ParametricShape@Ogre@@QAEXPAVSceneRenderer@3@PAVShaderContext@3@W4PARAMSHAPE_TYPE@3@II@Z@4IA
	or	edx, 32					; 00000020H
	mov	DWORD PTR ?$S10@?1??fillContext@ParametricShape@Ogre@@QAEXPAVSceneRenderer@3@PAVShaderContext@3@W4PARAMSHAPE_TYPE@3@II@Z@4IA, edx
	mov	DWORD PTR __$EHRec$[ebp+8], 5
	mov	ecx, OFFSET ?maskUvOffset@?1??fillContext@ParametricShape@Ogre@@QAEXPAVSceneRenderer@3@PAVShaderContext@3@W4PARAMSHAPE_TYPE@3@II@Z@4VVector2@3@A
	call	??0Vector2@Ogre@@QAE@XZ			; Ogre::Vector2::Vector2
	mov	DWORD PTR __$EHRec$[ebp+8], -1
$LN46@fillContex:

; 204  : 		static Vector2 maskUvScale;

	mov	eax, DWORD PTR ?$S10@?1??fillContext@ParametricShape@Ogre@@QAEXPAVSceneRenderer@3@PAVShaderContext@3@W4PARAMSHAPE_TYPE@3@II@Z@4IA
	and	eax, 64					; 00000040H
	jne	SHORT $LN45@fillContex
	mov	ecx, DWORD PTR ?$S10@?1??fillContext@ParametricShape@Ogre@@QAEXPAVSceneRenderer@3@PAVShaderContext@3@W4PARAMSHAPE_TYPE@3@II@Z@4IA
	or	ecx, 64					; 00000040H
	mov	DWORD PTR ?$S10@?1??fillContext@ParametricShape@Ogre@@QAEXPAVSceneRenderer@3@PAVShaderContext@3@W4PARAMSHAPE_TYPE@3@II@Z@4IA, ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 6
	mov	ecx, OFFSET ?maskUvScale@?1??fillContext@ParametricShape@Ogre@@QAEXPAVSceneRenderer@3@PAVShaderContext@3@W4PARAMSHAPE_TYPE@3@II@Z@4VVector2@3@A
	call	??0Vector2@Ogre@@QAE@XZ			; Ogre::Vector2::Vector2
	mov	DWORD PTR __$EHRec$[ebp+8], -1
$LN45@fillContex:

; 205  : 		static Vector2 maskUvRoate;

	mov	edx, DWORD PTR ?$S10@?1??fillContext@ParametricShape@Ogre@@QAEXPAVSceneRenderer@3@PAVShaderContext@3@W4PARAMSHAPE_TYPE@3@II@Z@4IA
	and	edx, 128				; 00000080H
	jne	SHORT $LN44@fillContex
	mov	eax, DWORD PTR ?$S10@?1??fillContext@ParametricShape@Ogre@@QAEXPAVSceneRenderer@3@PAVShaderContext@3@W4PARAMSHAPE_TYPE@3@II@Z@4IA
	or	eax, 128				; 00000080H
	mov	DWORD PTR ?$S10@?1??fillContext@ParametricShape@Ogre@@QAEXPAVSceneRenderer@3@PAVShaderContext@3@W4PARAMSHAPE_TYPE@3@II@Z@4IA, eax
	mov	DWORD PTR __$EHRec$[ebp+8], 7
	mov	ecx, OFFSET ?maskUvRoate@?1??fillContext@ParametricShape@Ogre@@QAEXPAVSceneRenderer@3@PAVShaderContext@3@W4PARAMSHAPE_TYPE@3@II@Z@4VVector2@3@A
	call	??0Vector2@Ogre@@QAE@XZ			; Ogre::Vector2::Vector2
	mov	DWORD PTR __$EHRec$[ebp+8], -1
$LN44@fillContex:

; 206  : 
; 207  : 		if ( m_pCurMaskTex != NULL )

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+328], 0
	je	$LN43@fillContex

; 208  : 		{
; 209  : 			maskUvOffset.setElement( m_FrameData.m_MaskUOffset,	m_FrameData.m_MaskVOffset );

	mov	edx, DWORD PTR _this$[ebp]
	push	ecx
	fld	DWORD PTR [edx+420]
	fstp	DWORD PTR [esp]
	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	fld	DWORD PTR [eax+416]
	fstp	DWORD PTR [esp]
	mov	ecx, OFFSET ?maskUvOffset@?1??fillContext@ParametricShape@Ogre@@QAEXPAVSceneRenderer@3@PAVShaderContext@3@W4PARAMSHAPE_TYPE@3@II@Z@4VVector2@3@A
	call	?setElement@Vector2@Ogre@@QAEXMM@Z	; Ogre::Vector2::setElement

; 210  : 			maskUvScale.setElement( m_FrameData.m_MaskUScale,	m_FrameData.m_MaskVScale );

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	fld	DWORD PTR [ecx+428]
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _this$[ebp]
	push	ecx
	fld	DWORD PTR [edx+424]
	fstp	DWORD PTR [esp]
	mov	ecx, OFFSET ?maskUvScale@?1??fillContext@ParametricShape@Ogre@@QAEXPAVSceneRenderer@3@PAVShaderContext@3@W4PARAMSHAPE_TYPE@3@II@Z@4VVector2@3@A
	call	?setElement@Vector2@Ogre@@QAEXMM@Z	; Ogre::Vector2::setElement

; 211  : 			maskUvRoate.setElement( fastSin( m_FrameData.m_MaskUVRotate ), fastCos( m_FrameData.m_MaskUVRotate ) );

	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	fld	DWORD PTR [eax+432]
	fstp	DWORD PTR [esp]
	call	?fastCos@Ogre@@YAMM@Z			; Ogre::fastCos
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	fld	DWORD PTR [ecx+432]
	fstp	DWORD PTR [esp]
	call	?fastSin@Ogre@@YAMM@Z			; Ogre::fastSin
	fstp	DWORD PTR [esp]
	mov	ecx, OFFSET ?maskUvRoate@?1??fillContext@ParametricShape@Ogre@@QAEXPAVSceneRenderer@3@PAVShaderContext@3@W4PARAMSHAPE_TYPE@3@II@Z@4VVector2@3@A
	call	?setElement@Vector2@Ogre@@QAEXMM@Z	; Ogre::Vector2::setElement

; 212  : 
; 213  : 			iTotalTile		= m_pSource->m_iMaskTexCol * m_pSource->m_iMaskTexRow;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+280]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+280]
	mov	eax, DWORD PTR [eax+64]
	imul	eax, DWORD PTR [edx+68]
	mov	DWORD PTR _iTotalTile$[ebp], eax

; 214  : 			iCol			= m_FrameData.m_iCurrMaskTile / m_pSource->m_iMaskTexCol;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+280]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+440]
	cdq
	idiv	DWORD PTR [ecx+64]
	mov	DWORD PTR _iCol$[ebp], eax

; 215  : 			iRow			= m_FrameData.m_iCurrMaskTile % m_pSource->m_iMaskTexCol;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+280]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+440]
	cdq
	idiv	DWORD PTR [ecx+64]
	mov	DWORD PTR _iRow$[ebp], edx

; 216  : 
; 217  : 			maskUvTile.setElement(	( float )iCol / ( float )m_pSource->m_iMaskTexCol, 
; 218  : 				( float )iRow / ( float )m_pSource->m_iMaskTexRow, 
; 219  : 				( float )m_pSource->m_iMaskTexCol, 
; 220  : 				( float )m_pSource->m_iMaskTexRow
; 221  : 				);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+280]
	fild	DWORD PTR [ecx+68]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+280]
	fild	DWORD PTR [eax+64]
	push	ecx
	fstp	DWORD PTR [esp]
	fild	DWORD PTR _iRow$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+280]
	fidiv	DWORD PTR [edx+68]
	fstp	DWORD PTR tv1274[ebp]
	fld	DWORD PTR tv1274[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	fild	DWORD PTR _iCol$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+280]
	fidiv	DWORD PTR [ecx+64]
	fstp	DWORD PTR tv1278[ebp]
	fld	DWORD PTR tv1278[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, OFFSET ?maskUvTile@?1??fillContext@ParametricShape@Ogre@@QAEXPAVSceneRenderer@3@PAVShaderContext@3@W4PARAMSHAPE_TYPE@3@II@Z@4VVector4@3@A
	call	?setElement@Vector4@Ogre@@QAEXMMMM@Z	; Ogre::Vector4::setElement
$LN43@fillContex:

; 222  : 		}
; 223  : 
; 224  : 		const ColorQuad& color = GetTransparentColor( m_FrameData.m_Color, getTransparent(), m_pSource->m_iBlendMode );

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+280]
	mov	ecx, DWORD PTR [eax+24]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getTransparent@MovableObject@Ogre@@QAEMXZ ; Ogre::MovableObject::getTransparent
	push	ecx
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 376				; 00000178H
	push	edx
	call	?GetTransparentColor@Ogre@@YAABVColourValue@1@ABV21@MH@Z ; Ogre::GetTransparentColor
	add	esp, 12					; 0000000cH
	push	eax
	lea	ecx, DWORD PTR _$S11$[ebp]
	call	??0ColorQuad@Ogre@@QAE@ABVColourValue@1@@Z ; Ogre::ColorQuad::ColorQuad
	lea	eax, DWORD PTR _$S11$[ebp]
	mov	DWORD PTR _color$[ebp], eax

; 225  : 
; 226  : 		if( GeoType == GEO_SPHERE )	

	cmp	DWORD PTR _GeoType$[ebp], 0
	jne	$LN42@fillContex

; 227  : 		{ 
; 228  : 			int nCurIndexBufferIndex	= 0;

	mov	DWORD PTR _nCurIndexBufferIndex$70013[ebp], 0

; 229  : 			float du					= 1.0f / nSegu;

	mov	ecx, DWORD PTR _nSegu$[ebp]
	mov	DWORD PTR tv1297[ebp], ecx
	mov	DWORD PTR tv1297[ebp+4], 0
	fild	QWORD PTR tv1297[ebp]
	fld1
	fdivrp	ST(1), ST(0)
	fstp	DWORD PTR _du$70014[ebp]

; 230  : 			float dv					= 1.0f / nSegv;

	mov	edx, DWORD PTR _nSegv$[ebp]
	mov	DWORD PTR tv1304[ebp], edx
	mov	DWORD PTR tv1304[ebp+4], 0
	fild	QWORD PTR tv1304[ebp]
	fld1
	fdivrp	ST(1), ST(0)
	fstp	DWORD PTR _dv$70015[ebp]

; 231  : 
; 232  : 			for ( size_t nCurRow = 0; nCurRow < nSegu + 1; ++nCurRow )

	mov	DWORD PTR _nCurRow$70016[ebp], 0
	jmp	SHORT $LN41@fillContex
$LN40@fillContex:
	mov	eax, DWORD PTR _nCurRow$70016[ebp]
	add	eax, 1
	mov	DWORD PTR _nCurRow$70016[ebp], eax
$LN41@fillContex:
	mov	ecx, DWORD PTR _nSegu$[ebp]
	add	ecx, 1
	cmp	DWORD PTR _nCurRow$70016[ebp], ecx
	jae	$LN39@fillContex

; 233  : 			{
; 234  : 				for ( size_t nCurColumn = 0; nCurColumn < nSegv + 1; ++nCurColumn )

	mov	DWORD PTR _nCurColumn$70020[ebp], 0
	jmp	SHORT $LN38@fillContex
$LN37@fillContex:
	mov	edx, DWORD PTR _nCurColumn$70020[ebp]
	add	edx, 1
	mov	DWORD PTR _nCurColumn$70020[ebp], edx
$LN38@fillContex:
	mov	eax, DWORD PTR _nSegv$[ebp]
	add	eax, 1
	cmp	DWORD PTR _nCurColumn$70020[ebp], eax
	jae	$LN36@fillContex

; 235  : 				{
; 236  : 					GEOMETRY_VERT &oneVertex = pVertices[nCurRow * ( nSegv + 1 ) + nCurColumn];

	mov	ecx, DWORD PTR _nSegv$[ebp]
	add	ecx, 1
	imul	ecx, DWORD PTR _nCurRow$70016[ebp]
	add	ecx, DWORD PTR _nCurColumn$70020[ebp]
	shl	ecx, 5
	add	ecx, DWORD PTR _pVertices$[ebp]
	mov	DWORD PTR _oneVertex$70024[ebp], ecx

; 237  : 
; 238  : 					float thita = nCurRow * du * 2 * 180.0f;

	mov	edx, DWORD PTR _nCurRow$70016[ebp]
	mov	DWORD PTR tv1317[ebp], edx
	mov	DWORD PTR tv1317[ebp+4], 0
	fild	QWORD PTR tv1317[ebp]
	fmul	DWORD PTR _du$70014[ebp]
	fadd	ST(0), ST(0)
	fmul	QWORD PTR __real@4066800000000000
	fstp	DWORD PTR _thita$70025[ebp]

; 239  : 					float alpha = nCurColumn * dv * 180.0f;

	mov	eax, DWORD PTR _nCurColumn$70020[ebp]
	mov	DWORD PTR tv1323[ebp], eax
	mov	DWORD PTR tv1323[ebp+4], 0
	fild	QWORD PTR tv1323[ebp]
	fmul	DWORD PTR _dv$70015[ebp]
	fmul	QWORD PTR __real@4066800000000000
	fstp	DWORD PTR _alpha$70026[ebp]

; 240  : 					thita *= m_FrameData.m_fRound/360.0f;

	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+400]
	fdiv	QWORD PTR __real@4076800000000000
	fmul	DWORD PTR _thita$70025[ebp]
	fstp	DWORD PTR _thita$70025[ebp]

; 241  : 					alpha *= m_FrameData.m_fSphereAngle/180.0f;

	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+340]
	fdiv	QWORD PTR __real@4066800000000000
	fmul	DWORD PTR _alpha$70026[ebp]
	fstp	DWORD PTR _alpha$70026[ebp]

; 242  : 
; 243  : 					Vector3& oneVertexPos = oneVertex.pos;

	mov	eax, DWORD PTR _oneVertex$70024[ebp]
	mov	DWORD PTR _oneVertexPos$70027[ebp], eax

; 244  : 					oneVertexPos.setElement( 
; 245  : 						fastCos(thita)*fastSin(alpha), 
; 246  : 						fastCos(alpha), 
; 247  : 						fastSin(thita)*fastSin(alpha) 
; 248  : 						);

	push	ecx
	fld	DWORD PTR _thita$70025[ebp]
	fstp	DWORD PTR [esp]
	call	?fastSin@Ogre@@YAMM@Z			; Ogre::fastSin
	fld	DWORD PTR _alpha$70026[ebp]
	fstp	DWORD PTR [esp]
	fstp	QWORD PTR tv1916[ebp]
	call	?fastSin@Ogre@@YAMM@Z			; Ogre::fastSin
	add	esp, 4
	fmul	QWORD PTR tv1916[ebp]
	fstp	DWORD PTR tv1343[ebp]
	fld	DWORD PTR tv1343[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR _alpha$70026[ebp]
	fstp	DWORD PTR [esp]
	call	?fastCos@Ogre@@YAMM@Z			; Ogre::fastCos
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR _thita$70025[ebp]
	fstp	DWORD PTR [esp]
	call	?fastCos@Ogre@@YAMM@Z			; Ogre::fastCos
	fld	DWORD PTR _alpha$70026[ebp]
	fstp	DWORD PTR [esp]
	fstp	QWORD PTR tv1918[ebp]
	call	?fastSin@Ogre@@YAMM@Z			; Ogre::fastSin
	add	esp, 4
	fmul	QWORD PTR tv1918[ebp]
	fstp	DWORD PTR tv1358[ebp]
	fld	DWORD PTR tv1358[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _oneVertexPos$70027[ebp]
	call	?setElement@Vector3@Ogre@@QAEXMMM@Z	; Ogre::Vector3::setElement

; 249  : 					oneVertexPos *= m_FrameData.m_fSphereRadius;

	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	fld	DWORD PTR [ecx+336]
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _oneVertexPos$70027[ebp]
	call	??XVector3@Ogre@@QAEXM@Z		; Ogre::Vector3::operator*=

; 250  : 
; 251  : 					Vector2& oneVertexUv	= oneVertex.uv;

	mov	edx, DWORD PTR _oneVertex$70024[ebp]
	add	edx, 16					; 00000010H
	mov	DWORD PTR _oneVertexUv$70028[ebp], edx

; 252  : 					oneVertexUv.setElement( nCurRow*du,nCurColumn*dv );

	mov	eax, DWORD PTR _nCurColumn$70020[ebp]
	mov	DWORD PTR tv1370[ebp], eax
	mov	DWORD PTR tv1370[ebp+4], 0
	fild	QWORD PTR tv1370[ebp]
	fmul	DWORD PTR _dv$70015[ebp]
	fstp	DWORD PTR tv1374[ebp]
	fld	DWORD PTR tv1374[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _nCurRow$70016[ebp]
	mov	DWORD PTR tv1376[ebp], ecx
	mov	DWORD PTR tv1376[ebp+4], 0
	fild	QWORD PTR tv1376[ebp]
	fmul	DWORD PTR _du$70014[ebp]
	fstp	DWORD PTR tv1380[ebp]
	fld	DWORD PTR tv1380[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _oneVertexUv$70028[ebp]
	call	?setElement@Vector2@Ogre@@QAEXMM@Z	; Ogre::Vector2::setElement

; 253  : 
; 254  : 					Vector2& oneVertexUvMask = oneVertex.uvMask;

	mov	edx, DWORD PTR _oneVertex$70024[ebp]
	add	edx, 24					; 00000018H
	mov	DWORD PTR _oneVertexUvMask$70029[ebp], edx

; 255  : 					oneVertexUvMask.setElement( nCurRow*du,nCurColumn*dv );

	mov	eax, DWORD PTR _nCurColumn$70020[ebp]
	mov	DWORD PTR tv1387[ebp], eax
	mov	DWORD PTR tv1387[ebp+4], 0
	fild	QWORD PTR tv1387[ebp]
	fmul	DWORD PTR _dv$70015[ebp]
	fstp	DWORD PTR tv1391[ebp]
	fld	DWORD PTR tv1391[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _nCurRow$70016[ebp]
	mov	DWORD PTR tv1393[ebp], ecx
	mov	DWORD PTR tv1393[ebp+4], 0
	fild	QWORD PTR tv1393[ebp]
	fmul	DWORD PTR _du$70014[ebp]
	fstp	DWORD PTR tv1397[ebp]
	fld	DWORD PTR tv1397[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _oneVertexUvMask$70029[ebp]
	call	?setElement@Vector2@Ogre@@QAEXMM@Z	; Ogre::Vector2::setElement

; 256  : 					oneVertex.color = color;

	mov	edx, DWORD PTR _color$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _oneVertex$70024[ebp]
	mov	DWORD PTR [ecx+12], eax

; 257  : 
; 258  : 					TransformUV( oneVertexUv, uvOffset, uvScale, uvRotate, uvTile );

	push	OFFSET ?uvTile@?1??fillContext@ParametricShape@Ogre@@QAEXPAVSceneRenderer@3@PAVShaderContext@3@W4PARAMSHAPE_TYPE@3@II@Z@4VVector4@3@A
	push	OFFSET ?uvRotate@?1??fillContext@ParametricShape@Ogre@@QAEXPAVSceneRenderer@3@PAVShaderContext@3@W4PARAMSHAPE_TYPE@3@II@Z@4VVector2@3@A
	push	OFFSET ?uvScale@?1??fillContext@ParametricShape@Ogre@@QAEXPAVSceneRenderer@3@PAVShaderContext@3@W4PARAMSHAPE_TYPE@3@II@Z@4VVector2@3@A
	push	OFFSET ?uvOffset@?1??fillContext@ParametricShape@Ogre@@QAEXPAVSceneRenderer@3@PAVShaderContext@3@W4PARAMSHAPE_TYPE@3@II@Z@4VVector2@3@A
	mov	edx, DWORD PTR _oneVertexUv$70028[ebp]
	push	edx
	call	?TransformUV@Ogre@@YAXAAVVector2@1@ABV21@11ABVVector4@1@@Z ; Ogre::TransformUV
	add	esp, 20					; 00000014H

; 259  : 					if(m_pSource->m_pMaskTextureRes != NULL)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+280]
	cmp	DWORD PTR [ecx+80], 0
	je	SHORT $LN35@fillContex

; 260  : 					{
; 261  : 						TransformUV( oneVertexUvMask, maskUvOffset, maskUvScale, maskUvRoate, maskUvTile );

	push	OFFSET ?maskUvTile@?1??fillContext@ParametricShape@Ogre@@QAEXPAVSceneRenderer@3@PAVShaderContext@3@W4PARAMSHAPE_TYPE@3@II@Z@4VVector4@3@A
	push	OFFSET ?maskUvRoate@?1??fillContext@ParametricShape@Ogre@@QAEXPAVSceneRenderer@3@PAVShaderContext@3@W4PARAMSHAPE_TYPE@3@II@Z@4VVector2@3@A
	push	OFFSET ?maskUvScale@?1??fillContext@ParametricShape@Ogre@@QAEXPAVSceneRenderer@3@PAVShaderContext@3@W4PARAMSHAPE_TYPE@3@II@Z@4VVector2@3@A
	push	OFFSET ?maskUvOffset@?1??fillContext@ParametricShape@Ogre@@QAEXPAVSceneRenderer@3@PAVShaderContext@3@W4PARAMSHAPE_TYPE@3@II@Z@4VVector2@3@A
	mov	edx, DWORD PTR _oneVertexUvMask$70029[ebp]
	push	edx
	call	?TransformUV@Ogre@@YAXAAVVector2@1@ABV21@11ABVVector4@1@@Z ; Ogre::TransformUV
	add	esp, 20					; 00000014H
$LN35@fillContex:

; 262  : 					}
; 263  : 
; 264  : 					if (nCurRow != nSegu && nCurColumn!=nSegv)

	mov	eax, DWORD PTR _nCurRow$70016[ebp]
	cmp	eax, DWORD PTR _nSegu$[ebp]
	je	$LN34@fillContex
	mov	ecx, DWORD PTR _nCurColumn$70020[ebp]
	cmp	ecx, DWORD PTR _nSegv$[ebp]
	je	$LN34@fillContex

; 265  : 					{
; 266  : 						pIndices[nCurIndexBufferIndex++]	=(ushort) (nCurRow*(nSegv+1) + nCurColumn);

	mov	edx, DWORD PTR _nSegv$[ebp]
	add	edx, 1
	imul	edx, DWORD PTR _nCurRow$70016[ebp]
	add	edx, DWORD PTR _nCurColumn$70020[ebp]
	mov	eax, DWORD PTR _nCurIndexBufferIndex$70013[ebp]
	mov	ecx, DWORD PTR _pIndices$[ebp]
	mov	WORD PTR [ecx+eax*2], dx
	mov	edx, DWORD PTR _nCurIndexBufferIndex$70013[ebp]
	add	edx, 1
	mov	DWORD PTR _nCurIndexBufferIndex$70013[ebp], edx

; 267  : 						pIndices[nCurIndexBufferIndex++]	=(ushort) (nCurRow*(nSegv+1) + nCurColumn+1);

	mov	eax, DWORD PTR _nSegv$[ebp]
	add	eax, 1
	imul	eax, DWORD PTR _nCurRow$70016[ebp]
	mov	ecx, DWORD PTR _nCurColumn$70020[ebp]
	lea	edx, DWORD PTR [eax+ecx+1]
	mov	eax, DWORD PTR _nCurIndexBufferIndex$70013[ebp]
	mov	ecx, DWORD PTR _pIndices$[ebp]
	mov	WORD PTR [ecx+eax*2], dx
	mov	edx, DWORD PTR _nCurIndexBufferIndex$70013[ebp]
	add	edx, 1
	mov	DWORD PTR _nCurIndexBufferIndex$70013[ebp], edx

; 268  : 						pIndices[nCurIndexBufferIndex++]	=(ushort) ((nCurRow+1)*(nSegv+1) + nCurColumn+1);

	mov	eax, DWORD PTR _nCurRow$70016[ebp]
	add	eax, 1
	mov	ecx, DWORD PTR _nSegv$[ebp]
	add	ecx, 1
	imul	eax, ecx
	mov	edx, DWORD PTR _nCurColumn$70020[ebp]
	lea	eax, DWORD PTR [eax+edx+1]
	mov	ecx, DWORD PTR _nCurIndexBufferIndex$70013[ebp]
	mov	edx, DWORD PTR _pIndices$[ebp]
	mov	WORD PTR [edx+ecx*2], ax
	mov	eax, DWORD PTR _nCurIndexBufferIndex$70013[ebp]
	add	eax, 1
	mov	DWORD PTR _nCurIndexBufferIndex$70013[ebp], eax

; 269  : 
; 270  : 						pIndices[nCurIndexBufferIndex++]	=(ushort) (nCurRow*(nSegv+1) + nCurColumn);

	mov	ecx, DWORD PTR _nSegv$[ebp]
	add	ecx, 1
	imul	ecx, DWORD PTR _nCurRow$70016[ebp]
	add	ecx, DWORD PTR _nCurColumn$70020[ebp]
	mov	edx, DWORD PTR _nCurIndexBufferIndex$70013[ebp]
	mov	eax, DWORD PTR _pIndices$[ebp]
	mov	WORD PTR [eax+edx*2], cx
	mov	ecx, DWORD PTR _nCurIndexBufferIndex$70013[ebp]
	add	ecx, 1
	mov	DWORD PTR _nCurIndexBufferIndex$70013[ebp], ecx

; 271  : 						pIndices[nCurIndexBufferIndex++]	=(ushort) ((nCurRow+1)*(nSegv+1) + nCurColumn);

	mov	edx, DWORD PTR _nCurRow$70016[ebp]
	add	edx, 1
	mov	eax, DWORD PTR _nSegv$[ebp]
	add	eax, 1
	imul	edx, eax
	add	edx, DWORD PTR _nCurColumn$70020[ebp]
	mov	ecx, DWORD PTR _nCurIndexBufferIndex$70013[ebp]
	mov	eax, DWORD PTR _pIndices$[ebp]
	mov	WORD PTR [eax+ecx*2], dx
	mov	ecx, DWORD PTR _nCurIndexBufferIndex$70013[ebp]
	add	ecx, 1
	mov	DWORD PTR _nCurIndexBufferIndex$70013[ebp], ecx

; 272  : 						pIndices[nCurIndexBufferIndex++]	=(ushort) ((nCurRow+1)*(nSegv+1) + nCurColumn+1);

	mov	edx, DWORD PTR _nCurRow$70016[ebp]
	add	edx, 1
	mov	eax, DWORD PTR _nSegv$[ebp]
	add	eax, 1
	imul	edx, eax
	mov	ecx, DWORD PTR _nCurColumn$70020[ebp]
	lea	edx, DWORD PTR [edx+ecx+1]
	mov	eax, DWORD PTR _nCurIndexBufferIndex$70013[ebp]
	mov	ecx, DWORD PTR _pIndices$[ebp]
	mov	WORD PTR [ecx+eax*2], dx
	mov	edx, DWORD PTR _nCurIndexBufferIndex$70013[ebp]
	add	edx, 1
	mov	DWORD PTR _nCurIndexBufferIndex$70013[ebp], edx
$LN34@fillContex:

; 273  : 					}
; 274  : 				}

	jmp	$LN37@fillContex
$LN36@fillContex:

; 275  : 			}

	jmp	$LN40@fillContex
$LN39@fillContex:

; 276  : 
; 277  : 			//int nCurIndexBufferIndex = 0;
; 278  : 			//for( size_t nCurRow=0; nCurRow<nSegu; nCurRow++ )
; 279  : 			//{
; 280  : 			//	for( size_t nCurColumn=0; nCurColumn<nSegv; nCurColumn++ )
; 281  : 			//	{
; 282  : 			//		pIndices[nCurIndexBufferIndex++]	=(ushort) (nCurRow*(nSegv+1) + nCurColumn);
; 283  : 			//		pIndices[nCurIndexBufferIndex++]	=(ushort) (nCurRow*(nSegv+1) + nCurColumn+1);
; 284  : 			//		pIndices[nCurIndexBufferIndex++]	=(ushort) ((nCurRow+1)*(nSegv+1) + nCurColumn+1);
; 285  : 
; 286  : 			//		pIndices[nCurIndexBufferIndex++]	=(ushort) (nCurRow*(nSegv+1) + nCurColumn);
; 287  : 			//		pIndices[nCurIndexBufferIndex++]	=(ushort) ((nCurRow+1)*(nSegv+1) + nCurColumn);
; 288  : 			//		pIndices[nCurIndexBufferIndex++]	=(ushort) ((nCurRow+1)*(nSegv+1) + nCurColumn+1);
; 289  : 			//	}
; 290  : 			//}
; 291  : 		}
; 292  : 		else if( GeoType == GEO_TORUS )

	jmp	$LN6@fillContex
$LN42@fillContex:
	cmp	DWORD PTR _GeoType$[ebp], 1
	jne	$LN32@fillContex

; 293  : 		{
; 294  : 			static Vector4 radius;

	mov	eax, DWORD PTR ?$S10@?1??fillContext@ParametricShape@Ogre@@QAEXPAVSceneRenderer@3@PAVShaderContext@3@W4PARAMSHAPE_TYPE@3@II@Z@4IA
	and	eax, 256				; 00000100H
	jne	SHORT $LN31@fillContex
	mov	ecx, DWORD PTR ?$S10@?1??fillContext@ParametricShape@Ogre@@QAEXPAVSceneRenderer@3@PAVShaderContext@3@W4PARAMSHAPE_TYPE@3@II@Z@4IA
	or	ecx, 256				; 00000100H
	mov	DWORD PTR ?$S10@?1??fillContext@ParametricShape@Ogre@@QAEXPAVSceneRenderer@3@PAVShaderContext@3@W4PARAMSHAPE_TYPE@3@II@Z@4IA, ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 8
	mov	ecx, OFFSET ?radius@?BG@??fillContext@ParametricShape@Ogre@@QAEXPAVSceneRenderer@3@PAVShaderContext@3@W4PARAMSHAPE_TYPE@3@II@Z@4VVector4@3@A
	call	??0Vector4@Ogre@@QAE@XZ			; Ogre::Vector4::Vector4
	mov	DWORD PTR __$EHRec$[ebp+8], -1
$LN31@fillContex:

; 295  : 
; 296  : 			int nCurIndexBufferIndex	= 0;

	mov	DWORD PTR _nCurIndexBufferIndex$70043[ebp], 0

; 297  : 			float du					= 1.0f / nSegu;

	mov	edx, DWORD PTR _nSegu$[ebp]
	mov	DWORD PTR tv1445[ebp], edx
	mov	DWORD PTR tv1445[ebp+4], 0
	fild	QWORD PTR tv1445[ebp]
	fld1
	fdivrp	ST(1), ST(0)
	fstp	DWORD PTR _du$70044[ebp]

; 298  : 			float dv					= 1.0f / nSegv;

	mov	eax, DWORD PTR _nSegv$[ebp]
	mov	DWORD PTR tv1452[ebp], eax
	mov	DWORD PTR tv1452[ebp+4], 0
	fild	QWORD PTR tv1452[ebp]
	fld1
	fdivrp	ST(1), ST(0)
	fstp	DWORD PTR _dv$70045[ebp]

; 299  : 
; 300  : 			for ( size_t nCurRow = 0; nCurRow < nSegu + 1; ++nCurRow )

	mov	DWORD PTR _nCurRow$70046[ebp], 0
	jmp	SHORT $LN30@fillContex
$LN29@fillContex:
	mov	ecx, DWORD PTR _nCurRow$70046[ebp]
	add	ecx, 1
	mov	DWORD PTR _nCurRow$70046[ebp], ecx
$LN30@fillContex:
	mov	edx, DWORD PTR _nSegu$[ebp]
	add	edx, 1
	cmp	DWORD PTR _nCurRow$70046[ebp], edx
	jae	$LN28@fillContex

; 301  : 			{
; 302  : 				for ( size_t nCurColumn = 0; nCurColumn < nSegv + 1; ++nCurColumn )

	mov	DWORD PTR _nCurColumn$70050[ebp], 0
	jmp	SHORT $LN27@fillContex
$LN26@fillContex:
	mov	eax, DWORD PTR _nCurColumn$70050[ebp]
	add	eax, 1
	mov	DWORD PTR _nCurColumn$70050[ebp], eax
$LN27@fillContex:
	mov	ecx, DWORD PTR _nSegv$[ebp]
	add	ecx, 1
	cmp	DWORD PTR _nCurColumn$70050[ebp], ecx
	jae	$LN25@fillContex

; 303  : 				{
; 304  : 					GEOMETRY_VERT &oneVertex = pVertices[nCurRow * ( nSegv + 1 ) + nCurColumn];

	mov	edx, DWORD PTR _nSegv$[ebp]
	add	edx, 1
	imul	edx, DWORD PTR _nCurRow$70046[ebp]
	add	edx, DWORD PTR _nCurColumn$70050[ebp]
	shl	edx, 5
	add	edx, DWORD PTR _pVertices$[ebp]
	mov	DWORD PTR _oneVertex$70054[ebp], edx

; 305  : 
; 306  : 					float thita = nCurRow * du * 2 * 180.0f;

	mov	eax, DWORD PTR _nCurRow$70046[ebp]
	mov	DWORD PTR tv1465[ebp], eax
	mov	DWORD PTR tv1465[ebp+4], 0
	fild	QWORD PTR tv1465[ebp]
	fmul	DWORD PTR _du$70044[ebp]
	fadd	ST(0), ST(0)
	fmul	QWORD PTR __real@4066800000000000
	fstp	DWORD PTR _thita$70055[ebp]

; 307  : 					float alpha = nCurColumn * dv * 180.0f;

	mov	ecx, DWORD PTR _nCurColumn$70050[ebp]
	mov	DWORD PTR tv1471[ebp], ecx
	mov	DWORD PTR tv1471[ebp+4], 0
	fild	QWORD PTR tv1471[ebp]
	fmul	DWORD PTR _dv$70045[ebp]
	fmul	QWORD PTR __real@4066800000000000
	fstp	DWORD PTR _alpha$70056[ebp]

; 308  : 					thita *= m_FrameData.m_fRound / 360.0f;

	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+400]
	fdiv	QWORD PTR __real@4076800000000000
	fmul	DWORD PTR _thita$70055[ebp]
	fstp	DWORD PTR _thita$70055[ebp]

; 309  : 
; 310  : 					radius.setElement( m_FrameData.m_fTorusNRadius, m_FrameData.m_fTorusLRadius, 0.0f, 0.0f );

	push	ecx
	fldz
	fstp	DWORD PTR [esp]
	push	ecx
	fldz
	fstp	DWORD PTR [esp]
	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	fld	DWORD PTR [eax+348]
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	fld	DWORD PTR [ecx+344]
	fstp	DWORD PTR [esp]
	mov	ecx, OFFSET ?radius@?BG@??fillContext@ParametricShape@Ogre@@QAEXPAVSceneRenderer@3@PAVShaderContext@3@W4PARAMSHAPE_TYPE@3@II@Z@4VVector4@3@A
	call	?setElement@Vector4@Ogre@@QAEXMMMM@Z	; Ogre::Vector4::setElement

; 311  : 
; 312  : 					Vector3& oneVertexPos = oneVertex.pos;

	mov	edx, DWORD PTR _oneVertex$70054[ebp]
	mov	DWORD PTR _oneVertexPos$70057[ebp], edx

; 313  : 					oneVertexPos.setElement( 
; 314  : 						fastCos( thita ) * ( radius.x + radius.y * fastSin( 2.0f * alpha ) ), 
; 315  : 						radius.y * fastCos( 2.0f * alpha ), 
; 316  : 						fastSin( thita ) * ( radius.x + radius.y * fastSin( 2.0f * alpha ) ) );

	push	ecx
	fld	DWORD PTR _thita$70055[ebp]
	fstp	DWORD PTR [esp]
	call	?fastSin@Ogre@@YAMM@Z			; Ogre::fastSin
	add	esp, 4
	fld	DWORD PTR _alpha$70056[ebp]
	fmul	QWORD PTR __real@4000000000000000
	fstp	DWORD PTR tv1494[ebp]
	fld	DWORD PTR tv1494[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	fstp	QWORD PTR tv1920[ebp]
	call	?fastSin@Ogre@@YAMM@Z			; Ogre::fastSin
	add	esp, 4
	fmul	DWORD PTR ?radius@?BG@??fillContext@ParametricShape@Ogre@@QAEXPAVSceneRenderer@3@PAVShaderContext@3@W4PARAMSHAPE_TYPE@3@II@Z@4VVector4@3@A+4
	fadd	DWORD PTR ?radius@?BG@??fillContext@ParametricShape@Ogre@@QAEXPAVSceneRenderer@3@PAVShaderContext@3@W4PARAMSHAPE_TYPE@3@II@Z@4VVector4@3@A
	fmul	QWORD PTR tv1920[ebp]
	fstp	DWORD PTR tv1502[ebp]
	fld	DWORD PTR tv1502[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	fld	DWORD PTR _alpha$70056[ebp]
	fmul	QWORD PTR __real@4000000000000000
	fstp	DWORD PTR tv1504[ebp]
	fld	DWORD PTR tv1504[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	call	?fastCos@Ogre@@YAMM@Z			; Ogre::fastCos
	add	esp, 4
	fmul	DWORD PTR ?radius@?BG@??fillContext@ParametricShape@Ogre@@QAEXPAVSceneRenderer@3@PAVShaderContext@3@W4PARAMSHAPE_TYPE@3@II@Z@4VVector4@3@A+4
	fstp	DWORD PTR tv1510[ebp]
	fld	DWORD PTR tv1510[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR _thita$70055[ebp]
	fstp	DWORD PTR [esp]
	call	?fastCos@Ogre@@YAMM@Z			; Ogre::fastCos
	add	esp, 4
	fld	DWORD PTR _alpha$70056[ebp]
	fmul	QWORD PTR __real@4000000000000000
	fstp	DWORD PTR tv1516[ebp]
	fld	DWORD PTR tv1516[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	fstp	QWORD PTR tv1922[ebp]
	call	?fastSin@Ogre@@YAMM@Z			; Ogre::fastSin
	add	esp, 4
	fmul	DWORD PTR ?radius@?BG@??fillContext@ParametricShape@Ogre@@QAEXPAVSceneRenderer@3@PAVShaderContext@3@W4PARAMSHAPE_TYPE@3@II@Z@4VVector4@3@A+4
	fadd	DWORD PTR ?radius@?BG@??fillContext@ParametricShape@Ogre@@QAEXPAVSceneRenderer@3@PAVShaderContext@3@W4PARAMSHAPE_TYPE@3@II@Z@4VVector4@3@A
	fmul	QWORD PTR tv1922[ebp]
	fstp	DWORD PTR tv1524[ebp]
	fld	DWORD PTR tv1524[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _oneVertexPos$70057[ebp]
	call	?setElement@Vector3@Ogre@@QAEXMMM@Z	; Ogre::Vector3::setElement

; 317  : 
; 318  : 					Vector2& oneVertexUv	= oneVertex.uv;

	mov	eax, DWORD PTR _oneVertex$70054[ebp]
	add	eax, 16					; 00000010H
	mov	DWORD PTR _oneVertexUv$70058[ebp], eax

; 319  : 					oneVertexUv.setElement( nCurRow * du,nCurColumn * dv );

	mov	ecx, DWORD PTR _nCurColumn$70050[ebp]
	mov	DWORD PTR tv1533[ebp], ecx
	mov	DWORD PTR tv1533[ebp+4], 0
	fild	QWORD PTR tv1533[ebp]
	fmul	DWORD PTR _dv$70045[ebp]
	fstp	DWORD PTR tv1537[ebp]
	fld	DWORD PTR tv1537[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _nCurRow$70046[ebp]
	mov	DWORD PTR tv1539[ebp], edx
	mov	DWORD PTR tv1539[ebp+4], 0
	fild	QWORD PTR tv1539[ebp]
	fmul	DWORD PTR _du$70044[ebp]
	fstp	DWORD PTR tv1543[ebp]
	fld	DWORD PTR tv1543[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _oneVertexUv$70058[ebp]
	call	?setElement@Vector2@Ogre@@QAEXMM@Z	; Ogre::Vector2::setElement

; 320  : 
; 321  : 					Vector2& oneVertexUvMask = oneVertex.uvMask;

	mov	eax, DWORD PTR _oneVertex$70054[ebp]
	add	eax, 24					; 00000018H
	mov	DWORD PTR _oneVertexUvMask$70059[ebp], eax

; 322  : 					oneVertexUvMask.setElement( nCurRow * du,nCurColumn * dv );

	mov	ecx, DWORD PTR _nCurColumn$70050[ebp]
	mov	DWORD PTR tv1550[ebp], ecx
	mov	DWORD PTR tv1550[ebp+4], 0
	fild	QWORD PTR tv1550[ebp]
	fmul	DWORD PTR _dv$70045[ebp]
	fstp	DWORD PTR tv1554[ebp]
	fld	DWORD PTR tv1554[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _nCurRow$70046[ebp]
	mov	DWORD PTR tv1556[ebp], edx
	mov	DWORD PTR tv1556[ebp+4], 0
	fild	QWORD PTR tv1556[ebp]
	fmul	DWORD PTR _du$70044[ebp]
	fstp	DWORD PTR tv1560[ebp]
	fld	DWORD PTR tv1560[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _oneVertexUvMask$70059[ebp]
	call	?setElement@Vector2@Ogre@@QAEXMM@Z	; Ogre::Vector2::setElement

; 323  : 
; 324  : 					oneVertex.color	= color;

	mov	eax, DWORD PTR _color$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _oneVertex$70054[ebp]
	mov	DWORD PTR [edx+12], ecx

; 325  : 
; 326  : 					TransformUV( oneVertexUv, uvOffset, uvScale, uvRotate, uvTile );

	push	OFFSET ?uvTile@?1??fillContext@ParametricShape@Ogre@@QAEXPAVSceneRenderer@3@PAVShaderContext@3@W4PARAMSHAPE_TYPE@3@II@Z@4VVector4@3@A
	push	OFFSET ?uvRotate@?1??fillContext@ParametricShape@Ogre@@QAEXPAVSceneRenderer@3@PAVShaderContext@3@W4PARAMSHAPE_TYPE@3@II@Z@4VVector2@3@A
	push	OFFSET ?uvScale@?1??fillContext@ParametricShape@Ogre@@QAEXPAVSceneRenderer@3@PAVShaderContext@3@W4PARAMSHAPE_TYPE@3@II@Z@4VVector2@3@A
	push	OFFSET ?uvOffset@?1??fillContext@ParametricShape@Ogre@@QAEXPAVSceneRenderer@3@PAVShaderContext@3@W4PARAMSHAPE_TYPE@3@II@Z@4VVector2@3@A
	mov	eax, DWORD PTR _oneVertexUv$70058[ebp]
	push	eax
	call	?TransformUV@Ogre@@YAXAAVVector2@1@ABV21@11ABVVector4@1@@Z ; Ogre::TransformUV
	add	esp, 20					; 00000014H

; 327  : 					if(m_pSource->m_pMaskTextureRes != NULL)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+280]
	cmp	DWORD PTR [edx+80], 0
	je	SHORT $LN24@fillContex

; 328  : 					{
; 329  : 						TransformUV( oneVertexUvMask, maskUvOffset, maskUvScale, maskUvRoate, maskUvTile );

	push	OFFSET ?maskUvTile@?1??fillContext@ParametricShape@Ogre@@QAEXPAVSceneRenderer@3@PAVShaderContext@3@W4PARAMSHAPE_TYPE@3@II@Z@4VVector4@3@A
	push	OFFSET ?maskUvRoate@?1??fillContext@ParametricShape@Ogre@@QAEXPAVSceneRenderer@3@PAVShaderContext@3@W4PARAMSHAPE_TYPE@3@II@Z@4VVector2@3@A
	push	OFFSET ?maskUvScale@?1??fillContext@ParametricShape@Ogre@@QAEXPAVSceneRenderer@3@PAVShaderContext@3@W4PARAMSHAPE_TYPE@3@II@Z@4VVector2@3@A
	push	OFFSET ?maskUvOffset@?1??fillContext@ParametricShape@Ogre@@QAEXPAVSceneRenderer@3@PAVShaderContext@3@W4PARAMSHAPE_TYPE@3@II@Z@4VVector2@3@A
	mov	eax, DWORD PTR _oneVertexUvMask$70059[ebp]
	push	eax
	call	?TransformUV@Ogre@@YAXAAVVector2@1@ABV21@11ABVVector4@1@@Z ; Ogre::TransformUV
	add	esp, 20					; 00000014H
$LN24@fillContex:

; 330  : 					}
; 331  : 
; 332  : 					if ( nCurRow != nSegu && nCurColumn != nSegv )

	mov	ecx, DWORD PTR _nCurRow$70046[ebp]
	cmp	ecx, DWORD PTR _nSegu$[ebp]
	je	$LN23@fillContex
	mov	edx, DWORD PTR _nCurColumn$70050[ebp]
	cmp	edx, DWORD PTR _nSegv$[ebp]
	je	$LN23@fillContex

; 333  : 					{
; 334  : 						pIndices[nCurIndexBufferIndex++]	=(ushort) (nCurRow*(nSegv+1) + nCurColumn);

	mov	eax, DWORD PTR _nSegv$[ebp]
	add	eax, 1
	imul	eax, DWORD PTR _nCurRow$70046[ebp]
	add	eax, DWORD PTR _nCurColumn$70050[ebp]
	mov	ecx, DWORD PTR _nCurIndexBufferIndex$70043[ebp]
	mov	edx, DWORD PTR _pIndices$[ebp]
	mov	WORD PTR [edx+ecx*2], ax
	mov	eax, DWORD PTR _nCurIndexBufferIndex$70043[ebp]
	add	eax, 1
	mov	DWORD PTR _nCurIndexBufferIndex$70043[ebp], eax

; 335  : 						pIndices[nCurIndexBufferIndex++]	=(ushort) (nCurRow*(nSegv+1) + nCurColumn+1);

	mov	ecx, DWORD PTR _nSegv$[ebp]
	add	ecx, 1
	imul	ecx, DWORD PTR _nCurRow$70046[ebp]
	mov	edx, DWORD PTR _nCurColumn$70050[ebp]
	lea	eax, DWORD PTR [ecx+edx+1]
	mov	ecx, DWORD PTR _nCurIndexBufferIndex$70043[ebp]
	mov	edx, DWORD PTR _pIndices$[ebp]
	mov	WORD PTR [edx+ecx*2], ax
	mov	eax, DWORD PTR _nCurIndexBufferIndex$70043[ebp]
	add	eax, 1
	mov	DWORD PTR _nCurIndexBufferIndex$70043[ebp], eax

; 336  : 						pIndices[nCurIndexBufferIndex++]	=(ushort) ((nCurRow+1)*(nSegv+1) + nCurColumn+1);

	mov	ecx, DWORD PTR _nCurRow$70046[ebp]
	add	ecx, 1
	mov	edx, DWORD PTR _nSegv$[ebp]
	add	edx, 1
	imul	ecx, edx
	mov	eax, DWORD PTR _nCurColumn$70050[ebp]
	lea	ecx, DWORD PTR [ecx+eax+1]
	mov	edx, DWORD PTR _nCurIndexBufferIndex$70043[ebp]
	mov	eax, DWORD PTR _pIndices$[ebp]
	mov	WORD PTR [eax+edx*2], cx
	mov	ecx, DWORD PTR _nCurIndexBufferIndex$70043[ebp]
	add	ecx, 1
	mov	DWORD PTR _nCurIndexBufferIndex$70043[ebp], ecx

; 337  : 
; 338  : 						pIndices[nCurIndexBufferIndex++]	=(ushort) (nCurRow*(nSegv+1) + nCurColumn);

	mov	edx, DWORD PTR _nSegv$[ebp]
	add	edx, 1
	imul	edx, DWORD PTR _nCurRow$70046[ebp]
	add	edx, DWORD PTR _nCurColumn$70050[ebp]
	mov	eax, DWORD PTR _nCurIndexBufferIndex$70043[ebp]
	mov	ecx, DWORD PTR _pIndices$[ebp]
	mov	WORD PTR [ecx+eax*2], dx
	mov	edx, DWORD PTR _nCurIndexBufferIndex$70043[ebp]
	add	edx, 1
	mov	DWORD PTR _nCurIndexBufferIndex$70043[ebp], edx

; 339  : 						pIndices[nCurIndexBufferIndex++]	=(ushort) ((nCurRow+1)*(nSegv+1) + nCurColumn);

	mov	eax, DWORD PTR _nCurRow$70046[ebp]
	add	eax, 1
	mov	ecx, DWORD PTR _nSegv$[ebp]
	add	ecx, 1
	imul	eax, ecx
	add	eax, DWORD PTR _nCurColumn$70050[ebp]
	mov	edx, DWORD PTR _nCurIndexBufferIndex$70043[ebp]
	mov	ecx, DWORD PTR _pIndices$[ebp]
	mov	WORD PTR [ecx+edx*2], ax
	mov	edx, DWORD PTR _nCurIndexBufferIndex$70043[ebp]
	add	edx, 1
	mov	DWORD PTR _nCurIndexBufferIndex$70043[ebp], edx

; 340  : 						pIndices[nCurIndexBufferIndex++]	=(ushort) ((nCurRow+1)*(nSegv+1) + nCurColumn+1);

	mov	eax, DWORD PTR _nCurRow$70046[ebp]
	add	eax, 1
	mov	ecx, DWORD PTR _nSegv$[ebp]
	add	ecx, 1
	imul	eax, ecx
	mov	edx, DWORD PTR _nCurColumn$70050[ebp]
	lea	eax, DWORD PTR [eax+edx+1]
	mov	ecx, DWORD PTR _nCurIndexBufferIndex$70043[ebp]
	mov	edx, DWORD PTR _pIndices$[ebp]
	mov	WORD PTR [edx+ecx*2], ax
	mov	eax, DWORD PTR _nCurIndexBufferIndex$70043[ebp]
	add	eax, 1
	mov	DWORD PTR _nCurIndexBufferIndex$70043[ebp], eax
$LN23@fillContex:

; 341  : 					}
; 342  : 				}

	jmp	$LN26@fillContex
$LN25@fillContex:

; 343  : 			}

	jmp	$LN29@fillContex
$LN28@fillContex:

; 344  : 			//int nCurIndexBufferIndex = 0;
; 345  : 			//for( size_t nCurRow=0; nCurRow<nSegu; nCurRow++ )
; 346  : 			//{
; 347  : 			//	for( size_t nCurColumn=0; nCurColumn<nSegv; nCurColumn++ )
; 348  : 			//	{
; 349  : 			//		pIndices[nCurIndexBufferIndex++]	=(ushort) (nCurRow*(nSegv+1) + nCurColumn);
; 350  : 			//		pIndices[nCurIndexBufferIndex++]	=(ushort) (nCurRow*(nSegv+1) + nCurColumn+1);
; 351  : 			//		pIndices[nCurIndexBufferIndex++]	=(ushort) ((nCurRow+1)*(nSegv+1) + nCurColumn+1);
; 352  : 
; 353  : 			//		pIndices[nCurIndexBufferIndex++]	=(ushort) (nCurRow*(nSegv+1) + nCurColumn);
; 354  : 			//		pIndices[nCurIndexBufferIndex++]	=(ushort) ((nCurRow+1)*(nSegv+1) + nCurColumn);
; 355  : 			//		pIndices[nCurIndexBufferIndex++]	=(ushort) ((nCurRow+1)*(nSegv+1) + nCurColumn+1);
; 356  : 			//	}
; 357  : 			//}
; 358  : 
; 359  : 		}
; 360  : 		else if(GeoType == GEO_TUBE)

	jmp	$LN6@fillContex
$LN32@fillContex:
	cmp	DWORD PTR _GeoType$[ebp], 2
	jne	$LN21@fillContex

; 361  : 		{
; 362  : 			float du	= 1.0f / nSegu;

	mov	ecx, DWORD PTR _nSegu$[ebp]
	mov	DWORD PTR tv1606[ebp], ecx
	mov	DWORD PTR tv1606[ebp+4], 0
	fild	QWORD PTR tv1606[ebp]
	fld1
	fdivrp	ST(1), ST(0)
	fstp	DWORD PTR _du$70070[ebp]

; 363  : 			float dv	= 1.0f / ( 2 * nSegv + 1 );

	mov	edx, DWORD PTR _nSegv$[ebp]
	lea	eax, DWORD PTR [edx+edx+1]
	mov	DWORD PTR tv1613[ebp], eax
	mov	DWORD PTR tv1613[ebp+4], 0
	fild	QWORD PTR tv1613[ebp]
	fld1
	fdivrp	ST(1), ST(0)
	fstp	DWORD PTR _dv$70071[ebp]

; 364  : 			float dvv	= 1.0f / nSegv;

	mov	ecx, DWORD PTR _nSegv$[ebp]
	mov	DWORD PTR tv1620[ebp], ecx
	mov	DWORD PTR tv1620[ebp+4], 0
	fild	QWORD PTR tv1620[ebp]
	fld1
	fdivrp	ST(1), ST(0)
	fstp	DWORD PTR _dvv$70072[ebp]

; 365  : 			int nCurIndexBufferIndex = 0;

	mov	DWORD PTR _nCurIndexBufferIndex$70073[ebp], 0

; 366  : 
; 367  : 			for ( size_t nCurRow = 0; nCurRow < nSegu + 1; ++nCurRow )

	mov	DWORD PTR _nCurRow$70074[ebp], 0
	jmp	SHORT $LN20@fillContex
$LN19@fillContex:
	mov	edx, DWORD PTR _nCurRow$70074[ebp]
	add	edx, 1
	mov	DWORD PTR _nCurRow$70074[ebp], edx
$LN20@fillContex:
	mov	eax, DWORD PTR _nSegu$[ebp]
	add	eax, 1
	cmp	DWORD PTR _nCurRow$70074[ebp], eax
	jae	$LN18@fillContex

; 368  : 			{
; 369  : 				for ( size_t nCurColumn=0; nCurColumn < 2 * ( nSegv + 1 ); ++nCurColumn )

	mov	DWORD PTR _nCurColumn$70078[ebp], 0
	jmp	SHORT $LN17@fillContex
$LN16@fillContex:
	mov	ecx, DWORD PTR _nCurColumn$70078[ebp]
	add	ecx, 1
	mov	DWORD PTR _nCurColumn$70078[ebp], ecx
$LN17@fillContex:
	mov	edx, DWORD PTR _nSegv$[ebp]
	lea	eax, DWORD PTR [edx+edx+2]
	cmp	DWORD PTR _nCurColumn$70078[ebp], eax
	jae	$LN15@fillContex

; 370  : 				{
; 371  : 					GEOMETRY_VERT& oneVertex = pVertices[nCurRow * 2 * ( nSegv + 1 ) + nCurColumn];

	mov	ecx, DWORD PTR _nCurRow$70074[ebp]
	shl	ecx, 1
	mov	edx, DWORD PTR _nSegv$[ebp]
	add	edx, 1
	imul	ecx, edx
	add	ecx, DWORD PTR _nCurColumn$70078[ebp]
	shl	ecx, 5
	add	ecx, DWORD PTR _pVertices$[ebp]
	mov	DWORD PTR _oneVertex$70082[ebp], ecx

; 372  : 
; 373  : 					float thita = nCurRow * du * 2 * 180.0f;

	mov	eax, DWORD PTR _nCurRow$70074[ebp]
	mov	DWORD PTR tv1633[ebp], eax
	mov	DWORD PTR tv1633[ebp+4], 0
	fild	QWORD PTR tv1633[ebp]
	fmul	DWORD PTR _du$70070[ebp]
	fadd	ST(0), ST(0)
	fmul	QWORD PTR __real@4066800000000000
	fstp	DWORD PTR _thita$70083[ebp]

; 374  : 					thita *= m_FrameData.m_fRound / 360.0f;

	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+400]
	fdiv	QWORD PTR __real@4076800000000000
	fmul	DWORD PTR _thita$70083[ebp]
	fstp	DWORD PTR _thita$70083[ebp]

; 375  : 					float alpha, beta;
; 376  : 					if ( nCurColumn % ( 2 * nSegv + 1 ) >= ( nSegv + 1 ) )

	mov	edx, DWORD PTR _nSegv$[ebp]
	lea	ecx, DWORD PTR [edx+edx+1]
	mov	eax, DWORD PTR _nCurColumn$70078[ebp]
	xor	edx, edx
	div	ecx
	mov	eax, DWORD PTR _nSegv$[ebp]
	add	eax, 1
	cmp	edx, eax
	jb	SHORT $LN14@fillContex

; 377  : 					{
; 378  : 						alpha = (2*nSegv + 1 -nCurColumn%(2*nSegv+1))*dvv;

	mov	ecx, DWORD PTR _nSegv$[ebp]
	lea	ecx, DWORD PTR [ecx+ecx+1]
	mov	edx, DWORD PTR _nSegv$[ebp]
	lea	esi, DWORD PTR [edx+edx+1]
	mov	eax, DWORD PTR _nCurColumn$70078[ebp]
	xor	edx, edx
	div	esi
	sub	ecx, edx
	mov	DWORD PTR tv1650[ebp], ecx
	mov	DWORD PTR tv1650[ebp+4], 0
	fild	QWORD PTR tv1650[ebp]
	fmul	DWORD PTR _dvv$70072[ebp]
	fstp	DWORD PTR _alpha$70084[ebp]

; 379  : 						beta = 0.0f;

	fldz
	fstp	DWORD PTR _beta$70085[ebp]

; 380  : 					}
; 381  : 					else

	jmp	SHORT $LN13@fillContex
$LN14@fillContex:

; 382  : 					{
; 383  : 						alpha = (nCurColumn%(2*nSegv+1))*dvv;

	mov	eax, DWORD PTR _nSegv$[ebp]
	lea	ecx, DWORD PTR [eax+eax+1]
	mov	eax, DWORD PTR _nCurColumn$70078[ebp]
	xor	edx, edx
	div	ecx
	mov	DWORD PTR tv1660[ebp], edx
	mov	DWORD PTR tv1660[ebp+4], 0
	fild	QWORD PTR tv1660[ebp]
	fmul	DWORD PTR _dvv$70072[ebp]
	fstp	DWORD PTR _alpha$70084[ebp]

; 384  : 						beta = 1.0f;

	fld1
	fstp	DWORD PTR _beta$70085[ebp]
$LN13@fillContex:

; 385  : 					}
; 386  : 
; 387  : 					float radius = Lerp( m_FrameData.m_fTubeNRadius, m_FrameData.m_fTubeLRadius, beta );

	push	ecx
	fld	DWORD PTR _beta$70085[ebp]
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _this$[ebp]
	push	ecx
	fld	DWORD PTR [edx+356]
	fstp	DWORD PTR [esp]
	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	fld	DWORD PTR [eax+352]
	fstp	DWORD PTR [esp]
	call	?Lerp@Ogre@@YAMMMM@Z			; Ogre::Lerp
	add	esp, 12					; 0000000cH
	fstp	DWORD PTR _radius$70088[ebp]

; 388  : 
; 389  : 					Vector3& oneVertexPos = oneVertex.pos;

	mov	ecx, DWORD PTR _oneVertex$70082[ebp]
	mov	DWORD PTR _oneVertexPos$70089[ebp], ecx

; 390  : 					oneVertexPos.setElement( 
; 391  : 						radius*fastCos(thita), 
; 392  : 						m_FrameData.m_fTubeHeight * alpha, 
; 393  : 						radius*fastSin( thita ) 
; 394  : 						);

	push	ecx
	fld	DWORD PTR _thita$70083[ebp]
	fstp	DWORD PTR [esp]
	call	?fastSin@Ogre@@YAMM@Z			; Ogre::fastSin
	add	esp, 4
	fmul	DWORD PTR _radius$70088[ebp]
	fstp	DWORD PTR tv1682[ebp]
	fld	DWORD PTR tv1682[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+360]
	fmul	DWORD PTR _alpha$70084[ebp]
	fstp	DWORD PTR tv1684[ebp]
	fld	DWORD PTR tv1684[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR _thita$70083[ebp]
	fstp	DWORD PTR [esp]
	call	?fastCos@Ogre@@YAMM@Z			; Ogre::fastCos
	add	esp, 4
	fmul	DWORD PTR _radius$70088[ebp]
	fstp	DWORD PTR tv1690[ebp]
	fld	DWORD PTR tv1690[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _oneVertexPos$70089[ebp]
	call	?setElement@Vector3@Ogre@@QAEXMMM@Z	; Ogre::Vector3::setElement

; 395  : 
; 396  : 					Vector2& oneVertexUv	= oneVertex.uv;

	mov	eax, DWORD PTR _oneVertex$70082[ebp]
	add	eax, 16					; 00000010H
	mov	DWORD PTR _oneVertexUv$70090[ebp], eax

; 397  : 					oneVertexUv.setElement( nCurRow * du, nCurColumn * dv );

	mov	ecx, DWORD PTR _nCurColumn$70078[ebp]
	mov	DWORD PTR tv1699[ebp], ecx
	mov	DWORD PTR tv1699[ebp+4], 0
	fild	QWORD PTR tv1699[ebp]
	fmul	DWORD PTR _dv$70071[ebp]
	fstp	DWORD PTR tv1703[ebp]
	fld	DWORD PTR tv1703[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _nCurRow$70074[ebp]
	mov	DWORD PTR tv1705[ebp], edx
	mov	DWORD PTR tv1705[ebp+4], 0
	fild	QWORD PTR tv1705[ebp]
	fmul	DWORD PTR _du$70070[ebp]
	fstp	DWORD PTR tv1709[ebp]
	fld	DWORD PTR tv1709[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _oneVertexUv$70090[ebp]
	call	?setElement@Vector2@Ogre@@QAEXMM@Z	; Ogre::Vector2::setElement

; 398  : 
; 399  : 					Vector2& oneVertexUvMask = oneVertex.uvMask;

	mov	eax, DWORD PTR _oneVertex$70082[ebp]
	add	eax, 24					; 00000018H
	mov	DWORD PTR _oneVertexUvMask$70091[ebp], eax

; 400  : 					oneVertexUvMask.setElement( nCurRow * du, nCurColumn * dv );

	mov	ecx, DWORD PTR _nCurColumn$70078[ebp]
	mov	DWORD PTR tv1716[ebp], ecx
	mov	DWORD PTR tv1716[ebp+4], 0
	fild	QWORD PTR tv1716[ebp]
	fmul	DWORD PTR _dv$70071[ebp]
	fstp	DWORD PTR tv1720[ebp]
	fld	DWORD PTR tv1720[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _nCurRow$70074[ebp]
	mov	DWORD PTR tv1722[ebp], edx
	mov	DWORD PTR tv1722[ebp+4], 0
	fild	QWORD PTR tv1722[ebp]
	fmul	DWORD PTR _du$70070[ebp]
	fstp	DWORD PTR tv1726[ebp]
	fld	DWORD PTR tv1726[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _oneVertexUvMask$70091[ebp]
	call	?setElement@Vector2@Ogre@@QAEXMM@Z	; Ogre::Vector2::setElement

; 401  : 
; 402  : 					oneVertex.color = color;

	mov	eax, DWORD PTR _color$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _oneVertex$70082[ebp]
	mov	DWORD PTR [edx+12], ecx

; 403  : 
; 404  : 					TransformUV( oneVertexUv, uvOffset, uvScale, uvRotate, uvTile );

	push	OFFSET ?uvTile@?1??fillContext@ParametricShape@Ogre@@QAEXPAVSceneRenderer@3@PAVShaderContext@3@W4PARAMSHAPE_TYPE@3@II@Z@4VVector4@3@A
	push	OFFSET ?uvRotate@?1??fillContext@ParametricShape@Ogre@@QAEXPAVSceneRenderer@3@PAVShaderContext@3@W4PARAMSHAPE_TYPE@3@II@Z@4VVector2@3@A
	push	OFFSET ?uvScale@?1??fillContext@ParametricShape@Ogre@@QAEXPAVSceneRenderer@3@PAVShaderContext@3@W4PARAMSHAPE_TYPE@3@II@Z@4VVector2@3@A
	push	OFFSET ?uvOffset@?1??fillContext@ParametricShape@Ogre@@QAEXPAVSceneRenderer@3@PAVShaderContext@3@W4PARAMSHAPE_TYPE@3@II@Z@4VVector2@3@A
	mov	eax, DWORD PTR _oneVertexUv$70090[ebp]
	push	eax
	call	?TransformUV@Ogre@@YAXAAVVector2@1@ABV21@11ABVVector4@1@@Z ; Ogre::TransformUV
	add	esp, 20					; 00000014H

; 405  : 					if ( m_pSource->m_pMaskTextureRes != NULL )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+280]
	cmp	DWORD PTR [edx+80], 0
	je	SHORT $LN12@fillContex

; 406  : 					{
; 407  : 						TransformUV( oneVertexUvMask, maskUvOffset, maskUvScale, maskUvRoate, maskUvTile );

	push	OFFSET ?maskUvTile@?1??fillContext@ParametricShape@Ogre@@QAEXPAVSceneRenderer@3@PAVShaderContext@3@W4PARAMSHAPE_TYPE@3@II@Z@4VVector4@3@A
	push	OFFSET ?maskUvRoate@?1??fillContext@ParametricShape@Ogre@@QAEXPAVSceneRenderer@3@PAVShaderContext@3@W4PARAMSHAPE_TYPE@3@II@Z@4VVector2@3@A
	push	OFFSET ?maskUvScale@?1??fillContext@ParametricShape@Ogre@@QAEXPAVSceneRenderer@3@PAVShaderContext@3@W4PARAMSHAPE_TYPE@3@II@Z@4VVector2@3@A
	push	OFFSET ?maskUvOffset@?1??fillContext@ParametricShape@Ogre@@QAEXPAVSceneRenderer@3@PAVShaderContext@3@W4PARAMSHAPE_TYPE@3@II@Z@4VVector2@3@A
	mov	eax, DWORD PTR _oneVertexUvMask$70091[ebp]
	push	eax
	call	?TransformUV@Ogre@@YAXAAVVector2@1@ABV21@11ABVVector4@1@@Z ; Ogre::TransformUV
	add	esp, 20					; 00000014H
$LN12@fillContex:

; 408  : 					}
; 409  : 
; 410  : 					if ( nCurRow != nSegu && nCurColumn != 2 * nSegv + 1 )

	mov	ecx, DWORD PTR _nCurRow$70074[ebp]
	cmp	ecx, DWORD PTR _nSegu$[ebp]
	je	$LN11@fillContex
	mov	edx, DWORD PTR _nSegv$[ebp]
	lea	eax, DWORD PTR [edx+edx+1]
	cmp	DWORD PTR _nCurColumn$70078[ebp], eax
	je	$LN11@fillContex

; 411  : 					{
; 412  : 						pIndices[nCurIndexBufferIndex++]	=(ushort) (nCurRow*2*(nSegv+1) + nCurColumn);

	mov	ecx, DWORD PTR _nCurRow$70074[ebp]
	shl	ecx, 1
	mov	edx, DWORD PTR _nSegv$[ebp]
	add	edx, 1
	imul	ecx, edx
	add	ecx, DWORD PTR _nCurColumn$70078[ebp]
	mov	eax, DWORD PTR _nCurIndexBufferIndex$70073[ebp]
	mov	edx, DWORD PTR _pIndices$[ebp]
	mov	WORD PTR [edx+eax*2], cx
	mov	eax, DWORD PTR _nCurIndexBufferIndex$70073[ebp]
	add	eax, 1
	mov	DWORD PTR _nCurIndexBufferIndex$70073[ebp], eax

; 413  : 						pIndices[nCurIndexBufferIndex++]	=(ushort) (nCurRow*2*(nSegv+1) + nCurColumn+1);

	mov	ecx, DWORD PTR _nCurRow$70074[ebp]
	shl	ecx, 1
	mov	edx, DWORD PTR _nSegv$[ebp]
	add	edx, 1
	imul	ecx, edx
	mov	eax, DWORD PTR _nCurColumn$70078[ebp]
	lea	ecx, DWORD PTR [ecx+eax+1]
	mov	edx, DWORD PTR _nCurIndexBufferIndex$70073[ebp]
	mov	eax, DWORD PTR _pIndices$[ebp]
	mov	WORD PTR [eax+edx*2], cx
	mov	ecx, DWORD PTR _nCurIndexBufferIndex$70073[ebp]
	add	ecx, 1
	mov	DWORD PTR _nCurIndexBufferIndex$70073[ebp], ecx

; 414  : 						pIndices[nCurIndexBufferIndex++]	=(ushort) ((nCurRow+1)*2*(nSegv+1) + nCurColumn+1);

	mov	edx, DWORD PTR _nCurRow$70074[ebp]
	lea	eax, DWORD PTR [edx+edx+2]
	mov	ecx, DWORD PTR _nSegv$[ebp]
	add	ecx, 1
	imul	eax, ecx
	mov	edx, DWORD PTR _nCurColumn$70078[ebp]
	lea	eax, DWORD PTR [eax+edx+1]
	mov	ecx, DWORD PTR _nCurIndexBufferIndex$70073[ebp]
	mov	edx, DWORD PTR _pIndices$[ebp]
	mov	WORD PTR [edx+ecx*2], ax
	mov	eax, DWORD PTR _nCurIndexBufferIndex$70073[ebp]
	add	eax, 1
	mov	DWORD PTR _nCurIndexBufferIndex$70073[ebp], eax

; 415  : 
; 416  : 						pIndices[nCurIndexBufferIndex++]	=(ushort) (nCurRow*2*(nSegv+1) + nCurColumn);

	mov	ecx, DWORD PTR _nCurRow$70074[ebp]
	shl	ecx, 1
	mov	edx, DWORD PTR _nSegv$[ebp]
	add	edx, 1
	imul	ecx, edx
	add	ecx, DWORD PTR _nCurColumn$70078[ebp]
	mov	eax, DWORD PTR _nCurIndexBufferIndex$70073[ebp]
	mov	edx, DWORD PTR _pIndices$[ebp]
	mov	WORD PTR [edx+eax*2], cx
	mov	eax, DWORD PTR _nCurIndexBufferIndex$70073[ebp]
	add	eax, 1
	mov	DWORD PTR _nCurIndexBufferIndex$70073[ebp], eax

; 417  : 						pIndices[nCurIndexBufferIndex++]	=(ushort) ((nCurRow+1)*2*(nSegv+1) + nCurColumn);

	mov	ecx, DWORD PTR _nCurRow$70074[ebp]
	lea	edx, DWORD PTR [ecx+ecx+2]
	mov	eax, DWORD PTR _nSegv$[ebp]
	add	eax, 1
	imul	edx, eax
	add	edx, DWORD PTR _nCurColumn$70078[ebp]
	mov	ecx, DWORD PTR _nCurIndexBufferIndex$70073[ebp]
	mov	eax, DWORD PTR _pIndices$[ebp]
	mov	WORD PTR [eax+ecx*2], dx
	mov	ecx, DWORD PTR _nCurIndexBufferIndex$70073[ebp]
	add	ecx, 1
	mov	DWORD PTR _nCurIndexBufferIndex$70073[ebp], ecx

; 418  : 						pIndices[nCurIndexBufferIndex++]	=(ushort) ((nCurRow+1)*2*(nSegv+1) + nCurColumn+1);

	mov	edx, DWORD PTR _nCurRow$70074[ebp]
	lea	eax, DWORD PTR [edx+edx+2]
	mov	ecx, DWORD PTR _nSegv$[ebp]
	add	ecx, 1
	imul	eax, ecx
	mov	edx, DWORD PTR _nCurColumn$70078[ebp]
	lea	eax, DWORD PTR [eax+edx+1]
	mov	ecx, DWORD PTR _nCurIndexBufferIndex$70073[ebp]
	mov	edx, DWORD PTR _pIndices$[ebp]
	mov	WORD PTR [edx+ecx*2], ax
	mov	eax, DWORD PTR _nCurIndexBufferIndex$70073[ebp]
	add	eax, 1
	mov	DWORD PTR _nCurIndexBufferIndex$70073[ebp], eax
$LN11@fillContex:

; 419  : 					}
; 420  : 				}

	jmp	$LN16@fillContex
$LN15@fillContex:

; 421  : 			}

	jmp	$LN19@fillContex
$LN18@fillContex:

; 422  : 
; 423  : 			/*for( size_t nCurRow=0; nCurRow< nSegu; nCurRow++)
; 424  : 			{
; 425  : 			for( size_t nCurColumn=0; nCurColumn< 2*nSegv + 1; nCurColumn++ )
; 426  : 			{
; 427  : 			pIndices[nCurIndexBufferIndex++]	=(ushort) (nCurRow*2*(nSegv+1) + nCurColumn);
; 428  : 			pIndices[nCurIndexBufferIndex++]	=(ushort) (nCurRow*2*(nSegv+1) + nCurColumn+1);
; 429  : 			pIndices[nCurIndexBufferIndex++]	=(ushort) ((nCurRow+1)*2*(nSegv+1) + nCurColumn+1);
; 430  : 
; 431  : 			pIndices[nCurIndexBufferIndex++]	=(ushort) (nCurRow*2*(nSegv+1) + nCurColumn);
; 432  : 			pIndices[nCurIndexBufferIndex++]	=(ushort) ((nCurRow+1)*2*(nSegv+1) + nCurColumn);
; 433  : 			pIndices[nCurIndexBufferIndex++]	=(ushort) ((nCurRow+1)*2*(nSegv+1) + nCurColumn+1);
; 434  : 			}	
; 435  : 			}*/
; 436  : 		}
; 437  : 		else if(GeoType == GEO_COLUMN)

	jmp	$LN6@fillContex
$LN21@fillContex:
	cmp	DWORD PTR _GeoType$[ebp], 3
	jne	$LN6@fillContex

; 438  : 		{
; 439  : 			int nCurIndexBufferIndex = 0;

	mov	DWORD PTR _nCurIndexBufferIndex$70102[ebp], 0

; 440  : 			float du = 1.0f / nSegu;

	mov	ecx, DWORD PTR _nSegu$[ebp]
	mov	DWORD PTR tv1772[ebp], ecx
	mov	DWORD PTR tv1772[ebp+4], 0
	fild	QWORD PTR tv1772[ebp]
	fld1
	fdivrp	ST(1), ST(0)
	fstp	DWORD PTR _du$70103[ebp]

; 441  : 			float dv = 1.0f / nSegv;

	mov	edx, DWORD PTR _nSegv$[ebp]
	mov	DWORD PTR tv1779[ebp], edx
	mov	DWORD PTR tv1779[ebp+4], 0
	fild	QWORD PTR tv1779[ebp]
	fld1
	fdivrp	ST(1), ST(0)
	fstp	DWORD PTR _dv$70104[ebp]

; 442  : 
; 443  : 			for ( size_t nCurRow=0; nCurRow < nSegu + 1; ++nCurRow )

	mov	DWORD PTR _nCurRow$70105[ebp], 0
	jmp	SHORT $LN8@fillContex
$LN7@fillContex:
	mov	eax, DWORD PTR _nCurRow$70105[ebp]
	add	eax, 1
	mov	DWORD PTR _nCurRow$70105[ebp], eax
$LN8@fillContex:
	mov	ecx, DWORD PTR _nSegu$[ebp]
	add	ecx, 1
	cmp	DWORD PTR _nCurRow$70105[ebp], ecx
	jae	$LN6@fillContex

; 444  : 			{
; 445  : 				for ( size_t nCurColumn = 0; nCurColumn < nSegv + 1; ++nCurColumn )

	mov	DWORD PTR _nCurColumn$70109[ebp], 0
	jmp	SHORT $LN5@fillContex
$LN4@fillContex:
	mov	edx, DWORD PTR _nCurColumn$70109[ebp]
	add	edx, 1
	mov	DWORD PTR _nCurColumn$70109[ebp], edx
$LN5@fillContex:
	mov	eax, DWORD PTR _nSegv$[ebp]
	add	eax, 1
	cmp	DWORD PTR _nCurColumn$70109[ebp], eax
	jae	$LN3@fillContex

; 446  : 				{
; 447  : 					GEOMETRY_VERT& oneVertex = pVertices[nCurRow * ( nSegv + 1 ) + nCurColumn];

	mov	ecx, DWORD PTR _nSegv$[ebp]
	add	ecx, 1
	imul	ecx, DWORD PTR _nCurRow$70105[ebp]
	add	ecx, DWORD PTR _nCurColumn$70109[ebp]
	shl	ecx, 5
	add	ecx, DWORD PTR _pVertices$[ebp]
	mov	DWORD PTR _oneVertex$70113[ebp], ecx

; 448  : 
; 449  : 					float thita = nCurRow * du * 360.0f /*2 * 180.0f*/;

	mov	edx, DWORD PTR _nCurRow$70105[ebp]
	mov	DWORD PTR tv1792[ebp], edx
	mov	DWORD PTR tv1792[ebp+4], 0
	fild	QWORD PTR tv1792[ebp]
	fmul	DWORD PTR _du$70103[ebp]
	fmul	QWORD PTR __real@4076800000000000
	fstp	DWORD PTR _thita$70114[ebp]

; 450  : 					float alpha = nCurColumn * dv;

	mov	eax, DWORD PTR _nCurColumn$70109[ebp]
	mov	DWORD PTR tv1798[ebp], eax
	mov	DWORD PTR tv1798[ebp+4], 0
	fild	QWORD PTR tv1798[ebp]
	fmul	DWORD PTR _dv$70104[ebp]
	fstp	DWORD PTR _alpha$70115[ebp]

; 451  : 					thita		*= m_FrameData.m_fRound / 360.0f;

	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [ecx+400]
	fdiv	QWORD PTR __real@4076800000000000
	fmul	DWORD PTR _thita$70114[ebp]
	fstp	DWORD PTR _thita$70114[ebp]

; 452  : 					float beta	= alpha;

	fld	DWORD PTR _alpha$70115[ebp]
	fstp	DWORD PTR _beta$70116[ebp]

; 453  : 
; 454  : 					float radius	= Lerp( m_FrameData.m_fColumnDownRadius, m_FrameData.m_fColumnUpRadius, beta );

	push	ecx
	fld	DWORD PTR _beta$70116[ebp]
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _this$[ebp]
	push	ecx
	fld	DWORD PTR [edx+368]
	fstp	DWORD PTR [esp]
	mov	eax, DWORD PTR _this$[ebp]
	push	ecx
	fld	DWORD PTR [eax+364]
	fstp	DWORD PTR [esp]
	call	?Lerp@Ogre@@YAMMMM@Z			; Ogre::Lerp
	add	esp, 12					; 0000000cH
	fstp	DWORD PTR _radius$70117[ebp]

; 455  : 
; 456  : 					Vector3& oneVertexPos = oneVertex.pos;

	mov	ecx, DWORD PTR _oneVertex$70113[ebp]
	mov	DWORD PTR _oneVertexPos$70118[ebp], ecx

; 457  : 					oneVertexPos.setElement(	radius * fastCos( thita ), 
; 458  : 						m_FrameData.m_fColumnHeight * alpha, 
; 459  : 						radius * fastSin( thita ) 
; 460  : 						);

	push	ecx
	fld	DWORD PTR _thita$70114[ebp]
	fstp	DWORD PTR [esp]
	call	?fastSin@Ogre@@YAMM@Z			; Ogre::fastSin
	add	esp, 4
	fmul	DWORD PTR _radius$70117[ebp]
	fstp	DWORD PTR tv1822[ebp]
	fld	DWORD PTR tv1822[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR [edx+372]
	fmul	DWORD PTR _alpha$70115[ebp]
	fstp	DWORD PTR tv1824[ebp]
	fld	DWORD PTR tv1824[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR _thita$70114[ebp]
	fstp	DWORD PTR [esp]
	call	?fastCos@Ogre@@YAMM@Z			; Ogre::fastCos
	add	esp, 4
	fmul	DWORD PTR _radius$70117[ebp]
	fstp	DWORD PTR tv1830[ebp]
	fld	DWORD PTR tv1830[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _oneVertexPos$70118[ebp]
	call	?setElement@Vector3@Ogre@@QAEXMMM@Z	; Ogre::Vector3::setElement

; 461  : 
; 462  : 					Vector2& oneVertexUv	= oneVertex.uv;

	mov	eax, DWORD PTR _oneVertex$70113[ebp]
	add	eax, 16					; 00000010H
	mov	DWORD PTR _oneVertexUv$70119[ebp], eax

; 463  : 					oneVertexUv.setElement( nCurRow * du, nCurColumn * dv );

	mov	ecx, DWORD PTR _nCurColumn$70109[ebp]
	mov	DWORD PTR tv1839[ebp], ecx
	mov	DWORD PTR tv1839[ebp+4], 0
	fild	QWORD PTR tv1839[ebp]
	fmul	DWORD PTR _dv$70104[ebp]
	fstp	DWORD PTR tv1843[ebp]
	fld	DWORD PTR tv1843[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _nCurRow$70105[ebp]
	mov	DWORD PTR tv1845[ebp], edx
	mov	DWORD PTR tv1845[ebp+4], 0
	fild	QWORD PTR tv1845[ebp]
	fmul	DWORD PTR _du$70103[ebp]
	fstp	DWORD PTR tv1849[ebp]
	fld	DWORD PTR tv1849[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _oneVertexUv$70119[ebp]
	call	?setElement@Vector2@Ogre@@QAEXMM@Z	; Ogre::Vector2::setElement

; 464  : 
; 465  : 					Vector2& oneVertexUvMask = oneVertex.uvMask;

	mov	eax, DWORD PTR _oneVertex$70113[ebp]
	add	eax, 24					; 00000018H
	mov	DWORD PTR _oneVertexUvMask$70120[ebp], eax

; 466  : 					oneVertexUvMask.setElement( nCurRow * du, nCurColumn * dv );

	mov	ecx, DWORD PTR _nCurColumn$70109[ebp]
	mov	DWORD PTR tv1856[ebp], ecx
	mov	DWORD PTR tv1856[ebp+4], 0
	fild	QWORD PTR tv1856[ebp]
	fmul	DWORD PTR _dv$70104[ebp]
	fstp	DWORD PTR tv1860[ebp]
	fld	DWORD PTR tv1860[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _nCurRow$70105[ebp]
	mov	DWORD PTR tv1862[ebp], edx
	mov	DWORD PTR tv1862[ebp+4], 0
	fild	QWORD PTR tv1862[ebp]
	fmul	DWORD PTR _du$70103[ebp]
	fstp	DWORD PTR tv1866[ebp]
	fld	DWORD PTR tv1866[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _oneVertexUvMask$70120[ebp]
	call	?setElement@Vector2@Ogre@@QAEXMM@Z	; Ogre::Vector2::setElement

; 467  : 					oneVertex.color		= color;

	mov	eax, DWORD PTR _color$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _oneVertex$70113[ebp]
	mov	DWORD PTR [edx+12], ecx

; 468  : 
; 469  : 					TransformUV( oneVertexUv, uvOffset, uvScale, uvRotate, uvTile );

	push	OFFSET ?uvTile@?1??fillContext@ParametricShape@Ogre@@QAEXPAVSceneRenderer@3@PAVShaderContext@3@W4PARAMSHAPE_TYPE@3@II@Z@4VVector4@3@A
	push	OFFSET ?uvRotate@?1??fillContext@ParametricShape@Ogre@@QAEXPAVSceneRenderer@3@PAVShaderContext@3@W4PARAMSHAPE_TYPE@3@II@Z@4VVector2@3@A
	push	OFFSET ?uvScale@?1??fillContext@ParametricShape@Ogre@@QAEXPAVSceneRenderer@3@PAVShaderContext@3@W4PARAMSHAPE_TYPE@3@II@Z@4VVector2@3@A
	push	OFFSET ?uvOffset@?1??fillContext@ParametricShape@Ogre@@QAEXPAVSceneRenderer@3@PAVShaderContext@3@W4PARAMSHAPE_TYPE@3@II@Z@4VVector2@3@A
	mov	eax, DWORD PTR _oneVertexUv$70119[ebp]
	push	eax
	call	?TransformUV@Ogre@@YAXAAVVector2@1@ABV21@11ABVVector4@1@@Z ; Ogre::TransformUV
	add	esp, 20					; 00000014H

; 470  : 					if ( m_pSource->m_pMaskTextureRes != NULL )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+280]
	cmp	DWORD PTR [edx+80], 0
	je	SHORT $LN2@fillContex

; 471  : 					{
; 472  : 						TransformUV( oneVertexUvMask, maskUvOffset, maskUvScale, maskUvRoate, maskUvTile );

	push	OFFSET ?maskUvTile@?1??fillContext@ParametricShape@Ogre@@QAEXPAVSceneRenderer@3@PAVShaderContext@3@W4PARAMSHAPE_TYPE@3@II@Z@4VVector4@3@A
	push	OFFSET ?maskUvRoate@?1??fillContext@ParametricShape@Ogre@@QAEXPAVSceneRenderer@3@PAVShaderContext@3@W4PARAMSHAPE_TYPE@3@II@Z@4VVector2@3@A
	push	OFFSET ?maskUvScale@?1??fillContext@ParametricShape@Ogre@@QAEXPAVSceneRenderer@3@PAVShaderContext@3@W4PARAMSHAPE_TYPE@3@II@Z@4VVector2@3@A
	push	OFFSET ?maskUvOffset@?1??fillContext@ParametricShape@Ogre@@QAEXPAVSceneRenderer@3@PAVShaderContext@3@W4PARAMSHAPE_TYPE@3@II@Z@4VVector2@3@A
	mov	eax, DWORD PTR _oneVertexUvMask$70120[ebp]
	push	eax
	call	?TransformUV@Ogre@@YAXAAVVector2@1@ABV21@11ABVVector4@1@@Z ; Ogre::TransformUV
	add	esp, 20					; 00000014H
$LN2@fillContex:

; 473  : 					}
; 474  : 
; 475  : 					if (nCurRow != nSegu && nCurColumn!=nSegv)

	mov	ecx, DWORD PTR _nCurRow$70105[ebp]
	cmp	ecx, DWORD PTR _nSegu$[ebp]
	je	$LN1@fillContex
	mov	edx, DWORD PTR _nCurColumn$70109[ebp]
	cmp	edx, DWORD PTR _nSegv$[ebp]
	je	$LN1@fillContex

; 476  : 					{
; 477  : 						pIndices[nCurIndexBufferIndex++]	=(ushort) (nCurRow*(nSegv+1) + nCurColumn);

	mov	eax, DWORD PTR _nSegv$[ebp]
	add	eax, 1
	imul	eax, DWORD PTR _nCurRow$70105[ebp]
	add	eax, DWORD PTR _nCurColumn$70109[ebp]
	mov	ecx, DWORD PTR _nCurIndexBufferIndex$70102[ebp]
	mov	edx, DWORD PTR _pIndices$[ebp]
	mov	WORD PTR [edx+ecx*2], ax
	mov	eax, DWORD PTR _nCurIndexBufferIndex$70102[ebp]
	add	eax, 1
	mov	DWORD PTR _nCurIndexBufferIndex$70102[ebp], eax

; 478  : 						pIndices[nCurIndexBufferIndex++]	=(ushort) (nCurRow*(nSegv+1) + nCurColumn+1);

	mov	ecx, DWORD PTR _nSegv$[ebp]
	add	ecx, 1
	imul	ecx, DWORD PTR _nCurRow$70105[ebp]
	mov	edx, DWORD PTR _nCurColumn$70109[ebp]
	lea	eax, DWORD PTR [ecx+edx+1]
	mov	ecx, DWORD PTR _nCurIndexBufferIndex$70102[ebp]
	mov	edx, DWORD PTR _pIndices$[ebp]
	mov	WORD PTR [edx+ecx*2], ax
	mov	eax, DWORD PTR _nCurIndexBufferIndex$70102[ebp]
	add	eax, 1
	mov	DWORD PTR _nCurIndexBufferIndex$70102[ebp], eax

; 479  : 						pIndices[nCurIndexBufferIndex++]	=(ushort) ((nCurRow+1)*(nSegv+1) + nCurColumn+1);

	mov	ecx, DWORD PTR _nCurRow$70105[ebp]
	add	ecx, 1
	mov	edx, DWORD PTR _nSegv$[ebp]
	add	edx, 1
	imul	ecx, edx
	mov	eax, DWORD PTR _nCurColumn$70109[ebp]
	lea	ecx, DWORD PTR [ecx+eax+1]
	mov	edx, DWORD PTR _nCurIndexBufferIndex$70102[ebp]
	mov	eax, DWORD PTR _pIndices$[ebp]
	mov	WORD PTR [eax+edx*2], cx
	mov	ecx, DWORD PTR _nCurIndexBufferIndex$70102[ebp]
	add	ecx, 1
	mov	DWORD PTR _nCurIndexBufferIndex$70102[ebp], ecx

; 480  : 
; 481  : 						pIndices[nCurIndexBufferIndex++]	=(ushort) (nCurRow*(nSegv+1) + nCurColumn);

	mov	edx, DWORD PTR _nSegv$[ebp]
	add	edx, 1
	imul	edx, DWORD PTR _nCurRow$70105[ebp]
	add	edx, DWORD PTR _nCurColumn$70109[ebp]
	mov	eax, DWORD PTR _nCurIndexBufferIndex$70102[ebp]
	mov	ecx, DWORD PTR _pIndices$[ebp]
	mov	WORD PTR [ecx+eax*2], dx
	mov	edx, DWORD PTR _nCurIndexBufferIndex$70102[ebp]
	add	edx, 1
	mov	DWORD PTR _nCurIndexBufferIndex$70102[ebp], edx

; 482  : 						pIndices[nCurIndexBufferIndex++]	=(ushort) ((nCurRow+1)*(nSegv+1) + nCurColumn);

	mov	eax, DWORD PTR _nCurRow$70105[ebp]
	add	eax, 1
	mov	ecx, DWORD PTR _nSegv$[ebp]
	add	ecx, 1
	imul	eax, ecx
	add	eax, DWORD PTR _nCurColumn$70109[ebp]
	mov	edx, DWORD PTR _nCurIndexBufferIndex$70102[ebp]
	mov	ecx, DWORD PTR _pIndices$[ebp]
	mov	WORD PTR [ecx+edx*2], ax
	mov	edx, DWORD PTR _nCurIndexBufferIndex$70102[ebp]
	add	edx, 1
	mov	DWORD PTR _nCurIndexBufferIndex$70102[ebp], edx

; 483  : 						pIndices[nCurIndexBufferIndex++]	=(ushort) ((nCurRow+1)*(nSegv+1) + nCurColumn+1);

	mov	eax, DWORD PTR _nCurRow$70105[ebp]
	add	eax, 1
	mov	ecx, DWORD PTR _nSegv$[ebp]
	add	ecx, 1
	imul	eax, ecx
	mov	edx, DWORD PTR _nCurColumn$70109[ebp]
	lea	eax, DWORD PTR [eax+edx+1]
	mov	ecx, DWORD PTR _nCurIndexBufferIndex$70102[ebp]
	mov	edx, DWORD PTR _pIndices$[ebp]
	mov	WORD PTR [edx+ecx*2], ax
	mov	eax, DWORD PTR _nCurIndexBufferIndex$70102[ebp]
	add	eax, 1
	mov	DWORD PTR _nCurIndexBufferIndex$70102[ebp], eax
$LN1@fillContex:

; 484  : 					}
; 485  : 				}

	jmp	$LN4@fillContex
$LN3@fillContex:

; 486  : 			}

	jmp	$LN7@fillContex
$LN6@fillContex:

; 487  : 			//int nCurIndexBufferIndex = 0;
; 488  : 			//for( size_t nCurRow=0; nCurRow< nSegu; nCurRow++ )
; 489  : 			//{
; 490  : 			//	for( size_t nCurColumn=0; nCurColumn< nSegv; nCurColumn++ )
; 491  : 			//	{
; 492  : 			//		pIndices[nCurIndexBufferIndex++]	=(ushort) (nCurRow*(nSegv+1) + nCurColumn);
; 493  : 			//		pIndices[nCurIndexBufferIndex++]	=(ushort) (nCurRow*(nSegv+1) + nCurColumn+1);
; 494  : 			//		pIndices[nCurIndexBufferIndex++]	=(ushort) ((nCurRow+1)*(nSegv+1) + nCurColumn+1);
; 495  : 
; 496  : 			//		pIndices[nCurIndexBufferIndex++]	=(ushort) (nCurRow*(nSegv+1) + nCurColumn);
; 497  : 			//		pIndices[nCurIndexBufferIndex++]	=(ushort) ((nCurRow+1)*(nSegv+1) + nCurColumn);
; 498  : 			//		pIndices[nCurIndexBufferIndex++]	=(ushort) ((nCurRow+1)*(nSegv+1) + nCurColumn+1);
; 499  : 			//	}	
; 500  : 			//}
; 501  : 		}
; 502  : 
; 503  : 		pIndexBuffer->unlock();

	mov	ecx, DWORD PTR _pIndexBuffer$[ebp]
	call	?unlock@DynamicIndexBuffer@Ogre@@QAEXXZ	; Ogre::DynamicIndexBuffer::unlock

; 504  : 		pVertexBuffer->unlock();

	mov	ecx, DWORD PTR _pVertexBuffer$[ebp]
	call	?unlock@DynamicVertexBuffer@Ogre@@QAEXXZ ; Ogre::DynamicVertexBuffer::unlock

; 505  : 		pIndexBuffer->setVertexRange(0, m_nVerts);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+292]
	push	edx
	push	0
	mov	ecx, DWORD PTR _pIndexBuffer$[ebp]
	call	?setVertexRange@IndexBuffer@Ogre@@QAEXII@Z ; Ogre::IndexBuffer::setVertexRange

; 506  : 
; 507  : 		pcontext->setIB(pIndexBuffer);

	mov	eax, DWORD PTR _pIndexBuffer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pcontext$[ebp]
	call	?setIB@ShaderContext@Ogre@@QAEXPAVIndexBuffer@2@@Z ; Ogre::ShaderContext::setIB

; 508  : 		pcontext->setVB(pVertexBuffer);

	mov	ecx, DWORD PTR _pVertexBuffer$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _pcontext$[ebp]
	call	?setVB@ShaderContext@Ogre@@QAEXPAVVertexBuffer@2@@Z ; Ogre::ShaderContext::setVB

; 509  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?fillContext@ParametricShape@Ogre@@QAEXPAVSceneRenderer@2@PAVShaderContext@2@W4PARAMSHAPE_TYPE@2@II@Z$0:
	mov	eax, DWORD PTR ?$S10@?1??fillContext@ParametricShape@Ogre@@QAEXPAVSceneRenderer@3@PAVShaderContext@3@W4PARAMSHAPE_TYPE@3@II@Z@4IA
	and	eax, -2					; fffffffeH
	mov	DWORD PTR ?$S10@?1??fillContext@ParametricShape@Ogre@@QAEXPAVSceneRenderer@3@PAVShaderContext@3@W4PARAMSHAPE_TYPE@3@II@Z@4IA, eax
	ret	0
__unwindfunclet$?fillContext@ParametricShape@Ogre@@QAEXPAVSceneRenderer@2@PAVShaderContext@2@W4PARAMSHAPE_TYPE@2@II@Z$1:
	mov	eax, DWORD PTR ?$S10@?1??fillContext@ParametricShape@Ogre@@QAEXPAVSceneRenderer@3@PAVShaderContext@3@W4PARAMSHAPE_TYPE@3@II@Z@4IA
	and	eax, -3					; fffffffdH
	mov	DWORD PTR ?$S10@?1??fillContext@ParametricShape@Ogre@@QAEXPAVSceneRenderer@3@PAVShaderContext@3@W4PARAMSHAPE_TYPE@3@II@Z@4IA, eax
	ret	0
__unwindfunclet$?fillContext@ParametricShape@Ogre@@QAEXPAVSceneRenderer@2@PAVShaderContext@2@W4PARAMSHAPE_TYPE@2@II@Z$2:
	mov	eax, DWORD PTR ?$S10@?1??fillContext@ParametricShape@Ogre@@QAEXPAVSceneRenderer@3@PAVShaderContext@3@W4PARAMSHAPE_TYPE@3@II@Z@4IA
	and	eax, -5					; fffffffbH
	mov	DWORD PTR ?$S10@?1??fillContext@ParametricShape@Ogre@@QAEXPAVSceneRenderer@3@PAVShaderContext@3@W4PARAMSHAPE_TYPE@3@II@Z@4IA, eax
	ret	0
__unwindfunclet$?fillContext@ParametricShape@Ogre@@QAEXPAVSceneRenderer@2@PAVShaderContext@2@W4PARAMSHAPE_TYPE@2@II@Z$3:
	mov	eax, DWORD PTR ?$S10@?1??fillContext@ParametricShape@Ogre@@QAEXPAVSceneRenderer@3@PAVShaderContext@3@W4PARAMSHAPE_TYPE@3@II@Z@4IA
	and	eax, -9					; fffffff7H
	mov	DWORD PTR ?$S10@?1??fillContext@ParametricShape@Ogre@@QAEXPAVSceneRenderer@3@PAVShaderContext@3@W4PARAMSHAPE_TYPE@3@II@Z@4IA, eax
	ret	0
__unwindfunclet$?fillContext@ParametricShape@Ogre@@QAEXPAVSceneRenderer@2@PAVShaderContext@2@W4PARAMSHAPE_TYPE@2@II@Z$4:
	mov	eax, DWORD PTR ?$S10@?1??fillContext@ParametricShape@Ogre@@QAEXPAVSceneRenderer@3@PAVShaderContext@3@W4PARAMSHAPE_TYPE@3@II@Z@4IA
	and	eax, -17				; ffffffefH
	mov	DWORD PTR ?$S10@?1??fillContext@ParametricShape@Ogre@@QAEXPAVSceneRenderer@3@PAVShaderContext@3@W4PARAMSHAPE_TYPE@3@II@Z@4IA, eax
	ret	0
__unwindfunclet$?fillContext@ParametricShape@Ogre@@QAEXPAVSceneRenderer@2@PAVShaderContext@2@W4PARAMSHAPE_TYPE@2@II@Z$5:
	mov	eax, DWORD PTR ?$S10@?1??fillContext@ParametricShape@Ogre@@QAEXPAVSceneRenderer@3@PAVShaderContext@3@W4PARAMSHAPE_TYPE@3@II@Z@4IA
	and	eax, -33				; ffffffdfH
	mov	DWORD PTR ?$S10@?1??fillContext@ParametricShape@Ogre@@QAEXPAVSceneRenderer@3@PAVShaderContext@3@W4PARAMSHAPE_TYPE@3@II@Z@4IA, eax
	ret	0
__unwindfunclet$?fillContext@ParametricShape@Ogre@@QAEXPAVSceneRenderer@2@PAVShaderContext@2@W4PARAMSHAPE_TYPE@2@II@Z$6:
	mov	eax, DWORD PTR ?$S10@?1??fillContext@ParametricShape@Ogre@@QAEXPAVSceneRenderer@3@PAVShaderContext@3@W4PARAMSHAPE_TYPE@3@II@Z@4IA
	and	eax, -65				; ffffffbfH
	mov	DWORD PTR ?$S10@?1??fillContext@ParametricShape@Ogre@@QAEXPAVSceneRenderer@3@PAVShaderContext@3@W4PARAMSHAPE_TYPE@3@II@Z@4IA, eax
	ret	0
__unwindfunclet$?fillContext@ParametricShape@Ogre@@QAEXPAVSceneRenderer@2@PAVShaderContext@2@W4PARAMSHAPE_TYPE@2@II@Z$7:
	mov	eax, DWORD PTR ?$S10@?1??fillContext@ParametricShape@Ogre@@QAEXPAVSceneRenderer@3@PAVShaderContext@3@W4PARAMSHAPE_TYPE@3@II@Z@4IA
	and	eax, -129				; ffffff7fH
	mov	DWORD PTR ?$S10@?1??fillContext@ParametricShape@Ogre@@QAEXPAVSceneRenderer@3@PAVShaderContext@3@W4PARAMSHAPE_TYPE@3@II@Z@4IA, eax
	ret	0
__unwindfunclet$?fillContext@ParametricShape@Ogre@@QAEXPAVSceneRenderer@2@PAVShaderContext@2@W4PARAMSHAPE_TYPE@2@II@Z$8:
	mov	eax, DWORD PTR ?$S10@?1??fillContext@ParametricShape@Ogre@@QAEXPAVSceneRenderer@3@PAVShaderContext@3@W4PARAMSHAPE_TYPE@3@II@Z@4IA
	and	eax, -257				; fffffeffH
	mov	DWORD PTR ?$S10@?1??fillContext@ParametricShape@Ogre@@QAEXPAVSceneRenderer@3@PAVShaderContext@3@W4PARAMSHAPE_TYPE@3@II@Z@4IA, eax
	ret	0
__ehhandler$?fillContext@ParametricShape@Ogre@@QAEXPAVSceneRenderer@2@PAVShaderContext@2@W4PARAMSHAPE_TYPE@2@II@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-684]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?fillContext@ParametricShape@Ogre@@QAEXPAVSceneRenderer@2@PAVShaderContext@2@W4PARAMSHAPE_TYPE@2@II@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?fillContext@ParametricShape@Ogre@@QAEXPAVSceneRenderer@2@PAVShaderContext@2@W4PARAMSHAPE_TYPE@2@II@Z ENDP ; Ogre::ParametricShape::fillContext
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogremath.h
;	COMDAT ?Lerp@Ogre@@YAMMMM@Z
_TEXT	SEGMENT
tv74 = -4						; size = 4
_v1$ = 8						; size = 4
_v2$ = 12						; size = 4
_t$ = 16						; size = 4
?Lerp@Ogre@@YAMMMM@Z PROC				; Ogre::Lerp, COMDAT

; 135  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 136  : 		return v1+(v2-v1)*t;

	fld	DWORD PTR _v2$[ebp]
	fsub	DWORD PTR _v1$[ebp]
	fmul	DWORD PTR _t$[ebp]
	fadd	DWORD PTR _v1$[ebp]
	fstp	DWORD PTR tv74[ebp]
	fld	DWORD PTR tv74[ebp]

; 137  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?Lerp@Ogre@@YAMMMM@Z ENDP				; Ogre::Lerp
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogrevector4.h
_TEXT	ENDS
;	COMDAT ??0Vector4@Ogre@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0Vector4@Ogre@@QAE@XZ PROC				; Ogre::Vector4::Vector4, COMDAT
; _this$ = ecx

; 43   : 		Vector4(){}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0Vector4@Ogre@@QAE@XZ ENDP				; Ogre::Vector4::Vector4
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?setElement@Vector4@Ogre@@QAEXMMMM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_x1$ = 8						; size = 4
_y1$ = 12						; size = 4
_z1$ = 16						; size = 4
_w1$ = 20						; size = 4
?setElement@Vector4@Ogre@@QAEXMMMM@Z PROC		; Ogre::Vector4::setElement, COMDAT
; _this$ = ecx

; 101  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 102  : 			x = x1;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR _x1$[ebp]
	fstp	DWORD PTR [eax]

; 103  : 			y = y1;

	mov	ecx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _y1$[ebp]
	fstp	DWORD PTR [ecx+4]

; 104  : 			z = z1;

	mov	edx, DWORD PTR _this$[ebp]
	fld	DWORD PTR _z1$[ebp]
	fstp	DWORD PTR [edx+8]

; 105  : 			w = w1;

	mov	eax, DWORD PTR _this$[ebp]
	fld	DWORD PTR _w1$[ebp]
	fstp	DWORD PTR [eax+12]

; 106  : 		}

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?setElement@Vector4@Ogre@@QAEXMMMM@Z ENDP		; Ogre::Vector4::setElement
_TEXT	ENDS
PUBLIC	??$Clamp@H@Ogre@@YAHABH00@Z			; Ogre::Clamp<int>
PUBLIC	__real@406fe00000000000
;	COMDAT __real@406fe00000000000
; File i:\svnroot\client\ogremain\ogrecolourvalue.h
CONST	SEGMENT
__real@406fe00000000000 DQ 0406fe00000000000r	; 255
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ??0ColorQuad@Ogre@@QAE@ABVColourValue@1@@Z
_TEXT	SEGMENT
_this$ = -52						; size = 4
$T94773 = -48						; size = 4
$T94772 = -44						; size = 4
$T94771 = -40						; size = 4
$T94770 = -36						; size = 4
$T94769 = -32						; size = 4
$T94768 = -28						; size = 4
$T94767 = -24						; size = 4
$T94766 = -20						; size = 4
$T94765 = -16						; size = 4
$T94764 = -12						; size = 4
$T94763 = -8						; size = 4
$T94762 = -4						; size = 4
_rhs$ = 8						; size = 4
??0ColorQuad@Ogre@@QAE@ABVColourValue@1@@Z PROC		; Ogre::ColorQuad::ColorQuad, COMDAT
; _this$ = ecx

; 353  : 		ColorQuad(const ColourValue &rhs)

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H
	mov	DWORD PTR _this$[ebp], ecx

; 354  : 		{
; 355  : 			r = (unsigned char)Clamp(int(rhs.r*255), 0, 255);

	mov	DWORD PTR $T94762[ebp], 255		; 000000ffH
	mov	DWORD PTR $T94763[ebp], 0
	mov	eax, DWORD PTR _rhs$[ebp]
	fld	DWORD PTR [eax]
	fmul	QWORD PTR __real@406fe00000000000
	call	__ftol2_sse
	mov	DWORD PTR $T94764[ebp], eax
	lea	ecx, DWORD PTR $T94762[ebp]
	push	ecx
	lea	edx, DWORD PTR $T94763[ebp]
	push	edx
	lea	eax, DWORD PTR $T94764[ebp]
	push	eax
	call	??$Clamp@H@Ogre@@YAHABH00@Z		; Ogre::Clamp<int>
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+2], al

; 356  : 			g = (unsigned char)Clamp(int(rhs.g*255), 0, 255);

	mov	DWORD PTR $T94765[ebp], 255		; 000000ffH
	mov	DWORD PTR $T94766[ebp], 0
	mov	edx, DWORD PTR _rhs$[ebp]
	fld	DWORD PTR [edx+4]
	fmul	QWORD PTR __real@406fe00000000000
	call	__ftol2_sse
	mov	DWORD PTR $T94767[ebp], eax
	lea	eax, DWORD PTR $T94765[ebp]
	push	eax
	lea	ecx, DWORD PTR $T94766[ebp]
	push	ecx
	lea	edx, DWORD PTR $T94767[ebp]
	push	edx
	call	??$Clamp@H@Ogre@@YAHABH00@Z		; Ogre::Clamp<int>
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+1], al

; 357  : 			b = (unsigned char)Clamp(int(rhs.b*255), 0, 255);

	mov	DWORD PTR $T94768[ebp], 255		; 000000ffH
	mov	DWORD PTR $T94769[ebp], 0
	mov	edx, DWORD PTR _rhs$[ebp]
	fld	DWORD PTR [edx+8]
	fmul	QWORD PTR __real@406fe00000000000
	call	__ftol2_sse
	mov	DWORD PTR $T94770[ebp], eax
	lea	eax, DWORD PTR $T94768[ebp]
	push	eax
	lea	ecx, DWORD PTR $T94769[ebp]
	push	ecx
	lea	edx, DWORD PTR $T94770[ebp]
	push	edx
	call	??$Clamp@H@Ogre@@YAHABH00@Z		; Ogre::Clamp<int>
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx], al

; 358  : 			a = (unsigned char)Clamp(int(rhs.a*255), 0, 255);

	mov	DWORD PTR $T94771[ebp], 255		; 000000ffH
	mov	DWORD PTR $T94772[ebp], 0
	mov	edx, DWORD PTR _rhs$[ebp]
	fld	DWORD PTR [edx+12]
	fmul	QWORD PTR __real@406fe00000000000
	call	__ftol2_sse
	mov	DWORD PTR $T94773[ebp], eax
	lea	eax, DWORD PTR $T94771[ebp]
	push	eax
	lea	ecx, DWORD PTR $T94772[ebp]
	push	ecx
	lea	edx, DWORD PTR $T94773[ebp]
	push	edx
	call	??$Clamp@H@Ogre@@YAHABH00@Z		; Ogre::Clamp<int>
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+3], al

; 359  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0ColorQuad@Ogre@@QAE@ABVColourValue@1@@Z ENDP		; Ogre::ColorQuad::ColorQuad
_TEXT	ENDS
PUBLIC	?fTransformedUVY@?1??TransformUV@Ogre@@YAXAAVVector2@2@ABV32@11ABVVector4@2@@Z@4MA ; `Ogre::TransformUV'::`2'::fTransformedUVY
PUBLIC	?fTransformedUVX@?1??TransformUV@Ogre@@YAXAAVVector2@2@ABV32@11ABVVector4@2@@Z@4MA ; `Ogre::TransformUV'::`2'::fTransformedUVX
PUBLIC	?transformedVec@?1??TransformUV@Ogre@@YAXAAVVector2@2@ABV32@11ABVVector4@2@@Z@4V32@A ; `Ogre::TransformUV'::`2'::transformedVec
PUBLIC	?FIX_VEC@?1??TransformUV@Ogre@@YAXAAVVector2@2@ABV32@11ABVVector4@2@@Z@4V32@B ; `Ogre::TransformUV'::`2'::FIX_VEC
PUBLIC	??_B?1??TransformUV@Ogre@@YAXAAVVector2@1@ABV21@11ABVVector4@1@@Z@51 ; `Ogre::TransformUV'::`2'::`local static guard'
;	COMDAT ?fTransformedUVY@?1??TransformUV@Ogre@@YAXAAVVector2@2@ABV32@11ABVVector4@2@@Z@4MA
; File i:\svnroot\client\ogremain\ogreparametricshape.cpp
_BSS	SEGMENT
?fTransformedUVY@?1??TransformUV@Ogre@@YAXAAVVector2@2@ABV32@11ABVVector4@2@@Z@4MA DD 01H DUP (?) ; `Ogre::TransformUV'::`2'::fTransformedUVY
_BSS	ENDS
;	COMDAT ?fTransformedUVX@?1??TransformUV@Ogre@@YAXAAVVector2@2@ABV32@11ABVVector4@2@@Z@4MA
_BSS	SEGMENT
?fTransformedUVX@?1??TransformUV@Ogre@@YAXAAVVector2@2@ABV32@11ABVVector4@2@@Z@4MA DD 01H DUP (?) ; `Ogre::TransformUV'::`2'::fTransformedUVX
_BSS	ENDS
;	COMDAT ?transformedVec@?1??TransformUV@Ogre@@YAXAAVVector2@2@ABV32@11ABVVector4@2@@Z@4V32@A
_BSS	SEGMENT
?transformedVec@?1??TransformUV@Ogre@@YAXAAVVector2@2@ABV32@11ABVVector4@2@@Z@4V32@A DQ 01H DUP (?) ; `Ogre::TransformUV'::`2'::transformedVec
_BSS	ENDS
;	COMDAT ?FIX_VEC@?1??TransformUV@Ogre@@YAXAAVVector2@2@ABV32@11ABVVector4@2@@Z@4V32@B
_BSS	SEGMENT
?FIX_VEC@?1??TransformUV@Ogre@@YAXAAVVector2@2@ABV32@11ABVVector4@2@@Z@4V32@B DQ 01H DUP (?) ; `Ogre::TransformUV'::`2'::FIX_VEC
_BSS	ENDS
;	COMDAT ??_B?1??TransformUV@Ogre@@YAXAAVVector2@1@ABV21@11ABVVector4@1@@Z@51
_BSS	SEGMENT
??_B?1??TransformUV@Ogre@@YAXAAVVector2@1@ABV21@11ABVVector4@1@@Z@51 DD 01H DUP (?) ; `Ogre::TransformUV'::`2'::`local static guard'
_BSS	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?TransformUV@Ogre@@YAXAAVVector2@1@ABV21@11ABVVector4@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?TransformUV@Ogre@@YAXAAVVector2@1@ABV21@11ABVVector4@1@@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?TransformUV@Ogre@@YAXAAVVector2@1@ABV21@11ABVVector4@1@@Z$1
__ehfuncinfo$?TransformUV@Ogre@@YAXAAVVector2@1@ABV21@11ABVVector4@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?TransformUV@Ogre@@YAXAAVVector2@1@ABV21@11ABVVector4@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?TransformUV@Ogre@@YAXAAVVector2@1@ABV21@11ABVVector4@1@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_uv$ = 8						; size = 4
_uvOffset$ = 12						; size = 4
_uvScale$ = 16						; size = 4
_uvRotate$ = 20						; size = 4
_uvTile$ = 24						; size = 4
?TransformUV@Ogre@@YAXAAVVector2@1@ABV21@11ABVVector4@1@@Z PROC ; Ogre::TransformUV, COMDAT

; 151  : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?TransformUV@Ogre@@YAXAAVVector2@1@ABV21@11ABVVector4@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 152  : 		static const Vector2 FIX_VEC( 0.5f, 0.5f );

	mov	eax, DWORD PTR ??_B?1??TransformUV@Ogre@@YAXAAVVector2@1@ABV21@11ABVVector4@1@@Z@51
	and	eax, 1
	jne	SHORT $LN2@TransformU
	mov	ecx, DWORD PTR ??_B?1??TransformUV@Ogre@@YAXAAVVector2@1@ABV21@11ABVVector4@1@@Z@51
	or	ecx, 1
	mov	DWORD PTR ??_B?1??TransformUV@Ogre@@YAXAAVVector2@1@ABV21@11ABVVector4@1@@Z@51, ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	push	ecx
	fld	DWORD PTR __real@3f000000
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR __real@3f000000
	fstp	DWORD PTR [esp]
	mov	ecx, OFFSET ?FIX_VEC@?1??TransformUV@Ogre@@YAXAAVVector2@2@ABV32@11ABVVector4@2@@Z@4V32@B ; `Ogre::TransformUV'::`2'::FIX_VEC
	call	??0Vector2@Ogre@@QAE@MM@Z		; Ogre::Vector2::Vector2
	mov	DWORD PTR __$EHRec$[ebp+8], -1
$LN2@TransformU:

; 153  : 		static Vector2		transformedVec;

	mov	edx, DWORD PTR ??_B?1??TransformUV@Ogre@@YAXAAVVector2@1@ABV21@11ABVVector4@1@@Z@51
	and	edx, 2
	jne	SHORT $LN1@TransformU
	mov	eax, DWORD PTR ??_B?1??TransformUV@Ogre@@YAXAAVVector2@1@ABV21@11ABVVector4@1@@Z@51
	or	eax, 2
	mov	DWORD PTR ??_B?1??TransformUV@Ogre@@YAXAAVVector2@1@ABV21@11ABVVector4@1@@Z@51, eax
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	mov	ecx, OFFSET ?transformedVec@?1??TransformUV@Ogre@@YAXAAVVector2@2@ABV32@11ABVVector4@2@@Z@4V32@A ; `Ogre::TransformUV'::`2'::transformedVec
	call	??0Vector2@Ogre@@QAE@XZ			; Ogre::Vector2::Vector2
	mov	DWORD PTR __$EHRec$[ebp+8], -1
$LN1@TransformU:

; 154  : 		static float fTransformedUVX;
; 155  : 		static float fTransformedUVY;
; 156  : 
; 157  : 		uv -= FIX_VEC;

	push	OFFSET ?FIX_VEC@?1??TransformUV@Ogre@@YAXAAVVector2@2@ABV32@11ABVVector4@2@@Z@4V32@B ; `Ogre::TransformUV'::`2'::FIX_VEC
	mov	ecx, DWORD PTR _uv$[ebp]
	call	??ZVector2@Ogre@@QAEXABV01@@Z		; Ogre::Vector2::operator-=

; 158  : 		fTransformedUVX = uv.x * uvRotate.y - uv.y * uvRotate.x;

	mov	ecx, DWORD PTR _uv$[ebp]
	fld	DWORD PTR [ecx]
	mov	edx, DWORD PTR _uvRotate$[ebp]
	fmul	DWORD PTR [edx+4]
	mov	eax, DWORD PTR _uv$[ebp]
	fld	DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _uvRotate$[ebp]
	fmul	DWORD PTR [ecx]
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR ?fTransformedUVX@?1??TransformUV@Ogre@@YAXAAVVector2@2@ABV32@11ABVVector4@2@@Z@4MA ; `Ogre::TransformUV'::`2'::fTransformedUVX

; 159  : 		fTransformedUVY = uv.x * uvRotate.x + uv.y * uvRotate.y;

	mov	edx, DWORD PTR _uv$[ebp]
	fld	DWORD PTR [edx]
	mov	eax, DWORD PTR _uvRotate$[ebp]
	fmul	DWORD PTR [eax]
	mov	ecx, DWORD PTR _uv$[ebp]
	fld	DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _uvRotate$[ebp]
	fmul	DWORD PTR [edx+4]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR ?fTransformedUVY@?1??TransformUV@Ogre@@YAXAAVVector2@2@ABV32@11ABVVector4@2@@Z@4MA ; `Ogre::TransformUV'::`2'::fTransformedUVY

; 160  : 
; 161  : 		fTransformedUVX *= uvScale.x;

	fld	DWORD PTR ?fTransformedUVX@?1??TransformUV@Ogre@@YAXAAVVector2@2@ABV32@11ABVVector4@2@@Z@4MA ; `Ogre::TransformUV'::`2'::fTransformedUVX
	mov	eax, DWORD PTR _uvScale$[ebp]
	fmul	DWORD PTR [eax]
	fstp	DWORD PTR ?fTransformedUVX@?1??TransformUV@Ogre@@YAXAAVVector2@2@ABV32@11ABVVector4@2@@Z@4MA ; `Ogre::TransformUV'::`2'::fTransformedUVX

; 162  : 		fTransformedUVX += uvOffset.x;

	fld	DWORD PTR ?fTransformedUVX@?1??TransformUV@Ogre@@YAXAAVVector2@2@ABV32@11ABVVector4@2@@Z@4MA ; `Ogre::TransformUV'::`2'::fTransformedUVX
	mov	ecx, DWORD PTR _uvOffset$[ebp]
	fadd	DWORD PTR [ecx]
	fstp	DWORD PTR ?fTransformedUVX@?1??TransformUV@Ogre@@YAXAAVVector2@2@ABV32@11ABVVector4@2@@Z@4MA ; `Ogre::TransformUV'::`2'::fTransformedUVX

; 163  : 		fTransformedUVX += FIX_VEC.x;

	fld	DWORD PTR ?fTransformedUVX@?1??TransformUV@Ogre@@YAXAAVVector2@2@ABV32@11ABVVector4@2@@Z@4MA ; `Ogre::TransformUV'::`2'::fTransformedUVX
	fadd	DWORD PTR ?FIX_VEC@?1??TransformUV@Ogre@@YAXAAVVector2@2@ABV32@11ABVVector4@2@@Z@4V32@B
	fstp	DWORD PTR ?fTransformedUVX@?1??TransformUV@Ogre@@YAXAAVVector2@2@ABV32@11ABVVector4@2@@Z@4MA ; `Ogre::TransformUV'::`2'::fTransformedUVX

; 164  : 		fTransformedUVX /= uvTile.z;

	fld	DWORD PTR ?fTransformedUVX@?1??TransformUV@Ogre@@YAXAAVVector2@2@ABV32@11ABVVector4@2@@Z@4MA ; `Ogre::TransformUV'::`2'::fTransformedUVX
	mov	edx, DWORD PTR _uvTile$[ebp]
	fdiv	DWORD PTR [edx+8]
	fstp	DWORD PTR ?fTransformedUVX@?1??TransformUV@Ogre@@YAXAAVVector2@2@ABV32@11ABVVector4@2@@Z@4MA ; `Ogre::TransformUV'::`2'::fTransformedUVX

; 165  : 		fTransformedUVX += uvTile.x;

	fld	DWORD PTR ?fTransformedUVX@?1??TransformUV@Ogre@@YAXAAVVector2@2@ABV32@11ABVVector4@2@@Z@4MA ; `Ogre::TransformUV'::`2'::fTransformedUVX
	mov	eax, DWORD PTR _uvTile$[ebp]
	fadd	DWORD PTR [eax]
	fstp	DWORD PTR ?fTransformedUVX@?1??TransformUV@Ogre@@YAXAAVVector2@2@ABV32@11ABVVector4@2@@Z@4MA ; `Ogre::TransformUV'::`2'::fTransformedUVX

; 166  : 
; 167  : 		fTransformedUVY *= uvScale.y;

	fld	DWORD PTR ?fTransformedUVY@?1??TransformUV@Ogre@@YAXAAVVector2@2@ABV32@11ABVVector4@2@@Z@4MA ; `Ogre::TransformUV'::`2'::fTransformedUVY
	mov	ecx, DWORD PTR _uvScale$[ebp]
	fmul	DWORD PTR [ecx+4]
	fstp	DWORD PTR ?fTransformedUVY@?1??TransformUV@Ogre@@YAXAAVVector2@2@ABV32@11ABVVector4@2@@Z@4MA ; `Ogre::TransformUV'::`2'::fTransformedUVY

; 168  : 		fTransformedUVY += uvOffset.y;

	fld	DWORD PTR ?fTransformedUVY@?1??TransformUV@Ogre@@YAXAAVVector2@2@ABV32@11ABVVector4@2@@Z@4MA ; `Ogre::TransformUV'::`2'::fTransformedUVY
	mov	edx, DWORD PTR _uvOffset$[ebp]
	fadd	DWORD PTR [edx+4]
	fstp	DWORD PTR ?fTransformedUVY@?1??TransformUV@Ogre@@YAXAAVVector2@2@ABV32@11ABVVector4@2@@Z@4MA ; `Ogre::TransformUV'::`2'::fTransformedUVY

; 169  : 		fTransformedUVY += FIX_VEC.y;

	fld	DWORD PTR ?fTransformedUVY@?1??TransformUV@Ogre@@YAXAAVVector2@2@ABV32@11ABVVector4@2@@Z@4MA ; `Ogre::TransformUV'::`2'::fTransformedUVY
	fadd	DWORD PTR ?FIX_VEC@?1??TransformUV@Ogre@@YAXAAVVector2@2@ABV32@11ABVVector4@2@@Z@4V32@B+4
	fstp	DWORD PTR ?fTransformedUVY@?1??TransformUV@Ogre@@YAXAAVVector2@2@ABV32@11ABVVector4@2@@Z@4MA ; `Ogre::TransformUV'::`2'::fTransformedUVY

; 170  : 		fTransformedUVY /= uvTile.w;

	fld	DWORD PTR ?fTransformedUVY@?1??TransformUV@Ogre@@YAXAAVVector2@2@ABV32@11ABVVector4@2@@Z@4MA ; `Ogre::TransformUV'::`2'::fTransformedUVY
	mov	eax, DWORD PTR _uvTile$[ebp]
	fdiv	DWORD PTR [eax+12]
	fstp	DWORD PTR ?fTransformedUVY@?1??TransformUV@Ogre@@YAXAAVVector2@2@ABV32@11ABVVector4@2@@Z@4MA ; `Ogre::TransformUV'::`2'::fTransformedUVY

; 171  : 		fTransformedUVY += uvTile.y;

	fld	DWORD PTR ?fTransformedUVY@?1??TransformUV@Ogre@@YAXAAVVector2@2@ABV32@11ABVVector4@2@@Z@4MA ; `Ogre::TransformUV'::`2'::fTransformedUVY
	mov	ecx, DWORD PTR _uvTile$[ebp]
	fadd	DWORD PTR [ecx+4]
	fstp	DWORD PTR ?fTransformedUVY@?1??TransformUV@Ogre@@YAXAAVVector2@2@ABV32@11ABVVector4@2@@Z@4MA ; `Ogre::TransformUV'::`2'::fTransformedUVY

; 172  : 
; 173  : 		uv.setElement( fTransformedUVX, fTransformedUVY );

	push	ecx
	fld	DWORD PTR ?fTransformedUVY@?1??TransformUV@Ogre@@YAXAAVVector2@2@ABV32@11ABVVector4@2@@Z@4MA ; `Ogre::TransformUV'::`2'::fTransformedUVY
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR ?fTransformedUVX@?1??TransformUV@Ogre@@YAXAAVVector2@2@ABV32@11ABVVector4@2@@Z@4MA ; `Ogre::TransformUV'::`2'::fTransformedUVX
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _uv$[ebp]
	call	?setElement@Vector2@Ogre@@QAEXMM@Z	; Ogre::Vector2::setElement

; 174  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?TransformUV@Ogre@@YAXAAVVector2@1@ABV21@11ABVVector4@1@@Z$0:
	mov	eax, DWORD PTR ??_B?1??TransformUV@Ogre@@YAXAAVVector2@1@ABV21@11ABVVector4@1@@Z@51
	and	eax, -2					; fffffffeH
	mov	DWORD PTR ??_B?1??TransformUV@Ogre@@YAXAAVVector2@1@ABV21@11ABVVector4@1@@Z@51, eax
	ret	0
__unwindfunclet$?TransformUV@Ogre@@YAXAAVVector2@1@ABV21@11ABVVector4@1@@Z$1:
	mov	eax, DWORD PTR ??_B?1??TransformUV@Ogre@@YAXAAVVector2@1@ABV21@11ABVVector4@1@@Z@51
	and	eax, -3					; fffffffdH
	mov	DWORD PTR ??_B?1??TransformUV@Ogre@@YAXAAVVector2@1@ABV21@11ABVVector4@1@@Z@51, eax
	ret	0
__ehhandler$?TransformUV@Ogre@@YAXAAVVector2@1@ABV21@11ABVVector4@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?TransformUV@Ogre@@YAXAAVVector2@1@ABV21@11ABVVector4@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?TransformUV@Ogre@@YAXAAVVector2@1@ABV21@11ABVVector4@1@@Z ENDP ; Ogre::TransformUV
; Function compile flags: /Odtp
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pause$ = 8						; size = 1
_tick$ = 12						; size = 4
?resetUpdate@ParametricShape@Ogre@@UAEX_NI@Z PROC	; Ogre::ParametricShape::resetUpdate
; _this$ = ecx

; 512  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 513  : 		m_bPause = pause;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR _pause$[ebp]
	mov	BYTE PTR [eax+184], cl

; 514  : 		if(tick != 0xffffffff) m_CurTick = tick;

	cmp	DWORD PTR _tick$[ebp], -1
	je	SHORT $LN2@resetUpdat
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _tick$[ebp]
	mov	DWORD PTR [edx+284], eax
$LN2@resetUpdat:

; 515  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?resetUpdate@ParametricShape@Ogre@@UAEX_NI@Z ENDP	; Ogre::ParametricShape::resetUpdate
_TEXT	ENDS
PUBLIC	__real@43480000
EXTRN	?prepareData@ParamShapeData@Ogre@@QAEXIAAUParamShapeFrameData@2@@Z:PROC ; Ogre::ParamShapeData::prepareData
;	COMDAT __real@43480000
CONST	SEGMENT
__real@43480000 DD 043480000r			; 200
CONST	ENDS
xdata$x	SEGMENT
__unwindtable$?update@ParametricShape@Ogre@@UAEXI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?update@ParametricShape@Ogre@@UAEXI@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?update@ParametricShape@Ogre@@UAEXI@Z$1
__ehfuncinfo$?update@ParametricShape@Ogre@@UAEXI@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?update@ParametricShape@Ogre@@UAEXI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
_TEXT	SEGMENT
_this$ = -48						; size = 4
$T94792 = -44						; size = 12
$T94791 = -32						; size = 12
$T94790 = -20						; size = 4
$T94789 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_dtick$ = 8						; size = 4
?update@ParametricShape@Ogre@@UAEXI@Z PROC		; Ogre::ParametricShape::update
; _this$ = ecx

; 518  : 	{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?update@ParametricShape@Ogre@@UAEXI@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 36					; 00000024H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 519  : 		RenderableObject::update(dtick);

	mov	eax, DWORD PTR _dtick$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?update@MovableObject@Ogre@@UAEXI@Z	; Ogre::MovableObject::update

; 520  : 
; 521  : 		if(!m_bPause) m_CurTick += dtick;

	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+184]
	test	edx, edx
	jne	SHORT $LN3@update@2
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+284]
	add	ecx, DWORD PTR _dtick$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+284], ecx
$LN3@update@2:

; 522  : 
; 523  : 		m_pSource->prepareData(m_CurTick, m_FrameData);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 336				; 00000150H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+284]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+280]
	call	?prepareData@ParamShapeData@Ogre@@QAEXIAAUParamShapeFrameData@2@@Z ; Ogre::ParamShapeData::prepareData

; 524  : 		if(m_pCurTex != m_pSource->m_pTextureRes)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+280]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+324]
	cmp	ecx, DWORD PTR [edx+76]
	je	SHORT $LN2@update@2

; 525  : 		{
; 526  : 			m_pMtl->setParamTexture("g_DiffuseTex", m_pSource->m_pTextureRes);

	push	OFFSET $SG70142
	lea	ecx, DWORD PTR $T94789[ebp]
	call	??0FixedString@Ogre@@QAE@PBD@Z		; Ogre::FixedString::FixedString
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+280]
	mov	ecx, DWORD PTR [eax+76]
	push	ecx
	lea	edx, DWORD PTR $T94789[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+332]
	call	?setParamTexture@Material@Ogre@@QAEXABVFixedString@2@PAVTexture@2@@Z ; Ogre::Material::setParamTexture
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T94789[ebp]
	call	??1FixedString@Ogre@@QAE@XZ		; Ogre::FixedString::~FixedString

; 527  : 			m_pCurTex = m_pSource->m_pTextureRes;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+280]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+76]
	mov	DWORD PTR [eax+324], ecx
$LN2@update@2:

; 528  : 		}
; 529  : 		if(m_pCurMaskTex != m_pSource->m_pMaskTextureRes)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+280]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+328]
	cmp	edx, DWORD PTR [eax+80]
	je	SHORT $LN1@update@2

; 530  : 		{
; 531  : 			m_pMtl->setParamTexture("g_MaskTex", m_pSource->m_pMaskTextureRes);

	push	OFFSET $SG70145
	lea	ecx, DWORD PTR $T94790[ebp]
	call	??0FixedString@Ogre@@QAE@PBD@Z		; Ogre::FixedString::FixedString
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+280]
	mov	edx, DWORD PTR [ecx+80]
	push	edx
	lea	eax, DWORD PTR $T94790[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx+332]
	call	?setParamTexture@Material@Ogre@@QAEXABVFixedString@2@PAVTexture@2@@Z ; Ogre::Material::setParamTexture
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T94790[ebp]
	call	??1FixedString@Ogre@@QAE@XZ		; Ogre::FixedString::~FixedString

; 532  : 			m_pCurMaskTex = m_pSource->m_pMaskTextureRes;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+280]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+80]
	mov	DWORD PTR [ecx+328], edx
$LN1@update@2:

; 533  : 		}
; 534  : 
; 535  : 		m_WorldBounds.m_Center = getWorldPosition();

	lea	eax, DWORD PTR $T94791[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getWorldPosition@MovableObject@Ogre@@QAE?BVVector3@2@XZ ; Ogre::MovableObject::getWorldPosition
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 140				; 0000008cH
	call	??4Vector3@Ogre@@QAEABV01@ABV01@@Z	; Ogre::Vector3::operator=

; 536  : 		m_WorldBounds.m_Extent = Vector3(200.0f, 200.0f, 200.0f);

	push	ecx
	fld	DWORD PTR __real@43480000
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR __real@43480000
	fstp	DWORD PTR [esp]
	push	ecx
	fld	DWORD PTR __real@43480000
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR $T94792[ebp]
	call	??0Vector3@Ogre@@QAE@MMM@Z		; Ogre::Vector3::Vector3
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 152				; 00000098H
	call	??4Vector3@Ogre@@QAEABV01@ABV01@@Z	; Ogre::Vector3::operator=

; 537  : 		m_WorldBounds.m_Radius = m_WorldBounds.m_Extent.length();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 152				; 00000098H
	call	?length@Vector3@Ogre@@QBEMXZ		; Ogre::Vector3::length
	mov	ecx, DWORD PTR _this$[ebp]
	fstp	DWORD PTR [ecx+164]

; 538  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?update@ParametricShape@Ogre@@UAEXI@Z$0:
	lea	ecx, DWORD PTR $T94789[ebp]
	jmp	??1FixedString@Ogre@@QAE@XZ		; Ogre::FixedString::~FixedString
__unwindfunclet$?update@ParametricShape@Ogre@@UAEXI@Z$1:
	lea	ecx, DWORD PTR $T94790[ebp]
	jmp	??1FixedString@Ogre@@QAE@XZ		; Ogre::FixedString::~FixedString
__ehhandler$?update@ParametricShape@Ogre@@UAEXI@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-40]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?update@ParametricShape@Ogre@@UAEXI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?update@ParametricShape@Ogre@@UAEXI@Z ENDP		; Ogre::ParametricShape::update
EXTRN	?setInstanceEnvData@ShaderContext@Ogre@@QAEXPAVSceneRenderer@2@PAVRenderableObject@2@ABUShaderEnvData@2@PBVMatrix4@2@@Z:PROC ; Ogre::ShaderContext::setInstanceEnvData
EXTRN	?newContext@SceneRenderer@Ogre@@QAEPAVShaderContext@2@W4RenderLayer@2@ABUShaderEnvData@2@PAVMaterial@2@IPAVVertexBuffer@2@PAVIndexBuffer@2@W4PrimitiveType@2@I_N@Z:PROC ; Ogre::SceneRenderer::newContext
; Function compile flags: /Odtp
_TEXT	SEGMENT
_this$ = -8						; size = 4
_pcontext$ = -4						; size = 4
_pRenderer$ = 8						; size = 4
_envdata$ = 12						; size = 4
?render@ParametricShape@Ogre@@UAEXPAVSceneRenderer@2@ABUShaderEnvData@2@@Z PROC ; Ogre::ParametricShape::render
; _this$ = ecx

; 541  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 542  : 		m_nIndex = (int)GetNumIndex(m_pSource->m_GeoType, m_pSource->m_nUSeg, m_pSource->m_nVSeg);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+280]
	mov	edx, DWORD PTR [ecx+60]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+280]
	mov	edx, DWORD PTR [ecx+56]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+280]
	mov	edx, DWORD PTR [ecx+20]
	push	edx
	call	?GetNumIndex@Ogre@@YAIW4PARAMSHAPE_TYPE@1@II@Z ; Ogre::GetNumIndex
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+288], eax

; 543  : 		m_nVerts = (int)GetNumVertex(m_pSource->m_GeoType, m_pSource->m_nUSeg, m_pSource->m_nVSeg);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+280]
	mov	ecx, DWORD PTR [eax+60]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+280]
	mov	ecx, DWORD PTR [eax+56]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+280]
	mov	ecx, DWORD PTR [eax+20]
	push	ecx
	call	?GetNumVertex@Ogre@@YAIW4PARAMSHAPE_TYPE@1@II@Z ; Ogre::GetNumVertex
	add	esp, 12					; 0000000cH
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+292], eax

; 544  : 
; 545  : 		ShaderContext *pcontext = pRenderer->newContext(RL_SCENE, envdata, m_pMtl, m_VertDecl, NULL, NULL, PRIM_TRIANGLELIST, m_nIndex/3, true);

	push	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+288]
	cdq
	mov	ecx, 3
	idiv	ecx
	push	eax
	push	4
	push	0
	push	0
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+320]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+332]
	push	edx
	mov	eax, DWORD PTR _envdata$[ebp]
	push	eax
	push	2
	mov	ecx, DWORD PTR _pRenderer$[ebp]
	call	?newContext@SceneRenderer@Ogre@@QAEPAVShaderContext@2@W4RenderLayer@2@ABUShaderEnvData@2@PAVMaterial@2@IPAVVertexBuffer@2@PAVIndexBuffer@2@W4PrimitiveType@2@I_N@Z ; Ogre::SceneRenderer::newContext
	mov	DWORD PTR _pcontext$[ebp], eax

; 546  : 		DEBUG_SHADERCONTEXT(pcontext);
; 547  : 		fillContext(pRenderer, pcontext, m_pSource->m_GeoType, m_pSource->m_nUSeg, m_pSource->m_nVSeg);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+280]
	mov	eax, DWORD PTR [edx+60]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+280]
	mov	eax, DWORD PTR [edx+56]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+280]
	mov	eax, DWORD PTR [edx+20]
	push	eax
	mov	ecx, DWORD PTR _pcontext$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pRenderer$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?fillContext@ParametricShape@Ogre@@QAEXPAVSceneRenderer@2@PAVShaderContext@2@W4PARAMSHAPE_TYPE@2@II@Z ; Ogre::ParametricShape::fillContext

; 548  : 		pcontext->setInstanceEnvData(pRenderer, this, envdata);

	push	0
	mov	eax, DWORD PTR _envdata$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pRenderer$[ebp]
	push	edx
	mov	ecx, DWORD PTR _pcontext$[ebp]
	call	?setInstanceEnvData@ShaderContext@Ogre@@QAEXPAVSceneRenderer@2@PAVRenderableObject@2@ABUShaderEnvData@2@PBVMatrix4@2@@Z ; Ogre::ShaderContext::setInstanceEnvData

; 549  : 	}

	mov	esp, ebp
	pop	ebp
	ret	8
?render@ParametricShape@Ogre@@UAEXPAVSceneRenderer@2@ABUShaderEnvData@2@@Z ENDP ; Ogre::ParametricShape::render
; Function compile flags: /Odtp
_GeoType$ = 8						; size = 4
_nSegu$ = 12						; size = 4
_nSegv$ = 16						; size = 4
?GetNumIndex@Ogre@@YAIW4PARAMSHAPE_TYPE@1@II@Z PROC	; Ogre::GetNumIndex

; 128  : 	{

	push	ebp
	mov	ebp, esp

; 129  : 		if(GeoType==GEO_SPHERE || GeoType==GEO_TORUS || GeoType==GEO_COLUMN) return 6*nSegu*nSegv;

	cmp	DWORD PTR _GeoType$[ebp], 0
	je	SHORT $LN4@GetNumInde
	cmp	DWORD PTR _GeoType$[ebp], 1
	je	SHORT $LN4@GetNumInde
	cmp	DWORD PTR _GeoType$[ebp], 3
	jne	SHORT $LN5@GetNumInde
$LN4@GetNumInde:
	mov	eax, DWORD PTR _nSegu$[ebp]
	imul	eax, 6
	imul	eax, DWORD PTR _nSegv$[ebp]
	jmp	SHORT $LN6@GetNumInde
	jmp	SHORT $LN6@GetNumInde
$LN5@GetNumInde:

; 130  : 		else if(GeoType == GEO_TUBE) return 6*nSegu*(2*nSegv+1);

	cmp	DWORD PTR _GeoType$[ebp], 2
	jne	SHORT $LN2@GetNumInde
	mov	eax, DWORD PTR _nSegu$[ebp]
	imul	eax, 6
	mov	ecx, DWORD PTR _nSegv$[ebp]
	lea	edx, DWORD PTR [ecx+ecx+1]
	imul	eax, edx
	jmp	SHORT $LN6@GetNumInde

; 131  : 		else

	jmp	SHORT $LN6@GetNumInde
$LN2@GetNumInde:

; 132  : 		{
; 133  : 			assert(0);
; 134  : 			return 0;

	xor	eax, eax
$LN6@GetNumInde:

; 135  : 		}
; 136  : 	}

	pop	ebp
	ret	0
?GetNumIndex@Ogre@@YAIW4PARAMSHAPE_TYPE@1@II@Z ENDP	; Ogre::GetNumIndex
; Function compile flags: /Odtp
_GeoType$ = 8						; size = 4
_nSegu$ = 12						; size = 4
_nSegv$ = 16						; size = 4
?GetNumVertex@Ogre@@YAIW4PARAMSHAPE_TYPE@1@II@Z PROC	; Ogre::GetNumVertex

; 139  : 	{

	push	ebp
	mov	ebp, esp

; 140  : 		if(GeoType==GEO_SPHERE || GeoType==GEO_TORUS || GeoType==GEO_COLUMN) return (nSegu+1)*(nSegv+1);

	cmp	DWORD PTR _GeoType$[ebp], 0
	je	SHORT $LN4@GetNumVert
	cmp	DWORD PTR _GeoType$[ebp], 1
	je	SHORT $LN4@GetNumVert
	cmp	DWORD PTR _GeoType$[ebp], 3
	jne	SHORT $LN5@GetNumVert
$LN4@GetNumVert:
	mov	eax, DWORD PTR _nSegu$[ebp]
	add	eax, 1
	mov	ecx, DWORD PTR _nSegv$[ebp]
	add	ecx, 1
	imul	eax, ecx
	jmp	SHORT $LN6@GetNumVert
	jmp	SHORT $LN6@GetNumVert
$LN5@GetNumVert:

; 141  : 		else if(GeoType == GEO_TUBE) return 2*(nSegu+1)*(nSegv+1);

	cmp	DWORD PTR _GeoType$[ebp], 2
	jne	SHORT $LN2@GetNumVert
	mov	edx, DWORD PTR _nSegu$[ebp]
	lea	eax, DWORD PTR [edx+edx+2]
	mov	ecx, DWORD PTR _nSegv$[ebp]
	add	ecx, 1
	imul	eax, ecx
	jmp	SHORT $LN6@GetNumVert

; 142  : 		else

	jmp	SHORT $LN6@GetNumVert
$LN2@GetNumVert:

; 143  : 		{
; 144  : 			assert(0);
; 145  : 			return 0;

	xor	eax, eax
$LN6@GetNumVert:

; 146  : 		}
; 147  : 	}

	pop	ebp
	ret	0
?GetNumVertex@Ogre@@YAIW4PARAMSHAPE_TYPE@1@II@Z ENDP	; Ogre::GetNumVertex
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAE@XZ ; std::_Vector_val<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::~_Vector_val<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >
PUBLIC	?_Tidy@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAEXXZ ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::_Tidy
PUBLIC	??$_Ucopy@V?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAEPAUAnimRange@BaseKeyFrameArray@Ogre@@V?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@1@0PAU234@@Z ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::_Ucopy<std::_Vector_const_iterator<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> > >
PUBLIC	?begin@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@2@XZ ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::begin
PUBLIC	?end@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@2@XZ ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::end
PUBLIC	?_Buy@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAE_NI@Z ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::_Buy
PUBLIC	?size@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::size
PUBLIC	??0?$_Vector_val@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAE@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@1@@Z ; std::_Vector_val<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::_Vector_val<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >
PUBLIC	??0?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::BaseKeyFrameArray::AnimRange>::allocator<Ogre::BaseKeyFrameArray::AnimRange>
EXTRN	__CxxThrowException@8:PROC
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	SEGMENT
__catchsym$??0?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAE@ABV01@@Z$3 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??0?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAE@ABV01@@Z$0
__tryblocktable$??0?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAE@ABV01@@Z DD 01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??0?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAE@ABV01@@Z$3
__unwindtable$??0?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAE@ABV01@@Z$2
	DD	00H
	DD	00H
	DD	00H
	DD	00H
__ehfuncinfo$??0?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAE@ABV01@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAE@ABV01@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??0?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -40						; size = 4
$T94807 = -36						; size = 8
$T94806 = -28						; size = 8
$T94805 = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Right$ = 8						; size = 4
??0?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAE@ABV01@@Z PROC ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >, COMDAT
; _this$ = ecx

; 500  : 		{	// construct by copying _Right

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 24					; 00000018H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Right$[ebp]
	add	eax, 8
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T94805[ebp], esp
	push	eax
	call	??0?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::BaseKeyFrameArray::AnimRange>::allocator<Ogre::BaseKeyFrameArray::AnimRange>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_val@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAE@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@1@@Z ; std::_Vector_val<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::_Vector_val<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >
	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 501  : 		if (_Buy(_Right.size()))

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::size
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAE_NI@Z ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::_Buy
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN3@vector@28

; 502  : 			_TRY_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 1

; 503  : 			_Mylast = _Ucopy(_Right.begin(), _Right.end(), _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	lea	ecx, DWORD PTR $T94806[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?end@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@2@XZ ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::end
	mov	edx, DWORD PTR [eax+4]
	push	edx
	mov	eax, DWORD PTR [eax]
	push	eax
	lea	ecx, DWORD PTR $T94807[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?begin@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@2@XZ ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::begin
	mov	edx, DWORD PTR [eax+4]
	push	edx
	mov	eax, DWORD PTR [eax]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Ucopy@V?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAEPAUAnimRange@BaseKeyFrameArray@Ogre@@V?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@1@0PAU234@@Z ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::_Ucopy<std::_Vector_const_iterator<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> > >
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax
	jmp	SHORT $LN5@vector@28
__catch$??0?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAE@ABV01@@Z$0:

; 504  : 			_CATCH_ALL
; 505  : 			_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAEXXZ ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::_Tidy

; 506  : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 507  : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], 0
	mov	eax, $LN3@vector@28
	ret	0
$LN5@vector@28:
	mov	DWORD PTR __$EHRec$[ebp+12], 0
$LN3@vector@28:

; 508  : 		}

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector@28:
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAE@ABV01@@Z$2:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAE@XZ
__ehhandler$??0?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-44]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAE@XZ PROC ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::~vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 559  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAEXXZ ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::_Tidy

; 560  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Vector_val@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAE@XZ
__ehhandler$??1?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAE@XZ ENDP ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::~vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >
; Function compile flags: /Odtp
;	COMDAT ?size@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QBEIXZ PROC ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::size, COMDAT
; _this$ = ecx

; 725  : 		{	// return length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+16]
	sub	eax, DWORD PTR [ecx+12]
	sar	eax, 3

; 727  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?size@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QBEIXZ ENDP ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::size
_TEXT	ENDS
PUBLIC	?size@?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::size
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogrekeyframearray.h
;	COMDAT ?getNumKey@?$KeyFrameArray@M@Ogre@@UAEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getNumKey@?$KeyFrameArray@M@Ogre@@UAEIXZ PROC		; Ogre::KeyFrameArray<float>::getNumKey, COMDAT
; _this$ = ecx

; 94   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 95   : 			return m_Array.size();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	?size@?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::size

; 96   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?getNumKey@?$KeyFrameArray@M@Ogre@@UAEIXZ ENDP		; Ogre::KeyFrameArray<float>::getNumKey
_TEXT	ENDS
PUBLIC	?getValue@?$KeyFrameArray@M@Ogre@@QAEXHIAAM_N@Z	; Ogre::KeyFrameArray<float>::getValue
; Function compile flags: /Odtp
;	COMDAT ?getValue@?$KeyFrameArray@M@Ogre@@UAEXHIPAX@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_seq$ = 8						; size = 4
_tick$ = 12						; size = 4
_pdata$ = 16						; size = 4
?getValue@?$KeyFrameArray@M@Ogre@@UAEXHIPAX@Z PROC	; Ogre::KeyFrameArray<float>::getValue, COMDAT
; _this$ = ecx

; 99   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 100  : 			return getValue(seq, tick, *(POSTYPE *)pdata);

	push	1
	mov	eax, DWORD PTR _pdata$[ebp]
	push	eax
	mov	ecx, DWORD PTR _tick$[ebp]
	push	ecx
	mov	edx, DWORD PTR _seq$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getValue@?$KeyFrameArray@M@Ogre@@QAEXHIAAM_N@Z ; Ogre::KeyFrameArray<float>::getValue

; 101  : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?getValue@?$KeyFrameArray@M@Ogre@@UAEXHIPAX@Z ENDP	; Ogre::KeyFrameArray<float>::getValue
_TEXT	ENDS
PUBLIC	??A?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAEAAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@I@Z ; std::vector<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::operator[]
PUBLIC	?empty@?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QBE_NXZ ; std::vector<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::empty
PUBLIC	??$serializeRawArray@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@Archive@Ogre@@QAEAAV01@AAV?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@@Z ; Ogre::Archive::serializeRawArray<Ogre::KeyFrameArray<float>::CONTROL_POINT_T>
PUBLIC	??$serializeRawArray@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@Archive@Ogre@@QAEAAV01@AAV?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@@Z ; Ogre::Archive::serializeRawArray<Ogre::KeyFrameArray<float>::KEYFRAME_T>
PUBLIC	??$serializeRawType@W4InterpolType@Ogre@@@Archive@Ogre@@QAEXAAW4InterpolType@1@@Z ; Ogre::Archive::serializeRawType<enum Ogre::InterpolType>
; Function compile flags: /Odtp
;	COMDAT ?_serialize@?$KeyFrameArray@M@Ogre@@UAEXAAVArchive@2@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_ar$ = 8						; size = 4
_version$ = 12						; size = 4
?_serialize@?$KeyFrameArray@M@Ogre@@UAEXAAVArchive@2@H@Z PROC ; Ogre::KeyFrameArray<float>::_serialize, COMDAT
; _this$ = ecx

; 231  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 232  : 			ar.serializeRawType(m_Type);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 32					; 00000020H
	push	eax
	mov	ecx, DWORD PTR _ar$[ebp]
	call	??$serializeRawType@W4InterpolType@Ogre@@@Archive@Ogre@@QAEXAAW4InterpolType@1@@Z ; Ogre::Archive::serializeRawType<enum Ogre::InterpolType>

; 233  : 			ar.serializeRawArray(m_Array);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	push	ecx
	mov	ecx, DWORD PTR _ar$[ebp]
	call	??$serializeRawArray@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@Archive@Ogre@@QAEAAV01@AAV?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@@Z ; Ogre::Archive::serializeRawArray<Ogre::KeyFrameArray<float>::KEYFRAME_T>

; 234  : 			ar.serializeRawArray(m_CtrlPt);

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 60					; 0000003cH
	push	edx
	mov	ecx, DWORD PTR _ar$[ebp]
	call	??$serializeRawArray@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@Archive@Ogre@@QAEAAV01@AAV?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@@Z ; Ogre::Archive::serializeRawArray<Ogre::KeyFrameArray<float>::CONTROL_POINT_T>

; 235  : 
; 236  : 			if(!m_Array.empty() && int(m_Array[0].tick)<0)

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	?empty@?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QBE_NXZ ; std::vector<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::empty
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN1@serialize@2
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??A?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAEAAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@I@Z ; std::vector<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::operator[]
	cmp	DWORD PTR [eax], 0
	jge	SHORT $LN1@serialize@2

; 237  : 			{
; 238  : 				m_Array[0].tick = 0;

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??A?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAEAAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@I@Z ; std::vector<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::operator[]
	mov	DWORD PTR [eax], 0
$LN1@serialize@2:

; 239  : 			}
; 240  : 
; 241  : 			BaseKeyFrameArray::_serialize(ar, version);

	mov	ecx, DWORD PTR _version$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ar$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_serialize@BaseKeyFrameArray@Ogre@@UAEXAAVArchive@2@H@Z ; Ogre::BaseKeyFrameArray::_serialize

; 242  : 			m_nPrindex	 = -1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+84], -1

; 243  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?_serialize@?$KeyFrameArray@M@Ogre@@UAEXAAVArchive@2@H@Z ENDP ; Ogre::KeyFrameArray<float>::_serialize
_TEXT	ENDS
PUBLIC	??4?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::operator=
PUBLIC	??4?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::operator=
PUBLIC	??4?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::operator=
; Function compile flags: /Odtp
;	COMDAT ??4?$KeyFrameArray@M@Ogre@@QAEABV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_rhs$ = 8						; size = 4
??4?$KeyFrameArray@M@Ogre@@QAEABV01@ABV01@@Z PROC	; Ogre::KeyFrameArray<float>::operator=, COMDAT
; _this$ = ecx

; 246  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 247  : 			m_Type = rhs.m_Type;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _rhs$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	DWORD PTR [eax+32], edx

; 248  : 			m_Array = rhs.m_Array;

	mov	eax, DWORD PTR _rhs$[ebp]
	add	eax, 36					; 00000024H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??4?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::operator=

; 249  : 			m_Ranges = rhs.m_Ranges;

	mov	ecx, DWORD PTR _rhs$[ebp]
	add	ecx, 8
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??4?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::operator=

; 250  : 			m_CtrlPt = rhs.m_CtrlPt;

	mov	edx, DWORD PTR _rhs$[ebp]
	add	edx, 60					; 0000003cH
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 60					; 0000003cH
	call	??4?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::operator=

; 251  : 
; 252  : 			return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 253  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??4?$KeyFrameArray@M@Ogre@@QAEABV01@ABV01@@Z ENDP	; Ogre::KeyFrameArray<float>::operator=
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAE@XZ ; std::_Vector_val<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::~_Vector_val<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >
PUBLIC	?_Tidy@?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAEXXZ ; std::vector<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::_Tidy
PUBLIC	??$_Ucopy@V?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@@?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAEPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@1@0PAU234@@Z ; std::vector<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::_Ucopy<std::_Vector_const_iterator<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> > >
PUBLIC	?begin@?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@2@XZ ; std::vector<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::begin
PUBLIC	?end@?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@2@XZ ; std::vector<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::end
PUBLIC	?_Buy@?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAE_NI@Z ; std::vector<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::_Buy
PUBLIC	??0?$_Vector_val@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAE@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@1@@Z ; std::_Vector_val<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::_Vector_val<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >
PUBLIC	??0?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T>::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T>
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	SEGMENT
__catchsym$??0?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAE@ABV01@@Z$3 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??0?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAE@ABV01@@Z$0
__tryblocktable$??0?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAE@ABV01@@Z DD 01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??0?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAE@ABV01@@Z$3
__unwindtable$??0?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAE@ABV01@@Z$2
	DD	00H
	DD	00H
	DD	00H
	DD	00H
__ehfuncinfo$??0?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAE@ABV01@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAE@ABV01@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??0?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -40						; size = 4
$T94846 = -36						; size = 8
$T94845 = -28						; size = 8
$T94844 = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Right$ = 8						; size = 4
??0?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAE@ABV01@@Z PROC ; std::vector<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::vector<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >, COMDAT
; _this$ = ecx

; 500  : 		{	// construct by copying _Right

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 24					; 00000018H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Right$[ebp]
	add	eax, 8
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T94844[ebp], esp
	push	eax
	call	??0?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T>::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_val@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAE@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@1@@Z ; std::_Vector_val<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::_Vector_val<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >
	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 501  : 		if (_Buy(_Right.size()))

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::size
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAE_NI@Z ; std::vector<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::_Buy
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN3@vector@29

; 502  : 			_TRY_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 1

; 503  : 			_Mylast = _Ucopy(_Right.begin(), _Right.end(), _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	lea	ecx, DWORD PTR $T94845[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?end@?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@2@XZ ; std::vector<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::end
	mov	edx, DWORD PTR [eax+4]
	push	edx
	mov	eax, DWORD PTR [eax]
	push	eax
	lea	ecx, DWORD PTR $T94846[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?begin@?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@2@XZ ; std::vector<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::begin
	mov	edx, DWORD PTR [eax+4]
	push	edx
	mov	eax, DWORD PTR [eax]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Ucopy@V?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@@?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAEPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@1@0PAU234@@Z ; std::vector<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::_Ucopy<std::_Vector_const_iterator<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> > >
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax
	jmp	SHORT $LN5@vector@29
__catch$??0?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAE@ABV01@@Z$0:

; 504  : 			_CATCH_ALL
; 505  : 			_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAEXXZ ; std::vector<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::_Tidy

; 506  : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 507  : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], 0
	mov	eax, $LN3@vector@29
	ret	0
$LN5@vector@29:
	mov	DWORD PTR __$EHRec$[ebp+12], 0
$LN3@vector@29:

; 508  : 		}

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector@29:
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAE@ABV01@@Z$2:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAE@XZ
__ehhandler$??0?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-44]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::vector<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::vector<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAE@XZ PROC ; std::vector<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::~vector<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 559  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAEXXZ ; std::vector<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::_Tidy

; 560  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Vector_val@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAE@XZ
__ehhandler$??1?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAE@XZ ENDP ; std::vector<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::~vector<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >
PUBLIC	??1?$_Vector_val@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAE@XZ ; std::_Vector_val<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::~_Vector_val<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >
PUBLIC	?_Tidy@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAEXXZ ; std::vector<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::_Tidy
PUBLIC	??$_Ucopy@V?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAEPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@1@0PAU234@@Z ; std::vector<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::_Ucopy<std::_Vector_const_iterator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> > >
PUBLIC	?begin@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@2@XZ ; std::vector<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::begin
PUBLIC	?end@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@2@XZ ; std::vector<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::end
PUBLIC	?_Buy@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAE_NI@Z ; std::vector<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::_Buy
PUBLIC	?size@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::size
PUBLIC	??0?$_Vector_val@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAE@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@1@@Z ; std::_Vector_val<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::_Vector_val<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >
PUBLIC	??0?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T>::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T>
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??0?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAE@ABV01@@Z$3 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??0?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAE@ABV01@@Z$0
__tryblocktable$??0?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAE@ABV01@@Z DD 01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??0?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAE@ABV01@@Z$3
__unwindtable$??0?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAE@ABV01@@Z$2
	DD	00H
	DD	00H
	DD	00H
	DD	00H
__ehfuncinfo$??0?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAE@ABV01@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAE@ABV01@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??0?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -40						; size = 4
$T94874 = -36						; size = 8
$T94873 = -28						; size = 8
$T94872 = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Right$ = 8						; size = 4
??0?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAE@ABV01@@Z PROC ; std::vector<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::vector<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >, COMDAT
; _this$ = ecx

; 500  : 		{	// construct by copying _Right

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 24					; 00000018H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Right$[ebp]
	add	eax, 8
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T94872[ebp], esp
	push	eax
	call	??0?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T>::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_val@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAE@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@1@@Z ; std::_Vector_val<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::_Vector_val<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >
	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 501  : 		if (_Buy(_Right.size()))

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::size
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAE_NI@Z ; std::vector<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::_Buy
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN3@vector@30

; 502  : 			_TRY_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 1

; 503  : 			_Mylast = _Ucopy(_Right.begin(), _Right.end(), _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	lea	ecx, DWORD PTR $T94873[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?end@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@2@XZ ; std::vector<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::end
	mov	edx, DWORD PTR [eax+4]
	push	edx
	mov	eax, DWORD PTR [eax]
	push	eax
	lea	ecx, DWORD PTR $T94874[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?begin@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@2@XZ ; std::vector<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::begin
	mov	edx, DWORD PTR [eax+4]
	push	edx
	mov	eax, DWORD PTR [eax]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Ucopy@V?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAEPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@1@0PAU234@@Z ; std::vector<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::_Ucopy<std::_Vector_const_iterator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> > >
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax
	jmp	SHORT $LN5@vector@30
__catch$??0?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAE@ABV01@@Z$0:

; 504  : 			_CATCH_ALL
; 505  : 			_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAEXXZ ; std::vector<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::_Tidy

; 506  : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 507  : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], 0
	mov	eax, $LN3@vector@30
	ret	0
$LN5@vector@30:
	mov	DWORD PTR __$EHRec$[ebp+12], 0
$LN3@vector@30:

; 508  : 		}

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector@30:
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAE@ABV01@@Z$2:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAE@XZ
__ehhandler$??0?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-44]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::vector<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::vector<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAE@XZ PROC ; std::vector<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::~vector<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 559  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAEXXZ ; std::vector<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::_Tidy

; 560  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Vector_val@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAE@XZ
__ehhandler$??1?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAE@XZ ENDP ; std::vector<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::~vector<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >
PUBLIC	?size@?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::size
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogrekeyframearray.h
;	COMDAT ?getNumKey@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@UAEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getNumKey@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@UAEIXZ PROC ; Ogre::KeyFrameArray<Ogre::ColourValue>::getNumKey, COMDAT
; _this$ = ecx

; 94   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 95   : 			return m_Array.size();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	?size@?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::size

; 96   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?getNumKey@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@UAEIXZ ENDP ; Ogre::KeyFrameArray<Ogre::ColourValue>::getNumKey
_TEXT	ENDS
PUBLIC	?getValue@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@QAEXHIAAVColourValue@2@_N@Z ; Ogre::KeyFrameArray<Ogre::ColourValue>::getValue
; Function compile flags: /Odtp
;	COMDAT ?getValue@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@UAEXHIPAX@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_seq$ = 8						; size = 4
_tick$ = 12						; size = 4
_pdata$ = 16						; size = 4
?getValue@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@UAEXHIPAX@Z PROC ; Ogre::KeyFrameArray<Ogre::ColourValue>::getValue, COMDAT
; _this$ = ecx

; 99   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 100  : 			return getValue(seq, tick, *(POSTYPE *)pdata);

	push	1
	mov	eax, DWORD PTR _pdata$[ebp]
	push	eax
	mov	ecx, DWORD PTR _tick$[ebp]
	push	ecx
	mov	edx, DWORD PTR _seq$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getValue@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@QAEXHIAAVColourValue@2@_N@Z ; Ogre::KeyFrameArray<Ogre::ColourValue>::getValue

; 101  : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?getValue@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@UAEXHIPAX@Z ENDP ; Ogre::KeyFrameArray<Ogre::ColourValue>::getValue
_TEXT	ENDS
PUBLIC	??A?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAEAAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@I@Z ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::operator[]
PUBLIC	?empty@?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QBE_NXZ ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::empty
PUBLIC	??$serializeRawArray@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@Archive@Ogre@@QAEAAV01@AAV?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@@Z ; Ogre::Archive::serializeRawArray<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T>
PUBLIC	??$serializeRawArray@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@Archive@Ogre@@QAEAAV01@AAV?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@@Z ; Ogre::Archive::serializeRawArray<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T>
; Function compile flags: /Odtp
;	COMDAT ?_serialize@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@UAEXAAVArchive@2@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_ar$ = 8						; size = 4
_version$ = 12						; size = 4
?_serialize@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@UAEXAAVArchive@2@H@Z PROC ; Ogre::KeyFrameArray<Ogre::ColourValue>::_serialize, COMDAT
; _this$ = ecx

; 231  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 232  : 			ar.serializeRawType(m_Type);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 32					; 00000020H
	push	eax
	mov	ecx, DWORD PTR _ar$[ebp]
	call	??$serializeRawType@W4InterpolType@Ogre@@@Archive@Ogre@@QAEXAAW4InterpolType@1@@Z ; Ogre::Archive::serializeRawType<enum Ogre::InterpolType>

; 233  : 			ar.serializeRawArray(m_Array);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	push	ecx
	mov	ecx, DWORD PTR _ar$[ebp]
	call	??$serializeRawArray@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@Archive@Ogre@@QAEAAV01@AAV?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@@Z ; Ogre::Archive::serializeRawArray<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T>

; 234  : 			ar.serializeRawArray(m_CtrlPt);

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 60					; 0000003cH
	push	edx
	mov	ecx, DWORD PTR _ar$[ebp]
	call	??$serializeRawArray@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@Archive@Ogre@@QAEAAV01@AAV?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@@Z ; Ogre::Archive::serializeRawArray<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T>

; 235  : 
; 236  : 			if(!m_Array.empty() && int(m_Array[0].tick)<0)

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	?empty@?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QBE_NXZ ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::empty
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN1@serialize@3
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??A?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAEAAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@I@Z ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::operator[]
	cmp	DWORD PTR [eax], 0
	jge	SHORT $LN1@serialize@3

; 237  : 			{
; 238  : 				m_Array[0].tick = 0;

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??A?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAEAAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@I@Z ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::operator[]
	mov	DWORD PTR [eax], 0
$LN1@serialize@3:

; 239  : 			}
; 240  : 
; 241  : 			BaseKeyFrameArray::_serialize(ar, version);

	mov	ecx, DWORD PTR _version$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ar$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_serialize@BaseKeyFrameArray@Ogre@@UAEXAAVArchive@2@H@Z ; Ogre::BaseKeyFrameArray::_serialize

; 242  : 			m_nPrindex	 = -1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+84], -1

; 243  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?_serialize@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@UAEXAAVArchive@2@H@Z ENDP ; Ogre::KeyFrameArray<Ogre::ColourValue>::_serialize
_TEXT	ENDS
PUBLIC	??4?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::operator=
PUBLIC	??4?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::operator=
; Function compile flags: /Odtp
;	COMDAT ??4?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@QAEABV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_rhs$ = 8						; size = 4
??4?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@QAEABV01@ABV01@@Z PROC ; Ogre::KeyFrameArray<Ogre::ColourValue>::operator=, COMDAT
; _this$ = ecx

; 246  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 247  : 			m_Type = rhs.m_Type;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _rhs$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	DWORD PTR [eax+32], edx

; 248  : 			m_Array = rhs.m_Array;

	mov	eax, DWORD PTR _rhs$[ebp]
	add	eax, 36					; 00000024H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??4?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::operator=

; 249  : 			m_Ranges = rhs.m_Ranges;

	mov	ecx, DWORD PTR _rhs$[ebp]
	add	ecx, 8
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??4?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::operator=

; 250  : 			m_CtrlPt = rhs.m_CtrlPt;

	mov	edx, DWORD PTR _rhs$[ebp]
	add	edx, 60					; 0000003cH
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 60					; 0000003cH
	call	??4?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::operator=

; 251  : 
; 252  : 			return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 253  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??4?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@QAEABV01@ABV01@@Z ENDP ; Ogre::KeyFrameArray<Ogre::ColourValue>::operator=
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAE@XZ ; std::_Vector_val<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::~_Vector_val<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >
PUBLIC	?_Tidy@?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAEXXZ ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::_Tidy
PUBLIC	??$_Ucopy@V?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@@?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAEPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@1@0PAU234@@Z ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::_Ucopy<std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> > >
PUBLIC	?begin@?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@2@XZ ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::begin
PUBLIC	?end@?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@2@XZ ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::end
PUBLIC	?_Buy@?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAE_NI@Z ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::_Buy
PUBLIC	??0?$_Vector_val@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAE@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@1@@Z ; std::_Vector_val<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::_Vector_val<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >
PUBLIC	??0?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T>::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T>
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	SEGMENT
__catchsym$??0?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAE@ABV01@@Z$3 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??0?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAE@ABV01@@Z$0
__tryblocktable$??0?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAE@ABV01@@Z DD 01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??0?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAE@ABV01@@Z$3
__unwindtable$??0?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAE@ABV01@@Z$2
	DD	00H
	DD	00H
	DD	00H
	DD	00H
__ehfuncinfo$??0?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAE@ABV01@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAE@ABV01@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??0?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -40						; size = 4
$T94910 = -36						; size = 8
$T94909 = -28						; size = 8
$T94908 = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Right$ = 8						; size = 4
??0?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAE@ABV01@@Z PROC ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >, COMDAT
; _this$ = ecx

; 500  : 		{	// construct by copying _Right

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 24					; 00000018H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Right$[ebp]
	add	eax, 8
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T94908[ebp], esp
	push	eax
	call	??0?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T>::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_val@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAE@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@1@@Z ; std::_Vector_val<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::_Vector_val<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >
	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 501  : 		if (_Buy(_Right.size()))

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::size
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAE_NI@Z ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::_Buy
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN3@vector@31

; 502  : 			_TRY_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 1

; 503  : 			_Mylast = _Ucopy(_Right.begin(), _Right.end(), _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	lea	ecx, DWORD PTR $T94909[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?end@?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@2@XZ ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::end
	mov	edx, DWORD PTR [eax+4]
	push	edx
	mov	eax, DWORD PTR [eax]
	push	eax
	lea	ecx, DWORD PTR $T94910[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?begin@?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@2@XZ ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::begin
	mov	edx, DWORD PTR [eax+4]
	push	edx
	mov	eax, DWORD PTR [eax]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Ucopy@V?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@@?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAEPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@1@0PAU234@@Z ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::_Ucopy<std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> > >
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax
	jmp	SHORT $LN5@vector@31
__catch$??0?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAE@ABV01@@Z$0:

; 504  : 			_CATCH_ALL
; 505  : 			_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAEXXZ ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::_Tidy

; 506  : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 507  : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], 0
	mov	eax, $LN3@vector@31
	ret	0
$LN5@vector@31:
	mov	DWORD PTR __$EHRec$[ebp+12], 0
$LN3@vector@31:

; 508  : 		}

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector@31:
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAE@ABV01@@Z$2:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAE@XZ
__ehhandler$??0?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-44]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAE@XZ PROC ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::~vector<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 559  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAEXXZ ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::_Tidy

; 560  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Vector_val@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAE@XZ
__ehhandler$??1?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAE@XZ ENDP ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::~vector<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >
PUBLIC	??1?$_Vector_val@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAE@XZ ; std::_Vector_val<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::~_Vector_val<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >
PUBLIC	?_Tidy@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAEXXZ ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::_Tidy
PUBLIC	??$_Ucopy@V?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAEPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@1@0PAU234@@Z ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::_Ucopy<std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> > >
PUBLIC	?begin@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@2@XZ ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::begin
PUBLIC	?end@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@2@XZ ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::end
PUBLIC	?_Buy@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAE_NI@Z ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::_Buy
PUBLIC	?size@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::size
PUBLIC	??0?$_Vector_val@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAE@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@1@@Z ; std::_Vector_val<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::_Vector_val<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >
PUBLIC	??0?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T>::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T>
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??0?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAE@ABV01@@Z$3 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??0?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAE@ABV01@@Z$0
__tryblocktable$??0?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAE@ABV01@@Z DD 01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??0?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAE@ABV01@@Z$3
__unwindtable$??0?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAE@ABV01@@Z$2
	DD	00H
	DD	00H
	DD	00H
	DD	00H
__ehfuncinfo$??0?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAE@ABV01@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAE@ABV01@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??0?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -40						; size = 4
$T94938 = -36						; size = 8
$T94937 = -28						; size = 8
$T94936 = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Right$ = 8						; size = 4
??0?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAE@ABV01@@Z PROC ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >, COMDAT
; _this$ = ecx

; 500  : 		{	// construct by copying _Right

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 24					; 00000018H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Right$[ebp]
	add	eax, 8
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T94936[ebp], esp
	push	eax
	call	??0?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T>::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_val@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAE@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@1@@Z ; std::_Vector_val<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::_Vector_val<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >
	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 501  : 		if (_Buy(_Right.size()))

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::size
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAE_NI@Z ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::_Buy
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN3@vector@32

; 502  : 			_TRY_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 1

; 503  : 			_Mylast = _Ucopy(_Right.begin(), _Right.end(), _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	lea	ecx, DWORD PTR $T94937[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?end@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@2@XZ ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::end
	mov	edx, DWORD PTR [eax+4]
	push	edx
	mov	eax, DWORD PTR [eax]
	push	eax
	lea	ecx, DWORD PTR $T94938[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?begin@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@2@XZ ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::begin
	mov	edx, DWORD PTR [eax+4]
	push	edx
	mov	eax, DWORD PTR [eax]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Ucopy@V?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAEPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@1@0PAU234@@Z ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::_Ucopy<std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> > >
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax
	jmp	SHORT $LN5@vector@32
__catch$??0?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAE@ABV01@@Z$0:

; 504  : 			_CATCH_ALL
; 505  : 			_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAEXXZ ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::_Tidy

; 506  : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 507  : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], 0
	mov	eax, $LN3@vector@32
	ret	0
$LN5@vector@32:
	mov	DWORD PTR __$EHRec$[ebp+12], 0
$LN3@vector@32:

; 508  : 		}

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector@32:
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAE@ABV01@@Z$2:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAE@XZ
__ehhandler$??0?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-44]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAE@XZ PROC ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::~vector<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 559  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAEXXZ ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::_Tidy

; 560  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Vector_val@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAE@XZ
__ehhandler$??1?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAE@XZ ENDP ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::~vector<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >
; Function compile flags: /Odtp
;	COMDAT ?size@?$vector@VVertexElement@Ogre@@V?$allocator@VVertexElement@Ogre@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$vector@VVertexElement@Ogre@@V?$allocator@VVertexElement@Ogre@@@std@@@std@@QBEIXZ PROC ; std::vector<Ogre::VertexElement,std::allocator<Ogre::VertexElement> >::size, COMDAT
; _this$ = ecx

; 725  : 		{	// return length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+16]
	sub	eax, DWORD PTR [ecx+12]
	sar	eax, 2

; 727  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?size@?$vector@VVertexElement@Ogre@@V?$allocator@VVertexElement@Ogre@@@std@@@std@@QBEIXZ ENDP ; std::vector<Ogre::VertexElement,std::allocator<Ogre::VertexElement> >::size
_TEXT	ENDS
EXTRN	__imp___invalid_parameter_noinfo:PROC
; Function compile flags: /Odtp
;	COMDAT ??A?$vector@VVertexElement@Ogre@@V?$allocator@VVertexElement@Ogre@@@std@@@std@@QBEABVVertexElement@Ogre@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pos$ = 8						; size = 4
??A?$vector@VVertexElement@Ogre@@V?$allocator@VVertexElement@Ogre@@@std@@@std@@QBEABVVertexElement@Ogre@@I@Z PROC ; std::vector<Ogre::VertexElement,std::allocator<Ogre::VertexElement> >::operator[], COMDAT
; _this$ = ecx

; 759  : 		{	// subscript nonmutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 760  : 
; 761  :  #if _HAS_ITERATOR_DEBUGGING
; 762  : 		if (size() <= _Pos)
; 763  : 			{
; 764  : 			_DEBUG_ERROR("vector subscript out of range");
; 765  : 			_SCL_SECURE_OUT_OF_RANGE;
; 766  : 			}
; 767  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 768  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@VVertexElement@Ogre@@V?$allocator@VVertexElement@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::VertexElement,std::allocator<Ogre::VertexElement> >::size
	cmp	DWORD PTR __Pos$[ebp], eax
	jb	SHORT $LN1@operator@14
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN1@operator@14:

; 769  : 
; 770  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR __Pos$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]

; 771  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??A?$vector@VVertexElement@Ogre@@V?$allocator@VVertexElement@Ogre@@@std@@@std@@QBEABVVertexElement@Ogre@@I@Z ENDP ; std::vector<Ogre::VertexElement,std::allocator<Ogre::VertexElement> >::operator[]
_TEXT	ENDS
PUBLIC	??0?$Singleton@VRenderSystem@Ogre@@@Ogre@@QAE@XZ ; Ogre::Singleton<Ogre::RenderSystem>::Singleton<Ogre::RenderSystem>
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogresingleton.h
;	COMDAT ??0?$Singleton@VRenderSystem@Ogre@@@Ogre@@QAE@XZ
_TEXT	SEGMENT
tv68 = -8						; size = 4
_this$ = -4						; size = 4
??0?$Singleton@VRenderSystem@Ogre@@@Ogre@@QAE@XZ PROC	; Ogre::Singleton<Ogre::RenderSystem>::Singleton<Ogre::RenderSystem>, COMDAT
; _this$ = ecx

; 64   : 		Singleton( void )

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 65   : 		{
; 66   : 			assert( !ms_Singleton );
; 67   : #if defined( _MSC_VER ) && _MSC_VER < 1200	 
; 68   : 			int offset = (int)(T*)1 - (int)(Singleton <T>*)(T*)1;
; 69   : 			ms_Singleton = (T*)((int)this + offset);
; 70   : #else
; 71   : 			ms_Singleton = static_cast< T* >( this );

	cmp	DWORD PTR _this$[ebp], 0
	je	SHORT $LN3@Singleton
	mov	eax, DWORD PTR _this$[ebp]
	sub	eax, 4
	mov	DWORD PTR tv68[ebp], eax
	jmp	SHORT $LN4@Singleton
$LN3@Singleton:
	mov	DWORD PTR tv68[ebp], 0
$LN4@Singleton:
	mov	ecx, DWORD PTR tv68[ebp]
	mov	DWORD PTR ?ms_Singleton@?$Singleton@VRenderSystem@Ogre@@@Ogre@@1PAVRenderSystem@2@A, ecx ; Ogre::Singleton<Ogre::RenderSystem>::ms_Singleton

; 72   : #endif
; 73   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$Singleton@VRenderSystem@Ogre@@@Ogre@@QAE@XZ ENDP	; Ogre::Singleton<Ogre::RenderSystem>::Singleton<Ogre::RenderSystem>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??1?$Singleton@VRenderSystem@Ogre@@@Ogre@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$Singleton@VRenderSystem@Ogre@@@Ogre@@QAE@XZ PROC	; Ogre::Singleton<Ogre::RenderSystem>::~Singleton<Ogre::RenderSystem>, COMDAT
; _this$ = ecx

; 75   : 		{  assert( ms_Singleton );  ms_Singleton = 0;  }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR ?ms_Singleton@?$Singleton@VRenderSystem@Ogre@@@Ogre@@1PAVRenderSystem@2@A, 0 ; Ogre::Singleton<Ogre::RenderSystem>::ms_Singleton
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$Singleton@VRenderSystem@Ogre@@@Ogre@@QAE@XZ ENDP	; Ogre::Singleton<Ogre::RenderSystem>::~Singleton<Ogre::RenderSystem>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?getSingleton@?$Singleton@VRenderSystem@Ogre@@@Ogre@@SAAAVRenderSystem@2@XZ
_TEXT	SEGMENT
?getSingleton@?$Singleton@VRenderSystem@Ogre@@@Ogre@@SAAAVRenderSystem@2@XZ PROC ; Ogre::Singleton<Ogre::RenderSystem>::getSingleton, COMDAT

; 77   : 		{	assert( ms_Singleton );  return ( *ms_Singleton ); }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR ?ms_Singleton@?$Singleton@VRenderSystem@Ogre@@@Ogre@@1PAVRenderSystem@2@A ; Ogre::Singleton<Ogre::RenderSystem>::ms_Singleton
	pop	ebp
	ret	0
?getSingleton@?$Singleton@VRenderSystem@Ogre@@@Ogre@@SAAAVRenderSystem@2@XZ ENDP ; Ogre::Singleton<Ogre::RenderSystem>::getSingleton
_TEXT	ENDS
PUBLIC	?getSingletonPtr@?$Singleton@VRenderSystem@Ogre@@@Ogre@@SAPAVRenderSystem@2@XZ ; Ogre::Singleton<Ogre::RenderSystem>::getSingletonPtr
; Function compile flags: /Odtp
;	COMDAT ?getSingletonPtr@?$Singleton@VRenderSystem@Ogre@@@Ogre@@SAPAVRenderSystem@2@XZ
_TEXT	SEGMENT
?getSingletonPtr@?$Singleton@VRenderSystem@Ogre@@@Ogre@@SAPAVRenderSystem@2@XZ PROC ; Ogre::Singleton<Ogre::RenderSystem>::getSingletonPtr, COMDAT

; 79   : 		{ return ms_Singleton; }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR ?ms_Singleton@?$Singleton@VRenderSystem@Ogre@@@Ogre@@1PAVRenderSystem@2@A ; Ogre::Singleton<Ogre::RenderSystem>::ms_Singleton
	pop	ebp
	ret	0
?getSingletonPtr@?$Singleton@VRenderSystem@Ogre@@@Ogre@@SAPAVRenderSystem@2@XZ ENDP ; Ogre::Singleton<Ogre::RenderSystem>::getSingletonPtr
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@QAE@XZ ; std::_Vector_val<Ogre::ShaderContext *,std::allocator<Ogre::ShaderContext *> >::~_Vector_val<Ogre::ShaderContext *,std::allocator<Ogre::ShaderContext *> >
PUBLIC	?_Tidy@?$vector@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@IAEXXZ ; std::vector<Ogre::ShaderContext *,std::allocator<Ogre::ShaderContext *> >::_Tidy
PUBLIC	??$_Ucopy@V?$_Vector_const_iterator@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@@?$vector@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@IAEPAPAVShaderContext@Ogre@@V?$_Vector_const_iterator@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@1@0PAPAV23@@Z ; std::vector<Ogre::ShaderContext *,std::allocator<Ogre::ShaderContext *> >::_Ucopy<std::_Vector_const_iterator<Ogre::ShaderContext *,std::allocator<Ogre::ShaderContext *> > >
PUBLIC	?begin@?$vector@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@2@XZ ; std::vector<Ogre::ShaderContext *,std::allocator<Ogre::ShaderContext *> >::begin
PUBLIC	?end@?$vector@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@2@XZ ; std::vector<Ogre::ShaderContext *,std::allocator<Ogre::ShaderContext *> >::end
PUBLIC	?_Buy@?$vector@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@IAE_NI@Z ; std::vector<Ogre::ShaderContext *,std::allocator<Ogre::ShaderContext *> >::_Buy
PUBLIC	?size@?$vector@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::ShaderContext *,std::allocator<Ogre::ShaderContext *> >::size
PUBLIC	??0?$_Vector_val@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@IAE@V?$allocator@PAVShaderContext@Ogre@@@1@@Z ; std::_Vector_val<Ogre::ShaderContext *,std::allocator<Ogre::ShaderContext *> >::_Vector_val<Ogre::ShaderContext *,std::allocator<Ogre::ShaderContext *> >
PUBLIC	??0?$allocator@PAVShaderContext@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::ShaderContext *>::allocator<Ogre::ShaderContext *>
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	SEGMENT
__catchsym$??0?$vector@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@QAE@ABV01@@Z$3 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??0?$vector@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@QAE@ABV01@@Z$0
__tryblocktable$??0?$vector@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@QAE@ABV01@@Z DD 01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??0?$vector@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@QAE@ABV01@@Z$3
__unwindtable$??0?$vector@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@QAE@ABV01@@Z$2
	DD	00H
	DD	00H
	DD	00H
	DD	00H
__ehfuncinfo$??0?$vector@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@QAE@ABV01@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0?$vector@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@QAE@ABV01@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??0?$vector@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$vector@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -40						; size = 4
$T94980 = -36						; size = 8
$T94979 = -28						; size = 8
$T94978 = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Right$ = 8						; size = 4
??0?$vector@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@QAE@ABV01@@Z PROC ; std::vector<Ogre::ShaderContext *,std::allocator<Ogre::ShaderContext *> >::vector<Ogre::ShaderContext *,std::allocator<Ogre::ShaderContext *> >, COMDAT
; _this$ = ecx

; 500  : 		{	// construct by copying _Right

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$vector@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 24					; 00000018H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Right$[ebp]
	add	eax, 8
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T94978[ebp], esp
	push	eax
	call	??0?$allocator@PAVShaderContext@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::ShaderContext *>::allocator<Ogre::ShaderContext *>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_val@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@IAE@V?$allocator@PAVShaderContext@Ogre@@@1@@Z ; std::_Vector_val<Ogre::ShaderContext *,std::allocator<Ogre::ShaderContext *> >::_Vector_val<Ogre::ShaderContext *,std::allocator<Ogre::ShaderContext *> >
	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 501  : 		if (_Buy(_Right.size()))

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::ShaderContext *,std::allocator<Ogre::ShaderContext *> >::size
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@IAE_NI@Z ; std::vector<Ogre::ShaderContext *,std::allocator<Ogre::ShaderContext *> >::_Buy
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN3@vector@33

; 502  : 			_TRY_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 1

; 503  : 			_Mylast = _Ucopy(_Right.begin(), _Right.end(), _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	lea	ecx, DWORD PTR $T94979[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?end@?$vector@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@2@XZ ; std::vector<Ogre::ShaderContext *,std::allocator<Ogre::ShaderContext *> >::end
	mov	edx, DWORD PTR [eax+4]
	push	edx
	mov	eax, DWORD PTR [eax]
	push	eax
	lea	ecx, DWORD PTR $T94980[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?begin@?$vector@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@2@XZ ; std::vector<Ogre::ShaderContext *,std::allocator<Ogre::ShaderContext *> >::begin
	mov	edx, DWORD PTR [eax+4]
	push	edx
	mov	eax, DWORD PTR [eax]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Ucopy@V?$_Vector_const_iterator@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@@?$vector@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@IAEPAPAVShaderContext@Ogre@@V?$_Vector_const_iterator@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@1@0PAPAV23@@Z ; std::vector<Ogre::ShaderContext *,std::allocator<Ogre::ShaderContext *> >::_Ucopy<std::_Vector_const_iterator<Ogre::ShaderContext *,std::allocator<Ogre::ShaderContext *> > >
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax
	jmp	SHORT $LN5@vector@33
__catch$??0?$vector@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@QAE@ABV01@@Z$0:

; 504  : 			_CATCH_ALL
; 505  : 			_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@IAEXXZ ; std::vector<Ogre::ShaderContext *,std::allocator<Ogre::ShaderContext *> >::_Tidy

; 506  : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 507  : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], 0
	mov	eax, $LN3@vector@33
	ret	0
$LN5@vector@33:
	mov	DWORD PTR __$EHRec$[ebp+12], 0
$LN3@vector@33:

; 508  : 		}

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector@33:
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@QAE@ABV01@@Z$2:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@QAE@XZ
__ehhandler$??0?$vector@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-44]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::vector<Ogre::ShaderContext *,std::allocator<Ogre::ShaderContext *> >::vector<Ogre::ShaderContext *,std::allocator<Ogre::ShaderContext *> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$vector@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$vector@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$vector@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$vector@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$vector@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$vector@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@QAE@XZ PROC ; std::vector<Ogre::ShaderContext *,std::allocator<Ogre::ShaderContext *> >::~vector<Ogre::ShaderContext *,std::allocator<Ogre::ShaderContext *> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$vector@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 559  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@IAEXXZ ; std::vector<Ogre::ShaderContext *,std::allocator<Ogre::ShaderContext *> >::_Tidy

; 560  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Vector_val@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$vector@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@QAE@XZ
__ehhandler$??1?$vector@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$vector@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$vector@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@QAE@XZ ENDP ; std::vector<Ogre::ShaderContext *,std::allocator<Ogre::ShaderContext *> >::~vector<Ogre::ShaderContext *,std::allocator<Ogre::ShaderContext *> >
PUBLIC	?deallocate@?$allocator@PAVShaderContext@Ogre@@@std@@QAEXPAPAVShaderContext@Ogre@@I@Z ; std::allocator<Ogre::ShaderContext *>::deallocate
PUBLIC	??$_Ucopy@PAPAVShaderContext@Ogre@@@?$vector@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@IAEPAPAVShaderContext@Ogre@@PAPAV23@00@Z ; std::vector<Ogre::ShaderContext *,std::allocator<Ogre::ShaderContext *> >::_Ucopy<Ogre::ShaderContext * *>
PUBLIC	?capacity@?$vector@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::ShaderContext *,std::allocator<Ogre::ShaderContext *> >::capacity
PUBLIC	?_Destroy@?$vector@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@IAEXPAPAVShaderContext@Ogre@@0@Z ; std::vector<Ogre::ShaderContext *,std::allocator<Ogre::ShaderContext *> >::_Destroy
PUBLIC	??$unchecked_copy@PAPAVShaderContext@Ogre@@PAPAV12@@stdext@@YAPAPAVShaderContext@Ogre@@PAPAV12@00@Z ; stdext::unchecked_copy<Ogre::ShaderContext * *,Ogre::ShaderContext * *>
PUBLIC	?clear@?$vector@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@QAEXXZ ; std::vector<Ogre::ShaderContext *,std::allocator<Ogre::ShaderContext *> >::clear
; Function compile flags: /Odtp
;	COMDAT ??4?$vector@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
__Ptr$72389 = -8					; size = 4
__Ptr$72379 = -4					; size = 4
__Right$ = 8						; size = 4
??4?$vector@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z PROC ; std::vector<Ogre::ShaderContext *,std::allocator<Ogre::ShaderContext *> >::operator=, COMDAT
; _this$ = ecx

; 563  : 		{	// assign _Right

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 564  : 		if (this != &_Right)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR __Right$[ebp]
	je	$LN9@operator@15

; 565  : 			{	// worth doing
; 566  : 
; 567  :  #if _HAS_ITERATOR_DEBUGGING
; 568  : 			this->_Orphan_all();
; 569  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 570  : 
; 571  : 			if (_Right.size() == 0)

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::ShaderContext *,std::allocator<Ogre::ShaderContext *> >::size
	test	eax, eax
	jne	SHORT $LN8@operator@15

; 572  : 				clear();	// new sequence empty, erase existing sequence

	mov	ecx, DWORD PTR _this$[ebp]
	call	?clear@?$vector@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@QAEXXZ ; std::vector<Ogre::ShaderContext *,std::allocator<Ogre::ShaderContext *> >::clear
	jmp	$LN9@operator@15
$LN8@operator@15:

; 573  : 			else if (_Right.size() <= size())

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::ShaderContext *,std::allocator<Ogre::ShaderContext *> >::size
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::ShaderContext *,std::allocator<Ogre::ShaderContext *> >::size
	cmp	esi, eax
	ja	SHORT $LN6@operator@15

; 574  : 				{	// enough elements, copy new and destroy old
; 575  : 				pointer _Ptr = _STDEXT unchecked_copy(_Right._Myfirst, _Right._Mylast,
; 576  : 					_Myfirst);	// copy new

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	call	??$unchecked_copy@PAPAVShaderContext@Ogre@@PAPAV12@@stdext@@YAPAPAVShaderContext@Ogre@@PAPAV12@00@Z ; stdext::unchecked_copy<Ogre::ShaderContext * *,Ogre::ShaderContext * *>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR __Ptr$72379[ebp], eax

; 577  : 				_Destroy(_Ptr, _Mylast);	// destroy old

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR __Ptr$72379[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@IAEXPAPAVShaderContext@Ogre@@0@Z ; std::vector<Ogre::ShaderContext *,std::allocator<Ogre::ShaderContext *> >::_Destroy

; 578  : 				_Mylast = _Myfirst + _Right.size();

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::ShaderContext *,std::allocator<Ogre::ShaderContext *> >::size
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	lea	eax, DWORD PTR [edx+eax*4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax
	jmp	$LN9@operator@15
$LN6@operator@15:

; 579  : 				}
; 580  : 			else if (_Right.size() <= capacity())

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::ShaderContext *,std::allocator<Ogre::ShaderContext *> >::size
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?capacity@?$vector@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::ShaderContext *,std::allocator<Ogre::ShaderContext *> >::capacity
	cmp	esi, eax
	ja	SHORT $LN4@operator@15

; 581  : 				{	// enough room, copy and construct new
; 582  : 				pointer _Ptr = _Right._Myfirst + size();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::ShaderContext *,std::allocator<Ogre::ShaderContext *> >::size
	mov	edx, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR __Ptr$72389[ebp], edx

; 583  : 				_STDEXT unchecked_copy(_Right._Myfirst, _Ptr, _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	edx, DWORD PTR __Ptr$72389[ebp]
	push	edx
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	call	??$unchecked_copy@PAPAVShaderContext@Ogre@@PAPAV12@@stdext@@YAPAPAVShaderContext@Ogre@@PAPAV12@00@Z ; stdext::unchecked_copy<Ogre::ShaderContext * *,Ogre::ShaderContext * *>
	add	esp, 12					; 0000000cH

; 584  : 				_Mylast = _Ucopy(_Ptr, _Right._Mylast, _Mylast);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR __Ptr$72389[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Ucopy@PAPAVShaderContext@Ogre@@@?$vector@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@IAEPAPAVShaderContext@Ogre@@PAPAV23@00@Z ; std::vector<Ogre::ShaderContext *,std::allocator<Ogre::ShaderContext *> >::_Ucopy<Ogre::ShaderContext * *>
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 585  : 				}
; 586  : 			else

	jmp	SHORT $LN9@operator@15
$LN4@operator@15:

; 587  : 				{	// not enough room, allocate new array and construct new
; 588  : 				if (_Myfirst != 0)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+12], 0
	je	SHORT $LN2@operator@15

; 589  : 					{	// discard old array
; 590  : 					_Destroy(_Myfirst, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@IAEXPAPAVShaderContext@Ogre@@0@Z ; std::vector<Ogre::ShaderContext *,std::allocator<Ogre::ShaderContext *> >::_Destroy

; 591  : 					this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+20]
	sub	eax, DWORD PTR [edx+12]
	sar	eax, 2
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?deallocate@?$allocator@PAVShaderContext@Ogre@@@std@@QAEXPAPAVShaderContext@Ogre@@I@Z ; std::allocator<Ogre::ShaderContext *>::deallocate
$LN2@operator@15:

; 592  : 					}
; 593  : 				if (_Buy(_Right.size()))

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::ShaderContext *,std::allocator<Ogre::ShaderContext *> >::size
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@IAE_NI@Z ; std::vector<Ogre::ShaderContext *,std::allocator<Ogre::ShaderContext *> >::_Buy
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN9@operator@15

; 594  : 					_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 595  : 						_Myfirst);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Ucopy@PAPAVShaderContext@Ogre@@@?$vector@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@IAEPAPAVShaderContext@Ogre@@PAPAV23@00@Z ; std::vector<Ogre::ShaderContext *,std::allocator<Ogre::ShaderContext *> >::_Ucopy<Ogre::ShaderContext * *>
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax
$LN9@operator@15:

; 596  : 				}
; 597  : 			}
; 598  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 599  : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
??4?$vector@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z ENDP ; std::vector<Ogre::ShaderContext *,std::allocator<Ogre::ShaderContext *> >::operator=
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??A?$vector@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@QAEAAPAVShaderContext@Ogre@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pos$ = 8						; size = 4
??A?$vector@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@QAEAAPAVShaderContext@Ogre@@I@Z PROC ; std::vector<Ogre::ShaderContext *,std::allocator<Ogre::ShaderContext *> >::operator[], COMDAT
; _this$ = ecx

; 774  : 		{	// subscript mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)
; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");
; 780  : 			_SCL_SECURE_OUT_OF_RANGE;
; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::ShaderContext *,std::allocator<Ogre::ShaderContext *> >::size
	cmp	DWORD PTR __Pos$[ebp], eax
	jb	SHORT $LN1@operator@16
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN1@operator@16:

; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR __Pos$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]

; 786  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??A?$vector@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@QAEAAPAVShaderContext@Ogre@@I@Z ENDP ; std::vector<Ogre::ShaderContext *,std::allocator<Ogre::ShaderContext *> >::operator[]
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@QAE@XZ ; std::_Vector_val<Ogre::ContextQueDesc,std::allocator<Ogre::ContextQueDesc> >::~_Vector_val<Ogre::ContextQueDesc,std::allocator<Ogre::ContextQueDesc> >
PUBLIC	?_Tidy@?$vector@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@IAEXXZ ; std::vector<Ogre::ContextQueDesc,std::allocator<Ogre::ContextQueDesc> >::_Tidy
PUBLIC	??$_Ucopy@V?$_Vector_const_iterator@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@@?$vector@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@IAEPAUContextQueDesc@Ogre@@V?$_Vector_const_iterator@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@1@0PAU23@@Z ; std::vector<Ogre::ContextQueDesc,std::allocator<Ogre::ContextQueDesc> >::_Ucopy<std::_Vector_const_iterator<Ogre::ContextQueDesc,std::allocator<Ogre::ContextQueDesc> > >
PUBLIC	?begin@?$vector@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@2@XZ ; std::vector<Ogre::ContextQueDesc,std::allocator<Ogre::ContextQueDesc> >::begin
PUBLIC	?end@?$vector@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@2@XZ ; std::vector<Ogre::ContextQueDesc,std::allocator<Ogre::ContextQueDesc> >::end
PUBLIC	?_Buy@?$vector@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@IAE_NI@Z ; std::vector<Ogre::ContextQueDesc,std::allocator<Ogre::ContextQueDesc> >::_Buy
PUBLIC	?size@?$vector@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::ContextQueDesc,std::allocator<Ogre::ContextQueDesc> >::size
PUBLIC	??0?$_Vector_val@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@IAE@V?$allocator@UContextQueDesc@Ogre@@@1@@Z ; std::_Vector_val<Ogre::ContextQueDesc,std::allocator<Ogre::ContextQueDesc> >::_Vector_val<Ogre::ContextQueDesc,std::allocator<Ogre::ContextQueDesc> >
PUBLIC	??0?$allocator@UContextQueDesc@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::ContextQueDesc>::allocator<Ogre::ContextQueDesc>
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??0?$vector@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@QAE@ABV01@@Z$3 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??0?$vector@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@QAE@ABV01@@Z$0
__tryblocktable$??0?$vector@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@QAE@ABV01@@Z DD 01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??0?$vector@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@QAE@ABV01@@Z$3
__unwindtable$??0?$vector@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@QAE@ABV01@@Z$2
	DD	00H
	DD	00H
	DD	00H
	DD	00H
__ehfuncinfo$??0?$vector@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@QAE@ABV01@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0?$vector@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@QAE@ABV01@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??0?$vector@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$vector@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -40						; size = 4
$T95012 = -36						; size = 8
$T95011 = -28						; size = 8
$T95010 = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Right$ = 8						; size = 4
??0?$vector@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@QAE@ABV01@@Z PROC ; std::vector<Ogre::ContextQueDesc,std::allocator<Ogre::ContextQueDesc> >::vector<Ogre::ContextQueDesc,std::allocator<Ogre::ContextQueDesc> >, COMDAT
; _this$ = ecx

; 500  : 		{	// construct by copying _Right

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$vector@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 24					; 00000018H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Right$[ebp]
	add	eax, 8
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T95010[ebp], esp
	push	eax
	call	??0?$allocator@UContextQueDesc@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::ContextQueDesc>::allocator<Ogre::ContextQueDesc>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_val@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@IAE@V?$allocator@UContextQueDesc@Ogre@@@1@@Z ; std::_Vector_val<Ogre::ContextQueDesc,std::allocator<Ogre::ContextQueDesc> >::_Vector_val<Ogre::ContextQueDesc,std::allocator<Ogre::ContextQueDesc> >
	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 501  : 		if (_Buy(_Right.size()))

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::ContextQueDesc,std::allocator<Ogre::ContextQueDesc> >::size
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@IAE_NI@Z ; std::vector<Ogre::ContextQueDesc,std::allocator<Ogre::ContextQueDesc> >::_Buy
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN3@vector@34

; 502  : 			_TRY_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 1

; 503  : 			_Mylast = _Ucopy(_Right.begin(), _Right.end(), _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	lea	ecx, DWORD PTR $T95011[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?end@?$vector@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@2@XZ ; std::vector<Ogre::ContextQueDesc,std::allocator<Ogre::ContextQueDesc> >::end
	mov	edx, DWORD PTR [eax+4]
	push	edx
	mov	eax, DWORD PTR [eax]
	push	eax
	lea	ecx, DWORD PTR $T95012[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?begin@?$vector@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@2@XZ ; std::vector<Ogre::ContextQueDesc,std::allocator<Ogre::ContextQueDesc> >::begin
	mov	edx, DWORD PTR [eax+4]
	push	edx
	mov	eax, DWORD PTR [eax]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Ucopy@V?$_Vector_const_iterator@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@@?$vector@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@IAEPAUContextQueDesc@Ogre@@V?$_Vector_const_iterator@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@1@0PAU23@@Z ; std::vector<Ogre::ContextQueDesc,std::allocator<Ogre::ContextQueDesc> >::_Ucopy<std::_Vector_const_iterator<Ogre::ContextQueDesc,std::allocator<Ogre::ContextQueDesc> > >
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax
	jmp	SHORT $LN5@vector@34
__catch$??0?$vector@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@QAE@ABV01@@Z$0:

; 504  : 			_CATCH_ALL
; 505  : 			_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@IAEXXZ ; std::vector<Ogre::ContextQueDesc,std::allocator<Ogre::ContextQueDesc> >::_Tidy

; 506  : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 507  : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], 0
	mov	eax, $LN3@vector@34
	ret	0
$LN5@vector@34:
	mov	DWORD PTR __$EHRec$[ebp+12], 0
$LN3@vector@34:

; 508  : 		}

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector@34:
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@QAE@ABV01@@Z$2:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@QAE@XZ
__ehhandler$??0?$vector@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-44]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::vector<Ogre::ContextQueDesc,std::allocator<Ogre::ContextQueDesc> >::vector<Ogre::ContextQueDesc,std::allocator<Ogre::ContextQueDesc> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$vector@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$vector@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$vector@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$vector@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$vector@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$vector@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@QAE@XZ PROC ; std::vector<Ogre::ContextQueDesc,std::allocator<Ogre::ContextQueDesc> >::~vector<Ogre::ContextQueDesc,std::allocator<Ogre::ContextQueDesc> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$vector@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 559  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@IAEXXZ ; std::vector<Ogre::ContextQueDesc,std::allocator<Ogre::ContextQueDesc> >::_Tidy

; 560  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Vector_val@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$vector@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@QAE@XZ
__ehhandler$??1?$vector@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$vector@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$vector@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@QAE@XZ ENDP ; std::vector<Ogre::ContextQueDesc,std::allocator<Ogre::ContextQueDesc> >::~vector<Ogre::ContextQueDesc,std::allocator<Ogre::ContextQueDesc> >
PUBLIC	?deallocate@?$allocator@UContextQueDesc@Ogre@@@std@@QAEXPAUContextQueDesc@Ogre@@I@Z ; std::allocator<Ogre::ContextQueDesc>::deallocate
PUBLIC	??$_Ucopy@PAUContextQueDesc@Ogre@@@?$vector@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@IAEPAUContextQueDesc@Ogre@@PAU23@00@Z ; std::vector<Ogre::ContextQueDesc,std::allocator<Ogre::ContextQueDesc> >::_Ucopy<Ogre::ContextQueDesc *>
PUBLIC	?capacity@?$vector@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::ContextQueDesc,std::allocator<Ogre::ContextQueDesc> >::capacity
PUBLIC	?_Destroy@?$vector@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@IAEXPAUContextQueDesc@Ogre@@0@Z ; std::vector<Ogre::ContextQueDesc,std::allocator<Ogre::ContextQueDesc> >::_Destroy
PUBLIC	??$unchecked_copy@PAUContextQueDesc@Ogre@@PAU12@@stdext@@YAPAUContextQueDesc@Ogre@@PAU12@00@Z ; stdext::unchecked_copy<Ogre::ContextQueDesc *,Ogre::ContextQueDesc *>
PUBLIC	?clear@?$vector@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@QAEXXZ ; std::vector<Ogre::ContextQueDesc,std::allocator<Ogre::ContextQueDesc> >::clear
; Function compile flags: /Odtp
;	COMDAT ??4?$vector@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
__Ptr$72547 = -8					; size = 4
__Ptr$72537 = -4					; size = 4
__Right$ = 8						; size = 4
??4?$vector@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z PROC ; std::vector<Ogre::ContextQueDesc,std::allocator<Ogre::ContextQueDesc> >::operator=, COMDAT
; _this$ = ecx

; 563  : 		{	// assign _Right

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 564  : 		if (this != &_Right)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR __Right$[ebp]
	je	$LN9@operator@17

; 565  : 			{	// worth doing
; 566  : 
; 567  :  #if _HAS_ITERATOR_DEBUGGING
; 568  : 			this->_Orphan_all();
; 569  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 570  : 
; 571  : 			if (_Right.size() == 0)

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::ContextQueDesc,std::allocator<Ogre::ContextQueDesc> >::size
	test	eax, eax
	jne	SHORT $LN8@operator@17

; 572  : 				clear();	// new sequence empty, erase existing sequence

	mov	ecx, DWORD PTR _this$[ebp]
	call	?clear@?$vector@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@QAEXXZ ; std::vector<Ogre::ContextQueDesc,std::allocator<Ogre::ContextQueDesc> >::clear
	jmp	$LN9@operator@17
$LN8@operator@17:

; 573  : 			else if (_Right.size() <= size())

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::ContextQueDesc,std::allocator<Ogre::ContextQueDesc> >::size
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::ContextQueDesc,std::allocator<Ogre::ContextQueDesc> >::size
	cmp	esi, eax
	ja	SHORT $LN6@operator@17

; 574  : 				{	// enough elements, copy new and destroy old
; 575  : 				pointer _Ptr = _STDEXT unchecked_copy(_Right._Myfirst, _Right._Mylast,
; 576  : 					_Myfirst);	// copy new

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	call	??$unchecked_copy@PAUContextQueDesc@Ogre@@PAU12@@stdext@@YAPAUContextQueDesc@Ogre@@PAU12@00@Z ; stdext::unchecked_copy<Ogre::ContextQueDesc *,Ogre::ContextQueDesc *>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR __Ptr$72537[ebp], eax

; 577  : 				_Destroy(_Ptr, _Mylast);	// destroy old

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR __Ptr$72537[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@IAEXPAUContextQueDesc@Ogre@@0@Z ; std::vector<Ogre::ContextQueDesc,std::allocator<Ogre::ContextQueDesc> >::_Destroy

; 578  : 				_Mylast = _Myfirst + _Right.size();

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::ContextQueDesc,std::allocator<Ogre::ContextQueDesc> >::size
	imul	eax, 156				; 0000009cH
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+12]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+16], eax
	jmp	$LN9@operator@17
$LN6@operator@17:

; 579  : 				}
; 580  : 			else if (_Right.size() <= capacity())

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::ContextQueDesc,std::allocator<Ogre::ContextQueDesc> >::size
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?capacity@?$vector@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::ContextQueDesc,std::allocator<Ogre::ContextQueDesc> >::capacity
	cmp	esi, eax
	ja	SHORT $LN4@operator@17

; 581  : 				{	// enough room, copy and construct new
; 582  : 				pointer _Ptr = _Right._Myfirst + size();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::ContextQueDesc,std::allocator<Ogre::ContextQueDesc> >::size
	imul	eax, 156				; 0000009cH
	mov	ecx, DWORD PTR __Right$[ebp]
	add	eax, DWORD PTR [ecx+12]
	mov	DWORD PTR __Ptr$72547[ebp], eax

; 583  : 				_STDEXT unchecked_copy(_Right._Myfirst, _Ptr, _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR __Ptr$72547[ebp]
	push	ecx
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	call	??$unchecked_copy@PAUContextQueDesc@Ogre@@PAU12@@stdext@@YAPAUContextQueDesc@Ogre@@PAU12@00@Z ; stdext::unchecked_copy<Ogre::ContextQueDesc *,Ogre::ContextQueDesc *>
	add	esp, 12					; 0000000cH

; 584  : 				_Mylast = _Ucopy(_Ptr, _Right._Mylast, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Ptr$72547[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Ucopy@PAUContextQueDesc@Ogre@@@?$vector@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@IAEPAUContextQueDesc@Ogre@@PAU23@00@Z ; std::vector<Ogre::ContextQueDesc,std::allocator<Ogre::ContextQueDesc> >::_Ucopy<Ogre::ContextQueDesc *>
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 585  : 				}
; 586  : 			else

	jmp	$LN9@operator@17
$LN4@operator@17:

; 587  : 				{	// not enough room, allocate new array and construct new
; 588  : 				if (_Myfirst != 0)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+12], 0
	je	SHORT $LN2@operator@17

; 589  : 					{	// discard old array
; 590  : 					_Destroy(_Myfirst, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@IAEXPAUContextQueDesc@Ogre@@0@Z ; std::vector<Ogre::ContextQueDesc,std::allocator<Ogre::ContextQueDesc> >::_Destroy

; 591  : 					this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+20]
	sub	eax, DWORD PTR [edx+12]
	cdq
	mov	ecx, 156				; 0000009cH
	idiv	ecx
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?deallocate@?$allocator@UContextQueDesc@Ogre@@@std@@QAEXPAUContextQueDesc@Ogre@@I@Z ; std::allocator<Ogre::ContextQueDesc>::deallocate
$LN2@operator@17:

; 592  : 					}
; 593  : 				if (_Buy(_Right.size()))

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::ContextQueDesc,std::allocator<Ogre::ContextQueDesc> >::size
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@IAE_NI@Z ; std::vector<Ogre::ContextQueDesc,std::allocator<Ogre::ContextQueDesc> >::_Buy
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN9@operator@17

; 594  : 					_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 595  : 						_Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Ucopy@PAUContextQueDesc@Ogre@@@?$vector@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@IAEPAUContextQueDesc@Ogre@@PAU23@00@Z ; std::vector<Ogre::ContextQueDesc,std::allocator<Ogre::ContextQueDesc> >::_Ucopy<Ogre::ContextQueDesc *>
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+16], eax
$LN9@operator@17:

; 596  : 				}
; 597  : 			}
; 598  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 599  : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
??4?$vector@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z ENDP ; std::vector<Ogre::ContextQueDesc,std::allocator<Ogre::ContextQueDesc> >::operator=
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@EV?$allocator@E@std@@@std@@QAE@XZ ; std::_Vector_val<unsigned char,std::allocator<unsigned char> >::~_Vector_val<unsigned char,std::allocator<unsigned char> >
PUBLIC	?_Tidy@?$vector@EV?$allocator@E@std@@@std@@IAEXXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::_Tidy
PUBLIC	??$_Ucopy@V?$_Vector_const_iterator@EV?$allocator@E@std@@@std@@@?$vector@EV?$allocator@E@std@@@std@@IAEPAEV?$_Vector_const_iterator@EV?$allocator@E@std@@@1@0PAE@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Ucopy<std::_Vector_const_iterator<unsigned char,std::allocator<unsigned char> > >
PUBLIC	?begin@?$vector@EV?$allocator@E@std@@@std@@QBE?AV?$_Vector_const_iterator@EV?$allocator@E@std@@@2@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::begin
PUBLIC	?end@?$vector@EV?$allocator@E@std@@@std@@QBE?AV?$_Vector_const_iterator@EV?$allocator@E@std@@@2@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::end
PUBLIC	?_Buy@?$vector@EV?$allocator@E@std@@@std@@IAE_NI@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Buy
PUBLIC	?size@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::size
PUBLIC	??0?$_Vector_val@EV?$allocator@E@std@@@std@@IAE@V?$allocator@E@1@@Z ; std::_Vector_val<unsigned char,std::allocator<unsigned char> >::_Vector_val<unsigned char,std::allocator<unsigned char> >
PUBLIC	??0?$allocator@E@std@@QAE@ABV01@@Z		; std::allocator<unsigned char>::allocator<unsigned char>
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??0?$vector@EV?$allocator@E@std@@@std@@QAE@ABV01@@Z$3 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??0?$vector@EV?$allocator@E@std@@@std@@QAE@ABV01@@Z$0
__tryblocktable$??0?$vector@EV?$allocator@E@std@@@std@@QAE@ABV01@@Z DD 01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??0?$vector@EV?$allocator@E@std@@@std@@QAE@ABV01@@Z$3
__unwindtable$??0?$vector@EV?$allocator@E@std@@@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@EV?$allocator@E@std@@@std@@QAE@ABV01@@Z$2
	DD	00H
	DD	00H
	DD	00H
	DD	00H
__ehfuncinfo$??0?$vector@EV?$allocator@E@std@@@std@@QAE@ABV01@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0?$vector@EV?$allocator@E@std@@@std@@QAE@ABV01@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??0?$vector@EV?$allocator@E@std@@@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$vector@EV?$allocator@E@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -40						; size = 4
$T95042 = -36						; size = 8
$T95041 = -28						; size = 8
$T95040 = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Right$ = 8						; size = 4
??0?$vector@EV?$allocator@E@std@@@std@@QAE@ABV01@@Z PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::vector<unsigned char,std::allocator<unsigned char> >, COMDAT
; _this$ = ecx

; 500  : 		{	// construct by copying _Right

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$vector@EV?$allocator@E@std@@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 24					; 00000018H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Right$[ebp]
	add	eax, 8
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T95040[ebp], esp
	push	eax
	call	??0?$allocator@E@std@@QAE@ABV01@@Z	; std::allocator<unsigned char>::allocator<unsigned char>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_val@EV?$allocator@E@std@@@std@@IAE@V?$allocator@E@1@@Z ; std::_Vector_val<unsigned char,std::allocator<unsigned char> >::_Vector_val<unsigned char,std::allocator<unsigned char> >
	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 501  : 		if (_Buy(_Right.size()))

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::size
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@EV?$allocator@E@std@@@std@@IAE_NI@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Buy
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN3@vector@35

; 502  : 			_TRY_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 1

; 503  : 			_Mylast = _Ucopy(_Right.begin(), _Right.end(), _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	lea	ecx, DWORD PTR $T95041[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?end@?$vector@EV?$allocator@E@std@@@std@@QBE?AV?$_Vector_const_iterator@EV?$allocator@E@std@@@2@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::end
	mov	edx, DWORD PTR [eax+4]
	push	edx
	mov	eax, DWORD PTR [eax]
	push	eax
	lea	ecx, DWORD PTR $T95042[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?begin@?$vector@EV?$allocator@E@std@@@std@@QBE?AV?$_Vector_const_iterator@EV?$allocator@E@std@@@2@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::begin
	mov	edx, DWORD PTR [eax+4]
	push	edx
	mov	eax, DWORD PTR [eax]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Ucopy@V?$_Vector_const_iterator@EV?$allocator@E@std@@@std@@@?$vector@EV?$allocator@E@std@@@std@@IAEPAEV?$_Vector_const_iterator@EV?$allocator@E@std@@@1@0PAE@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Ucopy<std::_Vector_const_iterator<unsigned char,std::allocator<unsigned char> > >
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax
	jmp	SHORT $LN5@vector@35
__catch$??0?$vector@EV?$allocator@E@std@@@std@@QAE@ABV01@@Z$0:

; 504  : 			_CATCH_ALL
; 505  : 			_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@EV?$allocator@E@std@@@std@@IAEXXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::_Tidy

; 506  : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 507  : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], 0
	mov	eax, $LN3@vector@35
	ret	0
$LN5@vector@35:
	mov	DWORD PTR __$EHRec$[ebp+12], 0
$LN3@vector@35:

; 508  : 		}

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector@35:
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@EV?$allocator@E@std@@@std@@QAE@ABV01@@Z$2:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@EV?$allocator@E@std@@@std@@QAE@XZ
__ehhandler$??0?$vector@EV?$allocator@E@std@@@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-44]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@EV?$allocator@E@std@@@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@EV?$allocator@E@std@@@std@@QAE@ABV01@@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::vector<unsigned char,std::allocator<unsigned char> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$vector@EV?$allocator@E@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$vector@EV?$allocator@E@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$vector@EV?$allocator@E@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$vector@EV?$allocator@E@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$vector@EV?$allocator@E@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$vector@EV?$allocator@E@std@@@std@@QAE@XZ PROC	; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$vector@EV?$allocator@E@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 559  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@EV?$allocator@E@std@@@std@@IAEXXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::_Tidy

; 560  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Vector_val@EV?$allocator@E@std@@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$vector@EV?$allocator@E@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@EV?$allocator@E@std@@@std@@QAE@XZ
__ehhandler$??1?$vector@EV?$allocator@E@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$vector@EV?$allocator@E@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$vector@EV?$allocator@E@std@@@std@@QAE@XZ ENDP	; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >
PUBLIC	?deallocate@?$allocator@E@std@@QAEXPAEI@Z	; std::allocator<unsigned char>::deallocate
PUBLIC	??$_Ucopy@PAE@?$vector@EV?$allocator@E@std@@@std@@IAEPAEPAE00@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Ucopy<unsigned char *>
PUBLIC	?capacity@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::capacity
PUBLIC	?_Destroy@?$vector@EV?$allocator@E@std@@@std@@IAEXPAE0@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Destroy
PUBLIC	??$unchecked_copy@PAEPAE@stdext@@YAPAEPAE00@Z	; stdext::unchecked_copy<unsigned char *,unsigned char *>
PUBLIC	?clear@?$vector@EV?$allocator@E@std@@@std@@QAEXXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::clear
; Function compile flags: /Odtp
;	COMDAT ??4?$vector@EV?$allocator@E@std@@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
__Ptr$72701 = -8					; size = 4
__Ptr$72691 = -4					; size = 4
__Right$ = 8						; size = 4
??4?$vector@EV?$allocator@E@std@@@std@@QAEAAV01@ABV01@@Z PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::operator=, COMDAT
; _this$ = ecx

; 563  : 		{	// assign _Right

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 564  : 		if (this != &_Right)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR __Right$[ebp]
	je	$LN9@operator@18

; 565  : 			{	// worth doing
; 566  : 
; 567  :  #if _HAS_ITERATOR_DEBUGGING
; 568  : 			this->_Orphan_all();
; 569  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 570  : 
; 571  : 			if (_Right.size() == 0)

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::size
	test	eax, eax
	jne	SHORT $LN8@operator@18

; 572  : 				clear();	// new sequence empty, erase existing sequence

	mov	ecx, DWORD PTR _this$[ebp]
	call	?clear@?$vector@EV?$allocator@E@std@@@std@@QAEXXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::clear
	jmp	$LN9@operator@18
$LN8@operator@18:

; 573  : 			else if (_Right.size() <= size())

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::size
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::size
	cmp	esi, eax
	ja	SHORT $LN6@operator@18

; 574  : 				{	// enough elements, copy new and destroy old
; 575  : 				pointer _Ptr = _STDEXT unchecked_copy(_Right._Myfirst, _Right._Mylast,
; 576  : 					_Myfirst);	// copy new

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	call	??$unchecked_copy@PAEPAE@stdext@@YAPAEPAE00@Z ; stdext::unchecked_copy<unsigned char *,unsigned char *>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR __Ptr$72691[ebp], eax

; 577  : 				_Destroy(_Ptr, _Mylast);	// destroy old

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR __Ptr$72691[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@EV?$allocator@E@std@@@std@@IAEXPAE0@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Destroy

; 578  : 				_Mylast = _Myfirst + _Right.size();

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::size
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+12]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+16], eax
	jmp	$LN9@operator@18
$LN6@operator@18:

; 579  : 				}
; 580  : 			else if (_Right.size() <= capacity())

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::size
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?capacity@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::capacity
	cmp	esi, eax
	ja	SHORT $LN4@operator@18

; 581  : 				{	// enough room, copy and construct new
; 582  : 				pointer _Ptr = _Right._Myfirst + size();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::size
	mov	ecx, DWORD PTR __Right$[ebp]
	add	eax, DWORD PTR [ecx+12]
	mov	DWORD PTR __Ptr$72701[ebp], eax

; 583  : 				_STDEXT unchecked_copy(_Right._Myfirst, _Ptr, _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR __Ptr$72701[ebp]
	push	ecx
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	call	??$unchecked_copy@PAEPAE@stdext@@YAPAEPAE00@Z ; stdext::unchecked_copy<unsigned char *,unsigned char *>
	add	esp, 12					; 0000000cH

; 584  : 				_Mylast = _Ucopy(_Ptr, _Right._Mylast, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Ptr$72701[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Ucopy@PAE@?$vector@EV?$allocator@E@std@@@std@@IAEPAEPAE00@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Ucopy<unsigned char *>
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 585  : 				}
; 586  : 			else

	jmp	SHORT $LN9@operator@18
$LN4@operator@18:

; 587  : 				{	// not enough room, allocate new array and construct new
; 588  : 				if (_Myfirst != 0)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+12], 0
	je	SHORT $LN2@operator@18

; 589  : 					{	// discard old array
; 590  : 					_Destroy(_Myfirst, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@EV?$allocator@E@std@@@std@@IAEXPAE0@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Destroy

; 591  : 					this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+20]
	sub	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?deallocate@?$allocator@E@std@@QAEXPAEI@Z ; std::allocator<unsigned char>::deallocate
$LN2@operator@18:

; 592  : 					}
; 593  : 				if (_Buy(_Right.size()))

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::size
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@EV?$allocator@E@std@@@std@@IAE_NI@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Buy
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN9@operator@18

; 594  : 					_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 595  : 						_Myfirst);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Ucopy@PAE@?$vector@EV?$allocator@E@std@@@std@@IAEPAEPAE00@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Ucopy<unsigned char *>
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax
$LN9@operator@18:

; 596  : 				}
; 597  : 			}
; 598  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 599  : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
??4?$vector@EV?$allocator@E@std@@@std@@QAEAAV01@ABV01@@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::operator=
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@QAE@XZ ; std::_Vector_val<Ogre::ShaderContextPool::ValueParam,std::allocator<Ogre::ShaderContextPool::ValueParam> >::~_Vector_val<Ogre::ShaderContextPool::ValueParam,std::allocator<Ogre::ShaderContextPool::ValueParam> >
PUBLIC	?_Tidy@?$vector@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@IAEXXZ ; std::vector<Ogre::ShaderContextPool::ValueParam,std::allocator<Ogre::ShaderContextPool::ValueParam> >::_Tidy
PUBLIC	??$_Ucopy@V?$_Vector_const_iterator@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@@?$vector@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@IAEPAUValueParam@ShaderContextPool@Ogre@@V?$_Vector_const_iterator@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@1@0PAU234@@Z ; std::vector<Ogre::ShaderContextPool::ValueParam,std::allocator<Ogre::ShaderContextPool::ValueParam> >::_Ucopy<std::_Vector_const_iterator<Ogre::ShaderContextPool::ValueParam,std::allocator<Ogre::ShaderContextPool::ValueParam> > >
PUBLIC	?begin@?$vector@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@2@XZ ; std::vector<Ogre::ShaderContextPool::ValueParam,std::allocator<Ogre::ShaderContextPool::ValueParam> >::begin
PUBLIC	?end@?$vector@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@2@XZ ; std::vector<Ogre::ShaderContextPool::ValueParam,std::allocator<Ogre::ShaderContextPool::ValueParam> >::end
PUBLIC	?_Buy@?$vector@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@IAE_NI@Z ; std::vector<Ogre::ShaderContextPool::ValueParam,std::allocator<Ogre::ShaderContextPool::ValueParam> >::_Buy
PUBLIC	?size@?$vector@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::ShaderContextPool::ValueParam,std::allocator<Ogre::ShaderContextPool::ValueParam> >::size
PUBLIC	??0?$_Vector_val@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@IAE@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@1@@Z ; std::_Vector_val<Ogre::ShaderContextPool::ValueParam,std::allocator<Ogre::ShaderContextPool::ValueParam> >::_Vector_val<Ogre::ShaderContextPool::ValueParam,std::allocator<Ogre::ShaderContextPool::ValueParam> >
PUBLIC	??0?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::ShaderContextPool::ValueParam>::allocator<Ogre::ShaderContextPool::ValueParam>
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??0?$vector@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@QAE@ABV01@@Z$3 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??0?$vector@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@QAE@ABV01@@Z$0
__tryblocktable$??0?$vector@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@QAE@ABV01@@Z DD 01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??0?$vector@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@QAE@ABV01@@Z$3
__unwindtable$??0?$vector@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@QAE@ABV01@@Z$2
	DD	00H
	DD	00H
	DD	00H
	DD	00H
__ehfuncinfo$??0?$vector@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@QAE@ABV01@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0?$vector@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@QAE@ABV01@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??0?$vector@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$vector@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -40						; size = 4
$T95072 = -36						; size = 8
$T95071 = -28						; size = 8
$T95070 = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Right$ = 8						; size = 4
??0?$vector@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@QAE@ABV01@@Z PROC ; std::vector<Ogre::ShaderContextPool::ValueParam,std::allocator<Ogre::ShaderContextPool::ValueParam> >::vector<Ogre::ShaderContextPool::ValueParam,std::allocator<Ogre::ShaderContextPool::ValueParam> >, COMDAT
; _this$ = ecx

; 500  : 		{	// construct by copying _Right

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$vector@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 24					; 00000018H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Right$[ebp]
	add	eax, 8
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T95070[ebp], esp
	push	eax
	call	??0?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::ShaderContextPool::ValueParam>::allocator<Ogre::ShaderContextPool::ValueParam>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_val@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@IAE@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@1@@Z ; std::_Vector_val<Ogre::ShaderContextPool::ValueParam,std::allocator<Ogre::ShaderContextPool::ValueParam> >::_Vector_val<Ogre::ShaderContextPool::ValueParam,std::allocator<Ogre::ShaderContextPool::ValueParam> >
	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 501  : 		if (_Buy(_Right.size()))

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::ShaderContextPool::ValueParam,std::allocator<Ogre::ShaderContextPool::ValueParam> >::size
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@IAE_NI@Z ; std::vector<Ogre::ShaderContextPool::ValueParam,std::allocator<Ogre::ShaderContextPool::ValueParam> >::_Buy
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN3@vector@36

; 502  : 			_TRY_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 1

; 503  : 			_Mylast = _Ucopy(_Right.begin(), _Right.end(), _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	lea	ecx, DWORD PTR $T95071[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?end@?$vector@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@2@XZ ; std::vector<Ogre::ShaderContextPool::ValueParam,std::allocator<Ogre::ShaderContextPool::ValueParam> >::end
	mov	edx, DWORD PTR [eax+4]
	push	edx
	mov	eax, DWORD PTR [eax]
	push	eax
	lea	ecx, DWORD PTR $T95072[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?begin@?$vector@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@2@XZ ; std::vector<Ogre::ShaderContextPool::ValueParam,std::allocator<Ogre::ShaderContextPool::ValueParam> >::begin
	mov	edx, DWORD PTR [eax+4]
	push	edx
	mov	eax, DWORD PTR [eax]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Ucopy@V?$_Vector_const_iterator@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@@?$vector@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@IAEPAUValueParam@ShaderContextPool@Ogre@@V?$_Vector_const_iterator@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@1@0PAU234@@Z ; std::vector<Ogre::ShaderContextPool::ValueParam,std::allocator<Ogre::ShaderContextPool::ValueParam> >::_Ucopy<std::_Vector_const_iterator<Ogre::ShaderContextPool::ValueParam,std::allocator<Ogre::ShaderContextPool::ValueParam> > >
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax
	jmp	SHORT $LN5@vector@36
__catch$??0?$vector@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@QAE@ABV01@@Z$0:

; 504  : 			_CATCH_ALL
; 505  : 			_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@IAEXXZ ; std::vector<Ogre::ShaderContextPool::ValueParam,std::allocator<Ogre::ShaderContextPool::ValueParam> >::_Tidy

; 506  : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 507  : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], 0
	mov	eax, $LN3@vector@36
	ret	0
$LN5@vector@36:
	mov	DWORD PTR __$EHRec$[ebp+12], 0
$LN3@vector@36:

; 508  : 		}

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector@36:
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@QAE@ABV01@@Z$2:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@QAE@XZ
__ehhandler$??0?$vector@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-44]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::vector<Ogre::ShaderContextPool::ValueParam,std::allocator<Ogre::ShaderContextPool::ValueParam> >::vector<Ogre::ShaderContextPool::ValueParam,std::allocator<Ogre::ShaderContextPool::ValueParam> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$vector@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$vector@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$vector@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$vector@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$vector@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$vector@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@QAE@XZ PROC ; std::vector<Ogre::ShaderContextPool::ValueParam,std::allocator<Ogre::ShaderContextPool::ValueParam> >::~vector<Ogre::ShaderContextPool::ValueParam,std::allocator<Ogre::ShaderContextPool::ValueParam> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$vector@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 559  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@IAEXXZ ; std::vector<Ogre::ShaderContextPool::ValueParam,std::allocator<Ogre::ShaderContextPool::ValueParam> >::_Tidy

; 560  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Vector_val@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$vector@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@QAE@XZ
__ehhandler$??1?$vector@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$vector@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$vector@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@QAE@XZ ENDP ; std::vector<Ogre::ShaderContextPool::ValueParam,std::allocator<Ogre::ShaderContextPool::ValueParam> >::~vector<Ogre::ShaderContextPool::ValueParam,std::allocator<Ogre::ShaderContextPool::ValueParam> >
PUBLIC	?deallocate@?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@QAEXPAUValueParam@ShaderContextPool@Ogre@@I@Z ; std::allocator<Ogre::ShaderContextPool::ValueParam>::deallocate
PUBLIC	??$_Ucopy@PAUValueParam@ShaderContextPool@Ogre@@@?$vector@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@IAEPAUValueParam@ShaderContextPool@Ogre@@PAU234@00@Z ; std::vector<Ogre::ShaderContextPool::ValueParam,std::allocator<Ogre::ShaderContextPool::ValueParam> >::_Ucopy<Ogre::ShaderContextPool::ValueParam *>
PUBLIC	?capacity@?$vector@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::ShaderContextPool::ValueParam,std::allocator<Ogre::ShaderContextPool::ValueParam> >::capacity
PUBLIC	?_Destroy@?$vector@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@IAEXPAUValueParam@ShaderContextPool@Ogre@@0@Z ; std::vector<Ogre::ShaderContextPool::ValueParam,std::allocator<Ogre::ShaderContextPool::ValueParam> >::_Destroy
PUBLIC	??$unchecked_copy@PAUValueParam@ShaderContextPool@Ogre@@PAU123@@stdext@@YAPAUValueParam@ShaderContextPool@Ogre@@PAU123@00@Z ; stdext::unchecked_copy<Ogre::ShaderContextPool::ValueParam *,Ogre::ShaderContextPool::ValueParam *>
PUBLIC	?clear@?$vector@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@QAEXXZ ; std::vector<Ogre::ShaderContextPool::ValueParam,std::allocator<Ogre::ShaderContextPool::ValueParam> >::clear
; Function compile flags: /Odtp
;	COMDAT ??4?$vector@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
__Ptr$72859 = -8					; size = 4
__Ptr$72849 = -4					; size = 4
__Right$ = 8						; size = 4
??4?$vector@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z PROC ; std::vector<Ogre::ShaderContextPool::ValueParam,std::allocator<Ogre::ShaderContextPool::ValueParam> >::operator=, COMDAT
; _this$ = ecx

; 563  : 		{	// assign _Right

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 564  : 		if (this != &_Right)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR __Right$[ebp]
	je	$LN9@operator@19

; 565  : 			{	// worth doing
; 566  : 
; 567  :  #if _HAS_ITERATOR_DEBUGGING
; 568  : 			this->_Orphan_all();
; 569  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 570  : 
; 571  : 			if (_Right.size() == 0)

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::ShaderContextPool::ValueParam,std::allocator<Ogre::ShaderContextPool::ValueParam> >::size
	test	eax, eax
	jne	SHORT $LN8@operator@19

; 572  : 				clear();	// new sequence empty, erase existing sequence

	mov	ecx, DWORD PTR _this$[ebp]
	call	?clear@?$vector@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@QAEXXZ ; std::vector<Ogre::ShaderContextPool::ValueParam,std::allocator<Ogre::ShaderContextPool::ValueParam> >::clear
	jmp	$LN9@operator@19
$LN8@operator@19:

; 573  : 			else if (_Right.size() <= size())

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::ShaderContextPool::ValueParam,std::allocator<Ogre::ShaderContextPool::ValueParam> >::size
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::ShaderContextPool::ValueParam,std::allocator<Ogre::ShaderContextPool::ValueParam> >::size
	cmp	esi, eax
	ja	SHORT $LN6@operator@19

; 574  : 				{	// enough elements, copy new and destroy old
; 575  : 				pointer _Ptr = _STDEXT unchecked_copy(_Right._Myfirst, _Right._Mylast,
; 576  : 					_Myfirst);	// copy new

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	call	??$unchecked_copy@PAUValueParam@ShaderContextPool@Ogre@@PAU123@@stdext@@YAPAUValueParam@ShaderContextPool@Ogre@@PAU123@00@Z ; stdext::unchecked_copy<Ogre::ShaderContextPool::ValueParam *,Ogre::ShaderContextPool::ValueParam *>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR __Ptr$72849[ebp], eax

; 577  : 				_Destroy(_Ptr, _Mylast);	// destroy old

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR __Ptr$72849[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@IAEXPAUValueParam@ShaderContextPool@Ogre@@0@Z ; std::vector<Ogre::ShaderContextPool::ValueParam,std::allocator<Ogre::ShaderContextPool::ValueParam> >::_Destroy

; 578  : 				_Mylast = _Myfirst + _Right.size();

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::ShaderContextPool::ValueParam,std::allocator<Ogre::ShaderContextPool::ValueParam> >::size
	shl	eax, 4
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+12]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+16], eax
	jmp	$LN9@operator@19
$LN6@operator@19:

; 579  : 				}
; 580  : 			else if (_Right.size() <= capacity())

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::ShaderContextPool::ValueParam,std::allocator<Ogre::ShaderContextPool::ValueParam> >::size
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?capacity@?$vector@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::ShaderContextPool::ValueParam,std::allocator<Ogre::ShaderContextPool::ValueParam> >::capacity
	cmp	esi, eax
	ja	SHORT $LN4@operator@19

; 581  : 				{	// enough room, copy and construct new
; 582  : 				pointer _Ptr = _Right._Myfirst + size();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::ShaderContextPool::ValueParam,std::allocator<Ogre::ShaderContextPool::ValueParam> >::size
	shl	eax, 4
	mov	ecx, DWORD PTR __Right$[ebp]
	add	eax, DWORD PTR [ecx+12]
	mov	DWORD PTR __Ptr$72859[ebp], eax

; 583  : 				_STDEXT unchecked_copy(_Right._Myfirst, _Ptr, _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR __Ptr$72859[ebp]
	push	ecx
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	call	??$unchecked_copy@PAUValueParam@ShaderContextPool@Ogre@@PAU123@@stdext@@YAPAUValueParam@ShaderContextPool@Ogre@@PAU123@00@Z ; stdext::unchecked_copy<Ogre::ShaderContextPool::ValueParam *,Ogre::ShaderContextPool::ValueParam *>
	add	esp, 12					; 0000000cH

; 584  : 				_Mylast = _Ucopy(_Ptr, _Right._Mylast, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Ptr$72859[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Ucopy@PAUValueParam@ShaderContextPool@Ogre@@@?$vector@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@IAEPAUValueParam@ShaderContextPool@Ogre@@PAU234@00@Z ; std::vector<Ogre::ShaderContextPool::ValueParam,std::allocator<Ogre::ShaderContextPool::ValueParam> >::_Ucopy<Ogre::ShaderContextPool::ValueParam *>
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 585  : 				}
; 586  : 			else

	jmp	SHORT $LN9@operator@19
$LN4@operator@19:

; 587  : 				{	// not enough room, allocate new array and construct new
; 588  : 				if (_Myfirst != 0)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+12], 0
	je	SHORT $LN2@operator@19

; 589  : 					{	// discard old array
; 590  : 					_Destroy(_Myfirst, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@IAEXPAUValueParam@ShaderContextPool@Ogre@@0@Z ; std::vector<Ogre::ShaderContextPool::ValueParam,std::allocator<Ogre::ShaderContextPool::ValueParam> >::_Destroy

; 591  : 					this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+20]
	sub	eax, DWORD PTR [edx+12]
	sar	eax, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?deallocate@?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@QAEXPAUValueParam@ShaderContextPool@Ogre@@I@Z ; std::allocator<Ogre::ShaderContextPool::ValueParam>::deallocate
$LN2@operator@19:

; 592  : 					}
; 593  : 				if (_Buy(_Right.size()))

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::ShaderContextPool::ValueParam,std::allocator<Ogre::ShaderContextPool::ValueParam> >::size
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@IAE_NI@Z ; std::vector<Ogre::ShaderContextPool::ValueParam,std::allocator<Ogre::ShaderContextPool::ValueParam> >::_Buy
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN9@operator@19

; 594  : 					_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 595  : 						_Myfirst);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Ucopy@PAUValueParam@ShaderContextPool@Ogre@@@?$vector@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@IAEPAUValueParam@ShaderContextPool@Ogre@@PAU234@00@Z ; std::vector<Ogre::ShaderContextPool::ValueParam,std::allocator<Ogre::ShaderContextPool::ValueParam> >::_Ucopy<Ogre::ShaderContextPool::ValueParam *>
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax
$LN9@operator@19:

; 596  : 				}
; 597  : 			}
; 598  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 599  : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
??4?$vector@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z ENDP ; std::vector<Ogre::ShaderContextPool::ValueParam,std::allocator<Ogre::ShaderContextPool::ValueParam> >::operator=
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@QAE@XZ ; std::_Vector_val<Ogre::ShaderContextPool::TexParam,std::allocator<Ogre::ShaderContextPool::TexParam> >::~_Vector_val<Ogre::ShaderContextPool::TexParam,std::allocator<Ogre::ShaderContextPool::TexParam> >
PUBLIC	?_Tidy@?$vector@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@IAEXXZ ; std::vector<Ogre::ShaderContextPool::TexParam,std::allocator<Ogre::ShaderContextPool::TexParam> >::_Tidy
PUBLIC	??$_Ucopy@V?$_Vector_const_iterator@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@@?$vector@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@IAEPAUTexParam@ShaderContextPool@Ogre@@V?$_Vector_const_iterator@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@1@0PAU234@@Z ; std::vector<Ogre::ShaderContextPool::TexParam,std::allocator<Ogre::ShaderContextPool::TexParam> >::_Ucopy<std::_Vector_const_iterator<Ogre::ShaderContextPool::TexParam,std::allocator<Ogre::ShaderContextPool::TexParam> > >
PUBLIC	?begin@?$vector@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@2@XZ ; std::vector<Ogre::ShaderContextPool::TexParam,std::allocator<Ogre::ShaderContextPool::TexParam> >::begin
PUBLIC	?end@?$vector@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@2@XZ ; std::vector<Ogre::ShaderContextPool::TexParam,std::allocator<Ogre::ShaderContextPool::TexParam> >::end
PUBLIC	?_Buy@?$vector@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@IAE_NI@Z ; std::vector<Ogre::ShaderContextPool::TexParam,std::allocator<Ogre::ShaderContextPool::TexParam> >::_Buy
PUBLIC	?size@?$vector@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::ShaderContextPool::TexParam,std::allocator<Ogre::ShaderContextPool::TexParam> >::size
PUBLIC	??0?$_Vector_val@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@IAE@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@1@@Z ; std::_Vector_val<Ogre::ShaderContextPool::TexParam,std::allocator<Ogre::ShaderContextPool::TexParam> >::_Vector_val<Ogre::ShaderContextPool::TexParam,std::allocator<Ogre::ShaderContextPool::TexParam> >
PUBLIC	??0?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::ShaderContextPool::TexParam>::allocator<Ogre::ShaderContextPool::TexParam>
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??0?$vector@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@QAE@ABV01@@Z$3 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??0?$vector@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@QAE@ABV01@@Z$0
__tryblocktable$??0?$vector@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@QAE@ABV01@@Z DD 01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??0?$vector@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@QAE@ABV01@@Z$3
__unwindtable$??0?$vector@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@QAE@ABV01@@Z$2
	DD	00H
	DD	00H
	DD	00H
	DD	00H
__ehfuncinfo$??0?$vector@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@QAE@ABV01@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0?$vector@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@QAE@ABV01@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??0?$vector@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$vector@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -40						; size = 4
$T95102 = -36						; size = 8
$T95101 = -28						; size = 8
$T95100 = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Right$ = 8						; size = 4
??0?$vector@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@QAE@ABV01@@Z PROC ; std::vector<Ogre::ShaderContextPool::TexParam,std::allocator<Ogre::ShaderContextPool::TexParam> >::vector<Ogre::ShaderContextPool::TexParam,std::allocator<Ogre::ShaderContextPool::TexParam> >, COMDAT
; _this$ = ecx

; 500  : 		{	// construct by copying _Right

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$vector@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 24					; 00000018H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Right$[ebp]
	add	eax, 8
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T95100[ebp], esp
	push	eax
	call	??0?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::ShaderContextPool::TexParam>::allocator<Ogre::ShaderContextPool::TexParam>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_val@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@IAE@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@1@@Z ; std::_Vector_val<Ogre::ShaderContextPool::TexParam,std::allocator<Ogre::ShaderContextPool::TexParam> >::_Vector_val<Ogre::ShaderContextPool::TexParam,std::allocator<Ogre::ShaderContextPool::TexParam> >
	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 501  : 		if (_Buy(_Right.size()))

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::ShaderContextPool::TexParam,std::allocator<Ogre::ShaderContextPool::TexParam> >::size
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@IAE_NI@Z ; std::vector<Ogre::ShaderContextPool::TexParam,std::allocator<Ogre::ShaderContextPool::TexParam> >::_Buy
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN3@vector@37

; 502  : 			_TRY_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 1

; 503  : 			_Mylast = _Ucopy(_Right.begin(), _Right.end(), _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	lea	ecx, DWORD PTR $T95101[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?end@?$vector@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@2@XZ ; std::vector<Ogre::ShaderContextPool::TexParam,std::allocator<Ogre::ShaderContextPool::TexParam> >::end
	mov	edx, DWORD PTR [eax+4]
	push	edx
	mov	eax, DWORD PTR [eax]
	push	eax
	lea	ecx, DWORD PTR $T95102[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?begin@?$vector@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@2@XZ ; std::vector<Ogre::ShaderContextPool::TexParam,std::allocator<Ogre::ShaderContextPool::TexParam> >::begin
	mov	edx, DWORD PTR [eax+4]
	push	edx
	mov	eax, DWORD PTR [eax]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Ucopy@V?$_Vector_const_iterator@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@@?$vector@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@IAEPAUTexParam@ShaderContextPool@Ogre@@V?$_Vector_const_iterator@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@1@0PAU234@@Z ; std::vector<Ogre::ShaderContextPool::TexParam,std::allocator<Ogre::ShaderContextPool::TexParam> >::_Ucopy<std::_Vector_const_iterator<Ogre::ShaderContextPool::TexParam,std::allocator<Ogre::ShaderContextPool::TexParam> > >
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax
	jmp	SHORT $LN5@vector@37
__catch$??0?$vector@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@QAE@ABV01@@Z$0:

; 504  : 			_CATCH_ALL
; 505  : 			_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@IAEXXZ ; std::vector<Ogre::ShaderContextPool::TexParam,std::allocator<Ogre::ShaderContextPool::TexParam> >::_Tidy

; 506  : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 507  : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], 0
	mov	eax, $LN3@vector@37
	ret	0
$LN5@vector@37:
	mov	DWORD PTR __$EHRec$[ebp+12], 0
$LN3@vector@37:

; 508  : 		}

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector@37:
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@QAE@ABV01@@Z$2:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@QAE@XZ
__ehhandler$??0?$vector@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-44]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::vector<Ogre::ShaderContextPool::TexParam,std::allocator<Ogre::ShaderContextPool::TexParam> >::vector<Ogre::ShaderContextPool::TexParam,std::allocator<Ogre::ShaderContextPool::TexParam> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$vector@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$vector@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$vector@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$vector@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$vector@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$vector@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@QAE@XZ PROC ; std::vector<Ogre::ShaderContextPool::TexParam,std::allocator<Ogre::ShaderContextPool::TexParam> >::~vector<Ogre::ShaderContextPool::TexParam,std::allocator<Ogre::ShaderContextPool::TexParam> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$vector@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 559  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@IAEXXZ ; std::vector<Ogre::ShaderContextPool::TexParam,std::allocator<Ogre::ShaderContextPool::TexParam> >::_Tidy

; 560  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Vector_val@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$vector@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@QAE@XZ
__ehhandler$??1?$vector@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$vector@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$vector@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@QAE@XZ ENDP ; std::vector<Ogre::ShaderContextPool::TexParam,std::allocator<Ogre::ShaderContextPool::TexParam> >::~vector<Ogre::ShaderContextPool::TexParam,std::allocator<Ogre::ShaderContextPool::TexParam> >
PUBLIC	?deallocate@?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@QAEXPAUTexParam@ShaderContextPool@Ogre@@I@Z ; std::allocator<Ogre::ShaderContextPool::TexParam>::deallocate
PUBLIC	??$_Ucopy@PAUTexParam@ShaderContextPool@Ogre@@@?$vector@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@IAEPAUTexParam@ShaderContextPool@Ogre@@PAU234@00@Z ; std::vector<Ogre::ShaderContextPool::TexParam,std::allocator<Ogre::ShaderContextPool::TexParam> >::_Ucopy<Ogre::ShaderContextPool::TexParam *>
PUBLIC	?capacity@?$vector@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::ShaderContextPool::TexParam,std::allocator<Ogre::ShaderContextPool::TexParam> >::capacity
PUBLIC	?_Destroy@?$vector@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@IAEXPAUTexParam@ShaderContextPool@Ogre@@0@Z ; std::vector<Ogre::ShaderContextPool::TexParam,std::allocator<Ogre::ShaderContextPool::TexParam> >::_Destroy
PUBLIC	??$unchecked_copy@PAUTexParam@ShaderContextPool@Ogre@@PAU123@@stdext@@YAPAUTexParam@ShaderContextPool@Ogre@@PAU123@00@Z ; stdext::unchecked_copy<Ogre::ShaderContextPool::TexParam *,Ogre::ShaderContextPool::TexParam *>
PUBLIC	?clear@?$vector@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@QAEXXZ ; std::vector<Ogre::ShaderContextPool::TexParam,std::allocator<Ogre::ShaderContextPool::TexParam> >::clear
; Function compile flags: /Odtp
;	COMDAT ??4?$vector@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
__Ptr$73013 = -8					; size = 4
__Ptr$73003 = -4					; size = 4
__Right$ = 8						; size = 4
??4?$vector@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z PROC ; std::vector<Ogre::ShaderContextPool::TexParam,std::allocator<Ogre::ShaderContextPool::TexParam> >::operator=, COMDAT
; _this$ = ecx

; 563  : 		{	// assign _Right

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 564  : 		if (this != &_Right)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR __Right$[ebp]
	je	$LN9@operator@20

; 565  : 			{	// worth doing
; 566  : 
; 567  :  #if _HAS_ITERATOR_DEBUGGING
; 568  : 			this->_Orphan_all();
; 569  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 570  : 
; 571  : 			if (_Right.size() == 0)

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::ShaderContextPool::TexParam,std::allocator<Ogre::ShaderContextPool::TexParam> >::size
	test	eax, eax
	jne	SHORT $LN8@operator@20

; 572  : 				clear();	// new sequence empty, erase existing sequence

	mov	ecx, DWORD PTR _this$[ebp]
	call	?clear@?$vector@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@QAEXXZ ; std::vector<Ogre::ShaderContextPool::TexParam,std::allocator<Ogre::ShaderContextPool::TexParam> >::clear
	jmp	$LN9@operator@20
$LN8@operator@20:

; 573  : 			else if (_Right.size() <= size())

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::ShaderContextPool::TexParam,std::allocator<Ogre::ShaderContextPool::TexParam> >::size
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::ShaderContextPool::TexParam,std::allocator<Ogre::ShaderContextPool::TexParam> >::size
	cmp	esi, eax
	ja	SHORT $LN6@operator@20

; 574  : 				{	// enough elements, copy new and destroy old
; 575  : 				pointer _Ptr = _STDEXT unchecked_copy(_Right._Myfirst, _Right._Mylast,
; 576  : 					_Myfirst);	// copy new

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	call	??$unchecked_copy@PAUTexParam@ShaderContextPool@Ogre@@PAU123@@stdext@@YAPAUTexParam@ShaderContextPool@Ogre@@PAU123@00@Z ; stdext::unchecked_copy<Ogre::ShaderContextPool::TexParam *,Ogre::ShaderContextPool::TexParam *>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR __Ptr$73003[ebp], eax

; 577  : 				_Destroy(_Ptr, _Mylast);	// destroy old

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR __Ptr$73003[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@IAEXPAUTexParam@ShaderContextPool@Ogre@@0@Z ; std::vector<Ogre::ShaderContextPool::TexParam,std::allocator<Ogre::ShaderContextPool::TexParam> >::_Destroy

; 578  : 				_Mylast = _Myfirst + _Right.size();

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::ShaderContextPool::TexParam,std::allocator<Ogre::ShaderContextPool::TexParam> >::size
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	lea	eax, DWORD PTR [edx+eax*8]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax
	jmp	$LN9@operator@20
$LN6@operator@20:

; 579  : 				}
; 580  : 			else if (_Right.size() <= capacity())

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::ShaderContextPool::TexParam,std::allocator<Ogre::ShaderContextPool::TexParam> >::size
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?capacity@?$vector@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::ShaderContextPool::TexParam,std::allocator<Ogre::ShaderContextPool::TexParam> >::capacity
	cmp	esi, eax
	ja	SHORT $LN4@operator@20

; 581  : 				{	// enough room, copy and construct new
; 582  : 				pointer _Ptr = _Right._Myfirst + size();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::ShaderContextPool::TexParam,std::allocator<Ogre::ShaderContextPool::TexParam> >::size
	mov	edx, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	lea	edx, DWORD PTR [ecx+eax*8]
	mov	DWORD PTR __Ptr$73013[ebp], edx

; 583  : 				_STDEXT unchecked_copy(_Right._Myfirst, _Ptr, _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	edx, DWORD PTR __Ptr$73013[ebp]
	push	edx
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	call	??$unchecked_copy@PAUTexParam@ShaderContextPool@Ogre@@PAU123@@stdext@@YAPAUTexParam@ShaderContextPool@Ogre@@PAU123@00@Z ; stdext::unchecked_copy<Ogre::ShaderContextPool::TexParam *,Ogre::ShaderContextPool::TexParam *>
	add	esp, 12					; 0000000cH

; 584  : 				_Mylast = _Ucopy(_Ptr, _Right._Mylast, _Mylast);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR __Ptr$73013[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Ucopy@PAUTexParam@ShaderContextPool@Ogre@@@?$vector@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@IAEPAUTexParam@ShaderContextPool@Ogre@@PAU234@00@Z ; std::vector<Ogre::ShaderContextPool::TexParam,std::allocator<Ogre::ShaderContextPool::TexParam> >::_Ucopy<Ogre::ShaderContextPool::TexParam *>
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 585  : 				}
; 586  : 			else

	jmp	SHORT $LN9@operator@20
$LN4@operator@20:

; 587  : 				{	// not enough room, allocate new array and construct new
; 588  : 				if (_Myfirst != 0)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+12], 0
	je	SHORT $LN2@operator@20

; 589  : 					{	// discard old array
; 590  : 					_Destroy(_Myfirst, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@IAEXPAUTexParam@ShaderContextPool@Ogre@@0@Z ; std::vector<Ogre::ShaderContextPool::TexParam,std::allocator<Ogre::ShaderContextPool::TexParam> >::_Destroy

; 591  : 					this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+20]
	sub	eax, DWORD PTR [edx+12]
	sar	eax, 3
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?deallocate@?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@QAEXPAUTexParam@ShaderContextPool@Ogre@@I@Z ; std::allocator<Ogre::ShaderContextPool::TexParam>::deallocate
$LN2@operator@20:

; 592  : 					}
; 593  : 				if (_Buy(_Right.size()))

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::ShaderContextPool::TexParam,std::allocator<Ogre::ShaderContextPool::TexParam> >::size
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@IAE_NI@Z ; std::vector<Ogre::ShaderContextPool::TexParam,std::allocator<Ogre::ShaderContextPool::TexParam> >::_Buy
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN9@operator@20

; 594  : 					_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 595  : 						_Myfirst);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Ucopy@PAUTexParam@ShaderContextPool@Ogre@@@?$vector@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@IAEPAUTexParam@ShaderContextPool@Ogre@@PAU234@00@Z ; std::vector<Ogre::ShaderContextPool::TexParam,std::allocator<Ogre::ShaderContextPool::TexParam> >::_Ucopy<Ogre::ShaderContextPool::TexParam *>
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax
$LN9@operator@20:

; 596  : 				}
; 597  : 			}
; 598  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 599  : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
??4?$vector@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z ENDP ; std::vector<Ogre::ShaderContextPool::TexParam,std::allocator<Ogre::ShaderContextPool::TexParam> >::operator=
_TEXT	ENDS
PUBLIC	?_Buy@?$vector@PAVMaterialParam@Ogre@@V?$allocator@PAVMaterialParam@Ogre@@@std@@@std@@IAE_NI@Z ; std::vector<Ogre::MaterialParam *,std::allocator<Ogre::MaterialParam *> >::_Buy
PUBLIC	?deallocate@?$allocator@PAVMaterialParam@Ogre@@@std@@QAEXPAPAVMaterialParam@Ogre@@I@Z ; std::allocator<Ogre::MaterialParam *>::deallocate
PUBLIC	??$_Ucopy@PAPAVMaterialParam@Ogre@@@?$vector@PAVMaterialParam@Ogre@@V?$allocator@PAVMaterialParam@Ogre@@@std@@@std@@IAEPAPAVMaterialParam@Ogre@@PAPAV23@00@Z ; std::vector<Ogre::MaterialParam *,std::allocator<Ogre::MaterialParam *> >::_Ucopy<Ogre::MaterialParam * *>
PUBLIC	?capacity@?$vector@PAVMaterialParam@Ogre@@V?$allocator@PAVMaterialParam@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::MaterialParam *,std::allocator<Ogre::MaterialParam *> >::capacity
PUBLIC	?_Destroy@?$vector@PAVMaterialParam@Ogre@@V?$allocator@PAVMaterialParam@Ogre@@@std@@@std@@IAEXPAPAVMaterialParam@Ogre@@0@Z ; std::vector<Ogre::MaterialParam *,std::allocator<Ogre::MaterialParam *> >::_Destroy
PUBLIC	??$unchecked_copy@PAPAVMaterialParam@Ogre@@PAPAV12@@stdext@@YAPAPAVMaterialParam@Ogre@@PAPAV12@00@Z ; stdext::unchecked_copy<Ogre::MaterialParam * *,Ogre::MaterialParam * *>
PUBLIC	?clear@?$vector@PAVMaterialParam@Ogre@@V?$allocator@PAVMaterialParam@Ogre@@@std@@@std@@QAEXXZ ; std::vector<Ogre::MaterialParam *,std::allocator<Ogre::MaterialParam *> >::clear
PUBLIC	?size@?$vector@PAVMaterialParam@Ogre@@V?$allocator@PAVMaterialParam@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::MaterialParam *,std::allocator<Ogre::MaterialParam *> >::size
; Function compile flags: /Odtp
;	COMDAT ??4?$vector@PAVMaterialParam@Ogre@@V?$allocator@PAVMaterialParam@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
__Ptr$73038 = -8					; size = 4
__Ptr$73028 = -4					; size = 4
__Right$ = 8						; size = 4
??4?$vector@PAVMaterialParam@Ogre@@V?$allocator@PAVMaterialParam@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z PROC ; std::vector<Ogre::MaterialParam *,std::allocator<Ogre::MaterialParam *> >::operator=, COMDAT
; _this$ = ecx

; 563  : 		{	// assign _Right

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 564  : 		if (this != &_Right)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR __Right$[ebp]
	je	$LN9@operator@21

; 565  : 			{	// worth doing
; 566  : 
; 567  :  #if _HAS_ITERATOR_DEBUGGING
; 568  : 			this->_Orphan_all();
; 569  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 570  : 
; 571  : 			if (_Right.size() == 0)

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@PAVMaterialParam@Ogre@@V?$allocator@PAVMaterialParam@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::MaterialParam *,std::allocator<Ogre::MaterialParam *> >::size
	test	eax, eax
	jne	SHORT $LN8@operator@21

; 572  : 				clear();	// new sequence empty, erase existing sequence

	mov	ecx, DWORD PTR _this$[ebp]
	call	?clear@?$vector@PAVMaterialParam@Ogre@@V?$allocator@PAVMaterialParam@Ogre@@@std@@@std@@QAEXXZ ; std::vector<Ogre::MaterialParam *,std::allocator<Ogre::MaterialParam *> >::clear
	jmp	$LN9@operator@21
$LN8@operator@21:

; 573  : 			else if (_Right.size() <= size())

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@PAVMaterialParam@Ogre@@V?$allocator@PAVMaterialParam@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::MaterialParam *,std::allocator<Ogre::MaterialParam *> >::size
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAVMaterialParam@Ogre@@V?$allocator@PAVMaterialParam@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::MaterialParam *,std::allocator<Ogre::MaterialParam *> >::size
	cmp	esi, eax
	ja	SHORT $LN6@operator@21

; 574  : 				{	// enough elements, copy new and destroy old
; 575  : 				pointer _Ptr = _STDEXT unchecked_copy(_Right._Myfirst, _Right._Mylast,
; 576  : 					_Myfirst);	// copy new

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	call	??$unchecked_copy@PAPAVMaterialParam@Ogre@@PAPAV12@@stdext@@YAPAPAVMaterialParam@Ogre@@PAPAV12@00@Z ; stdext::unchecked_copy<Ogre::MaterialParam * *,Ogre::MaterialParam * *>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR __Ptr$73028[ebp], eax

; 577  : 				_Destroy(_Ptr, _Mylast);	// destroy old

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR __Ptr$73028[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@PAVMaterialParam@Ogre@@V?$allocator@PAVMaterialParam@Ogre@@@std@@@std@@IAEXPAPAVMaterialParam@Ogre@@0@Z ; std::vector<Ogre::MaterialParam *,std::allocator<Ogre::MaterialParam *> >::_Destroy

; 578  : 				_Mylast = _Myfirst + _Right.size();

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@PAVMaterialParam@Ogre@@V?$allocator@PAVMaterialParam@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::MaterialParam *,std::allocator<Ogre::MaterialParam *> >::size
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	lea	eax, DWORD PTR [edx+eax*4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax
	jmp	$LN9@operator@21
$LN6@operator@21:

; 579  : 				}
; 580  : 			else if (_Right.size() <= capacity())

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@PAVMaterialParam@Ogre@@V?$allocator@PAVMaterialParam@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::MaterialParam *,std::allocator<Ogre::MaterialParam *> >::size
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?capacity@?$vector@PAVMaterialParam@Ogre@@V?$allocator@PAVMaterialParam@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::MaterialParam *,std::allocator<Ogre::MaterialParam *> >::capacity
	cmp	esi, eax
	ja	SHORT $LN4@operator@21

; 581  : 				{	// enough room, copy and construct new
; 582  : 				pointer _Ptr = _Right._Myfirst + size();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAVMaterialParam@Ogre@@V?$allocator@PAVMaterialParam@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::MaterialParam *,std::allocator<Ogre::MaterialParam *> >::size
	mov	edx, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR __Ptr$73038[ebp], edx

; 583  : 				_STDEXT unchecked_copy(_Right._Myfirst, _Ptr, _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	edx, DWORD PTR __Ptr$73038[ebp]
	push	edx
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	call	??$unchecked_copy@PAPAVMaterialParam@Ogre@@PAPAV12@@stdext@@YAPAPAVMaterialParam@Ogre@@PAPAV12@00@Z ; stdext::unchecked_copy<Ogre::MaterialParam * *,Ogre::MaterialParam * *>
	add	esp, 12					; 0000000cH

; 584  : 				_Mylast = _Ucopy(_Ptr, _Right._Mylast, _Mylast);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR __Ptr$73038[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Ucopy@PAPAVMaterialParam@Ogre@@@?$vector@PAVMaterialParam@Ogre@@V?$allocator@PAVMaterialParam@Ogre@@@std@@@std@@IAEPAPAVMaterialParam@Ogre@@PAPAV23@00@Z ; std::vector<Ogre::MaterialParam *,std::allocator<Ogre::MaterialParam *> >::_Ucopy<Ogre::MaterialParam * *>
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 585  : 				}
; 586  : 			else

	jmp	SHORT $LN9@operator@21
$LN4@operator@21:

; 587  : 				{	// not enough room, allocate new array and construct new
; 588  : 				if (_Myfirst != 0)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+12], 0
	je	SHORT $LN2@operator@21

; 589  : 					{	// discard old array
; 590  : 					_Destroy(_Myfirst, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@PAVMaterialParam@Ogre@@V?$allocator@PAVMaterialParam@Ogre@@@std@@@std@@IAEXPAPAVMaterialParam@Ogre@@0@Z ; std::vector<Ogre::MaterialParam *,std::allocator<Ogre::MaterialParam *> >::_Destroy

; 591  : 					this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+20]
	sub	eax, DWORD PTR [edx+12]
	sar	eax, 2
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?deallocate@?$allocator@PAVMaterialParam@Ogre@@@std@@QAEXPAPAVMaterialParam@Ogre@@I@Z ; std::allocator<Ogre::MaterialParam *>::deallocate
$LN2@operator@21:

; 592  : 					}
; 593  : 				if (_Buy(_Right.size()))

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@PAVMaterialParam@Ogre@@V?$allocator@PAVMaterialParam@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::MaterialParam *,std::allocator<Ogre::MaterialParam *> >::size
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@PAVMaterialParam@Ogre@@V?$allocator@PAVMaterialParam@Ogre@@@std@@@std@@IAE_NI@Z ; std::vector<Ogre::MaterialParam *,std::allocator<Ogre::MaterialParam *> >::_Buy
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN9@operator@21

; 594  : 					_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 595  : 						_Myfirst);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Ucopy@PAPAVMaterialParam@Ogre@@@?$vector@PAVMaterialParam@Ogre@@V?$allocator@PAVMaterialParam@Ogre@@@std@@@std@@IAEPAPAVMaterialParam@Ogre@@PAPAV23@00@Z ; std::vector<Ogre::MaterialParam *,std::allocator<Ogre::MaterialParam *> >::_Ucopy<Ogre::MaterialParam * *>
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax
$LN9@operator@21:

; 596  : 				}
; 597  : 			}
; 598  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 599  : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
??4?$vector@PAVMaterialParam@Ogre@@V?$allocator@PAVMaterialParam@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z ENDP ; std::vector<Ogre::MaterialParam *,std::allocator<Ogre::MaterialParam *> >::operator=
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogrerect.h
_TEXT	ENDS
;	COMDAT ??0?$TBox@H@Ogre@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$TBox@H@Ogre@@QAE@XZ PROC				; Ogre::TBox<int>::TBox<int>, COMDAT
; _this$ = ecx

; 68   : 		TBox(){}

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$TBox@H@Ogre@@QAE@XZ ENDP				; Ogre::TBox<int>::TBox<int>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0?$TBox@H@Ogre@@QAE@HHHHHH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_left$ = 8						; size = 4
_top$ = 12						; size = 4
_front$ = 16						; size = 4
_right$ = 20						; size = 4
_bottom$ = 24						; size = 4
_back$ = 28						; size = 4
??0?$TBox@H@Ogre@@QAE@HHHHHH@Z PROC			; Ogre::TBox<int>::TBox<int>, COMDAT
; _this$ = ecx

; 70   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _left$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _top$[ebp]
	mov	DWORD PTR [edx+4], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _front$[ebp]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _right$[ebp]
	mov	DWORD PTR [eax+12], ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _bottom$[ebp]
	mov	DWORD PTR [edx+16], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _back$[ebp]
	mov	DWORD PTR [ecx+20], edx

; 71   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
??0?$TBox@H@Ogre@@QAE@HHHHHH@Z ENDP			; Ogre::TBox<int>::TBox<int>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?getWidth@?$TBox@H@Ogre@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getWidth@?$TBox@H@Ogre@@QBEHXZ PROC			; Ogre::TBox<int>::getWidth, COMDAT
; _this$ = ecx

; 73   : 		T getWidth() const{ return m_Right-m_Left; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+12]
	sub	eax, DWORD PTR [ecx]
	mov	esp, ebp
	pop	ebp
	ret	0
?getWidth@?$TBox@H@Ogre@@QBEHXZ ENDP			; Ogre::TBox<int>::getWidth
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?getHeight@?$TBox@H@Ogre@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getHeight@?$TBox@H@Ogre@@QBEHXZ PROC			; Ogre::TBox<int>::getHeight, COMDAT
; _this$ = ecx

; 74   : 		T getHeight() const{ return m_Bottom-m_Top; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+16]
	sub	eax, DWORD PTR [ecx+4]
	mov	esp, ebp
	pop	ebp
	ret	0
?getHeight@?$TBox@H@Ogre@@QBEHXZ ENDP			; Ogre::TBox<int>::getHeight
_TEXT	ENDS
PUBLIC	?getDepth@?$TBox@H@Ogre@@QBEHXZ			; Ogre::TBox<int>::getDepth
; Function compile flags: /Odtp
;	COMDAT ?getDepth@?$TBox@H@Ogre@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getDepth@?$TBox@H@Ogre@@QBEHXZ PROC			; Ogre::TBox<int>::getDepth, COMDAT
; _this$ = ecx

; 75   : 		T getDepth() const{ return m_Back-m_Front; }

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+20]
	sub	eax, DWORD PTR [ecx+8]
	mov	esp, ebp
	pop	ebp
	ret	0
?getDepth@?$TBox@H@Ogre@@QBEHXZ ENDP			; Ogre::TBox<int>::getDepth
_TEXT	ENDS
PUBLIC	?contains@?$TBox@H@Ogre@@QBE_NABV12@@Z		; Ogre::TBox<int>::contains
; Function compile flags: /Odtp
;	COMDAT ?contains@?$TBox@H@Ogre@@QBE_NABV12@@Z
_TEXT	SEGMENT
tv80 = -8						; size = 4
_this$ = -4						; size = 4
_def$ = 8						; size = 4
?contains@?$TBox@H@Ogre@@QBE_NABV12@@Z PROC		; Ogre::TBox<int>::contains, COMDAT
; _this$ = ecx

; 78   : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 79   : 			return (def.m_Left >= m_Left && def.m_Top >= m_Top && def.m_Front >= m_Front &&
; 80   : 				def.m_Right <= m_Right && def.m_Bottom <= m_Bottom && def.m_Back <= m_Back);

	mov	eax, DWORD PTR _def$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx]
	jl	SHORT $LN3@contains
	mov	eax, DWORD PTR _def$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+4]
	cmp	edx, DWORD PTR [ecx+4]
	jl	SHORT $LN3@contains
	mov	eax, DWORD PTR _def$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	cmp	edx, DWORD PTR [ecx+8]
	jl	SHORT $LN3@contains
	mov	eax, DWORD PTR _def$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+12]
	cmp	edx, DWORD PTR [ecx+12]
	jg	SHORT $LN3@contains
	mov	eax, DWORD PTR _def$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+16]
	cmp	edx, DWORD PTR [ecx+16]
	jg	SHORT $LN3@contains
	mov	eax, DWORD PTR _def$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+20]
	cmp	edx, DWORD PTR [ecx+20]
	jg	SHORT $LN3@contains
	mov	DWORD PTR tv80[ebp], 1
	jmp	SHORT $LN4@contains
$LN3@contains:
	mov	DWORD PTR tv80[ebp], 0
$LN4@contains:
	mov	al, BYTE PTR tv80[ebp]

; 81   : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?contains@?$TBox@H@Ogre@@QBE_NABV12@@Z ENDP		; Ogre::TBox<int>::contains
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@DV?$allocator@D@std@@@std@@QAE@XZ ; std::_Vector_val<char,std::allocator<char> >::~_Vector_val<char,std::allocator<char> >
PUBLIC	?_Tidy@?$vector@DV?$allocator@D@std@@@std@@IAEXXZ ; std::vector<char,std::allocator<char> >::_Tidy
PUBLIC	??$_Ucopy@V?$_Vector_const_iterator@DV?$allocator@D@std@@@std@@@?$vector@DV?$allocator@D@std@@@std@@IAEPADV?$_Vector_const_iterator@DV?$allocator@D@std@@@1@0PAD@Z ; std::vector<char,std::allocator<char> >::_Ucopy<std::_Vector_const_iterator<char,std::allocator<char> > >
PUBLIC	?begin@?$vector@DV?$allocator@D@std@@@std@@QBE?AV?$_Vector_const_iterator@DV?$allocator@D@std@@@2@XZ ; std::vector<char,std::allocator<char> >::begin
PUBLIC	?end@?$vector@DV?$allocator@D@std@@@std@@QBE?AV?$_Vector_const_iterator@DV?$allocator@D@std@@@2@XZ ; std::vector<char,std::allocator<char> >::end
PUBLIC	?_Buy@?$vector@DV?$allocator@D@std@@@std@@IAE_NI@Z ; std::vector<char,std::allocator<char> >::_Buy
PUBLIC	?size@?$vector@DV?$allocator@D@std@@@std@@QBEIXZ ; std::vector<char,std::allocator<char> >::size
PUBLIC	??0?$_Vector_val@DV?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z ; std::_Vector_val<char,std::allocator<char> >::_Vector_val<char,std::allocator<char> >
EXTRN	__imp_??0?$allocator@D@std@@QAE@ABV01@@Z:PROC
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	SEGMENT
__catchsym$??0?$vector@DV?$allocator@D@std@@@std@@QAE@ABV01@@Z$3 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??0?$vector@DV?$allocator@D@std@@@std@@QAE@ABV01@@Z$0
__tryblocktable$??0?$vector@DV?$allocator@D@std@@@std@@QAE@ABV01@@Z DD 01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??0?$vector@DV?$allocator@D@std@@@std@@QAE@ABV01@@Z$3
__unwindtable$??0?$vector@DV?$allocator@D@std@@@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@DV?$allocator@D@std@@@std@@QAE@ABV01@@Z$2
	DD	00H
	DD	00H
	DD	00H
	DD	00H
__ehfuncinfo$??0?$vector@DV?$allocator@D@std@@@std@@QAE@ABV01@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0?$vector@DV?$allocator@D@std@@@std@@QAE@ABV01@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??0?$vector@DV?$allocator@D@std@@@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$vector@DV?$allocator@D@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -40						; size = 4
$T95148 = -36						; size = 8
$T95147 = -28						; size = 8
$T95146 = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Right$ = 8						; size = 4
??0?$vector@DV?$allocator@D@std@@@std@@QAE@ABV01@@Z PROC ; std::vector<char,std::allocator<char> >::vector<char,std::allocator<char> >, COMDAT
; _this$ = ecx

; 500  : 		{	// construct by copying _Right

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$vector@DV?$allocator@D@std@@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 24					; 00000018H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Right$[ebp]
	add	eax, 8
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T95146[ebp], esp
	push	eax
	call	DWORD PTR __imp_??0?$allocator@D@std@@QAE@ABV01@@Z
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_val@DV?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z ; std::_Vector_val<char,std::allocator<char> >::_Vector_val<char,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 501  : 		if (_Buy(_Right.size()))

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@DV?$allocator@D@std@@@std@@QBEIXZ ; std::vector<char,std::allocator<char> >::size
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@DV?$allocator@D@std@@@std@@IAE_NI@Z ; std::vector<char,std::allocator<char> >::_Buy
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN3@vector@38

; 502  : 			_TRY_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 1

; 503  : 			_Mylast = _Ucopy(_Right.begin(), _Right.end(), _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	lea	ecx, DWORD PTR $T95147[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?end@?$vector@DV?$allocator@D@std@@@std@@QBE?AV?$_Vector_const_iterator@DV?$allocator@D@std@@@2@XZ ; std::vector<char,std::allocator<char> >::end
	mov	edx, DWORD PTR [eax+4]
	push	edx
	mov	eax, DWORD PTR [eax]
	push	eax
	lea	ecx, DWORD PTR $T95148[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?begin@?$vector@DV?$allocator@D@std@@@std@@QBE?AV?$_Vector_const_iterator@DV?$allocator@D@std@@@2@XZ ; std::vector<char,std::allocator<char> >::begin
	mov	edx, DWORD PTR [eax+4]
	push	edx
	mov	eax, DWORD PTR [eax]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Ucopy@V?$_Vector_const_iterator@DV?$allocator@D@std@@@std@@@?$vector@DV?$allocator@D@std@@@std@@IAEPADV?$_Vector_const_iterator@DV?$allocator@D@std@@@1@0PAD@Z ; std::vector<char,std::allocator<char> >::_Ucopy<std::_Vector_const_iterator<char,std::allocator<char> > >
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax
	jmp	SHORT $LN5@vector@38
__catch$??0?$vector@DV?$allocator@D@std@@@std@@QAE@ABV01@@Z$0:

; 504  : 			_CATCH_ALL
; 505  : 			_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@DV?$allocator@D@std@@@std@@IAEXXZ ; std::vector<char,std::allocator<char> >::_Tidy

; 506  : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 507  : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], 0
	mov	eax, $LN3@vector@38
	ret	0
$LN5@vector@38:
	mov	DWORD PTR __$EHRec$[ebp+12], 0
$LN3@vector@38:

; 508  : 		}

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector@38:
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@DV?$allocator@D@std@@@std@@QAE@ABV01@@Z$2:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@DV?$allocator@D@std@@@std@@QAE@XZ
__ehhandler$??0?$vector@DV?$allocator@D@std@@@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-44]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@DV?$allocator@D@std@@@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@DV?$allocator@D@std@@@std@@QAE@ABV01@@Z ENDP ; std::vector<char,std::allocator<char> >::vector<char,std::allocator<char> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$vector@DV?$allocator@D@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$vector@DV?$allocator@D@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$vector@DV?$allocator@D@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$vector@DV?$allocator@D@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$vector@DV?$allocator@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$vector@DV?$allocator@D@std@@@std@@QAE@XZ PROC	; std::vector<char,std::allocator<char> >::~vector<char,std::allocator<char> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$vector@DV?$allocator@D@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 559  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@DV?$allocator@D@std@@@std@@IAEXXZ ; std::vector<char,std::allocator<char> >::_Tidy

; 560  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Vector_val@DV?$allocator@D@std@@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$vector@DV?$allocator@D@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@DV?$allocator@D@std@@@std@@QAE@XZ
__ehhandler$??1?$vector@DV?$allocator@D@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$vector@DV?$allocator@D@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$vector@DV?$allocator@D@std@@@std@@QAE@XZ ENDP	; std::vector<char,std::allocator<char> >::~vector<char,std::allocator<char> >
PUBLIC	??$_Ucopy@PAD@?$vector@DV?$allocator@D@std@@@std@@IAEPADPAD00@Z ; std::vector<char,std::allocator<char> >::_Ucopy<char *>
PUBLIC	?capacity@?$vector@DV?$allocator@D@std@@@std@@QBEIXZ ; std::vector<char,std::allocator<char> >::capacity
PUBLIC	?_Destroy@?$vector@DV?$allocator@D@std@@@std@@IAEXPAD0@Z ; std::vector<char,std::allocator<char> >::_Destroy
PUBLIC	??$unchecked_copy@PADPAD@stdext@@YAPADPAD00@Z	; stdext::unchecked_copy<char *,char *>
PUBLIC	?clear@?$vector@DV?$allocator@D@std@@@std@@QAEXXZ ; std::vector<char,std::allocator<char> >::clear
EXTRN	__imp_?deallocate@?$allocator@D@std@@QAEXPADI@Z:PROC
; Function compile flags: /Odtp
;	COMDAT ??4?$vector@DV?$allocator@D@std@@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
__Ptr$73199 = -8					; size = 4
__Ptr$73189 = -4					; size = 4
__Right$ = 8						; size = 4
??4?$vector@DV?$allocator@D@std@@@std@@QAEAAV01@ABV01@@Z PROC ; std::vector<char,std::allocator<char> >::operator=, COMDAT
; _this$ = ecx

; 563  : 		{	// assign _Right

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 564  : 		if (this != &_Right)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR __Right$[ebp]
	je	$LN9@operator@22

; 565  : 			{	// worth doing
; 566  : 
; 567  :  #if _HAS_ITERATOR_DEBUGGING
; 568  : 			this->_Orphan_all();
; 569  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 570  : 
; 571  : 			if (_Right.size() == 0)

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@DV?$allocator@D@std@@@std@@QBEIXZ ; std::vector<char,std::allocator<char> >::size
	test	eax, eax
	jne	SHORT $LN8@operator@22

; 572  : 				clear();	// new sequence empty, erase existing sequence

	mov	ecx, DWORD PTR _this$[ebp]
	call	?clear@?$vector@DV?$allocator@D@std@@@std@@QAEXXZ ; std::vector<char,std::allocator<char> >::clear
	jmp	$LN9@operator@22
$LN8@operator@22:

; 573  : 			else if (_Right.size() <= size())

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@DV?$allocator@D@std@@@std@@QBEIXZ ; std::vector<char,std::allocator<char> >::size
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@DV?$allocator@D@std@@@std@@QBEIXZ ; std::vector<char,std::allocator<char> >::size
	cmp	esi, eax
	ja	SHORT $LN6@operator@22

; 574  : 				{	// enough elements, copy new and destroy old
; 575  : 				pointer _Ptr = _STDEXT unchecked_copy(_Right._Myfirst, _Right._Mylast,
; 576  : 					_Myfirst);	// copy new

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	call	??$unchecked_copy@PADPAD@stdext@@YAPADPAD00@Z ; stdext::unchecked_copy<char *,char *>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR __Ptr$73189[ebp], eax

; 577  : 				_Destroy(_Ptr, _Mylast);	// destroy old

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR __Ptr$73189[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@DV?$allocator@D@std@@@std@@IAEXPAD0@Z ; std::vector<char,std::allocator<char> >::_Destroy

; 578  : 				_Mylast = _Myfirst + _Right.size();

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@DV?$allocator@D@std@@@std@@QBEIXZ ; std::vector<char,std::allocator<char> >::size
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+12]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+16], eax
	jmp	$LN9@operator@22
$LN6@operator@22:

; 579  : 				}
; 580  : 			else if (_Right.size() <= capacity())

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@DV?$allocator@D@std@@@std@@QBEIXZ ; std::vector<char,std::allocator<char> >::size
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?capacity@?$vector@DV?$allocator@D@std@@@std@@QBEIXZ ; std::vector<char,std::allocator<char> >::capacity
	cmp	esi, eax
	ja	SHORT $LN4@operator@22

; 581  : 				{	// enough room, copy and construct new
; 582  : 				pointer _Ptr = _Right._Myfirst + size();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@DV?$allocator@D@std@@@std@@QBEIXZ ; std::vector<char,std::allocator<char> >::size
	mov	ecx, DWORD PTR __Right$[ebp]
	add	eax, DWORD PTR [ecx+12]
	mov	DWORD PTR __Ptr$73199[ebp], eax

; 583  : 				_STDEXT unchecked_copy(_Right._Myfirst, _Ptr, _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR __Ptr$73199[ebp]
	push	ecx
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	call	??$unchecked_copy@PADPAD@stdext@@YAPADPAD00@Z ; stdext::unchecked_copy<char *,char *>
	add	esp, 12					; 0000000cH

; 584  : 				_Mylast = _Ucopy(_Ptr, _Right._Mylast, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Ptr$73199[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Ucopy@PAD@?$vector@DV?$allocator@D@std@@@std@@IAEPADPAD00@Z ; std::vector<char,std::allocator<char> >::_Ucopy<char *>
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 585  : 				}
; 586  : 			else

	jmp	SHORT $LN9@operator@22
$LN4@operator@22:

; 587  : 				{	// not enough room, allocate new array and construct new
; 588  : 				if (_Myfirst != 0)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+12], 0
	je	SHORT $LN2@operator@22

; 589  : 					{	// discard old array
; 590  : 					_Destroy(_Myfirst, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@DV?$allocator@D@std@@@std@@IAEXPAD0@Z ; std::vector<char,std::allocator<char> >::_Destroy

; 591  : 					this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+20]
	sub	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	DWORD PTR __imp_?deallocate@?$allocator@D@std@@QAEXPADI@Z
$LN2@operator@22:

; 592  : 					}
; 593  : 				if (_Buy(_Right.size()))

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@DV?$allocator@D@std@@@std@@QBEIXZ ; std::vector<char,std::allocator<char> >::size
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@DV?$allocator@D@std@@@std@@IAE_NI@Z ; std::vector<char,std::allocator<char> >::_Buy
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN9@operator@22

; 594  : 					_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 595  : 						_Myfirst);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Ucopy@PAD@?$vector@DV?$allocator@D@std@@@std@@IAEPADPAD00@Z ; std::vector<char,std::allocator<char> >::_Ucopy<char *>
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax
$LN9@operator@22:

; 596  : 				}
; 597  : 			}
; 598  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 599  : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
??4?$vector@DV?$allocator@D@std@@@std@@QAEAAV01@ABV01@@Z ENDP ; std::vector<char,std::allocator<char> >::operator=
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??A?$vector@DV?$allocator@D@std@@@std@@QAEAADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pos$ = 8						; size = 4
??A?$vector@DV?$allocator@D@std@@@std@@QAEAADI@Z PROC	; std::vector<char,std::allocator<char> >::operator[], COMDAT
; _this$ = ecx

; 774  : 		{	// subscript mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)
; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");
; 780  : 			_SCL_SECURE_OUT_OF_RANGE;
; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@DV?$allocator@D@std@@@std@@QBEIXZ ; std::vector<char,std::allocator<char> >::size
	cmp	DWORD PTR __Pos$[ebp], eax
	jb	SHORT $LN1@operator@23
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN1@operator@23:

; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+12]
	add	eax, DWORD PTR __Pos$[ebp]

; 786  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??A?$vector@DV?$allocator@D@std@@@std@@QAEAADI@Z ENDP	; std::vector<char,std::allocator<char> >::operator[]
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE@XZ ; std::_Vector_val<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::~_Vector_val<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >
PUBLIC	?_Tidy@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAEXXZ ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::_Tidy
PUBLIC	??$_Ucopy@V?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAEPAPAVSurfaceData@Ogre@@V?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@1@0PAPAV23@@Z ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::_Ucopy<std::_Vector_const_iterator<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> > >
PUBLIC	?begin@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@2@XZ ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::begin
PUBLIC	?end@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@2@XZ ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::end
PUBLIC	?_Buy@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAE_NI@Z ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::_Buy
PUBLIC	?size@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::size
PUBLIC	??0?$_Vector_val@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAE@V?$allocator@PAVSurfaceData@Ogre@@@1@@Z ; std::_Vector_val<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::_Vector_val<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >
PUBLIC	??0?$allocator@PAVSurfaceData@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::SurfaceData *>::allocator<Ogre::SurfaceData *>
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??0?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE@ABV01@@Z$3 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??0?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE@ABV01@@Z$0
__tryblocktable$??0?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE@ABV01@@Z DD 01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??0?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE@ABV01@@Z$3
__unwindtable$??0?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE@ABV01@@Z$2
	DD	00H
	DD	00H
	DD	00H
	DD	00H
__ehfuncinfo$??0?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE@ABV01@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE@ABV01@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??0?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -40						; size = 4
$T95180 = -36						; size = 8
$T95179 = -28						; size = 8
$T95178 = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Right$ = 8						; size = 4
??0?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE@ABV01@@Z PROC ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >, COMDAT
; _this$ = ecx

; 500  : 		{	// construct by copying _Right

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 24					; 00000018H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Right$[ebp]
	add	eax, 8
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T95178[ebp], esp
	push	eax
	call	??0?$allocator@PAVSurfaceData@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::SurfaceData *>::allocator<Ogre::SurfaceData *>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_val@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAE@V?$allocator@PAVSurfaceData@Ogre@@@1@@Z ; std::_Vector_val<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::_Vector_val<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >
	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 501  : 		if (_Buy(_Right.size()))

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::size
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAE_NI@Z ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::_Buy
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN3@vector@39

; 502  : 			_TRY_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 1

; 503  : 			_Mylast = _Ucopy(_Right.begin(), _Right.end(), _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	lea	ecx, DWORD PTR $T95179[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?end@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@2@XZ ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::end
	mov	edx, DWORD PTR [eax+4]
	push	edx
	mov	eax, DWORD PTR [eax]
	push	eax
	lea	ecx, DWORD PTR $T95180[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?begin@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@2@XZ ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::begin
	mov	edx, DWORD PTR [eax+4]
	push	edx
	mov	eax, DWORD PTR [eax]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Ucopy@V?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAEPAPAVSurfaceData@Ogre@@V?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@1@0PAPAV23@@Z ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::_Ucopy<std::_Vector_const_iterator<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> > >
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax
	jmp	SHORT $LN5@vector@39
__catch$??0?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE@ABV01@@Z$0:

; 504  : 			_CATCH_ALL
; 505  : 			_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAEXXZ ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::_Tidy

; 506  : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 507  : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], 0
	mov	eax, $LN3@vector@39
	ret	0
$LN5@vector@39:
	mov	DWORD PTR __$EHRec$[ebp+12], 0
$LN3@vector@39:

; 508  : 		}

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector@39:
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE@ABV01@@Z$2:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE@XZ
__ehhandler$??0?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-44]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE@XZ PROC ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::~vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 559  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAEXXZ ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::_Tidy

; 560  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Vector_val@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE@XZ
__ehhandler$??1?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE@XZ ENDP ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::~vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >
PUBLIC	?deallocate@?$allocator@PAVSurfaceData@Ogre@@@std@@QAEXPAPAVSurfaceData@Ogre@@I@Z ; std::allocator<Ogre::SurfaceData *>::deallocate
PUBLIC	??$_Ucopy@PAPAVSurfaceData@Ogre@@@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAEPAPAVSurfaceData@Ogre@@PAPAV23@00@Z ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::_Ucopy<Ogre::SurfaceData * *>
PUBLIC	?capacity@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::capacity
PUBLIC	?_Destroy@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAEXPAPAVSurfaceData@Ogre@@0@Z ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::_Destroy
PUBLIC	??$unchecked_copy@PAPAVSurfaceData@Ogre@@PAPAV12@@stdext@@YAPAPAVSurfaceData@Ogre@@PAPAV12@00@Z ; stdext::unchecked_copy<Ogre::SurfaceData * *,Ogre::SurfaceData * *>
PUBLIC	?clear@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAEXXZ ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::clear
; Function compile flags: /Odtp
;	COMDAT ??4?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
__Ptr$73357 = -8					; size = 4
__Ptr$73347 = -4					; size = 4
__Right$ = 8						; size = 4
??4?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z PROC ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::operator=, COMDAT
; _this$ = ecx

; 563  : 		{	// assign _Right

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 564  : 		if (this != &_Right)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR __Right$[ebp]
	je	$LN9@operator@24

; 565  : 			{	// worth doing
; 566  : 
; 567  :  #if _HAS_ITERATOR_DEBUGGING
; 568  : 			this->_Orphan_all();
; 569  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 570  : 
; 571  : 			if (_Right.size() == 0)

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::size
	test	eax, eax
	jne	SHORT $LN8@operator@24

; 572  : 				clear();	// new sequence empty, erase existing sequence

	mov	ecx, DWORD PTR _this$[ebp]
	call	?clear@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAEXXZ ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::clear
	jmp	$LN9@operator@24
$LN8@operator@24:

; 573  : 			else if (_Right.size() <= size())

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::size
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::size
	cmp	esi, eax
	ja	SHORT $LN6@operator@24

; 574  : 				{	// enough elements, copy new and destroy old
; 575  : 				pointer _Ptr = _STDEXT unchecked_copy(_Right._Myfirst, _Right._Mylast,
; 576  : 					_Myfirst);	// copy new

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	call	??$unchecked_copy@PAPAVSurfaceData@Ogre@@PAPAV12@@stdext@@YAPAPAVSurfaceData@Ogre@@PAPAV12@00@Z ; stdext::unchecked_copy<Ogre::SurfaceData * *,Ogre::SurfaceData * *>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR __Ptr$73347[ebp], eax

; 577  : 				_Destroy(_Ptr, _Mylast);	// destroy old

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR __Ptr$73347[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAEXPAPAVSurfaceData@Ogre@@0@Z ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::_Destroy

; 578  : 				_Mylast = _Myfirst + _Right.size();

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::size
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	lea	eax, DWORD PTR [edx+eax*4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax
	jmp	$LN9@operator@24
$LN6@operator@24:

; 579  : 				}
; 580  : 			else if (_Right.size() <= capacity())

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::size
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?capacity@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::capacity
	cmp	esi, eax
	ja	SHORT $LN4@operator@24

; 581  : 				{	// enough room, copy and construct new
; 582  : 				pointer _Ptr = _Right._Myfirst + size();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::size
	mov	edx, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR __Ptr$73357[ebp], edx

; 583  : 				_STDEXT unchecked_copy(_Right._Myfirst, _Ptr, _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	edx, DWORD PTR __Ptr$73357[ebp]
	push	edx
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	call	??$unchecked_copy@PAPAVSurfaceData@Ogre@@PAPAV12@@stdext@@YAPAPAVSurfaceData@Ogre@@PAPAV12@00@Z ; stdext::unchecked_copy<Ogre::SurfaceData * *,Ogre::SurfaceData * *>
	add	esp, 12					; 0000000cH

; 584  : 				_Mylast = _Ucopy(_Ptr, _Right._Mylast, _Mylast);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR __Ptr$73357[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Ucopy@PAPAVSurfaceData@Ogre@@@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAEPAPAVSurfaceData@Ogre@@PAPAV23@00@Z ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::_Ucopy<Ogre::SurfaceData * *>
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 585  : 				}
; 586  : 			else

	jmp	SHORT $LN9@operator@24
$LN4@operator@24:

; 587  : 				{	// not enough room, allocate new array and construct new
; 588  : 				if (_Myfirst != 0)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+12], 0
	je	SHORT $LN2@operator@24

; 589  : 					{	// discard old array
; 590  : 					_Destroy(_Myfirst, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAEXPAPAVSurfaceData@Ogre@@0@Z ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::_Destroy

; 591  : 					this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+20]
	sub	eax, DWORD PTR [edx+12]
	sar	eax, 2
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?deallocate@?$allocator@PAVSurfaceData@Ogre@@@std@@QAEXPAPAVSurfaceData@Ogre@@I@Z ; std::allocator<Ogre::SurfaceData *>::deallocate
$LN2@operator@24:

; 592  : 					}
; 593  : 				if (_Buy(_Right.size()))

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::size
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAE_NI@Z ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::_Buy
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN9@operator@24

; 594  : 					_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 595  : 						_Myfirst);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Ucopy@PAPAVSurfaceData@Ogre@@@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAEPAPAVSurfaceData@Ogre@@PAPAV23@00@Z ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::_Ucopy<Ogre::SurfaceData * *>
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax
$LN9@operator@24:

; 596  : 				}
; 597  : 			}
; 598  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 599  : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
??4?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z ENDP ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::operator=
_TEXT	ENDS
PUBLIC	?_Buy@?$vector@GV?$allocator@G@std@@@std@@IAE_NI@Z ; std::vector<unsigned short,std::allocator<unsigned short> >::_Buy
PUBLIC	?deallocate@?$allocator@G@std@@QAEXPAGI@Z	; std::allocator<unsigned short>::deallocate
PUBLIC	??$_Ucopy@PAG@?$vector@GV?$allocator@G@std@@@std@@IAEPAGPAG00@Z ; std::vector<unsigned short,std::allocator<unsigned short> >::_Ucopy<unsigned short *>
PUBLIC	?capacity@?$vector@GV?$allocator@G@std@@@std@@QBEIXZ ; std::vector<unsigned short,std::allocator<unsigned short> >::capacity
PUBLIC	?_Destroy@?$vector@GV?$allocator@G@std@@@std@@IAEXPAG0@Z ; std::vector<unsigned short,std::allocator<unsigned short> >::_Destroy
PUBLIC	??$unchecked_copy@PAGPAG@stdext@@YAPAGPAG00@Z	; stdext::unchecked_copy<unsigned short *,unsigned short *>
PUBLIC	?clear@?$vector@GV?$allocator@G@std@@@std@@QAEXXZ ; std::vector<unsigned short,std::allocator<unsigned short> >::clear
; Function compile flags: /Odtp
;	COMDAT ??4?$vector@GV?$allocator@G@std@@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
__Ptr$73382 = -8					; size = 4
__Ptr$73372 = -4					; size = 4
__Right$ = 8						; size = 4
??4?$vector@GV?$allocator@G@std@@@std@@QAEAAV01@ABV01@@Z PROC ; std::vector<unsigned short,std::allocator<unsigned short> >::operator=, COMDAT
; _this$ = ecx

; 563  : 		{	// assign _Right

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 564  : 		if (this != &_Right)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR __Right$[ebp]
	je	$LN9@operator@25

; 565  : 			{	// worth doing
; 566  : 
; 567  :  #if _HAS_ITERATOR_DEBUGGING
; 568  : 			this->_Orphan_all();
; 569  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 570  : 
; 571  : 			if (_Right.size() == 0)

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@GV?$allocator@G@std@@@std@@QBEIXZ ; std::vector<unsigned short,std::allocator<unsigned short> >::size
	test	eax, eax
	jne	SHORT $LN8@operator@25

; 572  : 				clear();	// new sequence empty, erase existing sequence

	mov	ecx, DWORD PTR _this$[ebp]
	call	?clear@?$vector@GV?$allocator@G@std@@@std@@QAEXXZ ; std::vector<unsigned short,std::allocator<unsigned short> >::clear
	jmp	$LN9@operator@25
$LN8@operator@25:

; 573  : 			else if (_Right.size() <= size())

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@GV?$allocator@G@std@@@std@@QBEIXZ ; std::vector<unsigned short,std::allocator<unsigned short> >::size
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@GV?$allocator@G@std@@@std@@QBEIXZ ; std::vector<unsigned short,std::allocator<unsigned short> >::size
	cmp	esi, eax
	ja	SHORT $LN6@operator@25

; 574  : 				{	// enough elements, copy new and destroy old
; 575  : 				pointer _Ptr = _STDEXT unchecked_copy(_Right._Myfirst, _Right._Mylast,
; 576  : 					_Myfirst);	// copy new

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	call	??$unchecked_copy@PAGPAG@stdext@@YAPAGPAG00@Z ; stdext::unchecked_copy<unsigned short *,unsigned short *>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR __Ptr$73372[ebp], eax

; 577  : 				_Destroy(_Ptr, _Mylast);	// destroy old

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR __Ptr$73372[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@GV?$allocator@G@std@@@std@@IAEXPAG0@Z ; std::vector<unsigned short,std::allocator<unsigned short> >::_Destroy

; 578  : 				_Mylast = _Myfirst + _Right.size();

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@GV?$allocator@G@std@@@std@@QBEIXZ ; std::vector<unsigned short,std::allocator<unsigned short> >::size
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	lea	eax, DWORD PTR [edx+eax*2]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax
	jmp	$LN9@operator@25
$LN6@operator@25:

; 579  : 				}
; 580  : 			else if (_Right.size() <= capacity())

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@GV?$allocator@G@std@@@std@@QBEIXZ ; std::vector<unsigned short,std::allocator<unsigned short> >::size
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?capacity@?$vector@GV?$allocator@G@std@@@std@@QBEIXZ ; std::vector<unsigned short,std::allocator<unsigned short> >::capacity
	cmp	esi, eax
	ja	SHORT $LN4@operator@25

; 581  : 				{	// enough room, copy and construct new
; 582  : 				pointer _Ptr = _Right._Myfirst + size();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@GV?$allocator@G@std@@@std@@QBEIXZ ; std::vector<unsigned short,std::allocator<unsigned short> >::size
	mov	edx, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	lea	edx, DWORD PTR [ecx+eax*2]
	mov	DWORD PTR __Ptr$73382[ebp], edx

; 583  : 				_STDEXT unchecked_copy(_Right._Myfirst, _Ptr, _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	edx, DWORD PTR __Ptr$73382[ebp]
	push	edx
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	call	??$unchecked_copy@PAGPAG@stdext@@YAPAGPAG00@Z ; stdext::unchecked_copy<unsigned short *,unsigned short *>
	add	esp, 12					; 0000000cH

; 584  : 				_Mylast = _Ucopy(_Ptr, _Right._Mylast, _Mylast);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR __Ptr$73382[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Ucopy@PAG@?$vector@GV?$allocator@G@std@@@std@@IAEPAGPAG00@Z ; std::vector<unsigned short,std::allocator<unsigned short> >::_Ucopy<unsigned short *>
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 585  : 				}
; 586  : 			else

	jmp	SHORT $LN9@operator@25
$LN4@operator@25:

; 587  : 				{	// not enough room, allocate new array and construct new
; 588  : 				if (_Myfirst != 0)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+12], 0
	je	SHORT $LN2@operator@25

; 589  : 					{	// discard old array
; 590  : 					_Destroy(_Myfirst, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@GV?$allocator@G@std@@@std@@IAEXPAG0@Z ; std::vector<unsigned short,std::allocator<unsigned short> >::_Destroy

; 591  : 					this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+20]
	sub	eax, DWORD PTR [edx+12]
	sar	eax, 1
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?deallocate@?$allocator@G@std@@QAEXPAGI@Z ; std::allocator<unsigned short>::deallocate
$LN2@operator@25:

; 592  : 					}
; 593  : 				if (_Buy(_Right.size()))

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@GV?$allocator@G@std@@@std@@QBEIXZ ; std::vector<unsigned short,std::allocator<unsigned short> >::size
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@GV?$allocator@G@std@@@std@@IAE_NI@Z ; std::vector<unsigned short,std::allocator<unsigned short> >::_Buy
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN9@operator@25

; 594  : 					_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 595  : 						_Myfirst);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Ucopy@PAG@?$vector@GV?$allocator@G@std@@@std@@IAEPAGPAG00@Z ; std::vector<unsigned short,std::allocator<unsigned short> >::_Ucopy<unsigned short *>
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax
$LN9@operator@25:

; 596  : 				}
; 597  : 			}
; 598  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 599  : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
??4?$vector@GV?$allocator@G@std@@@std@@QAEAAV01@ABV01@@Z ENDP ; std::vector<unsigned short,std::allocator<unsigned short> >::operator=
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?size@?$vector@GV?$allocator@G@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$vector@GV?$allocator@G@std@@@std@@QBEIXZ PROC	; std::vector<unsigned short,std::allocator<unsigned short> >::size, COMDAT
; _this$ = ecx

; 725  : 		{	// return length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+16]
	sub	eax, DWORD PTR [ecx+12]
	sar	eax, 1

; 727  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?size@?$vector@GV?$allocator@G@std@@@std@@QBEIXZ ENDP	; std::vector<unsigned short,std::allocator<unsigned short> >::size
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@QAE@XZ ; std::_Vector_val<Ogre::CullResult::Record,std::allocator<Ogre::CullResult::Record> >::~_Vector_val<Ogre::CullResult::Record,std::allocator<Ogre::CullResult::Record> >
PUBLIC	?_Tidy@?$vector@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@IAEXXZ ; std::vector<Ogre::CullResult::Record,std::allocator<Ogre::CullResult::Record> >::_Tidy
PUBLIC	??$_Ucopy@V?$_Vector_const_iterator@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@@?$vector@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@IAEPAURecord@CullResult@Ogre@@V?$_Vector_const_iterator@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@1@0PAU234@@Z ; std::vector<Ogre::CullResult::Record,std::allocator<Ogre::CullResult::Record> >::_Ucopy<std::_Vector_const_iterator<Ogre::CullResult::Record,std::allocator<Ogre::CullResult::Record> > >
PUBLIC	?begin@?$vector@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@2@XZ ; std::vector<Ogre::CullResult::Record,std::allocator<Ogre::CullResult::Record> >::begin
PUBLIC	?end@?$vector@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@2@XZ ; std::vector<Ogre::CullResult::Record,std::allocator<Ogre::CullResult::Record> >::end
PUBLIC	?_Buy@?$vector@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@IAE_NI@Z ; std::vector<Ogre::CullResult::Record,std::allocator<Ogre::CullResult::Record> >::_Buy
PUBLIC	?size@?$vector@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::CullResult::Record,std::allocator<Ogre::CullResult::Record> >::size
PUBLIC	??0?$_Vector_val@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@IAE@V?$allocator@URecord@CullResult@Ogre@@@1@@Z ; std::_Vector_val<Ogre::CullResult::Record,std::allocator<Ogre::CullResult::Record> >::_Vector_val<Ogre::CullResult::Record,std::allocator<Ogre::CullResult::Record> >
PUBLIC	??0?$allocator@URecord@CullResult@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::CullResult::Record>::allocator<Ogre::CullResult::Record>
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??0?$vector@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@QAE@ABV01@@Z$3 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??0?$vector@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@QAE@ABV01@@Z$0
__tryblocktable$??0?$vector@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@QAE@ABV01@@Z DD 01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??0?$vector@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@QAE@ABV01@@Z$3
__unwindtable$??0?$vector@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@QAE@ABV01@@Z$2
	DD	00H
	DD	00H
	DD	00H
	DD	00H
__ehfuncinfo$??0?$vector@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@QAE@ABV01@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0?$vector@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@QAE@ABV01@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??0?$vector@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$vector@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -40						; size = 4
$T95214 = -36						; size = 8
$T95213 = -28						; size = 8
$T95212 = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Right$ = 8						; size = 4
??0?$vector@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@QAE@ABV01@@Z PROC ; std::vector<Ogre::CullResult::Record,std::allocator<Ogre::CullResult::Record> >::vector<Ogre::CullResult::Record,std::allocator<Ogre::CullResult::Record> >, COMDAT
; _this$ = ecx

; 500  : 		{	// construct by copying _Right

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$vector@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 24					; 00000018H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Right$[ebp]
	add	eax, 8
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T95212[ebp], esp
	push	eax
	call	??0?$allocator@URecord@CullResult@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::CullResult::Record>::allocator<Ogre::CullResult::Record>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_val@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@IAE@V?$allocator@URecord@CullResult@Ogre@@@1@@Z ; std::_Vector_val<Ogre::CullResult::Record,std::allocator<Ogre::CullResult::Record> >::_Vector_val<Ogre::CullResult::Record,std::allocator<Ogre::CullResult::Record> >
	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 501  : 		if (_Buy(_Right.size()))

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::CullResult::Record,std::allocator<Ogre::CullResult::Record> >::size
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@IAE_NI@Z ; std::vector<Ogre::CullResult::Record,std::allocator<Ogre::CullResult::Record> >::_Buy
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN3@vector@40

; 502  : 			_TRY_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 1

; 503  : 			_Mylast = _Ucopy(_Right.begin(), _Right.end(), _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	lea	ecx, DWORD PTR $T95213[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?end@?$vector@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@2@XZ ; std::vector<Ogre::CullResult::Record,std::allocator<Ogre::CullResult::Record> >::end
	mov	edx, DWORD PTR [eax+4]
	push	edx
	mov	eax, DWORD PTR [eax]
	push	eax
	lea	ecx, DWORD PTR $T95214[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?begin@?$vector@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@2@XZ ; std::vector<Ogre::CullResult::Record,std::allocator<Ogre::CullResult::Record> >::begin
	mov	edx, DWORD PTR [eax+4]
	push	edx
	mov	eax, DWORD PTR [eax]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Ucopy@V?$_Vector_const_iterator@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@@?$vector@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@IAEPAURecord@CullResult@Ogre@@V?$_Vector_const_iterator@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@1@0PAU234@@Z ; std::vector<Ogre::CullResult::Record,std::allocator<Ogre::CullResult::Record> >::_Ucopy<std::_Vector_const_iterator<Ogre::CullResult::Record,std::allocator<Ogre::CullResult::Record> > >
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax
	jmp	SHORT $LN5@vector@40
__catch$??0?$vector@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@QAE@ABV01@@Z$0:

; 504  : 			_CATCH_ALL
; 505  : 			_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@IAEXXZ ; std::vector<Ogre::CullResult::Record,std::allocator<Ogre::CullResult::Record> >::_Tidy

; 506  : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 507  : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], 0
	mov	eax, $LN3@vector@40
	ret	0
$LN5@vector@40:
	mov	DWORD PTR __$EHRec$[ebp+12], 0
$LN3@vector@40:

; 508  : 		}

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector@40:
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@QAE@ABV01@@Z$2:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@QAE@XZ
__ehhandler$??0?$vector@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-44]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::vector<Ogre::CullResult::Record,std::allocator<Ogre::CullResult::Record> >::vector<Ogre::CullResult::Record,std::allocator<Ogre::CullResult::Record> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$vector@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$vector@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$vector@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$vector@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$vector@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$vector@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@QAE@XZ PROC ; std::vector<Ogre::CullResult::Record,std::allocator<Ogre::CullResult::Record> >::~vector<Ogre::CullResult::Record,std::allocator<Ogre::CullResult::Record> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$vector@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 559  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@IAEXXZ ; std::vector<Ogre::CullResult::Record,std::allocator<Ogre::CullResult::Record> >::_Tidy

; 560  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Vector_val@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$vector@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@QAE@XZ
__ehhandler$??1?$vector@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$vector@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$vector@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@QAE@XZ ENDP ; std::vector<Ogre::CullResult::Record,std::allocator<Ogre::CullResult::Record> >::~vector<Ogre::CullResult::Record,std::allocator<Ogre::CullResult::Record> >
PUBLIC	?deallocate@?$allocator@URecord@CullResult@Ogre@@@std@@QAEXPAURecord@CullResult@Ogre@@I@Z ; std::allocator<Ogre::CullResult::Record>::deallocate
PUBLIC	??$_Ucopy@PAURecord@CullResult@Ogre@@@?$vector@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@IAEPAURecord@CullResult@Ogre@@PAU234@00@Z ; std::vector<Ogre::CullResult::Record,std::allocator<Ogre::CullResult::Record> >::_Ucopy<Ogre::CullResult::Record *>
PUBLIC	?capacity@?$vector@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::CullResult::Record,std::allocator<Ogre::CullResult::Record> >::capacity
PUBLIC	?_Destroy@?$vector@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@IAEXPAURecord@CullResult@Ogre@@0@Z ; std::vector<Ogre::CullResult::Record,std::allocator<Ogre::CullResult::Record> >::_Destroy
PUBLIC	??$unchecked_copy@PAURecord@CullResult@Ogre@@PAU123@@stdext@@YAPAURecord@CullResult@Ogre@@PAU123@00@Z ; stdext::unchecked_copy<Ogre::CullResult::Record *,Ogre::CullResult::Record *>
PUBLIC	?clear@?$vector@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@QAEXXZ ; std::vector<Ogre::CullResult::Record,std::allocator<Ogre::CullResult::Record> >::clear
; Function compile flags: /Odtp
;	COMDAT ??4?$vector@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
__Ptr$73538 = -8					; size = 4
__Ptr$73528 = -4					; size = 4
__Right$ = 8						; size = 4
??4?$vector@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z PROC ; std::vector<Ogre::CullResult::Record,std::allocator<Ogre::CullResult::Record> >::operator=, COMDAT
; _this$ = ecx

; 563  : 		{	// assign _Right

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 564  : 		if (this != &_Right)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR __Right$[ebp]
	je	$LN9@operator@26

; 565  : 			{	// worth doing
; 566  : 
; 567  :  #if _HAS_ITERATOR_DEBUGGING
; 568  : 			this->_Orphan_all();
; 569  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 570  : 
; 571  : 			if (_Right.size() == 0)

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::CullResult::Record,std::allocator<Ogre::CullResult::Record> >::size
	test	eax, eax
	jne	SHORT $LN8@operator@26

; 572  : 				clear();	// new sequence empty, erase existing sequence

	mov	ecx, DWORD PTR _this$[ebp]
	call	?clear@?$vector@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@QAEXXZ ; std::vector<Ogre::CullResult::Record,std::allocator<Ogre::CullResult::Record> >::clear
	jmp	$LN9@operator@26
$LN8@operator@26:

; 573  : 			else if (_Right.size() <= size())

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::CullResult::Record,std::allocator<Ogre::CullResult::Record> >::size
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::CullResult::Record,std::allocator<Ogre::CullResult::Record> >::size
	cmp	esi, eax
	ja	SHORT $LN6@operator@26

; 574  : 				{	// enough elements, copy new and destroy old
; 575  : 				pointer _Ptr = _STDEXT unchecked_copy(_Right._Myfirst, _Right._Mylast,
; 576  : 					_Myfirst);	// copy new

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	call	??$unchecked_copy@PAURecord@CullResult@Ogre@@PAU123@@stdext@@YAPAURecord@CullResult@Ogre@@PAU123@00@Z ; stdext::unchecked_copy<Ogre::CullResult::Record *,Ogre::CullResult::Record *>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR __Ptr$73528[ebp], eax

; 577  : 				_Destroy(_Ptr, _Mylast);	// destroy old

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR __Ptr$73528[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@IAEXPAURecord@CullResult@Ogre@@0@Z ; std::vector<Ogre::CullResult::Record,std::allocator<Ogre::CullResult::Record> >::_Destroy

; 578  : 				_Mylast = _Myfirst + _Right.size();

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::CullResult::Record,std::allocator<Ogre::CullResult::Record> >::size
	shl	eax, 4
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+12]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+16], eax
	jmp	$LN9@operator@26
$LN6@operator@26:

; 579  : 				}
; 580  : 			else if (_Right.size() <= capacity())

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::CullResult::Record,std::allocator<Ogre::CullResult::Record> >::size
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?capacity@?$vector@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::CullResult::Record,std::allocator<Ogre::CullResult::Record> >::capacity
	cmp	esi, eax
	ja	SHORT $LN4@operator@26

; 581  : 				{	// enough room, copy and construct new
; 582  : 				pointer _Ptr = _Right._Myfirst + size();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::CullResult::Record,std::allocator<Ogre::CullResult::Record> >::size
	shl	eax, 4
	mov	ecx, DWORD PTR __Right$[ebp]
	add	eax, DWORD PTR [ecx+12]
	mov	DWORD PTR __Ptr$73538[ebp], eax

; 583  : 				_STDEXT unchecked_copy(_Right._Myfirst, _Ptr, _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR __Ptr$73538[ebp]
	push	ecx
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	call	??$unchecked_copy@PAURecord@CullResult@Ogre@@PAU123@@stdext@@YAPAURecord@CullResult@Ogre@@PAU123@00@Z ; stdext::unchecked_copy<Ogre::CullResult::Record *,Ogre::CullResult::Record *>
	add	esp, 12					; 0000000cH

; 584  : 				_Mylast = _Ucopy(_Ptr, _Right._Mylast, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Ptr$73538[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Ucopy@PAURecord@CullResult@Ogre@@@?$vector@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@IAEPAURecord@CullResult@Ogre@@PAU234@00@Z ; std::vector<Ogre::CullResult::Record,std::allocator<Ogre::CullResult::Record> >::_Ucopy<Ogre::CullResult::Record *>
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 585  : 				}
; 586  : 			else

	jmp	SHORT $LN9@operator@26
$LN4@operator@26:

; 587  : 				{	// not enough room, allocate new array and construct new
; 588  : 				if (_Myfirst != 0)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+12], 0
	je	SHORT $LN2@operator@26

; 589  : 					{	// discard old array
; 590  : 					_Destroy(_Myfirst, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@IAEXPAURecord@CullResult@Ogre@@0@Z ; std::vector<Ogre::CullResult::Record,std::allocator<Ogre::CullResult::Record> >::_Destroy

; 591  : 					this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+20]
	sub	eax, DWORD PTR [edx+12]
	sar	eax, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?deallocate@?$allocator@URecord@CullResult@Ogre@@@std@@QAEXPAURecord@CullResult@Ogre@@I@Z ; std::allocator<Ogre::CullResult::Record>::deallocate
$LN2@operator@26:

; 592  : 					}
; 593  : 				if (_Buy(_Right.size()))

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::CullResult::Record,std::allocator<Ogre::CullResult::Record> >::size
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@IAE_NI@Z ; std::vector<Ogre::CullResult::Record,std::allocator<Ogre::CullResult::Record> >::_Buy
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN9@operator@26

; 594  : 					_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 595  : 						_Myfirst);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Ucopy@PAURecord@CullResult@Ogre@@@?$vector@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@IAEPAURecord@CullResult@Ogre@@PAU234@00@Z ; std::vector<Ogre::CullResult::Record,std::allocator<Ogre::CullResult::Record> >::_Ucopy<Ogre::CullResult::Record *>
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax
$LN9@operator@26:

; 596  : 				}
; 597  : 			}
; 598  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 599  : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
??4?$vector@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z ENDP ; std::vector<Ogre::CullResult::Record,std::allocator<Ogre::CullResult::Record> >::operator=
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@QAE@XZ ; std::_Vector_val<Ogre::EffectObject *,std::allocator<Ogre::EffectObject *> >::~_Vector_val<Ogre::EffectObject *,std::allocator<Ogre::EffectObject *> >
PUBLIC	?_Tidy@?$vector@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@IAEXXZ ; std::vector<Ogre::EffectObject *,std::allocator<Ogre::EffectObject *> >::_Tidy
PUBLIC	??$_Ucopy@V?$_Vector_const_iterator@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@@?$vector@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@IAEPAPAVEffectObject@Ogre@@V?$_Vector_const_iterator@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@1@0PAPAV23@@Z ; std::vector<Ogre::EffectObject *,std::allocator<Ogre::EffectObject *> >::_Ucopy<std::_Vector_const_iterator<Ogre::EffectObject *,std::allocator<Ogre::EffectObject *> > >
PUBLIC	?begin@?$vector@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@2@XZ ; std::vector<Ogre::EffectObject *,std::allocator<Ogre::EffectObject *> >::begin
PUBLIC	?end@?$vector@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@2@XZ ; std::vector<Ogre::EffectObject *,std::allocator<Ogre::EffectObject *> >::end
PUBLIC	?_Buy@?$vector@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@IAE_NI@Z ; std::vector<Ogre::EffectObject *,std::allocator<Ogre::EffectObject *> >::_Buy
PUBLIC	?size@?$vector@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::EffectObject *,std::allocator<Ogre::EffectObject *> >::size
PUBLIC	??0?$_Vector_val@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@IAE@V?$allocator@PAVEffectObject@Ogre@@@1@@Z ; std::_Vector_val<Ogre::EffectObject *,std::allocator<Ogre::EffectObject *> >::_Vector_val<Ogre::EffectObject *,std::allocator<Ogre::EffectObject *> >
PUBLIC	??0?$allocator@PAVEffectObject@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::EffectObject *>::allocator<Ogre::EffectObject *>
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??0?$vector@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@QAE@ABV01@@Z$3 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??0?$vector@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@QAE@ABV01@@Z$0
__tryblocktable$??0?$vector@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@QAE@ABV01@@Z DD 01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??0?$vector@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@QAE@ABV01@@Z$3
__unwindtable$??0?$vector@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@QAE@ABV01@@Z$2
	DD	00H
	DD	00H
	DD	00H
	DD	00H
__ehfuncinfo$??0?$vector@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@QAE@ABV01@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0?$vector@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@QAE@ABV01@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??0?$vector@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$vector@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -40						; size = 4
$T95244 = -36						; size = 8
$T95243 = -28						; size = 8
$T95242 = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Right$ = 8						; size = 4
??0?$vector@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@QAE@ABV01@@Z PROC ; std::vector<Ogre::EffectObject *,std::allocator<Ogre::EffectObject *> >::vector<Ogre::EffectObject *,std::allocator<Ogre::EffectObject *> >, COMDAT
; _this$ = ecx

; 500  : 		{	// construct by copying _Right

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$vector@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 24					; 00000018H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Right$[ebp]
	add	eax, 8
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T95242[ebp], esp
	push	eax
	call	??0?$allocator@PAVEffectObject@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::EffectObject *>::allocator<Ogre::EffectObject *>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_val@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@IAE@V?$allocator@PAVEffectObject@Ogre@@@1@@Z ; std::_Vector_val<Ogre::EffectObject *,std::allocator<Ogre::EffectObject *> >::_Vector_val<Ogre::EffectObject *,std::allocator<Ogre::EffectObject *> >
	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 501  : 		if (_Buy(_Right.size()))

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::EffectObject *,std::allocator<Ogre::EffectObject *> >::size
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@IAE_NI@Z ; std::vector<Ogre::EffectObject *,std::allocator<Ogre::EffectObject *> >::_Buy
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN3@vector@41

; 502  : 			_TRY_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 1

; 503  : 			_Mylast = _Ucopy(_Right.begin(), _Right.end(), _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	lea	ecx, DWORD PTR $T95243[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?end@?$vector@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@2@XZ ; std::vector<Ogre::EffectObject *,std::allocator<Ogre::EffectObject *> >::end
	mov	edx, DWORD PTR [eax+4]
	push	edx
	mov	eax, DWORD PTR [eax]
	push	eax
	lea	ecx, DWORD PTR $T95244[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?begin@?$vector@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@2@XZ ; std::vector<Ogre::EffectObject *,std::allocator<Ogre::EffectObject *> >::begin
	mov	edx, DWORD PTR [eax+4]
	push	edx
	mov	eax, DWORD PTR [eax]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Ucopy@V?$_Vector_const_iterator@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@@?$vector@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@IAEPAPAVEffectObject@Ogre@@V?$_Vector_const_iterator@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@1@0PAPAV23@@Z ; std::vector<Ogre::EffectObject *,std::allocator<Ogre::EffectObject *> >::_Ucopy<std::_Vector_const_iterator<Ogre::EffectObject *,std::allocator<Ogre::EffectObject *> > >
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax
	jmp	SHORT $LN5@vector@41
__catch$??0?$vector@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@QAE@ABV01@@Z$0:

; 504  : 			_CATCH_ALL
; 505  : 			_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@IAEXXZ ; std::vector<Ogre::EffectObject *,std::allocator<Ogre::EffectObject *> >::_Tidy

; 506  : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 507  : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], 0
	mov	eax, $LN3@vector@41
	ret	0
$LN5@vector@41:
	mov	DWORD PTR __$EHRec$[ebp+12], 0
$LN3@vector@41:

; 508  : 		}

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector@41:
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@QAE@ABV01@@Z$2:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@QAE@XZ
__ehhandler$??0?$vector@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-44]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::vector<Ogre::EffectObject *,std::allocator<Ogre::EffectObject *> >::vector<Ogre::EffectObject *,std::allocator<Ogre::EffectObject *> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$vector@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$vector@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$vector@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$vector@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$vector@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$vector@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@QAE@XZ PROC ; std::vector<Ogre::EffectObject *,std::allocator<Ogre::EffectObject *> >::~vector<Ogre::EffectObject *,std::allocator<Ogre::EffectObject *> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$vector@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 559  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@IAEXXZ ; std::vector<Ogre::EffectObject *,std::allocator<Ogre::EffectObject *> >::_Tidy

; 560  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Vector_val@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$vector@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@QAE@XZ
__ehhandler$??1?$vector@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$vector@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$vector@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@QAE@XZ ENDP ; std::vector<Ogre::EffectObject *,std::allocator<Ogre::EffectObject *> >::~vector<Ogre::EffectObject *,std::allocator<Ogre::EffectObject *> >
PUBLIC	?deallocate@?$allocator@PAVEffectObject@Ogre@@@std@@QAEXPAPAVEffectObject@Ogre@@I@Z ; std::allocator<Ogre::EffectObject *>::deallocate
PUBLIC	??$_Ucopy@PAPAVEffectObject@Ogre@@@?$vector@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@IAEPAPAVEffectObject@Ogre@@PAPAV23@00@Z ; std::vector<Ogre::EffectObject *,std::allocator<Ogre::EffectObject *> >::_Ucopy<Ogre::EffectObject * *>
PUBLIC	?capacity@?$vector@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::EffectObject *,std::allocator<Ogre::EffectObject *> >::capacity
PUBLIC	?_Destroy@?$vector@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@IAEXPAPAVEffectObject@Ogre@@0@Z ; std::vector<Ogre::EffectObject *,std::allocator<Ogre::EffectObject *> >::_Destroy
PUBLIC	??$unchecked_copy@PAPAVEffectObject@Ogre@@PAPAV12@@stdext@@YAPAPAVEffectObject@Ogre@@PAPAV12@00@Z ; stdext::unchecked_copy<Ogre::EffectObject * *,Ogre::EffectObject * *>
PUBLIC	?clear@?$vector@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@QAEXXZ ; std::vector<Ogre::EffectObject *,std::allocator<Ogre::EffectObject *> >::clear
; Function compile flags: /Odtp
;	COMDAT ??4?$vector@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
__Ptr$73692 = -8					; size = 4
__Ptr$73682 = -4					; size = 4
__Right$ = 8						; size = 4
??4?$vector@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z PROC ; std::vector<Ogre::EffectObject *,std::allocator<Ogre::EffectObject *> >::operator=, COMDAT
; _this$ = ecx

; 563  : 		{	// assign _Right

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 564  : 		if (this != &_Right)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR __Right$[ebp]
	je	$LN9@operator@27

; 565  : 			{	// worth doing
; 566  : 
; 567  :  #if _HAS_ITERATOR_DEBUGGING
; 568  : 			this->_Orphan_all();
; 569  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 570  : 
; 571  : 			if (_Right.size() == 0)

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::EffectObject *,std::allocator<Ogre::EffectObject *> >::size
	test	eax, eax
	jne	SHORT $LN8@operator@27

; 572  : 				clear();	// new sequence empty, erase existing sequence

	mov	ecx, DWORD PTR _this$[ebp]
	call	?clear@?$vector@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@QAEXXZ ; std::vector<Ogre::EffectObject *,std::allocator<Ogre::EffectObject *> >::clear
	jmp	$LN9@operator@27
$LN8@operator@27:

; 573  : 			else if (_Right.size() <= size())

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::EffectObject *,std::allocator<Ogre::EffectObject *> >::size
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::EffectObject *,std::allocator<Ogre::EffectObject *> >::size
	cmp	esi, eax
	ja	SHORT $LN6@operator@27

; 574  : 				{	// enough elements, copy new and destroy old
; 575  : 				pointer _Ptr = _STDEXT unchecked_copy(_Right._Myfirst, _Right._Mylast,
; 576  : 					_Myfirst);	// copy new

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	call	??$unchecked_copy@PAPAVEffectObject@Ogre@@PAPAV12@@stdext@@YAPAPAVEffectObject@Ogre@@PAPAV12@00@Z ; stdext::unchecked_copy<Ogre::EffectObject * *,Ogre::EffectObject * *>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR __Ptr$73682[ebp], eax

; 577  : 				_Destroy(_Ptr, _Mylast);	// destroy old

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR __Ptr$73682[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@IAEXPAPAVEffectObject@Ogre@@0@Z ; std::vector<Ogre::EffectObject *,std::allocator<Ogre::EffectObject *> >::_Destroy

; 578  : 				_Mylast = _Myfirst + _Right.size();

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::EffectObject *,std::allocator<Ogre::EffectObject *> >::size
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	lea	eax, DWORD PTR [edx+eax*4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax
	jmp	$LN9@operator@27
$LN6@operator@27:

; 579  : 				}
; 580  : 			else if (_Right.size() <= capacity())

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::EffectObject *,std::allocator<Ogre::EffectObject *> >::size
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?capacity@?$vector@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::EffectObject *,std::allocator<Ogre::EffectObject *> >::capacity
	cmp	esi, eax
	ja	SHORT $LN4@operator@27

; 581  : 				{	// enough room, copy and construct new
; 582  : 				pointer _Ptr = _Right._Myfirst + size();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::EffectObject *,std::allocator<Ogre::EffectObject *> >::size
	mov	edx, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR __Ptr$73692[ebp], edx

; 583  : 				_STDEXT unchecked_copy(_Right._Myfirst, _Ptr, _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	edx, DWORD PTR __Ptr$73692[ebp]
	push	edx
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	call	??$unchecked_copy@PAPAVEffectObject@Ogre@@PAPAV12@@stdext@@YAPAPAVEffectObject@Ogre@@PAPAV12@00@Z ; stdext::unchecked_copy<Ogre::EffectObject * *,Ogre::EffectObject * *>
	add	esp, 12					; 0000000cH

; 584  : 				_Mylast = _Ucopy(_Ptr, _Right._Mylast, _Mylast);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR __Ptr$73692[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Ucopy@PAPAVEffectObject@Ogre@@@?$vector@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@IAEPAPAVEffectObject@Ogre@@PAPAV23@00@Z ; std::vector<Ogre::EffectObject *,std::allocator<Ogre::EffectObject *> >::_Ucopy<Ogre::EffectObject * *>
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 585  : 				}
; 586  : 			else

	jmp	SHORT $LN9@operator@27
$LN4@operator@27:

; 587  : 				{	// not enough room, allocate new array and construct new
; 588  : 				if (_Myfirst != 0)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+12], 0
	je	SHORT $LN2@operator@27

; 589  : 					{	// discard old array
; 590  : 					_Destroy(_Myfirst, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@IAEXPAPAVEffectObject@Ogre@@0@Z ; std::vector<Ogre::EffectObject *,std::allocator<Ogre::EffectObject *> >::_Destroy

; 591  : 					this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+20]
	sub	eax, DWORD PTR [edx+12]
	sar	eax, 2
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?deallocate@?$allocator@PAVEffectObject@Ogre@@@std@@QAEXPAPAVEffectObject@Ogre@@I@Z ; std::allocator<Ogre::EffectObject *>::deallocate
$LN2@operator@27:

; 592  : 					}
; 593  : 				if (_Buy(_Right.size()))

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::EffectObject *,std::allocator<Ogre::EffectObject *> >::size
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@IAE_NI@Z ; std::vector<Ogre::EffectObject *,std::allocator<Ogre::EffectObject *> >::_Buy
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN9@operator@27

; 594  : 					_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 595  : 						_Myfirst);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Ucopy@PAPAVEffectObject@Ogre@@@?$vector@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@IAEPAPAVEffectObject@Ogre@@PAPAV23@00@Z ; std::vector<Ogre::EffectObject *,std::allocator<Ogre::EffectObject *> >::_Ucopy<Ogre::EffectObject * *>
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax
$LN9@operator@27:

; 596  : 				}
; 597  : 			}
; 598  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 599  : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
??4?$vector@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z ENDP ; std::vector<Ogre::EffectObject *,std::allocator<Ogre::EffectObject *> >::operator=
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@QAE@XZ ; std::_Vector_val<Ogre::SoundNode *,std::allocator<Ogre::SoundNode *> >::~_Vector_val<Ogre::SoundNode *,std::allocator<Ogre::SoundNode *> >
PUBLIC	?_Tidy@?$vector@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@IAEXXZ ; std::vector<Ogre::SoundNode *,std::allocator<Ogre::SoundNode *> >::_Tidy
PUBLIC	??$_Ucopy@V?$_Vector_const_iterator@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@@?$vector@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@IAEPAPAVSoundNode@Ogre@@V?$_Vector_const_iterator@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@1@0PAPAV23@@Z ; std::vector<Ogre::SoundNode *,std::allocator<Ogre::SoundNode *> >::_Ucopy<std::_Vector_const_iterator<Ogre::SoundNode *,std::allocator<Ogre::SoundNode *> > >
PUBLIC	?begin@?$vector@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@2@XZ ; std::vector<Ogre::SoundNode *,std::allocator<Ogre::SoundNode *> >::begin
PUBLIC	?end@?$vector@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@2@XZ ; std::vector<Ogre::SoundNode *,std::allocator<Ogre::SoundNode *> >::end
PUBLIC	?_Buy@?$vector@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@IAE_NI@Z ; std::vector<Ogre::SoundNode *,std::allocator<Ogre::SoundNode *> >::_Buy
PUBLIC	?size@?$vector@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::SoundNode *,std::allocator<Ogre::SoundNode *> >::size
PUBLIC	??0?$_Vector_val@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@IAE@V?$allocator@PAVSoundNode@Ogre@@@1@@Z ; std::_Vector_val<Ogre::SoundNode *,std::allocator<Ogre::SoundNode *> >::_Vector_val<Ogre::SoundNode *,std::allocator<Ogre::SoundNode *> >
PUBLIC	??0?$allocator@PAVSoundNode@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::SoundNode *>::allocator<Ogre::SoundNode *>
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??0?$vector@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@QAE@ABV01@@Z$3 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??0?$vector@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@QAE@ABV01@@Z$0
__tryblocktable$??0?$vector@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@QAE@ABV01@@Z DD 01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??0?$vector@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@QAE@ABV01@@Z$3
__unwindtable$??0?$vector@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@QAE@ABV01@@Z$2
	DD	00H
	DD	00H
	DD	00H
	DD	00H
__ehfuncinfo$??0?$vector@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@QAE@ABV01@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0?$vector@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@QAE@ABV01@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??0?$vector@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$vector@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -40						; size = 4
$T95274 = -36						; size = 8
$T95273 = -28						; size = 8
$T95272 = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Right$ = 8						; size = 4
??0?$vector@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@QAE@ABV01@@Z PROC ; std::vector<Ogre::SoundNode *,std::allocator<Ogre::SoundNode *> >::vector<Ogre::SoundNode *,std::allocator<Ogre::SoundNode *> >, COMDAT
; _this$ = ecx

; 500  : 		{	// construct by copying _Right

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$vector@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 24					; 00000018H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Right$[ebp]
	add	eax, 8
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T95272[ebp], esp
	push	eax
	call	??0?$allocator@PAVSoundNode@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::SoundNode *>::allocator<Ogre::SoundNode *>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_val@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@IAE@V?$allocator@PAVSoundNode@Ogre@@@1@@Z ; std::_Vector_val<Ogre::SoundNode *,std::allocator<Ogre::SoundNode *> >::_Vector_val<Ogre::SoundNode *,std::allocator<Ogre::SoundNode *> >
	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 501  : 		if (_Buy(_Right.size()))

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::SoundNode *,std::allocator<Ogre::SoundNode *> >::size
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@IAE_NI@Z ; std::vector<Ogre::SoundNode *,std::allocator<Ogre::SoundNode *> >::_Buy
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN3@vector@42

; 502  : 			_TRY_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 1

; 503  : 			_Mylast = _Ucopy(_Right.begin(), _Right.end(), _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	lea	ecx, DWORD PTR $T95273[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?end@?$vector@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@2@XZ ; std::vector<Ogre::SoundNode *,std::allocator<Ogre::SoundNode *> >::end
	mov	edx, DWORD PTR [eax+4]
	push	edx
	mov	eax, DWORD PTR [eax]
	push	eax
	lea	ecx, DWORD PTR $T95274[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?begin@?$vector@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@2@XZ ; std::vector<Ogre::SoundNode *,std::allocator<Ogre::SoundNode *> >::begin
	mov	edx, DWORD PTR [eax+4]
	push	edx
	mov	eax, DWORD PTR [eax]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Ucopy@V?$_Vector_const_iterator@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@@?$vector@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@IAEPAPAVSoundNode@Ogre@@V?$_Vector_const_iterator@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@1@0PAPAV23@@Z ; std::vector<Ogre::SoundNode *,std::allocator<Ogre::SoundNode *> >::_Ucopy<std::_Vector_const_iterator<Ogre::SoundNode *,std::allocator<Ogre::SoundNode *> > >
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax
	jmp	SHORT $LN5@vector@42
__catch$??0?$vector@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@QAE@ABV01@@Z$0:

; 504  : 			_CATCH_ALL
; 505  : 			_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@IAEXXZ ; std::vector<Ogre::SoundNode *,std::allocator<Ogre::SoundNode *> >::_Tidy

; 506  : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 507  : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], 0
	mov	eax, $LN3@vector@42
	ret	0
$LN5@vector@42:
	mov	DWORD PTR __$EHRec$[ebp+12], 0
$LN3@vector@42:

; 508  : 		}

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector@42:
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@QAE@ABV01@@Z$2:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@QAE@XZ
__ehhandler$??0?$vector@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-44]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::vector<Ogre::SoundNode *,std::allocator<Ogre::SoundNode *> >::vector<Ogre::SoundNode *,std::allocator<Ogre::SoundNode *> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$vector@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$vector@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$vector@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$vector@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$vector@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$vector@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@QAE@XZ PROC ; std::vector<Ogre::SoundNode *,std::allocator<Ogre::SoundNode *> >::~vector<Ogre::SoundNode *,std::allocator<Ogre::SoundNode *> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$vector@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 559  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@IAEXXZ ; std::vector<Ogre::SoundNode *,std::allocator<Ogre::SoundNode *> >::_Tidy

; 560  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Vector_val@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$vector@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@QAE@XZ
__ehhandler$??1?$vector@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$vector@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$vector@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@QAE@XZ ENDP ; std::vector<Ogre::SoundNode *,std::allocator<Ogre::SoundNode *> >::~vector<Ogre::SoundNode *,std::allocator<Ogre::SoundNode *> >
PUBLIC	?deallocate@?$allocator@PAVSoundNode@Ogre@@@std@@QAEXPAPAVSoundNode@Ogre@@I@Z ; std::allocator<Ogre::SoundNode *>::deallocate
PUBLIC	??$_Ucopy@PAPAVSoundNode@Ogre@@@?$vector@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@IAEPAPAVSoundNode@Ogre@@PAPAV23@00@Z ; std::vector<Ogre::SoundNode *,std::allocator<Ogre::SoundNode *> >::_Ucopy<Ogre::SoundNode * *>
PUBLIC	?capacity@?$vector@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::SoundNode *,std::allocator<Ogre::SoundNode *> >::capacity
PUBLIC	?_Destroy@?$vector@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@IAEXPAPAVSoundNode@Ogre@@0@Z ; std::vector<Ogre::SoundNode *,std::allocator<Ogre::SoundNode *> >::_Destroy
PUBLIC	??$unchecked_copy@PAPAVSoundNode@Ogre@@PAPAV12@@stdext@@YAPAPAVSoundNode@Ogre@@PAPAV12@00@Z ; stdext::unchecked_copy<Ogre::SoundNode * *,Ogre::SoundNode * *>
PUBLIC	?clear@?$vector@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@QAEXXZ ; std::vector<Ogre::SoundNode *,std::allocator<Ogre::SoundNode *> >::clear
; Function compile flags: /Odtp
;	COMDAT ??4?$vector@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
__Ptr$73846 = -8					; size = 4
__Ptr$73836 = -4					; size = 4
__Right$ = 8						; size = 4
??4?$vector@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z PROC ; std::vector<Ogre::SoundNode *,std::allocator<Ogre::SoundNode *> >::operator=, COMDAT
; _this$ = ecx

; 563  : 		{	// assign _Right

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 564  : 		if (this != &_Right)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR __Right$[ebp]
	je	$LN9@operator@28

; 565  : 			{	// worth doing
; 566  : 
; 567  :  #if _HAS_ITERATOR_DEBUGGING
; 568  : 			this->_Orphan_all();
; 569  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 570  : 
; 571  : 			if (_Right.size() == 0)

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::SoundNode *,std::allocator<Ogre::SoundNode *> >::size
	test	eax, eax
	jne	SHORT $LN8@operator@28

; 572  : 				clear();	// new sequence empty, erase existing sequence

	mov	ecx, DWORD PTR _this$[ebp]
	call	?clear@?$vector@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@QAEXXZ ; std::vector<Ogre::SoundNode *,std::allocator<Ogre::SoundNode *> >::clear
	jmp	$LN9@operator@28
$LN8@operator@28:

; 573  : 			else if (_Right.size() <= size())

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::SoundNode *,std::allocator<Ogre::SoundNode *> >::size
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::SoundNode *,std::allocator<Ogre::SoundNode *> >::size
	cmp	esi, eax
	ja	SHORT $LN6@operator@28

; 574  : 				{	// enough elements, copy new and destroy old
; 575  : 				pointer _Ptr = _STDEXT unchecked_copy(_Right._Myfirst, _Right._Mylast,
; 576  : 					_Myfirst);	// copy new

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	call	??$unchecked_copy@PAPAVSoundNode@Ogre@@PAPAV12@@stdext@@YAPAPAVSoundNode@Ogre@@PAPAV12@00@Z ; stdext::unchecked_copy<Ogre::SoundNode * *,Ogre::SoundNode * *>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR __Ptr$73836[ebp], eax

; 577  : 				_Destroy(_Ptr, _Mylast);	// destroy old

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR __Ptr$73836[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@IAEXPAPAVSoundNode@Ogre@@0@Z ; std::vector<Ogre::SoundNode *,std::allocator<Ogre::SoundNode *> >::_Destroy

; 578  : 				_Mylast = _Myfirst + _Right.size();

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::SoundNode *,std::allocator<Ogre::SoundNode *> >::size
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	lea	eax, DWORD PTR [edx+eax*4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax
	jmp	$LN9@operator@28
$LN6@operator@28:

; 579  : 				}
; 580  : 			else if (_Right.size() <= capacity())

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::SoundNode *,std::allocator<Ogre::SoundNode *> >::size
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?capacity@?$vector@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::SoundNode *,std::allocator<Ogre::SoundNode *> >::capacity
	cmp	esi, eax
	ja	SHORT $LN4@operator@28

; 581  : 				{	// enough room, copy and construct new
; 582  : 				pointer _Ptr = _Right._Myfirst + size();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::SoundNode *,std::allocator<Ogre::SoundNode *> >::size
	mov	edx, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR __Ptr$73846[ebp], edx

; 583  : 				_STDEXT unchecked_copy(_Right._Myfirst, _Ptr, _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	edx, DWORD PTR __Ptr$73846[ebp]
	push	edx
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	call	??$unchecked_copy@PAPAVSoundNode@Ogre@@PAPAV12@@stdext@@YAPAPAVSoundNode@Ogre@@PAPAV12@00@Z ; stdext::unchecked_copy<Ogre::SoundNode * *,Ogre::SoundNode * *>
	add	esp, 12					; 0000000cH

; 584  : 				_Mylast = _Ucopy(_Ptr, _Right._Mylast, _Mylast);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR __Ptr$73846[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Ucopy@PAPAVSoundNode@Ogre@@@?$vector@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@IAEPAPAVSoundNode@Ogre@@PAPAV23@00@Z ; std::vector<Ogre::SoundNode *,std::allocator<Ogre::SoundNode *> >::_Ucopy<Ogre::SoundNode * *>
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 585  : 				}
; 586  : 			else

	jmp	SHORT $LN9@operator@28
$LN4@operator@28:

; 587  : 				{	// not enough room, allocate new array and construct new
; 588  : 				if (_Myfirst != 0)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+12], 0
	je	SHORT $LN2@operator@28

; 589  : 					{	// discard old array
; 590  : 					_Destroy(_Myfirst, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@IAEXPAPAVSoundNode@Ogre@@0@Z ; std::vector<Ogre::SoundNode *,std::allocator<Ogre::SoundNode *> >::_Destroy

; 591  : 					this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+20]
	sub	eax, DWORD PTR [edx+12]
	sar	eax, 2
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?deallocate@?$allocator@PAVSoundNode@Ogre@@@std@@QAEXPAPAVSoundNode@Ogre@@I@Z ; std::allocator<Ogre::SoundNode *>::deallocate
$LN2@operator@28:

; 592  : 					}
; 593  : 				if (_Buy(_Right.size()))

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::SoundNode *,std::allocator<Ogre::SoundNode *> >::size
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@IAE_NI@Z ; std::vector<Ogre::SoundNode *,std::allocator<Ogre::SoundNode *> >::_Buy
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN9@operator@28

; 594  : 					_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 595  : 						_Myfirst);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Ucopy@PAPAVSoundNode@Ogre@@@?$vector@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@IAEPAPAVSoundNode@Ogre@@PAPAV23@00@Z ; std::vector<Ogre::SoundNode *,std::allocator<Ogre::SoundNode *> >::_Ucopy<Ogre::SoundNode * *>
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax
$LN9@operator@28:

; 596  : 				}
; 597  : 			}
; 598  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 599  : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
??4?$vector@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z ENDP ; std::vector<Ogre::SoundNode *,std::allocator<Ogre::SoundNode *> >::operator=
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@QAE@XZ ; std::_Vector_val<Ogre::RenderableObject *,std::allocator<Ogre::RenderableObject *> >::~_Vector_val<Ogre::RenderableObject *,std::allocator<Ogre::RenderableObject *> >
PUBLIC	?_Tidy@?$vector@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@IAEXXZ ; std::vector<Ogre::RenderableObject *,std::allocator<Ogre::RenderableObject *> >::_Tidy
PUBLIC	??$_Ucopy@V?$_Vector_const_iterator@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@@?$vector@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@IAEPAPAVRenderableObject@Ogre@@V?$_Vector_const_iterator@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@1@0PAPAV23@@Z ; std::vector<Ogre::RenderableObject *,std::allocator<Ogre::RenderableObject *> >::_Ucopy<std::_Vector_const_iterator<Ogre::RenderableObject *,std::allocator<Ogre::RenderableObject *> > >
PUBLIC	?begin@?$vector@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@2@XZ ; std::vector<Ogre::RenderableObject *,std::allocator<Ogre::RenderableObject *> >::begin
PUBLIC	?end@?$vector@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@2@XZ ; std::vector<Ogre::RenderableObject *,std::allocator<Ogre::RenderableObject *> >::end
PUBLIC	?_Buy@?$vector@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@IAE_NI@Z ; std::vector<Ogre::RenderableObject *,std::allocator<Ogre::RenderableObject *> >::_Buy
PUBLIC	?size@?$vector@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::RenderableObject *,std::allocator<Ogre::RenderableObject *> >::size
PUBLIC	??0?$_Vector_val@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@IAE@V?$allocator@PAVRenderableObject@Ogre@@@1@@Z ; std::_Vector_val<Ogre::RenderableObject *,std::allocator<Ogre::RenderableObject *> >::_Vector_val<Ogre::RenderableObject *,std::allocator<Ogre::RenderableObject *> >
PUBLIC	??0?$allocator@PAVRenderableObject@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::RenderableObject *>::allocator<Ogre::RenderableObject *>
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??0?$vector@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@QAE@ABV01@@Z$3 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??0?$vector@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@QAE@ABV01@@Z$0
__tryblocktable$??0?$vector@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@QAE@ABV01@@Z DD 01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??0?$vector@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@QAE@ABV01@@Z$3
__unwindtable$??0?$vector@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@QAE@ABV01@@Z$2
	DD	00H
	DD	00H
	DD	00H
	DD	00H
__ehfuncinfo$??0?$vector@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@QAE@ABV01@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0?$vector@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@QAE@ABV01@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??0?$vector@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$vector@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -40						; size = 4
$T95304 = -36						; size = 8
$T95303 = -28						; size = 8
$T95302 = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Right$ = 8						; size = 4
??0?$vector@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@QAE@ABV01@@Z PROC ; std::vector<Ogre::RenderableObject *,std::allocator<Ogre::RenderableObject *> >::vector<Ogre::RenderableObject *,std::allocator<Ogre::RenderableObject *> >, COMDAT
; _this$ = ecx

; 500  : 		{	// construct by copying _Right

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$vector@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 24					; 00000018H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Right$[ebp]
	add	eax, 8
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T95302[ebp], esp
	push	eax
	call	??0?$allocator@PAVRenderableObject@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::RenderableObject *>::allocator<Ogre::RenderableObject *>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_val@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@IAE@V?$allocator@PAVRenderableObject@Ogre@@@1@@Z ; std::_Vector_val<Ogre::RenderableObject *,std::allocator<Ogre::RenderableObject *> >::_Vector_val<Ogre::RenderableObject *,std::allocator<Ogre::RenderableObject *> >
	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 501  : 		if (_Buy(_Right.size()))

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::RenderableObject *,std::allocator<Ogre::RenderableObject *> >::size
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@IAE_NI@Z ; std::vector<Ogre::RenderableObject *,std::allocator<Ogre::RenderableObject *> >::_Buy
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN3@vector@43

; 502  : 			_TRY_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 1

; 503  : 			_Mylast = _Ucopy(_Right.begin(), _Right.end(), _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	lea	ecx, DWORD PTR $T95303[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?end@?$vector@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@2@XZ ; std::vector<Ogre::RenderableObject *,std::allocator<Ogre::RenderableObject *> >::end
	mov	edx, DWORD PTR [eax+4]
	push	edx
	mov	eax, DWORD PTR [eax]
	push	eax
	lea	ecx, DWORD PTR $T95304[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?begin@?$vector@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@2@XZ ; std::vector<Ogre::RenderableObject *,std::allocator<Ogre::RenderableObject *> >::begin
	mov	edx, DWORD PTR [eax+4]
	push	edx
	mov	eax, DWORD PTR [eax]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Ucopy@V?$_Vector_const_iterator@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@@?$vector@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@IAEPAPAVRenderableObject@Ogre@@V?$_Vector_const_iterator@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@1@0PAPAV23@@Z ; std::vector<Ogre::RenderableObject *,std::allocator<Ogre::RenderableObject *> >::_Ucopy<std::_Vector_const_iterator<Ogre::RenderableObject *,std::allocator<Ogre::RenderableObject *> > >
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax
	jmp	SHORT $LN5@vector@43
__catch$??0?$vector@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@QAE@ABV01@@Z$0:

; 504  : 			_CATCH_ALL
; 505  : 			_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@IAEXXZ ; std::vector<Ogre::RenderableObject *,std::allocator<Ogre::RenderableObject *> >::_Tidy

; 506  : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 507  : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], 0
	mov	eax, $LN3@vector@43
	ret	0
$LN5@vector@43:
	mov	DWORD PTR __$EHRec$[ebp+12], 0
$LN3@vector@43:

; 508  : 		}

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector@43:
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@QAE@ABV01@@Z$2:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@QAE@XZ
__ehhandler$??0?$vector@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-44]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::vector<Ogre::RenderableObject *,std::allocator<Ogre::RenderableObject *> >::vector<Ogre::RenderableObject *,std::allocator<Ogre::RenderableObject *> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$vector@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$vector@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$vector@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$vector@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$vector@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$vector@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@QAE@XZ PROC ; std::vector<Ogre::RenderableObject *,std::allocator<Ogre::RenderableObject *> >::~vector<Ogre::RenderableObject *,std::allocator<Ogre::RenderableObject *> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$vector@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 559  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@IAEXXZ ; std::vector<Ogre::RenderableObject *,std::allocator<Ogre::RenderableObject *> >::_Tidy

; 560  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Vector_val@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$vector@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@QAE@XZ
__ehhandler$??1?$vector@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$vector@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$vector@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@QAE@XZ ENDP ; std::vector<Ogre::RenderableObject *,std::allocator<Ogre::RenderableObject *> >::~vector<Ogre::RenderableObject *,std::allocator<Ogre::RenderableObject *> >
PUBLIC	?deallocate@?$allocator@PAVRenderableObject@Ogre@@@std@@QAEXPAPAVRenderableObject@Ogre@@I@Z ; std::allocator<Ogre::RenderableObject *>::deallocate
PUBLIC	??$_Ucopy@PAPAVRenderableObject@Ogre@@@?$vector@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@IAEPAPAVRenderableObject@Ogre@@PAPAV23@00@Z ; std::vector<Ogre::RenderableObject *,std::allocator<Ogre::RenderableObject *> >::_Ucopy<Ogre::RenderableObject * *>
PUBLIC	?capacity@?$vector@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::RenderableObject *,std::allocator<Ogre::RenderableObject *> >::capacity
PUBLIC	?_Destroy@?$vector@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@IAEXPAPAVRenderableObject@Ogre@@0@Z ; std::vector<Ogre::RenderableObject *,std::allocator<Ogre::RenderableObject *> >::_Destroy
PUBLIC	??$unchecked_copy@PAPAVRenderableObject@Ogre@@PAPAV12@@stdext@@YAPAPAVRenderableObject@Ogre@@PAPAV12@00@Z ; stdext::unchecked_copy<Ogre::RenderableObject * *,Ogre::RenderableObject * *>
PUBLIC	?clear@?$vector@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@QAEXXZ ; std::vector<Ogre::RenderableObject *,std::allocator<Ogre::RenderableObject *> >::clear
; Function compile flags: /Odtp
;	COMDAT ??4?$vector@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
__Ptr$74000 = -8					; size = 4
__Ptr$73990 = -4					; size = 4
__Right$ = 8						; size = 4
??4?$vector@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z PROC ; std::vector<Ogre::RenderableObject *,std::allocator<Ogre::RenderableObject *> >::operator=, COMDAT
; _this$ = ecx

; 563  : 		{	// assign _Right

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 564  : 		if (this != &_Right)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR __Right$[ebp]
	je	$LN9@operator@29

; 565  : 			{	// worth doing
; 566  : 
; 567  :  #if _HAS_ITERATOR_DEBUGGING
; 568  : 			this->_Orphan_all();
; 569  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 570  : 
; 571  : 			if (_Right.size() == 0)

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::RenderableObject *,std::allocator<Ogre::RenderableObject *> >::size
	test	eax, eax
	jne	SHORT $LN8@operator@29

; 572  : 				clear();	// new sequence empty, erase existing sequence

	mov	ecx, DWORD PTR _this$[ebp]
	call	?clear@?$vector@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@QAEXXZ ; std::vector<Ogre::RenderableObject *,std::allocator<Ogre::RenderableObject *> >::clear
	jmp	$LN9@operator@29
$LN8@operator@29:

; 573  : 			else if (_Right.size() <= size())

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::RenderableObject *,std::allocator<Ogre::RenderableObject *> >::size
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::RenderableObject *,std::allocator<Ogre::RenderableObject *> >::size
	cmp	esi, eax
	ja	SHORT $LN6@operator@29

; 574  : 				{	// enough elements, copy new and destroy old
; 575  : 				pointer _Ptr = _STDEXT unchecked_copy(_Right._Myfirst, _Right._Mylast,
; 576  : 					_Myfirst);	// copy new

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	call	??$unchecked_copy@PAPAVRenderableObject@Ogre@@PAPAV12@@stdext@@YAPAPAVRenderableObject@Ogre@@PAPAV12@00@Z ; stdext::unchecked_copy<Ogre::RenderableObject * *,Ogre::RenderableObject * *>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR __Ptr$73990[ebp], eax

; 577  : 				_Destroy(_Ptr, _Mylast);	// destroy old

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR __Ptr$73990[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@IAEXPAPAVRenderableObject@Ogre@@0@Z ; std::vector<Ogre::RenderableObject *,std::allocator<Ogre::RenderableObject *> >::_Destroy

; 578  : 				_Mylast = _Myfirst + _Right.size();

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::RenderableObject *,std::allocator<Ogre::RenderableObject *> >::size
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	lea	eax, DWORD PTR [edx+eax*4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax
	jmp	$LN9@operator@29
$LN6@operator@29:

; 579  : 				}
; 580  : 			else if (_Right.size() <= capacity())

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::RenderableObject *,std::allocator<Ogre::RenderableObject *> >::size
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?capacity@?$vector@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::RenderableObject *,std::allocator<Ogre::RenderableObject *> >::capacity
	cmp	esi, eax
	ja	SHORT $LN4@operator@29

; 581  : 				{	// enough room, copy and construct new
; 582  : 				pointer _Ptr = _Right._Myfirst + size();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::RenderableObject *,std::allocator<Ogre::RenderableObject *> >::size
	mov	edx, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR __Ptr$74000[ebp], edx

; 583  : 				_STDEXT unchecked_copy(_Right._Myfirst, _Ptr, _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	edx, DWORD PTR __Ptr$74000[ebp]
	push	edx
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	call	??$unchecked_copy@PAPAVRenderableObject@Ogre@@PAPAV12@@stdext@@YAPAPAVRenderableObject@Ogre@@PAPAV12@00@Z ; stdext::unchecked_copy<Ogre::RenderableObject * *,Ogre::RenderableObject * *>
	add	esp, 12					; 0000000cH

; 584  : 				_Mylast = _Ucopy(_Ptr, _Right._Mylast, _Mylast);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR __Ptr$74000[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Ucopy@PAPAVRenderableObject@Ogre@@@?$vector@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@IAEPAPAVRenderableObject@Ogre@@PAPAV23@00@Z ; std::vector<Ogre::RenderableObject *,std::allocator<Ogre::RenderableObject *> >::_Ucopy<Ogre::RenderableObject * *>
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 585  : 				}
; 586  : 			else

	jmp	SHORT $LN9@operator@29
$LN4@operator@29:

; 587  : 				{	// not enough room, allocate new array and construct new
; 588  : 				if (_Myfirst != 0)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+12], 0
	je	SHORT $LN2@operator@29

; 589  : 					{	// discard old array
; 590  : 					_Destroy(_Myfirst, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@IAEXPAPAVRenderableObject@Ogre@@0@Z ; std::vector<Ogre::RenderableObject *,std::allocator<Ogre::RenderableObject *> >::_Destroy

; 591  : 					this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+20]
	sub	eax, DWORD PTR [edx+12]
	sar	eax, 2
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?deallocate@?$allocator@PAVRenderableObject@Ogre@@@std@@QAEXPAPAVRenderableObject@Ogre@@I@Z ; std::allocator<Ogre::RenderableObject *>::deallocate
$LN2@operator@29:

; 592  : 					}
; 593  : 				if (_Buy(_Right.size()))

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::RenderableObject *,std::allocator<Ogre::RenderableObject *> >::size
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@IAE_NI@Z ; std::vector<Ogre::RenderableObject *,std::allocator<Ogre::RenderableObject *> >::_Buy
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN9@operator@29

; 594  : 					_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 595  : 						_Myfirst);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Ucopy@PAPAVRenderableObject@Ogre@@@?$vector@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@IAEPAPAVRenderableObject@Ogre@@PAPAV23@00@Z ; std::vector<Ogre::RenderableObject *,std::allocator<Ogre::RenderableObject *> >::_Ucopy<Ogre::RenderableObject * *>
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax
$LN9@operator@29:

; 596  : 				}
; 597  : 			}
; 598  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 599  : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
??4?$vector@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z ENDP ; std::vector<Ogre::RenderableObject *,std::allocator<Ogre::RenderableObject *> >::operator=
_TEXT	ENDS
PUBLIC	??1?$_Vector_val@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@QAE@XZ ; std::_Vector_val<Ogre::Light *,std::allocator<Ogre::Light *> >::~_Vector_val<Ogre::Light *,std::allocator<Ogre::Light *> >
PUBLIC	?_Tidy@?$vector@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@IAEXXZ ; std::vector<Ogre::Light *,std::allocator<Ogre::Light *> >::_Tidy
PUBLIC	??$_Ucopy@V?$_Vector_const_iterator@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@@?$vector@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@IAEPAPAVLight@Ogre@@V?$_Vector_const_iterator@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@1@0PAPAV23@@Z ; std::vector<Ogre::Light *,std::allocator<Ogre::Light *> >::_Ucopy<std::_Vector_const_iterator<Ogre::Light *,std::allocator<Ogre::Light *> > >
PUBLIC	?begin@?$vector@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@2@XZ ; std::vector<Ogre::Light *,std::allocator<Ogre::Light *> >::begin
PUBLIC	?end@?$vector@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@2@XZ ; std::vector<Ogre::Light *,std::allocator<Ogre::Light *> >::end
PUBLIC	?_Buy@?$vector@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@IAE_NI@Z ; std::vector<Ogre::Light *,std::allocator<Ogre::Light *> >::_Buy
PUBLIC	?size@?$vector@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::Light *,std::allocator<Ogre::Light *> >::size
PUBLIC	??0?$_Vector_val@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@IAE@V?$allocator@PAVLight@Ogre@@@1@@Z ; std::_Vector_val<Ogre::Light *,std::allocator<Ogre::Light *> >::_Vector_val<Ogre::Light *,std::allocator<Ogre::Light *> >
PUBLIC	??0?$allocator@PAVLight@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::Light *>::allocator<Ogre::Light *>
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??0?$vector@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@QAE@ABV01@@Z$3 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??0?$vector@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@QAE@ABV01@@Z$0
__tryblocktable$??0?$vector@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@QAE@ABV01@@Z DD 01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??0?$vector@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@QAE@ABV01@@Z$3
__unwindtable$??0?$vector@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@QAE@ABV01@@Z$2
	DD	00H
	DD	00H
	DD	00H
	DD	00H
__ehfuncinfo$??0?$vector@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@QAE@ABV01@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0?$vector@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@QAE@ABV01@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??0?$vector@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$vector@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -40						; size = 4
$T95334 = -36						; size = 8
$T95333 = -28						; size = 8
$T95332 = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Right$ = 8						; size = 4
??0?$vector@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@QAE@ABV01@@Z PROC ; std::vector<Ogre::Light *,std::allocator<Ogre::Light *> >::vector<Ogre::Light *,std::allocator<Ogre::Light *> >, COMDAT
; _this$ = ecx

; 500  : 		{	// construct by copying _Right

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$vector@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 24					; 00000018H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Right$[ebp]
	add	eax, 8
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T95332[ebp], esp
	push	eax
	call	??0?$allocator@PAVLight@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::Light *>::allocator<Ogre::Light *>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_val@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@IAE@V?$allocator@PAVLight@Ogre@@@1@@Z ; std::_Vector_val<Ogre::Light *,std::allocator<Ogre::Light *> >::_Vector_val<Ogre::Light *,std::allocator<Ogre::Light *> >
	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 501  : 		if (_Buy(_Right.size()))

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::Light *,std::allocator<Ogre::Light *> >::size
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@IAE_NI@Z ; std::vector<Ogre::Light *,std::allocator<Ogre::Light *> >::_Buy
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN3@vector@44

; 502  : 			_TRY_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 1

; 503  : 			_Mylast = _Ucopy(_Right.begin(), _Right.end(), _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	lea	ecx, DWORD PTR $T95333[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?end@?$vector@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@2@XZ ; std::vector<Ogre::Light *,std::allocator<Ogre::Light *> >::end
	mov	edx, DWORD PTR [eax+4]
	push	edx
	mov	eax, DWORD PTR [eax]
	push	eax
	lea	ecx, DWORD PTR $T95334[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?begin@?$vector@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@2@XZ ; std::vector<Ogre::Light *,std::allocator<Ogre::Light *> >::begin
	mov	edx, DWORD PTR [eax+4]
	push	edx
	mov	eax, DWORD PTR [eax]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Ucopy@V?$_Vector_const_iterator@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@@?$vector@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@IAEPAPAVLight@Ogre@@V?$_Vector_const_iterator@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@1@0PAPAV23@@Z ; std::vector<Ogre::Light *,std::allocator<Ogre::Light *> >::_Ucopy<std::_Vector_const_iterator<Ogre::Light *,std::allocator<Ogre::Light *> > >
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax
	jmp	SHORT $LN5@vector@44
__catch$??0?$vector@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@QAE@ABV01@@Z$0:

; 504  : 			_CATCH_ALL
; 505  : 			_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@IAEXXZ ; std::vector<Ogre::Light *,std::allocator<Ogre::Light *> >::_Tidy

; 506  : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 507  : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], 0
	mov	eax, $LN3@vector@44
	ret	0
$LN5@vector@44:
	mov	DWORD PTR __$EHRec$[ebp+12], 0
$LN3@vector@44:

; 508  : 		}

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector@44:
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@QAE@ABV01@@Z$2:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@QAE@XZ
__ehhandler$??0?$vector@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-44]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::vector<Ogre::Light *,std::allocator<Ogre::Light *> >::vector<Ogre::Light *,std::allocator<Ogre::Light *> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$vector@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$vector@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$vector@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$vector@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$vector@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$vector@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@QAE@XZ PROC ; std::vector<Ogre::Light *,std::allocator<Ogre::Light *> >::~vector<Ogre::Light *,std::allocator<Ogre::Light *> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$vector@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 559  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@IAEXXZ ; std::vector<Ogre::Light *,std::allocator<Ogre::Light *> >::_Tidy

; 560  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Vector_val@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$vector@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@QAE@XZ
__ehhandler$??1?$vector@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$vector@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$vector@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@QAE@XZ ENDP ; std::vector<Ogre::Light *,std::allocator<Ogre::Light *> >::~vector<Ogre::Light *,std::allocator<Ogre::Light *> >
PUBLIC	?deallocate@?$allocator@PAVLight@Ogre@@@std@@QAEXPAPAVLight@Ogre@@I@Z ; std::allocator<Ogre::Light *>::deallocate
PUBLIC	??$_Ucopy@PAPAVLight@Ogre@@@?$vector@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@IAEPAPAVLight@Ogre@@PAPAV23@00@Z ; std::vector<Ogre::Light *,std::allocator<Ogre::Light *> >::_Ucopy<Ogre::Light * *>
PUBLIC	?capacity@?$vector@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::Light *,std::allocator<Ogre::Light *> >::capacity
PUBLIC	?_Destroy@?$vector@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@IAEXPAPAVLight@Ogre@@0@Z ; std::vector<Ogre::Light *,std::allocator<Ogre::Light *> >::_Destroy
PUBLIC	??$unchecked_copy@PAPAVLight@Ogre@@PAPAV12@@stdext@@YAPAPAVLight@Ogre@@PAPAV12@00@Z ; stdext::unchecked_copy<Ogre::Light * *,Ogre::Light * *>
PUBLIC	?clear@?$vector@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@QAEXXZ ; std::vector<Ogre::Light *,std::allocator<Ogre::Light *> >::clear
; Function compile flags: /Odtp
;	COMDAT ??4?$vector@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
__Ptr$74154 = -8					; size = 4
__Ptr$74144 = -4					; size = 4
__Right$ = 8						; size = 4
??4?$vector@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z PROC ; std::vector<Ogre::Light *,std::allocator<Ogre::Light *> >::operator=, COMDAT
; _this$ = ecx

; 563  : 		{	// assign _Right

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 564  : 		if (this != &_Right)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR __Right$[ebp]
	je	$LN9@operator@30

; 565  : 			{	// worth doing
; 566  : 
; 567  :  #if _HAS_ITERATOR_DEBUGGING
; 568  : 			this->_Orphan_all();
; 569  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 570  : 
; 571  : 			if (_Right.size() == 0)

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::Light *,std::allocator<Ogre::Light *> >::size
	test	eax, eax
	jne	SHORT $LN8@operator@30

; 572  : 				clear();	// new sequence empty, erase existing sequence

	mov	ecx, DWORD PTR _this$[ebp]
	call	?clear@?$vector@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@QAEXXZ ; std::vector<Ogre::Light *,std::allocator<Ogre::Light *> >::clear
	jmp	$LN9@operator@30
$LN8@operator@30:

; 573  : 			else if (_Right.size() <= size())

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::Light *,std::allocator<Ogre::Light *> >::size
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::Light *,std::allocator<Ogre::Light *> >::size
	cmp	esi, eax
	ja	SHORT $LN6@operator@30

; 574  : 				{	// enough elements, copy new and destroy old
; 575  : 				pointer _Ptr = _STDEXT unchecked_copy(_Right._Myfirst, _Right._Mylast,
; 576  : 					_Myfirst);	// copy new

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	call	??$unchecked_copy@PAPAVLight@Ogre@@PAPAV12@@stdext@@YAPAPAVLight@Ogre@@PAPAV12@00@Z ; stdext::unchecked_copy<Ogre::Light * *,Ogre::Light * *>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR __Ptr$74144[ebp], eax

; 577  : 				_Destroy(_Ptr, _Mylast);	// destroy old

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR __Ptr$74144[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@IAEXPAPAVLight@Ogre@@0@Z ; std::vector<Ogre::Light *,std::allocator<Ogre::Light *> >::_Destroy

; 578  : 				_Mylast = _Myfirst + _Right.size();

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::Light *,std::allocator<Ogre::Light *> >::size
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	lea	eax, DWORD PTR [edx+eax*4]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax
	jmp	$LN9@operator@30
$LN6@operator@30:

; 579  : 				}
; 580  : 			else if (_Right.size() <= capacity())

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::Light *,std::allocator<Ogre::Light *> >::size
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?capacity@?$vector@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::Light *,std::allocator<Ogre::Light *> >::capacity
	cmp	esi, eax
	ja	SHORT $LN4@operator@30

; 581  : 				{	// enough room, copy and construct new
; 582  : 				pointer _Ptr = _Right._Myfirst + size();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::Light *,std::allocator<Ogre::Light *> >::size
	mov	edx, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR __Ptr$74154[ebp], edx

; 583  : 				_STDEXT unchecked_copy(_Right._Myfirst, _Ptr, _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	edx, DWORD PTR __Ptr$74154[ebp]
	push	edx
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	call	??$unchecked_copy@PAPAVLight@Ogre@@PAPAV12@@stdext@@YAPAPAVLight@Ogre@@PAPAV12@00@Z ; stdext::unchecked_copy<Ogre::Light * *,Ogre::Light * *>
	add	esp, 12					; 0000000cH

; 584  : 				_Mylast = _Ucopy(_Ptr, _Right._Mylast, _Mylast);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR __Ptr$74154[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Ucopy@PAPAVLight@Ogre@@@?$vector@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@IAEPAPAVLight@Ogre@@PAPAV23@00@Z ; std::vector<Ogre::Light *,std::allocator<Ogre::Light *> >::_Ucopy<Ogre::Light * *>
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 585  : 				}
; 586  : 			else

	jmp	SHORT $LN9@operator@30
$LN4@operator@30:

; 587  : 				{	// not enough room, allocate new array and construct new
; 588  : 				if (_Myfirst != 0)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+12], 0
	je	SHORT $LN2@operator@30

; 589  : 					{	// discard old array
; 590  : 					_Destroy(_Myfirst, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@IAEXPAPAVLight@Ogre@@0@Z ; std::vector<Ogre::Light *,std::allocator<Ogre::Light *> >::_Destroy

; 591  : 					this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+20]
	sub	eax, DWORD PTR [edx+12]
	sar	eax, 2
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?deallocate@?$allocator@PAVLight@Ogre@@@std@@QAEXPAPAVLight@Ogre@@I@Z ; std::allocator<Ogre::Light *>::deallocate
$LN2@operator@30:

; 592  : 					}
; 593  : 				if (_Buy(_Right.size()))

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::Light *,std::allocator<Ogre::Light *> >::size
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@IAE_NI@Z ; std::vector<Ogre::Light *,std::allocator<Ogre::Light *> >::_Buy
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN9@operator@30

; 594  : 					_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 595  : 						_Myfirst);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Ucopy@PAPAVLight@Ogre@@@?$vector@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@IAEPAPAVLight@Ogre@@PAPAV23@00@Z ; std::vector<Ogre::Light *,std::allocator<Ogre::Light *> >::_Ucopy<Ogre::Light * *>
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax
$LN9@operator@30:

; 596  : 				}
; 597  : 			}
; 598  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 599  : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
??4?$vector@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z ENDP ; std::vector<Ogre::Light *,std::allocator<Ogre::Light *> >::operator=
_TEXT	ENDS
PUBLIC	??1?$_Container_base_aux_alloc_real@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$_Vector_val@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Vector_val@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$_Vector_val@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Vector_val@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$_Vector_val@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Vector_val@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::~_Vector_val<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Vector_val@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Container_base_aux_alloc_real@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Vector_val@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Container_base_aux_alloc_real@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >
__ehhandler$??1?$_Vector_val@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Vector_val@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Vector_val@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::~_Vector_val<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >
PUBLIC	??1?$_Container_base_aux_alloc_real@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$_Vector_val@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Vector_val@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$_Vector_val@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Vector_val@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$_Vector_val@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Vector_val@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::~_Vector_val<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Vector_val@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Container_base_aux_alloc_real@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Vector_val@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Container_base_aux_alloc_real@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >
__ehhandler$??1?$_Vector_val@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Vector_val@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Vector_val@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::~_Vector_val<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >
PUBLIC	??1?$_Container_base_aux_alloc_real@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$_Vector_val@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Vector_val@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$_Vector_val@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Vector_val@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$_Vector_val@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Vector_val@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::~_Vector_val<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Vector_val@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Container_base_aux_alloc_real@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Vector_val@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Container_base_aux_alloc_real@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >
__ehhandler$??1?$_Vector_val@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Vector_val@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Vector_val@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::~_Vector_val<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >
PUBLIC	??1?$_Container_base_aux_alloc_real@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$_Vector_val@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Vector_val@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$_Vector_val@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Vector_val@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$_Vector_val@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Vector_val@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::~_Vector_val<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Vector_val@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Container_base_aux_alloc_real@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Vector_val@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Container_base_aux_alloc_real@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >
__ehhandler$??1?$_Vector_val@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Vector_val@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Vector_val@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::~_Vector_val<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >
PUBLIC	??1?$_Container_base_aux_alloc_real@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$_Vector_val@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Vector_val@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$_Vector_val@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Vector_val@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$_Vector_val@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Vector_val@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::~_Vector_val<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Vector_val@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Container_base_aux_alloc_real@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Vector_val@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Container_base_aux_alloc_real@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >
__ehhandler$??1?$_Vector_val@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Vector_val@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Vector_val@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::~_Vector_val<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >
PUBLIC	??1?$_Container_base_aux_alloc_real@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::ShaderContext *> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::ShaderContext *> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$_Vector_val@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Vector_val@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$_Vector_val@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Vector_val@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$_Vector_val@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Vector_val@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<Ogre::ShaderContext *,std::allocator<Ogre::ShaderContext *> >::~_Vector_val<Ogre::ShaderContext *,std::allocator<Ogre::ShaderContext *> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Vector_val@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Container_base_aux_alloc_real@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::ShaderContext *> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::ShaderContext *> >
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Vector_val@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Container_base_aux_alloc_real@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::ShaderContext *> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::ShaderContext *> >
__ehhandler$??1?$_Vector_val@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Vector_val@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Vector_val@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<Ogre::ShaderContext *,std::allocator<Ogre::ShaderContext *> >::~_Vector_val<Ogre::ShaderContext *,std::allocator<Ogre::ShaderContext *> >
PUBLIC	??1?$_Container_base_aux_alloc_real@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::ContextQueDesc> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::ContextQueDesc> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$_Vector_val@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Vector_val@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$_Vector_val@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Vector_val@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$_Vector_val@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Vector_val@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<Ogre::ContextQueDesc,std::allocator<Ogre::ContextQueDesc> >::~_Vector_val<Ogre::ContextQueDesc,std::allocator<Ogre::ContextQueDesc> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Vector_val@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Container_base_aux_alloc_real@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::ContextQueDesc> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::ContextQueDesc> >
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Vector_val@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Container_base_aux_alloc_real@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::ContextQueDesc> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::ContextQueDesc> >
__ehhandler$??1?$_Vector_val@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Vector_val@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Vector_val@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<Ogre::ContextQueDesc,std::allocator<Ogre::ContextQueDesc> >::~_Vector_val<Ogre::ContextQueDesc,std::allocator<Ogre::ContextQueDesc> >
PUBLIC	??1?$_Container_base_aux_alloc_real@V?$allocator@E@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<unsigned char> >::~_Container_base_aux_alloc_real<std::allocator<unsigned char> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$_Vector_val@EV?$allocator@E@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Vector_val@EV?$allocator@E@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$_Vector_val@EV?$allocator@E@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Vector_val@EV?$allocator@E@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$_Vector_val@EV?$allocator@E@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Vector_val@EV?$allocator@E@std@@@std@@QAE@XZ PROC	; std::_Vector_val<unsigned char,std::allocator<unsigned char> >::~_Vector_val<unsigned char,std::allocator<unsigned char> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Vector_val@EV?$allocator@E@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Container_base_aux_alloc_real@V?$allocator@E@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<unsigned char> >::~_Container_base_aux_alloc_real<std::allocator<unsigned char> >
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Vector_val@EV?$allocator@E@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Container_base_aux_alloc_real@V?$allocator@E@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<unsigned char> >::~_Container_base_aux_alloc_real<std::allocator<unsigned char> >
__ehhandler$??1?$_Vector_val@EV?$allocator@E@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Vector_val@EV?$allocator@E@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Vector_val@EV?$allocator@E@std@@@std@@QAE@XZ ENDP	; std::_Vector_val<unsigned char,std::allocator<unsigned char> >::~_Vector_val<unsigned char,std::allocator<unsigned char> >
PUBLIC	??1?$_Container_base_aux_alloc_real@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::ShaderContextPool::ValueParam> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::ShaderContextPool::ValueParam> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$_Vector_val@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Vector_val@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$_Vector_val@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Vector_val@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$_Vector_val@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Vector_val@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<Ogre::ShaderContextPool::ValueParam,std::allocator<Ogre::ShaderContextPool::ValueParam> >::~_Vector_val<Ogre::ShaderContextPool::ValueParam,std::allocator<Ogre::ShaderContextPool::ValueParam> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Vector_val@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Container_base_aux_alloc_real@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::ShaderContextPool::ValueParam> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::ShaderContextPool::ValueParam> >
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Vector_val@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Container_base_aux_alloc_real@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::ShaderContextPool::ValueParam> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::ShaderContextPool::ValueParam> >
__ehhandler$??1?$_Vector_val@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Vector_val@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Vector_val@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<Ogre::ShaderContextPool::ValueParam,std::allocator<Ogre::ShaderContextPool::ValueParam> >::~_Vector_val<Ogre::ShaderContextPool::ValueParam,std::allocator<Ogre::ShaderContextPool::ValueParam> >
PUBLIC	??1?$_Container_base_aux_alloc_real@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::ShaderContextPool::TexParam> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::ShaderContextPool::TexParam> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$_Vector_val@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Vector_val@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$_Vector_val@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Vector_val@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$_Vector_val@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Vector_val@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<Ogre::ShaderContextPool::TexParam,std::allocator<Ogre::ShaderContextPool::TexParam> >::~_Vector_val<Ogre::ShaderContextPool::TexParam,std::allocator<Ogre::ShaderContextPool::TexParam> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Vector_val@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Container_base_aux_alloc_real@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::ShaderContextPool::TexParam> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::ShaderContextPool::TexParam> >
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Vector_val@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Container_base_aux_alloc_real@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::ShaderContextPool::TexParam> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::ShaderContextPool::TexParam> >
__ehhandler$??1?$_Vector_val@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Vector_val@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Vector_val@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<Ogre::ShaderContextPool::TexParam,std::allocator<Ogre::ShaderContextPool::TexParam> >::~_Vector_val<Ogre::ShaderContextPool::TexParam,std::allocator<Ogre::ShaderContextPool::TexParam> >
PUBLIC	??1?$_Container_base_aux_alloc_real@V?$allocator@D@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<char> >::~_Container_base_aux_alloc_real<std::allocator<char> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$_Vector_val@DV?$allocator@D@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Vector_val@DV?$allocator@D@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$_Vector_val@DV?$allocator@D@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Vector_val@DV?$allocator@D@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$_Vector_val@DV?$allocator@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Vector_val@DV?$allocator@D@std@@@std@@QAE@XZ PROC	; std::_Vector_val<char,std::allocator<char> >::~_Vector_val<char,std::allocator<char> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Vector_val@DV?$allocator@D@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Container_base_aux_alloc_real@V?$allocator@D@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<char> >::~_Container_base_aux_alloc_real<std::allocator<char> >
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Vector_val@DV?$allocator@D@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Container_base_aux_alloc_real@V?$allocator@D@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<char> >::~_Container_base_aux_alloc_real<std::allocator<char> >
__ehhandler$??1?$_Vector_val@DV?$allocator@D@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Vector_val@DV?$allocator@D@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Vector_val@DV?$allocator@D@std@@@std@@QAE@XZ ENDP	; std::_Vector_val<char,std::allocator<char> >::~_Vector_val<char,std::allocator<char> >
PUBLIC	??1?$_Container_base_aux_alloc_real@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::SurfaceData *> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::SurfaceData *> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$_Vector_val@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Vector_val@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$_Vector_val@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Vector_val@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$_Vector_val@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Vector_val@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::~_Vector_val<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Vector_val@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Container_base_aux_alloc_real@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::SurfaceData *> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::SurfaceData *> >
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Vector_val@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Container_base_aux_alloc_real@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::SurfaceData *> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::SurfaceData *> >
__ehhandler$??1?$_Vector_val@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Vector_val@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Vector_val@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::~_Vector_val<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >
PUBLIC	??1?$_Container_base_aux_alloc_real@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::CullResult::Record> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::CullResult::Record> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$_Vector_val@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Vector_val@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$_Vector_val@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Vector_val@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$_Vector_val@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Vector_val@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<Ogre::CullResult::Record,std::allocator<Ogre::CullResult::Record> >::~_Vector_val<Ogre::CullResult::Record,std::allocator<Ogre::CullResult::Record> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Vector_val@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Container_base_aux_alloc_real@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::CullResult::Record> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::CullResult::Record> >
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Vector_val@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Container_base_aux_alloc_real@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::CullResult::Record> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::CullResult::Record> >
__ehhandler$??1?$_Vector_val@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Vector_val@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Vector_val@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<Ogre::CullResult::Record,std::allocator<Ogre::CullResult::Record> >::~_Vector_val<Ogre::CullResult::Record,std::allocator<Ogre::CullResult::Record> >
PUBLIC	??1?$_Container_base_aux_alloc_real@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::EffectObject *> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::EffectObject *> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$_Vector_val@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Vector_val@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$_Vector_val@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Vector_val@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$_Vector_val@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Vector_val@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<Ogre::EffectObject *,std::allocator<Ogre::EffectObject *> >::~_Vector_val<Ogre::EffectObject *,std::allocator<Ogre::EffectObject *> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Vector_val@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Container_base_aux_alloc_real@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::EffectObject *> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::EffectObject *> >
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Vector_val@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Container_base_aux_alloc_real@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::EffectObject *> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::EffectObject *> >
__ehhandler$??1?$_Vector_val@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Vector_val@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Vector_val@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<Ogre::EffectObject *,std::allocator<Ogre::EffectObject *> >::~_Vector_val<Ogre::EffectObject *,std::allocator<Ogre::EffectObject *> >
PUBLIC	??1?$_Container_base_aux_alloc_real@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::SoundNode *> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::SoundNode *> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$_Vector_val@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Vector_val@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$_Vector_val@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Vector_val@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$_Vector_val@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Vector_val@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<Ogre::SoundNode *,std::allocator<Ogre::SoundNode *> >::~_Vector_val<Ogre::SoundNode *,std::allocator<Ogre::SoundNode *> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Vector_val@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Container_base_aux_alloc_real@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::SoundNode *> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::SoundNode *> >
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Vector_val@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Container_base_aux_alloc_real@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::SoundNode *> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::SoundNode *> >
__ehhandler$??1?$_Vector_val@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Vector_val@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Vector_val@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<Ogre::SoundNode *,std::allocator<Ogre::SoundNode *> >::~_Vector_val<Ogre::SoundNode *,std::allocator<Ogre::SoundNode *> >
PUBLIC	??1?$_Container_base_aux_alloc_real@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::RenderableObject *> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::RenderableObject *> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$_Vector_val@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Vector_val@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$_Vector_val@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Vector_val@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$_Vector_val@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Vector_val@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<Ogre::RenderableObject *,std::allocator<Ogre::RenderableObject *> >::~_Vector_val<Ogre::RenderableObject *,std::allocator<Ogre::RenderableObject *> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Vector_val@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Container_base_aux_alloc_real@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::RenderableObject *> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::RenderableObject *> >
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Vector_val@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Container_base_aux_alloc_real@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::RenderableObject *> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::RenderableObject *> >
__ehhandler$??1?$_Vector_val@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Vector_val@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Vector_val@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<Ogre::RenderableObject *,std::allocator<Ogre::RenderableObject *> >::~_Vector_val<Ogre::RenderableObject *,std::allocator<Ogre::RenderableObject *> >
PUBLIC	??1?$_Container_base_aux_alloc_real@V?$allocator@PAVLight@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::Light *> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::Light *> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$_Vector_val@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Vector_val@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$_Vector_val@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Vector_val@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$_Vector_val@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Vector_val@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<Ogre::Light *,std::allocator<Ogre::Light *> >::~_Vector_val<Ogre::Light *,std::allocator<Ogre::Light *> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Vector_val@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Container_base_aux_alloc_real@V?$allocator@PAVLight@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::Light *> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::Light *> >
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Vector_val@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Container_base_aux_alloc_real@V?$allocator@PAVLight@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::Light *> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::Light *> >
__ehhandler$??1?$_Vector_val@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Vector_val@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Vector_val@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<Ogre::Light *,std::allocator<Ogre::Light *> >::~_Vector_val<Ogre::Light *,std::allocator<Ogre::Light *> >
PUBLIC	?deallocate@?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@QAEXPAUAnimRange@BaseKeyFrameArray@Ogre@@I@Z ; std::allocator<Ogre::BaseKeyFrameArray::AnimRange>::deallocate
PUBLIC	??$_Ucopy@PAUAnimRange@BaseKeyFrameArray@Ogre@@@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAEPAUAnimRange@BaseKeyFrameArray@Ogre@@PAU234@00@Z ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::_Ucopy<Ogre::BaseKeyFrameArray::AnimRange *>
PUBLIC	?capacity@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::capacity
PUBLIC	?_Destroy@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAEXPAUAnimRange@BaseKeyFrameArray@Ogre@@0@Z ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::_Destroy
PUBLIC	??$unchecked_copy@PAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@@stdext@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@00@Z ; stdext::unchecked_copy<Ogre::BaseKeyFrameArray::AnimRange *,Ogre::BaseKeyFrameArray::AnimRange *>
PUBLIC	?clear@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAEXXZ ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::clear
; Function compile flags: /Odtp
;	COMDAT ??4?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
__Ptr$75118 = -8					; size = 4
__Ptr$75108 = -4					; size = 4
__Right$ = 8						; size = 4
??4?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z PROC ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::operator=, COMDAT
; _this$ = ecx

; 563  : 		{	// assign _Right

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 564  : 		if (this != &_Right)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR __Right$[ebp]
	je	$LN9@operator@31

; 565  : 			{	// worth doing
; 566  : 
; 567  :  #if _HAS_ITERATOR_DEBUGGING
; 568  : 			this->_Orphan_all();
; 569  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 570  : 
; 571  : 			if (_Right.size() == 0)

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::size
	test	eax, eax
	jne	SHORT $LN8@operator@31

; 572  : 				clear();	// new sequence empty, erase existing sequence

	mov	ecx, DWORD PTR _this$[ebp]
	call	?clear@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAEXXZ ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::clear
	jmp	$LN9@operator@31
$LN8@operator@31:

; 573  : 			else if (_Right.size() <= size())

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::size
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::size
	cmp	esi, eax
	ja	SHORT $LN6@operator@31

; 574  : 				{	// enough elements, copy new and destroy old
; 575  : 				pointer _Ptr = _STDEXT unchecked_copy(_Right._Myfirst, _Right._Mylast,
; 576  : 					_Myfirst);	// copy new

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	call	??$unchecked_copy@PAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@@stdext@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@00@Z ; stdext::unchecked_copy<Ogre::BaseKeyFrameArray::AnimRange *,Ogre::BaseKeyFrameArray::AnimRange *>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR __Ptr$75108[ebp], eax

; 577  : 				_Destroy(_Ptr, _Mylast);	// destroy old

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR __Ptr$75108[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAEXPAUAnimRange@BaseKeyFrameArray@Ogre@@0@Z ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::_Destroy

; 578  : 				_Mylast = _Myfirst + _Right.size();

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::size
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	lea	eax, DWORD PTR [edx+eax*8]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax
	jmp	$LN9@operator@31
$LN6@operator@31:

; 579  : 				}
; 580  : 			else if (_Right.size() <= capacity())

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::size
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?capacity@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::capacity
	cmp	esi, eax
	ja	SHORT $LN4@operator@31

; 581  : 				{	// enough room, copy and construct new
; 582  : 				pointer _Ptr = _Right._Myfirst + size();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::size
	mov	edx, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	lea	edx, DWORD PTR [ecx+eax*8]
	mov	DWORD PTR __Ptr$75118[ebp], edx

; 583  : 				_STDEXT unchecked_copy(_Right._Myfirst, _Ptr, _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	edx, DWORD PTR __Ptr$75118[ebp]
	push	edx
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	call	??$unchecked_copy@PAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@@stdext@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@00@Z ; stdext::unchecked_copy<Ogre::BaseKeyFrameArray::AnimRange *,Ogre::BaseKeyFrameArray::AnimRange *>
	add	esp, 12					; 0000000cH

; 584  : 				_Mylast = _Ucopy(_Ptr, _Right._Mylast, _Mylast);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR __Ptr$75118[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Ucopy@PAUAnimRange@BaseKeyFrameArray@Ogre@@@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAEPAUAnimRange@BaseKeyFrameArray@Ogre@@PAU234@00@Z ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::_Ucopy<Ogre::BaseKeyFrameArray::AnimRange *>
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 585  : 				}
; 586  : 			else

	jmp	SHORT $LN9@operator@31
$LN4@operator@31:

; 587  : 				{	// not enough room, allocate new array and construct new
; 588  : 				if (_Myfirst != 0)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+12], 0
	je	SHORT $LN2@operator@31

; 589  : 					{	// discard old array
; 590  : 					_Destroy(_Myfirst, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAEXPAUAnimRange@BaseKeyFrameArray@Ogre@@0@Z ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::_Destroy

; 591  : 					this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+20]
	sub	eax, DWORD PTR [edx+12]
	sar	eax, 3
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?deallocate@?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@QAEXPAUAnimRange@BaseKeyFrameArray@Ogre@@I@Z ; std::allocator<Ogre::BaseKeyFrameArray::AnimRange>::deallocate
$LN2@operator@31:

; 592  : 					}
; 593  : 				if (_Buy(_Right.size()))

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::size
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAE_NI@Z ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::_Buy
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN9@operator@31

; 594  : 					_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 595  : 						_Myfirst);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Ucopy@PAUAnimRange@BaseKeyFrameArray@Ogre@@@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAEPAUAnimRange@BaseKeyFrameArray@Ogre@@PAU234@00@Z ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::_Ucopy<Ogre::BaseKeyFrameArray::AnimRange *>
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax
$LN9@operator@31:

; 596  : 				}
; 597  : 			}
; 598  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 599  : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
??4?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z ENDP ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::operator=
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAE@PAUAnimRange@BaseKeyFrameArray@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::_Vector_const_iterator<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >
; Function compile flags: /Odtp
;	COMDAT ?begin@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@2@XZ PROC ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::begin, COMDAT
; _this$ = ecx

; 645  : 		{	// return iterator for beginning of nonmutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 646  : 		return (const_iterator(_Myfirst, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAE@PAUAnimRange@BaseKeyFrameArray@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::_Vector_const_iterator<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 647  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?begin@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@2@XZ ENDP ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::begin
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?end@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@2@XZ PROC ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::end, COMDAT
; _this$ = ecx

; 655  : 		{	// return iterator for end of nonmutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 656  : 		return (const_iterator(_Mylast, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAE@PAUAnimRange@BaseKeyFrameArray@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::_Vector_const_iterator<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 657  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?end@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@2@XZ ENDP ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::end
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@QAEPAUAnimRange@BaseKeyFrameArray@Ogre@@I@Z ; std::allocator<Ogre::BaseKeyFrameArray::AnimRange>::allocate
PUBLIC	?_Xlen@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@KAXXZ ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::_Xlen
PUBLIC	?max_size@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::max_size
; Function compile flags: /Odtp
;	COMDAT ?_Buy@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Capacity$ = 8						; size = 4
?_Buy@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAE_NI@Z PROC ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+20], 0

; 1104 : 		if (_Capacity == 0)

	cmp	DWORD PTR __Capacity$[ebp], 0
	jne	SHORT $LN4@Buy

; 1105 : 			return (false);

	xor	al, al
	jmp	SHORT $LN5@Buy
	jmp	SHORT $LN3@Buy
$LN4@Buy:

; 1106 : 		else if (max_size() < _Capacity)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::max_size
	cmp	eax, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN2@Buy

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@KAXXZ ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::_Xlen

; 1108 : 		else

	jmp	SHORT $LN3@Buy
$LN2@Buy:

; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	mov	eax, DWORD PTR __Capacity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?allocate@?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@QAEPAUAnimRange@BaseKeyFrameArray@Ogre@@I@Z ; std::allocator<Ogre::BaseKeyFrameArray::AnimRange>::allocate
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [edx+16], ecx

; 1112 : 			_Myend = _Myfirst + _Capacity;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR __Capacity$[ebp]
	lea	edx, DWORD PTR [eax+ecx*8]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], edx
$LN3@Buy:

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
$LN5@Buy:

; 1115 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Buy@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::_Buy
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Tidy@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAEXXZ PROC ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	je	SHORT $LN1@Tidy

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAEXPAUAnimRange@BaseKeyFrameArray@Ogre@@0@Z ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::_Destroy

; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+20]
	sub	ecx, DWORD PTR [eax+12]
	sar	ecx, 3
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?deallocate@?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@QAEXPAUAnimRange@BaseKeyFrameArray@Ogre@@I@Z ; std::allocator<Ogre::BaseKeyFrameArray::AnimRange>::deallocate
$LN1@Tidy:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+16], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], 0

; 1135 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAEXXZ ENDP ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::_Tidy
_TEXT	ENDS
PUBLIC	??0?$_Container_base_aux_alloc_real@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAE@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::_Container_base_aux_alloc_real<std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$_Vector_val@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAE@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Vector_val@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAE@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@1@@Z$0
__ehfuncinfo$??0?$_Vector_val@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAE@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Vector_val@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAE@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Vector_val@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAE@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@1@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T95525 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 1
??0?$_Vector_val@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAE@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@1@@Z PROC ; std::_Vector_val<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::_Vector_val<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Vector_val@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAE@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T95525[ebp], esp
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	call	??0?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::BaseKeyFrameArray::AnimRange>::allocator<Ogre::BaseKeyFrameArray::AnimRange>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Container_base_aux_alloc_real@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAE@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::_Container_base_aux_alloc_real<std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??0?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::BaseKeyFrameArray::AnimRange>::allocator<Ogre::BaseKeyFrameArray::AnimRange>

; 426  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Vector_val@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAE@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Container_base_aux_alloc_real@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >
__ehhandler$??0?$_Vector_val@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAE@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Vector_val@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAE@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Vector_val@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAE@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@1@@Z ENDP ; std::_Vector_val<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::_Vector_val<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >
PUBLIC	??1_Container_base_aux@std@@QAE@XZ		; std::_Container_base_aux::~_Container_base_aux
PUBLIC	?deallocate@?$allocator@V_Aux_cont@std@@@std@@QAEXPAV_Aux_cont@2@I@Z ; std::allocator<std::_Aux_cont>::deallocate
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??1?$_Container_base_aux_alloc_real@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Container_base_aux_alloc_real@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAE@XZ$0
__ehfuncinfo$??1?$_Container_base_aux_alloc_real@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Container_base_aux_alloc_real@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$_Container_base_aux_alloc_real@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Container_base_aux_alloc_real@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >, COMDAT
; _this$ = ecx

; 436  : 		{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Container_base_aux_alloc_real@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 437  : 		_Myownedaux->~_Aux_cont();
; 438  : 
; 439  : 		_Alaux.deallocate(_Myownedaux, 1);

	push	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?deallocate@?$allocator@V_Aux_cont@std@@@std@@QAEXPAV_Aux_cont@2@I@Z ; std::allocator<std::_Aux_cont>::deallocate

; 440  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Container_base_aux_alloc_real@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
__ehhandler$??1?$_Container_base_aux_alloc_real@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Container_base_aux_alloc_real@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Container_base_aux_alloc_real@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >
; Function compile flags: /Odtp
;	COMDAT ??1_Container_base_aux@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_Container_base_aux@std@@QAE@XZ PROC			; std::_Container_base_aux::~_Container_base_aux, COMDAT
; _this$ = ecx

; 402  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 403  : 		// Do nothing: ~_Container_base_aux_alloc_real() previously destroyed the aux object.
; 404  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??1_Container_base_aux@std@@QAE@XZ ENDP			; std::_Container_base_aux::~_Container_base_aux
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@QAE@ABV01@@Z PROC ; std::allocator<Ogre::BaseKeyFrameArray::AnimRange>::allocator<Ogre::BaseKeyFrameArray::AnimRange>, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<Ogre::BaseKeyFrameArray::AnimRange>::allocator<Ogre::BaseKeyFrameArray::AnimRange>
_TEXT	ENDS
PUBLIC	??$KEYFRAME_HERMITE@M@Ogre@@YAXAAMMABM111@Z	; Ogre::KEYFRAME_HERMITE<float>
PUBLIC	??A?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAEAAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@I@Z ; std::vector<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::operator[]
PUBLIC	??$KEYFRAME_LERP@M@Ogre@@YAXAAMMABM1@Z		; Ogre::KEYFRAME_LERP<float>
PUBLIC	??A?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAEAAUAnimRange@BaseKeyFrameArray@Ogre@@I@Z ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::operator[]
EXTRN	__imp__rand:PROC
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogrekeyframearray.h
;	COMDAT ?getValue@?$KeyFrameArray@M@Ogre@@QAEXHIAAM_N@Z
_TEXT	SEGMENT
tv531 = -84						; size = 8
tv529 = -76						; size = 4
tv468 = -72						; size = 8
tv466 = -64						; size = 4
_this$ = -60						; size = 4
_tick1$75222 = -56					; size = 4
_t$75226 = -52						; size = 4
_tick2$75223 = -48					; size = 4
_middle$75217 = -44					; size = 4
_tick1$75182 = -40					; size = 4
_t$75186 = -36						; size = 4
_tick2$75183 = -32					; size = 4
_i$75168 = -28						; size = 4
_start$ = -24						; size = 4
_end$ = -20						; size = 4
_dtick$ = -16						; size = 4
_size$ = -12						; size = 4
_ntotalkeys$ = -8					; size = 4
_nseq$ = -4						; size = 4
_seq$ = 8						; size = 4
_tick$ = 12						; size = 4
_data$ = 16						; size = 4
_loop$ = 20						; size = 1
?getValue@?$KeyFrameArray@M@Ogre@@QAEXHIAAM_N@Z PROC	; Ogre::KeyFrameArray<float>::getValue, COMDAT
; _this$ = ecx

; 104  : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 105  : 			int size = (int)m_Array.size();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	?size@?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::size
	mov	DWORD PTR _size$[ebp], eax

; 106  : 
; 107  : 			//assert(size > 0);
; 108  : 
; 109  : 			if (size == 0)

	cmp	DWORD PTR _size$[ebp], 0
	jne	SHORT $LN29@getValue

; 110  : 				return;

	jmp	$LN30@getValue
$LN29@getValue:

; 111  : 			
; 112  : 			data = m_Array[0].data;

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??A?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAEAAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@I@Z ; std::vector<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::operator[]
	mov	ecx, DWORD PTR _data$[ebp]
	fld	DWORD PTR [eax+4]
	fstp	DWORD PTR [ecx]

; 113  : 
; 114  : 			int start, end;
; 115  : 			int ntotalkeys = (int)m_Array.size();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	?size@?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::size
	mov	DWORD PTR _ntotalkeys$[ebp], eax

; 116  : 			int nseq = (int)m_Ranges.size();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?size@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::size
	mov	DWORD PTR _nseq$[ebp], eax

; 117  : 
; 118  : 			if(nseq == 0)

	cmp	DWORD PTR _nseq$[ebp], 0
	jne	SHORT $LN28@getValue

; 119  : 			{
; 120  : 				start = 0;

	mov	DWORD PTR _start$[ebp], 0

; 121  : 				end = ntotalkeys-1;

	mov	edx, DWORD PTR _ntotalkeys$[ebp]
	sub	edx, 1
	mov	DWORD PTR _end$[ebp], edx

; 122  : 			}
; 123  : 			else

	jmp	SHORT $LN27@getValue
$LN28@getValue:

; 124  : 			{
; 125  : 				assert(seq>=0 && seq<nseq);
; 126  : 				start = m_Ranges[seq].begin;

	mov	eax, DWORD PTR _seq$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??A?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAEAAUAnimRange@BaseKeyFrameArray@Ogre@@I@Z ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::operator[]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _start$[ebp], ecx

; 127  : 				end = m_Ranges[seq].end;

	mov	edx, DWORD PTR _seq$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??A?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAEAAUAnimRange@BaseKeyFrameArray@Ogre@@I@Z ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::operator[]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR _end$[ebp], eax
$LN27@getValue:

; 128  : 				assert(start <= end);
; 129  : 			}
; 130  : 			
; 131  : 
; 132  : 			if(m_Type == INTERPOL_RANDOM)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+32], 3
	jne	SHORT $LN26@getValue

; 133  : 			{
; 134  : 				int i = start;

	mov	edx, DWORD PTR _start$[ebp]
	mov	DWORD PTR _i$75168[ebp], edx

; 135  : 				if(end > start) i += rand()%(end-start);

	mov	eax, DWORD PTR _end$[ebp]
	cmp	eax, DWORD PTR _start$[ebp]
	jle	SHORT $LN25@getValue
	call	DWORD PTR __imp__rand
	mov	ecx, DWORD PTR _end$[ebp]
	sub	ecx, DWORD PTR _start$[ebp]
	cdq
	idiv	ecx
	add	edx, DWORD PTR _i$75168[ebp]
	mov	DWORD PTR _i$75168[ebp], edx
$LN25@getValue:

; 136  : 
; 137  : 				data = m_Array[i].data;

	mov	edx, DWORD PTR _i$75168[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??A?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAEAAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@I@Z ; std::vector<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::operator[]
	mov	ecx, DWORD PTR _data$[ebp]
	fld	DWORD PTR [eax+4]
	fstp	DWORD PTR [ecx]

; 138  : 				return;

	jmp	$LN30@getValue
$LN26@getValue:

; 139  : 			}
; 140  : 			if(start >= size)

	mov	edx, DWORD PTR _start$[ebp]
	cmp	edx, DWORD PTR _size$[ebp]
	jl	SHORT $LN24@getValue

; 141  : 			{
; 142  : 				start = size -1;

	mov	eax, DWORD PTR _size$[ebp]
	sub	eax, 1
	mov	DWORD PTR _start$[ebp], eax
$LN24@getValue:

; 143  : 			}
; 144  : 			if(end >= size)

	mov	ecx, DWORD PTR _end$[ebp]
	cmp	ecx, DWORD PTR _size$[ebp]
	jl	SHORT $LN23@getValue

; 145  : 			{
; 146  : 				end = size -1;

	mov	edx, DWORD PTR _size$[ebp]
	sub	edx, 1
	mov	DWORD PTR _end$[ebp], edx
$LN23@getValue:

; 147  : 			}
; 148  : 			tick -= m_Array[start].tick;

	mov	eax, DWORD PTR _start$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??A?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAEAAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@I@Z ; std::vector<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::operator[]
	mov	ecx, DWORD PTR _tick$[ebp]
	sub	ecx, DWORD PTR [eax]
	mov	DWORD PTR _tick$[ebp], ecx

; 149  : 			uint dtick = (m_Array[end].tick - m_Array[start].tick + 1);

	mov	edx, DWORD PTR _end$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??A?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAEAAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@I@Z ; std::vector<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::operator[]
	mov	esi, eax
	mov	eax, DWORD PTR _start$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??A?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAEAAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@I@Z ; std::vector<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::operator[]
	mov	ecx, DWORD PTR [esi]
	sub	ecx, DWORD PTR [eax]
	add	ecx, 1
	mov	DWORD PTR _dtick$[ebp], ecx

; 150  : 			if(dtick == 0) tick = m_Array[start].tick;

	jne	SHORT $LN22@getValue
	mov	edx, DWORD PTR _start$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??A?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAEAAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@I@Z ; std::vector<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::operator[]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR _tick$[ebp], eax

; 151  : 			else

	jmp	SHORT $LN17@getValue
$LN22@getValue:

; 152  : 			{	
; 153  : 				if(loop) tick = m_Array[start].tick + (tick%dtick);

	movzx	ecx, BYTE PTR _loop$[ebp]
	test	ecx, ecx
	je	SHORT $LN20@getValue
	mov	edx, DWORD PTR _start$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??A?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAEAAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@I@Z ; std::vector<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::operator[]
	mov	ecx, eax
	mov	eax, DWORD PTR _tick$[ebp]
	xor	edx, edx
	div	DWORD PTR _dtick$[ebp]
	add	edx, DWORD PTR [ecx]
	mov	DWORD PTR _tick$[ebp], edx
	jmp	SHORT $LN17@getValue
$LN20@getValue:

; 154  : 				else if(dtick < tick) tick = m_Array[end].tick;

	mov	edx, DWORD PTR _dtick$[ebp]
	cmp	edx, DWORD PTR _tick$[ebp]
	jae	SHORT $LN18@getValue
	mov	eax, DWORD PTR _end$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??A?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAEAAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@I@Z ; std::vector<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::operator[]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _tick$[ebp], ecx
	jmp	SHORT $LN17@getValue
$LN18@getValue:

; 155  : 				else tick = m_Array[start].tick + tick;

	mov	edx, DWORD PTR _start$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??A?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAEAAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@I@Z ; std::vector<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::operator[]
	mov	eax, DWORD PTR [eax]
	add	eax, DWORD PTR _tick$[ebp]
	mov	DWORD PTR _tick$[ebp], eax
$LN17@getValue:

; 156  : 			}
; 157  : 
; 158  : 			if ( m_nPrindex >= start && m_nPrindex  < end )  

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+84]
	cmp	edx, DWORD PTR _start$[ebp]
	jl	$LN14@getValue
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+84]
	cmp	ecx, DWORD PTR _end$[ebp]
	jge	$LN14@getValue

; 159  : 			{
; 160  : 				if ( tick > m_Array[m_nPrindex + 1].tick && m_nPrindex + 2 <= end)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+84]
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??A?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAEAAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@I@Z ; std::vector<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::operator[]
	mov	ecx, DWORD PTR _tick$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jbe	SHORT $LN15@getValue
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+84]
	add	eax, 2
	cmp	eax, DWORD PTR _end$[ebp]
	jg	SHORT $LN15@getValue

; 161  : 				{
; 162  : 					m_nPrindex++;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+84]
	add	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+84], edx
$LN15@getValue:

; 163  : 				}
; 164  : 				if ( tick >= m_Array[m_nPrindex].tick && tick <= m_Array[m_nPrindex + 1].tick )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+84]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??A?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAEAAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@I@Z ; std::vector<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::operator[]
	mov	ecx, DWORD PTR _tick$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jb	$LN14@getValue
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+84]
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??A?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAEAAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@I@Z ; std::vector<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::operator[]
	mov	ecx, DWORD PTR _tick$[ebp]
	cmp	ecx, DWORD PTR [eax]
	ja	$LN14@getValue

; 165  : 				{
; 166  : 					uint tick1 = m_Array[m_nPrindex].tick;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+84]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??A?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAEAAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@I@Z ; std::vector<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::operator[]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _tick1$75182[ebp], ecx

; 167  : 					uint tick2 = m_Array[m_nPrindex+1].tick;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+84]
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??A?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAEAAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@I@Z ; std::vector<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::operator[]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _tick2$75183[ebp], ecx

; 168  : 					if( tick1 == tick2 )

	mov	edx, DWORD PTR _tick1$75182[ebp]
	cmp	edx, DWORD PTR _tick2$75183[ebp]
	jne	SHORT $LN13@getValue

; 169  : 					{
; 170  : 						return;

	jmp	$LN30@getValue
$LN13@getValue:

; 171  : 					}
; 172  : 					assert( tick1 < tick2);
; 173  : 
; 174  : 					float t = float( int(tick-tick1) / double(tick2-tick1) );

	mov	eax, DWORD PTR _tick$[ebp]
	sub	eax, DWORD PTR _tick1$75182[ebp]
	mov	DWORD PTR tv466[ebp], eax
	fild	DWORD PTR tv466[ebp]
	mov	ecx, DWORD PTR _tick2$75183[ebp]
	sub	ecx, DWORD PTR _tick1$75182[ebp]
	mov	DWORD PTR tv468[ebp], ecx
	mov	DWORD PTR tv468[ebp+4], 0
	fild	QWORD PTR tv468[ebp]
	fdivp	ST(1), ST(0)
	fstp	DWORD PTR _t$75186[ebp]

; 175  : 					if(m_Type == INTERPOL_LINEAR) KEYFRAME_LERP( data, t, m_Array[m_nPrindex].data, m_Array[m_nPrindex + 1].data);

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+32], 1
	jne	SHORT $LN12@getValue
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+84]
	add	ecx, 1
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??A?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAEAAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@I@Z ; std::vector<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::operator[]
	add	eax, 4
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+84]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??A?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAEAAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@I@Z ; std::vector<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::operator[]
	add	eax, 4
	push	eax
	push	ecx
	fld	DWORD PTR _t$75186[ebp]
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _data$[ebp]
	push	ecx
	call	??$KEYFRAME_LERP@M@Ogre@@YAXAAMMABM1@Z	; Ogre::KEYFRAME_LERP<float>
	add	esp, 16					; 00000010H
	jmp	SHORT $LN11@getValue
$LN12@getValue:

; 176  : 					else KEYFRAME_HERMITE(data, t, m_Array[m_nPrindex].data, m_Array[m_nPrindex + 1].data, m_CtrlPt[m_nPrindex].out, m_CtrlPt[m_nPrindex + 1].in);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+84]
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 60					; 0000003cH
	call	??A?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAEAAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@I@Z ; std::vector<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::operator[]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+84]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 60					; 0000003cH
	call	??A?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAEAAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@I@Z ; std::vector<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::operator[]
	add	eax, 4
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+84]
	add	ecx, 1
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??A?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAEAAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@I@Z ; std::vector<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::operator[]
	add	eax, 4
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+84]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??A?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAEAAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@I@Z ; std::vector<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::operator[]
	add	eax, 4
	push	eax
	push	ecx
	fld	DWORD PTR _t$75186[ebp]
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _data$[ebp]
	push	ecx
	call	??$KEYFRAME_HERMITE@M@Ogre@@YAXAAMMABM111@Z ; Ogre::KEYFRAME_HERMITE<float>
	add	esp, 24					; 00000018H
$LN11@getValue:

; 177  : 					return;

	jmp	$LN30@getValue
$LN14@getValue:

; 178  : 				}
; 179  : 				//while ( m_nPrindex < end)
; 180  : 				//{
; 181  : 				//	if ( tick >= m_Array[m_nPrindex].tick && tick <= m_Array[m_nPrindex + 1].tick )
; 182  : 				//	{
; 183  : 				//		uint tick1 = m_Array[m_nPrindex].tick;
; 184  : 				//		uint tick2 = m_Array[m_nPrindex+1].tick;
; 185  : 				//		if( tick1 == tick2 )
; 186  : 				//		{
; 187  : 				//			return;
; 188  : 				//		}
; 189  : 				//		assert( tick1 < tick2);
; 190  : 
; 191  : 				//		float t = float( int(tick-tick1) / double(tick2-tick1) );
; 192  : 				//		if(m_Type == INTERPOL_LINEAR) KEYFRAME_LERP( data, t, m_Array[m_nPrindex].data, m_Array[m_nPrindex + 1].data);
; 193  : 				//		else KEYFRAME_HERMITE(data, t, m_Array[m_nPrindex].data, m_Array[m_nPrindex + 1].data, m_CtrlPt[m_nPrindex].out, m_CtrlPt[m_nPrindex + 1].in);
; 194  : 				//		return;
; 195  : 				//	}
; 196  : 				//	m_nPrindex++;
; 197  : 				//}
; 198  : 			}
; 199  : 			//char po[100];
; 200  : 			//sprintf(po,"start %d end %d\n",start,end);
; 201  : 			//OutputDebugString(po);
; 202  : 
; 203  : 			for(;;)
; 204  : 			{
; 205  : 				if( start >= end-1 ) break;

	mov	edx, DWORD PTR _end$[ebp]
	sub	edx, 1
	cmp	DWORD PTR _start$[ebp], edx
	jl	SHORT $LN8@getValue
	jmp	SHORT $LN9@getValue
$LN8@getValue:

; 206  : 
; 207  : 				int middle = (start+end)/2;

	mov	eax, DWORD PTR _start$[ebp]
	add	eax, DWORD PTR _end$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR _middle$75217[ebp], eax

; 208  : 				if( tick < m_Array[middle].tick ) end = middle;

	mov	eax, DWORD PTR _middle$75217[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??A?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAEAAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@I@Z ; std::vector<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::operator[]
	mov	ecx, DWORD PTR _tick$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jae	SHORT $LN7@getValue
	mov	edx, DWORD PTR _middle$75217[ebp]
	mov	DWORD PTR _end$[ebp], edx
	jmp	SHORT $LN6@getValue
$LN7@getValue:

; 209  : 				else start = middle;

	mov	eax, DWORD PTR _middle$75217[ebp]
	mov	DWORD PTR _start$[ebp], eax
$LN6@getValue:

; 210  : 			}

	jmp	SHORT $LN14@getValue
$LN9@getValue:

; 211  : 
; 212  : 			if( start == end ) data = m_Array[start].data;

	mov	ecx, DWORD PTR _start$[ebp]
	cmp	ecx, DWORD PTR _end$[ebp]
	jne	SHORT $LN5@getValue
	mov	edx, DWORD PTR _start$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??A?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAEAAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@I@Z ; std::vector<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::operator[]
	mov	ecx, DWORD PTR _data$[ebp]
	fld	DWORD PTR [eax+4]
	fstp	DWORD PTR [ecx]

; 213  : 			else

	jmp	$LN4@getValue
$LN5@getValue:

; 214  : 			{
; 215  : 				uint tick1 = m_Array[start].tick;

	mov	edx, DWORD PTR _start$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??A?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAEAAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@I@Z ; std::vector<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::operator[]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR _tick1$75222[ebp], eax

; 216  : 				uint tick2 = m_Array[end].tick;

	mov	ecx, DWORD PTR _end$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??A?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAEAAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@I@Z ; std::vector<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::operator[]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR _tick2$75223[ebp], edx

; 217  : 				if( tick1 == tick2 )

	mov	eax, DWORD PTR _tick1$75222[ebp]
	cmp	eax, DWORD PTR _tick2$75223[ebp]
	jne	SHORT $LN3@getValue

; 218  : 				{
; 219  : 					return;

	jmp	$LN30@getValue
$LN3@getValue:

; 220  : 				}
; 221  : 				assert( tick1 < tick2);
; 222  : 
; 223  : 				float t = float( int(tick-tick1) / double(tick2-tick1) );

	mov	ecx, DWORD PTR _tick$[ebp]
	sub	ecx, DWORD PTR _tick1$75222[ebp]
	mov	DWORD PTR tv529[ebp], ecx
	fild	DWORD PTR tv529[ebp]
	mov	edx, DWORD PTR _tick2$75223[ebp]
	sub	edx, DWORD PTR _tick1$75222[ebp]
	mov	DWORD PTR tv531[ebp], edx
	mov	DWORD PTR tv531[ebp+4], 0
	fild	QWORD PTR tv531[ebp]
	fdivp	ST(1), ST(0)
	fstp	DWORD PTR _t$75226[ebp]

; 224  : 				if(m_Type == INTERPOL_LINEAR) KEYFRAME_LERP( data, t, m_Array[start].data, m_Array[end].data);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+32], 1
	jne	SHORT $LN2@getValue
	mov	ecx, DWORD PTR _end$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??A?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAEAAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@I@Z ; std::vector<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::operator[]
	add	eax, 4
	push	eax
	mov	edx, DWORD PTR _start$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??A?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAEAAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@I@Z ; std::vector<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::operator[]
	add	eax, 4
	push	eax
	push	ecx
	fld	DWORD PTR _t$75226[ebp]
	fstp	DWORD PTR [esp]
	mov	eax, DWORD PTR _data$[ebp]
	push	eax
	call	??$KEYFRAME_LERP@M@Ogre@@YAXAAMMABM1@Z	; Ogre::KEYFRAME_LERP<float>
	add	esp, 16					; 00000010H
	jmp	SHORT $LN1@getValue
$LN2@getValue:

; 225  : 				else KEYFRAME_HERMITE(data, t, m_Array[start].data, m_Array[end].data, m_CtrlPt[start].out, m_CtrlPt[end].in);

	mov	ecx, DWORD PTR _end$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 60					; 0000003cH
	call	??A?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAEAAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@I@Z ; std::vector<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::operator[]
	push	eax
	mov	edx, DWORD PTR _start$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 60					; 0000003cH
	call	??A?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAEAAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@I@Z ; std::vector<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::operator[]
	add	eax, 4
	push	eax
	mov	eax, DWORD PTR _end$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??A?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAEAAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@I@Z ; std::vector<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::operator[]
	add	eax, 4
	push	eax
	mov	ecx, DWORD PTR _start$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??A?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAEAAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@I@Z ; std::vector<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::operator[]
	add	eax, 4
	push	eax
	push	ecx
	fld	DWORD PTR _t$75226[ebp]
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _data$[ebp]
	push	edx
	call	??$KEYFRAME_HERMITE@M@Ogre@@YAXAAMMABM111@Z ; Ogre::KEYFRAME_HERMITE<float>
	add	esp, 24					; 00000018H
$LN1@getValue:

; 226  : 				m_nPrindex = start;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _start$[ebp]
	mov	DWORD PTR [eax+84], ecx
$LN4@getValue:
$LN30@getValue:

; 227  : 			}
; 228  : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?getValue@?$KeyFrameArray@M@Ogre@@QAEXHIAAM_N@Z ENDP	; Ogre::KeyFrameArray<float>::getValue
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ??A?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAEAAUAnimRange@BaseKeyFrameArray@Ogre@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pos$ = 8						; size = 4
??A?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAEAAUAnimRange@BaseKeyFrameArray@Ogre@@I@Z PROC ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::operator[], COMDAT
; _this$ = ecx

; 774  : 		{	// subscript mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)
; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");
; 780  : 			_SCL_SECURE_OUT_OF_RANGE;
; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::size
	cmp	DWORD PTR __Pos$[ebp], eax
	jb	SHORT $LN1@operator@32
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN1@operator@32:

; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR __Pos$[ebp]
	lea	eax, DWORD PTR [ecx+edx*8]

; 786  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??A?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAEAAUAnimRange@BaseKeyFrameArray@Ogre@@I@Z ENDP ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::operator[]
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@QAEXPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@I@Z ; std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T>::deallocate
PUBLIC	??$_Ucopy@PAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAEPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU234@00@Z ; std::vector<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::_Ucopy<Ogre::KeyFrameArray<float>::KEYFRAME_T *>
PUBLIC	?capacity@?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::capacity
PUBLIC	?_Destroy@?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAEXPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@0@Z ; std::vector<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::_Destroy
PUBLIC	??$unchecked_copy@PAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU123@@stdext@@YAPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU123@00@Z ; stdext::unchecked_copy<Ogre::KeyFrameArray<float>::KEYFRAME_T *,Ogre::KeyFrameArray<float>::KEYFRAME_T *>
PUBLIC	?clear@?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAEXXZ ; std::vector<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::clear
; Function compile flags: /Odtp
;	COMDAT ??4?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
__Ptr$75245 = -8					; size = 4
__Ptr$75235 = -4					; size = 4
__Right$ = 8						; size = 4
??4?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z PROC ; std::vector<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::operator=, COMDAT
; _this$ = ecx

; 563  : 		{	// assign _Right

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 564  : 		if (this != &_Right)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR __Right$[ebp]
	je	$LN9@operator@33

; 565  : 			{	// worth doing
; 566  : 
; 567  :  #if _HAS_ITERATOR_DEBUGGING
; 568  : 			this->_Orphan_all();
; 569  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 570  : 
; 571  : 			if (_Right.size() == 0)

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::size
	test	eax, eax
	jne	SHORT $LN8@operator@33

; 572  : 				clear();	// new sequence empty, erase existing sequence

	mov	ecx, DWORD PTR _this$[ebp]
	call	?clear@?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAEXXZ ; std::vector<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::clear
	jmp	$LN9@operator@33
$LN8@operator@33:

; 573  : 			else if (_Right.size() <= size())

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::size
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::size
	cmp	esi, eax
	ja	SHORT $LN6@operator@33

; 574  : 				{	// enough elements, copy new and destroy old
; 575  : 				pointer _Ptr = _STDEXT unchecked_copy(_Right._Myfirst, _Right._Mylast,
; 576  : 					_Myfirst);	// copy new

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	call	??$unchecked_copy@PAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU123@@stdext@@YAPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU123@00@Z ; stdext::unchecked_copy<Ogre::KeyFrameArray<float>::KEYFRAME_T *,Ogre::KeyFrameArray<float>::KEYFRAME_T *>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR __Ptr$75235[ebp], eax

; 577  : 				_Destroy(_Ptr, _Mylast);	// destroy old

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR __Ptr$75235[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAEXPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@0@Z ; std::vector<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::_Destroy

; 578  : 				_Mylast = _Myfirst + _Right.size();

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::size
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	lea	eax, DWORD PTR [edx+eax*8]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax
	jmp	$LN9@operator@33
$LN6@operator@33:

; 579  : 				}
; 580  : 			else if (_Right.size() <= capacity())

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::size
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?capacity@?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::capacity
	cmp	esi, eax
	ja	SHORT $LN4@operator@33

; 581  : 				{	// enough room, copy and construct new
; 582  : 				pointer _Ptr = _Right._Myfirst + size();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::size
	mov	edx, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	lea	edx, DWORD PTR [ecx+eax*8]
	mov	DWORD PTR __Ptr$75245[ebp], edx

; 583  : 				_STDEXT unchecked_copy(_Right._Myfirst, _Ptr, _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	edx, DWORD PTR __Ptr$75245[ebp]
	push	edx
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	call	??$unchecked_copy@PAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU123@@stdext@@YAPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU123@00@Z ; stdext::unchecked_copy<Ogre::KeyFrameArray<float>::KEYFRAME_T *,Ogre::KeyFrameArray<float>::KEYFRAME_T *>
	add	esp, 12					; 0000000cH

; 584  : 				_Mylast = _Ucopy(_Ptr, _Right._Mylast, _Mylast);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR __Ptr$75245[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Ucopy@PAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAEPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU234@00@Z ; std::vector<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::_Ucopy<Ogre::KeyFrameArray<float>::KEYFRAME_T *>
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 585  : 				}
; 586  : 			else

	jmp	SHORT $LN9@operator@33
$LN4@operator@33:

; 587  : 				{	// not enough room, allocate new array and construct new
; 588  : 				if (_Myfirst != 0)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+12], 0
	je	SHORT $LN2@operator@33

; 589  : 					{	// discard old array
; 590  : 					_Destroy(_Myfirst, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAEXPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@0@Z ; std::vector<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::_Destroy

; 591  : 					this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+20]
	sub	eax, DWORD PTR [edx+12]
	sar	eax, 3
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?deallocate@?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@QAEXPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@I@Z ; std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T>::deallocate
$LN2@operator@33:

; 592  : 					}
; 593  : 				if (_Buy(_Right.size()))

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::size
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAE_NI@Z ; std::vector<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::_Buy
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN9@operator@33

; 594  : 					_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 595  : 						_Myfirst);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Ucopy@PAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAEPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU234@00@Z ; std::vector<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::_Ucopy<Ogre::KeyFrameArray<float>::KEYFRAME_T *>
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax
$LN9@operator@33:

; 596  : 				}
; 597  : 			}
; 598  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 599  : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
??4?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z ENDP ; std::vector<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::operator=
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAE@PAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::_Vector_const_iterator<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >
; Function compile flags: /Odtp
;	COMDAT ?begin@?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@2@XZ PROC ; std::vector<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::begin, COMDAT
; _this$ = ecx

; 645  : 		{	// return iterator for beginning of nonmutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 646  : 		return (const_iterator(_Myfirst, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAE@PAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::_Vector_const_iterator<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 647  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?begin@?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@2@XZ ENDP ; std::vector<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::begin
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?end@?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@2@XZ PROC ; std::vector<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::end, COMDAT
; _this$ = ecx

; 655  : 		{	// return iterator for end of nonmutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 656  : 		return (const_iterator(_Mylast, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAE@PAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::_Vector_const_iterator<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 657  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?end@?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@2@XZ ENDP ; std::vector<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::end
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?size@?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QBEIXZ PROC ; std::vector<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::size, COMDAT
; _this$ = ecx

; 725  : 		{	// return length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+16]
	sub	eax, DWORD PTR [ecx+12]
	sar	eax, 3

; 727  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?size@?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QBEIXZ ENDP ; std::vector<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::size
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?empty@?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?empty@?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QBE_NXZ PROC ; std::vector<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::empty, COMDAT
; _this$ = ecx

; 735  : 		{	// test if sequence is empty

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 736  : 		return (size() == 0);

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::size
	neg	eax
	sbb	eax, eax
	add	eax, 1

; 737  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?empty@?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QBE_NXZ ENDP ; std::vector<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::empty
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??A?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAEAAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pos$ = 8						; size = 4
??A?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAEAAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@I@Z PROC ; std::vector<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::operator[], COMDAT
; _this$ = ecx

; 774  : 		{	// subscript mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)
; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");
; 780  : 			_SCL_SECURE_OUT_OF_RANGE;
; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::size
	cmp	DWORD PTR __Pos$[ebp], eax
	jb	SHORT $LN1@operator@34
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN1@operator@34:

; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR __Pos$[ebp]
	lea	eax, DWORD PTR [ecx+edx*8]

; 786  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??A?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAEAAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@I@Z ENDP ; std::vector<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::operator[]
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@QAEPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@I@Z ; std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T>::allocate
PUBLIC	?_Xlen@?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@KAXXZ ; std::vector<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::_Xlen
PUBLIC	?max_size@?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::max_size
; Function compile flags: /Odtp
;	COMDAT ?_Buy@?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Capacity$ = 8						; size = 4
?_Buy@?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAE_NI@Z PROC ; std::vector<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+20], 0

; 1104 : 		if (_Capacity == 0)

	cmp	DWORD PTR __Capacity$[ebp], 0
	jne	SHORT $LN4@Buy@2

; 1105 : 			return (false);

	xor	al, al
	jmp	SHORT $LN5@Buy@2
	jmp	SHORT $LN3@Buy@2
$LN4@Buy@2:

; 1106 : 		else if (max_size() < _Capacity)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::max_size
	cmp	eax, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN2@Buy@2

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@KAXXZ ; std::vector<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::_Xlen

; 1108 : 		else

	jmp	SHORT $LN3@Buy@2
$LN2@Buy@2:

; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	mov	eax, DWORD PTR __Capacity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?allocate@?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@QAEPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@I@Z ; std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T>::allocate
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [edx+16], ecx

; 1112 : 			_Myend = _Myfirst + _Capacity;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR __Capacity$[ebp]
	lea	edx, DWORD PTR [eax+ecx*8]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], edx
$LN3@Buy@2:

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
$LN5@Buy@2:

; 1115 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Buy@?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::_Buy
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Tidy@?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAEXXZ PROC ; std::vector<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	je	SHORT $LN1@Tidy@2

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAEXPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@0@Z ; std::vector<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::_Destroy

; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+20]
	sub	ecx, DWORD PTR [eax+12]
	sar	ecx, 3
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?deallocate@?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@QAEXPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@I@Z ; std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T>::deallocate
$LN1@Tidy@2:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+16], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], 0

; 1135 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAEXXZ ENDP ; std::vector<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::_Tidy
_TEXT	ENDS
PUBLIC	??0?$_Container_base_aux_alloc_real@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAE@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::_Container_base_aux_alloc_real<std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$_Vector_val@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAE@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Vector_val@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAE@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@1@@Z$0
__ehfuncinfo$??0?$_Vector_val@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAE@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Vector_val@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAE@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Vector_val@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAE@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@1@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T95568 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 1
??0?$_Vector_val@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAE@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@1@@Z PROC ; std::_Vector_val<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::_Vector_val<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Vector_val@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAE@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T95568[ebp], esp
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	call	??0?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T>::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Container_base_aux_alloc_real@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAE@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::_Container_base_aux_alloc_real<std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??0?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T>::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T>

; 426  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Vector_val@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAE@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Container_base_aux_alloc_real@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >
__ehhandler$??0?$_Vector_val@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAE@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Vector_val@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAE@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Vector_val@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAE@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@1@@Z ENDP ; std::_Vector_val<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::_Vector_val<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??1?$_Container_base_aux_alloc_real@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Container_base_aux_alloc_real@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAE@XZ$0
__ehfuncinfo$??1?$_Container_base_aux_alloc_real@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Container_base_aux_alloc_real@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$_Container_base_aux_alloc_real@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Container_base_aux_alloc_real@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >, COMDAT
; _this$ = ecx

; 436  : 		{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Container_base_aux_alloc_real@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 437  : 		_Myownedaux->~_Aux_cont();
; 438  : 
; 439  : 		_Alaux.deallocate(_Myownedaux, 1);

	push	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?deallocate@?$allocator@V_Aux_cont@std@@@std@@QAEXPAV_Aux_cont@2@I@Z ; std::allocator<std::_Aux_cont>::deallocate

; 440  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Container_base_aux_alloc_real@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
__ehhandler$??1?$_Container_base_aux_alloc_real@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Container_base_aux_alloc_real@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Container_base_aux_alloc_real@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@QAE@ABV01@@Z PROC ; std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T>::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T>, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T>::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T>
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@QAEXPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@I@Z ; std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T>::deallocate
PUBLIC	??$_Ucopy@PAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAEPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU234@00@Z ; std::vector<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::_Ucopy<Ogre::KeyFrameArray<float>::CONTROL_POINT_T *>
PUBLIC	?capacity@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::capacity
PUBLIC	?_Destroy@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAEXPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@0@Z ; std::vector<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::_Destroy
PUBLIC	??$unchecked_copy@PAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU123@@stdext@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU123@00@Z ; stdext::unchecked_copy<Ogre::KeyFrameArray<float>::CONTROL_POINT_T *,Ogre::KeyFrameArray<float>::CONTROL_POINT_T *>
PUBLIC	?clear@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAEXXZ ; std::vector<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::clear
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??4?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
__Ptr$75303 = -8					; size = 4
__Ptr$75293 = -4					; size = 4
__Right$ = 8						; size = 4
??4?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z PROC ; std::vector<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::operator=, COMDAT
; _this$ = ecx

; 563  : 		{	// assign _Right

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 564  : 		if (this != &_Right)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR __Right$[ebp]
	je	$LN9@operator@35

; 565  : 			{	// worth doing
; 566  : 
; 567  :  #if _HAS_ITERATOR_DEBUGGING
; 568  : 			this->_Orphan_all();
; 569  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 570  : 
; 571  : 			if (_Right.size() == 0)

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::size
	test	eax, eax
	jne	SHORT $LN8@operator@35

; 572  : 				clear();	// new sequence empty, erase existing sequence

	mov	ecx, DWORD PTR _this$[ebp]
	call	?clear@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAEXXZ ; std::vector<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::clear
	jmp	$LN9@operator@35
$LN8@operator@35:

; 573  : 			else if (_Right.size() <= size())

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::size
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::size
	cmp	esi, eax
	ja	SHORT $LN6@operator@35

; 574  : 				{	// enough elements, copy new and destroy old
; 575  : 				pointer _Ptr = _STDEXT unchecked_copy(_Right._Myfirst, _Right._Mylast,
; 576  : 					_Myfirst);	// copy new

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	call	??$unchecked_copy@PAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU123@@stdext@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU123@00@Z ; stdext::unchecked_copy<Ogre::KeyFrameArray<float>::CONTROL_POINT_T *,Ogre::KeyFrameArray<float>::CONTROL_POINT_T *>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR __Ptr$75293[ebp], eax

; 577  : 				_Destroy(_Ptr, _Mylast);	// destroy old

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR __Ptr$75293[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAEXPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@0@Z ; std::vector<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::_Destroy

; 578  : 				_Mylast = _Myfirst + _Right.size();

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::size
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	lea	eax, DWORD PTR [edx+eax*8]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax
	jmp	$LN9@operator@35
$LN6@operator@35:

; 579  : 				}
; 580  : 			else if (_Right.size() <= capacity())

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::size
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?capacity@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::capacity
	cmp	esi, eax
	ja	SHORT $LN4@operator@35

; 581  : 				{	// enough room, copy and construct new
; 582  : 				pointer _Ptr = _Right._Myfirst + size();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::size
	mov	edx, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	lea	edx, DWORD PTR [ecx+eax*8]
	mov	DWORD PTR __Ptr$75303[ebp], edx

; 583  : 				_STDEXT unchecked_copy(_Right._Myfirst, _Ptr, _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	edx, DWORD PTR __Ptr$75303[ebp]
	push	edx
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	call	??$unchecked_copy@PAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU123@@stdext@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU123@00@Z ; stdext::unchecked_copy<Ogre::KeyFrameArray<float>::CONTROL_POINT_T *,Ogre::KeyFrameArray<float>::CONTROL_POINT_T *>
	add	esp, 12					; 0000000cH

; 584  : 				_Mylast = _Ucopy(_Ptr, _Right._Mylast, _Mylast);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR __Ptr$75303[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Ucopy@PAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAEPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU234@00@Z ; std::vector<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::_Ucopy<Ogre::KeyFrameArray<float>::CONTROL_POINT_T *>
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 585  : 				}
; 586  : 			else

	jmp	SHORT $LN9@operator@35
$LN4@operator@35:

; 587  : 				{	// not enough room, allocate new array and construct new
; 588  : 				if (_Myfirst != 0)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+12], 0
	je	SHORT $LN2@operator@35

; 589  : 					{	// discard old array
; 590  : 					_Destroy(_Myfirst, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAEXPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@0@Z ; std::vector<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::_Destroy

; 591  : 					this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+20]
	sub	eax, DWORD PTR [edx+12]
	sar	eax, 3
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?deallocate@?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@QAEXPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@I@Z ; std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T>::deallocate
$LN2@operator@35:

; 592  : 					}
; 593  : 				if (_Buy(_Right.size()))

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::size
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAE_NI@Z ; std::vector<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::_Buy
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN9@operator@35

; 594  : 					_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 595  : 						_Myfirst);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Ucopy@PAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAEPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU234@00@Z ; std::vector<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::_Ucopy<Ogre::KeyFrameArray<float>::CONTROL_POINT_T *>
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax
$LN9@operator@35:

; 596  : 				}
; 597  : 			}
; 598  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 599  : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
??4?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z ENDP ; std::vector<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::operator=
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAE@PAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::_Vector_const_iterator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >
; Function compile flags: /Odtp
;	COMDAT ?begin@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@2@XZ PROC ; std::vector<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::begin, COMDAT
; _this$ = ecx

; 645  : 		{	// return iterator for beginning of nonmutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 646  : 		return (const_iterator(_Myfirst, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAE@PAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::_Vector_const_iterator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 647  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?begin@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@2@XZ ENDP ; std::vector<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::begin
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?end@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@2@XZ PROC ; std::vector<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::end, COMDAT
; _this$ = ecx

; 655  : 		{	// return iterator for end of nonmutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 656  : 		return (const_iterator(_Mylast, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAE@PAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::_Vector_const_iterator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 657  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?end@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@2@XZ ENDP ; std::vector<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::end
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?size@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QBEIXZ PROC ; std::vector<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::size, COMDAT
; _this$ = ecx

; 725  : 		{	// return length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+16]
	sub	eax, DWORD PTR [ecx+12]
	sar	eax, 3

; 727  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?size@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QBEIXZ ENDP ; std::vector<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::size
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@QAEPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@I@Z ; std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T>::allocate
PUBLIC	?_Xlen@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@KAXXZ ; std::vector<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::_Xlen
PUBLIC	?max_size@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::max_size
; Function compile flags: /Odtp
;	COMDAT ?_Buy@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Capacity$ = 8						; size = 4
?_Buy@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAE_NI@Z PROC ; std::vector<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+20], 0

; 1104 : 		if (_Capacity == 0)

	cmp	DWORD PTR __Capacity$[ebp], 0
	jne	SHORT $LN4@Buy@3

; 1105 : 			return (false);

	xor	al, al
	jmp	SHORT $LN5@Buy@3
	jmp	SHORT $LN3@Buy@3
$LN4@Buy@3:

; 1106 : 		else if (max_size() < _Capacity)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::max_size
	cmp	eax, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN2@Buy@3

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@KAXXZ ; std::vector<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::_Xlen

; 1108 : 		else

	jmp	SHORT $LN3@Buy@3
$LN2@Buy@3:

; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	mov	eax, DWORD PTR __Capacity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?allocate@?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@QAEPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@I@Z ; std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T>::allocate
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [edx+16], ecx

; 1112 : 			_Myend = _Myfirst + _Capacity;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR __Capacity$[ebp]
	lea	edx, DWORD PTR [eax+ecx*8]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], edx
$LN3@Buy@3:

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
$LN5@Buy@3:

; 1115 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Buy@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::_Buy
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Tidy@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAEXXZ PROC ; std::vector<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	je	SHORT $LN1@Tidy@3

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAEXPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@0@Z ; std::vector<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::_Destroy

; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+20]
	sub	ecx, DWORD PTR [eax+12]
	sar	ecx, 3
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?deallocate@?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@QAEXPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@I@Z ; std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T>::deallocate
$LN1@Tidy@3:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+16], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], 0

; 1135 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAEXXZ ENDP ; std::vector<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::_Tidy
_TEXT	ENDS
PUBLIC	??0?$_Container_base_aux_alloc_real@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAE@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::_Container_base_aux_alloc_real<std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$_Vector_val@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAE@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Vector_val@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAE@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@1@@Z$0
__ehfuncinfo$??0?$_Vector_val@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAE@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Vector_val@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAE@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Vector_val@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAE@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@1@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T95601 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 1
??0?$_Vector_val@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAE@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@1@@Z PROC ; std::_Vector_val<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::_Vector_val<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Vector_val@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAE@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T95601[ebp], esp
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	call	??0?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T>::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Container_base_aux_alloc_real@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAE@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::_Container_base_aux_alloc_real<std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??0?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T>::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T>

; 426  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Vector_val@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAE@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Container_base_aux_alloc_real@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >
__ehhandler$??0?$_Vector_val@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAE@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Vector_val@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAE@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Vector_val@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAE@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@1@@Z ENDP ; std::_Vector_val<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::_Vector_val<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??1?$_Container_base_aux_alloc_real@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Container_base_aux_alloc_real@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAE@XZ$0
__ehfuncinfo$??1?$_Container_base_aux_alloc_real@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Container_base_aux_alloc_real@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$_Container_base_aux_alloc_real@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Container_base_aux_alloc_real@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >, COMDAT
; _this$ = ecx

; 436  : 		{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Container_base_aux_alloc_real@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 437  : 		_Myownedaux->~_Aux_cont();
; 438  : 
; 439  : 		_Alaux.deallocate(_Myownedaux, 1);

	push	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?deallocate@?$allocator@V_Aux_cont@std@@@std@@QAEXPAV_Aux_cont@2@I@Z ; std::allocator<std::_Aux_cont>::deallocate

; 440  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Container_base_aux_alloc_real@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
__ehhandler$??1?$_Container_base_aux_alloc_real@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Container_base_aux_alloc_real@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Container_base_aux_alloc_real@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@QAE@ABV01@@Z PROC ; std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T>::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T>, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T>::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T>
_TEXT	ENDS
PUBLIC	??$KEYFRAME_HERMITE@VColourValue@Ogre@@@Ogre@@YAXAAVColourValue@0@MABV10@111@Z ; Ogre::KEYFRAME_HERMITE<Ogre::ColourValue>
PUBLIC	??A?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAEAAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@I@Z ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::operator[]
PUBLIC	??$KEYFRAME_LERP@VColourValue@Ogre@@@Ogre@@YAXAAVColourValue@0@MABV10@1@Z ; Ogre::KEYFRAME_LERP<Ogre::ColourValue>
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogrekeyframearray.h
;	COMDAT ?getValue@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@QAEXHIAAVColourValue@2@_N@Z
_TEXT	SEGMENT
tv567 = -84						; size = 8
tv565 = -76						; size = 4
tv493 = -72						; size = 8
tv491 = -64						; size = 4
_this$ = -60						; size = 4
_tick1$75409 = -56					; size = 4
_t$75413 = -52						; size = 4
_tick2$75410 = -48					; size = 4
_middle$75404 = -44					; size = 4
_tick1$75369 = -40					; size = 4
_t$75373 = -36						; size = 4
_tick2$75370 = -32					; size = 4
_i$75355 = -28						; size = 4
_start$ = -24						; size = 4
_end$ = -20						; size = 4
_dtick$ = -16						; size = 4
_size$ = -12						; size = 4
_ntotalkeys$ = -8					; size = 4
_nseq$ = -4						; size = 4
_seq$ = 8						; size = 4
_tick$ = 12						; size = 4
_data$ = 16						; size = 4
_loop$ = 20						; size = 1
?getValue@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@QAEXHIAAVColourValue@2@_N@Z PROC ; Ogre::KeyFrameArray<Ogre::ColourValue>::getValue, COMDAT
; _this$ = ecx

; 104  : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 105  : 			int size = (int)m_Array.size();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	?size@?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::size
	mov	DWORD PTR _size$[ebp], eax

; 106  : 
; 107  : 			//assert(size > 0);
; 108  : 
; 109  : 			if (size == 0)

	cmp	DWORD PTR _size$[ebp], 0
	jne	SHORT $LN29@getValue@2

; 110  : 				return;

	jmp	$LN30@getValue@2
$LN29@getValue@2:

; 111  : 			
; 112  : 			data = m_Array[0].data;

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??A?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAEAAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@I@Z ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::operator[]
	add	eax, 4
	mov	ecx, DWORD PTR _data$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], eax

; 113  : 
; 114  : 			int start, end;
; 115  : 			int ntotalkeys = (int)m_Array.size();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	?size@?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::size
	mov	DWORD PTR _ntotalkeys$[ebp], eax

; 116  : 			int nseq = (int)m_Ranges.size();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?size@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::size
	mov	DWORD PTR _nseq$[ebp], eax

; 117  : 
; 118  : 			if(nseq == 0)

	cmp	DWORD PTR _nseq$[ebp], 0
	jne	SHORT $LN28@getValue@2

; 119  : 			{
; 120  : 				start = 0;

	mov	DWORD PTR _start$[ebp], 0

; 121  : 				end = ntotalkeys-1;

	mov	ecx, DWORD PTR _ntotalkeys$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _end$[ebp], ecx

; 122  : 			}
; 123  : 			else

	jmp	SHORT $LN27@getValue@2
$LN28@getValue@2:

; 124  : 			{
; 125  : 				assert(seq>=0 && seq<nseq);
; 126  : 				start = m_Ranges[seq].begin;

	mov	edx, DWORD PTR _seq$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??A?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAEAAUAnimRange@BaseKeyFrameArray@Ogre@@I@Z ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::operator[]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR _start$[ebp], eax

; 127  : 				end = m_Ranges[seq].end;

	mov	ecx, DWORD PTR _seq$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??A?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAEAAUAnimRange@BaseKeyFrameArray@Ogre@@I@Z ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::operator[]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _end$[ebp], edx
$LN27@getValue@2:

; 128  : 				assert(start <= end);
; 129  : 			}
; 130  : 			
; 131  : 
; 132  : 			if(m_Type == INTERPOL_RANDOM)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+32], 3
	jne	SHORT $LN26@getValue@2

; 133  : 			{
; 134  : 				int i = start;

	mov	ecx, DWORD PTR _start$[ebp]
	mov	DWORD PTR _i$75355[ebp], ecx

; 135  : 				if(end > start) i += rand()%(end-start);

	mov	edx, DWORD PTR _end$[ebp]
	cmp	edx, DWORD PTR _start$[ebp]
	jle	SHORT $LN25@getValue@2
	call	DWORD PTR __imp__rand
	mov	ecx, DWORD PTR _end$[ebp]
	sub	ecx, DWORD PTR _start$[ebp]
	cdq
	idiv	ecx
	add	edx, DWORD PTR _i$75355[ebp]
	mov	DWORD PTR _i$75355[ebp], edx
$LN25@getValue@2:

; 136  : 
; 137  : 				data = m_Array[i].data;

	mov	edx, DWORD PTR _i$75355[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??A?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAEAAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@I@Z ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::operator[]
	add	eax, 4
	mov	ecx, DWORD PTR _data$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], eax

; 138  : 				return;

	jmp	$LN30@getValue@2
$LN26@getValue@2:

; 139  : 			}
; 140  : 			if(start >= size)

	mov	ecx, DWORD PTR _start$[ebp]
	cmp	ecx, DWORD PTR _size$[ebp]
	jl	SHORT $LN24@getValue@2

; 141  : 			{
; 142  : 				start = size -1;

	mov	edx, DWORD PTR _size$[ebp]
	sub	edx, 1
	mov	DWORD PTR _start$[ebp], edx
$LN24@getValue@2:

; 143  : 			}
; 144  : 			if(end >= size)

	mov	eax, DWORD PTR _end$[ebp]
	cmp	eax, DWORD PTR _size$[ebp]
	jl	SHORT $LN23@getValue@2

; 145  : 			{
; 146  : 				end = size -1;

	mov	ecx, DWORD PTR _size$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _end$[ebp], ecx
$LN23@getValue@2:

; 147  : 			}
; 148  : 			tick -= m_Array[start].tick;

	mov	edx, DWORD PTR _start$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??A?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAEAAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@I@Z ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::operator[]
	mov	ecx, DWORD PTR _tick$[ebp]
	sub	ecx, DWORD PTR [eax]
	mov	DWORD PTR _tick$[ebp], ecx

; 149  : 			uint dtick = (m_Array[end].tick - m_Array[start].tick + 1);

	mov	edx, DWORD PTR _end$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??A?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAEAAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@I@Z ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::operator[]
	mov	esi, eax
	mov	eax, DWORD PTR _start$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??A?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAEAAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@I@Z ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::operator[]
	mov	ecx, DWORD PTR [esi]
	sub	ecx, DWORD PTR [eax]
	add	ecx, 1
	mov	DWORD PTR _dtick$[ebp], ecx

; 150  : 			if(dtick == 0) tick = m_Array[start].tick;

	jne	SHORT $LN22@getValue@2
	mov	edx, DWORD PTR _start$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??A?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAEAAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@I@Z ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::operator[]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR _tick$[ebp], eax

; 151  : 			else

	jmp	SHORT $LN17@getValue@2
$LN22@getValue@2:

; 152  : 			{	
; 153  : 				if(loop) tick = m_Array[start].tick + (tick%dtick);

	movzx	ecx, BYTE PTR _loop$[ebp]
	test	ecx, ecx
	je	SHORT $LN20@getValue@2
	mov	edx, DWORD PTR _start$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??A?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAEAAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@I@Z ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::operator[]
	mov	ecx, eax
	mov	eax, DWORD PTR _tick$[ebp]
	xor	edx, edx
	div	DWORD PTR _dtick$[ebp]
	add	edx, DWORD PTR [ecx]
	mov	DWORD PTR _tick$[ebp], edx
	jmp	SHORT $LN17@getValue@2
$LN20@getValue@2:

; 154  : 				else if(dtick < tick) tick = m_Array[end].tick;

	mov	edx, DWORD PTR _dtick$[ebp]
	cmp	edx, DWORD PTR _tick$[ebp]
	jae	SHORT $LN18@getValue@2
	mov	eax, DWORD PTR _end$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??A?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAEAAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@I@Z ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::operator[]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _tick$[ebp], ecx
	jmp	SHORT $LN17@getValue@2
$LN18@getValue@2:

; 155  : 				else tick = m_Array[start].tick + tick;

	mov	edx, DWORD PTR _start$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??A?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAEAAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@I@Z ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::operator[]
	mov	eax, DWORD PTR [eax]
	add	eax, DWORD PTR _tick$[ebp]
	mov	DWORD PTR _tick$[ebp], eax
$LN17@getValue@2:

; 156  : 			}
; 157  : 
; 158  : 			if ( m_nPrindex >= start && m_nPrindex  < end )  

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+84]
	cmp	edx, DWORD PTR _start$[ebp]
	jl	$LN14@getValue@2
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+84]
	cmp	ecx, DWORD PTR _end$[ebp]
	jge	$LN14@getValue@2

; 159  : 			{
; 160  : 				if ( tick > m_Array[m_nPrindex + 1].tick && m_nPrindex + 2 <= end)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+84]
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??A?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAEAAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@I@Z ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::operator[]
	mov	ecx, DWORD PTR _tick$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jbe	SHORT $LN15@getValue@2
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+84]
	add	eax, 2
	cmp	eax, DWORD PTR _end$[ebp]
	jg	SHORT $LN15@getValue@2

; 161  : 				{
; 162  : 					m_nPrindex++;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+84]
	add	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+84], edx
$LN15@getValue@2:

; 163  : 				}
; 164  : 				if ( tick >= m_Array[m_nPrindex].tick && tick <= m_Array[m_nPrindex + 1].tick )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+84]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??A?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAEAAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@I@Z ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::operator[]
	mov	ecx, DWORD PTR _tick$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jb	$LN14@getValue@2
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+84]
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??A?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAEAAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@I@Z ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::operator[]
	mov	ecx, DWORD PTR _tick$[ebp]
	cmp	ecx, DWORD PTR [eax]
	ja	$LN14@getValue@2

; 165  : 				{
; 166  : 					uint tick1 = m_Array[m_nPrindex].tick;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+84]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??A?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAEAAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@I@Z ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::operator[]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _tick1$75369[ebp], ecx

; 167  : 					uint tick2 = m_Array[m_nPrindex+1].tick;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+84]
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??A?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAEAAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@I@Z ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::operator[]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _tick2$75370[ebp], ecx

; 168  : 					if( tick1 == tick2 )

	mov	edx, DWORD PTR _tick1$75369[ebp]
	cmp	edx, DWORD PTR _tick2$75370[ebp]
	jne	SHORT $LN13@getValue@2

; 169  : 					{
; 170  : 						return;

	jmp	$LN30@getValue@2
$LN13@getValue@2:

; 171  : 					}
; 172  : 					assert( tick1 < tick2);
; 173  : 
; 174  : 					float t = float( int(tick-tick1) / double(tick2-tick1) );

	mov	eax, DWORD PTR _tick$[ebp]
	sub	eax, DWORD PTR _tick1$75369[ebp]
	mov	DWORD PTR tv491[ebp], eax
	fild	DWORD PTR tv491[ebp]
	mov	ecx, DWORD PTR _tick2$75370[ebp]
	sub	ecx, DWORD PTR _tick1$75369[ebp]
	mov	DWORD PTR tv493[ebp], ecx
	mov	DWORD PTR tv493[ebp+4], 0
	fild	QWORD PTR tv493[ebp]
	fdivp	ST(1), ST(0)
	fstp	DWORD PTR _t$75373[ebp]

; 175  : 					if(m_Type == INTERPOL_LINEAR) KEYFRAME_LERP( data, t, m_Array[m_nPrindex].data, m_Array[m_nPrindex + 1].data);

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+32], 1
	jne	SHORT $LN12@getValue@2
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+84]
	add	ecx, 1
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??A?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAEAAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@I@Z ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::operator[]
	add	eax, 4
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+84]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??A?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAEAAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@I@Z ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::operator[]
	add	eax, 4
	push	eax
	push	ecx
	fld	DWORD PTR _t$75373[ebp]
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _data$[ebp]
	push	ecx
	call	??$KEYFRAME_LERP@VColourValue@Ogre@@@Ogre@@YAXAAVColourValue@0@MABV10@1@Z ; Ogre::KEYFRAME_LERP<Ogre::ColourValue>
	add	esp, 16					; 00000010H
	jmp	SHORT $LN11@getValue@2
$LN12@getValue@2:

; 176  : 					else KEYFRAME_HERMITE(data, t, m_Array[m_nPrindex].data, m_Array[m_nPrindex + 1].data, m_CtrlPt[m_nPrindex].out, m_CtrlPt[m_nPrindex + 1].in);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+84]
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 60					; 0000003cH
	call	??A?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAEAAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@I@Z ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::operator[]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+84]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 60					; 0000003cH
	call	??A?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAEAAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@I@Z ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::operator[]
	add	eax, 16					; 00000010H
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+84]
	add	ecx, 1
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??A?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAEAAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@I@Z ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::operator[]
	add	eax, 4
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+84]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??A?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAEAAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@I@Z ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::operator[]
	add	eax, 4
	push	eax
	push	ecx
	fld	DWORD PTR _t$75373[ebp]
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _data$[ebp]
	push	ecx
	call	??$KEYFRAME_HERMITE@VColourValue@Ogre@@@Ogre@@YAXAAVColourValue@0@MABV10@111@Z ; Ogre::KEYFRAME_HERMITE<Ogre::ColourValue>
	add	esp, 24					; 00000018H
$LN11@getValue@2:

; 177  : 					return;

	jmp	$LN30@getValue@2
$LN14@getValue@2:

; 178  : 				}
; 179  : 				//while ( m_nPrindex < end)
; 180  : 				//{
; 181  : 				//	if ( tick >= m_Array[m_nPrindex].tick && tick <= m_Array[m_nPrindex + 1].tick )
; 182  : 				//	{
; 183  : 				//		uint tick1 = m_Array[m_nPrindex].tick;
; 184  : 				//		uint tick2 = m_Array[m_nPrindex+1].tick;
; 185  : 				//		if( tick1 == tick2 )
; 186  : 				//		{
; 187  : 				//			return;
; 188  : 				//		}
; 189  : 				//		assert( tick1 < tick2);
; 190  : 
; 191  : 				//		float t = float( int(tick-tick1) / double(tick2-tick1) );
; 192  : 				//		if(m_Type == INTERPOL_LINEAR) KEYFRAME_LERP( data, t, m_Array[m_nPrindex].data, m_Array[m_nPrindex + 1].data);
; 193  : 				//		else KEYFRAME_HERMITE(data, t, m_Array[m_nPrindex].data, m_Array[m_nPrindex + 1].data, m_CtrlPt[m_nPrindex].out, m_CtrlPt[m_nPrindex + 1].in);
; 194  : 				//		return;
; 195  : 				//	}
; 196  : 				//	m_nPrindex++;
; 197  : 				//}
; 198  : 			}
; 199  : 			//char po[100];
; 200  : 			//sprintf(po,"start %d end %d\n",start,end);
; 201  : 			//OutputDebugString(po);
; 202  : 
; 203  : 			for(;;)
; 204  : 			{
; 205  : 				if( start >= end-1 ) break;

	mov	edx, DWORD PTR _end$[ebp]
	sub	edx, 1
	cmp	DWORD PTR _start$[ebp], edx
	jl	SHORT $LN8@getValue@2
	jmp	SHORT $LN9@getValue@2
$LN8@getValue@2:

; 206  : 
; 207  : 				int middle = (start+end)/2;

	mov	eax, DWORD PTR _start$[ebp]
	add	eax, DWORD PTR _end$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR _middle$75404[ebp], eax

; 208  : 				if( tick < m_Array[middle].tick ) end = middle;

	mov	eax, DWORD PTR _middle$75404[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??A?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAEAAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@I@Z ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::operator[]
	mov	ecx, DWORD PTR _tick$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jae	SHORT $LN7@getValue@2
	mov	edx, DWORD PTR _middle$75404[ebp]
	mov	DWORD PTR _end$[ebp], edx
	jmp	SHORT $LN6@getValue@2
$LN7@getValue@2:

; 209  : 				else start = middle;

	mov	eax, DWORD PTR _middle$75404[ebp]
	mov	DWORD PTR _start$[ebp], eax
$LN6@getValue@2:

; 210  : 			}

	jmp	SHORT $LN14@getValue@2
$LN9@getValue@2:

; 211  : 
; 212  : 			if( start == end ) data = m_Array[start].data;

	mov	ecx, DWORD PTR _start$[ebp]
	cmp	ecx, DWORD PTR _end$[ebp]
	jne	SHORT $LN5@getValue@2
	mov	edx, DWORD PTR _start$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??A?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAEAAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@I@Z ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::operator[]
	add	eax, 4
	mov	ecx, DWORD PTR _data$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], eax

; 213  : 			else

	jmp	$LN4@getValue@2
$LN5@getValue@2:

; 214  : 			{
; 215  : 				uint tick1 = m_Array[start].tick;

	mov	ecx, DWORD PTR _start$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??A?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAEAAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@I@Z ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::operator[]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR _tick1$75409[ebp], edx

; 216  : 				uint tick2 = m_Array[end].tick;

	mov	eax, DWORD PTR _end$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??A?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAEAAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@I@Z ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::operator[]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _tick2$75410[ebp], ecx

; 217  : 				if( tick1 == tick2 )

	mov	edx, DWORD PTR _tick1$75409[ebp]
	cmp	edx, DWORD PTR _tick2$75410[ebp]
	jne	SHORT $LN3@getValue@2

; 218  : 				{
; 219  : 					return;

	jmp	$LN30@getValue@2
$LN3@getValue@2:

; 220  : 				}
; 221  : 				assert( tick1 < tick2);
; 222  : 
; 223  : 				float t = float( int(tick-tick1) / double(tick2-tick1) );

	mov	eax, DWORD PTR _tick$[ebp]
	sub	eax, DWORD PTR _tick1$75409[ebp]
	mov	DWORD PTR tv565[ebp], eax
	fild	DWORD PTR tv565[ebp]
	mov	ecx, DWORD PTR _tick2$75410[ebp]
	sub	ecx, DWORD PTR _tick1$75409[ebp]
	mov	DWORD PTR tv567[ebp], ecx
	mov	DWORD PTR tv567[ebp+4], 0
	fild	QWORD PTR tv567[ebp]
	fdivp	ST(1), ST(0)
	fstp	DWORD PTR _t$75413[ebp]

; 224  : 				if(m_Type == INTERPOL_LINEAR) KEYFRAME_LERP( data, t, m_Array[start].data, m_Array[end].data);

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+32], 1
	jne	SHORT $LN2@getValue@2
	mov	eax, DWORD PTR _end$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??A?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAEAAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@I@Z ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::operator[]
	add	eax, 4
	push	eax
	mov	ecx, DWORD PTR _start$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??A?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAEAAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@I@Z ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::operator[]
	add	eax, 4
	push	eax
	push	ecx
	fld	DWORD PTR _t$75413[ebp]
	fstp	DWORD PTR [esp]
	mov	edx, DWORD PTR _data$[ebp]
	push	edx
	call	??$KEYFRAME_LERP@VColourValue@Ogre@@@Ogre@@YAXAAVColourValue@0@MABV10@1@Z ; Ogre::KEYFRAME_LERP<Ogre::ColourValue>
	add	esp, 16					; 00000010H
	jmp	SHORT $LN1@getValue@2
$LN2@getValue@2:

; 225  : 				else KEYFRAME_HERMITE(data, t, m_Array[start].data, m_Array[end].data, m_CtrlPt[start].out, m_CtrlPt[end].in);

	mov	eax, DWORD PTR _end$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 60					; 0000003cH
	call	??A?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAEAAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@I@Z ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::operator[]
	push	eax
	mov	ecx, DWORD PTR _start$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 60					; 0000003cH
	call	??A?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAEAAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@I@Z ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::operator[]
	add	eax, 16					; 00000010H
	push	eax
	mov	edx, DWORD PTR _end$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??A?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAEAAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@I@Z ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::operator[]
	add	eax, 4
	push	eax
	mov	eax, DWORD PTR _start$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 36					; 00000024H
	call	??A?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAEAAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@I@Z ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::operator[]
	add	eax, 4
	push	eax
	push	ecx
	fld	DWORD PTR _t$75413[ebp]
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _data$[ebp]
	push	ecx
	call	??$KEYFRAME_HERMITE@VColourValue@Ogre@@@Ogre@@YAXAAVColourValue@0@MABV10@111@Z ; Ogre::KEYFRAME_HERMITE<Ogre::ColourValue>
	add	esp, 24					; 00000018H
$LN1@getValue@2:

; 226  : 				m_nPrindex = start;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _start$[ebp]
	mov	DWORD PTR [edx+84], eax
$LN4@getValue@2:
$LN30@getValue@2:

; 227  : 			}
; 228  : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?getValue@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@QAEXHIAAVColourValue@2@_N@Z ENDP ; Ogre::KeyFrameArray<Ogre::ColourValue>::getValue
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@QAEXPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@I@Z ; std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T>::deallocate
PUBLIC	??$_Ucopy@PAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAEPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU234@00@Z ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::_Ucopy<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T *>
PUBLIC	?capacity@?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::capacity
PUBLIC	?_Destroy@?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAEXPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@0@Z ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::_Destroy
PUBLIC	??$unchecked_copy@PAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@@stdext@@YAPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@00@Z ; stdext::unchecked_copy<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T *>
PUBLIC	?clear@?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAEXXZ ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::clear
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??4?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
__Ptr$75432 = -8					; size = 4
__Ptr$75422 = -4					; size = 4
__Right$ = 8						; size = 4
??4?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z PROC ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::operator=, COMDAT
; _this$ = ecx

; 563  : 		{	// assign _Right

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 564  : 		if (this != &_Right)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR __Right$[ebp]
	je	$LN9@operator@36

; 565  : 			{	// worth doing
; 566  : 
; 567  :  #if _HAS_ITERATOR_DEBUGGING
; 568  : 			this->_Orphan_all();
; 569  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 570  : 
; 571  : 			if (_Right.size() == 0)

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::size
	test	eax, eax
	jne	SHORT $LN8@operator@36

; 572  : 				clear();	// new sequence empty, erase existing sequence

	mov	ecx, DWORD PTR _this$[ebp]
	call	?clear@?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAEXXZ ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::clear
	jmp	$LN9@operator@36
$LN8@operator@36:

; 573  : 			else if (_Right.size() <= size())

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::size
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::size
	cmp	esi, eax
	ja	SHORT $LN6@operator@36

; 574  : 				{	// enough elements, copy new and destroy old
; 575  : 				pointer _Ptr = _STDEXT unchecked_copy(_Right._Myfirst, _Right._Mylast,
; 576  : 					_Myfirst);	// copy new

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	call	??$unchecked_copy@PAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@@stdext@@YAPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@00@Z ; stdext::unchecked_copy<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T *>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR __Ptr$75422[ebp], eax

; 577  : 				_Destroy(_Ptr, _Mylast);	// destroy old

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR __Ptr$75422[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAEXPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@0@Z ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::_Destroy

; 578  : 				_Mylast = _Myfirst + _Right.size();

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::size
	imul	eax, 20					; 00000014H
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+12]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+16], eax
	jmp	$LN9@operator@36
$LN6@operator@36:

; 579  : 				}
; 580  : 			else if (_Right.size() <= capacity())

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::size
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?capacity@?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::capacity
	cmp	esi, eax
	ja	SHORT $LN4@operator@36

; 581  : 				{	// enough room, copy and construct new
; 582  : 				pointer _Ptr = _Right._Myfirst + size();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::size
	imul	eax, 20					; 00000014H
	mov	ecx, DWORD PTR __Right$[ebp]
	add	eax, DWORD PTR [ecx+12]
	mov	DWORD PTR __Ptr$75432[ebp], eax

; 583  : 				_STDEXT unchecked_copy(_Right._Myfirst, _Ptr, _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR __Ptr$75432[ebp]
	push	ecx
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	call	??$unchecked_copy@PAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@@stdext@@YAPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@00@Z ; stdext::unchecked_copy<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T *>
	add	esp, 12					; 0000000cH

; 584  : 				_Mylast = _Ucopy(_Ptr, _Right._Mylast, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Ptr$75432[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Ucopy@PAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAEPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU234@00@Z ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::_Ucopy<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T *>
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 585  : 				}
; 586  : 			else

	jmp	$LN9@operator@36
$LN4@operator@36:

; 587  : 				{	// not enough room, allocate new array and construct new
; 588  : 				if (_Myfirst != 0)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+12], 0
	je	SHORT $LN2@operator@36

; 589  : 					{	// discard old array
; 590  : 					_Destroy(_Myfirst, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAEXPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@0@Z ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::_Destroy

; 591  : 					this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+20]
	sub	eax, DWORD PTR [edx+12]
	cdq
	mov	ecx, 20					; 00000014H
	idiv	ecx
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?deallocate@?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@QAEXPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@I@Z ; std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T>::deallocate
$LN2@operator@36:

; 592  : 					}
; 593  : 				if (_Buy(_Right.size()))

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::size
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAE_NI@Z ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::_Buy
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN9@operator@36

; 594  : 					_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 595  : 						_Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Ucopy@PAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAEPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU234@00@Z ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::_Ucopy<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T *>
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+16], eax
$LN9@operator@36:

; 596  : 				}
; 597  : 			}
; 598  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 599  : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
??4?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z ENDP ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::operator=
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAE@PAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >
; Function compile flags: /Odtp
;	COMDAT ?begin@?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@2@XZ PROC ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::begin, COMDAT
; _this$ = ecx

; 645  : 		{	// return iterator for beginning of nonmutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 646  : 		return (const_iterator(_Myfirst, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAE@PAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 647  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?begin@?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@2@XZ ENDP ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::begin
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?end@?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@2@XZ PROC ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::end, COMDAT
; _this$ = ecx

; 655  : 		{	// return iterator for end of nonmutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 656  : 		return (const_iterator(_Mylast, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAE@PAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 657  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?end@?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@2@XZ ENDP ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::end
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?size@?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QBEIXZ PROC ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::size, COMDAT
; _this$ = ecx

; 725  : 		{	// return length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+16]
	sub	eax, DWORD PTR [ecx+12]
	cdq
	mov	ecx, 20					; 00000014H
	idiv	ecx

; 727  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?size@?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QBEIXZ ENDP ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::size
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?empty@?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?empty@?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QBE_NXZ PROC ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::empty, COMDAT
; _this$ = ecx

; 735  : 		{	// test if sequence is empty

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 736  : 		return (size() == 0);

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::size
	neg	eax
	sbb	eax, eax
	add	eax, 1

; 737  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?empty@?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QBE_NXZ ENDP ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::empty
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??A?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAEAAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pos$ = 8						; size = 4
??A?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAEAAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@I@Z PROC ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::operator[], COMDAT
; _this$ = ecx

; 774  : 		{	// subscript mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)
; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");
; 780  : 			_SCL_SECURE_OUT_OF_RANGE;
; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::size
	cmp	DWORD PTR __Pos$[ebp], eax
	jb	SHORT $LN1@operator@37
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN1@operator@37:

; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR __Pos$[ebp]
	imul	eax, 20					; 00000014H
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+12]

; 786  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??A?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAEAAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@I@Z ENDP ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::operator[]
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@QAEPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@I@Z ; std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T>::allocate
PUBLIC	?_Xlen@?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@KAXXZ ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::_Xlen
PUBLIC	?max_size@?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::max_size
; Function compile flags: /Odtp
;	COMDAT ?_Buy@?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Capacity$ = 8						; size = 4
?_Buy@?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAE_NI@Z PROC ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+20], 0

; 1104 : 		if (_Capacity == 0)

	cmp	DWORD PTR __Capacity$[ebp], 0
	jne	SHORT $LN4@Buy@4

; 1105 : 			return (false);

	xor	al, al
	jmp	SHORT $LN5@Buy@4
	jmp	SHORT $LN3@Buy@4
$LN4@Buy@4:

; 1106 : 		else if (max_size() < _Capacity)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::max_size
	cmp	eax, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN2@Buy@4

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@KAXXZ ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::_Xlen

; 1108 : 		else

	jmp	SHORT $LN3@Buy@4
$LN2@Buy@4:

; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	mov	eax, DWORD PTR __Capacity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?allocate@?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@QAEPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@I@Z ; std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T>::allocate
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [edx+16], ecx

; 1112 : 			_Myend = _Myfirst + _Capacity;

	mov	edx, DWORD PTR __Capacity$[ebp]
	imul	edx, 20					; 00000014H
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+12]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+20], edx
$LN3@Buy@4:

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
$LN5@Buy@4:

; 1115 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Buy@?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::_Buy
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Tidy@?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAEXXZ PROC ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	je	SHORT $LN1@Tidy@4

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAEXPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@0@Z ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::_Destroy

; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+20]
	sub	ecx, DWORD PTR [eax+12]
	mov	eax, ecx
	cdq
	mov	ecx, 20					; 00000014H
	idiv	ecx
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?deallocate@?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@QAEXPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@I@Z ; std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T>::deallocate
$LN1@Tidy@4:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+16], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], 0

; 1135 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAEXXZ ENDP ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::_Tidy
_TEXT	ENDS
PUBLIC	??0?$_Container_base_aux_alloc_real@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAE@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::_Container_base_aux_alloc_real<std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$_Vector_val@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAE@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Vector_val@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAE@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@1@@Z$0
__ehfuncinfo$??0?$_Vector_val@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAE@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Vector_val@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAE@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Vector_val@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAE@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@1@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T95640 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 1
??0?$_Vector_val@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAE@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@1@@Z PROC ; std::_Vector_val<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::_Vector_val<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Vector_val@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAE@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T95640[ebp], esp
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	call	??0?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T>::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Container_base_aux_alloc_real@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAE@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::_Container_base_aux_alloc_real<std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??0?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T>::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T>

; 426  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Vector_val@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAE@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Container_base_aux_alloc_real@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >
__ehhandler$??0?$_Vector_val@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAE@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Vector_val@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAE@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Vector_val@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAE@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@1@@Z ENDP ; std::_Vector_val<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::_Vector_val<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??1?$_Container_base_aux_alloc_real@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Container_base_aux_alloc_real@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAE@XZ$0
__ehfuncinfo$??1?$_Container_base_aux_alloc_real@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Container_base_aux_alloc_real@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$_Container_base_aux_alloc_real@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Container_base_aux_alloc_real@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >, COMDAT
; _this$ = ecx

; 436  : 		{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Container_base_aux_alloc_real@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 437  : 		_Myownedaux->~_Aux_cont();
; 438  : 
; 439  : 		_Alaux.deallocate(_Myownedaux, 1);

	push	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?deallocate@?$allocator@V_Aux_cont@std@@@std@@QAEXPAV_Aux_cont@2@I@Z ; std::allocator<std::_Aux_cont>::deallocate

; 440  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Container_base_aux_alloc_real@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
__ehhandler$??1?$_Container_base_aux_alloc_real@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Container_base_aux_alloc_real@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Container_base_aux_alloc_real@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@QAE@ABV01@@Z PROC ; std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T>::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T>, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T>::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T>
_TEXT	ENDS
PUBLIC	?deallocate@?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@QAEXPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@I@Z ; std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T>::deallocate
PUBLIC	??$_Ucopy@PAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAEPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU234@00@Z ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::_Ucopy<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T *>
PUBLIC	?capacity@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::capacity
PUBLIC	?_Destroy@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAEXPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@0@Z ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::_Destroy
PUBLIC	??$unchecked_copy@PAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@@stdext@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@00@Z ; stdext::unchecked_copy<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T *>
PUBLIC	?clear@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAEXXZ ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::clear
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??4?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
__Ptr$75490 = -8					; size = 4
__Ptr$75480 = -4					; size = 4
__Right$ = 8						; size = 4
??4?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z PROC ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::operator=, COMDAT
; _this$ = ecx

; 563  : 		{	// assign _Right

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 564  : 		if (this != &_Right)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR __Right$[ebp]
	je	$LN9@operator@38

; 565  : 			{	// worth doing
; 566  : 
; 567  :  #if _HAS_ITERATOR_DEBUGGING
; 568  : 			this->_Orphan_all();
; 569  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 570  : 
; 571  : 			if (_Right.size() == 0)

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::size
	test	eax, eax
	jne	SHORT $LN8@operator@38

; 572  : 				clear();	// new sequence empty, erase existing sequence

	mov	ecx, DWORD PTR _this$[ebp]
	call	?clear@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAEXXZ ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::clear
	jmp	$LN9@operator@38
$LN8@operator@38:

; 573  : 			else if (_Right.size() <= size())

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::size
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::size
	cmp	esi, eax
	ja	SHORT $LN6@operator@38

; 574  : 				{	// enough elements, copy new and destroy old
; 575  : 				pointer _Ptr = _STDEXT unchecked_copy(_Right._Myfirst, _Right._Mylast,
; 576  : 					_Myfirst);	// copy new

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	call	??$unchecked_copy@PAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@@stdext@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@00@Z ; stdext::unchecked_copy<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T *>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR __Ptr$75480[ebp], eax

; 577  : 				_Destroy(_Ptr, _Mylast);	// destroy old

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR __Ptr$75480[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAEXPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@0@Z ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::_Destroy

; 578  : 				_Mylast = _Myfirst + _Right.size();

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::size
	shl	eax, 5
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+12]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+16], eax
	jmp	$LN9@operator@38
$LN6@operator@38:

; 579  : 				}
; 580  : 			else if (_Right.size() <= capacity())

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::size
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?capacity@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::capacity
	cmp	esi, eax
	ja	SHORT $LN4@operator@38

; 581  : 				{	// enough room, copy and construct new
; 582  : 				pointer _Ptr = _Right._Myfirst + size();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::size
	shl	eax, 5
	mov	ecx, DWORD PTR __Right$[ebp]
	add	eax, DWORD PTR [ecx+12]
	mov	DWORD PTR __Ptr$75490[ebp], eax

; 583  : 				_STDEXT unchecked_copy(_Right._Myfirst, _Ptr, _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR __Ptr$75490[ebp]
	push	ecx
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	call	??$unchecked_copy@PAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@@stdext@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@00@Z ; stdext::unchecked_copy<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T *>
	add	esp, 12					; 0000000cH

; 584  : 				_Mylast = _Ucopy(_Ptr, _Right._Mylast, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Ptr$75490[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Ucopy@PAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAEPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU234@00@Z ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::_Ucopy<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T *>
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 585  : 				}
; 586  : 			else

	jmp	SHORT $LN9@operator@38
$LN4@operator@38:

; 587  : 				{	// not enough room, allocate new array and construct new
; 588  : 				if (_Myfirst != 0)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+12], 0
	je	SHORT $LN2@operator@38

; 589  : 					{	// discard old array
; 590  : 					_Destroy(_Myfirst, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAEXPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@0@Z ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::_Destroy

; 591  : 					this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+20]
	sub	eax, DWORD PTR [edx+12]
	sar	eax, 5
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?deallocate@?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@QAEXPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@I@Z ; std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T>::deallocate
$LN2@operator@38:

; 592  : 					}
; 593  : 				if (_Buy(_Right.size()))

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::size
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAE_NI@Z ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::_Buy
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN9@operator@38

; 594  : 					_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 595  : 						_Myfirst);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Ucopy@PAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAEPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU234@00@Z ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::_Ucopy<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T *>
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax
$LN9@operator@38:

; 596  : 				}
; 597  : 			}
; 598  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 599  : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
??4?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAEAAV01@ABV01@@Z ENDP ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::operator=
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAE@PAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >
; Function compile flags: /Odtp
;	COMDAT ?begin@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@2@XZ PROC ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::begin, COMDAT
; _this$ = ecx

; 645  : 		{	// return iterator for beginning of nonmutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 646  : 		return (const_iterator(_Myfirst, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAE@PAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 647  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?begin@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@2@XZ ENDP ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::begin
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?end@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@2@XZ PROC ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::end, COMDAT
; _this$ = ecx

; 655  : 		{	// return iterator for end of nonmutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 656  : 		return (const_iterator(_Mylast, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAE@PAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 657  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?end@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@2@XZ ENDP ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::end
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?size@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QBEIXZ PROC ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::size, COMDAT
; _this$ = ecx

; 725  : 		{	// return length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+16]
	sub	eax, DWORD PTR [ecx+12]
	sar	eax, 5

; 727  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?size@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QBEIXZ ENDP ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::size
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@QAEPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@I@Z ; std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T>::allocate
PUBLIC	?_Xlen@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@KAXXZ ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::_Xlen
PUBLIC	?max_size@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::max_size
; Function compile flags: /Odtp
;	COMDAT ?_Buy@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Capacity$ = 8						; size = 4
?_Buy@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAE_NI@Z PROC ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+20], 0

; 1104 : 		if (_Capacity == 0)

	cmp	DWORD PTR __Capacity$[ebp], 0
	jne	SHORT $LN4@Buy@5

; 1105 : 			return (false);

	xor	al, al
	jmp	SHORT $LN5@Buy@5
	jmp	SHORT $LN3@Buy@5
$LN4@Buy@5:

; 1106 : 		else if (max_size() < _Capacity)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::max_size
	cmp	eax, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN2@Buy@5

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@KAXXZ ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::_Xlen

; 1108 : 		else

	jmp	SHORT $LN3@Buy@5
$LN2@Buy@5:

; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	mov	eax, DWORD PTR __Capacity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?allocate@?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@QAEPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@I@Z ; std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T>::allocate
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [edx+16], ecx

; 1112 : 			_Myend = _Myfirst + _Capacity;

	mov	edx, DWORD PTR __Capacity$[ebp]
	shl	edx, 5
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+12]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+20], edx
$LN3@Buy@5:

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
$LN5@Buy@5:

; 1115 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Buy@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::_Buy
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Tidy@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAEXXZ PROC ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	je	SHORT $LN1@Tidy@5

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAEXPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@0@Z ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::_Destroy

; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+20]
	sub	ecx, DWORD PTR [eax+12]
	sar	ecx, 5
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?deallocate@?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@QAEXPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@I@Z ; std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T>::deallocate
$LN1@Tidy@5:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+16], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], 0

; 1135 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAEXXZ ENDP ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::_Tidy
_TEXT	ENDS
PUBLIC	??0?$_Container_base_aux_alloc_real@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAE@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::_Container_base_aux_alloc_real<std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$_Vector_val@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAE@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Vector_val@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAE@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@1@@Z$0
__ehfuncinfo$??0?$_Vector_val@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAE@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Vector_val@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAE@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Vector_val@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAE@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@1@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T95673 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 1
??0?$_Vector_val@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAE@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@1@@Z PROC ; std::_Vector_val<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::_Vector_val<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Vector_val@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAE@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T95673[ebp], esp
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	call	??0?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T>::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Container_base_aux_alloc_real@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAE@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::_Container_base_aux_alloc_real<std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??0?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T>::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T>

; 426  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Vector_val@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAE@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Container_base_aux_alloc_real@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >
__ehhandler$??0?$_Vector_val@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAE@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Vector_val@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAE@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Vector_val@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAE@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@1@@Z ENDP ; std::_Vector_val<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::_Vector_val<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??1?$_Container_base_aux_alloc_real@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Container_base_aux_alloc_real@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAE@XZ$0
__ehfuncinfo$??1?$_Container_base_aux_alloc_real@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Container_base_aux_alloc_real@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$_Container_base_aux_alloc_real@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Container_base_aux_alloc_real@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >, COMDAT
; _this$ = ecx

; 436  : 		{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Container_base_aux_alloc_real@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 437  : 		_Myownedaux->~_Aux_cont();
; 438  : 
; 439  : 		_Alaux.deallocate(_Myownedaux, 1);

	push	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?deallocate@?$allocator@V_Aux_cont@std@@@std@@QAEXPAV_Aux_cont@2@I@Z ; std::allocator<std::_Aux_cont>::deallocate

; 440  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Container_base_aux_alloc_real@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
__ehhandler$??1?$_Container_base_aux_alloc_real@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Container_base_aux_alloc_real@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Container_base_aux_alloc_real@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@QAE@ABV01@@Z PROC ; std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T>::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T>, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T>::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?capacity@?$vector@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
tv70 = -8						; size = 4
_this$ = -4						; size = 4
?capacity@?$vector@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@QBEIXZ PROC ; std::vector<Ogre::ShaderContext *,std::allocator<Ogre::ShaderContext *> >::capacity, COMDAT
; _this$ = ecx

; 634  : 		{	// return current length of allocated storage

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	jne	SHORT $LN3@capacity
	mov	DWORD PTR tv70[ebp], 0
	jmp	SHORT $LN4@capacity
$LN3@capacity:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+20]
	sub	eax, DWORD PTR [edx+12]
	sar	eax, 2
	mov	DWORD PTR tv70[ebp], eax
$LN4@capacity:
	mov	eax, DWORD PTR tv70[ebp]

; 636  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?capacity@?$vector@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@QBEIXZ ENDP ; std::vector<Ogre::ShaderContext *,std::allocator<Ogre::ShaderContext *> >::capacity
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@QAE@PAPAVShaderContext@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<Ogre::ShaderContext *,std::allocator<Ogre::ShaderContext *> >::_Vector_const_iterator<Ogre::ShaderContext *,std::allocator<Ogre::ShaderContext *> >
; Function compile flags: /Odtp
;	COMDAT ?begin@?$vector@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@2@XZ PROC ; std::vector<Ogre::ShaderContext *,std::allocator<Ogre::ShaderContext *> >::begin, COMDAT
; _this$ = ecx

; 645  : 		{	// return iterator for beginning of nonmutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 646  : 		return (const_iterator(_Myfirst, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_const_iterator@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@QAE@PAPAVShaderContext@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<Ogre::ShaderContext *,std::allocator<Ogre::ShaderContext *> >::_Vector_const_iterator<Ogre::ShaderContext *,std::allocator<Ogre::ShaderContext *> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 647  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?begin@?$vector@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@2@XZ ENDP ; std::vector<Ogre::ShaderContext *,std::allocator<Ogre::ShaderContext *> >::begin
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?end@?$vector@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@2@XZ PROC ; std::vector<Ogre::ShaderContext *,std::allocator<Ogre::ShaderContext *> >::end, COMDAT
; _this$ = ecx

; 655  : 		{	// return iterator for end of nonmutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 656  : 		return (const_iterator(_Mylast, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_const_iterator@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@QAE@PAPAVShaderContext@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<Ogre::ShaderContext *,std::allocator<Ogre::ShaderContext *> >::_Vector_const_iterator<Ogre::ShaderContext *,std::allocator<Ogre::ShaderContext *> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 657  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?end@?$vector@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@2@XZ ENDP ; std::vector<Ogre::ShaderContext *,std::allocator<Ogre::ShaderContext *> >::end
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?size@?$vector@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$vector@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@QBEIXZ PROC ; std::vector<Ogre::ShaderContext *,std::allocator<Ogre::ShaderContext *> >::size, COMDAT
; _this$ = ecx

; 725  : 		{	// return length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+16]
	sub	eax, DWORD PTR [ecx+12]
	sar	eax, 2

; 727  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?size@?$vector@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@QBEIXZ ENDP ; std::vector<Ogre::ShaderContext *,std::allocator<Ogre::ShaderContext *> >::size
_TEXT	ENDS
PUBLIC	?erase@?$vector@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@2@0@Z ; std::vector<Ogre::ShaderContext *,std::allocator<Ogre::ShaderContext *> >::erase
PUBLIC	?begin@?$vector@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@2@XZ ; std::vector<Ogre::ShaderContext *,std::allocator<Ogre::ShaderContext *> >::begin
PUBLIC	?end@?$vector@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@2@XZ ; std::vector<Ogre::ShaderContext *,std::allocator<Ogre::ShaderContext *> >::end
; Function compile flags: /Odtp
;	COMDAT ?clear@?$vector@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -44						; size = 4
$T95708 = -40						; size = 8
$T95707 = -32						; size = 8
$T95706 = -24						; size = 8
$T95705 = -16						; size = 8
$T95704 = -8						; size = 8
?clear@?$vector@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@QAEXXZ PROC ; std::vector<Ogre::ShaderContext *,std::allocator<Ogre::ShaderContext *> >::clear, COMDAT
; _this$ = ecx

; 1059 : 		{	// erase all

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	mov	DWORD PTR _this$[ebp], ecx

; 1060 : 		erase(begin(), end());

	lea	eax, DWORD PTR $T95705[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$vector@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@2@XZ ; std::vector<Ogre::ShaderContext *,std::allocator<Ogre::ShaderContext *> >::end
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T95704[ebp], ecx
	mov	DWORD PTR $T95704[ebp+4], edx
	lea	eax, DWORD PTR $T95707[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$vector@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@2@XZ ; std::vector<Ogre::ShaderContext *,std::allocator<Ogre::ShaderContext *> >::begin
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T95706[ebp], ecx
	mov	DWORD PTR $T95706[ebp+4], edx
	mov	eax, DWORD PTR $T95704[ebp+4]
	push	eax
	mov	ecx, DWORD PTR $T95704[ebp]
	push	ecx
	mov	edx, DWORD PTR $T95706[ebp+4]
	push	edx
	mov	eax, DWORD PTR $T95706[ebp]
	push	eax
	lea	ecx, DWORD PTR $T95708[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$vector@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@2@0@Z ; std::vector<Ogre::ShaderContext *,std::allocator<Ogre::ShaderContext *> >::erase

; 1061 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?clear@?$vector@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@QAEXXZ ENDP ; std::vector<Ogre::ShaderContext *,std::allocator<Ogre::ShaderContext *> >::clear
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@PAVShaderContext@Ogre@@@std@@QAEPAPAVShaderContext@Ogre@@I@Z ; std::allocator<Ogre::ShaderContext *>::allocate
PUBLIC	?_Xlen@?$vector@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@KAXXZ ; std::vector<Ogre::ShaderContext *,std::allocator<Ogre::ShaderContext *> >::_Xlen
PUBLIC	?max_size@?$vector@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::ShaderContext *,std::allocator<Ogre::ShaderContext *> >::max_size
; Function compile flags: /Odtp
;	COMDAT ?_Buy@?$vector@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Capacity$ = 8						; size = 4
?_Buy@?$vector@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@IAE_NI@Z PROC ; std::vector<Ogre::ShaderContext *,std::allocator<Ogre::ShaderContext *> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+20], 0

; 1104 : 		if (_Capacity == 0)

	cmp	DWORD PTR __Capacity$[ebp], 0
	jne	SHORT $LN4@Buy@6

; 1105 : 			return (false);

	xor	al, al
	jmp	SHORT $LN5@Buy@6
	jmp	SHORT $LN3@Buy@6
$LN4@Buy@6:

; 1106 : 		else if (max_size() < _Capacity)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::ShaderContext *,std::allocator<Ogre::ShaderContext *> >::max_size
	cmp	eax, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN2@Buy@6

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@KAXXZ ; std::vector<Ogre::ShaderContext *,std::allocator<Ogre::ShaderContext *> >::_Xlen

; 1108 : 		else

	jmp	SHORT $LN3@Buy@6
$LN2@Buy@6:

; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	mov	eax, DWORD PTR __Capacity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?allocate@?$allocator@PAVShaderContext@Ogre@@@std@@QAEPAPAVShaderContext@Ogre@@I@Z ; std::allocator<Ogre::ShaderContext *>::allocate
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [edx+16], ecx

; 1112 : 			_Myend = _Myfirst + _Capacity;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR __Capacity$[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], edx
$LN3@Buy@6:

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
$LN5@Buy@6:

; 1115 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Buy@?$vector@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<Ogre::ShaderContext *,std::allocator<Ogre::ShaderContext *> >::_Buy
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@YAXPAPAVShaderContext@Ogre@@0AAV?$allocator@PAVShaderContext@Ogre@@@0@@Z ; std::_Destroy_range<std::allocator<Ogre::ShaderContext *> >
; Function compile flags: /Odtp
;	COMDAT ?_Destroy@?$vector@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@IAEXPAPAVShaderContext@Ogre@@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@IAEXPAPAVShaderContext@Ogre@@0@Z PROC ; std::vector<Ogre::ShaderContext *,std::allocator<Ogre::ShaderContext *> >::_Destroy, COMDAT
; _this$ = ecx

; 1118 : 		{	// destroy [_First, _Last) using allocator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Destroy_range@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@YAXPAPAVShaderContext@Ogre@@0AAV?$allocator@PAVShaderContext@Ogre@@@0@@Z ; std::_Destroy_range<std::allocator<Ogre::ShaderContext *> >
	add	esp, 12					; 0000000cH

; 1120 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?_Destroy@?$vector@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@IAEXPAPAVShaderContext@Ogre@@0@Z ENDP ; std::vector<Ogre::ShaderContext *,std::allocator<Ogre::ShaderContext *> >::_Destroy
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Tidy@?$vector@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@IAEXXZ PROC ; std::vector<Ogre::ShaderContext *,std::allocator<Ogre::ShaderContext *> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	je	SHORT $LN1@Tidy@6

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@IAEXPAPAVShaderContext@Ogre@@0@Z ; std::vector<Ogre::ShaderContext *,std::allocator<Ogre::ShaderContext *> >::_Destroy

; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+20]
	sub	ecx, DWORD PTR [eax+12]
	sar	ecx, 2
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?deallocate@?$allocator@PAVShaderContext@Ogre@@@std@@QAEXPAPAVShaderContext@Ogre@@I@Z ; std::allocator<Ogre::ShaderContext *>::deallocate
$LN1@Tidy@6:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+16], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], 0

; 1135 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$vector@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@IAEXXZ ENDP ; std::vector<Ogre::ShaderContext *,std::allocator<Ogre::ShaderContext *> >::_Tidy
_TEXT	ENDS
PUBLIC	??0?$_Container_base_aux_alloc_real@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@IAE@V?$allocator@PAVShaderContext@Ogre@@@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::ShaderContext *> >::_Container_base_aux_alloc_real<std::allocator<Ogre::ShaderContext *> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$_Vector_val@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@IAE@V?$allocator@PAVShaderContext@Ogre@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Vector_val@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@IAE@V?$allocator@PAVShaderContext@Ogre@@@1@@Z$0
__ehfuncinfo$??0?$_Vector_val@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@IAE@V?$allocator@PAVShaderContext@Ogre@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Vector_val@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@IAE@V?$allocator@PAVShaderContext@Ogre@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Vector_val@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@IAE@V?$allocator@PAVShaderContext@Ogre@@@1@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T95717 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 1
??0?$_Vector_val@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@IAE@V?$allocator@PAVShaderContext@Ogre@@@1@@Z PROC ; std::_Vector_val<Ogre::ShaderContext *,std::allocator<Ogre::ShaderContext *> >::_Vector_val<Ogre::ShaderContext *,std::allocator<Ogre::ShaderContext *> >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Vector_val@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@IAE@V?$allocator@PAVShaderContext@Ogre@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T95717[ebp], esp
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	call	??0?$allocator@PAVShaderContext@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::ShaderContext *>::allocator<Ogre::ShaderContext *>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Container_base_aux_alloc_real@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@IAE@V?$allocator@PAVShaderContext@Ogre@@@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::ShaderContext *> >::_Container_base_aux_alloc_real<std::allocator<Ogre::ShaderContext *> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??0?$allocator@PAVShaderContext@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::ShaderContext *>::allocator<Ogre::ShaderContext *>

; 426  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Vector_val@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@IAE@V?$allocator@PAVShaderContext@Ogre@@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Container_base_aux_alloc_real@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::ShaderContext *> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::ShaderContext *> >
__ehhandler$??0?$_Vector_val@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@IAE@V?$allocator@PAVShaderContext@Ogre@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Vector_val@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@IAE@V?$allocator@PAVShaderContext@Ogre@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Vector_val@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@IAE@V?$allocator@PAVShaderContext@Ogre@@@1@@Z ENDP ; std::_Vector_val<Ogre::ShaderContext *,std::allocator<Ogre::ShaderContext *> >::_Vector_val<Ogre::ShaderContext *,std::allocator<Ogre::ShaderContext *> >
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??1?$_Container_base_aux_alloc_real@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@IAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Container_base_aux_alloc_real@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@IAE@XZ$0
__ehfuncinfo$??1?$_Container_base_aux_alloc_real@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@IAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Container_base_aux_alloc_real@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@IAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$_Container_base_aux_alloc_real@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Container_base_aux_alloc_real@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::ShaderContext *> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::ShaderContext *> >, COMDAT
; _this$ = ecx

; 436  : 		{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Container_base_aux_alloc_real@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@IAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 437  : 		_Myownedaux->~_Aux_cont();
; 438  : 
; 439  : 		_Alaux.deallocate(_Myownedaux, 1);

	push	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?deallocate@?$allocator@V_Aux_cont@std@@@std@@QAEXPAV_Aux_cont@2@I@Z ; std::allocator<std::_Aux_cont>::deallocate

; 440  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Container_base_aux_alloc_real@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@IAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
__ehhandler$??1?$_Container_base_aux_alloc_real@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@IAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Container_base_aux_alloc_real@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@IAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Container_base_aux_alloc_real@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::ShaderContext *> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::ShaderContext *> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@PAVShaderContext@Ogre@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$allocator@PAVShaderContext@Ogre@@@std@@QAE@ABV01@@Z PROC ; std::allocator<Ogre::ShaderContext *>::allocator<Ogre::ShaderContext *>, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$allocator@PAVShaderContext@Ogre@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<Ogre::ShaderContext *>::allocator<Ogre::ShaderContext *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@PAVShaderContext@Ogre@@@std@@QAEXPAPAVShaderContext@Ogre@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@PAVShaderContext@Ogre@@@std@@QAEXPAPAVShaderContext@Ogre@@I@Z PROC ; std::allocator<Ogre::ShaderContext *>::deallocate, COMDAT
; _this$ = ecx

; 139  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 141  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@PAVShaderContext@Ogre@@@std@@QAEXPAPAVShaderContext@Ogre@@I@Z ENDP ; std::allocator<Ogre::ShaderContext *>::deallocate
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?capacity@?$vector@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
tv70 = -8						; size = 4
_this$ = -4						; size = 4
?capacity@?$vector@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@QBEIXZ PROC ; std::vector<Ogre::ContextQueDesc,std::allocator<Ogre::ContextQueDesc> >::capacity, COMDAT
; _this$ = ecx

; 634  : 		{	// return current length of allocated storage

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	jne	SHORT $LN3@capacity@2
	mov	DWORD PTR tv70[ebp], 0
	jmp	SHORT $LN4@capacity@2
$LN3@capacity@2:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+20]
	sub	eax, DWORD PTR [edx+12]
	cdq
	mov	ecx, 156				; 0000009cH
	idiv	ecx
	mov	DWORD PTR tv70[ebp], eax
$LN4@capacity@2:
	mov	eax, DWORD PTR tv70[ebp]

; 636  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?capacity@?$vector@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@QBEIXZ ENDP ; std::vector<Ogre::ContextQueDesc,std::allocator<Ogre::ContextQueDesc> >::capacity
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@QAE@PAUContextQueDesc@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<Ogre::ContextQueDesc,std::allocator<Ogre::ContextQueDesc> >::_Vector_const_iterator<Ogre::ContextQueDesc,std::allocator<Ogre::ContextQueDesc> >
; Function compile flags: /Odtp
;	COMDAT ?begin@?$vector@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@2@XZ PROC ; std::vector<Ogre::ContextQueDesc,std::allocator<Ogre::ContextQueDesc> >::begin, COMDAT
; _this$ = ecx

; 645  : 		{	// return iterator for beginning of nonmutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 646  : 		return (const_iterator(_Myfirst, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_const_iterator@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@QAE@PAUContextQueDesc@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<Ogre::ContextQueDesc,std::allocator<Ogre::ContextQueDesc> >::_Vector_const_iterator<Ogre::ContextQueDesc,std::allocator<Ogre::ContextQueDesc> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 647  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?begin@?$vector@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@2@XZ ENDP ; std::vector<Ogre::ContextQueDesc,std::allocator<Ogre::ContextQueDesc> >::begin
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?end@?$vector@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@2@XZ PROC ; std::vector<Ogre::ContextQueDesc,std::allocator<Ogre::ContextQueDesc> >::end, COMDAT
; _this$ = ecx

; 655  : 		{	// return iterator for end of nonmutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 656  : 		return (const_iterator(_Mylast, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_const_iterator@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@QAE@PAUContextQueDesc@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<Ogre::ContextQueDesc,std::allocator<Ogre::ContextQueDesc> >::_Vector_const_iterator<Ogre::ContextQueDesc,std::allocator<Ogre::ContextQueDesc> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 657  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?end@?$vector@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@2@XZ ENDP ; std::vector<Ogre::ContextQueDesc,std::allocator<Ogre::ContextQueDesc> >::end
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?size@?$vector@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$vector@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@QBEIXZ PROC ; std::vector<Ogre::ContextQueDesc,std::allocator<Ogre::ContextQueDesc> >::size, COMDAT
; _this$ = ecx

; 725  : 		{	// return length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+16]
	sub	eax, DWORD PTR [ecx+12]
	cdq
	mov	ecx, 156				; 0000009cH
	idiv	ecx

; 727  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?size@?$vector@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@QBEIXZ ENDP ; std::vector<Ogre::ContextQueDesc,std::allocator<Ogre::ContextQueDesc> >::size
_TEXT	ENDS
PUBLIC	?erase@?$vector@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@2@V?$_Vector_const_iterator@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@2@0@Z ; std::vector<Ogre::ContextQueDesc,std::allocator<Ogre::ContextQueDesc> >::erase
PUBLIC	?begin@?$vector@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@2@XZ ; std::vector<Ogre::ContextQueDesc,std::allocator<Ogre::ContextQueDesc> >::begin
PUBLIC	?end@?$vector@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@2@XZ ; std::vector<Ogre::ContextQueDesc,std::allocator<Ogre::ContextQueDesc> >::end
; Function compile flags: /Odtp
;	COMDAT ?clear@?$vector@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -44						; size = 4
$T95754 = -40						; size = 8
$T95753 = -32						; size = 8
$T95752 = -24						; size = 8
$T95751 = -16						; size = 8
$T95750 = -8						; size = 8
?clear@?$vector@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@QAEXXZ PROC ; std::vector<Ogre::ContextQueDesc,std::allocator<Ogre::ContextQueDesc> >::clear, COMDAT
; _this$ = ecx

; 1059 : 		{	// erase all

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	mov	DWORD PTR _this$[ebp], ecx

; 1060 : 		erase(begin(), end());

	lea	eax, DWORD PTR $T95751[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$vector@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@2@XZ ; std::vector<Ogre::ContextQueDesc,std::allocator<Ogre::ContextQueDesc> >::end
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T95750[ebp], ecx
	mov	DWORD PTR $T95750[ebp+4], edx
	lea	eax, DWORD PTR $T95753[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$vector@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@2@XZ ; std::vector<Ogre::ContextQueDesc,std::allocator<Ogre::ContextQueDesc> >::begin
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T95752[ebp], ecx
	mov	DWORD PTR $T95752[ebp+4], edx
	mov	eax, DWORD PTR $T95750[ebp+4]
	push	eax
	mov	ecx, DWORD PTR $T95750[ebp]
	push	ecx
	mov	edx, DWORD PTR $T95752[ebp+4]
	push	edx
	mov	eax, DWORD PTR $T95752[ebp]
	push	eax
	lea	ecx, DWORD PTR $T95754[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$vector@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@2@V?$_Vector_const_iterator@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@2@0@Z ; std::vector<Ogre::ContextQueDesc,std::allocator<Ogre::ContextQueDesc> >::erase

; 1061 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?clear@?$vector@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@QAEXXZ ENDP ; std::vector<Ogre::ContextQueDesc,std::allocator<Ogre::ContextQueDesc> >::clear
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@UContextQueDesc@Ogre@@@std@@QAEPAUContextQueDesc@Ogre@@I@Z ; std::allocator<Ogre::ContextQueDesc>::allocate
PUBLIC	?_Xlen@?$vector@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@KAXXZ ; std::vector<Ogre::ContextQueDesc,std::allocator<Ogre::ContextQueDesc> >::_Xlen
PUBLIC	?max_size@?$vector@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::ContextQueDesc,std::allocator<Ogre::ContextQueDesc> >::max_size
; Function compile flags: /Odtp
;	COMDAT ?_Buy@?$vector@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Capacity$ = 8						; size = 4
?_Buy@?$vector@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@IAE_NI@Z PROC ; std::vector<Ogre::ContextQueDesc,std::allocator<Ogre::ContextQueDesc> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+20], 0

; 1104 : 		if (_Capacity == 0)

	cmp	DWORD PTR __Capacity$[ebp], 0
	jne	SHORT $LN4@Buy@7

; 1105 : 			return (false);

	xor	al, al
	jmp	SHORT $LN5@Buy@7
	jmp	SHORT $LN3@Buy@7
$LN4@Buy@7:

; 1106 : 		else if (max_size() < _Capacity)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::ContextQueDesc,std::allocator<Ogre::ContextQueDesc> >::max_size
	cmp	eax, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN2@Buy@7

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@KAXXZ ; std::vector<Ogre::ContextQueDesc,std::allocator<Ogre::ContextQueDesc> >::_Xlen

; 1108 : 		else

	jmp	SHORT $LN3@Buy@7
$LN2@Buy@7:

; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	mov	eax, DWORD PTR __Capacity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?allocate@?$allocator@UContextQueDesc@Ogre@@@std@@QAEPAUContextQueDesc@Ogre@@I@Z ; std::allocator<Ogre::ContextQueDesc>::allocate
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [edx+16], ecx

; 1112 : 			_Myend = _Myfirst + _Capacity;

	mov	edx, DWORD PTR __Capacity$[ebp]
	imul	edx, 156				; 0000009cH
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+12]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+20], edx
$LN3@Buy@7:

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
$LN5@Buy@7:

; 1115 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Buy@?$vector@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<Ogre::ContextQueDesc,std::allocator<Ogre::ContextQueDesc> >::_Buy
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@YAXPAUContextQueDesc@Ogre@@0AAV?$allocator@UContextQueDesc@Ogre@@@0@@Z ; std::_Destroy_range<std::allocator<Ogre::ContextQueDesc> >
; Function compile flags: /Odtp
;	COMDAT ?_Destroy@?$vector@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@IAEXPAUContextQueDesc@Ogre@@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@IAEXPAUContextQueDesc@Ogre@@0@Z PROC ; std::vector<Ogre::ContextQueDesc,std::allocator<Ogre::ContextQueDesc> >::_Destroy, COMDAT
; _this$ = ecx

; 1118 : 		{	// destroy [_First, _Last) using allocator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Destroy_range@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@YAXPAUContextQueDesc@Ogre@@0AAV?$allocator@UContextQueDesc@Ogre@@@0@@Z ; std::_Destroy_range<std::allocator<Ogre::ContextQueDesc> >
	add	esp, 12					; 0000000cH

; 1120 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?_Destroy@?$vector@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@IAEXPAUContextQueDesc@Ogre@@0@Z ENDP ; std::vector<Ogre::ContextQueDesc,std::allocator<Ogre::ContextQueDesc> >::_Destroy
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Tidy@?$vector@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@IAEXXZ PROC ; std::vector<Ogre::ContextQueDesc,std::allocator<Ogre::ContextQueDesc> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	je	SHORT $LN1@Tidy@7

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@IAEXPAUContextQueDesc@Ogre@@0@Z ; std::vector<Ogre::ContextQueDesc,std::allocator<Ogre::ContextQueDesc> >::_Destroy

; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+20]
	sub	ecx, DWORD PTR [eax+12]
	mov	eax, ecx
	cdq
	mov	ecx, 156				; 0000009cH
	idiv	ecx
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?deallocate@?$allocator@UContextQueDesc@Ogre@@@std@@QAEXPAUContextQueDesc@Ogre@@I@Z ; std::allocator<Ogre::ContextQueDesc>::deallocate
$LN1@Tidy@7:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+16], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], 0

; 1135 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$vector@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@IAEXXZ ENDP ; std::vector<Ogre::ContextQueDesc,std::allocator<Ogre::ContextQueDesc> >::_Tidy
_TEXT	ENDS
PUBLIC	??0?$_Container_base_aux_alloc_real@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@IAE@V?$allocator@UContextQueDesc@Ogre@@@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::ContextQueDesc> >::_Container_base_aux_alloc_real<std::allocator<Ogre::ContextQueDesc> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$_Vector_val@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@IAE@V?$allocator@UContextQueDesc@Ogre@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Vector_val@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@IAE@V?$allocator@UContextQueDesc@Ogre@@@1@@Z$0
__ehfuncinfo$??0?$_Vector_val@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@IAE@V?$allocator@UContextQueDesc@Ogre@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Vector_val@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@IAE@V?$allocator@UContextQueDesc@Ogre@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Vector_val@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@IAE@V?$allocator@UContextQueDesc@Ogre@@@1@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T95763 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 1
??0?$_Vector_val@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@IAE@V?$allocator@UContextQueDesc@Ogre@@@1@@Z PROC ; std::_Vector_val<Ogre::ContextQueDesc,std::allocator<Ogre::ContextQueDesc> >::_Vector_val<Ogre::ContextQueDesc,std::allocator<Ogre::ContextQueDesc> >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Vector_val@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@IAE@V?$allocator@UContextQueDesc@Ogre@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T95763[ebp], esp
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	call	??0?$allocator@UContextQueDesc@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::ContextQueDesc>::allocator<Ogre::ContextQueDesc>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Container_base_aux_alloc_real@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@IAE@V?$allocator@UContextQueDesc@Ogre@@@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::ContextQueDesc> >::_Container_base_aux_alloc_real<std::allocator<Ogre::ContextQueDesc> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??0?$allocator@UContextQueDesc@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::ContextQueDesc>::allocator<Ogre::ContextQueDesc>

; 426  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Vector_val@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@IAE@V?$allocator@UContextQueDesc@Ogre@@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Container_base_aux_alloc_real@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::ContextQueDesc> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::ContextQueDesc> >
__ehhandler$??0?$_Vector_val@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@IAE@V?$allocator@UContextQueDesc@Ogre@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Vector_val@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@IAE@V?$allocator@UContextQueDesc@Ogre@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Vector_val@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@IAE@V?$allocator@UContextQueDesc@Ogre@@@1@@Z ENDP ; std::_Vector_val<Ogre::ContextQueDesc,std::allocator<Ogre::ContextQueDesc> >::_Vector_val<Ogre::ContextQueDesc,std::allocator<Ogre::ContextQueDesc> >
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??1?$_Container_base_aux_alloc_real@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@IAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Container_base_aux_alloc_real@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@IAE@XZ$0
__ehfuncinfo$??1?$_Container_base_aux_alloc_real@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@IAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Container_base_aux_alloc_real@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@IAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$_Container_base_aux_alloc_real@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Container_base_aux_alloc_real@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::ContextQueDesc> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::ContextQueDesc> >, COMDAT
; _this$ = ecx

; 436  : 		{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Container_base_aux_alloc_real@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@IAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 437  : 		_Myownedaux->~_Aux_cont();
; 438  : 
; 439  : 		_Alaux.deallocate(_Myownedaux, 1);

	push	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?deallocate@?$allocator@V_Aux_cont@std@@@std@@QAEXPAV_Aux_cont@2@I@Z ; std::allocator<std::_Aux_cont>::deallocate

; 440  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Container_base_aux_alloc_real@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@IAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
__ehhandler$??1?$_Container_base_aux_alloc_real@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@IAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Container_base_aux_alloc_real@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@IAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Container_base_aux_alloc_real@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::ContextQueDesc> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::ContextQueDesc> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@UContextQueDesc@Ogre@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$allocator@UContextQueDesc@Ogre@@@std@@QAE@ABV01@@Z PROC ; std::allocator<Ogre::ContextQueDesc>::allocator<Ogre::ContextQueDesc>, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$allocator@UContextQueDesc@Ogre@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<Ogre::ContextQueDesc>::allocator<Ogre::ContextQueDesc>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@UContextQueDesc@Ogre@@@std@@QAEXPAUContextQueDesc@Ogre@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@UContextQueDesc@Ogre@@@std@@QAEXPAUContextQueDesc@Ogre@@I@Z PROC ; std::allocator<Ogre::ContextQueDesc>::deallocate, COMDAT
; _this$ = ecx

; 139  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 141  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@UContextQueDesc@Ogre@@@std@@QAEXPAUContextQueDesc@Ogre@@I@Z ENDP ; std::allocator<Ogre::ContextQueDesc>::deallocate
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?capacity@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ
_TEXT	SEGMENT
tv69 = -8						; size = 4
_this$ = -4						; size = 4
?capacity@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::capacity, COMDAT
; _this$ = ecx

; 634  : 		{	// return current length of allocated storage

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	jne	SHORT $LN3@capacity@3
	mov	DWORD PTR tv69[ebp], 0
	jmp	SHORT $LN4@capacity@3
$LN3@capacity@3:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+20]
	sub	eax, DWORD PTR [edx+12]
	mov	DWORD PTR tv69[ebp], eax
$LN4@capacity@3:
	mov	eax, DWORD PTR tv69[ebp]

; 636  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?capacity@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::capacity
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@EV?$allocator@E@std@@@std@@QAE@PAEPBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<unsigned char,std::allocator<unsigned char> >::_Vector_const_iterator<unsigned char,std::allocator<unsigned char> >
; Function compile flags: /Odtp
;	COMDAT ?begin@?$vector@EV?$allocator@E@std@@@std@@QBE?AV?$_Vector_const_iterator@EV?$allocator@E@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@EV?$allocator@E@std@@@std@@QBE?AV?$_Vector_const_iterator@EV?$allocator@E@std@@@2@XZ PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::begin, COMDAT
; _this$ = ecx

; 645  : 		{	// return iterator for beginning of nonmutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 646  : 		return (const_iterator(_Myfirst, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_const_iterator@EV?$allocator@E@std@@@std@@QAE@PAEPBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<unsigned char,std::allocator<unsigned char> >::_Vector_const_iterator<unsigned char,std::allocator<unsigned char> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 647  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?begin@?$vector@EV?$allocator@E@std@@@std@@QBE?AV?$_Vector_const_iterator@EV?$allocator@E@std@@@2@XZ ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::begin
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?end@?$vector@EV?$allocator@E@std@@@std@@QBE?AV?$_Vector_const_iterator@EV?$allocator@E@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@EV?$allocator@E@std@@@std@@QBE?AV?$_Vector_const_iterator@EV?$allocator@E@std@@@2@XZ PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::end, COMDAT
; _this$ = ecx

; 655  : 		{	// return iterator for end of nonmutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 656  : 		return (const_iterator(_Mylast, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_const_iterator@EV?$allocator@E@std@@@std@@QAE@PAEPBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<unsigned char,std::allocator<unsigned char> >::_Vector_const_iterator<unsigned char,std::allocator<unsigned char> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 657  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?end@?$vector@EV?$allocator@E@std@@@std@@QBE?AV?$_Vector_const_iterator@EV?$allocator@E@std@@@2@XZ ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::end
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?size@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ PROC	; std::vector<unsigned char,std::allocator<unsigned char> >::size, COMDAT
; _this$ = ecx

; 725  : 		{	// return length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+16]
	sub	eax, DWORD PTR [ecx+12]

; 727  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?size@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ ENDP	; std::vector<unsigned char,std::allocator<unsigned char> >::size
_TEXT	ENDS
PUBLIC	?erase@?$vector@EV?$allocator@E@std@@@std@@QAE?AV?$_Vector_iterator@EV?$allocator@E@std@@@2@V?$_Vector_const_iterator@EV?$allocator@E@std@@@2@0@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::erase
PUBLIC	?begin@?$vector@EV?$allocator@E@std@@@std@@QAE?AV?$_Vector_iterator@EV?$allocator@E@std@@@2@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::begin
PUBLIC	?end@?$vector@EV?$allocator@E@std@@@std@@QAE?AV?$_Vector_iterator@EV?$allocator@E@std@@@2@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::end
; Function compile flags: /Odtp
;	COMDAT ?clear@?$vector@EV?$allocator@E@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -44						; size = 4
$T95800 = -40						; size = 8
$T95799 = -32						; size = 8
$T95798 = -24						; size = 8
$T95797 = -16						; size = 8
$T95796 = -8						; size = 8
?clear@?$vector@EV?$allocator@E@std@@@std@@QAEXXZ PROC	; std::vector<unsigned char,std::allocator<unsigned char> >::clear, COMDAT
; _this$ = ecx

; 1059 : 		{	// erase all

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	mov	DWORD PTR _this$[ebp], ecx

; 1060 : 		erase(begin(), end());

	lea	eax, DWORD PTR $T95797[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$vector@EV?$allocator@E@std@@@std@@QAE?AV?$_Vector_iterator@EV?$allocator@E@std@@@2@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::end
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T95796[ebp], ecx
	mov	DWORD PTR $T95796[ebp+4], edx
	lea	eax, DWORD PTR $T95799[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$vector@EV?$allocator@E@std@@@std@@QAE?AV?$_Vector_iterator@EV?$allocator@E@std@@@2@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::begin
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T95798[ebp], ecx
	mov	DWORD PTR $T95798[ebp+4], edx
	mov	eax, DWORD PTR $T95796[ebp+4]
	push	eax
	mov	ecx, DWORD PTR $T95796[ebp]
	push	ecx
	mov	edx, DWORD PTR $T95798[ebp+4]
	push	edx
	mov	eax, DWORD PTR $T95798[ebp]
	push	eax
	lea	ecx, DWORD PTR $T95800[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$vector@EV?$allocator@E@std@@@std@@QAE?AV?$_Vector_iterator@EV?$allocator@E@std@@@2@V?$_Vector_const_iterator@EV?$allocator@E@std@@@2@0@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::erase

; 1061 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?clear@?$vector@EV?$allocator@E@std@@@std@@QAEXXZ ENDP	; std::vector<unsigned char,std::allocator<unsigned char> >::clear
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@E@std@@QAEPAEI@Z		; std::allocator<unsigned char>::allocate
PUBLIC	?_Xlen@?$vector@EV?$allocator@E@std@@@std@@KAXXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::_Xlen
PUBLIC	?max_size@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::max_size
; Function compile flags: /Odtp
;	COMDAT ?_Buy@?$vector@EV?$allocator@E@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Capacity$ = 8						; size = 4
?_Buy@?$vector@EV?$allocator@E@std@@@std@@IAE_NI@Z PROC	; std::vector<unsigned char,std::allocator<unsigned char> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+20], 0

; 1104 : 		if (_Capacity == 0)

	cmp	DWORD PTR __Capacity$[ebp], 0
	jne	SHORT $LN4@Buy@8

; 1105 : 			return (false);

	xor	al, al
	jmp	SHORT $LN5@Buy@8
	jmp	SHORT $LN3@Buy@8
$LN4@Buy@8:

; 1106 : 		else if (max_size() < _Capacity)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::max_size
	cmp	eax, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN2@Buy@8

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@EV?$allocator@E@std@@@std@@KAXXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::_Xlen

; 1108 : 		else

	jmp	SHORT $LN3@Buy@8
$LN2@Buy@8:

; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	mov	eax, DWORD PTR __Capacity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?allocate@?$allocator@E@std@@QAEPAEI@Z	; std::allocator<unsigned char>::allocate
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [edx+16], ecx

; 1112 : 			_Myend = _Myfirst + _Capacity;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	add	eax, DWORD PTR __Capacity$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+20], eax
$LN3@Buy@8:

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
$LN5@Buy@8:

; 1115 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Buy@?$vector@EV?$allocator@E@std@@@std@@IAE_NI@Z ENDP	; std::vector<unsigned char,std::allocator<unsigned char> >::_Buy
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@E@std@@@std@@YAXPAE0AAV?$allocator@E@0@@Z ; std::_Destroy_range<std::allocator<unsigned char> >
; Function compile flags: /Odtp
;	COMDAT ?_Destroy@?$vector@EV?$allocator@E@std@@@std@@IAEXPAE0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@EV?$allocator@E@std@@@std@@IAEXPAE0@Z PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::_Destroy, COMDAT
; _this$ = ecx

; 1118 : 		{	// destroy [_First, _Last) using allocator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Destroy_range@V?$allocator@E@std@@@std@@YAXPAE0AAV?$allocator@E@0@@Z ; std::_Destroy_range<std::allocator<unsigned char> >
	add	esp, 12					; 0000000cH

; 1120 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?_Destroy@?$vector@EV?$allocator@E@std@@@std@@IAEXPAE0@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::_Destroy
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@EV?$allocator@E@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Tidy@?$vector@EV?$allocator@E@std@@@std@@IAEXXZ PROC	; std::vector<unsigned char,std::allocator<unsigned char> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	je	SHORT $LN1@Tidy@8

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@EV?$allocator@E@std@@@std@@IAEXPAE0@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Destroy

; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+20]
	sub	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?deallocate@?$allocator@E@std@@QAEXPAEI@Z ; std::allocator<unsigned char>::deallocate
$LN1@Tidy@8:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+16], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], 0

; 1135 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$vector@EV?$allocator@E@std@@@std@@IAEXXZ ENDP	; std::vector<unsigned char,std::allocator<unsigned char> >::_Tidy
_TEXT	ENDS
PUBLIC	??0?$_Container_base_aux_alloc_real@V?$allocator@E@std@@@std@@IAE@V?$allocator@E@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<unsigned char> >::_Container_base_aux_alloc_real<std::allocator<unsigned char> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$_Vector_val@EV?$allocator@E@std@@@std@@IAE@V?$allocator@E@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Vector_val@EV?$allocator@E@std@@@std@@IAE@V?$allocator@E@1@@Z$0
__ehfuncinfo$??0?$_Vector_val@EV?$allocator@E@std@@@std@@IAE@V?$allocator@E@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Vector_val@EV?$allocator@E@std@@@std@@IAE@V?$allocator@E@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Vector_val@EV?$allocator@E@std@@@std@@IAE@V?$allocator@E@1@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T95809 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 1
??0?$_Vector_val@EV?$allocator@E@std@@@std@@IAE@V?$allocator@E@1@@Z PROC ; std::_Vector_val<unsigned char,std::allocator<unsigned char> >::_Vector_val<unsigned char,std::allocator<unsigned char> >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Vector_val@EV?$allocator@E@std@@@std@@IAE@V?$allocator@E@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T95809[ebp], esp
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	call	??0?$allocator@E@std@@QAE@ABV01@@Z	; std::allocator<unsigned char>::allocator<unsigned char>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Container_base_aux_alloc_real@V?$allocator@E@std@@@std@@IAE@V?$allocator@E@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<unsigned char> >::_Container_base_aux_alloc_real<std::allocator<unsigned char> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??0?$allocator@E@std@@QAE@ABV01@@Z	; std::allocator<unsigned char>::allocator<unsigned char>

; 426  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Vector_val@EV?$allocator@E@std@@@std@@IAE@V?$allocator@E@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Container_base_aux_alloc_real@V?$allocator@E@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<unsigned char> >::~_Container_base_aux_alloc_real<std::allocator<unsigned char> >
__ehhandler$??0?$_Vector_val@EV?$allocator@E@std@@@std@@IAE@V?$allocator@E@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Vector_val@EV?$allocator@E@std@@@std@@IAE@V?$allocator@E@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Vector_val@EV?$allocator@E@std@@@std@@IAE@V?$allocator@E@1@@Z ENDP ; std::_Vector_val<unsigned char,std::allocator<unsigned char> >::_Vector_val<unsigned char,std::allocator<unsigned char> >
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??1?$_Container_base_aux_alloc_real@V?$allocator@E@std@@@std@@IAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Container_base_aux_alloc_real@V?$allocator@E@std@@@std@@IAE@XZ$0
__ehfuncinfo$??1?$_Container_base_aux_alloc_real@V?$allocator@E@std@@@std@@IAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Container_base_aux_alloc_real@V?$allocator@E@std@@@std@@IAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$_Container_base_aux_alloc_real@V?$allocator@E@std@@@std@@IAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Container_base_aux_alloc_real@V?$allocator@E@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_real<std::allocator<unsigned char> >::~_Container_base_aux_alloc_real<std::allocator<unsigned char> >, COMDAT
; _this$ = ecx

; 436  : 		{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Container_base_aux_alloc_real@V?$allocator@E@std@@@std@@IAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 437  : 		_Myownedaux->~_Aux_cont();
; 438  : 
; 439  : 		_Alaux.deallocate(_Myownedaux, 1);

	push	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?deallocate@?$allocator@V_Aux_cont@std@@@std@@QAEXPAV_Aux_cont@2@I@Z ; std::allocator<std::_Aux_cont>::deallocate

; 440  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Container_base_aux_alloc_real@V?$allocator@E@std@@@std@@IAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
__ehhandler$??1?$_Container_base_aux_alloc_real@V?$allocator@E@std@@@std@@IAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Container_base_aux_alloc_real@V?$allocator@E@std@@@std@@IAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Container_base_aux_alloc_real@V?$allocator@E@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_real<std::allocator<unsigned char> >::~_Container_base_aux_alloc_real<std::allocator<unsigned char> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@E@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$allocator@E@std@@QAE@ABV01@@Z PROC			; std::allocator<unsigned char>::allocator<unsigned char>, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$allocator@E@std@@QAE@ABV01@@Z ENDP			; std::allocator<unsigned char>::allocator<unsigned char>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@E@std@@QAEXPAEI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@E@std@@QAEXPAEI@Z PROC		; std::allocator<unsigned char>::deallocate, COMDAT
; _this$ = ecx

; 139  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 141  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@E@std@@QAEXPAEI@Z ENDP		; std::allocator<unsigned char>::deallocate
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?capacity@?$vector@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
tv70 = -8						; size = 4
_this$ = -4						; size = 4
?capacity@?$vector@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@QBEIXZ PROC ; std::vector<Ogre::ShaderContextPool::ValueParam,std::allocator<Ogre::ShaderContextPool::ValueParam> >::capacity, COMDAT
; _this$ = ecx

; 634  : 		{	// return current length of allocated storage

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	jne	SHORT $LN3@capacity@4
	mov	DWORD PTR tv70[ebp], 0
	jmp	SHORT $LN4@capacity@4
$LN3@capacity@4:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+20]
	sub	eax, DWORD PTR [edx+12]
	sar	eax, 4
	mov	DWORD PTR tv70[ebp], eax
$LN4@capacity@4:
	mov	eax, DWORD PTR tv70[ebp]

; 636  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?capacity@?$vector@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@QBEIXZ ENDP ; std::vector<Ogre::ShaderContextPool::ValueParam,std::allocator<Ogre::ShaderContextPool::ValueParam> >::capacity
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@QAE@PAUValueParam@ShaderContextPool@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<Ogre::ShaderContextPool::ValueParam,std::allocator<Ogre::ShaderContextPool::ValueParam> >::_Vector_const_iterator<Ogre::ShaderContextPool::ValueParam,std::allocator<Ogre::ShaderContextPool::ValueParam> >
; Function compile flags: /Odtp
;	COMDAT ?begin@?$vector@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@2@XZ PROC ; std::vector<Ogre::ShaderContextPool::ValueParam,std::allocator<Ogre::ShaderContextPool::ValueParam> >::begin, COMDAT
; _this$ = ecx

; 645  : 		{	// return iterator for beginning of nonmutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 646  : 		return (const_iterator(_Myfirst, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_const_iterator@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@QAE@PAUValueParam@ShaderContextPool@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<Ogre::ShaderContextPool::ValueParam,std::allocator<Ogre::ShaderContextPool::ValueParam> >::_Vector_const_iterator<Ogre::ShaderContextPool::ValueParam,std::allocator<Ogre::ShaderContextPool::ValueParam> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 647  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?begin@?$vector@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@2@XZ ENDP ; std::vector<Ogre::ShaderContextPool::ValueParam,std::allocator<Ogre::ShaderContextPool::ValueParam> >::begin
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?end@?$vector@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@2@XZ PROC ; std::vector<Ogre::ShaderContextPool::ValueParam,std::allocator<Ogre::ShaderContextPool::ValueParam> >::end, COMDAT
; _this$ = ecx

; 655  : 		{	// return iterator for end of nonmutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 656  : 		return (const_iterator(_Mylast, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_const_iterator@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@QAE@PAUValueParam@ShaderContextPool@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<Ogre::ShaderContextPool::ValueParam,std::allocator<Ogre::ShaderContextPool::ValueParam> >::_Vector_const_iterator<Ogre::ShaderContextPool::ValueParam,std::allocator<Ogre::ShaderContextPool::ValueParam> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 657  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?end@?$vector@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@2@XZ ENDP ; std::vector<Ogre::ShaderContextPool::ValueParam,std::allocator<Ogre::ShaderContextPool::ValueParam> >::end
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?size@?$vector@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$vector@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@QBEIXZ PROC ; std::vector<Ogre::ShaderContextPool::ValueParam,std::allocator<Ogre::ShaderContextPool::ValueParam> >::size, COMDAT
; _this$ = ecx

; 725  : 		{	// return length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+16]
	sub	eax, DWORD PTR [ecx+12]
	sar	eax, 4

; 727  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?size@?$vector@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@QBEIXZ ENDP ; std::vector<Ogre::ShaderContextPool::ValueParam,std::allocator<Ogre::ShaderContextPool::ValueParam> >::size
_TEXT	ENDS
PUBLIC	?erase@?$vector@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@2@V?$_Vector_const_iterator@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@2@0@Z ; std::vector<Ogre::ShaderContextPool::ValueParam,std::allocator<Ogre::ShaderContextPool::ValueParam> >::erase
PUBLIC	?begin@?$vector@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@2@XZ ; std::vector<Ogre::ShaderContextPool::ValueParam,std::allocator<Ogre::ShaderContextPool::ValueParam> >::begin
PUBLIC	?end@?$vector@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@2@XZ ; std::vector<Ogre::ShaderContextPool::ValueParam,std::allocator<Ogre::ShaderContextPool::ValueParam> >::end
; Function compile flags: /Odtp
;	COMDAT ?clear@?$vector@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -44						; size = 4
$T95846 = -40						; size = 8
$T95845 = -32						; size = 8
$T95844 = -24						; size = 8
$T95843 = -16						; size = 8
$T95842 = -8						; size = 8
?clear@?$vector@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@QAEXXZ PROC ; std::vector<Ogre::ShaderContextPool::ValueParam,std::allocator<Ogre::ShaderContextPool::ValueParam> >::clear, COMDAT
; _this$ = ecx

; 1059 : 		{	// erase all

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	mov	DWORD PTR _this$[ebp], ecx

; 1060 : 		erase(begin(), end());

	lea	eax, DWORD PTR $T95843[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$vector@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@2@XZ ; std::vector<Ogre::ShaderContextPool::ValueParam,std::allocator<Ogre::ShaderContextPool::ValueParam> >::end
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T95842[ebp], ecx
	mov	DWORD PTR $T95842[ebp+4], edx
	lea	eax, DWORD PTR $T95845[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$vector@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@2@XZ ; std::vector<Ogre::ShaderContextPool::ValueParam,std::allocator<Ogre::ShaderContextPool::ValueParam> >::begin
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T95844[ebp], ecx
	mov	DWORD PTR $T95844[ebp+4], edx
	mov	eax, DWORD PTR $T95842[ebp+4]
	push	eax
	mov	ecx, DWORD PTR $T95842[ebp]
	push	ecx
	mov	edx, DWORD PTR $T95844[ebp+4]
	push	edx
	mov	eax, DWORD PTR $T95844[ebp]
	push	eax
	lea	ecx, DWORD PTR $T95846[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$vector@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@2@V?$_Vector_const_iterator@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@2@0@Z ; std::vector<Ogre::ShaderContextPool::ValueParam,std::allocator<Ogre::ShaderContextPool::ValueParam> >::erase

; 1061 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?clear@?$vector@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@QAEXXZ ENDP ; std::vector<Ogre::ShaderContextPool::ValueParam,std::allocator<Ogre::ShaderContextPool::ValueParam> >::clear
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@QAEPAUValueParam@ShaderContextPool@Ogre@@I@Z ; std::allocator<Ogre::ShaderContextPool::ValueParam>::allocate
PUBLIC	?_Xlen@?$vector@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@KAXXZ ; std::vector<Ogre::ShaderContextPool::ValueParam,std::allocator<Ogre::ShaderContextPool::ValueParam> >::_Xlen
PUBLIC	?max_size@?$vector@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::ShaderContextPool::ValueParam,std::allocator<Ogre::ShaderContextPool::ValueParam> >::max_size
; Function compile flags: /Odtp
;	COMDAT ?_Buy@?$vector@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Capacity$ = 8						; size = 4
?_Buy@?$vector@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@IAE_NI@Z PROC ; std::vector<Ogre::ShaderContextPool::ValueParam,std::allocator<Ogre::ShaderContextPool::ValueParam> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+20], 0

; 1104 : 		if (_Capacity == 0)

	cmp	DWORD PTR __Capacity$[ebp], 0
	jne	SHORT $LN4@Buy@9

; 1105 : 			return (false);

	xor	al, al
	jmp	SHORT $LN5@Buy@9
	jmp	SHORT $LN3@Buy@9
$LN4@Buy@9:

; 1106 : 		else if (max_size() < _Capacity)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::ShaderContextPool::ValueParam,std::allocator<Ogre::ShaderContextPool::ValueParam> >::max_size
	cmp	eax, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN2@Buy@9

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@KAXXZ ; std::vector<Ogre::ShaderContextPool::ValueParam,std::allocator<Ogre::ShaderContextPool::ValueParam> >::_Xlen

; 1108 : 		else

	jmp	SHORT $LN3@Buy@9
$LN2@Buy@9:

; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	mov	eax, DWORD PTR __Capacity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?allocate@?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@QAEPAUValueParam@ShaderContextPool@Ogre@@I@Z ; std::allocator<Ogre::ShaderContextPool::ValueParam>::allocate
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [edx+16], ecx

; 1112 : 			_Myend = _Myfirst + _Capacity;

	mov	edx, DWORD PTR __Capacity$[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+12]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+20], edx
$LN3@Buy@9:

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
$LN5@Buy@9:

; 1115 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Buy@?$vector@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<Ogre::ShaderContextPool::ValueParam,std::allocator<Ogre::ShaderContextPool::ValueParam> >::_Buy
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@YAXPAUValueParam@ShaderContextPool@Ogre@@0AAV?$allocator@UValueParam@ShaderContextPool@Ogre@@@0@@Z ; std::_Destroy_range<std::allocator<Ogre::ShaderContextPool::ValueParam> >
; Function compile flags: /Odtp
;	COMDAT ?_Destroy@?$vector@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@IAEXPAUValueParam@ShaderContextPool@Ogre@@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@IAEXPAUValueParam@ShaderContextPool@Ogre@@0@Z PROC ; std::vector<Ogre::ShaderContextPool::ValueParam,std::allocator<Ogre::ShaderContextPool::ValueParam> >::_Destroy, COMDAT
; _this$ = ecx

; 1118 : 		{	// destroy [_First, _Last) using allocator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Destroy_range@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@YAXPAUValueParam@ShaderContextPool@Ogre@@0AAV?$allocator@UValueParam@ShaderContextPool@Ogre@@@0@@Z ; std::_Destroy_range<std::allocator<Ogre::ShaderContextPool::ValueParam> >
	add	esp, 12					; 0000000cH

; 1120 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?_Destroy@?$vector@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@IAEXPAUValueParam@ShaderContextPool@Ogre@@0@Z ENDP ; std::vector<Ogre::ShaderContextPool::ValueParam,std::allocator<Ogre::ShaderContextPool::ValueParam> >::_Destroy
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Tidy@?$vector@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@IAEXXZ PROC ; std::vector<Ogre::ShaderContextPool::ValueParam,std::allocator<Ogre::ShaderContextPool::ValueParam> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	je	SHORT $LN1@Tidy@9

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@IAEXPAUValueParam@ShaderContextPool@Ogre@@0@Z ; std::vector<Ogre::ShaderContextPool::ValueParam,std::allocator<Ogre::ShaderContextPool::ValueParam> >::_Destroy

; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+20]
	sub	ecx, DWORD PTR [eax+12]
	sar	ecx, 4
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?deallocate@?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@QAEXPAUValueParam@ShaderContextPool@Ogre@@I@Z ; std::allocator<Ogre::ShaderContextPool::ValueParam>::deallocate
$LN1@Tidy@9:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+16], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], 0

; 1135 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$vector@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@IAEXXZ ENDP ; std::vector<Ogre::ShaderContextPool::ValueParam,std::allocator<Ogre::ShaderContextPool::ValueParam> >::_Tidy
_TEXT	ENDS
PUBLIC	??0?$_Container_base_aux_alloc_real@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@IAE@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::ShaderContextPool::ValueParam> >::_Container_base_aux_alloc_real<std::allocator<Ogre::ShaderContextPool::ValueParam> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$_Vector_val@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@IAE@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Vector_val@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@IAE@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@1@@Z$0
__ehfuncinfo$??0?$_Vector_val@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@IAE@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Vector_val@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@IAE@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Vector_val@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@IAE@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@1@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T95855 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 1
??0?$_Vector_val@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@IAE@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@1@@Z PROC ; std::_Vector_val<Ogre::ShaderContextPool::ValueParam,std::allocator<Ogre::ShaderContextPool::ValueParam> >::_Vector_val<Ogre::ShaderContextPool::ValueParam,std::allocator<Ogre::ShaderContextPool::ValueParam> >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Vector_val@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@IAE@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T95855[ebp], esp
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	call	??0?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::ShaderContextPool::ValueParam>::allocator<Ogre::ShaderContextPool::ValueParam>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Container_base_aux_alloc_real@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@IAE@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::ShaderContextPool::ValueParam> >::_Container_base_aux_alloc_real<std::allocator<Ogre::ShaderContextPool::ValueParam> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??0?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::ShaderContextPool::ValueParam>::allocator<Ogre::ShaderContextPool::ValueParam>

; 426  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Vector_val@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@IAE@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Container_base_aux_alloc_real@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::ShaderContextPool::ValueParam> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::ShaderContextPool::ValueParam> >
__ehhandler$??0?$_Vector_val@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@IAE@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Vector_val@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@IAE@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Vector_val@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@IAE@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@1@@Z ENDP ; std::_Vector_val<Ogre::ShaderContextPool::ValueParam,std::allocator<Ogre::ShaderContextPool::ValueParam> >::_Vector_val<Ogre::ShaderContextPool::ValueParam,std::allocator<Ogre::ShaderContextPool::ValueParam> >
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??1?$_Container_base_aux_alloc_real@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@IAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Container_base_aux_alloc_real@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@IAE@XZ$0
__ehfuncinfo$??1?$_Container_base_aux_alloc_real@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@IAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Container_base_aux_alloc_real@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@IAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$_Container_base_aux_alloc_real@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Container_base_aux_alloc_real@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::ShaderContextPool::ValueParam> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::ShaderContextPool::ValueParam> >, COMDAT
; _this$ = ecx

; 436  : 		{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Container_base_aux_alloc_real@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@IAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 437  : 		_Myownedaux->~_Aux_cont();
; 438  : 
; 439  : 		_Alaux.deallocate(_Myownedaux, 1);

	push	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?deallocate@?$allocator@V_Aux_cont@std@@@std@@QAEXPAV_Aux_cont@2@I@Z ; std::allocator<std::_Aux_cont>::deallocate

; 440  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Container_base_aux_alloc_real@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@IAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
__ehhandler$??1?$_Container_base_aux_alloc_real@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@IAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Container_base_aux_alloc_real@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@IAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Container_base_aux_alloc_real@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::ShaderContextPool::ValueParam> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::ShaderContextPool::ValueParam> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@QAE@ABV01@@Z PROC ; std::allocator<Ogre::ShaderContextPool::ValueParam>::allocator<Ogre::ShaderContextPool::ValueParam>, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<Ogre::ShaderContextPool::ValueParam>::allocator<Ogre::ShaderContextPool::ValueParam>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@QAEXPAUValueParam@ShaderContextPool@Ogre@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@QAEXPAUValueParam@ShaderContextPool@Ogre@@I@Z PROC ; std::allocator<Ogre::ShaderContextPool::ValueParam>::deallocate, COMDAT
; _this$ = ecx

; 139  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 141  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@QAEXPAUValueParam@ShaderContextPool@Ogre@@I@Z ENDP ; std::allocator<Ogre::ShaderContextPool::ValueParam>::deallocate
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?capacity@?$vector@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
tv70 = -8						; size = 4
_this$ = -4						; size = 4
?capacity@?$vector@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@QBEIXZ PROC ; std::vector<Ogre::ShaderContextPool::TexParam,std::allocator<Ogre::ShaderContextPool::TexParam> >::capacity, COMDAT
; _this$ = ecx

; 634  : 		{	// return current length of allocated storage

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	jne	SHORT $LN3@capacity@5
	mov	DWORD PTR tv70[ebp], 0
	jmp	SHORT $LN4@capacity@5
$LN3@capacity@5:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+20]
	sub	eax, DWORD PTR [edx+12]
	sar	eax, 3
	mov	DWORD PTR tv70[ebp], eax
$LN4@capacity@5:
	mov	eax, DWORD PTR tv70[ebp]

; 636  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?capacity@?$vector@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@QBEIXZ ENDP ; std::vector<Ogre::ShaderContextPool::TexParam,std::allocator<Ogre::ShaderContextPool::TexParam> >::capacity
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@QAE@PAUTexParam@ShaderContextPool@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<Ogre::ShaderContextPool::TexParam,std::allocator<Ogre::ShaderContextPool::TexParam> >::_Vector_const_iterator<Ogre::ShaderContextPool::TexParam,std::allocator<Ogre::ShaderContextPool::TexParam> >
; Function compile flags: /Odtp
;	COMDAT ?begin@?$vector@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@2@XZ PROC ; std::vector<Ogre::ShaderContextPool::TexParam,std::allocator<Ogre::ShaderContextPool::TexParam> >::begin, COMDAT
; _this$ = ecx

; 645  : 		{	// return iterator for beginning of nonmutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 646  : 		return (const_iterator(_Myfirst, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_const_iterator@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@QAE@PAUTexParam@ShaderContextPool@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<Ogre::ShaderContextPool::TexParam,std::allocator<Ogre::ShaderContextPool::TexParam> >::_Vector_const_iterator<Ogre::ShaderContextPool::TexParam,std::allocator<Ogre::ShaderContextPool::TexParam> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 647  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?begin@?$vector@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@2@XZ ENDP ; std::vector<Ogre::ShaderContextPool::TexParam,std::allocator<Ogre::ShaderContextPool::TexParam> >::begin
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?end@?$vector@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@2@XZ PROC ; std::vector<Ogre::ShaderContextPool::TexParam,std::allocator<Ogre::ShaderContextPool::TexParam> >::end, COMDAT
; _this$ = ecx

; 655  : 		{	// return iterator for end of nonmutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 656  : 		return (const_iterator(_Mylast, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_const_iterator@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@QAE@PAUTexParam@ShaderContextPool@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<Ogre::ShaderContextPool::TexParam,std::allocator<Ogre::ShaderContextPool::TexParam> >::_Vector_const_iterator<Ogre::ShaderContextPool::TexParam,std::allocator<Ogre::ShaderContextPool::TexParam> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 657  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?end@?$vector@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@2@XZ ENDP ; std::vector<Ogre::ShaderContextPool::TexParam,std::allocator<Ogre::ShaderContextPool::TexParam> >::end
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?size@?$vector@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$vector@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@QBEIXZ PROC ; std::vector<Ogre::ShaderContextPool::TexParam,std::allocator<Ogre::ShaderContextPool::TexParam> >::size, COMDAT
; _this$ = ecx

; 725  : 		{	// return length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+16]
	sub	eax, DWORD PTR [ecx+12]
	sar	eax, 3

; 727  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?size@?$vector@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@QBEIXZ ENDP ; std::vector<Ogre::ShaderContextPool::TexParam,std::allocator<Ogre::ShaderContextPool::TexParam> >::size
_TEXT	ENDS
PUBLIC	?erase@?$vector@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@2@V?$_Vector_const_iterator@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@2@0@Z ; std::vector<Ogre::ShaderContextPool::TexParam,std::allocator<Ogre::ShaderContextPool::TexParam> >::erase
PUBLIC	?begin@?$vector@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@2@XZ ; std::vector<Ogre::ShaderContextPool::TexParam,std::allocator<Ogre::ShaderContextPool::TexParam> >::begin
PUBLIC	?end@?$vector@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@2@XZ ; std::vector<Ogre::ShaderContextPool::TexParam,std::allocator<Ogre::ShaderContextPool::TexParam> >::end
; Function compile flags: /Odtp
;	COMDAT ?clear@?$vector@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -44						; size = 4
$T95892 = -40						; size = 8
$T95891 = -32						; size = 8
$T95890 = -24						; size = 8
$T95889 = -16						; size = 8
$T95888 = -8						; size = 8
?clear@?$vector@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@QAEXXZ PROC ; std::vector<Ogre::ShaderContextPool::TexParam,std::allocator<Ogre::ShaderContextPool::TexParam> >::clear, COMDAT
; _this$ = ecx

; 1059 : 		{	// erase all

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	mov	DWORD PTR _this$[ebp], ecx

; 1060 : 		erase(begin(), end());

	lea	eax, DWORD PTR $T95889[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$vector@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@2@XZ ; std::vector<Ogre::ShaderContextPool::TexParam,std::allocator<Ogre::ShaderContextPool::TexParam> >::end
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T95888[ebp], ecx
	mov	DWORD PTR $T95888[ebp+4], edx
	lea	eax, DWORD PTR $T95891[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$vector@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@2@XZ ; std::vector<Ogre::ShaderContextPool::TexParam,std::allocator<Ogre::ShaderContextPool::TexParam> >::begin
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T95890[ebp], ecx
	mov	DWORD PTR $T95890[ebp+4], edx
	mov	eax, DWORD PTR $T95888[ebp+4]
	push	eax
	mov	ecx, DWORD PTR $T95888[ebp]
	push	ecx
	mov	edx, DWORD PTR $T95890[ebp+4]
	push	edx
	mov	eax, DWORD PTR $T95890[ebp]
	push	eax
	lea	ecx, DWORD PTR $T95892[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$vector@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@2@V?$_Vector_const_iterator@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@2@0@Z ; std::vector<Ogre::ShaderContextPool::TexParam,std::allocator<Ogre::ShaderContextPool::TexParam> >::erase

; 1061 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?clear@?$vector@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@QAEXXZ ENDP ; std::vector<Ogre::ShaderContextPool::TexParam,std::allocator<Ogre::ShaderContextPool::TexParam> >::clear
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@QAEPAUTexParam@ShaderContextPool@Ogre@@I@Z ; std::allocator<Ogre::ShaderContextPool::TexParam>::allocate
PUBLIC	?_Xlen@?$vector@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@KAXXZ ; std::vector<Ogre::ShaderContextPool::TexParam,std::allocator<Ogre::ShaderContextPool::TexParam> >::_Xlen
PUBLIC	?max_size@?$vector@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::ShaderContextPool::TexParam,std::allocator<Ogre::ShaderContextPool::TexParam> >::max_size
; Function compile flags: /Odtp
;	COMDAT ?_Buy@?$vector@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Capacity$ = 8						; size = 4
?_Buy@?$vector@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@IAE_NI@Z PROC ; std::vector<Ogre::ShaderContextPool::TexParam,std::allocator<Ogre::ShaderContextPool::TexParam> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+20], 0

; 1104 : 		if (_Capacity == 0)

	cmp	DWORD PTR __Capacity$[ebp], 0
	jne	SHORT $LN4@Buy@10

; 1105 : 			return (false);

	xor	al, al
	jmp	SHORT $LN5@Buy@10
	jmp	SHORT $LN3@Buy@10
$LN4@Buy@10:

; 1106 : 		else if (max_size() < _Capacity)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::ShaderContextPool::TexParam,std::allocator<Ogre::ShaderContextPool::TexParam> >::max_size
	cmp	eax, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN2@Buy@10

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@KAXXZ ; std::vector<Ogre::ShaderContextPool::TexParam,std::allocator<Ogre::ShaderContextPool::TexParam> >::_Xlen

; 1108 : 		else

	jmp	SHORT $LN3@Buy@10
$LN2@Buy@10:

; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	mov	eax, DWORD PTR __Capacity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?allocate@?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@QAEPAUTexParam@ShaderContextPool@Ogre@@I@Z ; std::allocator<Ogre::ShaderContextPool::TexParam>::allocate
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [edx+16], ecx

; 1112 : 			_Myend = _Myfirst + _Capacity;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR __Capacity$[ebp]
	lea	edx, DWORD PTR [eax+ecx*8]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], edx
$LN3@Buy@10:

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
$LN5@Buy@10:

; 1115 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Buy@?$vector@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<Ogre::ShaderContextPool::TexParam,std::allocator<Ogre::ShaderContextPool::TexParam> >::_Buy
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@YAXPAUTexParam@ShaderContextPool@Ogre@@0AAV?$allocator@UTexParam@ShaderContextPool@Ogre@@@0@@Z ; std::_Destroy_range<std::allocator<Ogre::ShaderContextPool::TexParam> >
; Function compile flags: /Odtp
;	COMDAT ?_Destroy@?$vector@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@IAEXPAUTexParam@ShaderContextPool@Ogre@@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@IAEXPAUTexParam@ShaderContextPool@Ogre@@0@Z PROC ; std::vector<Ogre::ShaderContextPool::TexParam,std::allocator<Ogre::ShaderContextPool::TexParam> >::_Destroy, COMDAT
; _this$ = ecx

; 1118 : 		{	// destroy [_First, _Last) using allocator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Destroy_range@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@YAXPAUTexParam@ShaderContextPool@Ogre@@0AAV?$allocator@UTexParam@ShaderContextPool@Ogre@@@0@@Z ; std::_Destroy_range<std::allocator<Ogre::ShaderContextPool::TexParam> >
	add	esp, 12					; 0000000cH

; 1120 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?_Destroy@?$vector@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@IAEXPAUTexParam@ShaderContextPool@Ogre@@0@Z ENDP ; std::vector<Ogre::ShaderContextPool::TexParam,std::allocator<Ogre::ShaderContextPool::TexParam> >::_Destroy
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Tidy@?$vector@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@IAEXXZ PROC ; std::vector<Ogre::ShaderContextPool::TexParam,std::allocator<Ogre::ShaderContextPool::TexParam> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	je	SHORT $LN1@Tidy@10

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@IAEXPAUTexParam@ShaderContextPool@Ogre@@0@Z ; std::vector<Ogre::ShaderContextPool::TexParam,std::allocator<Ogre::ShaderContextPool::TexParam> >::_Destroy

; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+20]
	sub	ecx, DWORD PTR [eax+12]
	sar	ecx, 3
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?deallocate@?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@QAEXPAUTexParam@ShaderContextPool@Ogre@@I@Z ; std::allocator<Ogre::ShaderContextPool::TexParam>::deallocate
$LN1@Tidy@10:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+16], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], 0

; 1135 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$vector@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@IAEXXZ ENDP ; std::vector<Ogre::ShaderContextPool::TexParam,std::allocator<Ogre::ShaderContextPool::TexParam> >::_Tidy
_TEXT	ENDS
PUBLIC	??0?$_Container_base_aux_alloc_real@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@IAE@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::ShaderContextPool::TexParam> >::_Container_base_aux_alloc_real<std::allocator<Ogre::ShaderContextPool::TexParam> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$_Vector_val@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@IAE@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Vector_val@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@IAE@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@1@@Z$0
__ehfuncinfo$??0?$_Vector_val@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@IAE@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Vector_val@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@IAE@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Vector_val@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@IAE@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@1@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T95901 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 1
??0?$_Vector_val@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@IAE@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@1@@Z PROC ; std::_Vector_val<Ogre::ShaderContextPool::TexParam,std::allocator<Ogre::ShaderContextPool::TexParam> >::_Vector_val<Ogre::ShaderContextPool::TexParam,std::allocator<Ogre::ShaderContextPool::TexParam> >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Vector_val@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@IAE@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T95901[ebp], esp
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	call	??0?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::ShaderContextPool::TexParam>::allocator<Ogre::ShaderContextPool::TexParam>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Container_base_aux_alloc_real@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@IAE@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::ShaderContextPool::TexParam> >::_Container_base_aux_alloc_real<std::allocator<Ogre::ShaderContextPool::TexParam> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??0?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::ShaderContextPool::TexParam>::allocator<Ogre::ShaderContextPool::TexParam>

; 426  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Vector_val@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@IAE@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Container_base_aux_alloc_real@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::ShaderContextPool::TexParam> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::ShaderContextPool::TexParam> >
__ehhandler$??0?$_Vector_val@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@IAE@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Vector_val@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@IAE@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Vector_val@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@IAE@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@1@@Z ENDP ; std::_Vector_val<Ogre::ShaderContextPool::TexParam,std::allocator<Ogre::ShaderContextPool::TexParam> >::_Vector_val<Ogre::ShaderContextPool::TexParam,std::allocator<Ogre::ShaderContextPool::TexParam> >
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??1?$_Container_base_aux_alloc_real@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@IAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Container_base_aux_alloc_real@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@IAE@XZ$0
__ehfuncinfo$??1?$_Container_base_aux_alloc_real@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@IAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Container_base_aux_alloc_real@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@IAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$_Container_base_aux_alloc_real@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Container_base_aux_alloc_real@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::ShaderContextPool::TexParam> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::ShaderContextPool::TexParam> >, COMDAT
; _this$ = ecx

; 436  : 		{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Container_base_aux_alloc_real@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@IAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 437  : 		_Myownedaux->~_Aux_cont();
; 438  : 
; 439  : 		_Alaux.deallocate(_Myownedaux, 1);

	push	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?deallocate@?$allocator@V_Aux_cont@std@@@std@@QAEXPAV_Aux_cont@2@I@Z ; std::allocator<std::_Aux_cont>::deallocate

; 440  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Container_base_aux_alloc_real@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@IAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
__ehhandler$??1?$_Container_base_aux_alloc_real@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@IAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Container_base_aux_alloc_real@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@IAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Container_base_aux_alloc_real@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::ShaderContextPool::TexParam> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::ShaderContextPool::TexParam> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@QAE@ABV01@@Z PROC ; std::allocator<Ogre::ShaderContextPool::TexParam>::allocator<Ogre::ShaderContextPool::TexParam>, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<Ogre::ShaderContextPool::TexParam>::allocator<Ogre::ShaderContextPool::TexParam>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@QAEXPAUTexParam@ShaderContextPool@Ogre@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@QAEXPAUTexParam@ShaderContextPool@Ogre@@I@Z PROC ; std::allocator<Ogre::ShaderContextPool::TexParam>::deallocate, COMDAT
; _this$ = ecx

; 139  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 141  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@QAEXPAUTexParam@ShaderContextPool@Ogre@@I@Z ENDP ; std::allocator<Ogre::ShaderContextPool::TexParam>::deallocate
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?capacity@?$vector@PAVMaterialParam@Ogre@@V?$allocator@PAVMaterialParam@Ogre@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
tv70 = -8						; size = 4
_this$ = -4						; size = 4
?capacity@?$vector@PAVMaterialParam@Ogre@@V?$allocator@PAVMaterialParam@Ogre@@@std@@@std@@QBEIXZ PROC ; std::vector<Ogre::MaterialParam *,std::allocator<Ogre::MaterialParam *> >::capacity, COMDAT
; _this$ = ecx

; 634  : 		{	// return current length of allocated storage

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	jne	SHORT $LN3@capacity@6
	mov	DWORD PTR tv70[ebp], 0
	jmp	SHORT $LN4@capacity@6
$LN3@capacity@6:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+20]
	sub	eax, DWORD PTR [edx+12]
	sar	eax, 2
	mov	DWORD PTR tv70[ebp], eax
$LN4@capacity@6:
	mov	eax, DWORD PTR tv70[ebp]

; 636  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?capacity@?$vector@PAVMaterialParam@Ogre@@V?$allocator@PAVMaterialParam@Ogre@@@std@@@std@@QBEIXZ ENDP ; std::vector<Ogre::MaterialParam *,std::allocator<Ogre::MaterialParam *> >::capacity
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?size@?$vector@PAVMaterialParam@Ogre@@V?$allocator@PAVMaterialParam@Ogre@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$vector@PAVMaterialParam@Ogre@@V?$allocator@PAVMaterialParam@Ogre@@@std@@@std@@QBEIXZ PROC ; std::vector<Ogre::MaterialParam *,std::allocator<Ogre::MaterialParam *> >::size, COMDAT
; _this$ = ecx

; 725  : 		{	// return length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+16]
	sub	eax, DWORD PTR [ecx+12]
	sar	eax, 2

; 727  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?size@?$vector@PAVMaterialParam@Ogre@@V?$allocator@PAVMaterialParam@Ogre@@@std@@@std@@QBEIXZ ENDP ; std::vector<Ogre::MaterialParam *,std::allocator<Ogre::MaterialParam *> >::size
_TEXT	ENDS
PUBLIC	?erase@?$vector@PAVMaterialParam@Ogre@@V?$allocator@PAVMaterialParam@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVMaterialParam@Ogre@@V?$allocator@PAVMaterialParam@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVMaterialParam@Ogre@@V?$allocator@PAVMaterialParam@Ogre@@@std@@@2@0@Z ; std::vector<Ogre::MaterialParam *,std::allocator<Ogre::MaterialParam *> >::erase
PUBLIC	?begin@?$vector@PAVMaterialParam@Ogre@@V?$allocator@PAVMaterialParam@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVMaterialParam@Ogre@@V?$allocator@PAVMaterialParam@Ogre@@@std@@@2@XZ ; std::vector<Ogre::MaterialParam *,std::allocator<Ogre::MaterialParam *> >::begin
PUBLIC	?end@?$vector@PAVMaterialParam@Ogre@@V?$allocator@PAVMaterialParam@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVMaterialParam@Ogre@@V?$allocator@PAVMaterialParam@Ogre@@@std@@@2@XZ ; std::vector<Ogre::MaterialParam *,std::allocator<Ogre::MaterialParam *> >::end
; Function compile flags: /Odtp
;	COMDAT ?clear@?$vector@PAVMaterialParam@Ogre@@V?$allocator@PAVMaterialParam@Ogre@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -44						; size = 4
$T95934 = -40						; size = 8
$T95933 = -32						; size = 8
$T95932 = -24						; size = 8
$T95931 = -16						; size = 8
$T95930 = -8						; size = 8
?clear@?$vector@PAVMaterialParam@Ogre@@V?$allocator@PAVMaterialParam@Ogre@@@std@@@std@@QAEXXZ PROC ; std::vector<Ogre::MaterialParam *,std::allocator<Ogre::MaterialParam *> >::clear, COMDAT
; _this$ = ecx

; 1059 : 		{	// erase all

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	mov	DWORD PTR _this$[ebp], ecx

; 1060 : 		erase(begin(), end());

	lea	eax, DWORD PTR $T95931[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$vector@PAVMaterialParam@Ogre@@V?$allocator@PAVMaterialParam@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVMaterialParam@Ogre@@V?$allocator@PAVMaterialParam@Ogre@@@std@@@2@XZ ; std::vector<Ogre::MaterialParam *,std::allocator<Ogre::MaterialParam *> >::end
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T95930[ebp], ecx
	mov	DWORD PTR $T95930[ebp+4], edx
	lea	eax, DWORD PTR $T95933[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$vector@PAVMaterialParam@Ogre@@V?$allocator@PAVMaterialParam@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVMaterialParam@Ogre@@V?$allocator@PAVMaterialParam@Ogre@@@std@@@2@XZ ; std::vector<Ogre::MaterialParam *,std::allocator<Ogre::MaterialParam *> >::begin
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T95932[ebp], ecx
	mov	DWORD PTR $T95932[ebp+4], edx
	mov	eax, DWORD PTR $T95930[ebp+4]
	push	eax
	mov	ecx, DWORD PTR $T95930[ebp]
	push	ecx
	mov	edx, DWORD PTR $T95932[ebp+4]
	push	edx
	mov	eax, DWORD PTR $T95932[ebp]
	push	eax
	lea	ecx, DWORD PTR $T95934[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$vector@PAVMaterialParam@Ogre@@V?$allocator@PAVMaterialParam@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVMaterialParam@Ogre@@V?$allocator@PAVMaterialParam@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVMaterialParam@Ogre@@V?$allocator@PAVMaterialParam@Ogre@@@std@@@2@0@Z ; std::vector<Ogre::MaterialParam *,std::allocator<Ogre::MaterialParam *> >::erase

; 1061 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?clear@?$vector@PAVMaterialParam@Ogre@@V?$allocator@PAVMaterialParam@Ogre@@@std@@@std@@QAEXXZ ENDP ; std::vector<Ogre::MaterialParam *,std::allocator<Ogre::MaterialParam *> >::clear
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@PAVMaterialParam@Ogre@@@std@@QAEPAPAVMaterialParam@Ogre@@I@Z ; std::allocator<Ogre::MaterialParam *>::allocate
PUBLIC	?_Xlen@?$vector@PAVMaterialParam@Ogre@@V?$allocator@PAVMaterialParam@Ogre@@@std@@@std@@KAXXZ ; std::vector<Ogre::MaterialParam *,std::allocator<Ogre::MaterialParam *> >::_Xlen
PUBLIC	?max_size@?$vector@PAVMaterialParam@Ogre@@V?$allocator@PAVMaterialParam@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::MaterialParam *,std::allocator<Ogre::MaterialParam *> >::max_size
; Function compile flags: /Odtp
;	COMDAT ?_Buy@?$vector@PAVMaterialParam@Ogre@@V?$allocator@PAVMaterialParam@Ogre@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Capacity$ = 8						; size = 4
?_Buy@?$vector@PAVMaterialParam@Ogre@@V?$allocator@PAVMaterialParam@Ogre@@@std@@@std@@IAE_NI@Z PROC ; std::vector<Ogre::MaterialParam *,std::allocator<Ogre::MaterialParam *> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+20], 0

; 1104 : 		if (_Capacity == 0)

	cmp	DWORD PTR __Capacity$[ebp], 0
	jne	SHORT $LN4@Buy@11

; 1105 : 			return (false);

	xor	al, al
	jmp	SHORT $LN5@Buy@11
	jmp	SHORT $LN3@Buy@11
$LN4@Buy@11:

; 1106 : 		else if (max_size() < _Capacity)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@PAVMaterialParam@Ogre@@V?$allocator@PAVMaterialParam@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::MaterialParam *,std::allocator<Ogre::MaterialParam *> >::max_size
	cmp	eax, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN2@Buy@11

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@PAVMaterialParam@Ogre@@V?$allocator@PAVMaterialParam@Ogre@@@std@@@std@@KAXXZ ; std::vector<Ogre::MaterialParam *,std::allocator<Ogre::MaterialParam *> >::_Xlen

; 1108 : 		else

	jmp	SHORT $LN3@Buy@11
$LN2@Buy@11:

; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	mov	eax, DWORD PTR __Capacity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?allocate@?$allocator@PAVMaterialParam@Ogre@@@std@@QAEPAPAVMaterialParam@Ogre@@I@Z ; std::allocator<Ogre::MaterialParam *>::allocate
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [edx+16], ecx

; 1112 : 			_Myend = _Myfirst + _Capacity;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR __Capacity$[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], edx
$LN3@Buy@11:

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
$LN5@Buy@11:

; 1115 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Buy@?$vector@PAVMaterialParam@Ogre@@V?$allocator@PAVMaterialParam@Ogre@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<Ogre::MaterialParam *,std::allocator<Ogre::MaterialParam *> >::_Buy
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAVMaterialParam@Ogre@@@std@@@std@@YAXPAPAVMaterialParam@Ogre@@0AAV?$allocator@PAVMaterialParam@Ogre@@@0@@Z ; std::_Destroy_range<std::allocator<Ogre::MaterialParam *> >
; Function compile flags: /Odtp
;	COMDAT ?_Destroy@?$vector@PAVMaterialParam@Ogre@@V?$allocator@PAVMaterialParam@Ogre@@@std@@@std@@IAEXPAPAVMaterialParam@Ogre@@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@PAVMaterialParam@Ogre@@V?$allocator@PAVMaterialParam@Ogre@@@std@@@std@@IAEXPAPAVMaterialParam@Ogre@@0@Z PROC ; std::vector<Ogre::MaterialParam *,std::allocator<Ogre::MaterialParam *> >::_Destroy, COMDAT
; _this$ = ecx

; 1118 : 		{	// destroy [_First, _Last) using allocator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Destroy_range@V?$allocator@PAVMaterialParam@Ogre@@@std@@@std@@YAXPAPAVMaterialParam@Ogre@@0AAV?$allocator@PAVMaterialParam@Ogre@@@0@@Z ; std::_Destroy_range<std::allocator<Ogre::MaterialParam *> >
	add	esp, 12					; 0000000cH

; 1120 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?_Destroy@?$vector@PAVMaterialParam@Ogre@@V?$allocator@PAVMaterialParam@Ogre@@@std@@@std@@IAEXPAPAVMaterialParam@Ogre@@0@Z ENDP ; std::vector<Ogre::MaterialParam *,std::allocator<Ogre::MaterialParam *> >::_Destroy
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@PAVMaterialParam@Ogre@@@std@@QAEXPAPAVMaterialParam@Ogre@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@PAVMaterialParam@Ogre@@@std@@QAEXPAPAVMaterialParam@Ogre@@I@Z PROC ; std::allocator<Ogre::MaterialParam *>::deallocate, COMDAT
; _this$ = ecx

; 139  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 141  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@PAVMaterialParam@Ogre@@@std@@QAEXPAPAVMaterialParam@Ogre@@I@Z ENDP ; std::allocator<Ogre::MaterialParam *>::deallocate
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?capacity@?$vector@DV?$allocator@D@std@@@std@@QBEIXZ
_TEXT	SEGMENT
tv69 = -8						; size = 4
_this$ = -4						; size = 4
?capacity@?$vector@DV?$allocator@D@std@@@std@@QBEIXZ PROC ; std::vector<char,std::allocator<char> >::capacity, COMDAT
; _this$ = ecx

; 634  : 		{	// return current length of allocated storage

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	jne	SHORT $LN3@capacity@7
	mov	DWORD PTR tv69[ebp], 0
	jmp	SHORT $LN4@capacity@7
$LN3@capacity@7:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+20]
	sub	eax, DWORD PTR [edx+12]
	mov	DWORD PTR tv69[ebp], eax
$LN4@capacity@7:
	mov	eax, DWORD PTR tv69[ebp]

; 636  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?capacity@?$vector@DV?$allocator@D@std@@@std@@QBEIXZ ENDP ; std::vector<char,std::allocator<char> >::capacity
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@DV?$allocator@D@std@@@std@@QAE@PADPBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<char,std::allocator<char> >::_Vector_const_iterator<char,std::allocator<char> >
; Function compile flags: /Odtp
;	COMDAT ?begin@?$vector@DV?$allocator@D@std@@@std@@QBE?AV?$_Vector_const_iterator@DV?$allocator@D@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@DV?$allocator@D@std@@@std@@QBE?AV?$_Vector_const_iterator@DV?$allocator@D@std@@@2@XZ PROC ; std::vector<char,std::allocator<char> >::begin, COMDAT
; _this$ = ecx

; 645  : 		{	// return iterator for beginning of nonmutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 646  : 		return (const_iterator(_Myfirst, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_const_iterator@DV?$allocator@D@std@@@std@@QAE@PADPBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<char,std::allocator<char> >::_Vector_const_iterator<char,std::allocator<char> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 647  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?begin@?$vector@DV?$allocator@D@std@@@std@@QBE?AV?$_Vector_const_iterator@DV?$allocator@D@std@@@2@XZ ENDP ; std::vector<char,std::allocator<char> >::begin
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?end@?$vector@DV?$allocator@D@std@@@std@@QBE?AV?$_Vector_const_iterator@DV?$allocator@D@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@DV?$allocator@D@std@@@std@@QBE?AV?$_Vector_const_iterator@DV?$allocator@D@std@@@2@XZ PROC ; std::vector<char,std::allocator<char> >::end, COMDAT
; _this$ = ecx

; 655  : 		{	// return iterator for end of nonmutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 656  : 		return (const_iterator(_Mylast, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_const_iterator@DV?$allocator@D@std@@@std@@QAE@PADPBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<char,std::allocator<char> >::_Vector_const_iterator<char,std::allocator<char> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 657  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?end@?$vector@DV?$allocator@D@std@@@std@@QBE?AV?$_Vector_const_iterator@DV?$allocator@D@std@@@2@XZ ENDP ; std::vector<char,std::allocator<char> >::end
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?size@?$vector@DV?$allocator@D@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$vector@DV?$allocator@D@std@@@std@@QBEIXZ PROC	; std::vector<char,std::allocator<char> >::size, COMDAT
; _this$ = ecx

; 725  : 		{	// return length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+16]
	sub	eax, DWORD PTR [ecx+12]

; 727  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?size@?$vector@DV?$allocator@D@std@@@std@@QBEIXZ ENDP	; std::vector<char,std::allocator<char> >::size
_TEXT	ENDS
PUBLIC	?erase@?$vector@DV?$allocator@D@std@@@std@@QAE?AV?$_Vector_iterator@DV?$allocator@D@std@@@2@V?$_Vector_const_iterator@DV?$allocator@D@std@@@2@0@Z ; std::vector<char,std::allocator<char> >::erase
PUBLIC	?begin@?$vector@DV?$allocator@D@std@@@std@@QAE?AV?$_Vector_iterator@DV?$allocator@D@std@@@2@XZ ; std::vector<char,std::allocator<char> >::begin
PUBLIC	?end@?$vector@DV?$allocator@D@std@@@std@@QAE?AV?$_Vector_iterator@DV?$allocator@D@std@@@2@XZ ; std::vector<char,std::allocator<char> >::end
; Function compile flags: /Odtp
;	COMDAT ?clear@?$vector@DV?$allocator@D@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -44						; size = 4
$T95957 = -40						; size = 8
$T95956 = -32						; size = 8
$T95955 = -24						; size = 8
$T95954 = -16						; size = 8
$T95953 = -8						; size = 8
?clear@?$vector@DV?$allocator@D@std@@@std@@QAEXXZ PROC	; std::vector<char,std::allocator<char> >::clear, COMDAT
; _this$ = ecx

; 1059 : 		{	// erase all

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	mov	DWORD PTR _this$[ebp], ecx

; 1060 : 		erase(begin(), end());

	lea	eax, DWORD PTR $T95954[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$vector@DV?$allocator@D@std@@@std@@QAE?AV?$_Vector_iterator@DV?$allocator@D@std@@@2@XZ ; std::vector<char,std::allocator<char> >::end
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T95953[ebp], ecx
	mov	DWORD PTR $T95953[ebp+4], edx
	lea	eax, DWORD PTR $T95956[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$vector@DV?$allocator@D@std@@@std@@QAE?AV?$_Vector_iterator@DV?$allocator@D@std@@@2@XZ ; std::vector<char,std::allocator<char> >::begin
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T95955[ebp], ecx
	mov	DWORD PTR $T95955[ebp+4], edx
	mov	eax, DWORD PTR $T95953[ebp+4]
	push	eax
	mov	ecx, DWORD PTR $T95953[ebp]
	push	ecx
	mov	edx, DWORD PTR $T95955[ebp+4]
	push	edx
	mov	eax, DWORD PTR $T95955[ebp]
	push	eax
	lea	ecx, DWORD PTR $T95957[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$vector@DV?$allocator@D@std@@@std@@QAE?AV?$_Vector_iterator@DV?$allocator@D@std@@@2@V?$_Vector_const_iterator@DV?$allocator@D@std@@@2@0@Z ; std::vector<char,std::allocator<char> >::erase

; 1061 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?clear@?$vector@DV?$allocator@D@std@@@std@@QAEXXZ ENDP	; std::vector<char,std::allocator<char> >::clear
_TEXT	ENDS
PUBLIC	?_Xlen@?$vector@DV?$allocator@D@std@@@std@@KAXXZ ; std::vector<char,std::allocator<char> >::_Xlen
PUBLIC	?max_size@?$vector@DV?$allocator@D@std@@@std@@QBEIXZ ; std::vector<char,std::allocator<char> >::max_size
EXTRN	__imp_?allocate@?$allocator@D@std@@QAEPADI@Z:PROC
; Function compile flags: /Odtp
;	COMDAT ?_Buy@?$vector@DV?$allocator@D@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Capacity$ = 8						; size = 4
?_Buy@?$vector@DV?$allocator@D@std@@@std@@IAE_NI@Z PROC	; std::vector<char,std::allocator<char> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+20], 0

; 1104 : 		if (_Capacity == 0)

	cmp	DWORD PTR __Capacity$[ebp], 0
	jne	SHORT $LN4@Buy@12

; 1105 : 			return (false);

	xor	al, al
	jmp	SHORT $LN5@Buy@12
	jmp	SHORT $LN3@Buy@12
$LN4@Buy@12:

; 1106 : 		else if (max_size() < _Capacity)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@DV?$allocator@D@std@@@std@@QBEIXZ ; std::vector<char,std::allocator<char> >::max_size
	cmp	eax, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN2@Buy@12

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@DV?$allocator@D@std@@@std@@KAXXZ ; std::vector<char,std::allocator<char> >::_Xlen

; 1108 : 		else

	jmp	SHORT $LN3@Buy@12
$LN2@Buy@12:

; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	mov	eax, DWORD PTR __Capacity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	DWORD PTR __imp_?allocate@?$allocator@D@std@@QAEPADI@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [edx+16], ecx

; 1112 : 			_Myend = _Myfirst + _Capacity;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	add	eax, DWORD PTR __Capacity$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+20], eax
$LN3@Buy@12:

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
$LN5@Buy@12:

; 1115 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Buy@?$vector@DV?$allocator@D@std@@@std@@IAE_NI@Z ENDP	; std::vector<char,std::allocator<char> >::_Buy
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@D@std@@@std@@YAXPAD0AAV?$allocator@D@0@@Z ; std::_Destroy_range<std::allocator<char> >
; Function compile flags: /Odtp
;	COMDAT ?_Destroy@?$vector@DV?$allocator@D@std@@@std@@IAEXPAD0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@DV?$allocator@D@std@@@std@@IAEXPAD0@Z PROC ; std::vector<char,std::allocator<char> >::_Destroy, COMDAT
; _this$ = ecx

; 1118 : 		{	// destroy [_First, _Last) using allocator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Destroy_range@V?$allocator@D@std@@@std@@YAXPAD0AAV?$allocator@D@0@@Z ; std::_Destroy_range<std::allocator<char> >
	add	esp, 12					; 0000000cH

; 1120 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?_Destroy@?$vector@DV?$allocator@D@std@@@std@@IAEXPAD0@Z ENDP ; std::vector<char,std::allocator<char> >::_Destroy
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@DV?$allocator@D@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Tidy@?$vector@DV?$allocator@D@std@@@std@@IAEXXZ PROC	; std::vector<char,std::allocator<char> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	je	SHORT $LN1@Tidy@11

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@DV?$allocator@D@std@@@std@@IAEXPAD0@Z ; std::vector<char,std::allocator<char> >::_Destroy

; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+20]
	sub	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	DWORD PTR __imp_?deallocate@?$allocator@D@std@@QAEXPADI@Z
$LN1@Tidy@11:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+16], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], 0

; 1135 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$vector@DV?$allocator@D@std@@@std@@IAEXXZ ENDP	; std::vector<char,std::allocator<char> >::_Tidy
_TEXT	ENDS
PUBLIC	??0?$_Container_base_aux_alloc_real@V?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<char> >::_Container_base_aux_alloc_real<std::allocator<char> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$_Vector_val@DV?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Vector_val@DV?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z$0
__ehfuncinfo$??0?$_Vector_val@DV?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Vector_val@DV?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Vector_val@DV?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T95966 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 1
??0?$_Vector_val@DV?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z PROC ; std::_Vector_val<char,std::allocator<char> >::_Vector_val<char,std::allocator<char> >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Vector_val@DV?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T95966[ebp], esp
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	call	DWORD PTR __imp_??0?$allocator@D@std@@QAE@ABV01@@Z
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Container_base_aux_alloc_real@V?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<char> >::_Container_base_aux_alloc_real<std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	DWORD PTR __imp_??0?$allocator@D@std@@QAE@ABV01@@Z

; 426  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Vector_val@DV?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Container_base_aux_alloc_real@V?$allocator@D@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<char> >::~_Container_base_aux_alloc_real<std::allocator<char> >
__ehhandler$??0?$_Vector_val@DV?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Vector_val@DV?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Vector_val@DV?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z ENDP ; std::_Vector_val<char,std::allocator<char> >::_Vector_val<char,std::allocator<char> >
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??1?$_Container_base_aux_alloc_real@V?$allocator@D@std@@@std@@IAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Container_base_aux_alloc_real@V?$allocator@D@std@@@std@@IAE@XZ$0
__ehfuncinfo$??1?$_Container_base_aux_alloc_real@V?$allocator@D@std@@@std@@IAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Container_base_aux_alloc_real@V?$allocator@D@std@@@std@@IAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$_Container_base_aux_alloc_real@V?$allocator@D@std@@@std@@IAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Container_base_aux_alloc_real@V?$allocator@D@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_real<std::allocator<char> >::~_Container_base_aux_alloc_real<std::allocator<char> >, COMDAT
; _this$ = ecx

; 436  : 		{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Container_base_aux_alloc_real@V?$allocator@D@std@@@std@@IAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 437  : 		_Myownedaux->~_Aux_cont();
; 438  : 
; 439  : 		_Alaux.deallocate(_Myownedaux, 1);

	push	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?deallocate@?$allocator@V_Aux_cont@std@@@std@@QAEXPAV_Aux_cont@2@I@Z ; std::allocator<std::_Aux_cont>::deallocate

; 440  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Container_base_aux_alloc_real@V?$allocator@D@std@@@std@@IAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
__ehhandler$??1?$_Container_base_aux_alloc_real@V?$allocator@D@std@@@std@@IAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Container_base_aux_alloc_real@V?$allocator@D@std@@@std@@IAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Container_base_aux_alloc_real@V?$allocator@D@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_real<std::allocator<char> >::~_Container_base_aux_alloc_real<std::allocator<char> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?capacity@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
tv70 = -8						; size = 4
_this$ = -4						; size = 4
?capacity@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QBEIXZ PROC ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::capacity, COMDAT
; _this$ = ecx

; 634  : 		{	// return current length of allocated storage

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	jne	SHORT $LN3@capacity@8
	mov	DWORD PTR tv70[ebp], 0
	jmp	SHORT $LN4@capacity@8
$LN3@capacity@8:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+20]
	sub	eax, DWORD PTR [edx+12]
	sar	eax, 2
	mov	DWORD PTR tv70[ebp], eax
$LN4@capacity@8:
	mov	eax, DWORD PTR tv70[ebp]

; 636  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?capacity@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QBEIXZ ENDP ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::capacity
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE@PAPAVSurfaceData@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::_Vector_const_iterator<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >
; Function compile flags: /Odtp
;	COMDAT ?begin@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@2@XZ PROC ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::begin, COMDAT
; _this$ = ecx

; 645  : 		{	// return iterator for beginning of nonmutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 646  : 		return (const_iterator(_Myfirst, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE@PAPAVSurfaceData@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::_Vector_const_iterator<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 647  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?begin@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@2@XZ ENDP ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::begin
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?end@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@2@XZ PROC ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::end, COMDAT
; _this$ = ecx

; 655  : 		{	// return iterator for end of nonmutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 656  : 		return (const_iterator(_Mylast, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE@PAPAVSurfaceData@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::_Vector_const_iterator<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 657  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?end@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@2@XZ ENDP ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::end
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?size@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QBEIXZ PROC ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::size, COMDAT
; _this$ = ecx

; 725  : 		{	// return length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+16]
	sub	eax, DWORD PTR [ecx+12]
	sar	eax, 2

; 727  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?size@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QBEIXZ ENDP ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::size
_TEXT	ENDS
PUBLIC	?erase@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@2@0@Z ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::erase
PUBLIC	?begin@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@2@XZ ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::begin
PUBLIC	?end@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@2@XZ ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::end
; Function compile flags: /Odtp
;	COMDAT ?clear@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -44						; size = 4
$T95999 = -40						; size = 8
$T95998 = -32						; size = 8
$T95997 = -24						; size = 8
$T95996 = -16						; size = 8
$T95995 = -8						; size = 8
?clear@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAEXXZ PROC ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::clear, COMDAT
; _this$ = ecx

; 1059 : 		{	// erase all

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	mov	DWORD PTR _this$[ebp], ecx

; 1060 : 		erase(begin(), end());

	lea	eax, DWORD PTR $T95996[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@2@XZ ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::end
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T95995[ebp], ecx
	mov	DWORD PTR $T95995[ebp+4], edx
	lea	eax, DWORD PTR $T95998[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@2@XZ ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::begin
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T95997[ebp], ecx
	mov	DWORD PTR $T95997[ebp+4], edx
	mov	eax, DWORD PTR $T95995[ebp+4]
	push	eax
	mov	ecx, DWORD PTR $T95995[ebp]
	push	ecx
	mov	edx, DWORD PTR $T95997[ebp+4]
	push	edx
	mov	eax, DWORD PTR $T95997[ebp]
	push	eax
	lea	ecx, DWORD PTR $T95999[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@2@0@Z ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::erase

; 1061 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?clear@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAEXXZ ENDP ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::clear
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@PAVSurfaceData@Ogre@@@std@@QAEPAPAVSurfaceData@Ogre@@I@Z ; std::allocator<Ogre::SurfaceData *>::allocate
PUBLIC	?_Xlen@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@KAXXZ ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::_Xlen
PUBLIC	?max_size@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::max_size
; Function compile flags: /Odtp
;	COMDAT ?_Buy@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Capacity$ = 8						; size = 4
?_Buy@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAE_NI@Z PROC ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+20], 0

; 1104 : 		if (_Capacity == 0)

	cmp	DWORD PTR __Capacity$[ebp], 0
	jne	SHORT $LN4@Buy@13

; 1105 : 			return (false);

	xor	al, al
	jmp	SHORT $LN5@Buy@13
	jmp	SHORT $LN3@Buy@13
$LN4@Buy@13:

; 1106 : 		else if (max_size() < _Capacity)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::max_size
	cmp	eax, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN2@Buy@13

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@KAXXZ ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::_Xlen

; 1108 : 		else

	jmp	SHORT $LN3@Buy@13
$LN2@Buy@13:

; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	mov	eax, DWORD PTR __Capacity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?allocate@?$allocator@PAVSurfaceData@Ogre@@@std@@QAEPAPAVSurfaceData@Ogre@@I@Z ; std::allocator<Ogre::SurfaceData *>::allocate
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [edx+16], ecx

; 1112 : 			_Myend = _Myfirst + _Capacity;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR __Capacity$[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], edx
$LN3@Buy@13:

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
$LN5@Buy@13:

; 1115 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Buy@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::_Buy
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@YAXPAPAVSurfaceData@Ogre@@0AAV?$allocator@PAVSurfaceData@Ogre@@@0@@Z ; std::_Destroy_range<std::allocator<Ogre::SurfaceData *> >
; Function compile flags: /Odtp
;	COMDAT ?_Destroy@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAEXPAPAVSurfaceData@Ogre@@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAEXPAPAVSurfaceData@Ogre@@0@Z PROC ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::_Destroy, COMDAT
; _this$ = ecx

; 1118 : 		{	// destroy [_First, _Last) using allocator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Destroy_range@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@YAXPAPAVSurfaceData@Ogre@@0AAV?$allocator@PAVSurfaceData@Ogre@@@0@@Z ; std::_Destroy_range<std::allocator<Ogre::SurfaceData *> >
	add	esp, 12					; 0000000cH

; 1120 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?_Destroy@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAEXPAPAVSurfaceData@Ogre@@0@Z ENDP ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::_Destroy
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Tidy@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAEXXZ PROC ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	je	SHORT $LN1@Tidy@12

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAEXPAPAVSurfaceData@Ogre@@0@Z ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::_Destroy

; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+20]
	sub	ecx, DWORD PTR [eax+12]
	sar	ecx, 2
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?deallocate@?$allocator@PAVSurfaceData@Ogre@@@std@@QAEXPAPAVSurfaceData@Ogre@@I@Z ; std::allocator<Ogre::SurfaceData *>::deallocate
$LN1@Tidy@12:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+16], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], 0

; 1135 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAEXXZ ENDP ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::_Tidy
_TEXT	ENDS
PUBLIC	??0?$_Container_base_aux_alloc_real@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAE@V?$allocator@PAVSurfaceData@Ogre@@@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::SurfaceData *> >::_Container_base_aux_alloc_real<std::allocator<Ogre::SurfaceData *> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$_Vector_val@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAE@V?$allocator@PAVSurfaceData@Ogre@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Vector_val@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAE@V?$allocator@PAVSurfaceData@Ogre@@@1@@Z$0
__ehfuncinfo$??0?$_Vector_val@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAE@V?$allocator@PAVSurfaceData@Ogre@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Vector_val@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAE@V?$allocator@PAVSurfaceData@Ogre@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Vector_val@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAE@V?$allocator@PAVSurfaceData@Ogre@@@1@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T96008 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 1
??0?$_Vector_val@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAE@V?$allocator@PAVSurfaceData@Ogre@@@1@@Z PROC ; std::_Vector_val<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::_Vector_val<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Vector_val@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAE@V?$allocator@PAVSurfaceData@Ogre@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T96008[ebp], esp
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	call	??0?$allocator@PAVSurfaceData@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::SurfaceData *>::allocator<Ogre::SurfaceData *>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Container_base_aux_alloc_real@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAE@V?$allocator@PAVSurfaceData@Ogre@@@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::SurfaceData *> >::_Container_base_aux_alloc_real<std::allocator<Ogre::SurfaceData *> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??0?$allocator@PAVSurfaceData@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::SurfaceData *>::allocator<Ogre::SurfaceData *>

; 426  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Vector_val@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAE@V?$allocator@PAVSurfaceData@Ogre@@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Container_base_aux_alloc_real@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::SurfaceData *> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::SurfaceData *> >
__ehhandler$??0?$_Vector_val@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAE@V?$allocator@PAVSurfaceData@Ogre@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Vector_val@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAE@V?$allocator@PAVSurfaceData@Ogre@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Vector_val@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAE@V?$allocator@PAVSurfaceData@Ogre@@@1@@Z ENDP ; std::_Vector_val<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::_Vector_val<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??1?$_Container_base_aux_alloc_real@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Container_base_aux_alloc_real@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAE@XZ$0
__ehfuncinfo$??1?$_Container_base_aux_alloc_real@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Container_base_aux_alloc_real@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$_Container_base_aux_alloc_real@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Container_base_aux_alloc_real@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::SurfaceData *> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::SurfaceData *> >, COMDAT
; _this$ = ecx

; 436  : 		{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Container_base_aux_alloc_real@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 437  : 		_Myownedaux->~_Aux_cont();
; 438  : 
; 439  : 		_Alaux.deallocate(_Myownedaux, 1);

	push	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?deallocate@?$allocator@V_Aux_cont@std@@@std@@QAEXPAV_Aux_cont@2@I@Z ; std::allocator<std::_Aux_cont>::deallocate

; 440  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Container_base_aux_alloc_real@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
__ehhandler$??1?$_Container_base_aux_alloc_real@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Container_base_aux_alloc_real@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Container_base_aux_alloc_real@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::SurfaceData *> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::SurfaceData *> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@PAVSurfaceData@Ogre@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$allocator@PAVSurfaceData@Ogre@@@std@@QAE@ABV01@@Z PROC ; std::allocator<Ogre::SurfaceData *>::allocator<Ogre::SurfaceData *>, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$allocator@PAVSurfaceData@Ogre@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<Ogre::SurfaceData *>::allocator<Ogre::SurfaceData *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@PAVSurfaceData@Ogre@@@std@@QAEXPAPAVSurfaceData@Ogre@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@PAVSurfaceData@Ogre@@@std@@QAEXPAPAVSurfaceData@Ogre@@I@Z PROC ; std::allocator<Ogre::SurfaceData *>::deallocate, COMDAT
; _this$ = ecx

; 139  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 141  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@PAVSurfaceData@Ogre@@@std@@QAEXPAPAVSurfaceData@Ogre@@I@Z ENDP ; std::allocator<Ogre::SurfaceData *>::deallocate
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?capacity@?$vector@GV?$allocator@G@std@@@std@@QBEIXZ
_TEXT	SEGMENT
tv70 = -8						; size = 4
_this$ = -4						; size = 4
?capacity@?$vector@GV?$allocator@G@std@@@std@@QBEIXZ PROC ; std::vector<unsigned short,std::allocator<unsigned short> >::capacity, COMDAT
; _this$ = ecx

; 634  : 		{	// return current length of allocated storage

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	jne	SHORT $LN3@capacity@9
	mov	DWORD PTR tv70[ebp], 0
	jmp	SHORT $LN4@capacity@9
$LN3@capacity@9:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+20]
	sub	eax, DWORD PTR [edx+12]
	sar	eax, 1
	mov	DWORD PTR tv70[ebp], eax
$LN4@capacity@9:
	mov	eax, DWORD PTR tv70[ebp]

; 636  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?capacity@?$vector@GV?$allocator@G@std@@@std@@QBEIXZ ENDP ; std::vector<unsigned short,std::allocator<unsigned short> >::capacity
_TEXT	ENDS
PUBLIC	?erase@?$vector@GV?$allocator@G@std@@@std@@QAE?AV?$_Vector_iterator@GV?$allocator@G@std@@@2@V?$_Vector_const_iterator@GV?$allocator@G@std@@@2@0@Z ; std::vector<unsigned short,std::allocator<unsigned short> >::erase
PUBLIC	?begin@?$vector@GV?$allocator@G@std@@@std@@QAE?AV?$_Vector_iterator@GV?$allocator@G@std@@@2@XZ ; std::vector<unsigned short,std::allocator<unsigned short> >::begin
PUBLIC	?end@?$vector@GV?$allocator@G@std@@@std@@QAE?AV?$_Vector_iterator@GV?$allocator@G@std@@@2@XZ ; std::vector<unsigned short,std::allocator<unsigned short> >::end
; Function compile flags: /Odtp
;	COMDAT ?clear@?$vector@GV?$allocator@G@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -44						; size = 4
$T96039 = -40						; size = 8
$T96038 = -32						; size = 8
$T96037 = -24						; size = 8
$T96036 = -16						; size = 8
$T96035 = -8						; size = 8
?clear@?$vector@GV?$allocator@G@std@@@std@@QAEXXZ PROC	; std::vector<unsigned short,std::allocator<unsigned short> >::clear, COMDAT
; _this$ = ecx

; 1059 : 		{	// erase all

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	mov	DWORD PTR _this$[ebp], ecx

; 1060 : 		erase(begin(), end());

	lea	eax, DWORD PTR $T96036[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$vector@GV?$allocator@G@std@@@std@@QAE?AV?$_Vector_iterator@GV?$allocator@G@std@@@2@XZ ; std::vector<unsigned short,std::allocator<unsigned short> >::end
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T96035[ebp], ecx
	mov	DWORD PTR $T96035[ebp+4], edx
	lea	eax, DWORD PTR $T96038[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$vector@GV?$allocator@G@std@@@std@@QAE?AV?$_Vector_iterator@GV?$allocator@G@std@@@2@XZ ; std::vector<unsigned short,std::allocator<unsigned short> >::begin
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T96037[ebp], ecx
	mov	DWORD PTR $T96037[ebp+4], edx
	mov	eax, DWORD PTR $T96035[ebp+4]
	push	eax
	mov	ecx, DWORD PTR $T96035[ebp]
	push	ecx
	mov	edx, DWORD PTR $T96037[ebp+4]
	push	edx
	mov	eax, DWORD PTR $T96037[ebp]
	push	eax
	lea	ecx, DWORD PTR $T96039[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$vector@GV?$allocator@G@std@@@std@@QAE?AV?$_Vector_iterator@GV?$allocator@G@std@@@2@V?$_Vector_const_iterator@GV?$allocator@G@std@@@2@0@Z ; std::vector<unsigned short,std::allocator<unsigned short> >::erase

; 1061 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?clear@?$vector@GV?$allocator@G@std@@@std@@QAEXXZ ENDP	; std::vector<unsigned short,std::allocator<unsigned short> >::clear
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@G@std@@QAEPAGI@Z		; std::allocator<unsigned short>::allocate
PUBLIC	?_Xlen@?$vector@GV?$allocator@G@std@@@std@@KAXXZ ; std::vector<unsigned short,std::allocator<unsigned short> >::_Xlen
PUBLIC	?max_size@?$vector@GV?$allocator@G@std@@@std@@QBEIXZ ; std::vector<unsigned short,std::allocator<unsigned short> >::max_size
; Function compile flags: /Odtp
;	COMDAT ?_Buy@?$vector@GV?$allocator@G@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Capacity$ = 8						; size = 4
?_Buy@?$vector@GV?$allocator@G@std@@@std@@IAE_NI@Z PROC	; std::vector<unsigned short,std::allocator<unsigned short> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+20], 0

; 1104 : 		if (_Capacity == 0)

	cmp	DWORD PTR __Capacity$[ebp], 0
	jne	SHORT $LN4@Buy@14

; 1105 : 			return (false);

	xor	al, al
	jmp	SHORT $LN5@Buy@14
	jmp	SHORT $LN3@Buy@14
$LN4@Buy@14:

; 1106 : 		else if (max_size() < _Capacity)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@GV?$allocator@G@std@@@std@@QBEIXZ ; std::vector<unsigned short,std::allocator<unsigned short> >::max_size
	cmp	eax, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN2@Buy@14

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@GV?$allocator@G@std@@@std@@KAXXZ ; std::vector<unsigned short,std::allocator<unsigned short> >::_Xlen

; 1108 : 		else

	jmp	SHORT $LN3@Buy@14
$LN2@Buy@14:

; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	mov	eax, DWORD PTR __Capacity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?allocate@?$allocator@G@std@@QAEPAGI@Z	; std::allocator<unsigned short>::allocate
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [edx+16], ecx

; 1112 : 			_Myend = _Myfirst + _Capacity;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR __Capacity$[ebp]
	lea	edx, DWORD PTR [eax+ecx*2]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], edx
$LN3@Buy@14:

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
$LN5@Buy@14:

; 1115 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Buy@?$vector@GV?$allocator@G@std@@@std@@IAE_NI@Z ENDP	; std::vector<unsigned short,std::allocator<unsigned short> >::_Buy
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@G@std@@@std@@YAXPAG0AAV?$allocator@G@0@@Z ; std::_Destroy_range<std::allocator<unsigned short> >
; Function compile flags: /Odtp
;	COMDAT ?_Destroy@?$vector@GV?$allocator@G@std@@@std@@IAEXPAG0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@GV?$allocator@G@std@@@std@@IAEXPAG0@Z PROC ; std::vector<unsigned short,std::allocator<unsigned short> >::_Destroy, COMDAT
; _this$ = ecx

; 1118 : 		{	// destroy [_First, _Last) using allocator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Destroy_range@V?$allocator@G@std@@@std@@YAXPAG0AAV?$allocator@G@0@@Z ; std::_Destroy_range<std::allocator<unsigned short> >
	add	esp, 12					; 0000000cH

; 1120 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?_Destroy@?$vector@GV?$allocator@G@std@@@std@@IAEXPAG0@Z ENDP ; std::vector<unsigned short,std::allocator<unsigned short> >::_Destroy
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@G@std@@QAEXPAGI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@G@std@@QAEXPAGI@Z PROC		; std::allocator<unsigned short>::deallocate, COMDAT
; _this$ = ecx

; 139  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 141  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@G@std@@QAEXPAGI@Z ENDP		; std::allocator<unsigned short>::deallocate
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?capacity@?$vector@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
tv70 = -8						; size = 4
_this$ = -4						; size = 4
?capacity@?$vector@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@QBEIXZ PROC ; std::vector<Ogre::CullResult::Record,std::allocator<Ogre::CullResult::Record> >::capacity, COMDAT
; _this$ = ecx

; 634  : 		{	// return current length of allocated storage

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	jne	SHORT $LN3@capacity@10
	mov	DWORD PTR tv70[ebp], 0
	jmp	SHORT $LN4@capacity@10
$LN3@capacity@10:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+20]
	sub	eax, DWORD PTR [edx+12]
	sar	eax, 4
	mov	DWORD PTR tv70[ebp], eax
$LN4@capacity@10:
	mov	eax, DWORD PTR tv70[ebp]

; 636  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?capacity@?$vector@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@QBEIXZ ENDP ; std::vector<Ogre::CullResult::Record,std::allocator<Ogre::CullResult::Record> >::capacity
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@QAE@PAURecord@CullResult@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<Ogre::CullResult::Record,std::allocator<Ogre::CullResult::Record> >::_Vector_const_iterator<Ogre::CullResult::Record,std::allocator<Ogre::CullResult::Record> >
; Function compile flags: /Odtp
;	COMDAT ?begin@?$vector@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@2@XZ PROC ; std::vector<Ogre::CullResult::Record,std::allocator<Ogre::CullResult::Record> >::begin, COMDAT
; _this$ = ecx

; 645  : 		{	// return iterator for beginning of nonmutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 646  : 		return (const_iterator(_Myfirst, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_const_iterator@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@QAE@PAURecord@CullResult@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<Ogre::CullResult::Record,std::allocator<Ogre::CullResult::Record> >::_Vector_const_iterator<Ogre::CullResult::Record,std::allocator<Ogre::CullResult::Record> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 647  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?begin@?$vector@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@2@XZ ENDP ; std::vector<Ogre::CullResult::Record,std::allocator<Ogre::CullResult::Record> >::begin
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?end@?$vector@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@2@XZ PROC ; std::vector<Ogre::CullResult::Record,std::allocator<Ogre::CullResult::Record> >::end, COMDAT
; _this$ = ecx

; 655  : 		{	// return iterator for end of nonmutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 656  : 		return (const_iterator(_Mylast, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_const_iterator@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@QAE@PAURecord@CullResult@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<Ogre::CullResult::Record,std::allocator<Ogre::CullResult::Record> >::_Vector_const_iterator<Ogre::CullResult::Record,std::allocator<Ogre::CullResult::Record> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 657  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?end@?$vector@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@2@XZ ENDP ; std::vector<Ogre::CullResult::Record,std::allocator<Ogre::CullResult::Record> >::end
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?size@?$vector@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$vector@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@QBEIXZ PROC ; std::vector<Ogre::CullResult::Record,std::allocator<Ogre::CullResult::Record> >::size, COMDAT
; _this$ = ecx

; 725  : 		{	// return length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+16]
	sub	eax, DWORD PTR [ecx+12]
	sar	eax, 4

; 727  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?size@?$vector@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@QBEIXZ ENDP ; std::vector<Ogre::CullResult::Record,std::allocator<Ogre::CullResult::Record> >::size
_TEXT	ENDS
PUBLIC	?erase@?$vector@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@2@V?$_Vector_const_iterator@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@2@0@Z ; std::vector<Ogre::CullResult::Record,std::allocator<Ogre::CullResult::Record> >::erase
PUBLIC	?begin@?$vector@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@2@XZ ; std::vector<Ogre::CullResult::Record,std::allocator<Ogre::CullResult::Record> >::begin
PUBLIC	?end@?$vector@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@2@XZ ; std::vector<Ogre::CullResult::Record,std::allocator<Ogre::CullResult::Record> >::end
; Function compile flags: /Odtp
;	COMDAT ?clear@?$vector@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -44						; size = 4
$T96062 = -40						; size = 8
$T96061 = -32						; size = 8
$T96060 = -24						; size = 8
$T96059 = -16						; size = 8
$T96058 = -8						; size = 8
?clear@?$vector@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@QAEXXZ PROC ; std::vector<Ogre::CullResult::Record,std::allocator<Ogre::CullResult::Record> >::clear, COMDAT
; _this$ = ecx

; 1059 : 		{	// erase all

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	mov	DWORD PTR _this$[ebp], ecx

; 1060 : 		erase(begin(), end());

	lea	eax, DWORD PTR $T96059[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$vector@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@2@XZ ; std::vector<Ogre::CullResult::Record,std::allocator<Ogre::CullResult::Record> >::end
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T96058[ebp], ecx
	mov	DWORD PTR $T96058[ebp+4], edx
	lea	eax, DWORD PTR $T96061[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$vector@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@2@XZ ; std::vector<Ogre::CullResult::Record,std::allocator<Ogre::CullResult::Record> >::begin
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T96060[ebp], ecx
	mov	DWORD PTR $T96060[ebp+4], edx
	mov	eax, DWORD PTR $T96058[ebp+4]
	push	eax
	mov	ecx, DWORD PTR $T96058[ebp]
	push	ecx
	mov	edx, DWORD PTR $T96060[ebp+4]
	push	edx
	mov	eax, DWORD PTR $T96060[ebp]
	push	eax
	lea	ecx, DWORD PTR $T96062[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$vector@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@2@V?$_Vector_const_iterator@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@2@0@Z ; std::vector<Ogre::CullResult::Record,std::allocator<Ogre::CullResult::Record> >::erase

; 1061 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?clear@?$vector@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@QAEXXZ ENDP ; std::vector<Ogre::CullResult::Record,std::allocator<Ogre::CullResult::Record> >::clear
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@URecord@CullResult@Ogre@@@std@@QAEPAURecord@CullResult@Ogre@@I@Z ; std::allocator<Ogre::CullResult::Record>::allocate
PUBLIC	?_Xlen@?$vector@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@KAXXZ ; std::vector<Ogre::CullResult::Record,std::allocator<Ogre::CullResult::Record> >::_Xlen
PUBLIC	?max_size@?$vector@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::CullResult::Record,std::allocator<Ogre::CullResult::Record> >::max_size
; Function compile flags: /Odtp
;	COMDAT ?_Buy@?$vector@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Capacity$ = 8						; size = 4
?_Buy@?$vector@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@IAE_NI@Z PROC ; std::vector<Ogre::CullResult::Record,std::allocator<Ogre::CullResult::Record> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+20], 0

; 1104 : 		if (_Capacity == 0)

	cmp	DWORD PTR __Capacity$[ebp], 0
	jne	SHORT $LN4@Buy@15

; 1105 : 			return (false);

	xor	al, al
	jmp	SHORT $LN5@Buy@15
	jmp	SHORT $LN3@Buy@15
$LN4@Buy@15:

; 1106 : 		else if (max_size() < _Capacity)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::CullResult::Record,std::allocator<Ogre::CullResult::Record> >::max_size
	cmp	eax, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN2@Buy@15

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@KAXXZ ; std::vector<Ogre::CullResult::Record,std::allocator<Ogre::CullResult::Record> >::_Xlen

; 1108 : 		else

	jmp	SHORT $LN3@Buy@15
$LN2@Buy@15:

; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	mov	eax, DWORD PTR __Capacity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?allocate@?$allocator@URecord@CullResult@Ogre@@@std@@QAEPAURecord@CullResult@Ogre@@I@Z ; std::allocator<Ogre::CullResult::Record>::allocate
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [edx+16], ecx

; 1112 : 			_Myend = _Myfirst + _Capacity;

	mov	edx, DWORD PTR __Capacity$[ebp]
	shl	edx, 4
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+12]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+20], edx
$LN3@Buy@15:

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
$LN5@Buy@15:

; 1115 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Buy@?$vector@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<Ogre::CullResult::Record,std::allocator<Ogre::CullResult::Record> >::_Buy
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@YAXPAURecord@CullResult@Ogre@@0AAV?$allocator@URecord@CullResult@Ogre@@@0@@Z ; std::_Destroy_range<std::allocator<Ogre::CullResult::Record> >
; Function compile flags: /Odtp
;	COMDAT ?_Destroy@?$vector@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@IAEXPAURecord@CullResult@Ogre@@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@IAEXPAURecord@CullResult@Ogre@@0@Z PROC ; std::vector<Ogre::CullResult::Record,std::allocator<Ogre::CullResult::Record> >::_Destroy, COMDAT
; _this$ = ecx

; 1118 : 		{	// destroy [_First, _Last) using allocator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Destroy_range@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@YAXPAURecord@CullResult@Ogre@@0AAV?$allocator@URecord@CullResult@Ogre@@@0@@Z ; std::_Destroy_range<std::allocator<Ogre::CullResult::Record> >
	add	esp, 12					; 0000000cH

; 1120 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?_Destroy@?$vector@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@IAEXPAURecord@CullResult@Ogre@@0@Z ENDP ; std::vector<Ogre::CullResult::Record,std::allocator<Ogre::CullResult::Record> >::_Destroy
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Tidy@?$vector@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@IAEXXZ PROC ; std::vector<Ogre::CullResult::Record,std::allocator<Ogre::CullResult::Record> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	je	SHORT $LN1@Tidy@13

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@IAEXPAURecord@CullResult@Ogre@@0@Z ; std::vector<Ogre::CullResult::Record,std::allocator<Ogre::CullResult::Record> >::_Destroy

; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+20]
	sub	ecx, DWORD PTR [eax+12]
	sar	ecx, 4
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?deallocate@?$allocator@URecord@CullResult@Ogre@@@std@@QAEXPAURecord@CullResult@Ogre@@I@Z ; std::allocator<Ogre::CullResult::Record>::deallocate
$LN1@Tidy@13:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+16], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], 0

; 1135 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$vector@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@IAEXXZ ENDP ; std::vector<Ogre::CullResult::Record,std::allocator<Ogre::CullResult::Record> >::_Tidy
_TEXT	ENDS
PUBLIC	??0?$_Container_base_aux_alloc_real@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@IAE@V?$allocator@URecord@CullResult@Ogre@@@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::CullResult::Record> >::_Container_base_aux_alloc_real<std::allocator<Ogre::CullResult::Record> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$_Vector_val@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@IAE@V?$allocator@URecord@CullResult@Ogre@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Vector_val@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@IAE@V?$allocator@URecord@CullResult@Ogre@@@1@@Z$0
__ehfuncinfo$??0?$_Vector_val@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@IAE@V?$allocator@URecord@CullResult@Ogre@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Vector_val@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@IAE@V?$allocator@URecord@CullResult@Ogre@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Vector_val@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@IAE@V?$allocator@URecord@CullResult@Ogre@@@1@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T96071 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 1
??0?$_Vector_val@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@IAE@V?$allocator@URecord@CullResult@Ogre@@@1@@Z PROC ; std::_Vector_val<Ogre::CullResult::Record,std::allocator<Ogre::CullResult::Record> >::_Vector_val<Ogre::CullResult::Record,std::allocator<Ogre::CullResult::Record> >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Vector_val@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@IAE@V?$allocator@URecord@CullResult@Ogre@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T96071[ebp], esp
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	call	??0?$allocator@URecord@CullResult@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::CullResult::Record>::allocator<Ogre::CullResult::Record>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Container_base_aux_alloc_real@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@IAE@V?$allocator@URecord@CullResult@Ogre@@@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::CullResult::Record> >::_Container_base_aux_alloc_real<std::allocator<Ogre::CullResult::Record> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??0?$allocator@URecord@CullResult@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::CullResult::Record>::allocator<Ogre::CullResult::Record>

; 426  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Vector_val@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@IAE@V?$allocator@URecord@CullResult@Ogre@@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Container_base_aux_alloc_real@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::CullResult::Record> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::CullResult::Record> >
__ehhandler$??0?$_Vector_val@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@IAE@V?$allocator@URecord@CullResult@Ogre@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Vector_val@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@IAE@V?$allocator@URecord@CullResult@Ogre@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Vector_val@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@IAE@V?$allocator@URecord@CullResult@Ogre@@@1@@Z ENDP ; std::_Vector_val<Ogre::CullResult::Record,std::allocator<Ogre::CullResult::Record> >::_Vector_val<Ogre::CullResult::Record,std::allocator<Ogre::CullResult::Record> >
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??1?$_Container_base_aux_alloc_real@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@IAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Container_base_aux_alloc_real@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@IAE@XZ$0
__ehfuncinfo$??1?$_Container_base_aux_alloc_real@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@IAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Container_base_aux_alloc_real@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@IAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$_Container_base_aux_alloc_real@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Container_base_aux_alloc_real@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::CullResult::Record> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::CullResult::Record> >, COMDAT
; _this$ = ecx

; 436  : 		{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Container_base_aux_alloc_real@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@IAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 437  : 		_Myownedaux->~_Aux_cont();
; 438  : 
; 439  : 		_Alaux.deallocate(_Myownedaux, 1);

	push	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?deallocate@?$allocator@V_Aux_cont@std@@@std@@QAEXPAV_Aux_cont@2@I@Z ; std::allocator<std::_Aux_cont>::deallocate

; 440  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Container_base_aux_alloc_real@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@IAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
__ehhandler$??1?$_Container_base_aux_alloc_real@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@IAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Container_base_aux_alloc_real@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@IAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Container_base_aux_alloc_real@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::CullResult::Record> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::CullResult::Record> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@URecord@CullResult@Ogre@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$allocator@URecord@CullResult@Ogre@@@std@@QAE@ABV01@@Z PROC ; std::allocator<Ogre::CullResult::Record>::allocator<Ogre::CullResult::Record>, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$allocator@URecord@CullResult@Ogre@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<Ogre::CullResult::Record>::allocator<Ogre::CullResult::Record>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@URecord@CullResult@Ogre@@@std@@QAEXPAURecord@CullResult@Ogre@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@URecord@CullResult@Ogre@@@std@@QAEXPAURecord@CullResult@Ogre@@I@Z PROC ; std::allocator<Ogre::CullResult::Record>::deallocate, COMDAT
; _this$ = ecx

; 139  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 141  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@URecord@CullResult@Ogre@@@std@@QAEXPAURecord@CullResult@Ogre@@I@Z ENDP ; std::allocator<Ogre::CullResult::Record>::deallocate
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?capacity@?$vector@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
tv70 = -8						; size = 4
_this$ = -4						; size = 4
?capacity@?$vector@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@QBEIXZ PROC ; std::vector<Ogre::EffectObject *,std::allocator<Ogre::EffectObject *> >::capacity, COMDAT
; _this$ = ecx

; 634  : 		{	// return current length of allocated storage

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	jne	SHORT $LN3@capacity@11
	mov	DWORD PTR tv70[ebp], 0
	jmp	SHORT $LN4@capacity@11
$LN3@capacity@11:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+20]
	sub	eax, DWORD PTR [edx+12]
	sar	eax, 2
	mov	DWORD PTR tv70[ebp], eax
$LN4@capacity@11:
	mov	eax, DWORD PTR tv70[ebp]

; 636  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?capacity@?$vector@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@QBEIXZ ENDP ; std::vector<Ogre::EffectObject *,std::allocator<Ogre::EffectObject *> >::capacity
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@QAE@PAPAVEffectObject@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<Ogre::EffectObject *,std::allocator<Ogre::EffectObject *> >::_Vector_const_iterator<Ogre::EffectObject *,std::allocator<Ogre::EffectObject *> >
; Function compile flags: /Odtp
;	COMDAT ?begin@?$vector@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@2@XZ PROC ; std::vector<Ogre::EffectObject *,std::allocator<Ogre::EffectObject *> >::begin, COMDAT
; _this$ = ecx

; 645  : 		{	// return iterator for beginning of nonmutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 646  : 		return (const_iterator(_Myfirst, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_const_iterator@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@QAE@PAPAVEffectObject@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<Ogre::EffectObject *,std::allocator<Ogre::EffectObject *> >::_Vector_const_iterator<Ogre::EffectObject *,std::allocator<Ogre::EffectObject *> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 647  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?begin@?$vector@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@2@XZ ENDP ; std::vector<Ogre::EffectObject *,std::allocator<Ogre::EffectObject *> >::begin
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?end@?$vector@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@2@XZ PROC ; std::vector<Ogre::EffectObject *,std::allocator<Ogre::EffectObject *> >::end, COMDAT
; _this$ = ecx

; 655  : 		{	// return iterator for end of nonmutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 656  : 		return (const_iterator(_Mylast, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_const_iterator@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@QAE@PAPAVEffectObject@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<Ogre::EffectObject *,std::allocator<Ogre::EffectObject *> >::_Vector_const_iterator<Ogre::EffectObject *,std::allocator<Ogre::EffectObject *> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 657  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?end@?$vector@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@2@XZ ENDP ; std::vector<Ogre::EffectObject *,std::allocator<Ogre::EffectObject *> >::end
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?size@?$vector@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$vector@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@QBEIXZ PROC ; std::vector<Ogre::EffectObject *,std::allocator<Ogre::EffectObject *> >::size, COMDAT
; _this$ = ecx

; 725  : 		{	// return length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+16]
	sub	eax, DWORD PTR [ecx+12]
	sar	eax, 2

; 727  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?size@?$vector@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@QBEIXZ ENDP ; std::vector<Ogre::EffectObject *,std::allocator<Ogre::EffectObject *> >::size
_TEXT	ENDS
PUBLIC	?erase@?$vector@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@2@0@Z ; std::vector<Ogre::EffectObject *,std::allocator<Ogre::EffectObject *> >::erase
PUBLIC	?begin@?$vector@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@2@XZ ; std::vector<Ogre::EffectObject *,std::allocator<Ogre::EffectObject *> >::begin
PUBLIC	?end@?$vector@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@2@XZ ; std::vector<Ogre::EffectObject *,std::allocator<Ogre::EffectObject *> >::end
; Function compile flags: /Odtp
;	COMDAT ?clear@?$vector@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -44						; size = 4
$T96108 = -40						; size = 8
$T96107 = -32						; size = 8
$T96106 = -24						; size = 8
$T96105 = -16						; size = 8
$T96104 = -8						; size = 8
?clear@?$vector@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@QAEXXZ PROC ; std::vector<Ogre::EffectObject *,std::allocator<Ogre::EffectObject *> >::clear, COMDAT
; _this$ = ecx

; 1059 : 		{	// erase all

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	mov	DWORD PTR _this$[ebp], ecx

; 1060 : 		erase(begin(), end());

	lea	eax, DWORD PTR $T96105[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$vector@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@2@XZ ; std::vector<Ogre::EffectObject *,std::allocator<Ogre::EffectObject *> >::end
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T96104[ebp], ecx
	mov	DWORD PTR $T96104[ebp+4], edx
	lea	eax, DWORD PTR $T96107[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$vector@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@2@XZ ; std::vector<Ogre::EffectObject *,std::allocator<Ogre::EffectObject *> >::begin
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T96106[ebp], ecx
	mov	DWORD PTR $T96106[ebp+4], edx
	mov	eax, DWORD PTR $T96104[ebp+4]
	push	eax
	mov	ecx, DWORD PTR $T96104[ebp]
	push	ecx
	mov	edx, DWORD PTR $T96106[ebp+4]
	push	edx
	mov	eax, DWORD PTR $T96106[ebp]
	push	eax
	lea	ecx, DWORD PTR $T96108[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$vector@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@2@0@Z ; std::vector<Ogre::EffectObject *,std::allocator<Ogre::EffectObject *> >::erase

; 1061 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?clear@?$vector@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@QAEXXZ ENDP ; std::vector<Ogre::EffectObject *,std::allocator<Ogre::EffectObject *> >::clear
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@PAVEffectObject@Ogre@@@std@@QAEPAPAVEffectObject@Ogre@@I@Z ; std::allocator<Ogre::EffectObject *>::allocate
PUBLIC	?_Xlen@?$vector@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@KAXXZ ; std::vector<Ogre::EffectObject *,std::allocator<Ogre::EffectObject *> >::_Xlen
PUBLIC	?max_size@?$vector@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::EffectObject *,std::allocator<Ogre::EffectObject *> >::max_size
; Function compile flags: /Odtp
;	COMDAT ?_Buy@?$vector@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Capacity$ = 8						; size = 4
?_Buy@?$vector@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@IAE_NI@Z PROC ; std::vector<Ogre::EffectObject *,std::allocator<Ogre::EffectObject *> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+20], 0

; 1104 : 		if (_Capacity == 0)

	cmp	DWORD PTR __Capacity$[ebp], 0
	jne	SHORT $LN4@Buy@16

; 1105 : 			return (false);

	xor	al, al
	jmp	SHORT $LN5@Buy@16
	jmp	SHORT $LN3@Buy@16
$LN4@Buy@16:

; 1106 : 		else if (max_size() < _Capacity)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::EffectObject *,std::allocator<Ogre::EffectObject *> >::max_size
	cmp	eax, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN2@Buy@16

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@KAXXZ ; std::vector<Ogre::EffectObject *,std::allocator<Ogre::EffectObject *> >::_Xlen

; 1108 : 		else

	jmp	SHORT $LN3@Buy@16
$LN2@Buy@16:

; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	mov	eax, DWORD PTR __Capacity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?allocate@?$allocator@PAVEffectObject@Ogre@@@std@@QAEPAPAVEffectObject@Ogre@@I@Z ; std::allocator<Ogre::EffectObject *>::allocate
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [edx+16], ecx

; 1112 : 			_Myend = _Myfirst + _Capacity;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR __Capacity$[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], edx
$LN3@Buy@16:

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
$LN5@Buy@16:

; 1115 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Buy@?$vector@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<Ogre::EffectObject *,std::allocator<Ogre::EffectObject *> >::_Buy
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@YAXPAPAVEffectObject@Ogre@@0AAV?$allocator@PAVEffectObject@Ogre@@@0@@Z ; std::_Destroy_range<std::allocator<Ogre::EffectObject *> >
; Function compile flags: /Odtp
;	COMDAT ?_Destroy@?$vector@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@IAEXPAPAVEffectObject@Ogre@@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@IAEXPAPAVEffectObject@Ogre@@0@Z PROC ; std::vector<Ogre::EffectObject *,std::allocator<Ogre::EffectObject *> >::_Destroy, COMDAT
; _this$ = ecx

; 1118 : 		{	// destroy [_First, _Last) using allocator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Destroy_range@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@YAXPAPAVEffectObject@Ogre@@0AAV?$allocator@PAVEffectObject@Ogre@@@0@@Z ; std::_Destroy_range<std::allocator<Ogre::EffectObject *> >
	add	esp, 12					; 0000000cH

; 1120 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?_Destroy@?$vector@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@IAEXPAPAVEffectObject@Ogre@@0@Z ENDP ; std::vector<Ogre::EffectObject *,std::allocator<Ogre::EffectObject *> >::_Destroy
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Tidy@?$vector@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@IAEXXZ PROC ; std::vector<Ogre::EffectObject *,std::allocator<Ogre::EffectObject *> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	je	SHORT $LN1@Tidy@14

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@IAEXPAPAVEffectObject@Ogre@@0@Z ; std::vector<Ogre::EffectObject *,std::allocator<Ogre::EffectObject *> >::_Destroy

; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+20]
	sub	ecx, DWORD PTR [eax+12]
	sar	ecx, 2
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?deallocate@?$allocator@PAVEffectObject@Ogre@@@std@@QAEXPAPAVEffectObject@Ogre@@I@Z ; std::allocator<Ogre::EffectObject *>::deallocate
$LN1@Tidy@14:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+16], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], 0

; 1135 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$vector@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@IAEXXZ ENDP ; std::vector<Ogre::EffectObject *,std::allocator<Ogre::EffectObject *> >::_Tidy
_TEXT	ENDS
PUBLIC	??0?$_Container_base_aux_alloc_real@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@IAE@V?$allocator@PAVEffectObject@Ogre@@@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::EffectObject *> >::_Container_base_aux_alloc_real<std::allocator<Ogre::EffectObject *> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$_Vector_val@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@IAE@V?$allocator@PAVEffectObject@Ogre@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Vector_val@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@IAE@V?$allocator@PAVEffectObject@Ogre@@@1@@Z$0
__ehfuncinfo$??0?$_Vector_val@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@IAE@V?$allocator@PAVEffectObject@Ogre@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Vector_val@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@IAE@V?$allocator@PAVEffectObject@Ogre@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Vector_val@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@IAE@V?$allocator@PAVEffectObject@Ogre@@@1@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T96117 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 1
??0?$_Vector_val@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@IAE@V?$allocator@PAVEffectObject@Ogre@@@1@@Z PROC ; std::_Vector_val<Ogre::EffectObject *,std::allocator<Ogre::EffectObject *> >::_Vector_val<Ogre::EffectObject *,std::allocator<Ogre::EffectObject *> >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Vector_val@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@IAE@V?$allocator@PAVEffectObject@Ogre@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T96117[ebp], esp
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	call	??0?$allocator@PAVEffectObject@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::EffectObject *>::allocator<Ogre::EffectObject *>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Container_base_aux_alloc_real@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@IAE@V?$allocator@PAVEffectObject@Ogre@@@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::EffectObject *> >::_Container_base_aux_alloc_real<std::allocator<Ogre::EffectObject *> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??0?$allocator@PAVEffectObject@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::EffectObject *>::allocator<Ogre::EffectObject *>

; 426  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Vector_val@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@IAE@V?$allocator@PAVEffectObject@Ogre@@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Container_base_aux_alloc_real@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::EffectObject *> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::EffectObject *> >
__ehhandler$??0?$_Vector_val@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@IAE@V?$allocator@PAVEffectObject@Ogre@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Vector_val@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@IAE@V?$allocator@PAVEffectObject@Ogre@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Vector_val@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@IAE@V?$allocator@PAVEffectObject@Ogre@@@1@@Z ENDP ; std::_Vector_val<Ogre::EffectObject *,std::allocator<Ogre::EffectObject *> >::_Vector_val<Ogre::EffectObject *,std::allocator<Ogre::EffectObject *> >
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??1?$_Container_base_aux_alloc_real@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@IAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Container_base_aux_alloc_real@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@IAE@XZ$0
__ehfuncinfo$??1?$_Container_base_aux_alloc_real@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@IAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Container_base_aux_alloc_real@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@IAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$_Container_base_aux_alloc_real@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Container_base_aux_alloc_real@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::EffectObject *> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::EffectObject *> >, COMDAT
; _this$ = ecx

; 436  : 		{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Container_base_aux_alloc_real@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@IAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 437  : 		_Myownedaux->~_Aux_cont();
; 438  : 
; 439  : 		_Alaux.deallocate(_Myownedaux, 1);

	push	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?deallocate@?$allocator@V_Aux_cont@std@@@std@@QAEXPAV_Aux_cont@2@I@Z ; std::allocator<std::_Aux_cont>::deallocate

; 440  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Container_base_aux_alloc_real@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@IAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
__ehhandler$??1?$_Container_base_aux_alloc_real@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@IAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Container_base_aux_alloc_real@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@IAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Container_base_aux_alloc_real@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::EffectObject *> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::EffectObject *> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@PAVEffectObject@Ogre@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$allocator@PAVEffectObject@Ogre@@@std@@QAE@ABV01@@Z PROC ; std::allocator<Ogre::EffectObject *>::allocator<Ogre::EffectObject *>, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$allocator@PAVEffectObject@Ogre@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<Ogre::EffectObject *>::allocator<Ogre::EffectObject *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@PAVEffectObject@Ogre@@@std@@QAEXPAPAVEffectObject@Ogre@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@PAVEffectObject@Ogre@@@std@@QAEXPAPAVEffectObject@Ogre@@I@Z PROC ; std::allocator<Ogre::EffectObject *>::deallocate, COMDAT
; _this$ = ecx

; 139  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 141  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@PAVEffectObject@Ogre@@@std@@QAEXPAPAVEffectObject@Ogre@@I@Z ENDP ; std::allocator<Ogre::EffectObject *>::deallocate
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?capacity@?$vector@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
tv70 = -8						; size = 4
_this$ = -4						; size = 4
?capacity@?$vector@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@QBEIXZ PROC ; std::vector<Ogre::SoundNode *,std::allocator<Ogre::SoundNode *> >::capacity, COMDAT
; _this$ = ecx

; 634  : 		{	// return current length of allocated storage

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	jne	SHORT $LN3@capacity@12
	mov	DWORD PTR tv70[ebp], 0
	jmp	SHORT $LN4@capacity@12
$LN3@capacity@12:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+20]
	sub	eax, DWORD PTR [edx+12]
	sar	eax, 2
	mov	DWORD PTR tv70[ebp], eax
$LN4@capacity@12:
	mov	eax, DWORD PTR tv70[ebp]

; 636  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?capacity@?$vector@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@QBEIXZ ENDP ; std::vector<Ogre::SoundNode *,std::allocator<Ogre::SoundNode *> >::capacity
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@QAE@PAPAVSoundNode@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<Ogre::SoundNode *,std::allocator<Ogre::SoundNode *> >::_Vector_const_iterator<Ogre::SoundNode *,std::allocator<Ogre::SoundNode *> >
; Function compile flags: /Odtp
;	COMDAT ?begin@?$vector@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@2@XZ PROC ; std::vector<Ogre::SoundNode *,std::allocator<Ogre::SoundNode *> >::begin, COMDAT
; _this$ = ecx

; 645  : 		{	// return iterator for beginning of nonmutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 646  : 		return (const_iterator(_Myfirst, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_const_iterator@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@QAE@PAPAVSoundNode@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<Ogre::SoundNode *,std::allocator<Ogre::SoundNode *> >::_Vector_const_iterator<Ogre::SoundNode *,std::allocator<Ogre::SoundNode *> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 647  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?begin@?$vector@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@2@XZ ENDP ; std::vector<Ogre::SoundNode *,std::allocator<Ogre::SoundNode *> >::begin
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?end@?$vector@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@2@XZ PROC ; std::vector<Ogre::SoundNode *,std::allocator<Ogre::SoundNode *> >::end, COMDAT
; _this$ = ecx

; 655  : 		{	// return iterator for end of nonmutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 656  : 		return (const_iterator(_Mylast, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_const_iterator@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@QAE@PAPAVSoundNode@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<Ogre::SoundNode *,std::allocator<Ogre::SoundNode *> >::_Vector_const_iterator<Ogre::SoundNode *,std::allocator<Ogre::SoundNode *> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 657  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?end@?$vector@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@2@XZ ENDP ; std::vector<Ogre::SoundNode *,std::allocator<Ogre::SoundNode *> >::end
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?size@?$vector@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$vector@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@QBEIXZ PROC ; std::vector<Ogre::SoundNode *,std::allocator<Ogre::SoundNode *> >::size, COMDAT
; _this$ = ecx

; 725  : 		{	// return length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+16]
	sub	eax, DWORD PTR [ecx+12]
	sar	eax, 2

; 727  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?size@?$vector@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@QBEIXZ ENDP ; std::vector<Ogre::SoundNode *,std::allocator<Ogre::SoundNode *> >::size
_TEXT	ENDS
PUBLIC	?erase@?$vector@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@2@0@Z ; std::vector<Ogre::SoundNode *,std::allocator<Ogre::SoundNode *> >::erase
PUBLIC	?begin@?$vector@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@2@XZ ; std::vector<Ogre::SoundNode *,std::allocator<Ogre::SoundNode *> >::begin
PUBLIC	?end@?$vector@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@2@XZ ; std::vector<Ogre::SoundNode *,std::allocator<Ogre::SoundNode *> >::end
; Function compile flags: /Odtp
;	COMDAT ?clear@?$vector@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -44						; size = 4
$T96154 = -40						; size = 8
$T96153 = -32						; size = 8
$T96152 = -24						; size = 8
$T96151 = -16						; size = 8
$T96150 = -8						; size = 8
?clear@?$vector@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@QAEXXZ PROC ; std::vector<Ogre::SoundNode *,std::allocator<Ogre::SoundNode *> >::clear, COMDAT
; _this$ = ecx

; 1059 : 		{	// erase all

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	mov	DWORD PTR _this$[ebp], ecx

; 1060 : 		erase(begin(), end());

	lea	eax, DWORD PTR $T96151[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$vector@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@2@XZ ; std::vector<Ogre::SoundNode *,std::allocator<Ogre::SoundNode *> >::end
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T96150[ebp], ecx
	mov	DWORD PTR $T96150[ebp+4], edx
	lea	eax, DWORD PTR $T96153[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$vector@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@2@XZ ; std::vector<Ogre::SoundNode *,std::allocator<Ogre::SoundNode *> >::begin
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T96152[ebp], ecx
	mov	DWORD PTR $T96152[ebp+4], edx
	mov	eax, DWORD PTR $T96150[ebp+4]
	push	eax
	mov	ecx, DWORD PTR $T96150[ebp]
	push	ecx
	mov	edx, DWORD PTR $T96152[ebp+4]
	push	edx
	mov	eax, DWORD PTR $T96152[ebp]
	push	eax
	lea	ecx, DWORD PTR $T96154[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$vector@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@2@0@Z ; std::vector<Ogre::SoundNode *,std::allocator<Ogre::SoundNode *> >::erase

; 1061 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?clear@?$vector@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@QAEXXZ ENDP ; std::vector<Ogre::SoundNode *,std::allocator<Ogre::SoundNode *> >::clear
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@PAVSoundNode@Ogre@@@std@@QAEPAPAVSoundNode@Ogre@@I@Z ; std::allocator<Ogre::SoundNode *>::allocate
PUBLIC	?_Xlen@?$vector@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@KAXXZ ; std::vector<Ogre::SoundNode *,std::allocator<Ogre::SoundNode *> >::_Xlen
PUBLIC	?max_size@?$vector@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::SoundNode *,std::allocator<Ogre::SoundNode *> >::max_size
; Function compile flags: /Odtp
;	COMDAT ?_Buy@?$vector@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Capacity$ = 8						; size = 4
?_Buy@?$vector@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@IAE_NI@Z PROC ; std::vector<Ogre::SoundNode *,std::allocator<Ogre::SoundNode *> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+20], 0

; 1104 : 		if (_Capacity == 0)

	cmp	DWORD PTR __Capacity$[ebp], 0
	jne	SHORT $LN4@Buy@17

; 1105 : 			return (false);

	xor	al, al
	jmp	SHORT $LN5@Buy@17
	jmp	SHORT $LN3@Buy@17
$LN4@Buy@17:

; 1106 : 		else if (max_size() < _Capacity)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::SoundNode *,std::allocator<Ogre::SoundNode *> >::max_size
	cmp	eax, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN2@Buy@17

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@KAXXZ ; std::vector<Ogre::SoundNode *,std::allocator<Ogre::SoundNode *> >::_Xlen

; 1108 : 		else

	jmp	SHORT $LN3@Buy@17
$LN2@Buy@17:

; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	mov	eax, DWORD PTR __Capacity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?allocate@?$allocator@PAVSoundNode@Ogre@@@std@@QAEPAPAVSoundNode@Ogre@@I@Z ; std::allocator<Ogre::SoundNode *>::allocate
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [edx+16], ecx

; 1112 : 			_Myend = _Myfirst + _Capacity;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR __Capacity$[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], edx
$LN3@Buy@17:

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
$LN5@Buy@17:

; 1115 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Buy@?$vector@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<Ogre::SoundNode *,std::allocator<Ogre::SoundNode *> >::_Buy
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@YAXPAPAVSoundNode@Ogre@@0AAV?$allocator@PAVSoundNode@Ogre@@@0@@Z ; std::_Destroy_range<std::allocator<Ogre::SoundNode *> >
; Function compile flags: /Odtp
;	COMDAT ?_Destroy@?$vector@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@IAEXPAPAVSoundNode@Ogre@@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@IAEXPAPAVSoundNode@Ogre@@0@Z PROC ; std::vector<Ogre::SoundNode *,std::allocator<Ogre::SoundNode *> >::_Destroy, COMDAT
; _this$ = ecx

; 1118 : 		{	// destroy [_First, _Last) using allocator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Destroy_range@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@YAXPAPAVSoundNode@Ogre@@0AAV?$allocator@PAVSoundNode@Ogre@@@0@@Z ; std::_Destroy_range<std::allocator<Ogre::SoundNode *> >
	add	esp, 12					; 0000000cH

; 1120 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?_Destroy@?$vector@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@IAEXPAPAVSoundNode@Ogre@@0@Z ENDP ; std::vector<Ogre::SoundNode *,std::allocator<Ogre::SoundNode *> >::_Destroy
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Tidy@?$vector@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@IAEXXZ PROC ; std::vector<Ogre::SoundNode *,std::allocator<Ogre::SoundNode *> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	je	SHORT $LN1@Tidy@15

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@IAEXPAPAVSoundNode@Ogre@@0@Z ; std::vector<Ogre::SoundNode *,std::allocator<Ogre::SoundNode *> >::_Destroy

; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+20]
	sub	ecx, DWORD PTR [eax+12]
	sar	ecx, 2
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?deallocate@?$allocator@PAVSoundNode@Ogre@@@std@@QAEXPAPAVSoundNode@Ogre@@I@Z ; std::allocator<Ogre::SoundNode *>::deallocate
$LN1@Tidy@15:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+16], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], 0

; 1135 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$vector@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@IAEXXZ ENDP ; std::vector<Ogre::SoundNode *,std::allocator<Ogre::SoundNode *> >::_Tidy
_TEXT	ENDS
PUBLIC	??0?$_Container_base_aux_alloc_real@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@IAE@V?$allocator@PAVSoundNode@Ogre@@@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::SoundNode *> >::_Container_base_aux_alloc_real<std::allocator<Ogre::SoundNode *> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$_Vector_val@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@IAE@V?$allocator@PAVSoundNode@Ogre@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Vector_val@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@IAE@V?$allocator@PAVSoundNode@Ogre@@@1@@Z$0
__ehfuncinfo$??0?$_Vector_val@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@IAE@V?$allocator@PAVSoundNode@Ogre@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Vector_val@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@IAE@V?$allocator@PAVSoundNode@Ogre@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Vector_val@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@IAE@V?$allocator@PAVSoundNode@Ogre@@@1@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T96163 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 1
??0?$_Vector_val@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@IAE@V?$allocator@PAVSoundNode@Ogre@@@1@@Z PROC ; std::_Vector_val<Ogre::SoundNode *,std::allocator<Ogre::SoundNode *> >::_Vector_val<Ogre::SoundNode *,std::allocator<Ogre::SoundNode *> >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Vector_val@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@IAE@V?$allocator@PAVSoundNode@Ogre@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T96163[ebp], esp
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	call	??0?$allocator@PAVSoundNode@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::SoundNode *>::allocator<Ogre::SoundNode *>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Container_base_aux_alloc_real@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@IAE@V?$allocator@PAVSoundNode@Ogre@@@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::SoundNode *> >::_Container_base_aux_alloc_real<std::allocator<Ogre::SoundNode *> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??0?$allocator@PAVSoundNode@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::SoundNode *>::allocator<Ogre::SoundNode *>

; 426  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Vector_val@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@IAE@V?$allocator@PAVSoundNode@Ogre@@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Container_base_aux_alloc_real@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::SoundNode *> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::SoundNode *> >
__ehhandler$??0?$_Vector_val@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@IAE@V?$allocator@PAVSoundNode@Ogre@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Vector_val@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@IAE@V?$allocator@PAVSoundNode@Ogre@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Vector_val@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@IAE@V?$allocator@PAVSoundNode@Ogre@@@1@@Z ENDP ; std::_Vector_val<Ogre::SoundNode *,std::allocator<Ogre::SoundNode *> >::_Vector_val<Ogre::SoundNode *,std::allocator<Ogre::SoundNode *> >
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??1?$_Container_base_aux_alloc_real@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@IAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Container_base_aux_alloc_real@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@IAE@XZ$0
__ehfuncinfo$??1?$_Container_base_aux_alloc_real@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@IAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Container_base_aux_alloc_real@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@IAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$_Container_base_aux_alloc_real@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Container_base_aux_alloc_real@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::SoundNode *> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::SoundNode *> >, COMDAT
; _this$ = ecx

; 436  : 		{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Container_base_aux_alloc_real@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@IAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 437  : 		_Myownedaux->~_Aux_cont();
; 438  : 
; 439  : 		_Alaux.deallocate(_Myownedaux, 1);

	push	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?deallocate@?$allocator@V_Aux_cont@std@@@std@@QAEXPAV_Aux_cont@2@I@Z ; std::allocator<std::_Aux_cont>::deallocate

; 440  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Container_base_aux_alloc_real@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@IAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
__ehhandler$??1?$_Container_base_aux_alloc_real@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@IAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Container_base_aux_alloc_real@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@IAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Container_base_aux_alloc_real@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::SoundNode *> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::SoundNode *> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@PAVSoundNode@Ogre@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$allocator@PAVSoundNode@Ogre@@@std@@QAE@ABV01@@Z PROC ; std::allocator<Ogre::SoundNode *>::allocator<Ogre::SoundNode *>, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$allocator@PAVSoundNode@Ogre@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<Ogre::SoundNode *>::allocator<Ogre::SoundNode *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@PAVSoundNode@Ogre@@@std@@QAEXPAPAVSoundNode@Ogre@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@PAVSoundNode@Ogre@@@std@@QAEXPAPAVSoundNode@Ogre@@I@Z PROC ; std::allocator<Ogre::SoundNode *>::deallocate, COMDAT
; _this$ = ecx

; 139  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 141  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@PAVSoundNode@Ogre@@@std@@QAEXPAPAVSoundNode@Ogre@@I@Z ENDP ; std::allocator<Ogre::SoundNode *>::deallocate
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?capacity@?$vector@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
tv70 = -8						; size = 4
_this$ = -4						; size = 4
?capacity@?$vector@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@QBEIXZ PROC ; std::vector<Ogre::RenderableObject *,std::allocator<Ogre::RenderableObject *> >::capacity, COMDAT
; _this$ = ecx

; 634  : 		{	// return current length of allocated storage

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	jne	SHORT $LN3@capacity@13
	mov	DWORD PTR tv70[ebp], 0
	jmp	SHORT $LN4@capacity@13
$LN3@capacity@13:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+20]
	sub	eax, DWORD PTR [edx+12]
	sar	eax, 2
	mov	DWORD PTR tv70[ebp], eax
$LN4@capacity@13:
	mov	eax, DWORD PTR tv70[ebp]

; 636  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?capacity@?$vector@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@QBEIXZ ENDP ; std::vector<Ogre::RenderableObject *,std::allocator<Ogre::RenderableObject *> >::capacity
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@QAE@PAPAVRenderableObject@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<Ogre::RenderableObject *,std::allocator<Ogre::RenderableObject *> >::_Vector_const_iterator<Ogre::RenderableObject *,std::allocator<Ogre::RenderableObject *> >
; Function compile flags: /Odtp
;	COMDAT ?begin@?$vector@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@2@XZ PROC ; std::vector<Ogre::RenderableObject *,std::allocator<Ogre::RenderableObject *> >::begin, COMDAT
; _this$ = ecx

; 645  : 		{	// return iterator for beginning of nonmutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 646  : 		return (const_iterator(_Myfirst, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_const_iterator@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@QAE@PAPAVRenderableObject@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<Ogre::RenderableObject *,std::allocator<Ogre::RenderableObject *> >::_Vector_const_iterator<Ogre::RenderableObject *,std::allocator<Ogre::RenderableObject *> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 647  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?begin@?$vector@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@2@XZ ENDP ; std::vector<Ogre::RenderableObject *,std::allocator<Ogre::RenderableObject *> >::begin
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?end@?$vector@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@2@XZ PROC ; std::vector<Ogre::RenderableObject *,std::allocator<Ogre::RenderableObject *> >::end, COMDAT
; _this$ = ecx

; 655  : 		{	// return iterator for end of nonmutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 656  : 		return (const_iterator(_Mylast, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_const_iterator@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@QAE@PAPAVRenderableObject@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<Ogre::RenderableObject *,std::allocator<Ogre::RenderableObject *> >::_Vector_const_iterator<Ogre::RenderableObject *,std::allocator<Ogre::RenderableObject *> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 657  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?end@?$vector@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@2@XZ ENDP ; std::vector<Ogre::RenderableObject *,std::allocator<Ogre::RenderableObject *> >::end
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?size@?$vector@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$vector@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@QBEIXZ PROC ; std::vector<Ogre::RenderableObject *,std::allocator<Ogre::RenderableObject *> >::size, COMDAT
; _this$ = ecx

; 725  : 		{	// return length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+16]
	sub	eax, DWORD PTR [ecx+12]
	sar	eax, 2

; 727  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?size@?$vector@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@QBEIXZ ENDP ; std::vector<Ogre::RenderableObject *,std::allocator<Ogre::RenderableObject *> >::size
_TEXT	ENDS
PUBLIC	?erase@?$vector@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@2@0@Z ; std::vector<Ogre::RenderableObject *,std::allocator<Ogre::RenderableObject *> >::erase
PUBLIC	?begin@?$vector@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@2@XZ ; std::vector<Ogre::RenderableObject *,std::allocator<Ogre::RenderableObject *> >::begin
PUBLIC	?end@?$vector@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@2@XZ ; std::vector<Ogre::RenderableObject *,std::allocator<Ogre::RenderableObject *> >::end
; Function compile flags: /Odtp
;	COMDAT ?clear@?$vector@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -44						; size = 4
$T96200 = -40						; size = 8
$T96199 = -32						; size = 8
$T96198 = -24						; size = 8
$T96197 = -16						; size = 8
$T96196 = -8						; size = 8
?clear@?$vector@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@QAEXXZ PROC ; std::vector<Ogre::RenderableObject *,std::allocator<Ogre::RenderableObject *> >::clear, COMDAT
; _this$ = ecx

; 1059 : 		{	// erase all

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	mov	DWORD PTR _this$[ebp], ecx

; 1060 : 		erase(begin(), end());

	lea	eax, DWORD PTR $T96197[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$vector@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@2@XZ ; std::vector<Ogre::RenderableObject *,std::allocator<Ogre::RenderableObject *> >::end
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T96196[ebp], ecx
	mov	DWORD PTR $T96196[ebp+4], edx
	lea	eax, DWORD PTR $T96199[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$vector@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@2@XZ ; std::vector<Ogre::RenderableObject *,std::allocator<Ogre::RenderableObject *> >::begin
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T96198[ebp], ecx
	mov	DWORD PTR $T96198[ebp+4], edx
	mov	eax, DWORD PTR $T96196[ebp+4]
	push	eax
	mov	ecx, DWORD PTR $T96196[ebp]
	push	ecx
	mov	edx, DWORD PTR $T96198[ebp+4]
	push	edx
	mov	eax, DWORD PTR $T96198[ebp]
	push	eax
	lea	ecx, DWORD PTR $T96200[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$vector@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@2@0@Z ; std::vector<Ogre::RenderableObject *,std::allocator<Ogre::RenderableObject *> >::erase

; 1061 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?clear@?$vector@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@QAEXXZ ENDP ; std::vector<Ogre::RenderableObject *,std::allocator<Ogre::RenderableObject *> >::clear
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@PAVRenderableObject@Ogre@@@std@@QAEPAPAVRenderableObject@Ogre@@I@Z ; std::allocator<Ogre::RenderableObject *>::allocate
PUBLIC	?_Xlen@?$vector@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@KAXXZ ; std::vector<Ogre::RenderableObject *,std::allocator<Ogre::RenderableObject *> >::_Xlen
PUBLIC	?max_size@?$vector@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::RenderableObject *,std::allocator<Ogre::RenderableObject *> >::max_size
; Function compile flags: /Odtp
;	COMDAT ?_Buy@?$vector@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Capacity$ = 8						; size = 4
?_Buy@?$vector@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@IAE_NI@Z PROC ; std::vector<Ogre::RenderableObject *,std::allocator<Ogre::RenderableObject *> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+20], 0

; 1104 : 		if (_Capacity == 0)

	cmp	DWORD PTR __Capacity$[ebp], 0
	jne	SHORT $LN4@Buy@18

; 1105 : 			return (false);

	xor	al, al
	jmp	SHORT $LN5@Buy@18
	jmp	SHORT $LN3@Buy@18
$LN4@Buy@18:

; 1106 : 		else if (max_size() < _Capacity)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::RenderableObject *,std::allocator<Ogre::RenderableObject *> >::max_size
	cmp	eax, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN2@Buy@18

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@KAXXZ ; std::vector<Ogre::RenderableObject *,std::allocator<Ogre::RenderableObject *> >::_Xlen

; 1108 : 		else

	jmp	SHORT $LN3@Buy@18
$LN2@Buy@18:

; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	mov	eax, DWORD PTR __Capacity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?allocate@?$allocator@PAVRenderableObject@Ogre@@@std@@QAEPAPAVRenderableObject@Ogre@@I@Z ; std::allocator<Ogre::RenderableObject *>::allocate
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [edx+16], ecx

; 1112 : 			_Myend = _Myfirst + _Capacity;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR __Capacity$[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], edx
$LN3@Buy@18:

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
$LN5@Buy@18:

; 1115 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Buy@?$vector@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<Ogre::RenderableObject *,std::allocator<Ogre::RenderableObject *> >::_Buy
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@YAXPAPAVRenderableObject@Ogre@@0AAV?$allocator@PAVRenderableObject@Ogre@@@0@@Z ; std::_Destroy_range<std::allocator<Ogre::RenderableObject *> >
; Function compile flags: /Odtp
;	COMDAT ?_Destroy@?$vector@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@IAEXPAPAVRenderableObject@Ogre@@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@IAEXPAPAVRenderableObject@Ogre@@0@Z PROC ; std::vector<Ogre::RenderableObject *,std::allocator<Ogre::RenderableObject *> >::_Destroy, COMDAT
; _this$ = ecx

; 1118 : 		{	// destroy [_First, _Last) using allocator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Destroy_range@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@YAXPAPAVRenderableObject@Ogre@@0AAV?$allocator@PAVRenderableObject@Ogre@@@0@@Z ; std::_Destroy_range<std::allocator<Ogre::RenderableObject *> >
	add	esp, 12					; 0000000cH

; 1120 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?_Destroy@?$vector@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@IAEXPAPAVRenderableObject@Ogre@@0@Z ENDP ; std::vector<Ogre::RenderableObject *,std::allocator<Ogre::RenderableObject *> >::_Destroy
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Tidy@?$vector@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@IAEXXZ PROC ; std::vector<Ogre::RenderableObject *,std::allocator<Ogre::RenderableObject *> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	je	SHORT $LN1@Tidy@16

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@IAEXPAPAVRenderableObject@Ogre@@0@Z ; std::vector<Ogre::RenderableObject *,std::allocator<Ogre::RenderableObject *> >::_Destroy

; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+20]
	sub	ecx, DWORD PTR [eax+12]
	sar	ecx, 2
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?deallocate@?$allocator@PAVRenderableObject@Ogre@@@std@@QAEXPAPAVRenderableObject@Ogre@@I@Z ; std::allocator<Ogre::RenderableObject *>::deallocate
$LN1@Tidy@16:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+16], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], 0

; 1135 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$vector@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@IAEXXZ ENDP ; std::vector<Ogre::RenderableObject *,std::allocator<Ogre::RenderableObject *> >::_Tidy
_TEXT	ENDS
PUBLIC	??0?$_Container_base_aux_alloc_real@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@IAE@V?$allocator@PAVRenderableObject@Ogre@@@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::RenderableObject *> >::_Container_base_aux_alloc_real<std::allocator<Ogre::RenderableObject *> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$_Vector_val@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@IAE@V?$allocator@PAVRenderableObject@Ogre@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Vector_val@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@IAE@V?$allocator@PAVRenderableObject@Ogre@@@1@@Z$0
__ehfuncinfo$??0?$_Vector_val@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@IAE@V?$allocator@PAVRenderableObject@Ogre@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Vector_val@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@IAE@V?$allocator@PAVRenderableObject@Ogre@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Vector_val@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@IAE@V?$allocator@PAVRenderableObject@Ogre@@@1@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T96209 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 1
??0?$_Vector_val@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@IAE@V?$allocator@PAVRenderableObject@Ogre@@@1@@Z PROC ; std::_Vector_val<Ogre::RenderableObject *,std::allocator<Ogre::RenderableObject *> >::_Vector_val<Ogre::RenderableObject *,std::allocator<Ogre::RenderableObject *> >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Vector_val@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@IAE@V?$allocator@PAVRenderableObject@Ogre@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T96209[ebp], esp
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	call	??0?$allocator@PAVRenderableObject@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::RenderableObject *>::allocator<Ogre::RenderableObject *>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Container_base_aux_alloc_real@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@IAE@V?$allocator@PAVRenderableObject@Ogre@@@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::RenderableObject *> >::_Container_base_aux_alloc_real<std::allocator<Ogre::RenderableObject *> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??0?$allocator@PAVRenderableObject@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::RenderableObject *>::allocator<Ogre::RenderableObject *>

; 426  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Vector_val@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@IAE@V?$allocator@PAVRenderableObject@Ogre@@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Container_base_aux_alloc_real@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::RenderableObject *> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::RenderableObject *> >
__ehhandler$??0?$_Vector_val@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@IAE@V?$allocator@PAVRenderableObject@Ogre@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Vector_val@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@IAE@V?$allocator@PAVRenderableObject@Ogre@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Vector_val@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@IAE@V?$allocator@PAVRenderableObject@Ogre@@@1@@Z ENDP ; std::_Vector_val<Ogre::RenderableObject *,std::allocator<Ogre::RenderableObject *> >::_Vector_val<Ogre::RenderableObject *,std::allocator<Ogre::RenderableObject *> >
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??1?$_Container_base_aux_alloc_real@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@IAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Container_base_aux_alloc_real@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@IAE@XZ$0
__ehfuncinfo$??1?$_Container_base_aux_alloc_real@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@IAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Container_base_aux_alloc_real@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@IAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$_Container_base_aux_alloc_real@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Container_base_aux_alloc_real@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::RenderableObject *> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::RenderableObject *> >, COMDAT
; _this$ = ecx

; 436  : 		{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Container_base_aux_alloc_real@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@IAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 437  : 		_Myownedaux->~_Aux_cont();
; 438  : 
; 439  : 		_Alaux.deallocate(_Myownedaux, 1);

	push	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?deallocate@?$allocator@V_Aux_cont@std@@@std@@QAEXPAV_Aux_cont@2@I@Z ; std::allocator<std::_Aux_cont>::deallocate

; 440  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Container_base_aux_alloc_real@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@IAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
__ehhandler$??1?$_Container_base_aux_alloc_real@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@IAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Container_base_aux_alloc_real@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@IAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Container_base_aux_alloc_real@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::RenderableObject *> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::RenderableObject *> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@PAVRenderableObject@Ogre@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$allocator@PAVRenderableObject@Ogre@@@std@@QAE@ABV01@@Z PROC ; std::allocator<Ogre::RenderableObject *>::allocator<Ogre::RenderableObject *>, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$allocator@PAVRenderableObject@Ogre@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<Ogre::RenderableObject *>::allocator<Ogre::RenderableObject *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@PAVRenderableObject@Ogre@@@std@@QAEXPAPAVRenderableObject@Ogre@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@PAVRenderableObject@Ogre@@@std@@QAEXPAPAVRenderableObject@Ogre@@I@Z PROC ; std::allocator<Ogre::RenderableObject *>::deallocate, COMDAT
; _this$ = ecx

; 139  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 141  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@PAVRenderableObject@Ogre@@@std@@QAEXPAPAVRenderableObject@Ogre@@I@Z ENDP ; std::allocator<Ogre::RenderableObject *>::deallocate
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?capacity@?$vector@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
tv70 = -8						; size = 4
_this$ = -4						; size = 4
?capacity@?$vector@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@QBEIXZ PROC ; std::vector<Ogre::Light *,std::allocator<Ogre::Light *> >::capacity, COMDAT
; _this$ = ecx

; 634  : 		{	// return current length of allocated storage

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	jne	SHORT $LN3@capacity@14
	mov	DWORD PTR tv70[ebp], 0
	jmp	SHORT $LN4@capacity@14
$LN3@capacity@14:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+20]
	sub	eax, DWORD PTR [edx+12]
	sar	eax, 2
	mov	DWORD PTR tv70[ebp], eax
$LN4@capacity@14:
	mov	eax, DWORD PTR tv70[ebp]

; 636  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?capacity@?$vector@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@QBEIXZ ENDP ; std::vector<Ogre::Light *,std::allocator<Ogre::Light *> >::capacity
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@QAE@PAPAVLight@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<Ogre::Light *,std::allocator<Ogre::Light *> >::_Vector_const_iterator<Ogre::Light *,std::allocator<Ogre::Light *> >
; Function compile flags: /Odtp
;	COMDAT ?begin@?$vector@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@2@XZ PROC ; std::vector<Ogre::Light *,std::allocator<Ogre::Light *> >::begin, COMDAT
; _this$ = ecx

; 645  : 		{	// return iterator for beginning of nonmutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 646  : 		return (const_iterator(_Myfirst, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_const_iterator@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@QAE@PAPAVLight@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<Ogre::Light *,std::allocator<Ogre::Light *> >::_Vector_const_iterator<Ogre::Light *,std::allocator<Ogre::Light *> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 647  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?begin@?$vector@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@2@XZ ENDP ; std::vector<Ogre::Light *,std::allocator<Ogre::Light *> >::begin
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?end@?$vector@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@2@XZ PROC ; std::vector<Ogre::Light *,std::allocator<Ogre::Light *> >::end, COMDAT
; _this$ = ecx

; 655  : 		{	// return iterator for end of nonmutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 656  : 		return (const_iterator(_Mylast, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_const_iterator@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@QAE@PAPAVLight@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<Ogre::Light *,std::allocator<Ogre::Light *> >::_Vector_const_iterator<Ogre::Light *,std::allocator<Ogre::Light *> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 657  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?end@?$vector@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@QBE?AV?$_Vector_const_iterator@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@2@XZ ENDP ; std::vector<Ogre::Light *,std::allocator<Ogre::Light *> >::end
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?size@?$vector@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$vector@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@QBEIXZ PROC ; std::vector<Ogre::Light *,std::allocator<Ogre::Light *> >::size, COMDAT
; _this$ = ecx

; 725  : 		{	// return length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+16]
	sub	eax, DWORD PTR [ecx+12]
	sar	eax, 2

; 727  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?size@?$vector@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@QBEIXZ ENDP ; std::vector<Ogre::Light *,std::allocator<Ogre::Light *> >::size
_TEXT	ENDS
PUBLIC	?erase@?$vector@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@2@0@Z ; std::vector<Ogre::Light *,std::allocator<Ogre::Light *> >::erase
PUBLIC	?begin@?$vector@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@2@XZ ; std::vector<Ogre::Light *,std::allocator<Ogre::Light *> >::begin
PUBLIC	?end@?$vector@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@2@XZ ; std::vector<Ogre::Light *,std::allocator<Ogre::Light *> >::end
; Function compile flags: /Odtp
;	COMDAT ?clear@?$vector@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -44						; size = 4
$T96246 = -40						; size = 8
$T96245 = -32						; size = 8
$T96244 = -24						; size = 8
$T96243 = -16						; size = 8
$T96242 = -8						; size = 8
?clear@?$vector@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@QAEXXZ PROC ; std::vector<Ogre::Light *,std::allocator<Ogre::Light *> >::clear, COMDAT
; _this$ = ecx

; 1059 : 		{	// erase all

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	mov	DWORD PTR _this$[ebp], ecx

; 1060 : 		erase(begin(), end());

	lea	eax, DWORD PTR $T96243[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$vector@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@2@XZ ; std::vector<Ogre::Light *,std::allocator<Ogre::Light *> >::end
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T96242[ebp], ecx
	mov	DWORD PTR $T96242[ebp+4], edx
	lea	eax, DWORD PTR $T96245[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$vector@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@2@XZ ; std::vector<Ogre::Light *,std::allocator<Ogre::Light *> >::begin
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T96244[ebp], ecx
	mov	DWORD PTR $T96244[ebp+4], edx
	mov	eax, DWORD PTR $T96242[ebp+4]
	push	eax
	mov	ecx, DWORD PTR $T96242[ebp]
	push	ecx
	mov	edx, DWORD PTR $T96244[ebp+4]
	push	edx
	mov	eax, DWORD PTR $T96244[ebp]
	push	eax
	lea	ecx, DWORD PTR $T96246[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$vector@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@2@0@Z ; std::vector<Ogre::Light *,std::allocator<Ogre::Light *> >::erase

; 1061 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?clear@?$vector@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@QAEXXZ ENDP ; std::vector<Ogre::Light *,std::allocator<Ogre::Light *> >::clear
_TEXT	ENDS
PUBLIC	?allocate@?$allocator@PAVLight@Ogre@@@std@@QAEPAPAVLight@Ogre@@I@Z ; std::allocator<Ogre::Light *>::allocate
PUBLIC	?_Xlen@?$vector@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@KAXXZ ; std::vector<Ogre::Light *,std::allocator<Ogre::Light *> >::_Xlen
PUBLIC	?max_size@?$vector@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::Light *,std::allocator<Ogre::Light *> >::max_size
; Function compile flags: /Odtp
;	COMDAT ?_Buy@?$vector@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Capacity$ = 8						; size = 4
?_Buy@?$vector@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@IAE_NI@Z PROC ; std::vector<Ogre::Light *,std::allocator<Ogre::Light *> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+20], 0

; 1104 : 		if (_Capacity == 0)

	cmp	DWORD PTR __Capacity$[ebp], 0
	jne	SHORT $LN4@Buy@19

; 1105 : 			return (false);

	xor	al, al
	jmp	SHORT $LN5@Buy@19
	jmp	SHORT $LN3@Buy@19
$LN4@Buy@19:

; 1106 : 		else if (max_size() < _Capacity)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::Light *,std::allocator<Ogre::Light *> >::max_size
	cmp	eax, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN2@Buy@19

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@KAXXZ ; std::vector<Ogre::Light *,std::allocator<Ogre::Light *> >::_Xlen

; 1108 : 		else

	jmp	SHORT $LN3@Buy@19
$LN2@Buy@19:

; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	mov	eax, DWORD PTR __Capacity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?allocate@?$allocator@PAVLight@Ogre@@@std@@QAEPAPAVLight@Ogre@@I@Z ; std::allocator<Ogre::Light *>::allocate
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [edx+16], ecx

; 1112 : 			_Myend = _Myfirst + _Capacity;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR __Capacity$[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], edx
$LN3@Buy@19:

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
$LN5@Buy@19:

; 1115 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Buy@?$vector@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<Ogre::Light *,std::allocator<Ogre::Light *> >::_Buy
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAVLight@Ogre@@@std@@@std@@YAXPAPAVLight@Ogre@@0AAV?$allocator@PAVLight@Ogre@@@0@@Z ; std::_Destroy_range<std::allocator<Ogre::Light *> >
; Function compile flags: /Odtp
;	COMDAT ?_Destroy@?$vector@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@IAEXPAPAVLight@Ogre@@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@IAEXPAPAVLight@Ogre@@0@Z PROC ; std::vector<Ogre::Light *,std::allocator<Ogre::Light *> >::_Destroy, COMDAT
; _this$ = ecx

; 1118 : 		{	// destroy [_First, _Last) using allocator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Destroy_range@V?$allocator@PAVLight@Ogre@@@std@@@std@@YAXPAPAVLight@Ogre@@0AAV?$allocator@PAVLight@Ogre@@@0@@Z ; std::_Destroy_range<std::allocator<Ogre::Light *> >
	add	esp, 12					; 0000000cH

; 1120 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?_Destroy@?$vector@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@IAEXPAPAVLight@Ogre@@0@Z ENDP ; std::vector<Ogre::Light *,std::allocator<Ogre::Light *> >::_Destroy
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Tidy@?$vector@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@IAEXXZ PROC ; std::vector<Ogre::Light *,std::allocator<Ogre::Light *> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	je	SHORT $LN1@Tidy@17

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@IAEXPAPAVLight@Ogre@@0@Z ; std::vector<Ogre::Light *,std::allocator<Ogre::Light *> >::_Destroy

; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+20]
	sub	ecx, DWORD PTR [eax+12]
	sar	ecx, 2
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?deallocate@?$allocator@PAVLight@Ogre@@@std@@QAEXPAPAVLight@Ogre@@I@Z ; std::allocator<Ogre::Light *>::deallocate
$LN1@Tidy@17:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+16], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], 0

; 1135 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$vector@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@IAEXXZ ENDP ; std::vector<Ogre::Light *,std::allocator<Ogre::Light *> >::_Tidy
_TEXT	ENDS
PUBLIC	??0?$_Container_base_aux_alloc_real@V?$allocator@PAVLight@Ogre@@@std@@@std@@IAE@V?$allocator@PAVLight@Ogre@@@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::Light *> >::_Container_base_aux_alloc_real<std::allocator<Ogre::Light *> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$_Vector_val@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@IAE@V?$allocator@PAVLight@Ogre@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Vector_val@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@IAE@V?$allocator@PAVLight@Ogre@@@1@@Z$0
__ehfuncinfo$??0?$_Vector_val@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@IAE@V?$allocator@PAVLight@Ogre@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Vector_val@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@IAE@V?$allocator@PAVLight@Ogre@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Vector_val@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@IAE@V?$allocator@PAVLight@Ogre@@@1@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T96255 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 1
??0?$_Vector_val@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@IAE@V?$allocator@PAVLight@Ogre@@@1@@Z PROC ; std::_Vector_val<Ogre::Light *,std::allocator<Ogre::Light *> >::_Vector_val<Ogre::Light *,std::allocator<Ogre::Light *> >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Vector_val@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@IAE@V?$allocator@PAVLight@Ogre@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T96255[ebp], esp
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	call	??0?$allocator@PAVLight@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::Light *>::allocator<Ogre::Light *>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Container_base_aux_alloc_real@V?$allocator@PAVLight@Ogre@@@std@@@std@@IAE@V?$allocator@PAVLight@Ogre@@@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::Light *> >::_Container_base_aux_alloc_real<std::allocator<Ogre::Light *> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??0?$allocator@PAVLight@Ogre@@@std@@QAE@ABV01@@Z ; std::allocator<Ogre::Light *>::allocator<Ogre::Light *>

; 426  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Vector_val@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@IAE@V?$allocator@PAVLight@Ogre@@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Container_base_aux_alloc_real@V?$allocator@PAVLight@Ogre@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::Light *> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::Light *> >
__ehhandler$??0?$_Vector_val@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@IAE@V?$allocator@PAVLight@Ogre@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Vector_val@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@IAE@V?$allocator@PAVLight@Ogre@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Vector_val@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@IAE@V?$allocator@PAVLight@Ogre@@@1@@Z ENDP ; std::_Vector_val<Ogre::Light *,std::allocator<Ogre::Light *> >::_Vector_val<Ogre::Light *,std::allocator<Ogre::Light *> >
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??1?$_Container_base_aux_alloc_real@V?$allocator@PAVLight@Ogre@@@std@@@std@@IAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$_Container_base_aux_alloc_real@V?$allocator@PAVLight@Ogre@@@std@@@std@@IAE@XZ$0
__ehfuncinfo$??1?$_Container_base_aux_alloc_real@V?$allocator@PAVLight@Ogre@@@std@@@std@@IAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$_Container_base_aux_alloc_real@V?$allocator@PAVLight@Ogre@@@std@@@std@@IAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$_Container_base_aux_alloc_real@V?$allocator@PAVLight@Ogre@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Container_base_aux_alloc_real@V?$allocator@PAVLight@Ogre@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::Light *> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::Light *> >, COMDAT
; _this$ = ecx

; 436  : 		{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Container_base_aux_alloc_real@V?$allocator@PAVLight@Ogre@@@std@@@std@@IAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 437  : 		_Myownedaux->~_Aux_cont();
; 438  : 
; 439  : 		_Alaux.deallocate(_Myownedaux, 1);

	push	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?deallocate@?$allocator@V_Aux_cont@std@@@std@@QAEXPAV_Aux_cont@2@I@Z ; std::allocator<std::_Aux_cont>::deallocate

; 440  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$_Container_base_aux_alloc_real@V?$allocator@PAVLight@Ogre@@@std@@@std@@IAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
__ehhandler$??1?$_Container_base_aux_alloc_real@V?$allocator@PAVLight@Ogre@@@std@@@std@@IAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Container_base_aux_alloc_real@V?$allocator@PAVLight@Ogre@@@std@@@std@@IAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Container_base_aux_alloc_real@V?$allocator@PAVLight@Ogre@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::Light *> >::~_Container_base_aux_alloc_real<std::allocator<Ogre::Light *> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??0?$allocator@PAVLight@Ogre@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$allocator@PAVLight@Ogre@@@std@@QAE@ABV01@@Z PROC	; std::allocator<Ogre::Light *>::allocator<Ogre::Light *>, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$allocator@PAVLight@Ogre@@@std@@QAE@ABV01@@Z ENDP	; std::allocator<Ogre::Light *>::allocator<Ogre::Light *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@PAVLight@Ogre@@@std@@QAEXPAPAVLight@Ogre@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@PAVLight@Ogre@@@std@@QAEXPAPAVLight@Ogre@@I@Z PROC ; std::allocator<Ogre::Light *>::deallocate, COMDAT
; _this$ = ecx

; 139  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 141  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@PAVLight@Ogre@@@std@@QAEXPAPAVLight@Ogre@@I@Z ENDP ; std::allocator<Ogre::Light *>::deallocate
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?capacity@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
tv70 = -8						; size = 4
_this$ = -4						; size = 4
?capacity@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QBEIXZ PROC ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::capacity, COMDAT
; _this$ = ecx

; 634  : 		{	// return current length of allocated storage

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	jne	SHORT $LN3@capacity@15
	mov	DWORD PTR tv70[ebp], 0
	jmp	SHORT $LN4@capacity@15
$LN3@capacity@15:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+20]
	sub	eax, DWORD PTR [edx+12]
	sar	eax, 3
	mov	DWORD PTR tv70[ebp], eax
$LN4@capacity@15:
	mov	eax, DWORD PTR tv70[ebp]

; 636  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?capacity@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QBEIXZ ENDP ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::capacity
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@QBEIXZ ; std::allocator<Ogre::BaseKeyFrameArray::AnimRange>::max_size
; Function compile flags: /Odtp
;	COMDAT ?max_size@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QBEIXZ PROC ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::max_size, COMDAT
; _this$ = ecx

; 730  : 		{	// return maximum possible length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 731  : 		return (this->_Alval.max_size());

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?max_size@?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@QBEIXZ ; std::allocator<Ogre::BaseKeyFrameArray::AnimRange>::max_size

; 732  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QBEIXZ ENDP ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::max_size
_TEXT	ENDS
PUBLIC	?erase@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@2@V?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@2@0@Z ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::erase
PUBLIC	?begin@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@2@XZ ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::begin
PUBLIC	?end@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@2@XZ ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::end
; Function compile flags: /Odtp
;	COMDAT ?clear@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -44						; size = 4
$T96288 = -40						; size = 8
$T96287 = -32						; size = 8
$T96286 = -24						; size = 8
$T96285 = -16						; size = 8
$T96284 = -8						; size = 8
?clear@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAEXXZ PROC ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::clear, COMDAT
; _this$ = ecx

; 1059 : 		{	// erase all

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	mov	DWORD PTR _this$[ebp], ecx

; 1060 : 		erase(begin(), end());

	lea	eax, DWORD PTR $T96285[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@2@XZ ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::end
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T96284[ebp], ecx
	mov	DWORD PTR $T96284[ebp+4], edx
	lea	eax, DWORD PTR $T96287[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@2@XZ ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::begin
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T96286[ebp], ecx
	mov	DWORD PTR $T96286[ebp+4], edx
	mov	eax, DWORD PTR $T96284[ebp+4]
	push	eax
	mov	ecx, DWORD PTR $T96284[ebp]
	push	ecx
	mov	edx, DWORD PTR $T96286[ebp+4]
	push	edx
	mov	eax, DWORD PTR $T96286[ebp]
	push	eax
	lea	ecx, DWORD PTR $T96288[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@2@V?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@2@0@Z ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::erase

; 1061 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?clear@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAEXXZ ENDP ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::clear
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@YAXPAUAnimRange@BaseKeyFrameArray@Ogre@@0AAV?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@0@@Z ; std::_Destroy_range<std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >
; Function compile flags: /Odtp
;	COMDAT ?_Destroy@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAEXPAUAnimRange@BaseKeyFrameArray@Ogre@@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAEXPAUAnimRange@BaseKeyFrameArray@Ogre@@0@Z PROC ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::_Destroy, COMDAT
; _this$ = ecx

; 1118 : 		{	// destroy [_First, _Last) using allocator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Destroy_range@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@YAXPAUAnimRange@BaseKeyFrameArray@Ogre@@0AAV?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@0@@Z ; std::_Destroy_range<std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >
	add	esp, 12					; 0000000cH

; 1120 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?_Destroy@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAEXPAUAnimRange@BaseKeyFrameArray@Ogre@@0@Z ENDP ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::_Destroy
_TEXT	ENDS
PUBLIC	__TI3?AVlength_error@std@@
PUBLIC	??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::length_error::length_error
PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	??1length_error@std@@UAE@XZ			; std::length_error::~length_error
PUBLIC	__CTA3?AVlength_error@std@@
PUBLIC	__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
PUBLIC	??_R0?AVlength_error@std@@@8			; std::length_error `RTTI Type Descriptor'
PUBLIC	??0length_error@std@@QAE@ABV01@@Z		; std::length_error::length_error
PUBLIC	__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
PUBLIC	??_R0?AVlogic_error@std@@@8			; std::logic_error `RTTI Type Descriptor'
PUBLIC	??0logic_error@std@@QAE@ABV01@@Z		; std::logic_error::logic_error
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z:PROC
EXTRN	??0exception@std@@QAE@ABV01@@Z:PROC		; std::exception::exception
;	COMDAT ??_R0?AVexception@std@@@8
_DATA	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVlogic_error@std@@@8
_DATA	SEGMENT
??_R0?AVlogic_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::logic_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlogic_error@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0logic_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVlength_error@std@@@8
_DATA	SEGMENT
??_R0?AVlength_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::length_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlength_error@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlength_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0length_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA3?AVlength_error@std@@
xdata$x	SEGMENT
__CTA3?AVlength_error@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVlength_error@std@@
xdata$x	SEGMENT
__TI3?AVlength_error@std@@ DD 00H
	DD	FLAT:??1length_error@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVlength_error@std@@
xdata$x	ENDS
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ DB 'vector<T> too long'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@KAXXZ$0
__ehfuncinfo$?_Xlen@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@KAXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T96294 = -80						; size = 28
$T96293 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@KAXXZ PROC ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Xlen@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T96294[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR $T96294[ebp]
	push	eax
	lea	ecx, DWORD PTR $T96293[ebp]
	call	??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::length_error::length_error
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T96293[ebp]
	push	ecx
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T96294[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN2@Xlen:

; 1261 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T96294[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?_Xlen@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@KAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@KAXXZ ENDP ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::_Xlen
PUBLIC	??1logic_error@std@@UAE@XZ			; std::logic_error::~logic_error
PUBLIC	??_7length_error@std@@6B@			; std::length_error::`vftable'
PUBLIC	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
PUBLIC	??_R4length_error@std@@6B@			; std::length_error::`RTTI Complete Object Locator'
PUBLIC	??_R3length_error@std@@8			; std::length_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2length_error@std@@8			; std::length_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@length_error@std@@8		; std::length_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@logic_error@std@@8		; std::logic_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3logic_error@std@@8				; std::logic_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2logic_error@std@@8				; std::logic_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
PUBLIC	?what@logic_error@std@@UBEPBDXZ			; std::logic_error::what
EXTRN	??_Elength_error@std@@UAEPAXI@Z:PROC		; std::length_error::`vector deleting destructor'
;	COMDAT ??_R2exception@std@@8
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R2logic_error@std@@8
rdata$r	SEGMENT
??_R2logic_error@std@@8 DD FLAT:??_R1A@?0A@EA@logic_error@std@@8 ; std::logic_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3logic_error@std@@8
rdata$r	SEGMENT
??_R3logic_error@std@@8 DD 00H				; std::logic_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@logic_error@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@logic_error@std@@8 DD FLAT:??_R0?AVlogic_error@std@@@8 ; std::logic_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@length_error@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@length_error@std@@8 DD FLAT:??_R0?AVlength_error@std@@@8 ; std::length_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2length_error@std@@8
rdata$r	SEGMENT
??_R2length_error@std@@8 DD FLAT:??_R1A@?0A@EA@length_error@std@@8 ; std::length_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@logic_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3length_error@std@@8
rdata$r	SEGMENT
??_R3length_error@std@@8 DD 00H				; std::length_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R4length_error@std@@6B@
rdata$r	SEGMENT
??_R4length_error@std@@6B@ DD 00H			; std::length_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVlength_error@std@@@8
	DD	FLAT:??_R3length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_7length_error@std@@6B@
CONST	SEGMENT
??_7length_error@std@@6B@ DD FLAT:??_R4length_error@std@@6B@ ; std::length_error::`vftable'
	DD	FLAT:??_Elength_error@std@@UAEPAXI@Z
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0
__ehfuncinfo$??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Message$ = 8						; size = 4
??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::length_error::length_error, COMDAT
; _this$ = ecx

; 105  : 		{	// construct from message string

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Message$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7length_error@std@@6B@

; 106  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1logic_error@std@@UAE@XZ		; std::logic_error::~logic_error
__ehhandler$??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::length_error::length_error
PUBLIC	??_7logic_error@std@@6B@			; std::logic_error::`vftable'
PUBLIC	??_R4logic_error@std@@6B@			; std::logic_error::`RTTI Complete Object Locator'
EXTRN	__imp_??1exception@std@@UAE@XZ:PROC
EXTRN	__imp_??0exception@std@@QAE@XZ:PROC
EXTRN	??_Elogic_error@std@@UAEPAXI@Z:PROC		; std::logic_error::`vector deleting destructor'
;	COMDAT ??_R4logic_error@std@@6B@
rdata$r	SEGMENT
??_R4logic_error@std@@6B@ DD 00H			; std::logic_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	FLAT:??_R3logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_7logic_error@std@@6B@
CONST	SEGMENT
??_7logic_error@std@@6B@ DD FLAT:??_R4logic_error@std@@6B@ ; std::logic_error::`vftable'
	DD	FLAT:??_Elogic_error@std@@UAEPAXI@Z
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$1
__ehfuncinfo$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Message$ = 8						; size = 4
??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::logic_error::logic_error, COMDAT
; _this$ = ecx

; 26   : 		{	// construct from message string

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7logic_error@std@@6B@
	mov	ecx, DWORD PTR __Message$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 27   : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__unwindfunclet$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::logic_error::logic_error
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1logic_error@std@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1logic_error@std@@UAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1logic_error@std@@UAE@XZ$1
__ehfuncinfo$??1logic_error@std@@UAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??1logic_error@std@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1logic_error@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1logic_error@std@@UAE@XZ PROC				; std::logic_error::~logic_error, COMDAT
; _this$ = ecx

; 30   : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1logic_error@std@@UAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7logic_error@std@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 31   : 		}

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1logic_error@std@@UAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__unwindfunclet$??1logic_error@std@@UAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$??1logic_error@std@@UAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1logic_error@std@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1logic_error@std@@UAE@XZ ENDP				; std::logic_error::~logic_error
EXTRN	__imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ:PROC
; Function compile flags: /Odtp
;	COMDAT ?what@logic_error@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?what@logic_error@std@@UBEPBDXZ PROC			; std::logic_error::what, COMDAT
; _this$ = ecx

; 34   : 		{	// return pointer to message string

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 35   : 		return (_Str.c_str());

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ

; 36   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?what@logic_error@std@@UBEPBDXZ ENDP			; std::logic_error::what
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_Glogic_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Glogic_error@std@@UAEPAXI@Z PROC			; std::logic_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1logic_error@std@@UAE@XZ		; std::logic_error::~logic_error
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@30
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@30:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Glogic_error@std@@UAEPAXI@Z ENDP			; std::logic_error::`scalar deleting destructor'
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1length_error@std@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1length_error@std@@UAE@XZ$0
__ehfuncinfo$??1length_error@std@@UAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1length_error@std@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1length_error@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1length_error@std@@UAE@XZ PROC			; std::length_error::~length_error, COMDAT
; _this$ = ecx

; 109  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1length_error@std@@UAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7length_error@std@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 110  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1logic_error@std@@UAE@XZ		; std::logic_error::~logic_error
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1length_error@std@@UAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1logic_error@std@@UAE@XZ		; std::logic_error::~logic_error
__ehhandler$??1length_error@std@@UAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1length_error@std@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1length_error@std@@UAE@XZ ENDP			; std::length_error::~length_error
; Function compile flags: /Odtp
;	COMDAT ??_Glength_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Glength_error@std@@UAEPAXI@Z PROC			; std::length_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1length_error@std@@UAE@XZ		; std::length_error::~length_error
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@31
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@31:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Glength_error@std@@UAEPAXI@Z ENDP			; std::length_error::`scalar deleting destructor'
_TEXT	ENDS
EXTRN	__imp_??0exception@std@@QAE@ABV01@@Z:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0logic_error@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$1
__ehfuncinfo$??0logic_error@std@@QAE@ABV01@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0logic_error@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0logic_error@std@@QAE@ABV01@@Z PROC			; std::logic_error::logic_error, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0logic_error@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7logic_error@std@@6B@
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 12					; 0000000cH
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$??0logic_error@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0logic_error@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0logic_error@std@@QAE@ABV01@@Z ENDP			; std::logic_error::logic_error
PUBLIC	??3@YAXPAX0@Z					; operator delete
PUBLIC	??0_Aux_cont@std@@QAE@QBV_Container_base_aux@1@@Z ; std::_Aux_cont::_Aux_cont
PUBLIC	??2@YAPAXIPAX@Z					; operator new
PUBLIC	?allocate@?$allocator@V_Aux_cont@std@@@std@@QAEPAV_Aux_cont@2@I@Z ; std::allocator<std::_Aux_cont>::allocate
PUBLIC	??$?0UAnimRange@BaseKeyFrameArray@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::BaseKeyFrameArray::AnimRange>
PUBLIC	??0_Container_base_aux@std@@QAE@XZ		; std::_Container_base_aux::_Container_base_aux
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??0?$_Container_base_aux_alloc_real@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAE@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAE@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@1@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAE@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@1@@Z$1
__ehfuncinfo$??0?$_Container_base_aux_alloc_real@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAE@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0?$_Container_base_aux_alloc_real@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAE@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Container_base_aux_alloc_real@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAE@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@1@@Z
_TEXT	SEGMENT
tv133 = -32						; size = 4
_this$ = -28						; size = 4
$T96360 = -24						; size = 4
$T96359 = -20						; size = 4
$T96358 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 1
??0?$_Container_base_aux_alloc_real@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAE@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@1@@Z PROC ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::_Container_base_aux_alloc_real<std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >, COMDAT
; _this$ = ecx

; 419  : 		{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Container_base_aux_alloc_real@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAE@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 20					; 00000014H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::_Container_base_aux
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??$?0UAnimRange@BaseKeyFrameArray@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::BaseKeyFrameArray::AnimRange>

; 420  : 		_Myownedaux = new (_Alaux.allocate(1)) _Aux_cont(this);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?allocate@?$allocator@V_Aux_cont@std@@@std@@QAEPAV_Aux_cont@2@I@Z ; std::allocator<std::_Aux_cont>::allocate
	mov	DWORD PTR $T96360[ebp], eax
	mov	ecx, DWORD PTR $T96360[ebp]
	push	ecx
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T96359[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	cmp	DWORD PTR $T96359[ebp], 0
	je	SHORT $LN3@Container_
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T96359[ebp]
	call	??0_Aux_cont@std@@QAE@QBV_Container_base_aux@1@@Z ; std::_Aux_cont::_Aux_cont
	mov	DWORD PTR tv133[ebp], eax
	jmp	SHORT $LN4@Container_
$LN3@Container_:
	mov	DWORD PTR tv133[ebp], 0
$LN4@Container_:
	mov	eax, DWORD PTR tv133[ebp]
	mov	DWORD PTR $T96358[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T96358[ebp]
	mov	DWORD PTR [ecx], edx

; 421  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAE@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAE@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@1@@Z$1:
	mov	eax, DWORD PTR $T96360[ebp]
	push	eax
	mov	ecx, DWORD PTR $T96359[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??0?$_Container_base_aux_alloc_real@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAE@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Container_base_aux_alloc_real@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAE@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Container_base_aux_alloc_real@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAE@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@1@@Z ENDP ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::_Container_base_aux_alloc_real<std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\new
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 58   : 	{	// construct array with placement at _Where

	push	ebp
	mov	ebp, esp

; 59   : 	return (_Where);

	mov	eax, DWORD PTR __Where$[ebp]

; 60   : 	}

	pop	ebp
	ret	0
??2@YAPAXIPAX@Z ENDP					; operator new
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??3@YAXPAX0@Z PROC					; operator delete, COMDAT

; 63   : 	{	// delete if placement new fails

	push	ebp
	mov	ebp, esp

; 64   : 	}

	pop	ebp
	ret	0
??3@YAXPAX0@Z ENDP					; operator delete
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??0_Aux_cont@std@@QAE@QBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pcont$ = 8						; size = 4
??0_Aux_cont@std@@QAE@QBV_Container_base_aux@1@@Z PROC	; std::_Aux_cont::_Aux_cont, COMDAT
; _this$ = ecx

; 364  : 	explicit _Aux_cont(const _Container_base_aux * const _Pcont)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Pcont$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0_Aux_cont@std@@QAE@QBV_Container_base_aux@1@@Z ENDP	; std::_Aux_cont::_Aux_cont
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0_Container_base_aux@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_Container_base_aux@std@@QAE@XZ PROC			; std::_Container_base_aux::_Container_base_aux, COMDAT
; _this$ = ecx

; 379  : 	_Container_base_aux()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 380  : 		{
; 381  : 		// Do nothing: _Container_base_aux_alloc_real() will construct the aux object.
; 382  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0_Container_base_aux@std@@QAE@XZ ENDP			; std::_Container_base_aux::_Container_base_aux
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@QAEXPAUAnimRange@BaseKeyFrameArray@Ogre@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@QAEXPAUAnimRange@BaseKeyFrameArray@Ogre@@I@Z PROC ; std::allocator<Ogre::BaseKeyFrameArray::AnimRange>::deallocate, COMDAT
; _this$ = ecx

; 139  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 141  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@QAEXPAUAnimRange@BaseKeyFrameArray@Ogre@@I@Z ENDP ; std::allocator<Ogre::BaseKeyFrameArray::AnimRange>::deallocate
_TEXT	ENDS
PUBLIC	??$_Allocate@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@IPAU123@@Z ; std::_Allocate<Ogre::BaseKeyFrameArray::AnimRange>
; Function compile flags: /Odtp
;	COMDAT ?allocate@?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@QAEPAUAnimRange@BaseKeyFrameArray@Ogre@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@QAEPAUAnimRange@BaseKeyFrameArray@Ogre@@I@Z PROC ; std::allocator<Ogre::BaseKeyFrameArray::AnimRange>::allocate, COMDAT
; _this$ = ecx

; 144  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@IPAU123@@Z ; std::_Allocate<Ogre::BaseKeyFrameArray::AnimRange>
	add	esp, 8

; 146  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@QAEPAUAnimRange@BaseKeyFrameArray@Ogre@@I@Z ENDP ; std::allocator<Ogre::BaseKeyFrameArray::AnimRange>::allocate
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@V_Aux_cont@std@@@std@@QAEXPAV_Aux_cont@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@V_Aux_cont@std@@@std@@QAEXPAV_Aux_cont@2@I@Z PROC ; std::allocator<std::_Aux_cont>::deallocate, COMDAT
; _this$ = ecx

; 139  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 141  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@V_Aux_cont@std@@@std@@QAEXPAV_Aux_cont@2@I@Z ENDP ; std::allocator<std::_Aux_cont>::deallocate
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?capacity@?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
tv70 = -8						; size = 4
_this$ = -4						; size = 4
?capacity@?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QBEIXZ PROC ; std::vector<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::capacity, COMDAT
; _this$ = ecx

; 634  : 		{	// return current length of allocated storage

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	jne	SHORT $LN3@capacity@16
	mov	DWORD PTR tv70[ebp], 0
	jmp	SHORT $LN4@capacity@16
$LN3@capacity@16:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+20]
	sub	eax, DWORD PTR [edx+12]
	sar	eax, 3
	mov	DWORD PTR tv70[ebp], eax
$LN4@capacity@16:
	mov	eax, DWORD PTR tv70[ebp]

; 636  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?capacity@?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QBEIXZ ENDP ; std::vector<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::capacity
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@QBEIXZ ; std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T>::max_size
; Function compile flags: /Odtp
;	COMDAT ?max_size@?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QBEIXZ PROC ; std::vector<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::max_size, COMDAT
; _this$ = ecx

; 730  : 		{	// return maximum possible length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 731  : 		return (this->_Alval.max_size());

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?max_size@?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@QBEIXZ ; std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T>::max_size

; 732  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QBEIXZ ENDP ; std::vector<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::max_size
_TEXT	ENDS
PUBLIC	?erase@?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@2@V?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@2@0@Z ; std::vector<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::erase
PUBLIC	?begin@?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@2@XZ ; std::vector<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::begin
PUBLIC	?end@?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@2@XZ ; std::vector<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::end
; Function compile flags: /Odtp
;	COMDAT ?clear@?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -44						; size = 4
$T96397 = -40						; size = 8
$T96396 = -32						; size = 8
$T96395 = -24						; size = 8
$T96394 = -16						; size = 8
$T96393 = -8						; size = 8
?clear@?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAEXXZ PROC ; std::vector<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::clear, COMDAT
; _this$ = ecx

; 1059 : 		{	// erase all

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	mov	DWORD PTR _this$[ebp], ecx

; 1060 : 		erase(begin(), end());

	lea	eax, DWORD PTR $T96394[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@2@XZ ; std::vector<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::end
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T96393[ebp], ecx
	mov	DWORD PTR $T96393[ebp+4], edx
	lea	eax, DWORD PTR $T96396[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@2@XZ ; std::vector<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::begin
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T96395[ebp], ecx
	mov	DWORD PTR $T96395[ebp+4], edx
	mov	eax, DWORD PTR $T96393[ebp+4]
	push	eax
	mov	ecx, DWORD PTR $T96393[ebp]
	push	ecx
	mov	edx, DWORD PTR $T96395[ebp+4]
	push	edx
	mov	eax, DWORD PTR $T96395[ebp]
	push	eax
	lea	ecx, DWORD PTR $T96397[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@2@V?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@2@0@Z ; std::vector<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::erase

; 1061 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?clear@?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAEXXZ ENDP ; std::vector<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::clear
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@0AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@0@@Z ; std::_Destroy_range<std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >
; Function compile flags: /Odtp
;	COMDAT ?_Destroy@?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAEXPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAEXPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@0@Z PROC ; std::vector<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::_Destroy, COMDAT
; _this$ = ecx

; 1118 : 		{	// destroy [_First, _Last) using allocator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Destroy_range@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@0AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@0@@Z ; std::_Destroy_range<std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >
	add	esp, 12					; 0000000cH

; 1120 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?_Destroy@?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAEXPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@0@Z ENDP ; std::vector<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::_Destroy
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@KAXXZ$0
__ehfuncinfo$?_Xlen@?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@KAXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T96403 = -80						; size = 28
$T96402 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@KAXXZ PROC ; std::vector<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Xlen@?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T96403[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR $T96403[ebp]
	push	eax
	lea	ecx, DWORD PTR $T96402[ebp]
	call	??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::length_error::length_error
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T96402[ebp]
	push	ecx
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T96403[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN2@Xlen@2:

; 1261 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T96403[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?_Xlen@?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@KAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@KAXXZ ENDP ; std::vector<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::_Xlen
PUBLIC	??$?0UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::KeyFrameArray<float>::KEYFRAME_T>
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??0?$_Container_base_aux_alloc_real@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAE@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAE@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@1@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAE@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@1@@Z$1
__ehfuncinfo$??0?$_Container_base_aux_alloc_real@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAE@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0?$_Container_base_aux_alloc_real@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAE@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Container_base_aux_alloc_real@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAE@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@1@@Z
_TEXT	SEGMENT
tv133 = -32						; size = 4
_this$ = -28						; size = 4
$T96415 = -24						; size = 4
$T96414 = -20						; size = 4
$T96413 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 1
??0?$_Container_base_aux_alloc_real@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAE@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@1@@Z PROC ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::_Container_base_aux_alloc_real<std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >, COMDAT
; _this$ = ecx

; 419  : 		{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Container_base_aux_alloc_real@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAE@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 20					; 00000014H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::_Container_base_aux
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??$?0UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::KeyFrameArray<float>::KEYFRAME_T>

; 420  : 		_Myownedaux = new (_Alaux.allocate(1)) _Aux_cont(this);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?allocate@?$allocator@V_Aux_cont@std@@@std@@QAEPAV_Aux_cont@2@I@Z ; std::allocator<std::_Aux_cont>::allocate
	mov	DWORD PTR $T96415[ebp], eax
	mov	ecx, DWORD PTR $T96415[ebp]
	push	ecx
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T96414[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	cmp	DWORD PTR $T96414[ebp], 0
	je	SHORT $LN3@Container_@2
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T96414[ebp]
	call	??0_Aux_cont@std@@QAE@QBV_Container_base_aux@1@@Z ; std::_Aux_cont::_Aux_cont
	mov	DWORD PTR tv133[ebp], eax
	jmp	SHORT $LN4@Container_@2
$LN3@Container_@2:
	mov	DWORD PTR tv133[ebp], 0
$LN4@Container_@2:
	mov	eax, DWORD PTR tv133[ebp]
	mov	DWORD PTR $T96413[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T96413[ebp]
	mov	DWORD PTR [ecx], edx

; 421  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAE@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAE@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@1@@Z$1:
	mov	eax, DWORD PTR $T96415[ebp]
	push	eax
	mov	ecx, DWORD PTR $T96414[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??0?$_Container_base_aux_alloc_real@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAE@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Container_base_aux_alloc_real@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAE@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Container_base_aux_alloc_real@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAE@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@1@@Z ENDP ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::_Container_base_aux_alloc_real<std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?deallocate@?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@QAEXPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@QAEXPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@I@Z PROC ; std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T>::deallocate, COMDAT
; _this$ = ecx

; 139  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 141  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@QAEXPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@I@Z ENDP ; std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T>::deallocate
_TEXT	ENDS
PUBLIC	??$_Allocate@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@IPAU123@@Z ; std::_Allocate<Ogre::KeyFrameArray<float>::KEYFRAME_T>
; Function compile flags: /Odtp
;	COMDAT ?allocate@?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@QAEPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@QAEPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@I@Z PROC ; std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T>::allocate, COMDAT
; _this$ = ecx

; 144  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@IPAU123@@Z ; std::_Allocate<Ogre::KeyFrameArray<float>::KEYFRAME_T>
	add	esp, 8

; 146  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@QAEPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@I@Z ENDP ; std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T>::allocate
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?capacity@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
tv70 = -8						; size = 4
_this$ = -4						; size = 4
?capacity@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QBEIXZ PROC ; std::vector<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::capacity, COMDAT
; _this$ = ecx

; 634  : 		{	// return current length of allocated storage

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	jne	SHORT $LN3@capacity@17
	mov	DWORD PTR tv70[ebp], 0
	jmp	SHORT $LN4@capacity@17
$LN3@capacity@17:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+20]
	sub	eax, DWORD PTR [edx+12]
	sar	eax, 3
	mov	DWORD PTR tv70[ebp], eax
$LN4@capacity@17:
	mov	eax, DWORD PTR tv70[ebp]

; 636  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?capacity@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QBEIXZ ENDP ; std::vector<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::capacity
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@QBEIXZ ; std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T>::max_size
; Function compile flags: /Odtp
;	COMDAT ?max_size@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QBEIXZ PROC ; std::vector<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::max_size, COMDAT
; _this$ = ecx

; 730  : 		{	// return maximum possible length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 731  : 		return (this->_Alval.max_size());

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?max_size@?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@QBEIXZ ; std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T>::max_size

; 732  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QBEIXZ ENDP ; std::vector<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::max_size
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??A?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAEAAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pos$ = 8						; size = 4
??A?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAEAAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@I@Z PROC ; std::vector<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::operator[], COMDAT
; _this$ = ecx

; 774  : 		{	// subscript mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)
; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");
; 780  : 			_SCL_SECURE_OUT_OF_RANGE;
; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::size
	cmp	DWORD PTR __Pos$[ebp], eax
	jb	SHORT $LN1@operator@39
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN1@operator@39:

; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	edx, DWORD PTR __Pos$[ebp]
	lea	eax, DWORD PTR [ecx+edx*8]

; 786  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??A?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAEAAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@I@Z ENDP ; std::vector<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::operator[]
_TEXT	ENDS
PUBLIC	?erase@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@2@V?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@2@0@Z ; std::vector<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::erase
PUBLIC	?begin@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@2@XZ ; std::vector<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::begin
PUBLIC	?end@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@2@XZ ; std::vector<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::end
; Function compile flags: /Odtp
;	COMDAT ?clear@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -44						; size = 4
$T96444 = -40						; size = 8
$T96443 = -32						; size = 8
$T96442 = -24						; size = 8
$T96441 = -16						; size = 8
$T96440 = -8						; size = 8
?clear@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAEXXZ PROC ; std::vector<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::clear, COMDAT
; _this$ = ecx

; 1059 : 		{	// erase all

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	mov	DWORD PTR _this$[ebp], ecx

; 1060 : 		erase(begin(), end());

	lea	eax, DWORD PTR $T96441[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@2@XZ ; std::vector<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::end
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T96440[ebp], ecx
	mov	DWORD PTR $T96440[ebp+4], edx
	lea	eax, DWORD PTR $T96443[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@2@XZ ; std::vector<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::begin
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T96442[ebp], ecx
	mov	DWORD PTR $T96442[ebp+4], edx
	mov	eax, DWORD PTR $T96440[ebp+4]
	push	eax
	mov	ecx, DWORD PTR $T96440[ebp]
	push	ecx
	mov	edx, DWORD PTR $T96442[ebp+4]
	push	edx
	mov	eax, DWORD PTR $T96442[ebp]
	push	eax
	lea	ecx, DWORD PTR $T96444[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@2@V?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@2@0@Z ; std::vector<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::erase

; 1061 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?clear@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAEXXZ ENDP ; std::vector<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::clear
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@0AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@0@@Z ; std::_Destroy_range<std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >
; Function compile flags: /Odtp
;	COMDAT ?_Destroy@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAEXPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAEXPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@0@Z PROC ; std::vector<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::_Destroy, COMDAT
; _this$ = ecx

; 1118 : 		{	// destroy [_First, _Last) using allocator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Destroy_range@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@0AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@0@@Z ; std::_Destroy_range<std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >
	add	esp, 12					; 0000000cH

; 1120 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?_Destroy@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAEXPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@0@Z ENDP ; std::vector<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::_Destroy
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@KAXXZ$0
__ehfuncinfo$?_Xlen@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@KAXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T96450 = -80						; size = 28
$T96449 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@KAXXZ PROC ; std::vector<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Xlen@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T96450[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR $T96450[ebp]
	push	eax
	lea	ecx, DWORD PTR $T96449[ebp]
	call	??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::length_error::length_error
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T96449[ebp]
	push	ecx
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T96450[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN2@Xlen@3:

; 1261 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T96450[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?_Xlen@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@KAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@KAXXZ ENDP ; std::vector<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::_Xlen
PUBLIC	??$?0UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::KeyFrameArray<float>::CONTROL_POINT_T>
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??0?$_Container_base_aux_alloc_real@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAE@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAE@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@1@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAE@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@1@@Z$1
__ehfuncinfo$??0?$_Container_base_aux_alloc_real@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAE@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0?$_Container_base_aux_alloc_real@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAE@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Container_base_aux_alloc_real@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAE@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@1@@Z
_TEXT	SEGMENT
tv133 = -32						; size = 4
_this$ = -28						; size = 4
$T96462 = -24						; size = 4
$T96461 = -20						; size = 4
$T96460 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 1
??0?$_Container_base_aux_alloc_real@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAE@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@1@@Z PROC ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::_Container_base_aux_alloc_real<std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >, COMDAT
; _this$ = ecx

; 419  : 		{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Container_base_aux_alloc_real@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAE@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 20					; 00000014H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::_Container_base_aux
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??$?0UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::KeyFrameArray<float>::CONTROL_POINT_T>

; 420  : 		_Myownedaux = new (_Alaux.allocate(1)) _Aux_cont(this);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?allocate@?$allocator@V_Aux_cont@std@@@std@@QAEPAV_Aux_cont@2@I@Z ; std::allocator<std::_Aux_cont>::allocate
	mov	DWORD PTR $T96462[ebp], eax
	mov	ecx, DWORD PTR $T96462[ebp]
	push	ecx
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T96461[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	cmp	DWORD PTR $T96461[ebp], 0
	je	SHORT $LN3@Container_@3
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T96461[ebp]
	call	??0_Aux_cont@std@@QAE@QBV_Container_base_aux@1@@Z ; std::_Aux_cont::_Aux_cont
	mov	DWORD PTR tv133[ebp], eax
	jmp	SHORT $LN4@Container_@3
$LN3@Container_@3:
	mov	DWORD PTR tv133[ebp], 0
$LN4@Container_@3:
	mov	eax, DWORD PTR tv133[ebp]
	mov	DWORD PTR $T96460[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T96460[ebp]
	mov	DWORD PTR [ecx], edx

; 421  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAE@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAE@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@1@@Z$1:
	mov	eax, DWORD PTR $T96462[ebp]
	push	eax
	mov	ecx, DWORD PTR $T96461[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??0?$_Container_base_aux_alloc_real@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAE@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Container_base_aux_alloc_real@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAE@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Container_base_aux_alloc_real@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAE@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@1@@Z ENDP ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::_Container_base_aux_alloc_real<std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?deallocate@?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@QAEXPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@QAEXPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@I@Z PROC ; std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T>::deallocate, COMDAT
; _this$ = ecx

; 139  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 141  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@QAEXPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@I@Z ENDP ; std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T>::deallocate
_TEXT	ENDS
PUBLIC	??$_Allocate@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@IPAU123@@Z ; std::_Allocate<Ogre::KeyFrameArray<float>::CONTROL_POINT_T>
; Function compile flags: /Odtp
;	COMDAT ?allocate@?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@QAEPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@QAEPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@I@Z PROC ; std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T>::allocate, COMDAT
; _this$ = ecx

; 144  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@IPAU123@@Z ; std::_Allocate<Ogre::KeyFrameArray<float>::CONTROL_POINT_T>
	add	esp, 8

; 146  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@QAEPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@I@Z ENDP ; std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T>::allocate
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?capacity@?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
tv70 = -8						; size = 4
_this$ = -4						; size = 4
?capacity@?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QBEIXZ PROC ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::capacity, COMDAT
; _this$ = ecx

; 634  : 		{	// return current length of allocated storage

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	jne	SHORT $LN3@capacity@18
	mov	DWORD PTR tv70[ebp], 0
	jmp	SHORT $LN4@capacity@18
$LN3@capacity@18:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+20]
	sub	eax, DWORD PTR [edx+12]
	cdq
	mov	ecx, 20					; 00000014H
	idiv	ecx
	mov	DWORD PTR tv70[ebp], eax
$LN4@capacity@18:
	mov	eax, DWORD PTR tv70[ebp]

; 636  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?capacity@?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QBEIXZ ENDP ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::capacity
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@QBEIXZ ; std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T>::max_size
; Function compile flags: /Odtp
;	COMDAT ?max_size@?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QBEIXZ PROC ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::max_size, COMDAT
; _this$ = ecx

; 730  : 		{	// return maximum possible length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 731  : 		return (this->_Alval.max_size());

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?max_size@?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@QBEIXZ ; std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T>::max_size

; 732  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QBEIXZ ENDP ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::max_size
_TEXT	ENDS
PUBLIC	?erase@?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@2@V?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@2@0@Z ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::erase
PUBLIC	?begin@?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@2@XZ ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::begin
PUBLIC	?end@?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@2@XZ ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::end
; Function compile flags: /Odtp
;	COMDAT ?clear@?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -44						; size = 4
$T96489 = -40						; size = 8
$T96488 = -32						; size = 8
$T96487 = -24						; size = 8
$T96486 = -16						; size = 8
$T96485 = -8						; size = 8
?clear@?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAEXXZ PROC ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::clear, COMDAT
; _this$ = ecx

; 1059 : 		{	// erase all

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	mov	DWORD PTR _this$[ebp], ecx

; 1060 : 		erase(begin(), end());

	lea	eax, DWORD PTR $T96486[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@2@XZ ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::end
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T96485[ebp], ecx
	mov	DWORD PTR $T96485[ebp+4], edx
	lea	eax, DWORD PTR $T96488[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@2@XZ ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::begin
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T96487[ebp], ecx
	mov	DWORD PTR $T96487[ebp+4], edx
	mov	eax, DWORD PTR $T96485[ebp+4]
	push	eax
	mov	ecx, DWORD PTR $T96485[ebp]
	push	ecx
	mov	edx, DWORD PTR $T96487[ebp+4]
	push	edx
	mov	eax, DWORD PTR $T96487[ebp]
	push	eax
	lea	ecx, DWORD PTR $T96489[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@2@V?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@2@0@Z ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::erase

; 1061 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?clear@?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAEXXZ ENDP ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::clear
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@0AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@0@@Z ; std::_Destroy_range<std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >
; Function compile flags: /Odtp
;	COMDAT ?_Destroy@?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAEXPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAEXPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@0@Z PROC ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::_Destroy, COMDAT
; _this$ = ecx

; 1118 : 		{	// destroy [_First, _Last) using allocator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Destroy_range@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@0AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@0@@Z ; std::_Destroy_range<std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >
	add	esp, 12					; 0000000cH

; 1120 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?_Destroy@?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAEXPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@0@Z ENDP ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::_Destroy
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@KAXXZ$0
__ehfuncinfo$?_Xlen@?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@KAXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T96495 = -80						; size = 28
$T96494 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@KAXXZ PROC ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Xlen@?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T96495[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR $T96495[ebp]
	push	eax
	lea	ecx, DWORD PTR $T96494[ebp]
	call	??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::length_error::length_error
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T96494[ebp]
	push	ecx
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T96495[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN2@Xlen@4:

; 1261 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T96495[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?_Xlen@?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@KAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@KAXXZ ENDP ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::_Xlen
PUBLIC	??$?0UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T>
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??0?$_Container_base_aux_alloc_real@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAE@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAE@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@1@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAE@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@1@@Z$1
__ehfuncinfo$??0?$_Container_base_aux_alloc_real@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAE@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0?$_Container_base_aux_alloc_real@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAE@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Container_base_aux_alloc_real@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAE@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@1@@Z
_TEXT	SEGMENT
tv133 = -32						; size = 4
_this$ = -28						; size = 4
$T96507 = -24						; size = 4
$T96506 = -20						; size = 4
$T96505 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 1
??0?$_Container_base_aux_alloc_real@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAE@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@1@@Z PROC ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::_Container_base_aux_alloc_real<std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >, COMDAT
; _this$ = ecx

; 419  : 		{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Container_base_aux_alloc_real@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAE@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 20					; 00000014H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::_Container_base_aux
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??$?0UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T>

; 420  : 		_Myownedaux = new (_Alaux.allocate(1)) _Aux_cont(this);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?allocate@?$allocator@V_Aux_cont@std@@@std@@QAEPAV_Aux_cont@2@I@Z ; std::allocator<std::_Aux_cont>::allocate
	mov	DWORD PTR $T96507[ebp], eax
	mov	ecx, DWORD PTR $T96507[ebp]
	push	ecx
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T96506[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	cmp	DWORD PTR $T96506[ebp], 0
	je	SHORT $LN3@Container_@4
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T96506[ebp]
	call	??0_Aux_cont@std@@QAE@QBV_Container_base_aux@1@@Z ; std::_Aux_cont::_Aux_cont
	mov	DWORD PTR tv133[ebp], eax
	jmp	SHORT $LN4@Container_@4
$LN3@Container_@4:
	mov	DWORD PTR tv133[ebp], 0
$LN4@Container_@4:
	mov	eax, DWORD PTR tv133[ebp]
	mov	DWORD PTR $T96505[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T96505[ebp]
	mov	DWORD PTR [ecx], edx

; 421  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAE@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAE@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@1@@Z$1:
	mov	eax, DWORD PTR $T96507[ebp]
	push	eax
	mov	ecx, DWORD PTR $T96506[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??0?$_Container_base_aux_alloc_real@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAE@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Container_base_aux_alloc_real@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAE@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Container_base_aux_alloc_real@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAE@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@1@@Z ENDP ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::_Container_base_aux_alloc_real<std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?deallocate@?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@QAEXPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@QAEXPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@I@Z PROC ; std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T>::deallocate, COMDAT
; _this$ = ecx

; 139  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 141  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@QAEXPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@I@Z ENDP ; std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T>::deallocate
_TEXT	ENDS
PUBLIC	??$_Allocate@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@IPAU123@@Z ; std::_Allocate<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T>
; Function compile flags: /Odtp
;	COMDAT ?allocate@?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@QAEPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@QAEPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@I@Z PROC ; std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T>::allocate, COMDAT
; _this$ = ecx

; 144  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@IPAU123@@Z ; std::_Allocate<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T>
	add	esp, 8

; 146  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@QAEPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@I@Z ENDP ; std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T>::allocate
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?capacity@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
tv70 = -8						; size = 4
_this$ = -4						; size = 4
?capacity@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QBEIXZ PROC ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::capacity, COMDAT
; _this$ = ecx

; 634  : 		{	// return current length of allocated storage

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	jne	SHORT $LN3@capacity@19
	mov	DWORD PTR tv70[ebp], 0
	jmp	SHORT $LN4@capacity@19
$LN3@capacity@19:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+20]
	sub	eax, DWORD PTR [edx+12]
	sar	eax, 5
	mov	DWORD PTR tv70[ebp], eax
$LN4@capacity@19:
	mov	eax, DWORD PTR tv70[ebp]

; 636  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?capacity@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QBEIXZ ENDP ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::capacity
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@QBEIXZ ; std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T>::max_size
; Function compile flags: /Odtp
;	COMDAT ?max_size@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QBEIXZ PROC ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::max_size, COMDAT
; _this$ = ecx

; 730  : 		{	// return maximum possible length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 731  : 		return (this->_Alval.max_size());

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?max_size@?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@QBEIXZ ; std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T>::max_size

; 732  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QBEIXZ ENDP ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::max_size
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??A?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAEAAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pos$ = 8						; size = 4
??A?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAEAAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@I@Z PROC ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::operator[], COMDAT
; _this$ = ecx

; 774  : 		{	// subscript mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)
; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");
; 780  : 			_SCL_SECURE_OUT_OF_RANGE;
; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::size
	cmp	DWORD PTR __Pos$[ebp], eax
	jb	SHORT $LN1@operator@40
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN1@operator@40:

; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR __Pos$[ebp]
	shl	eax, 5
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+12]

; 786  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??A?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAEAAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@I@Z ENDP ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::operator[]
_TEXT	ENDS
PUBLIC	?erase@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@2@V?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@2@0@Z ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::erase
PUBLIC	?begin@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@2@XZ ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::begin
PUBLIC	?end@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@2@XZ ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::end
; Function compile flags: /Odtp
;	COMDAT ?clear@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -44						; size = 4
$T96536 = -40						; size = 8
$T96535 = -32						; size = 8
$T96534 = -24						; size = 8
$T96533 = -16						; size = 8
$T96532 = -8						; size = 8
?clear@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAEXXZ PROC ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::clear, COMDAT
; _this$ = ecx

; 1059 : 		{	// erase all

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	mov	DWORD PTR _this$[ebp], ecx

; 1060 : 		erase(begin(), end());

	lea	eax, DWORD PTR $T96533[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@2@XZ ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::end
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T96532[ebp], ecx
	mov	DWORD PTR $T96532[ebp+4], edx
	lea	eax, DWORD PTR $T96535[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@2@XZ ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::begin
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T96534[ebp], ecx
	mov	DWORD PTR $T96534[ebp+4], edx
	mov	eax, DWORD PTR $T96532[ebp+4]
	push	eax
	mov	ecx, DWORD PTR $T96532[ebp]
	push	ecx
	mov	edx, DWORD PTR $T96534[ebp+4]
	push	edx
	mov	eax, DWORD PTR $T96534[ebp]
	push	eax
	lea	ecx, DWORD PTR $T96536[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@2@V?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@2@0@Z ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::erase

; 1061 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?clear@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAEXXZ ENDP ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::clear
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@0AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@0@@Z ; std::_Destroy_range<std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >
; Function compile flags: /Odtp
;	COMDAT ?_Destroy@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAEXPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAEXPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@0@Z PROC ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::_Destroy, COMDAT
; _this$ = ecx

; 1118 : 		{	// destroy [_First, _Last) using allocator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Destroy_range@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@0AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@0@@Z ; std::_Destroy_range<std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >
	add	esp, 12					; 0000000cH

; 1120 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?_Destroy@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAEXPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@0@Z ENDP ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::_Destroy
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@KAXXZ$0
__ehfuncinfo$?_Xlen@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@KAXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T96542 = -80						; size = 28
$T96541 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@KAXXZ PROC ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Xlen@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T96542[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR $T96542[ebp]
	push	eax
	lea	ecx, DWORD PTR $T96541[ebp]
	call	??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::length_error::length_error
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T96541[ebp]
	push	ecx
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T96542[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN2@Xlen@5:

; 1261 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T96542[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?_Xlen@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@KAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@KAXXZ ENDP ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::_Xlen
PUBLIC	??$?0UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T>
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??0?$_Container_base_aux_alloc_real@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAE@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAE@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@1@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAE@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@1@@Z$1
__ehfuncinfo$??0?$_Container_base_aux_alloc_real@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAE@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0?$_Container_base_aux_alloc_real@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAE@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Container_base_aux_alloc_real@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAE@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@1@@Z
_TEXT	SEGMENT
tv133 = -32						; size = 4
_this$ = -28						; size = 4
$T96554 = -24						; size = 4
$T96553 = -20						; size = 4
$T96552 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 1
??0?$_Container_base_aux_alloc_real@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAE@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@1@@Z PROC ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::_Container_base_aux_alloc_real<std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >, COMDAT
; _this$ = ecx

; 419  : 		{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Container_base_aux_alloc_real@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAE@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 20					; 00000014H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::_Container_base_aux
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??$?0UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T>

; 420  : 		_Myownedaux = new (_Alaux.allocate(1)) _Aux_cont(this);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?allocate@?$allocator@V_Aux_cont@std@@@std@@QAEPAV_Aux_cont@2@I@Z ; std::allocator<std::_Aux_cont>::allocate
	mov	DWORD PTR $T96554[ebp], eax
	mov	ecx, DWORD PTR $T96554[ebp]
	push	ecx
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T96553[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	cmp	DWORD PTR $T96553[ebp], 0
	je	SHORT $LN3@Container_@5
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T96553[ebp]
	call	??0_Aux_cont@std@@QAE@QBV_Container_base_aux@1@@Z ; std::_Aux_cont::_Aux_cont
	mov	DWORD PTR tv133[ebp], eax
	jmp	SHORT $LN4@Container_@5
$LN3@Container_@5:
	mov	DWORD PTR tv133[ebp], 0
$LN4@Container_@5:
	mov	eax, DWORD PTR tv133[ebp]
	mov	DWORD PTR $T96552[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T96552[ebp]
	mov	DWORD PTR [ecx], edx

; 421  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAE@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAE@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@1@@Z$1:
	mov	eax, DWORD PTR $T96554[ebp]
	push	eax
	mov	ecx, DWORD PTR $T96553[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??0?$_Container_base_aux_alloc_real@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAE@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Container_base_aux_alloc_real@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAE@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Container_base_aux_alloc_real@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAE@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@1@@Z ENDP ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::_Container_base_aux_alloc_real<std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?deallocate@?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@QAEXPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@QAEXPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@I@Z PROC ; std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T>::deallocate, COMDAT
; _this$ = ecx

; 139  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 141  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@QAEXPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@I@Z ENDP ; std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T>::deallocate
_TEXT	ENDS
PUBLIC	??$_Allocate@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@IPAU123@@Z ; std::_Allocate<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T>
; Function compile flags: /Odtp
;	COMDAT ?allocate@?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@QAEPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@QAEPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@I@Z PROC ; std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T>::allocate, COMDAT
; _this$ = ecx

; 144  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@IPAU123@@Z ; std::_Allocate<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T>
	add	esp, 8

; 146  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@QAEPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@I@Z ENDP ; std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T>::allocate
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@QAE@PAPAVShaderContext@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::ShaderContext *,std::allocator<Ogre::ShaderContext *> >::_Vector_iterator<Ogre::ShaderContext *,std::allocator<Ogre::ShaderContext *> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?begin@?$vector@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@2@XZ PROC ; std::vector<Ogre::ShaderContext *,std::allocator<Ogre::ShaderContext *> >::begin, COMDAT
; _this$ = ecx

; 640  : 		{	// return iterator for beginning of mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 641  : 		return (iterator(_Myfirst, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@QAE@PAPAVShaderContext@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::ShaderContext *,std::allocator<Ogre::ShaderContext *> >::_Vector_iterator<Ogre::ShaderContext *,std::allocator<Ogre::ShaderContext *> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 642  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?begin@?$vector@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@2@XZ ENDP ; std::vector<Ogre::ShaderContext *,std::allocator<Ogre::ShaderContext *> >::begin
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?end@?$vector@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@2@XZ PROC ; std::vector<Ogre::ShaderContext *,std::allocator<Ogre::ShaderContext *> >::end, COMDAT
; _this$ = ecx

; 650  : 		{	// return iterator for end of mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 651  : 		return (iterator(_Mylast, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@QAE@PAPAVShaderContext@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::ShaderContext *,std::allocator<Ogre::ShaderContext *> >::_Vector_iterator<Ogre::ShaderContext *,std::allocator<Ogre::ShaderContext *> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 652  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?end@?$vector@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@2@XZ ENDP ; std::vector<Ogre::ShaderContext *,std::allocator<Ogre::ShaderContext *> >::end
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@PAVShaderContext@Ogre@@@std@@QBEIXZ ; std::allocator<Ogre::ShaderContext *>::max_size
; Function compile flags: /Odtp
;	COMDAT ?max_size@?$vector@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$vector@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@QBEIXZ PROC ; std::vector<Ogre::ShaderContext *,std::allocator<Ogre::ShaderContext *> >::max_size, COMDAT
; _this$ = ecx

; 730  : 		{	// return maximum possible length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 731  : 		return (this->_Alval.max_size());

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?max_size@?$allocator@PAVShaderContext@Ogre@@@std@@QBEIXZ ; std::allocator<Ogre::ShaderContext *>::max_size

; 732  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$vector@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@QBEIXZ ENDP ; std::vector<Ogre::ShaderContext *,std::allocator<Ogre::ShaderContext *> >::max_size
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Ogre::ShaderContext *,std::allocator<Ogre::ShaderContext *> >::operator!=
PUBLIC	?_Make_iter@?$vector@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@2@@Z ; std::vector<Ogre::ShaderContext *,std::allocator<Ogre::ShaderContext *> >::_Make_iter
; Function compile flags: /Odtp
;	COMDAT ?erase@?$vector@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@2@0@Z
_TEXT	SEGMENT
_this$ = -24						; size = 4
__Ptr$77722 = -20					; size = 4
__Last$ = -16						; size = 8
__First$ = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 8
__Last_arg$ = 20					; size = 8
?erase@?$vector@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@2@0@Z PROC ; std::vector<Ogre::ShaderContext *,std::allocator<Ogre::ShaderContext *> >::erase, COMDAT
; _this$ = ecx

; 1028 : 		{	// erase [_First, _Last)

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	eax, DWORD PTR __First_arg$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __First_arg$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Make_iter@?$vector@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@2@@Z ; std::vector<Ogre::ShaderContext *,std::allocator<Ogre::ShaderContext *> >::_Make_iter

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);

	mov	eax, DWORD PTR __Last_arg$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __Last_arg$[ebp]
	push	ecx
	lea	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Make_iter@?$vector@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@2@@Z ; std::vector<Ogre::ShaderContext *,std::allocator<Ogre::ShaderContext *> >::_Make_iter

; 1031 : 
; 1032 : 		if (_First != _Last)

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	call	??9?$_Vector_const_iterator@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Ogre::ShaderContext *,std::allocator<Ogre::ShaderContext *> >::operator!=
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@erase

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	edx, DWORD PTR __First$[ebp+4]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp+4]
	push	edx
	call	??$unchecked_copy@PAPAVShaderContext@Ogre@@PAPAV12@@stdext@@YAPAPAVShaderContext@Ogre@@PAPAV12@00@Z ; stdext::unchecked_copy<Ogre::ShaderContext * *,Ogre::ShaderContext * *>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR __Ptr$77722[ebp], eax

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Ptr$77722[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@IAEXPAPAVShaderContext@Ogre@@0@Z ; std::vector<Ogre::ShaderContext *,std::allocator<Ogre::ShaderContext *> >::_Destroy

; 1049 : 			_Mylast = _Ptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Ptr$77722[ebp]
	mov	DWORD PTR [eax+16], ecx
$LN1@erase:

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);

	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR __First$[ebp+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1055 : #endif
; 1056 : 		}

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?erase@?$vector@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@2@0@Z ENDP ; std::vector<Ogre::ShaderContext *,std::allocator<Ogre::ShaderContext *> >::erase
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@KAXXZ$0
__ehfuncinfo$?_Xlen@?$vector@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@KAXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T96580 = -80						; size = 28
$T96579 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@KAXXZ PROC ; std::vector<Ogre::ShaderContext *,std::allocator<Ogre::ShaderContext *> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Xlen@?$vector@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T96580[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR $T96580[ebp]
	push	eax
	lea	ecx, DWORD PTR $T96579[ebp]
	call	??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::length_error::length_error
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T96579[ebp]
	push	ecx
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T96580[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN2@Xlen@6:

; 1261 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T96580[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?_Xlen@?$vector@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@KAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@KAXXZ ENDP ; std::vector<Ogre::ShaderContext *,std::allocator<Ogre::ShaderContext *> >::_Xlen
PUBLIC	??$?0PAVShaderContext@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@PAVShaderContext@Ogre@@@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::ShaderContext *>
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@IAE@V?$allocator@PAVShaderContext@Ogre@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@IAE@V?$allocator@PAVShaderContext@Ogre@@@1@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@IAE@V?$allocator@PAVShaderContext@Ogre@@@1@@Z$1
__ehfuncinfo$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@IAE@V?$allocator@PAVShaderContext@Ogre@@@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@IAE@V?$allocator@PAVShaderContext@Ogre@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Container_base_aux_alloc_real@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@IAE@V?$allocator@PAVShaderContext@Ogre@@@1@@Z
_TEXT	SEGMENT
tv133 = -32						; size = 4
_this$ = -28						; size = 4
$T96592 = -24						; size = 4
$T96591 = -20						; size = 4
$T96590 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 1
??0?$_Container_base_aux_alloc_real@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@IAE@V?$allocator@PAVShaderContext@Ogre@@@1@@Z PROC ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::ShaderContext *> >::_Container_base_aux_alloc_real<std::allocator<Ogre::ShaderContext *> >, COMDAT
; _this$ = ecx

; 419  : 		{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@IAE@V?$allocator@PAVShaderContext@Ogre@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 20					; 00000014H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::_Container_base_aux
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??$?0PAVShaderContext@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@PAVShaderContext@Ogre@@@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::ShaderContext *>

; 420  : 		_Myownedaux = new (_Alaux.allocate(1)) _Aux_cont(this);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?allocate@?$allocator@V_Aux_cont@std@@@std@@QAEPAV_Aux_cont@2@I@Z ; std::allocator<std::_Aux_cont>::allocate
	mov	DWORD PTR $T96592[ebp], eax
	mov	ecx, DWORD PTR $T96592[ebp]
	push	ecx
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T96591[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	cmp	DWORD PTR $T96591[ebp], 0
	je	SHORT $LN3@Container_@6
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T96591[ebp]
	call	??0_Aux_cont@std@@QAE@QBV_Container_base_aux@1@@Z ; std::_Aux_cont::_Aux_cont
	mov	DWORD PTR tv133[ebp], eax
	jmp	SHORT $LN4@Container_@6
$LN3@Container_@6:
	mov	DWORD PTR tv133[ebp], 0
$LN4@Container_@6:
	mov	eax, DWORD PTR tv133[ebp]
	mov	DWORD PTR $T96590[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T96590[ebp]
	mov	DWORD PTR [ecx], edx

; 421  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@IAE@V?$allocator@PAVShaderContext@Ogre@@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@IAE@V?$allocator@PAVShaderContext@Ogre@@@1@@Z$1:
	mov	eax, DWORD PTR $T96592[ebp]
	push	eax
	mov	ecx, DWORD PTR $T96591[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@IAE@V?$allocator@PAVShaderContext@Ogre@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@IAE@V?$allocator@PAVShaderContext@Ogre@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Container_base_aux_alloc_real@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@IAE@V?$allocator@PAVShaderContext@Ogre@@@1@@Z ENDP ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::ShaderContext *> >::_Container_base_aux_alloc_real<std::allocator<Ogre::ShaderContext *> >
PUBLIC	??$_Allocate@PAVShaderContext@Ogre@@@std@@YAPAPAVShaderContext@Ogre@@IPAPAV12@@Z ; std::_Allocate<Ogre::ShaderContext *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@PAVShaderContext@Ogre@@@std@@QAEPAPAVShaderContext@Ogre@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@PAVShaderContext@Ogre@@@std@@QAEPAPAVShaderContext@Ogre@@I@Z PROC ; std::allocator<Ogre::ShaderContext *>::allocate, COMDAT
; _this$ = ecx

; 144  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@PAVShaderContext@Ogre@@@std@@YAPAPAVShaderContext@Ogre@@IPAPAV12@@Z ; std::_Allocate<Ogre::ShaderContext *>
	add	esp, 8

; 146  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@PAVShaderContext@Ogre@@@std@@QAEPAPAVShaderContext@Ogre@@I@Z ENDP ; std::allocator<Ogre::ShaderContext *>::allocate
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@QAE@PAUContextQueDesc@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::ContextQueDesc,std::allocator<Ogre::ContextQueDesc> >::_Vector_iterator<Ogre::ContextQueDesc,std::allocator<Ogre::ContextQueDesc> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?begin@?$vector@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@2@XZ PROC ; std::vector<Ogre::ContextQueDesc,std::allocator<Ogre::ContextQueDesc> >::begin, COMDAT
; _this$ = ecx

; 640  : 		{	// return iterator for beginning of mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 641  : 		return (iterator(_Myfirst, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@QAE@PAUContextQueDesc@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::ContextQueDesc,std::allocator<Ogre::ContextQueDesc> >::_Vector_iterator<Ogre::ContextQueDesc,std::allocator<Ogre::ContextQueDesc> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 642  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?begin@?$vector@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@2@XZ ENDP ; std::vector<Ogre::ContextQueDesc,std::allocator<Ogre::ContextQueDesc> >::begin
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?end@?$vector@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@2@XZ PROC ; std::vector<Ogre::ContextQueDesc,std::allocator<Ogre::ContextQueDesc> >::end, COMDAT
; _this$ = ecx

; 650  : 		{	// return iterator for end of mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 651  : 		return (iterator(_Mylast, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@QAE@PAUContextQueDesc@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::ContextQueDesc,std::allocator<Ogre::ContextQueDesc> >::_Vector_iterator<Ogre::ContextQueDesc,std::allocator<Ogre::ContextQueDesc> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 652  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?end@?$vector@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@2@XZ ENDP ; std::vector<Ogre::ContextQueDesc,std::allocator<Ogre::ContextQueDesc> >::end
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@UContextQueDesc@Ogre@@@std@@QBEIXZ ; std::allocator<Ogre::ContextQueDesc>::max_size
; Function compile flags: /Odtp
;	COMDAT ?max_size@?$vector@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$vector@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@QBEIXZ PROC ; std::vector<Ogre::ContextQueDesc,std::allocator<Ogre::ContextQueDesc> >::max_size, COMDAT
; _this$ = ecx

; 730  : 		{	// return maximum possible length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 731  : 		return (this->_Alval.max_size());

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?max_size@?$allocator@UContextQueDesc@Ogre@@@std@@QBEIXZ ; std::allocator<Ogre::ContextQueDesc>::max_size

; 732  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$vector@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@QBEIXZ ENDP ; std::vector<Ogre::ContextQueDesc,std::allocator<Ogre::ContextQueDesc> >::max_size
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Ogre::ContextQueDesc,std::allocator<Ogre::ContextQueDesc> >::operator!=
PUBLIC	?_Make_iter@?$vector@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@2@V?$_Vector_const_iterator@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@2@@Z ; std::vector<Ogre::ContextQueDesc,std::allocator<Ogre::ContextQueDesc> >::_Make_iter
; Function compile flags: /Odtp
;	COMDAT ?erase@?$vector@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@2@V?$_Vector_const_iterator@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@2@0@Z
_TEXT	SEGMENT
_this$ = -24						; size = 4
__Ptr$77766 = -20					; size = 4
__Last$ = -16						; size = 8
__First$ = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 8
__Last_arg$ = 20					; size = 8
?erase@?$vector@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@2@V?$_Vector_const_iterator@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@2@0@Z PROC ; std::vector<Ogre::ContextQueDesc,std::allocator<Ogre::ContextQueDesc> >::erase, COMDAT
; _this$ = ecx

; 1028 : 		{	// erase [_First, _Last)

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	eax, DWORD PTR __First_arg$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __First_arg$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Make_iter@?$vector@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@2@V?$_Vector_const_iterator@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@2@@Z ; std::vector<Ogre::ContextQueDesc,std::allocator<Ogre::ContextQueDesc> >::_Make_iter

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);

	mov	eax, DWORD PTR __Last_arg$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __Last_arg$[ebp]
	push	ecx
	lea	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Make_iter@?$vector@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@2@V?$_Vector_const_iterator@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@2@@Z ; std::vector<Ogre::ContextQueDesc,std::allocator<Ogre::ContextQueDesc> >::_Make_iter

; 1031 : 
; 1032 : 		if (_First != _Last)

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	call	??9?$_Vector_const_iterator@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Ogre::ContextQueDesc,std::allocator<Ogre::ContextQueDesc> >::operator!=
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@erase@2

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	edx, DWORD PTR __First$[ebp+4]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp+4]
	push	edx
	call	??$unchecked_copy@PAUContextQueDesc@Ogre@@PAU12@@stdext@@YAPAUContextQueDesc@Ogre@@PAU12@00@Z ; stdext::unchecked_copy<Ogre::ContextQueDesc *,Ogre::ContextQueDesc *>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR __Ptr$77766[ebp], eax

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Ptr$77766[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@IAEXPAUContextQueDesc@Ogre@@0@Z ; std::vector<Ogre::ContextQueDesc,std::allocator<Ogre::ContextQueDesc> >::_Destroy

; 1049 : 			_Mylast = _Ptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Ptr$77766[ebp]
	mov	DWORD PTR [eax+16], ecx
$LN1@erase@2:

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);

	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR __First$[ebp+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1055 : #endif
; 1056 : 		}

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?erase@?$vector@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@2@V?$_Vector_const_iterator@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@2@0@Z ENDP ; std::vector<Ogre::ContextQueDesc,std::allocator<Ogre::ContextQueDesc> >::erase
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@KAXXZ$0
__ehfuncinfo$?_Xlen@?$vector@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@KAXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T96616 = -80						; size = 28
$T96615 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@KAXXZ PROC ; std::vector<Ogre::ContextQueDesc,std::allocator<Ogre::ContextQueDesc> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Xlen@?$vector@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T96616[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR $T96616[ebp]
	push	eax
	lea	ecx, DWORD PTR $T96615[ebp]
	call	??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::length_error::length_error
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T96615[ebp]
	push	ecx
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T96616[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN2@Xlen@7:

; 1261 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T96616[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?_Xlen@?$vector@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@KAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@KAXXZ ENDP ; std::vector<Ogre::ContextQueDesc,std::allocator<Ogre::ContextQueDesc> >::_Xlen
PUBLIC	??$?0UContextQueDesc@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@UContextQueDesc@Ogre@@@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::ContextQueDesc>
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??0?$_Container_base_aux_alloc_real@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@IAE@V?$allocator@UContextQueDesc@Ogre@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@IAE@V?$allocator@UContextQueDesc@Ogre@@@1@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@IAE@V?$allocator@UContextQueDesc@Ogre@@@1@@Z$1
__ehfuncinfo$??0?$_Container_base_aux_alloc_real@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@IAE@V?$allocator@UContextQueDesc@Ogre@@@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0?$_Container_base_aux_alloc_real@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@IAE@V?$allocator@UContextQueDesc@Ogre@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Container_base_aux_alloc_real@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@IAE@V?$allocator@UContextQueDesc@Ogre@@@1@@Z
_TEXT	SEGMENT
tv133 = -32						; size = 4
_this$ = -28						; size = 4
$T96628 = -24						; size = 4
$T96627 = -20						; size = 4
$T96626 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 1
??0?$_Container_base_aux_alloc_real@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@IAE@V?$allocator@UContextQueDesc@Ogre@@@1@@Z PROC ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::ContextQueDesc> >::_Container_base_aux_alloc_real<std::allocator<Ogre::ContextQueDesc> >, COMDAT
; _this$ = ecx

; 419  : 		{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Container_base_aux_alloc_real@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@IAE@V?$allocator@UContextQueDesc@Ogre@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 20					; 00000014H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::_Container_base_aux
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??$?0UContextQueDesc@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@UContextQueDesc@Ogre@@@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::ContextQueDesc>

; 420  : 		_Myownedaux = new (_Alaux.allocate(1)) _Aux_cont(this);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?allocate@?$allocator@V_Aux_cont@std@@@std@@QAEPAV_Aux_cont@2@I@Z ; std::allocator<std::_Aux_cont>::allocate
	mov	DWORD PTR $T96628[ebp], eax
	mov	ecx, DWORD PTR $T96628[ebp]
	push	ecx
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T96627[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	cmp	DWORD PTR $T96627[ebp], 0
	je	SHORT $LN3@Container_@7
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T96627[ebp]
	call	??0_Aux_cont@std@@QAE@QBV_Container_base_aux@1@@Z ; std::_Aux_cont::_Aux_cont
	mov	DWORD PTR tv133[ebp], eax
	jmp	SHORT $LN4@Container_@7
$LN3@Container_@7:
	mov	DWORD PTR tv133[ebp], 0
$LN4@Container_@7:
	mov	eax, DWORD PTR tv133[ebp]
	mov	DWORD PTR $T96626[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T96626[ebp]
	mov	DWORD PTR [ecx], edx

; 421  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@IAE@V?$allocator@UContextQueDesc@Ogre@@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@IAE@V?$allocator@UContextQueDesc@Ogre@@@1@@Z$1:
	mov	eax, DWORD PTR $T96628[ebp]
	push	eax
	mov	ecx, DWORD PTR $T96627[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??0?$_Container_base_aux_alloc_real@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@IAE@V?$allocator@UContextQueDesc@Ogre@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Container_base_aux_alloc_real@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@IAE@V?$allocator@UContextQueDesc@Ogre@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Container_base_aux_alloc_real@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@IAE@V?$allocator@UContextQueDesc@Ogre@@@1@@Z ENDP ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::ContextQueDesc> >::_Container_base_aux_alloc_real<std::allocator<Ogre::ContextQueDesc> >
PUBLIC	??$_Allocate@UContextQueDesc@Ogre@@@std@@YAPAUContextQueDesc@Ogre@@IPAU12@@Z ; std::_Allocate<Ogre::ContextQueDesc>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@UContextQueDesc@Ogre@@@std@@QAEPAUContextQueDesc@Ogre@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@UContextQueDesc@Ogre@@@std@@QAEPAUContextQueDesc@Ogre@@I@Z PROC ; std::allocator<Ogre::ContextQueDesc>::allocate, COMDAT
; _this$ = ecx

; 144  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@UContextQueDesc@Ogre@@@std@@YAPAUContextQueDesc@Ogre@@IPAU12@@Z ; std::_Allocate<Ogre::ContextQueDesc>
	add	esp, 8

; 146  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@UContextQueDesc@Ogre@@@std@@QAEPAUContextQueDesc@Ogre@@I@Z ENDP ; std::allocator<Ogre::ContextQueDesc>::allocate
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@EV?$allocator@E@std@@@std@@QAE@PAEPBV_Container_base_aux@1@@Z ; std::_Vector_iterator<unsigned char,std::allocator<unsigned char> >::_Vector_iterator<unsigned char,std::allocator<unsigned char> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?begin@?$vector@EV?$allocator@E@std@@@std@@QAE?AV?$_Vector_iterator@EV?$allocator@E@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@EV?$allocator@E@std@@@std@@QAE?AV?$_Vector_iterator@EV?$allocator@E@std@@@2@XZ PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::begin, COMDAT
; _this$ = ecx

; 640  : 		{	// return iterator for beginning of mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 641  : 		return (iterator(_Myfirst, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@EV?$allocator@E@std@@@std@@QAE@PAEPBV_Container_base_aux@1@@Z ; std::_Vector_iterator<unsigned char,std::allocator<unsigned char> >::_Vector_iterator<unsigned char,std::allocator<unsigned char> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 642  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?begin@?$vector@EV?$allocator@E@std@@@std@@QAE?AV?$_Vector_iterator@EV?$allocator@E@std@@@2@XZ ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::begin
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?end@?$vector@EV?$allocator@E@std@@@std@@QAE?AV?$_Vector_iterator@EV?$allocator@E@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@EV?$allocator@E@std@@@std@@QAE?AV?$_Vector_iterator@EV?$allocator@E@std@@@2@XZ PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::end, COMDAT
; _this$ = ecx

; 650  : 		{	// return iterator for end of mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 651  : 		return (iterator(_Mylast, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@EV?$allocator@E@std@@@std@@QAE@PAEPBV_Container_base_aux@1@@Z ; std::_Vector_iterator<unsigned char,std::allocator<unsigned char> >::_Vector_iterator<unsigned char,std::allocator<unsigned char> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 652  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?end@?$vector@EV?$allocator@E@std@@@std@@QAE?AV?$_Vector_iterator@EV?$allocator@E@std@@@2@XZ ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::end
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@E@std@@QBEIXZ		; std::allocator<unsigned char>::max_size
; Function compile flags: /Odtp
;	COMDAT ?max_size@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::max_size, COMDAT
; _this$ = ecx

; 730  : 		{	// return maximum possible length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 731  : 		return (this->_Alval.max_size());

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?max_size@?$allocator@E@std@@QBEIXZ	; std::allocator<unsigned char>::max_size

; 732  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::max_size
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@EV?$allocator@E@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<unsigned char,std::allocator<unsigned char> >::operator!=
PUBLIC	?_Make_iter@?$vector@EV?$allocator@E@std@@@std@@QBE?AV?$_Vector_iterator@EV?$allocator@E@std@@@2@V?$_Vector_const_iterator@EV?$allocator@E@std@@@2@@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Make_iter
; Function compile flags: /Odtp
;	COMDAT ?erase@?$vector@EV?$allocator@E@std@@@std@@QAE?AV?$_Vector_iterator@EV?$allocator@E@std@@@2@V?$_Vector_const_iterator@EV?$allocator@E@std@@@2@0@Z
_TEXT	SEGMENT
_this$ = -24						; size = 4
__Ptr$77810 = -20					; size = 4
__Last$ = -16						; size = 8
__First$ = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 8
__Last_arg$ = 20					; size = 8
?erase@?$vector@EV?$allocator@E@std@@@std@@QAE?AV?$_Vector_iterator@EV?$allocator@E@std@@@2@V?$_Vector_const_iterator@EV?$allocator@E@std@@@2@0@Z PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::erase, COMDAT
; _this$ = ecx

; 1028 : 		{	// erase [_First, _Last)

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	eax, DWORD PTR __First_arg$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __First_arg$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Make_iter@?$vector@EV?$allocator@E@std@@@std@@QBE?AV?$_Vector_iterator@EV?$allocator@E@std@@@2@V?$_Vector_const_iterator@EV?$allocator@E@std@@@2@@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Make_iter

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);

	mov	eax, DWORD PTR __Last_arg$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __Last_arg$[ebp]
	push	ecx
	lea	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Make_iter@?$vector@EV?$allocator@E@std@@@std@@QBE?AV?$_Vector_iterator@EV?$allocator@E@std@@@2@V?$_Vector_const_iterator@EV?$allocator@E@std@@@2@@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Make_iter

; 1031 : 
; 1032 : 		if (_First != _Last)

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	call	??9?$_Vector_const_iterator@EV?$allocator@E@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<unsigned char,std::allocator<unsigned char> >::operator!=
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@erase@3

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	edx, DWORD PTR __First$[ebp+4]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp+4]
	push	edx
	call	??$unchecked_copy@PAEPAE@stdext@@YAPAEPAE00@Z ; stdext::unchecked_copy<unsigned char *,unsigned char *>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR __Ptr$77810[ebp], eax

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Ptr$77810[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@EV?$allocator@E@std@@@std@@IAEXPAE0@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Destroy

; 1049 : 			_Mylast = _Ptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Ptr$77810[ebp]
	mov	DWORD PTR [eax+16], ecx
$LN1@erase@3:

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);

	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR __First$[ebp+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1055 : #endif
; 1056 : 		}

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?erase@?$vector@EV?$allocator@E@std@@@std@@QAE?AV?$_Vector_iterator@EV?$allocator@E@std@@@2@V?$_Vector_const_iterator@EV?$allocator@E@std@@@2@0@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::erase
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@EV?$allocator@E@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@EV?$allocator@E@std@@@std@@KAXXZ$0
__ehfuncinfo$?_Xlen@?$vector@EV?$allocator@E@std@@@std@@KAXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@EV?$allocator@E@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@EV?$allocator@E@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T96652 = -80						; size = 28
$T96651 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@EV?$allocator@E@std@@@std@@KAXXZ PROC	; std::vector<unsigned char,std::allocator<unsigned char> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Xlen@?$vector@EV?$allocator@E@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T96652[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR $T96652[ebp]
	push	eax
	lea	ecx, DWORD PTR $T96651[ebp]
	call	??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::length_error::length_error
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T96651[ebp]
	push	ecx
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T96652[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN2@Xlen@8:

; 1261 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@EV?$allocator@E@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T96652[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?_Xlen@?$vector@EV?$allocator@E@std@@@std@@KAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@EV?$allocator@E@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@EV?$allocator@E@std@@@std@@KAXXZ ENDP	; std::vector<unsigned char,std::allocator<unsigned char> >::_Xlen
PUBLIC	??$?0E@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@E@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><unsigned char>
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??0?$_Container_base_aux_alloc_real@V?$allocator@E@std@@@std@@IAE@V?$allocator@E@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@E@std@@@std@@IAE@V?$allocator@E@1@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@E@std@@@std@@IAE@V?$allocator@E@1@@Z$1
__ehfuncinfo$??0?$_Container_base_aux_alloc_real@V?$allocator@E@std@@@std@@IAE@V?$allocator@E@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0?$_Container_base_aux_alloc_real@V?$allocator@E@std@@@std@@IAE@V?$allocator@E@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Container_base_aux_alloc_real@V?$allocator@E@std@@@std@@IAE@V?$allocator@E@1@@Z
_TEXT	SEGMENT
tv133 = -32						; size = 4
_this$ = -28						; size = 4
$T96664 = -24						; size = 4
$T96663 = -20						; size = 4
$T96662 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 1
??0?$_Container_base_aux_alloc_real@V?$allocator@E@std@@@std@@IAE@V?$allocator@E@1@@Z PROC ; std::_Container_base_aux_alloc_real<std::allocator<unsigned char> >::_Container_base_aux_alloc_real<std::allocator<unsigned char> >, COMDAT
; _this$ = ecx

; 419  : 		{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Container_base_aux_alloc_real@V?$allocator@E@std@@@std@@IAE@V?$allocator@E@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 20					; 00000014H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::_Container_base_aux
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??$?0E@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@E@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><unsigned char>

; 420  : 		_Myownedaux = new (_Alaux.allocate(1)) _Aux_cont(this);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?allocate@?$allocator@V_Aux_cont@std@@@std@@QAEPAV_Aux_cont@2@I@Z ; std::allocator<std::_Aux_cont>::allocate
	mov	DWORD PTR $T96664[ebp], eax
	mov	ecx, DWORD PTR $T96664[ebp]
	push	ecx
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T96663[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	cmp	DWORD PTR $T96663[ebp], 0
	je	SHORT $LN3@Container_@8
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T96663[ebp]
	call	??0_Aux_cont@std@@QAE@QBV_Container_base_aux@1@@Z ; std::_Aux_cont::_Aux_cont
	mov	DWORD PTR tv133[ebp], eax
	jmp	SHORT $LN4@Container_@8
$LN3@Container_@8:
	mov	DWORD PTR tv133[ebp], 0
$LN4@Container_@8:
	mov	eax, DWORD PTR tv133[ebp]
	mov	DWORD PTR $T96662[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T96662[ebp]
	mov	DWORD PTR [ecx], edx

; 421  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@E@std@@@std@@IAE@V?$allocator@E@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@E@std@@@std@@IAE@V?$allocator@E@1@@Z$1:
	mov	eax, DWORD PTR $T96664[ebp]
	push	eax
	mov	ecx, DWORD PTR $T96663[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??0?$_Container_base_aux_alloc_real@V?$allocator@E@std@@@std@@IAE@V?$allocator@E@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Container_base_aux_alloc_real@V?$allocator@E@std@@@std@@IAE@V?$allocator@E@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Container_base_aux_alloc_real@V?$allocator@E@std@@@std@@IAE@V?$allocator@E@1@@Z ENDP ; std::_Container_base_aux_alloc_real<std::allocator<unsigned char> >::_Container_base_aux_alloc_real<std::allocator<unsigned char> >
PUBLIC	??$_Allocate@E@std@@YAPAEIPAE@Z			; std::_Allocate<unsigned char>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@E@std@@QAEPAEI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@E@std@@QAEPAEI@Z PROC		; std::allocator<unsigned char>::allocate, COMDAT
; _this$ = ecx

; 144  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@E@std@@YAPAEIPAE@Z		; std::_Allocate<unsigned char>
	add	esp, 8

; 146  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@E@std@@QAEPAEI@Z ENDP		; std::allocator<unsigned char>::allocate
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@QAE@PAUValueParam@ShaderContextPool@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::ShaderContextPool::ValueParam,std::allocator<Ogre::ShaderContextPool::ValueParam> >::_Vector_iterator<Ogre::ShaderContextPool::ValueParam,std::allocator<Ogre::ShaderContextPool::ValueParam> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?begin@?$vector@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@2@XZ PROC ; std::vector<Ogre::ShaderContextPool::ValueParam,std::allocator<Ogre::ShaderContextPool::ValueParam> >::begin, COMDAT
; _this$ = ecx

; 640  : 		{	// return iterator for beginning of mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 641  : 		return (iterator(_Myfirst, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@QAE@PAUValueParam@ShaderContextPool@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::ShaderContextPool::ValueParam,std::allocator<Ogre::ShaderContextPool::ValueParam> >::_Vector_iterator<Ogre::ShaderContextPool::ValueParam,std::allocator<Ogre::ShaderContextPool::ValueParam> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 642  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?begin@?$vector@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@2@XZ ENDP ; std::vector<Ogre::ShaderContextPool::ValueParam,std::allocator<Ogre::ShaderContextPool::ValueParam> >::begin
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?end@?$vector@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@2@XZ PROC ; std::vector<Ogre::ShaderContextPool::ValueParam,std::allocator<Ogre::ShaderContextPool::ValueParam> >::end, COMDAT
; _this$ = ecx

; 650  : 		{	// return iterator for end of mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 651  : 		return (iterator(_Mylast, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@QAE@PAUValueParam@ShaderContextPool@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::ShaderContextPool::ValueParam,std::allocator<Ogre::ShaderContextPool::ValueParam> >::_Vector_iterator<Ogre::ShaderContextPool::ValueParam,std::allocator<Ogre::ShaderContextPool::ValueParam> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 652  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?end@?$vector@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@2@XZ ENDP ; std::vector<Ogre::ShaderContextPool::ValueParam,std::allocator<Ogre::ShaderContextPool::ValueParam> >::end
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@QBEIXZ ; std::allocator<Ogre::ShaderContextPool::ValueParam>::max_size
; Function compile flags: /Odtp
;	COMDAT ?max_size@?$vector@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$vector@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@QBEIXZ PROC ; std::vector<Ogre::ShaderContextPool::ValueParam,std::allocator<Ogre::ShaderContextPool::ValueParam> >::max_size, COMDAT
; _this$ = ecx

; 730  : 		{	// return maximum possible length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 731  : 		return (this->_Alval.max_size());

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?max_size@?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@QBEIXZ ; std::allocator<Ogre::ShaderContextPool::ValueParam>::max_size

; 732  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$vector@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@QBEIXZ ENDP ; std::vector<Ogre::ShaderContextPool::ValueParam,std::allocator<Ogre::ShaderContextPool::ValueParam> >::max_size
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Ogre::ShaderContextPool::ValueParam,std::allocator<Ogre::ShaderContextPool::ValueParam> >::operator!=
PUBLIC	?_Make_iter@?$vector@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@2@V?$_Vector_const_iterator@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@2@@Z ; std::vector<Ogre::ShaderContextPool::ValueParam,std::allocator<Ogre::ShaderContextPool::ValueParam> >::_Make_iter
; Function compile flags: /Odtp
;	COMDAT ?erase@?$vector@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@2@V?$_Vector_const_iterator@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@2@0@Z
_TEXT	SEGMENT
_this$ = -24						; size = 4
__Ptr$77854 = -20					; size = 4
__Last$ = -16						; size = 8
__First$ = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 8
__Last_arg$ = 20					; size = 8
?erase@?$vector@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@2@V?$_Vector_const_iterator@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@2@0@Z PROC ; std::vector<Ogre::ShaderContextPool::ValueParam,std::allocator<Ogre::ShaderContextPool::ValueParam> >::erase, COMDAT
; _this$ = ecx

; 1028 : 		{	// erase [_First, _Last)

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	eax, DWORD PTR __First_arg$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __First_arg$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Make_iter@?$vector@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@2@V?$_Vector_const_iterator@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@2@@Z ; std::vector<Ogre::ShaderContextPool::ValueParam,std::allocator<Ogre::ShaderContextPool::ValueParam> >::_Make_iter

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);

	mov	eax, DWORD PTR __Last_arg$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __Last_arg$[ebp]
	push	ecx
	lea	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Make_iter@?$vector@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@2@V?$_Vector_const_iterator@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@2@@Z ; std::vector<Ogre::ShaderContextPool::ValueParam,std::allocator<Ogre::ShaderContextPool::ValueParam> >::_Make_iter

; 1031 : 
; 1032 : 		if (_First != _Last)

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	call	??9?$_Vector_const_iterator@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Ogre::ShaderContextPool::ValueParam,std::allocator<Ogre::ShaderContextPool::ValueParam> >::operator!=
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@erase@4

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	edx, DWORD PTR __First$[ebp+4]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp+4]
	push	edx
	call	??$unchecked_copy@PAUValueParam@ShaderContextPool@Ogre@@PAU123@@stdext@@YAPAUValueParam@ShaderContextPool@Ogre@@PAU123@00@Z ; stdext::unchecked_copy<Ogre::ShaderContextPool::ValueParam *,Ogre::ShaderContextPool::ValueParam *>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR __Ptr$77854[ebp], eax

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Ptr$77854[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@IAEXPAUValueParam@ShaderContextPool@Ogre@@0@Z ; std::vector<Ogre::ShaderContextPool::ValueParam,std::allocator<Ogre::ShaderContextPool::ValueParam> >::_Destroy

; 1049 : 			_Mylast = _Ptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Ptr$77854[ebp]
	mov	DWORD PTR [eax+16], ecx
$LN1@erase@4:

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);

	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR __First$[ebp+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1055 : #endif
; 1056 : 		}

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?erase@?$vector@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@2@V?$_Vector_const_iterator@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@2@0@Z ENDP ; std::vector<Ogre::ShaderContextPool::ValueParam,std::allocator<Ogre::ShaderContextPool::ValueParam> >::erase
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@KAXXZ$0
__ehfuncinfo$?_Xlen@?$vector@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@KAXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T96688 = -80						; size = 28
$T96687 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@KAXXZ PROC ; std::vector<Ogre::ShaderContextPool::ValueParam,std::allocator<Ogre::ShaderContextPool::ValueParam> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Xlen@?$vector@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T96688[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR $T96688[ebp]
	push	eax
	lea	ecx, DWORD PTR $T96687[ebp]
	call	??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::length_error::length_error
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T96687[ebp]
	push	ecx
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T96688[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN2@Xlen@9:

; 1261 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T96688[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?_Xlen@?$vector@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@KAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@KAXXZ ENDP ; std::vector<Ogre::ShaderContextPool::ValueParam,std::allocator<Ogre::ShaderContextPool::ValueParam> >::_Xlen
PUBLIC	??$?0UValueParam@ShaderContextPool@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@UValueParam@ShaderContextPool@Ogre@@@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::ShaderContextPool::ValueParam>
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??0?$_Container_base_aux_alloc_real@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@IAE@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@IAE@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@1@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@IAE@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@1@@Z$1
__ehfuncinfo$??0?$_Container_base_aux_alloc_real@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@IAE@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0?$_Container_base_aux_alloc_real@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@IAE@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Container_base_aux_alloc_real@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@IAE@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@1@@Z
_TEXT	SEGMENT
tv133 = -32						; size = 4
_this$ = -28						; size = 4
$T96700 = -24						; size = 4
$T96699 = -20						; size = 4
$T96698 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 1
??0?$_Container_base_aux_alloc_real@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@IAE@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@1@@Z PROC ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::ShaderContextPool::ValueParam> >::_Container_base_aux_alloc_real<std::allocator<Ogre::ShaderContextPool::ValueParam> >, COMDAT
; _this$ = ecx

; 419  : 		{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Container_base_aux_alloc_real@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@IAE@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 20					; 00000014H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::_Container_base_aux
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??$?0UValueParam@ShaderContextPool@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@UValueParam@ShaderContextPool@Ogre@@@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::ShaderContextPool::ValueParam>

; 420  : 		_Myownedaux = new (_Alaux.allocate(1)) _Aux_cont(this);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?allocate@?$allocator@V_Aux_cont@std@@@std@@QAEPAV_Aux_cont@2@I@Z ; std::allocator<std::_Aux_cont>::allocate
	mov	DWORD PTR $T96700[ebp], eax
	mov	ecx, DWORD PTR $T96700[ebp]
	push	ecx
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T96699[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	cmp	DWORD PTR $T96699[ebp], 0
	je	SHORT $LN3@Container_@9
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T96699[ebp]
	call	??0_Aux_cont@std@@QAE@QBV_Container_base_aux@1@@Z ; std::_Aux_cont::_Aux_cont
	mov	DWORD PTR tv133[ebp], eax
	jmp	SHORT $LN4@Container_@9
$LN3@Container_@9:
	mov	DWORD PTR tv133[ebp], 0
$LN4@Container_@9:
	mov	eax, DWORD PTR tv133[ebp]
	mov	DWORD PTR $T96698[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T96698[ebp]
	mov	DWORD PTR [ecx], edx

; 421  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@IAE@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@IAE@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@1@@Z$1:
	mov	eax, DWORD PTR $T96700[ebp]
	push	eax
	mov	ecx, DWORD PTR $T96699[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??0?$_Container_base_aux_alloc_real@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@IAE@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Container_base_aux_alloc_real@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@IAE@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Container_base_aux_alloc_real@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@IAE@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@1@@Z ENDP ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::ShaderContextPool::ValueParam> >::_Container_base_aux_alloc_real<std::allocator<Ogre::ShaderContextPool::ValueParam> >
PUBLIC	??$_Allocate@UValueParam@ShaderContextPool@Ogre@@@std@@YAPAUValueParam@ShaderContextPool@Ogre@@IPAU123@@Z ; std::_Allocate<Ogre::ShaderContextPool::ValueParam>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@QAEPAUValueParam@ShaderContextPool@Ogre@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@QAEPAUValueParam@ShaderContextPool@Ogre@@I@Z PROC ; std::allocator<Ogre::ShaderContextPool::ValueParam>::allocate, COMDAT
; _this$ = ecx

; 144  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@UValueParam@ShaderContextPool@Ogre@@@std@@YAPAUValueParam@ShaderContextPool@Ogre@@IPAU123@@Z ; std::_Allocate<Ogre::ShaderContextPool::ValueParam>
	add	esp, 8

; 146  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@QAEPAUValueParam@ShaderContextPool@Ogre@@I@Z ENDP ; std::allocator<Ogre::ShaderContextPool::ValueParam>::allocate
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@QAE@PAUTexParam@ShaderContextPool@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::ShaderContextPool::TexParam,std::allocator<Ogre::ShaderContextPool::TexParam> >::_Vector_iterator<Ogre::ShaderContextPool::TexParam,std::allocator<Ogre::ShaderContextPool::TexParam> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?begin@?$vector@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@2@XZ PROC ; std::vector<Ogre::ShaderContextPool::TexParam,std::allocator<Ogre::ShaderContextPool::TexParam> >::begin, COMDAT
; _this$ = ecx

; 640  : 		{	// return iterator for beginning of mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 641  : 		return (iterator(_Myfirst, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@QAE@PAUTexParam@ShaderContextPool@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::ShaderContextPool::TexParam,std::allocator<Ogre::ShaderContextPool::TexParam> >::_Vector_iterator<Ogre::ShaderContextPool::TexParam,std::allocator<Ogre::ShaderContextPool::TexParam> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 642  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?begin@?$vector@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@2@XZ ENDP ; std::vector<Ogre::ShaderContextPool::TexParam,std::allocator<Ogre::ShaderContextPool::TexParam> >::begin
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?end@?$vector@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@2@XZ PROC ; std::vector<Ogre::ShaderContextPool::TexParam,std::allocator<Ogre::ShaderContextPool::TexParam> >::end, COMDAT
; _this$ = ecx

; 650  : 		{	// return iterator for end of mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 651  : 		return (iterator(_Mylast, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@QAE@PAUTexParam@ShaderContextPool@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::ShaderContextPool::TexParam,std::allocator<Ogre::ShaderContextPool::TexParam> >::_Vector_iterator<Ogre::ShaderContextPool::TexParam,std::allocator<Ogre::ShaderContextPool::TexParam> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 652  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?end@?$vector@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@2@XZ ENDP ; std::vector<Ogre::ShaderContextPool::TexParam,std::allocator<Ogre::ShaderContextPool::TexParam> >::end
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@QBEIXZ ; std::allocator<Ogre::ShaderContextPool::TexParam>::max_size
; Function compile flags: /Odtp
;	COMDAT ?max_size@?$vector@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$vector@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@QBEIXZ PROC ; std::vector<Ogre::ShaderContextPool::TexParam,std::allocator<Ogre::ShaderContextPool::TexParam> >::max_size, COMDAT
; _this$ = ecx

; 730  : 		{	// return maximum possible length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 731  : 		return (this->_Alval.max_size());

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?max_size@?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@QBEIXZ ; std::allocator<Ogre::ShaderContextPool::TexParam>::max_size

; 732  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$vector@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@QBEIXZ ENDP ; std::vector<Ogre::ShaderContextPool::TexParam,std::allocator<Ogre::ShaderContextPool::TexParam> >::max_size
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Ogre::ShaderContextPool::TexParam,std::allocator<Ogre::ShaderContextPool::TexParam> >::operator!=
PUBLIC	?_Make_iter@?$vector@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@2@V?$_Vector_const_iterator@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@2@@Z ; std::vector<Ogre::ShaderContextPool::TexParam,std::allocator<Ogre::ShaderContextPool::TexParam> >::_Make_iter
; Function compile flags: /Odtp
;	COMDAT ?erase@?$vector@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@2@V?$_Vector_const_iterator@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@2@0@Z
_TEXT	SEGMENT
_this$ = -24						; size = 4
__Ptr$77898 = -20					; size = 4
__Last$ = -16						; size = 8
__First$ = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 8
__Last_arg$ = 20					; size = 8
?erase@?$vector@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@2@V?$_Vector_const_iterator@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@2@0@Z PROC ; std::vector<Ogre::ShaderContextPool::TexParam,std::allocator<Ogre::ShaderContextPool::TexParam> >::erase, COMDAT
; _this$ = ecx

; 1028 : 		{	// erase [_First, _Last)

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	eax, DWORD PTR __First_arg$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __First_arg$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Make_iter@?$vector@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@2@V?$_Vector_const_iterator@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@2@@Z ; std::vector<Ogre::ShaderContextPool::TexParam,std::allocator<Ogre::ShaderContextPool::TexParam> >::_Make_iter

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);

	mov	eax, DWORD PTR __Last_arg$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __Last_arg$[ebp]
	push	ecx
	lea	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Make_iter@?$vector@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@2@V?$_Vector_const_iterator@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@2@@Z ; std::vector<Ogre::ShaderContextPool::TexParam,std::allocator<Ogre::ShaderContextPool::TexParam> >::_Make_iter

; 1031 : 
; 1032 : 		if (_First != _Last)

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	call	??9?$_Vector_const_iterator@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Ogre::ShaderContextPool::TexParam,std::allocator<Ogre::ShaderContextPool::TexParam> >::operator!=
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@erase@5

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	edx, DWORD PTR __First$[ebp+4]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp+4]
	push	edx
	call	??$unchecked_copy@PAUTexParam@ShaderContextPool@Ogre@@PAU123@@stdext@@YAPAUTexParam@ShaderContextPool@Ogre@@PAU123@00@Z ; stdext::unchecked_copy<Ogre::ShaderContextPool::TexParam *,Ogre::ShaderContextPool::TexParam *>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR __Ptr$77898[ebp], eax

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Ptr$77898[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@IAEXPAUTexParam@ShaderContextPool@Ogre@@0@Z ; std::vector<Ogre::ShaderContextPool::TexParam,std::allocator<Ogre::ShaderContextPool::TexParam> >::_Destroy

; 1049 : 			_Mylast = _Ptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Ptr$77898[ebp]
	mov	DWORD PTR [eax+16], ecx
$LN1@erase@5:

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);

	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR __First$[ebp+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1055 : #endif
; 1056 : 		}

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?erase@?$vector@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@2@V?$_Vector_const_iterator@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@2@0@Z ENDP ; std::vector<Ogre::ShaderContextPool::TexParam,std::allocator<Ogre::ShaderContextPool::TexParam> >::erase
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@KAXXZ$0
__ehfuncinfo$?_Xlen@?$vector@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@KAXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T96724 = -80						; size = 28
$T96723 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@KAXXZ PROC ; std::vector<Ogre::ShaderContextPool::TexParam,std::allocator<Ogre::ShaderContextPool::TexParam> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Xlen@?$vector@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T96724[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR $T96724[ebp]
	push	eax
	lea	ecx, DWORD PTR $T96723[ebp]
	call	??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::length_error::length_error
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T96723[ebp]
	push	ecx
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T96724[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN2@Xlen@10:

; 1261 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T96724[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?_Xlen@?$vector@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@KAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@KAXXZ ENDP ; std::vector<Ogre::ShaderContextPool::TexParam,std::allocator<Ogre::ShaderContextPool::TexParam> >::_Xlen
PUBLIC	??$?0UTexParam@ShaderContextPool@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@UTexParam@ShaderContextPool@Ogre@@@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::ShaderContextPool::TexParam>
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??0?$_Container_base_aux_alloc_real@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@IAE@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@IAE@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@1@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@IAE@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@1@@Z$1
__ehfuncinfo$??0?$_Container_base_aux_alloc_real@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@IAE@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0?$_Container_base_aux_alloc_real@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@IAE@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Container_base_aux_alloc_real@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@IAE@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@1@@Z
_TEXT	SEGMENT
tv133 = -32						; size = 4
_this$ = -28						; size = 4
$T96736 = -24						; size = 4
$T96735 = -20						; size = 4
$T96734 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 1
??0?$_Container_base_aux_alloc_real@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@IAE@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@1@@Z PROC ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::ShaderContextPool::TexParam> >::_Container_base_aux_alloc_real<std::allocator<Ogre::ShaderContextPool::TexParam> >, COMDAT
; _this$ = ecx

; 419  : 		{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Container_base_aux_alloc_real@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@IAE@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 20					; 00000014H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::_Container_base_aux
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??$?0UTexParam@ShaderContextPool@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@UTexParam@ShaderContextPool@Ogre@@@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::ShaderContextPool::TexParam>

; 420  : 		_Myownedaux = new (_Alaux.allocate(1)) _Aux_cont(this);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?allocate@?$allocator@V_Aux_cont@std@@@std@@QAEPAV_Aux_cont@2@I@Z ; std::allocator<std::_Aux_cont>::allocate
	mov	DWORD PTR $T96736[ebp], eax
	mov	ecx, DWORD PTR $T96736[ebp]
	push	ecx
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T96735[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	cmp	DWORD PTR $T96735[ebp], 0
	je	SHORT $LN3@Container_@10
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T96735[ebp]
	call	??0_Aux_cont@std@@QAE@QBV_Container_base_aux@1@@Z ; std::_Aux_cont::_Aux_cont
	mov	DWORD PTR tv133[ebp], eax
	jmp	SHORT $LN4@Container_@10
$LN3@Container_@10:
	mov	DWORD PTR tv133[ebp], 0
$LN4@Container_@10:
	mov	eax, DWORD PTR tv133[ebp]
	mov	DWORD PTR $T96734[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T96734[ebp]
	mov	DWORD PTR [ecx], edx

; 421  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@IAE@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@IAE@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@1@@Z$1:
	mov	eax, DWORD PTR $T96736[ebp]
	push	eax
	mov	ecx, DWORD PTR $T96735[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??0?$_Container_base_aux_alloc_real@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@IAE@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Container_base_aux_alloc_real@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@IAE@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Container_base_aux_alloc_real@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@IAE@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@1@@Z ENDP ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::ShaderContextPool::TexParam> >::_Container_base_aux_alloc_real<std::allocator<Ogre::ShaderContextPool::TexParam> >
PUBLIC	??$_Allocate@UTexParam@ShaderContextPool@Ogre@@@std@@YAPAUTexParam@ShaderContextPool@Ogre@@IPAU123@@Z ; std::_Allocate<Ogre::ShaderContextPool::TexParam>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@QAEPAUTexParam@ShaderContextPool@Ogre@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@QAEPAUTexParam@ShaderContextPool@Ogre@@I@Z PROC ; std::allocator<Ogre::ShaderContextPool::TexParam>::allocate, COMDAT
; _this$ = ecx

; 144  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@UTexParam@ShaderContextPool@Ogre@@@std@@YAPAUTexParam@ShaderContextPool@Ogre@@IPAU123@@Z ; std::_Allocate<Ogre::ShaderContextPool::TexParam>
	add	esp, 8

; 146  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@QAEPAUTexParam@ShaderContextPool@Ogre@@I@Z ENDP ; std::allocator<Ogre::ShaderContextPool::TexParam>::allocate
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@PAVMaterialParam@Ogre@@V?$allocator@PAVMaterialParam@Ogre@@@std@@@std@@QAE@PAPAVMaterialParam@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::MaterialParam *,std::allocator<Ogre::MaterialParam *> >::_Vector_iterator<Ogre::MaterialParam *,std::allocator<Ogre::MaterialParam *> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?begin@?$vector@PAVMaterialParam@Ogre@@V?$allocator@PAVMaterialParam@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVMaterialParam@Ogre@@V?$allocator@PAVMaterialParam@Ogre@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAVMaterialParam@Ogre@@V?$allocator@PAVMaterialParam@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVMaterialParam@Ogre@@V?$allocator@PAVMaterialParam@Ogre@@@std@@@2@XZ PROC ; std::vector<Ogre::MaterialParam *,std::allocator<Ogre::MaterialParam *> >::begin, COMDAT
; _this$ = ecx

; 640  : 		{	// return iterator for beginning of mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 641  : 		return (iterator(_Myfirst, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@PAVMaterialParam@Ogre@@V?$allocator@PAVMaterialParam@Ogre@@@std@@@std@@QAE@PAPAVMaterialParam@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::MaterialParam *,std::allocator<Ogre::MaterialParam *> >::_Vector_iterator<Ogre::MaterialParam *,std::allocator<Ogre::MaterialParam *> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 642  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?begin@?$vector@PAVMaterialParam@Ogre@@V?$allocator@PAVMaterialParam@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVMaterialParam@Ogre@@V?$allocator@PAVMaterialParam@Ogre@@@std@@@2@XZ ENDP ; std::vector<Ogre::MaterialParam *,std::allocator<Ogre::MaterialParam *> >::begin
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?end@?$vector@PAVMaterialParam@Ogre@@V?$allocator@PAVMaterialParam@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVMaterialParam@Ogre@@V?$allocator@PAVMaterialParam@Ogre@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAVMaterialParam@Ogre@@V?$allocator@PAVMaterialParam@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVMaterialParam@Ogre@@V?$allocator@PAVMaterialParam@Ogre@@@std@@@2@XZ PROC ; std::vector<Ogre::MaterialParam *,std::allocator<Ogre::MaterialParam *> >::end, COMDAT
; _this$ = ecx

; 650  : 		{	// return iterator for end of mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 651  : 		return (iterator(_Mylast, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@PAVMaterialParam@Ogre@@V?$allocator@PAVMaterialParam@Ogre@@@std@@@std@@QAE@PAPAVMaterialParam@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::MaterialParam *,std::allocator<Ogre::MaterialParam *> >::_Vector_iterator<Ogre::MaterialParam *,std::allocator<Ogre::MaterialParam *> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 652  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?end@?$vector@PAVMaterialParam@Ogre@@V?$allocator@PAVMaterialParam@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVMaterialParam@Ogre@@V?$allocator@PAVMaterialParam@Ogre@@@std@@@2@XZ ENDP ; std::vector<Ogre::MaterialParam *,std::allocator<Ogre::MaterialParam *> >::end
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@PAVMaterialParam@Ogre@@@std@@QBEIXZ ; std::allocator<Ogre::MaterialParam *>::max_size
; Function compile flags: /Odtp
;	COMDAT ?max_size@?$vector@PAVMaterialParam@Ogre@@V?$allocator@PAVMaterialParam@Ogre@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$vector@PAVMaterialParam@Ogre@@V?$allocator@PAVMaterialParam@Ogre@@@std@@@std@@QBEIXZ PROC ; std::vector<Ogre::MaterialParam *,std::allocator<Ogre::MaterialParam *> >::max_size, COMDAT
; _this$ = ecx

; 730  : 		{	// return maximum possible length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 731  : 		return (this->_Alval.max_size());

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?max_size@?$allocator@PAVMaterialParam@Ogre@@@std@@QBEIXZ ; std::allocator<Ogre::MaterialParam *>::max_size

; 732  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$vector@PAVMaterialParam@Ogre@@V?$allocator@PAVMaterialParam@Ogre@@@std@@@std@@QBEIXZ ENDP ; std::vector<Ogre::MaterialParam *,std::allocator<Ogre::MaterialParam *> >::max_size
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@PAVMaterialParam@Ogre@@V?$allocator@PAVMaterialParam@Ogre@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Ogre::MaterialParam *,std::allocator<Ogre::MaterialParam *> >::operator!=
PUBLIC	?_Make_iter@?$vector@PAVMaterialParam@Ogre@@V?$allocator@PAVMaterialParam@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVMaterialParam@Ogre@@V?$allocator@PAVMaterialParam@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVMaterialParam@Ogre@@V?$allocator@PAVMaterialParam@Ogre@@@std@@@2@@Z ; std::vector<Ogre::MaterialParam *,std::allocator<Ogre::MaterialParam *> >::_Make_iter
; Function compile flags: /Odtp
;	COMDAT ?erase@?$vector@PAVMaterialParam@Ogre@@V?$allocator@PAVMaterialParam@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVMaterialParam@Ogre@@V?$allocator@PAVMaterialParam@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVMaterialParam@Ogre@@V?$allocator@PAVMaterialParam@Ogre@@@std@@@2@0@Z
_TEXT	SEGMENT
_this$ = -24						; size = 4
__Ptr$77942 = -20					; size = 4
__Last$ = -16						; size = 8
__First$ = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 8
__Last_arg$ = 20					; size = 8
?erase@?$vector@PAVMaterialParam@Ogre@@V?$allocator@PAVMaterialParam@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVMaterialParam@Ogre@@V?$allocator@PAVMaterialParam@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVMaterialParam@Ogre@@V?$allocator@PAVMaterialParam@Ogre@@@std@@@2@0@Z PROC ; std::vector<Ogre::MaterialParam *,std::allocator<Ogre::MaterialParam *> >::erase, COMDAT
; _this$ = ecx

; 1028 : 		{	// erase [_First, _Last)

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	eax, DWORD PTR __First_arg$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __First_arg$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Make_iter@?$vector@PAVMaterialParam@Ogre@@V?$allocator@PAVMaterialParam@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVMaterialParam@Ogre@@V?$allocator@PAVMaterialParam@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVMaterialParam@Ogre@@V?$allocator@PAVMaterialParam@Ogre@@@std@@@2@@Z ; std::vector<Ogre::MaterialParam *,std::allocator<Ogre::MaterialParam *> >::_Make_iter

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);

	mov	eax, DWORD PTR __Last_arg$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __Last_arg$[ebp]
	push	ecx
	lea	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Make_iter@?$vector@PAVMaterialParam@Ogre@@V?$allocator@PAVMaterialParam@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVMaterialParam@Ogre@@V?$allocator@PAVMaterialParam@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVMaterialParam@Ogre@@V?$allocator@PAVMaterialParam@Ogre@@@std@@@2@@Z ; std::vector<Ogre::MaterialParam *,std::allocator<Ogre::MaterialParam *> >::_Make_iter

; 1031 : 
; 1032 : 		if (_First != _Last)

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	call	??9?$_Vector_const_iterator@PAVMaterialParam@Ogre@@V?$allocator@PAVMaterialParam@Ogre@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Ogre::MaterialParam *,std::allocator<Ogre::MaterialParam *> >::operator!=
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@erase@6

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	edx, DWORD PTR __First$[ebp+4]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp+4]
	push	edx
	call	??$unchecked_copy@PAPAVMaterialParam@Ogre@@PAPAV12@@stdext@@YAPAPAVMaterialParam@Ogre@@PAPAV12@00@Z ; stdext::unchecked_copy<Ogre::MaterialParam * *,Ogre::MaterialParam * *>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR __Ptr$77942[ebp], eax

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Ptr$77942[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@PAVMaterialParam@Ogre@@V?$allocator@PAVMaterialParam@Ogre@@@std@@@std@@IAEXPAPAVMaterialParam@Ogre@@0@Z ; std::vector<Ogre::MaterialParam *,std::allocator<Ogre::MaterialParam *> >::_Destroy

; 1049 : 			_Mylast = _Ptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Ptr$77942[ebp]
	mov	DWORD PTR [eax+16], ecx
$LN1@erase@6:

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);

	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR __First$[ebp+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1055 : #endif
; 1056 : 		}

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?erase@?$vector@PAVMaterialParam@Ogre@@V?$allocator@PAVMaterialParam@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVMaterialParam@Ogre@@V?$allocator@PAVMaterialParam@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVMaterialParam@Ogre@@V?$allocator@PAVMaterialParam@Ogre@@@std@@@2@0@Z ENDP ; std::vector<Ogre::MaterialParam *,std::allocator<Ogre::MaterialParam *> >::erase
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@PAVMaterialParam@Ogre@@V?$allocator@PAVMaterialParam@Ogre@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@PAVMaterialParam@Ogre@@V?$allocator@PAVMaterialParam@Ogre@@@std@@@std@@KAXXZ$0
__ehfuncinfo$?_Xlen@?$vector@PAVMaterialParam@Ogre@@V?$allocator@PAVMaterialParam@Ogre@@@std@@@std@@KAXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@PAVMaterialParam@Ogre@@V?$allocator@PAVMaterialParam@Ogre@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@PAVMaterialParam@Ogre@@V?$allocator@PAVMaterialParam@Ogre@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T96760 = -80						; size = 28
$T96759 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@PAVMaterialParam@Ogre@@V?$allocator@PAVMaterialParam@Ogre@@@std@@@std@@KAXXZ PROC ; std::vector<Ogre::MaterialParam *,std::allocator<Ogre::MaterialParam *> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Xlen@?$vector@PAVMaterialParam@Ogre@@V?$allocator@PAVMaterialParam@Ogre@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T96760[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR $T96760[ebp]
	push	eax
	lea	ecx, DWORD PTR $T96759[ebp]
	call	??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::length_error::length_error
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T96759[ebp]
	push	ecx
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T96760[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN2@Xlen@11:

; 1261 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@PAVMaterialParam@Ogre@@V?$allocator@PAVMaterialParam@Ogre@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T96760[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?_Xlen@?$vector@PAVMaterialParam@Ogre@@V?$allocator@PAVMaterialParam@Ogre@@@std@@@std@@KAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@PAVMaterialParam@Ogre@@V?$allocator@PAVMaterialParam@Ogre@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@PAVMaterialParam@Ogre@@V?$allocator@PAVMaterialParam@Ogre@@@std@@@std@@KAXXZ ENDP ; std::vector<Ogre::MaterialParam *,std::allocator<Ogre::MaterialParam *> >::_Xlen
PUBLIC	??$_Allocate@PAVMaterialParam@Ogre@@@std@@YAPAPAVMaterialParam@Ogre@@IPAPAV12@@Z ; std::_Allocate<Ogre::MaterialParam *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@PAVMaterialParam@Ogre@@@std@@QAEPAPAVMaterialParam@Ogre@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@PAVMaterialParam@Ogre@@@std@@QAEPAPAVMaterialParam@Ogre@@I@Z PROC ; std::allocator<Ogre::MaterialParam *>::allocate, COMDAT
; _this$ = ecx

; 144  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@PAVMaterialParam@Ogre@@@std@@YAPAPAVMaterialParam@Ogre@@IPAPAV12@@Z ; std::_Allocate<Ogre::MaterialParam *>
	add	esp, 8

; 146  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@PAVMaterialParam@Ogre@@@std@@QAEPAPAVMaterialParam@Ogre@@I@Z ENDP ; std::allocator<Ogre::MaterialParam *>::allocate
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@DV?$allocator@D@std@@@std@@QAE@PADPBV_Container_base_aux@1@@Z ; std::_Vector_iterator<char,std::allocator<char> >::_Vector_iterator<char,std::allocator<char> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?begin@?$vector@DV?$allocator@D@std@@@std@@QAE?AV?$_Vector_iterator@DV?$allocator@D@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@DV?$allocator@D@std@@@std@@QAE?AV?$_Vector_iterator@DV?$allocator@D@std@@@2@XZ PROC ; std::vector<char,std::allocator<char> >::begin, COMDAT
; _this$ = ecx

; 640  : 		{	// return iterator for beginning of mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 641  : 		return (iterator(_Myfirst, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@DV?$allocator@D@std@@@std@@QAE@PADPBV_Container_base_aux@1@@Z ; std::_Vector_iterator<char,std::allocator<char> >::_Vector_iterator<char,std::allocator<char> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 642  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?begin@?$vector@DV?$allocator@D@std@@@std@@QAE?AV?$_Vector_iterator@DV?$allocator@D@std@@@2@XZ ENDP ; std::vector<char,std::allocator<char> >::begin
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?end@?$vector@DV?$allocator@D@std@@@std@@QAE?AV?$_Vector_iterator@DV?$allocator@D@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@DV?$allocator@D@std@@@std@@QAE?AV?$_Vector_iterator@DV?$allocator@D@std@@@2@XZ PROC ; std::vector<char,std::allocator<char> >::end, COMDAT
; _this$ = ecx

; 650  : 		{	// return iterator for end of mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 651  : 		return (iterator(_Mylast, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@DV?$allocator@D@std@@@std@@QAE@PADPBV_Container_base_aux@1@@Z ; std::_Vector_iterator<char,std::allocator<char> >::_Vector_iterator<char,std::allocator<char> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 652  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?end@?$vector@DV?$allocator@D@std@@@std@@QAE?AV?$_Vector_iterator@DV?$allocator@D@std@@@2@XZ ENDP ; std::vector<char,std::allocator<char> >::end
_TEXT	ENDS
EXTRN	__imp_?max_size@?$allocator@D@std@@QBEIXZ:PROC
; Function compile flags: /Odtp
;	COMDAT ?max_size@?$vector@DV?$allocator@D@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$vector@DV?$allocator@D@std@@@std@@QBEIXZ PROC ; std::vector<char,std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 730  : 		{	// return maximum possible length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 731  : 		return (this->_Alval.max_size());

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	DWORD PTR __imp_?max_size@?$allocator@D@std@@QBEIXZ

; 732  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$vector@DV?$allocator@D@std@@@std@@QBEIXZ ENDP ; std::vector<char,std::allocator<char> >::max_size
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@DV?$allocator@D@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<char,std::allocator<char> >::operator!=
PUBLIC	?_Make_iter@?$vector@DV?$allocator@D@std@@@std@@QBE?AV?$_Vector_iterator@DV?$allocator@D@std@@@2@V?$_Vector_const_iterator@DV?$allocator@D@std@@@2@@Z ; std::vector<char,std::allocator<char> >::_Make_iter
; Function compile flags: /Odtp
;	COMDAT ?erase@?$vector@DV?$allocator@D@std@@@std@@QAE?AV?$_Vector_iterator@DV?$allocator@D@std@@@2@V?$_Vector_const_iterator@DV?$allocator@D@std@@@2@0@Z
_TEXT	SEGMENT
_this$ = -24						; size = 4
__Ptr$77973 = -20					; size = 4
__Last$ = -16						; size = 8
__First$ = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 8
__Last_arg$ = 20					; size = 8
?erase@?$vector@DV?$allocator@D@std@@@std@@QAE?AV?$_Vector_iterator@DV?$allocator@D@std@@@2@V?$_Vector_const_iterator@DV?$allocator@D@std@@@2@0@Z PROC ; std::vector<char,std::allocator<char> >::erase, COMDAT
; _this$ = ecx

; 1028 : 		{	// erase [_First, _Last)

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	eax, DWORD PTR __First_arg$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __First_arg$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Make_iter@?$vector@DV?$allocator@D@std@@@std@@QBE?AV?$_Vector_iterator@DV?$allocator@D@std@@@2@V?$_Vector_const_iterator@DV?$allocator@D@std@@@2@@Z ; std::vector<char,std::allocator<char> >::_Make_iter

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);

	mov	eax, DWORD PTR __Last_arg$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __Last_arg$[ebp]
	push	ecx
	lea	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Make_iter@?$vector@DV?$allocator@D@std@@@std@@QBE?AV?$_Vector_iterator@DV?$allocator@D@std@@@2@V?$_Vector_const_iterator@DV?$allocator@D@std@@@2@@Z ; std::vector<char,std::allocator<char> >::_Make_iter

; 1031 : 
; 1032 : 		if (_First != _Last)

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	call	??9?$_Vector_const_iterator@DV?$allocator@D@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<char,std::allocator<char> >::operator!=
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@erase@7

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	edx, DWORD PTR __First$[ebp+4]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp+4]
	push	edx
	call	??$unchecked_copy@PADPAD@stdext@@YAPADPAD00@Z ; stdext::unchecked_copy<char *,char *>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR __Ptr$77973[ebp], eax

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Ptr$77973[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@DV?$allocator@D@std@@@std@@IAEXPAD0@Z ; std::vector<char,std::allocator<char> >::_Destroy

; 1049 : 			_Mylast = _Ptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Ptr$77973[ebp]
	mov	DWORD PTR [eax+16], ecx
$LN1@erase@7:

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);

	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR __First$[ebp+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1055 : #endif
; 1056 : 		}

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?erase@?$vector@DV?$allocator@D@std@@@std@@QAE?AV?$_Vector_iterator@DV?$allocator@D@std@@@2@V?$_Vector_const_iterator@DV?$allocator@D@std@@@2@0@Z ENDP ; std::vector<char,std::allocator<char> >::erase
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@DV?$allocator@D@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@DV?$allocator@D@std@@@std@@KAXXZ$0
__ehfuncinfo$?_Xlen@?$vector@DV?$allocator@D@std@@@std@@KAXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@DV?$allocator@D@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@DV?$allocator@D@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T96781 = -80						; size = 28
$T96780 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@DV?$allocator@D@std@@@std@@KAXXZ PROC	; std::vector<char,std::allocator<char> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Xlen@?$vector@DV?$allocator@D@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T96781[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR $T96781[ebp]
	push	eax
	lea	ecx, DWORD PTR $T96780[ebp]
	call	??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::length_error::length_error
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T96780[ebp]
	push	ecx
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T96781[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN2@Xlen@12:

; 1261 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@DV?$allocator@D@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T96781[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?_Xlen@?$vector@DV?$allocator@D@std@@@std@@KAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@DV?$allocator@D@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@DV?$allocator@D@std@@@std@@KAXXZ ENDP	; std::vector<char,std::allocator<char> >::_Xlen
PUBLIC	??$?0D@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><char>
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??0?$_Container_base_aux_alloc_real@V?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z$1
__ehfuncinfo$??0?$_Container_base_aux_alloc_real@V?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0?$_Container_base_aux_alloc_real@V?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Container_base_aux_alloc_real@V?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z
_TEXT	SEGMENT
tv133 = -32						; size = 4
_this$ = -28						; size = 4
$T96793 = -24						; size = 4
$T96792 = -20						; size = 4
$T96791 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 1
??0?$_Container_base_aux_alloc_real@V?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z PROC ; std::_Container_base_aux_alloc_real<std::allocator<char> >::_Container_base_aux_alloc_real<std::allocator<char> >, COMDAT
; _this$ = ecx

; 419  : 		{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Container_base_aux_alloc_real@V?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 20					; 00000014H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::_Container_base_aux
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??$?0D@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><char>

; 420  : 		_Myownedaux = new (_Alaux.allocate(1)) _Aux_cont(this);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?allocate@?$allocator@V_Aux_cont@std@@@std@@QAEPAV_Aux_cont@2@I@Z ; std::allocator<std::_Aux_cont>::allocate
	mov	DWORD PTR $T96793[ebp], eax
	mov	ecx, DWORD PTR $T96793[ebp]
	push	ecx
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T96792[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	cmp	DWORD PTR $T96792[ebp], 0
	je	SHORT $LN3@Container_@11
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T96792[ebp]
	call	??0_Aux_cont@std@@QAE@QBV_Container_base_aux@1@@Z ; std::_Aux_cont::_Aux_cont
	mov	DWORD PTR tv133[ebp], eax
	jmp	SHORT $LN4@Container_@11
$LN3@Container_@11:
	mov	DWORD PTR tv133[ebp], 0
$LN4@Container_@11:
	mov	eax, DWORD PTR tv133[ebp]
	mov	DWORD PTR $T96791[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T96791[ebp]
	mov	DWORD PTR [ecx], edx

; 421  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z$1:
	mov	eax, DWORD PTR $T96793[ebp]
	push	eax
	mov	ecx, DWORD PTR $T96792[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??0?$_Container_base_aux_alloc_real@V?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Container_base_aux_alloc_real@V?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Container_base_aux_alloc_real@V?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z ENDP ; std::_Container_base_aux_alloc_real<std::allocator<char> >::_Container_base_aux_alloc_real<std::allocator<char> >
PUBLIC	??0?$_Vector_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE@PAPAVSurfaceData@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::_Vector_iterator<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?begin@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@2@XZ PROC ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::begin, COMDAT
; _this$ = ecx

; 640  : 		{	// return iterator for beginning of mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 641  : 		return (iterator(_Myfirst, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE@PAPAVSurfaceData@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::_Vector_iterator<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 642  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?begin@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@2@XZ ENDP ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::begin
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?end@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@2@XZ PROC ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::end, COMDAT
; _this$ = ecx

; 650  : 		{	// return iterator for end of mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 651  : 		return (iterator(_Mylast, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE@PAPAVSurfaceData@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::_Vector_iterator<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 652  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?end@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@2@XZ ENDP ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::end
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@PAVSurfaceData@Ogre@@@std@@QBEIXZ ; std::allocator<Ogre::SurfaceData *>::max_size
; Function compile flags: /Odtp
;	COMDAT ?max_size@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QBEIXZ PROC ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::max_size, COMDAT
; _this$ = ecx

; 730  : 		{	// return maximum possible length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 731  : 		return (this->_Alval.max_size());

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?max_size@?$allocator@PAVSurfaceData@Ogre@@@std@@QBEIXZ ; std::allocator<Ogre::SurfaceData *>::max_size

; 732  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QBEIXZ ENDP ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::max_size
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::operator!=
PUBLIC	?_Make_iter@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@2@@Z ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::_Make_iter
; Function compile flags: /Odtp
;	COMDAT ?erase@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@2@0@Z
_TEXT	SEGMENT
_this$ = -24						; size = 4
__Ptr$78009 = -20					; size = 4
__Last$ = -16						; size = 8
__First$ = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 8
__Last_arg$ = 20					; size = 8
?erase@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@2@0@Z PROC ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::erase, COMDAT
; _this$ = ecx

; 1028 : 		{	// erase [_First, _Last)

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	eax, DWORD PTR __First_arg$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __First_arg$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Make_iter@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@2@@Z ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::_Make_iter

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);

	mov	eax, DWORD PTR __Last_arg$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __Last_arg$[ebp]
	push	ecx
	lea	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Make_iter@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@2@@Z ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::_Make_iter

; 1031 : 
; 1032 : 		if (_First != _Last)

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	call	??9?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::operator!=
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@erase@8

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	edx, DWORD PTR __First$[ebp+4]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp+4]
	push	edx
	call	??$unchecked_copy@PAPAVSurfaceData@Ogre@@PAPAV12@@stdext@@YAPAPAVSurfaceData@Ogre@@PAPAV12@00@Z ; stdext::unchecked_copy<Ogre::SurfaceData * *,Ogre::SurfaceData * *>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR __Ptr$78009[ebp], eax

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Ptr$78009[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAEXPAPAVSurfaceData@Ogre@@0@Z ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::_Destroy

; 1049 : 			_Mylast = _Ptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Ptr$78009[ebp]
	mov	DWORD PTR [eax+16], ecx
$LN1@erase@8:

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);

	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR __First$[ebp+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1055 : #endif
; 1056 : 		}

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?erase@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@2@0@Z ENDP ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::erase
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@KAXXZ$0
__ehfuncinfo$?_Xlen@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@KAXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T96815 = -80						; size = 28
$T96814 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@KAXXZ PROC ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Xlen@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T96815[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR $T96815[ebp]
	push	eax
	lea	ecx, DWORD PTR $T96814[ebp]
	call	??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::length_error::length_error
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T96814[ebp]
	push	ecx
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T96815[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN2@Xlen@13:

; 1261 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T96815[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?_Xlen@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@KAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@KAXXZ ENDP ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::_Xlen
PUBLIC	??$?0PAVSurfaceData@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@PAVSurfaceData@Ogre@@@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::SurfaceData *>
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAE@V?$allocator@PAVSurfaceData@Ogre@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAE@V?$allocator@PAVSurfaceData@Ogre@@@1@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAE@V?$allocator@PAVSurfaceData@Ogre@@@1@@Z$1
__ehfuncinfo$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAE@V?$allocator@PAVSurfaceData@Ogre@@@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAE@V?$allocator@PAVSurfaceData@Ogre@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Container_base_aux_alloc_real@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAE@V?$allocator@PAVSurfaceData@Ogre@@@1@@Z
_TEXT	SEGMENT
tv133 = -32						; size = 4
_this$ = -28						; size = 4
$T96827 = -24						; size = 4
$T96826 = -20						; size = 4
$T96825 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 1
??0?$_Container_base_aux_alloc_real@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAE@V?$allocator@PAVSurfaceData@Ogre@@@1@@Z PROC ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::SurfaceData *> >::_Container_base_aux_alloc_real<std::allocator<Ogre::SurfaceData *> >, COMDAT
; _this$ = ecx

; 419  : 		{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAE@V?$allocator@PAVSurfaceData@Ogre@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 20					; 00000014H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::_Container_base_aux
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??$?0PAVSurfaceData@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@PAVSurfaceData@Ogre@@@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::SurfaceData *>

; 420  : 		_Myownedaux = new (_Alaux.allocate(1)) _Aux_cont(this);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?allocate@?$allocator@V_Aux_cont@std@@@std@@QAEPAV_Aux_cont@2@I@Z ; std::allocator<std::_Aux_cont>::allocate
	mov	DWORD PTR $T96827[ebp], eax
	mov	ecx, DWORD PTR $T96827[ebp]
	push	ecx
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T96826[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	cmp	DWORD PTR $T96826[ebp], 0
	je	SHORT $LN3@Container_@12
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T96826[ebp]
	call	??0_Aux_cont@std@@QAE@QBV_Container_base_aux@1@@Z ; std::_Aux_cont::_Aux_cont
	mov	DWORD PTR tv133[ebp], eax
	jmp	SHORT $LN4@Container_@12
$LN3@Container_@12:
	mov	DWORD PTR tv133[ebp], 0
$LN4@Container_@12:
	mov	eax, DWORD PTR tv133[ebp]
	mov	DWORD PTR $T96825[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T96825[ebp]
	mov	DWORD PTR [ecx], edx

; 421  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAE@V?$allocator@PAVSurfaceData@Ogre@@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAE@V?$allocator@PAVSurfaceData@Ogre@@@1@@Z$1:
	mov	eax, DWORD PTR $T96827[ebp]
	push	eax
	mov	ecx, DWORD PTR $T96826[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAE@V?$allocator@PAVSurfaceData@Ogre@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAE@V?$allocator@PAVSurfaceData@Ogre@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Container_base_aux_alloc_real@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAE@V?$allocator@PAVSurfaceData@Ogre@@@1@@Z ENDP ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::SurfaceData *> >::_Container_base_aux_alloc_real<std::allocator<Ogre::SurfaceData *> >
PUBLIC	??$_Allocate@PAVSurfaceData@Ogre@@@std@@YAPAPAVSurfaceData@Ogre@@IPAPAV12@@Z ; std::_Allocate<Ogre::SurfaceData *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@PAVSurfaceData@Ogre@@@std@@QAEPAPAVSurfaceData@Ogre@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@PAVSurfaceData@Ogre@@@std@@QAEPAPAVSurfaceData@Ogre@@I@Z PROC ; std::allocator<Ogre::SurfaceData *>::allocate, COMDAT
; _this$ = ecx

; 144  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@PAVSurfaceData@Ogre@@@std@@YAPAPAVSurfaceData@Ogre@@IPAPAV12@@Z ; std::_Allocate<Ogre::SurfaceData *>
	add	esp, 8

; 146  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@PAVSurfaceData@Ogre@@@std@@QAEPAPAVSurfaceData@Ogre@@I@Z ENDP ; std::allocator<Ogre::SurfaceData *>::allocate
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@GV?$allocator@G@std@@@std@@QAE@PAGPBV_Container_base_aux@1@@Z ; std::_Vector_iterator<unsigned short,std::allocator<unsigned short> >::_Vector_iterator<unsigned short,std::allocator<unsigned short> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?begin@?$vector@GV?$allocator@G@std@@@std@@QAE?AV?$_Vector_iterator@GV?$allocator@G@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@GV?$allocator@G@std@@@std@@QAE?AV?$_Vector_iterator@GV?$allocator@G@std@@@2@XZ PROC ; std::vector<unsigned short,std::allocator<unsigned short> >::begin, COMDAT
; _this$ = ecx

; 640  : 		{	// return iterator for beginning of mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 641  : 		return (iterator(_Myfirst, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@GV?$allocator@G@std@@@std@@QAE@PAGPBV_Container_base_aux@1@@Z ; std::_Vector_iterator<unsigned short,std::allocator<unsigned short> >::_Vector_iterator<unsigned short,std::allocator<unsigned short> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 642  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?begin@?$vector@GV?$allocator@G@std@@@std@@QAE?AV?$_Vector_iterator@GV?$allocator@G@std@@@2@XZ ENDP ; std::vector<unsigned short,std::allocator<unsigned short> >::begin
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?end@?$vector@GV?$allocator@G@std@@@std@@QAE?AV?$_Vector_iterator@GV?$allocator@G@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@GV?$allocator@G@std@@@std@@QAE?AV?$_Vector_iterator@GV?$allocator@G@std@@@2@XZ PROC ; std::vector<unsigned short,std::allocator<unsigned short> >::end, COMDAT
; _this$ = ecx

; 650  : 		{	// return iterator for end of mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 651  : 		return (iterator(_Mylast, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@GV?$allocator@G@std@@@std@@QAE@PAGPBV_Container_base_aux@1@@Z ; std::_Vector_iterator<unsigned short,std::allocator<unsigned short> >::_Vector_iterator<unsigned short,std::allocator<unsigned short> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 652  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?end@?$vector@GV?$allocator@G@std@@@std@@QAE?AV?$_Vector_iterator@GV?$allocator@G@std@@@2@XZ ENDP ; std::vector<unsigned short,std::allocator<unsigned short> >::end
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@G@std@@QBEIXZ		; std::allocator<unsigned short>::max_size
; Function compile flags: /Odtp
;	COMDAT ?max_size@?$vector@GV?$allocator@G@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$vector@GV?$allocator@G@std@@@std@@QBEIXZ PROC ; std::vector<unsigned short,std::allocator<unsigned short> >::max_size, COMDAT
; _this$ = ecx

; 730  : 		{	// return maximum possible length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 731  : 		return (this->_Alval.max_size());

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?max_size@?$allocator@G@std@@QBEIXZ	; std::allocator<unsigned short>::max_size

; 732  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$vector@GV?$allocator@G@std@@@std@@QBEIXZ ENDP ; std::vector<unsigned short,std::allocator<unsigned short> >::max_size
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@GV?$allocator@G@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<unsigned short,std::allocator<unsigned short> >::operator!=
PUBLIC	?_Make_iter@?$vector@GV?$allocator@G@std@@@std@@QBE?AV?$_Vector_iterator@GV?$allocator@G@std@@@2@V?$_Vector_const_iterator@GV?$allocator@G@std@@@2@@Z ; std::vector<unsigned short,std::allocator<unsigned short> >::_Make_iter
; Function compile flags: /Odtp
;	COMDAT ?erase@?$vector@GV?$allocator@G@std@@@std@@QAE?AV?$_Vector_iterator@GV?$allocator@G@std@@@2@V?$_Vector_const_iterator@GV?$allocator@G@std@@@2@0@Z
_TEXT	SEGMENT
_this$ = -24						; size = 4
__Ptr$78053 = -20					; size = 4
__Last$ = -16						; size = 8
__First$ = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 8
__Last_arg$ = 20					; size = 8
?erase@?$vector@GV?$allocator@G@std@@@std@@QAE?AV?$_Vector_iterator@GV?$allocator@G@std@@@2@V?$_Vector_const_iterator@GV?$allocator@G@std@@@2@0@Z PROC ; std::vector<unsigned short,std::allocator<unsigned short> >::erase, COMDAT
; _this$ = ecx

; 1028 : 		{	// erase [_First, _Last)

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	eax, DWORD PTR __First_arg$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __First_arg$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Make_iter@?$vector@GV?$allocator@G@std@@@std@@QBE?AV?$_Vector_iterator@GV?$allocator@G@std@@@2@V?$_Vector_const_iterator@GV?$allocator@G@std@@@2@@Z ; std::vector<unsigned short,std::allocator<unsigned short> >::_Make_iter

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);

	mov	eax, DWORD PTR __Last_arg$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __Last_arg$[ebp]
	push	ecx
	lea	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Make_iter@?$vector@GV?$allocator@G@std@@@std@@QBE?AV?$_Vector_iterator@GV?$allocator@G@std@@@2@V?$_Vector_const_iterator@GV?$allocator@G@std@@@2@@Z ; std::vector<unsigned short,std::allocator<unsigned short> >::_Make_iter

; 1031 : 
; 1032 : 		if (_First != _Last)

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	call	??9?$_Vector_const_iterator@GV?$allocator@G@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<unsigned short,std::allocator<unsigned short> >::operator!=
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@erase@9

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	edx, DWORD PTR __First$[ebp+4]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp+4]
	push	edx
	call	??$unchecked_copy@PAGPAG@stdext@@YAPAGPAG00@Z ; stdext::unchecked_copy<unsigned short *,unsigned short *>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR __Ptr$78053[ebp], eax

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Ptr$78053[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@GV?$allocator@G@std@@@std@@IAEXPAG0@Z ; std::vector<unsigned short,std::allocator<unsigned short> >::_Destroy

; 1049 : 			_Mylast = _Ptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Ptr$78053[ebp]
	mov	DWORD PTR [eax+16], ecx
$LN1@erase@9:

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);

	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR __First$[ebp+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1055 : #endif
; 1056 : 		}

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?erase@?$vector@GV?$allocator@G@std@@@std@@QAE?AV?$_Vector_iterator@GV?$allocator@G@std@@@2@V?$_Vector_const_iterator@GV?$allocator@G@std@@@2@0@Z ENDP ; std::vector<unsigned short,std::allocator<unsigned short> >::erase
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@GV?$allocator@G@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@GV?$allocator@G@std@@@std@@KAXXZ$0
__ehfuncinfo$?_Xlen@?$vector@GV?$allocator@G@std@@@std@@KAXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@GV?$allocator@G@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@GV?$allocator@G@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T96851 = -80						; size = 28
$T96850 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@GV?$allocator@G@std@@@std@@KAXXZ PROC	; std::vector<unsigned short,std::allocator<unsigned short> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Xlen@?$vector@GV?$allocator@G@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T96851[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR $T96851[ebp]
	push	eax
	lea	ecx, DWORD PTR $T96850[ebp]
	call	??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::length_error::length_error
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T96850[ebp]
	push	ecx
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T96851[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN2@Xlen@14:

; 1261 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@GV?$allocator@G@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T96851[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?_Xlen@?$vector@GV?$allocator@G@std@@@std@@KAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@GV?$allocator@G@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@GV?$allocator@G@std@@@std@@KAXXZ ENDP	; std::vector<unsigned short,std::allocator<unsigned short> >::_Xlen
PUBLIC	??$_Allocate@G@std@@YAPAGIPAG@Z			; std::_Allocate<unsigned short>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@G@std@@QAEPAGI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@G@std@@QAEPAGI@Z PROC		; std::allocator<unsigned short>::allocate, COMDAT
; _this$ = ecx

; 144  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@G@std@@YAPAGIPAG@Z		; std::_Allocate<unsigned short>
	add	esp, 8

; 146  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@G@std@@QAEPAGI@Z ENDP		; std::allocator<unsigned short>::allocate
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@QAE@PAURecord@CullResult@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::CullResult::Record,std::allocator<Ogre::CullResult::Record> >::_Vector_iterator<Ogre::CullResult::Record,std::allocator<Ogre::CullResult::Record> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?begin@?$vector@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@2@XZ PROC ; std::vector<Ogre::CullResult::Record,std::allocator<Ogre::CullResult::Record> >::begin, COMDAT
; _this$ = ecx

; 640  : 		{	// return iterator for beginning of mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 641  : 		return (iterator(_Myfirst, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@QAE@PAURecord@CullResult@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::CullResult::Record,std::allocator<Ogre::CullResult::Record> >::_Vector_iterator<Ogre::CullResult::Record,std::allocator<Ogre::CullResult::Record> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 642  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?begin@?$vector@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@2@XZ ENDP ; std::vector<Ogre::CullResult::Record,std::allocator<Ogre::CullResult::Record> >::begin
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?end@?$vector@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@2@XZ PROC ; std::vector<Ogre::CullResult::Record,std::allocator<Ogre::CullResult::Record> >::end, COMDAT
; _this$ = ecx

; 650  : 		{	// return iterator for end of mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 651  : 		return (iterator(_Mylast, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@QAE@PAURecord@CullResult@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::CullResult::Record,std::allocator<Ogre::CullResult::Record> >::_Vector_iterator<Ogre::CullResult::Record,std::allocator<Ogre::CullResult::Record> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 652  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?end@?$vector@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@2@XZ ENDP ; std::vector<Ogre::CullResult::Record,std::allocator<Ogre::CullResult::Record> >::end
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@URecord@CullResult@Ogre@@@std@@QBEIXZ ; std::allocator<Ogre::CullResult::Record>::max_size
; Function compile flags: /Odtp
;	COMDAT ?max_size@?$vector@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$vector@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@QBEIXZ PROC ; std::vector<Ogre::CullResult::Record,std::allocator<Ogre::CullResult::Record> >::max_size, COMDAT
; _this$ = ecx

; 730  : 		{	// return maximum possible length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 731  : 		return (this->_Alval.max_size());

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?max_size@?$allocator@URecord@CullResult@Ogre@@@std@@QBEIXZ ; std::allocator<Ogre::CullResult::Record>::max_size

; 732  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$vector@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@QBEIXZ ENDP ; std::vector<Ogre::CullResult::Record,std::allocator<Ogre::CullResult::Record> >::max_size
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Ogre::CullResult::Record,std::allocator<Ogre::CullResult::Record> >::operator!=
PUBLIC	?_Make_iter@?$vector@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@2@V?$_Vector_const_iterator@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@2@@Z ; std::vector<Ogre::CullResult::Record,std::allocator<Ogre::CullResult::Record> >::_Make_iter
; Function compile flags: /Odtp
;	COMDAT ?erase@?$vector@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@2@V?$_Vector_const_iterator@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@2@0@Z
_TEXT	SEGMENT
_this$ = -24						; size = 4
__Ptr$78084 = -20					; size = 4
__Last$ = -16						; size = 8
__First$ = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 8
__Last_arg$ = 20					; size = 8
?erase@?$vector@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@2@V?$_Vector_const_iterator@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@2@0@Z PROC ; std::vector<Ogre::CullResult::Record,std::allocator<Ogre::CullResult::Record> >::erase, COMDAT
; _this$ = ecx

; 1028 : 		{	// erase [_First, _Last)

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	eax, DWORD PTR __First_arg$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __First_arg$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Make_iter@?$vector@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@2@V?$_Vector_const_iterator@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@2@@Z ; std::vector<Ogre::CullResult::Record,std::allocator<Ogre::CullResult::Record> >::_Make_iter

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);

	mov	eax, DWORD PTR __Last_arg$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __Last_arg$[ebp]
	push	ecx
	lea	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Make_iter@?$vector@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@2@V?$_Vector_const_iterator@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@2@@Z ; std::vector<Ogre::CullResult::Record,std::allocator<Ogre::CullResult::Record> >::_Make_iter

; 1031 : 
; 1032 : 		if (_First != _Last)

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	call	??9?$_Vector_const_iterator@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Ogre::CullResult::Record,std::allocator<Ogre::CullResult::Record> >::operator!=
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@erase@10

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	edx, DWORD PTR __First$[ebp+4]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp+4]
	push	edx
	call	??$unchecked_copy@PAURecord@CullResult@Ogre@@PAU123@@stdext@@YAPAURecord@CullResult@Ogre@@PAU123@00@Z ; stdext::unchecked_copy<Ogre::CullResult::Record *,Ogre::CullResult::Record *>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR __Ptr$78084[ebp], eax

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Ptr$78084[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@IAEXPAURecord@CullResult@Ogre@@0@Z ; std::vector<Ogre::CullResult::Record,std::allocator<Ogre::CullResult::Record> >::_Destroy

; 1049 : 			_Mylast = _Ptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Ptr$78084[ebp]
	mov	DWORD PTR [eax+16], ecx
$LN1@erase@10:

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);

	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR __First$[ebp+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1055 : #endif
; 1056 : 		}

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?erase@?$vector@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@2@V?$_Vector_const_iterator@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@2@0@Z ENDP ; std::vector<Ogre::CullResult::Record,std::allocator<Ogre::CullResult::Record> >::erase
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@KAXXZ$0
__ehfuncinfo$?_Xlen@?$vector@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@KAXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T96872 = -80						; size = 28
$T96871 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@KAXXZ PROC ; std::vector<Ogre::CullResult::Record,std::allocator<Ogre::CullResult::Record> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Xlen@?$vector@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T96872[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR $T96872[ebp]
	push	eax
	lea	ecx, DWORD PTR $T96871[ebp]
	call	??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::length_error::length_error
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T96871[ebp]
	push	ecx
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T96872[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN2@Xlen@15:

; 1261 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T96872[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?_Xlen@?$vector@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@KAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@KAXXZ ENDP ; std::vector<Ogre::CullResult::Record,std::allocator<Ogre::CullResult::Record> >::_Xlen
PUBLIC	??$?0URecord@CullResult@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@URecord@CullResult@Ogre@@@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::CullResult::Record>
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??0?$_Container_base_aux_alloc_real@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@IAE@V?$allocator@URecord@CullResult@Ogre@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@IAE@V?$allocator@URecord@CullResult@Ogre@@@1@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@IAE@V?$allocator@URecord@CullResult@Ogre@@@1@@Z$1
__ehfuncinfo$??0?$_Container_base_aux_alloc_real@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@IAE@V?$allocator@URecord@CullResult@Ogre@@@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0?$_Container_base_aux_alloc_real@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@IAE@V?$allocator@URecord@CullResult@Ogre@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Container_base_aux_alloc_real@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@IAE@V?$allocator@URecord@CullResult@Ogre@@@1@@Z
_TEXT	SEGMENT
tv133 = -32						; size = 4
_this$ = -28						; size = 4
$T96884 = -24						; size = 4
$T96883 = -20						; size = 4
$T96882 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 1
??0?$_Container_base_aux_alloc_real@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@IAE@V?$allocator@URecord@CullResult@Ogre@@@1@@Z PROC ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::CullResult::Record> >::_Container_base_aux_alloc_real<std::allocator<Ogre::CullResult::Record> >, COMDAT
; _this$ = ecx

; 419  : 		{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Container_base_aux_alloc_real@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@IAE@V?$allocator@URecord@CullResult@Ogre@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 20					; 00000014H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::_Container_base_aux
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??$?0URecord@CullResult@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@URecord@CullResult@Ogre@@@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::CullResult::Record>

; 420  : 		_Myownedaux = new (_Alaux.allocate(1)) _Aux_cont(this);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?allocate@?$allocator@V_Aux_cont@std@@@std@@QAEPAV_Aux_cont@2@I@Z ; std::allocator<std::_Aux_cont>::allocate
	mov	DWORD PTR $T96884[ebp], eax
	mov	ecx, DWORD PTR $T96884[ebp]
	push	ecx
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T96883[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	cmp	DWORD PTR $T96883[ebp], 0
	je	SHORT $LN3@Container_@13
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T96883[ebp]
	call	??0_Aux_cont@std@@QAE@QBV_Container_base_aux@1@@Z ; std::_Aux_cont::_Aux_cont
	mov	DWORD PTR tv133[ebp], eax
	jmp	SHORT $LN4@Container_@13
$LN3@Container_@13:
	mov	DWORD PTR tv133[ebp], 0
$LN4@Container_@13:
	mov	eax, DWORD PTR tv133[ebp]
	mov	DWORD PTR $T96882[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T96882[ebp]
	mov	DWORD PTR [ecx], edx

; 421  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@IAE@V?$allocator@URecord@CullResult@Ogre@@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@IAE@V?$allocator@URecord@CullResult@Ogre@@@1@@Z$1:
	mov	eax, DWORD PTR $T96884[ebp]
	push	eax
	mov	ecx, DWORD PTR $T96883[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??0?$_Container_base_aux_alloc_real@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@IAE@V?$allocator@URecord@CullResult@Ogre@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Container_base_aux_alloc_real@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@IAE@V?$allocator@URecord@CullResult@Ogre@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Container_base_aux_alloc_real@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@IAE@V?$allocator@URecord@CullResult@Ogre@@@1@@Z ENDP ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::CullResult::Record> >::_Container_base_aux_alloc_real<std::allocator<Ogre::CullResult::Record> >
PUBLIC	??$_Allocate@URecord@CullResult@Ogre@@@std@@YAPAURecord@CullResult@Ogre@@IPAU123@@Z ; std::_Allocate<Ogre::CullResult::Record>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@URecord@CullResult@Ogre@@@std@@QAEPAURecord@CullResult@Ogre@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@URecord@CullResult@Ogre@@@std@@QAEPAURecord@CullResult@Ogre@@I@Z PROC ; std::allocator<Ogre::CullResult::Record>::allocate, COMDAT
; _this$ = ecx

; 144  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@URecord@CullResult@Ogre@@@std@@YAPAURecord@CullResult@Ogre@@IPAU123@@Z ; std::_Allocate<Ogre::CullResult::Record>
	add	esp, 8

; 146  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@URecord@CullResult@Ogre@@@std@@QAEPAURecord@CullResult@Ogre@@I@Z ENDP ; std::allocator<Ogre::CullResult::Record>::allocate
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@QAE@PAPAVEffectObject@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::EffectObject *,std::allocator<Ogre::EffectObject *> >::_Vector_iterator<Ogre::EffectObject *,std::allocator<Ogre::EffectObject *> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?begin@?$vector@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@2@XZ PROC ; std::vector<Ogre::EffectObject *,std::allocator<Ogre::EffectObject *> >::begin, COMDAT
; _this$ = ecx

; 640  : 		{	// return iterator for beginning of mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 641  : 		return (iterator(_Myfirst, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@QAE@PAPAVEffectObject@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::EffectObject *,std::allocator<Ogre::EffectObject *> >::_Vector_iterator<Ogre::EffectObject *,std::allocator<Ogre::EffectObject *> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 642  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?begin@?$vector@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@2@XZ ENDP ; std::vector<Ogre::EffectObject *,std::allocator<Ogre::EffectObject *> >::begin
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?end@?$vector@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@2@XZ PROC ; std::vector<Ogre::EffectObject *,std::allocator<Ogre::EffectObject *> >::end, COMDAT
; _this$ = ecx

; 650  : 		{	// return iterator for end of mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 651  : 		return (iterator(_Mylast, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@QAE@PAPAVEffectObject@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::EffectObject *,std::allocator<Ogre::EffectObject *> >::_Vector_iterator<Ogre::EffectObject *,std::allocator<Ogre::EffectObject *> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 652  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?end@?$vector@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@2@XZ ENDP ; std::vector<Ogre::EffectObject *,std::allocator<Ogre::EffectObject *> >::end
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@PAVEffectObject@Ogre@@@std@@QBEIXZ ; std::allocator<Ogre::EffectObject *>::max_size
; Function compile flags: /Odtp
;	COMDAT ?max_size@?$vector@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$vector@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@QBEIXZ PROC ; std::vector<Ogre::EffectObject *,std::allocator<Ogre::EffectObject *> >::max_size, COMDAT
; _this$ = ecx

; 730  : 		{	// return maximum possible length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 731  : 		return (this->_Alval.max_size());

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?max_size@?$allocator@PAVEffectObject@Ogre@@@std@@QBEIXZ ; std::allocator<Ogre::EffectObject *>::max_size

; 732  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$vector@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@QBEIXZ ENDP ; std::vector<Ogre::EffectObject *,std::allocator<Ogre::EffectObject *> >::max_size
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Ogre::EffectObject *,std::allocator<Ogre::EffectObject *> >::operator!=
PUBLIC	?_Make_iter@?$vector@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@2@@Z ; std::vector<Ogre::EffectObject *,std::allocator<Ogre::EffectObject *> >::_Make_iter
; Function compile flags: /Odtp
;	COMDAT ?erase@?$vector@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@2@0@Z
_TEXT	SEGMENT
_this$ = -24						; size = 4
__Ptr$78128 = -20					; size = 4
__Last$ = -16						; size = 8
__First$ = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 8
__Last_arg$ = 20					; size = 8
?erase@?$vector@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@2@0@Z PROC ; std::vector<Ogre::EffectObject *,std::allocator<Ogre::EffectObject *> >::erase, COMDAT
; _this$ = ecx

; 1028 : 		{	// erase [_First, _Last)

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	eax, DWORD PTR __First_arg$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __First_arg$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Make_iter@?$vector@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@2@@Z ; std::vector<Ogre::EffectObject *,std::allocator<Ogre::EffectObject *> >::_Make_iter

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);

	mov	eax, DWORD PTR __Last_arg$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __Last_arg$[ebp]
	push	ecx
	lea	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Make_iter@?$vector@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@2@@Z ; std::vector<Ogre::EffectObject *,std::allocator<Ogre::EffectObject *> >::_Make_iter

; 1031 : 
; 1032 : 		if (_First != _Last)

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	call	??9?$_Vector_const_iterator@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Ogre::EffectObject *,std::allocator<Ogre::EffectObject *> >::operator!=
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@erase@11

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	edx, DWORD PTR __First$[ebp+4]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp+4]
	push	edx
	call	??$unchecked_copy@PAPAVEffectObject@Ogre@@PAPAV12@@stdext@@YAPAPAVEffectObject@Ogre@@PAPAV12@00@Z ; stdext::unchecked_copy<Ogre::EffectObject * *,Ogre::EffectObject * *>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR __Ptr$78128[ebp], eax

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Ptr$78128[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@IAEXPAPAVEffectObject@Ogre@@0@Z ; std::vector<Ogre::EffectObject *,std::allocator<Ogre::EffectObject *> >::_Destroy

; 1049 : 			_Mylast = _Ptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Ptr$78128[ebp]
	mov	DWORD PTR [eax+16], ecx
$LN1@erase@11:

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);

	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR __First$[ebp+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1055 : #endif
; 1056 : 		}

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?erase@?$vector@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@2@0@Z ENDP ; std::vector<Ogre::EffectObject *,std::allocator<Ogre::EffectObject *> >::erase
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@KAXXZ$0
__ehfuncinfo$?_Xlen@?$vector@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@KAXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T96908 = -80						; size = 28
$T96907 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@KAXXZ PROC ; std::vector<Ogre::EffectObject *,std::allocator<Ogre::EffectObject *> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Xlen@?$vector@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T96908[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR $T96908[ebp]
	push	eax
	lea	ecx, DWORD PTR $T96907[ebp]
	call	??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::length_error::length_error
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T96907[ebp]
	push	ecx
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T96908[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN2@Xlen@16:

; 1261 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T96908[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?_Xlen@?$vector@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@KAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@KAXXZ ENDP ; std::vector<Ogre::EffectObject *,std::allocator<Ogre::EffectObject *> >::_Xlen
PUBLIC	??$?0PAVEffectObject@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@PAVEffectObject@Ogre@@@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::EffectObject *>
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@IAE@V?$allocator@PAVEffectObject@Ogre@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@IAE@V?$allocator@PAVEffectObject@Ogre@@@1@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@IAE@V?$allocator@PAVEffectObject@Ogre@@@1@@Z$1
__ehfuncinfo$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@IAE@V?$allocator@PAVEffectObject@Ogre@@@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@IAE@V?$allocator@PAVEffectObject@Ogre@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Container_base_aux_alloc_real@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@IAE@V?$allocator@PAVEffectObject@Ogre@@@1@@Z
_TEXT	SEGMENT
tv133 = -32						; size = 4
_this$ = -28						; size = 4
$T96920 = -24						; size = 4
$T96919 = -20						; size = 4
$T96918 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 1
??0?$_Container_base_aux_alloc_real@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@IAE@V?$allocator@PAVEffectObject@Ogre@@@1@@Z PROC ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::EffectObject *> >::_Container_base_aux_alloc_real<std::allocator<Ogre::EffectObject *> >, COMDAT
; _this$ = ecx

; 419  : 		{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@IAE@V?$allocator@PAVEffectObject@Ogre@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 20					; 00000014H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::_Container_base_aux
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??$?0PAVEffectObject@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@PAVEffectObject@Ogre@@@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::EffectObject *>

; 420  : 		_Myownedaux = new (_Alaux.allocate(1)) _Aux_cont(this);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?allocate@?$allocator@V_Aux_cont@std@@@std@@QAEPAV_Aux_cont@2@I@Z ; std::allocator<std::_Aux_cont>::allocate
	mov	DWORD PTR $T96920[ebp], eax
	mov	ecx, DWORD PTR $T96920[ebp]
	push	ecx
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T96919[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	cmp	DWORD PTR $T96919[ebp], 0
	je	SHORT $LN3@Container_@14
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T96919[ebp]
	call	??0_Aux_cont@std@@QAE@QBV_Container_base_aux@1@@Z ; std::_Aux_cont::_Aux_cont
	mov	DWORD PTR tv133[ebp], eax
	jmp	SHORT $LN4@Container_@14
$LN3@Container_@14:
	mov	DWORD PTR tv133[ebp], 0
$LN4@Container_@14:
	mov	eax, DWORD PTR tv133[ebp]
	mov	DWORD PTR $T96918[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T96918[ebp]
	mov	DWORD PTR [ecx], edx

; 421  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@IAE@V?$allocator@PAVEffectObject@Ogre@@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@IAE@V?$allocator@PAVEffectObject@Ogre@@@1@@Z$1:
	mov	eax, DWORD PTR $T96920[ebp]
	push	eax
	mov	ecx, DWORD PTR $T96919[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@IAE@V?$allocator@PAVEffectObject@Ogre@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@IAE@V?$allocator@PAVEffectObject@Ogre@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Container_base_aux_alloc_real@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@IAE@V?$allocator@PAVEffectObject@Ogre@@@1@@Z ENDP ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::EffectObject *> >::_Container_base_aux_alloc_real<std::allocator<Ogre::EffectObject *> >
PUBLIC	??$_Allocate@PAVEffectObject@Ogre@@@std@@YAPAPAVEffectObject@Ogre@@IPAPAV12@@Z ; std::_Allocate<Ogre::EffectObject *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@PAVEffectObject@Ogre@@@std@@QAEPAPAVEffectObject@Ogre@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@PAVEffectObject@Ogre@@@std@@QAEPAPAVEffectObject@Ogre@@I@Z PROC ; std::allocator<Ogre::EffectObject *>::allocate, COMDAT
; _this$ = ecx

; 144  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@PAVEffectObject@Ogre@@@std@@YAPAPAVEffectObject@Ogre@@IPAPAV12@@Z ; std::_Allocate<Ogre::EffectObject *>
	add	esp, 8

; 146  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@PAVEffectObject@Ogre@@@std@@QAEPAPAVEffectObject@Ogre@@I@Z ENDP ; std::allocator<Ogre::EffectObject *>::allocate
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@QAE@PAPAVSoundNode@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::SoundNode *,std::allocator<Ogre::SoundNode *> >::_Vector_iterator<Ogre::SoundNode *,std::allocator<Ogre::SoundNode *> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?begin@?$vector@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@2@XZ PROC ; std::vector<Ogre::SoundNode *,std::allocator<Ogre::SoundNode *> >::begin, COMDAT
; _this$ = ecx

; 640  : 		{	// return iterator for beginning of mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 641  : 		return (iterator(_Myfirst, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@QAE@PAPAVSoundNode@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::SoundNode *,std::allocator<Ogre::SoundNode *> >::_Vector_iterator<Ogre::SoundNode *,std::allocator<Ogre::SoundNode *> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 642  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?begin@?$vector@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@2@XZ ENDP ; std::vector<Ogre::SoundNode *,std::allocator<Ogre::SoundNode *> >::begin
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?end@?$vector@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@2@XZ PROC ; std::vector<Ogre::SoundNode *,std::allocator<Ogre::SoundNode *> >::end, COMDAT
; _this$ = ecx

; 650  : 		{	// return iterator for end of mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 651  : 		return (iterator(_Mylast, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@QAE@PAPAVSoundNode@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::SoundNode *,std::allocator<Ogre::SoundNode *> >::_Vector_iterator<Ogre::SoundNode *,std::allocator<Ogre::SoundNode *> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 652  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?end@?$vector@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@2@XZ ENDP ; std::vector<Ogre::SoundNode *,std::allocator<Ogre::SoundNode *> >::end
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@PAVSoundNode@Ogre@@@std@@QBEIXZ ; std::allocator<Ogre::SoundNode *>::max_size
; Function compile flags: /Odtp
;	COMDAT ?max_size@?$vector@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$vector@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@QBEIXZ PROC ; std::vector<Ogre::SoundNode *,std::allocator<Ogre::SoundNode *> >::max_size, COMDAT
; _this$ = ecx

; 730  : 		{	// return maximum possible length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 731  : 		return (this->_Alval.max_size());

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?max_size@?$allocator@PAVSoundNode@Ogre@@@std@@QBEIXZ ; std::allocator<Ogre::SoundNode *>::max_size

; 732  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$vector@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@QBEIXZ ENDP ; std::vector<Ogre::SoundNode *,std::allocator<Ogre::SoundNode *> >::max_size
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Ogre::SoundNode *,std::allocator<Ogre::SoundNode *> >::operator!=
PUBLIC	?_Make_iter@?$vector@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@2@@Z ; std::vector<Ogre::SoundNode *,std::allocator<Ogre::SoundNode *> >::_Make_iter
; Function compile flags: /Odtp
;	COMDAT ?erase@?$vector@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@2@0@Z
_TEXT	SEGMENT
_this$ = -24						; size = 4
__Ptr$78172 = -20					; size = 4
__Last$ = -16						; size = 8
__First$ = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 8
__Last_arg$ = 20					; size = 8
?erase@?$vector@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@2@0@Z PROC ; std::vector<Ogre::SoundNode *,std::allocator<Ogre::SoundNode *> >::erase, COMDAT
; _this$ = ecx

; 1028 : 		{	// erase [_First, _Last)

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	eax, DWORD PTR __First_arg$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __First_arg$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Make_iter@?$vector@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@2@@Z ; std::vector<Ogre::SoundNode *,std::allocator<Ogre::SoundNode *> >::_Make_iter

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);

	mov	eax, DWORD PTR __Last_arg$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __Last_arg$[ebp]
	push	ecx
	lea	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Make_iter@?$vector@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@2@@Z ; std::vector<Ogre::SoundNode *,std::allocator<Ogre::SoundNode *> >::_Make_iter

; 1031 : 
; 1032 : 		if (_First != _Last)

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	call	??9?$_Vector_const_iterator@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Ogre::SoundNode *,std::allocator<Ogre::SoundNode *> >::operator!=
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@erase@12

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	edx, DWORD PTR __First$[ebp+4]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp+4]
	push	edx
	call	??$unchecked_copy@PAPAVSoundNode@Ogre@@PAPAV12@@stdext@@YAPAPAVSoundNode@Ogre@@PAPAV12@00@Z ; stdext::unchecked_copy<Ogre::SoundNode * *,Ogre::SoundNode * *>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR __Ptr$78172[ebp], eax

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Ptr$78172[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@IAEXPAPAVSoundNode@Ogre@@0@Z ; std::vector<Ogre::SoundNode *,std::allocator<Ogre::SoundNode *> >::_Destroy

; 1049 : 			_Mylast = _Ptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Ptr$78172[ebp]
	mov	DWORD PTR [eax+16], ecx
$LN1@erase@12:

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);

	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR __First$[ebp+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1055 : #endif
; 1056 : 		}

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?erase@?$vector@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@2@0@Z ENDP ; std::vector<Ogre::SoundNode *,std::allocator<Ogre::SoundNode *> >::erase
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@KAXXZ$0
__ehfuncinfo$?_Xlen@?$vector@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@KAXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T96944 = -80						; size = 28
$T96943 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@KAXXZ PROC ; std::vector<Ogre::SoundNode *,std::allocator<Ogre::SoundNode *> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Xlen@?$vector@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T96944[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR $T96944[ebp]
	push	eax
	lea	ecx, DWORD PTR $T96943[ebp]
	call	??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::length_error::length_error
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T96943[ebp]
	push	ecx
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T96944[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN2@Xlen@17:

; 1261 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T96944[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?_Xlen@?$vector@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@KAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@KAXXZ ENDP ; std::vector<Ogre::SoundNode *,std::allocator<Ogre::SoundNode *> >::_Xlen
PUBLIC	??$?0PAVSoundNode@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@PAVSoundNode@Ogre@@@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::SoundNode *>
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@IAE@V?$allocator@PAVSoundNode@Ogre@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@IAE@V?$allocator@PAVSoundNode@Ogre@@@1@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@IAE@V?$allocator@PAVSoundNode@Ogre@@@1@@Z$1
__ehfuncinfo$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@IAE@V?$allocator@PAVSoundNode@Ogre@@@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@IAE@V?$allocator@PAVSoundNode@Ogre@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Container_base_aux_alloc_real@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@IAE@V?$allocator@PAVSoundNode@Ogre@@@1@@Z
_TEXT	SEGMENT
tv133 = -32						; size = 4
_this$ = -28						; size = 4
$T96956 = -24						; size = 4
$T96955 = -20						; size = 4
$T96954 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 1
??0?$_Container_base_aux_alloc_real@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@IAE@V?$allocator@PAVSoundNode@Ogre@@@1@@Z PROC ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::SoundNode *> >::_Container_base_aux_alloc_real<std::allocator<Ogre::SoundNode *> >, COMDAT
; _this$ = ecx

; 419  : 		{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@IAE@V?$allocator@PAVSoundNode@Ogre@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 20					; 00000014H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::_Container_base_aux
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??$?0PAVSoundNode@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@PAVSoundNode@Ogre@@@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::SoundNode *>

; 420  : 		_Myownedaux = new (_Alaux.allocate(1)) _Aux_cont(this);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?allocate@?$allocator@V_Aux_cont@std@@@std@@QAEPAV_Aux_cont@2@I@Z ; std::allocator<std::_Aux_cont>::allocate
	mov	DWORD PTR $T96956[ebp], eax
	mov	ecx, DWORD PTR $T96956[ebp]
	push	ecx
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T96955[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	cmp	DWORD PTR $T96955[ebp], 0
	je	SHORT $LN3@Container_@15
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T96955[ebp]
	call	??0_Aux_cont@std@@QAE@QBV_Container_base_aux@1@@Z ; std::_Aux_cont::_Aux_cont
	mov	DWORD PTR tv133[ebp], eax
	jmp	SHORT $LN4@Container_@15
$LN3@Container_@15:
	mov	DWORD PTR tv133[ebp], 0
$LN4@Container_@15:
	mov	eax, DWORD PTR tv133[ebp]
	mov	DWORD PTR $T96954[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T96954[ebp]
	mov	DWORD PTR [ecx], edx

; 421  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@IAE@V?$allocator@PAVSoundNode@Ogre@@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@IAE@V?$allocator@PAVSoundNode@Ogre@@@1@@Z$1:
	mov	eax, DWORD PTR $T96956[ebp]
	push	eax
	mov	ecx, DWORD PTR $T96955[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@IAE@V?$allocator@PAVSoundNode@Ogre@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@IAE@V?$allocator@PAVSoundNode@Ogre@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Container_base_aux_alloc_real@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@IAE@V?$allocator@PAVSoundNode@Ogre@@@1@@Z ENDP ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::SoundNode *> >::_Container_base_aux_alloc_real<std::allocator<Ogre::SoundNode *> >
PUBLIC	??$_Allocate@PAVSoundNode@Ogre@@@std@@YAPAPAVSoundNode@Ogre@@IPAPAV12@@Z ; std::_Allocate<Ogre::SoundNode *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@PAVSoundNode@Ogre@@@std@@QAEPAPAVSoundNode@Ogre@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@PAVSoundNode@Ogre@@@std@@QAEPAPAVSoundNode@Ogre@@I@Z PROC ; std::allocator<Ogre::SoundNode *>::allocate, COMDAT
; _this$ = ecx

; 144  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@PAVSoundNode@Ogre@@@std@@YAPAPAVSoundNode@Ogre@@IPAPAV12@@Z ; std::_Allocate<Ogre::SoundNode *>
	add	esp, 8

; 146  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@PAVSoundNode@Ogre@@@std@@QAEPAPAVSoundNode@Ogre@@I@Z ENDP ; std::allocator<Ogre::SoundNode *>::allocate
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@QAE@PAPAVRenderableObject@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::RenderableObject *,std::allocator<Ogre::RenderableObject *> >::_Vector_iterator<Ogre::RenderableObject *,std::allocator<Ogre::RenderableObject *> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?begin@?$vector@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@2@XZ PROC ; std::vector<Ogre::RenderableObject *,std::allocator<Ogre::RenderableObject *> >::begin, COMDAT
; _this$ = ecx

; 640  : 		{	// return iterator for beginning of mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 641  : 		return (iterator(_Myfirst, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@QAE@PAPAVRenderableObject@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::RenderableObject *,std::allocator<Ogre::RenderableObject *> >::_Vector_iterator<Ogre::RenderableObject *,std::allocator<Ogre::RenderableObject *> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 642  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?begin@?$vector@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@2@XZ ENDP ; std::vector<Ogre::RenderableObject *,std::allocator<Ogre::RenderableObject *> >::begin
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?end@?$vector@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@2@XZ PROC ; std::vector<Ogre::RenderableObject *,std::allocator<Ogre::RenderableObject *> >::end, COMDAT
; _this$ = ecx

; 650  : 		{	// return iterator for end of mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 651  : 		return (iterator(_Mylast, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@QAE@PAPAVRenderableObject@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::RenderableObject *,std::allocator<Ogre::RenderableObject *> >::_Vector_iterator<Ogre::RenderableObject *,std::allocator<Ogre::RenderableObject *> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 652  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?end@?$vector@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@2@XZ ENDP ; std::vector<Ogre::RenderableObject *,std::allocator<Ogre::RenderableObject *> >::end
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@PAVRenderableObject@Ogre@@@std@@QBEIXZ ; std::allocator<Ogre::RenderableObject *>::max_size
; Function compile flags: /Odtp
;	COMDAT ?max_size@?$vector@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$vector@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@QBEIXZ PROC ; std::vector<Ogre::RenderableObject *,std::allocator<Ogre::RenderableObject *> >::max_size, COMDAT
; _this$ = ecx

; 730  : 		{	// return maximum possible length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 731  : 		return (this->_Alval.max_size());

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?max_size@?$allocator@PAVRenderableObject@Ogre@@@std@@QBEIXZ ; std::allocator<Ogre::RenderableObject *>::max_size

; 732  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$vector@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@QBEIXZ ENDP ; std::vector<Ogre::RenderableObject *,std::allocator<Ogre::RenderableObject *> >::max_size
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Ogre::RenderableObject *,std::allocator<Ogre::RenderableObject *> >::operator!=
PUBLIC	?_Make_iter@?$vector@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@2@@Z ; std::vector<Ogre::RenderableObject *,std::allocator<Ogre::RenderableObject *> >::_Make_iter
; Function compile flags: /Odtp
;	COMDAT ?erase@?$vector@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@2@0@Z
_TEXT	SEGMENT
_this$ = -24						; size = 4
__Ptr$78216 = -20					; size = 4
__Last$ = -16						; size = 8
__First$ = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 8
__Last_arg$ = 20					; size = 8
?erase@?$vector@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@2@0@Z PROC ; std::vector<Ogre::RenderableObject *,std::allocator<Ogre::RenderableObject *> >::erase, COMDAT
; _this$ = ecx

; 1028 : 		{	// erase [_First, _Last)

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	eax, DWORD PTR __First_arg$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __First_arg$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Make_iter@?$vector@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@2@@Z ; std::vector<Ogre::RenderableObject *,std::allocator<Ogre::RenderableObject *> >::_Make_iter

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);

	mov	eax, DWORD PTR __Last_arg$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __Last_arg$[ebp]
	push	ecx
	lea	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Make_iter@?$vector@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@2@@Z ; std::vector<Ogre::RenderableObject *,std::allocator<Ogre::RenderableObject *> >::_Make_iter

; 1031 : 
; 1032 : 		if (_First != _Last)

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	call	??9?$_Vector_const_iterator@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Ogre::RenderableObject *,std::allocator<Ogre::RenderableObject *> >::operator!=
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@erase@13

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	edx, DWORD PTR __First$[ebp+4]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp+4]
	push	edx
	call	??$unchecked_copy@PAPAVRenderableObject@Ogre@@PAPAV12@@stdext@@YAPAPAVRenderableObject@Ogre@@PAPAV12@00@Z ; stdext::unchecked_copy<Ogre::RenderableObject * *,Ogre::RenderableObject * *>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR __Ptr$78216[ebp], eax

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Ptr$78216[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@IAEXPAPAVRenderableObject@Ogre@@0@Z ; std::vector<Ogre::RenderableObject *,std::allocator<Ogre::RenderableObject *> >::_Destroy

; 1049 : 			_Mylast = _Ptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Ptr$78216[ebp]
	mov	DWORD PTR [eax+16], ecx
$LN1@erase@13:

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);

	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR __First$[ebp+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1055 : #endif
; 1056 : 		}

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?erase@?$vector@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@2@0@Z ENDP ; std::vector<Ogre::RenderableObject *,std::allocator<Ogre::RenderableObject *> >::erase
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@KAXXZ$0
__ehfuncinfo$?_Xlen@?$vector@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@KAXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T96980 = -80						; size = 28
$T96979 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@KAXXZ PROC ; std::vector<Ogre::RenderableObject *,std::allocator<Ogre::RenderableObject *> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Xlen@?$vector@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T96980[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR $T96980[ebp]
	push	eax
	lea	ecx, DWORD PTR $T96979[ebp]
	call	??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::length_error::length_error
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T96979[ebp]
	push	ecx
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T96980[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN2@Xlen@18:

; 1261 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T96980[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?_Xlen@?$vector@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@KAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@KAXXZ ENDP ; std::vector<Ogre::RenderableObject *,std::allocator<Ogre::RenderableObject *> >::_Xlen
PUBLIC	??$?0PAVRenderableObject@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@PAVRenderableObject@Ogre@@@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::RenderableObject *>
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@IAE@V?$allocator@PAVRenderableObject@Ogre@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@IAE@V?$allocator@PAVRenderableObject@Ogre@@@1@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@IAE@V?$allocator@PAVRenderableObject@Ogre@@@1@@Z$1
__ehfuncinfo$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@IAE@V?$allocator@PAVRenderableObject@Ogre@@@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@IAE@V?$allocator@PAVRenderableObject@Ogre@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Container_base_aux_alloc_real@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@IAE@V?$allocator@PAVRenderableObject@Ogre@@@1@@Z
_TEXT	SEGMENT
tv133 = -32						; size = 4
_this$ = -28						; size = 4
$T96992 = -24						; size = 4
$T96991 = -20						; size = 4
$T96990 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 1
??0?$_Container_base_aux_alloc_real@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@IAE@V?$allocator@PAVRenderableObject@Ogre@@@1@@Z PROC ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::RenderableObject *> >::_Container_base_aux_alloc_real<std::allocator<Ogre::RenderableObject *> >, COMDAT
; _this$ = ecx

; 419  : 		{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@IAE@V?$allocator@PAVRenderableObject@Ogre@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 20					; 00000014H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::_Container_base_aux
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??$?0PAVRenderableObject@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@PAVRenderableObject@Ogre@@@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::RenderableObject *>

; 420  : 		_Myownedaux = new (_Alaux.allocate(1)) _Aux_cont(this);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?allocate@?$allocator@V_Aux_cont@std@@@std@@QAEPAV_Aux_cont@2@I@Z ; std::allocator<std::_Aux_cont>::allocate
	mov	DWORD PTR $T96992[ebp], eax
	mov	ecx, DWORD PTR $T96992[ebp]
	push	ecx
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T96991[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	cmp	DWORD PTR $T96991[ebp], 0
	je	SHORT $LN3@Container_@16
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T96991[ebp]
	call	??0_Aux_cont@std@@QAE@QBV_Container_base_aux@1@@Z ; std::_Aux_cont::_Aux_cont
	mov	DWORD PTR tv133[ebp], eax
	jmp	SHORT $LN4@Container_@16
$LN3@Container_@16:
	mov	DWORD PTR tv133[ebp], 0
$LN4@Container_@16:
	mov	eax, DWORD PTR tv133[ebp]
	mov	DWORD PTR $T96990[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T96990[ebp]
	mov	DWORD PTR [ecx], edx

; 421  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@IAE@V?$allocator@PAVRenderableObject@Ogre@@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@IAE@V?$allocator@PAVRenderableObject@Ogre@@@1@@Z$1:
	mov	eax, DWORD PTR $T96992[ebp]
	push	eax
	mov	ecx, DWORD PTR $T96991[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@IAE@V?$allocator@PAVRenderableObject@Ogre@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@IAE@V?$allocator@PAVRenderableObject@Ogre@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Container_base_aux_alloc_real@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@IAE@V?$allocator@PAVRenderableObject@Ogre@@@1@@Z ENDP ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::RenderableObject *> >::_Container_base_aux_alloc_real<std::allocator<Ogre::RenderableObject *> >
PUBLIC	??$_Allocate@PAVRenderableObject@Ogre@@@std@@YAPAPAVRenderableObject@Ogre@@IPAPAV12@@Z ; std::_Allocate<Ogre::RenderableObject *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@PAVRenderableObject@Ogre@@@std@@QAEPAPAVRenderableObject@Ogre@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@PAVRenderableObject@Ogre@@@std@@QAEPAPAVRenderableObject@Ogre@@I@Z PROC ; std::allocator<Ogre::RenderableObject *>::allocate, COMDAT
; _this$ = ecx

; 144  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@PAVRenderableObject@Ogre@@@std@@YAPAPAVRenderableObject@Ogre@@IPAPAV12@@Z ; std::_Allocate<Ogre::RenderableObject *>
	add	esp, 8

; 146  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@PAVRenderableObject@Ogre@@@std@@QAEPAPAVRenderableObject@Ogre@@I@Z ENDP ; std::allocator<Ogre::RenderableObject *>::allocate
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@QAE@PAPAVLight@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::Light *,std::allocator<Ogre::Light *> >::_Vector_iterator<Ogre::Light *,std::allocator<Ogre::Light *> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?begin@?$vector@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@2@XZ PROC ; std::vector<Ogre::Light *,std::allocator<Ogre::Light *> >::begin, COMDAT
; _this$ = ecx

; 640  : 		{	// return iterator for beginning of mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 641  : 		return (iterator(_Myfirst, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@QAE@PAPAVLight@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::Light *,std::allocator<Ogre::Light *> >::_Vector_iterator<Ogre::Light *,std::allocator<Ogre::Light *> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 642  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?begin@?$vector@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@2@XZ ENDP ; std::vector<Ogre::Light *,std::allocator<Ogre::Light *> >::begin
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?end@?$vector@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@2@XZ PROC ; std::vector<Ogre::Light *,std::allocator<Ogre::Light *> >::end, COMDAT
; _this$ = ecx

; 650  : 		{	// return iterator for end of mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 651  : 		return (iterator(_Mylast, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@QAE@PAPAVLight@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::Light *,std::allocator<Ogre::Light *> >::_Vector_iterator<Ogre::Light *,std::allocator<Ogre::Light *> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 652  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?end@?$vector@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@2@XZ ENDP ; std::vector<Ogre::Light *,std::allocator<Ogre::Light *> >::end
_TEXT	ENDS
PUBLIC	?max_size@?$allocator@PAVLight@Ogre@@@std@@QBEIXZ ; std::allocator<Ogre::Light *>::max_size
; Function compile flags: /Odtp
;	COMDAT ?max_size@?$vector@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$vector@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@QBEIXZ PROC ; std::vector<Ogre::Light *,std::allocator<Ogre::Light *> >::max_size, COMDAT
; _this$ = ecx

; 730  : 		{	// return maximum possible length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 731  : 		return (this->_Alval.max_size());

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?max_size@?$allocator@PAVLight@Ogre@@@std@@QBEIXZ ; std::allocator<Ogre::Light *>::max_size

; 732  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$vector@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@QBEIXZ ENDP ; std::vector<Ogre::Light *,std::allocator<Ogre::Light *> >::max_size
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Ogre::Light *,std::allocator<Ogre::Light *> >::operator!=
PUBLIC	?_Make_iter@?$vector@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@2@@Z ; std::vector<Ogre::Light *,std::allocator<Ogre::Light *> >::_Make_iter
; Function compile flags: /Odtp
;	COMDAT ?erase@?$vector@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@2@0@Z
_TEXT	SEGMENT
_this$ = -24						; size = 4
__Ptr$78260 = -20					; size = 4
__Last$ = -16						; size = 8
__First$ = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 8
__Last_arg$ = 20					; size = 8
?erase@?$vector@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@2@0@Z PROC ; std::vector<Ogre::Light *,std::allocator<Ogre::Light *> >::erase, COMDAT
; _this$ = ecx

; 1028 : 		{	// erase [_First, _Last)

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	eax, DWORD PTR __First_arg$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __First_arg$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Make_iter@?$vector@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@2@@Z ; std::vector<Ogre::Light *,std::allocator<Ogre::Light *> >::_Make_iter

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);

	mov	eax, DWORD PTR __Last_arg$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __Last_arg$[ebp]
	push	ecx
	lea	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Make_iter@?$vector@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@2@@Z ; std::vector<Ogre::Light *,std::allocator<Ogre::Light *> >::_Make_iter

; 1031 : 
; 1032 : 		if (_First != _Last)

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	call	??9?$_Vector_const_iterator@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Ogre::Light *,std::allocator<Ogre::Light *> >::operator!=
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@erase@14

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	edx, DWORD PTR __First$[ebp+4]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp+4]
	push	edx
	call	??$unchecked_copy@PAPAVLight@Ogre@@PAPAV12@@stdext@@YAPAPAVLight@Ogre@@PAPAV12@00@Z ; stdext::unchecked_copy<Ogre::Light * *,Ogre::Light * *>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR __Ptr$78260[ebp], eax

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Ptr$78260[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@IAEXPAPAVLight@Ogre@@0@Z ; std::vector<Ogre::Light *,std::allocator<Ogre::Light *> >::_Destroy

; 1049 : 			_Mylast = _Ptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Ptr$78260[ebp]
	mov	DWORD PTR [eax+16], ecx
$LN1@erase@14:

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);

	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR __First$[ebp+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1055 : #endif
; 1056 : 		}

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?erase@?$vector@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@2@0@Z ENDP ; std::vector<Ogre::Light *,std::allocator<Ogre::Light *> >::erase
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@KAXXZ$0
__ehfuncinfo$?_Xlen@?$vector@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@KAXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T97016 = -80						; size = 28
$T97015 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@KAXXZ PROC ; std::vector<Ogre::Light *,std::allocator<Ogre::Light *> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Xlen@?$vector@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T97016[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR $T97016[ebp]
	push	eax
	lea	ecx, DWORD PTR $T97015[ebp]
	call	??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::length_error::length_error
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T97015[ebp]
	push	ecx
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T97016[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN2@Xlen@19:

; 1261 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T97016[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?_Xlen@?$vector@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@KAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@KAXXZ ENDP ; std::vector<Ogre::Light *,std::allocator<Ogre::Light *> >::_Xlen
PUBLIC	??$?0PAVLight@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@PAVLight@Ogre@@@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::Light *>
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVLight@Ogre@@@std@@@std@@IAE@V?$allocator@PAVLight@Ogre@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVLight@Ogre@@@std@@@std@@IAE@V?$allocator@PAVLight@Ogre@@@1@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVLight@Ogre@@@std@@@std@@IAE@V?$allocator@PAVLight@Ogre@@@1@@Z$1
__ehfuncinfo$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVLight@Ogre@@@std@@@std@@IAE@V?$allocator@PAVLight@Ogre@@@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVLight@Ogre@@@std@@@std@@IAE@V?$allocator@PAVLight@Ogre@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Container_base_aux_alloc_real@V?$allocator@PAVLight@Ogre@@@std@@@std@@IAE@V?$allocator@PAVLight@Ogre@@@1@@Z
_TEXT	SEGMENT
tv133 = -32						; size = 4
_this$ = -28						; size = 4
$T97028 = -24						; size = 4
$T97027 = -20						; size = 4
$T97026 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 1
??0?$_Container_base_aux_alloc_real@V?$allocator@PAVLight@Ogre@@@std@@@std@@IAE@V?$allocator@PAVLight@Ogre@@@1@@Z PROC ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::Light *> >::_Container_base_aux_alloc_real<std::allocator<Ogre::Light *> >, COMDAT
; _this$ = ecx

; 419  : 		{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVLight@Ogre@@@std@@@std@@IAE@V?$allocator@PAVLight@Ogre@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 20					; 00000014H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::_Container_base_aux
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??$?0PAVLight@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@PAVLight@Ogre@@@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::Light *>

; 420  : 		_Myownedaux = new (_Alaux.allocate(1)) _Aux_cont(this);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?allocate@?$allocator@V_Aux_cont@std@@@std@@QAEPAV_Aux_cont@2@I@Z ; std::allocator<std::_Aux_cont>::allocate
	mov	DWORD PTR $T97028[ebp], eax
	mov	ecx, DWORD PTR $T97028[ebp]
	push	ecx
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T97027[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	cmp	DWORD PTR $T97027[ebp], 0
	je	SHORT $LN3@Container_@17
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T97027[ebp]
	call	??0_Aux_cont@std@@QAE@QBV_Container_base_aux@1@@Z ; std::_Aux_cont::_Aux_cont
	mov	DWORD PTR tv133[ebp], eax
	jmp	SHORT $LN4@Container_@17
$LN3@Container_@17:
	mov	DWORD PTR tv133[ebp], 0
$LN4@Container_@17:
	mov	eax, DWORD PTR tv133[ebp]
	mov	DWORD PTR $T97026[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T97026[ebp]
	mov	DWORD PTR [ecx], edx

; 421  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVLight@Ogre@@@std@@@std@@IAE@V?$allocator@PAVLight@Ogre@@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVLight@Ogre@@@std@@@std@@IAE@V?$allocator@PAVLight@Ogre@@@1@@Z$1:
	mov	eax, DWORD PTR $T97028[ebp]
	push	eax
	mov	ecx, DWORD PTR $T97027[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVLight@Ogre@@@std@@@std@@IAE@V?$allocator@PAVLight@Ogre@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVLight@Ogre@@@std@@@std@@IAE@V?$allocator@PAVLight@Ogre@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Container_base_aux_alloc_real@V?$allocator@PAVLight@Ogre@@@std@@@std@@IAE@V?$allocator@PAVLight@Ogre@@@1@@Z ENDP ; std::_Container_base_aux_alloc_real<std::allocator<Ogre::Light *> >::_Container_base_aux_alloc_real<std::allocator<Ogre::Light *> >
PUBLIC	??$_Allocate@PAVLight@Ogre@@@std@@YAPAPAVLight@Ogre@@IPAPAV12@@Z ; std::_Allocate<Ogre::Light *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?allocate@?$allocator@PAVLight@Ogre@@@std@@QAEPAPAVLight@Ogre@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@PAVLight@Ogre@@@std@@QAEPAPAVLight@Ogre@@I@Z PROC ; std::allocator<Ogre::Light *>::allocate, COMDAT
; _this$ = ecx

; 144  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@PAVLight@Ogre@@@std@@YAPAPAVLight@Ogre@@IPAPAV12@@Z ; std::_Allocate<Ogre::Light *>
	add	esp, 8

; 146  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@PAVLight@Ogre@@@std@@QAEPAPAVLight@Ogre@@I@Z ENDP ; std::allocator<Ogre::Light *>::allocate
_TEXT	ENDS
PUBLIC	?_Set_container@_Iterator_base_aux@std@@QAEXQBV_Container_base_aux@2@@Z ; std::_Iterator_base_aux::_Set_container
PUBLIC	??0?$_Ranit@UAnimRange@BaseKeyFrameArray@Ogre@@HPBU123@ABU123@@std@@QAE@XZ ; std::_Ranit<Ogre::BaseKeyFrameArray::AnimRange,int,Ogre::BaseKeyFrameArray::AnimRange const *,Ogre::BaseKeyFrameArray::AnimRange const &>::_Ranit<Ogre::BaseKeyFrameArray::AnimRange,int,Ogre::BaseKeyFrameArray::AnimRange const *,Ogre::BaseKeyFrameArray::AnimRange const &>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAE@PAUAnimRange@BaseKeyFrameArray@Ogre@@PBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAE@PAUAnimRange@BaseKeyFrameArray@Ogre@@PBV_Container_base_aux@1@@Z PROC ; std::_Vector_const_iterator<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::_Vector_const_iterator<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >, COMDAT
; _this$ = ecx

; 76   : 	_Vector_const_iterator(_Tptr _Ptr, const _Container_base *_Pvector)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Ranit@UAnimRange@BaseKeyFrameArray@Ogre@@HPBU123@ABU123@@std@@QAE@XZ

; 77   : 		{	// construct with pointer _Ptr
; 78   : 		_SCL_SECURE_VALIDATE(_Pvector != NULL && ((_Myvec *)_Pvector)->_Myfirst <= _Ptr && _Ptr <= ((_Myvec *)_Pvector)->_Mylast);

	cmp	DWORD PTR __Pvector$[ebp], 0
	je	SHORT $LN1@Vector_con
	mov	eax, DWORD PTR __Pvector$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	cmp	ecx, DWORD PTR __Ptr$[ebp]
	ja	SHORT $LN1@Vector_con
	mov	edx, DWORD PTR __Pvector$[ebp]
	mov	eax, DWORD PTR __Ptr$[ebp]
	cmp	eax, DWORD PTR [edx+16]
	jbe	SHORT $LN2@Vector_con
$LN1@Vector_con:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@Vector_con:

; 79   : 		this->_Set_container(_Pvector);

	mov	ecx, DWORD PTR __Pvector$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Set_container@_Iterator_base_aux@std@@QAEXQBV_Container_base_aux@2@@Z ; std::_Iterator_base_aux::_Set_container

; 80   : 		_Myptr = _Ptr;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR [edx+4], eax

; 81   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAE@PAUAnimRange@BaseKeyFrameArray@Ogre@@PBV_Container_base_aux@1@@Z ENDP ; std::_Vector_const_iterator<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::_Vector_const_iterator<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ?_Set_container@_Iterator_base_aux@std@@QAEXQBV_Container_base_aux@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pcont$ = 8						; size = 4
?_Set_container@_Iterator_base_aux@std@@QAEXQBV_Container_base_aux@2@@Z PROC ; std::_Iterator_base_aux::_Set_container, COMDAT
; _this$ = ecx

; 452  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 453  : 		_Myaux = _Pcont->_Myownedaux;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Pcont$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 454  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Set_container@_Iterator_base_aux@std@@QAEXQBV_Container_base_aux@2@@Z ENDP ; std::_Iterator_base_aux::_Set_container
_TEXT	ENDS
PUBLIC	??0?$_Ranit@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@HPBU123@ABU123@@std@@QAE@XZ ; std::_Ranit<Ogre::KeyFrameArray<float>::KEYFRAME_T,int,Ogre::KeyFrameArray<float>::KEYFRAME_T const *,Ogre::KeyFrameArray<float>::KEYFRAME_T const &>::_Ranit<Ogre::KeyFrameArray<float>::KEYFRAME_T,int,Ogre::KeyFrameArray<float>::KEYFRAME_T const *,Ogre::KeyFrameArray<float>::KEYFRAME_T const &>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAE@PAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAE@PAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PBV_Container_base_aux@1@@Z PROC ; std::_Vector_const_iterator<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::_Vector_const_iterator<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >, COMDAT
; _this$ = ecx

; 76   : 	_Vector_const_iterator(_Tptr _Ptr, const _Container_base *_Pvector)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Ranit@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@HPBU123@ABU123@@std@@QAE@XZ

; 77   : 		{	// construct with pointer _Ptr
; 78   : 		_SCL_SECURE_VALIDATE(_Pvector != NULL && ((_Myvec *)_Pvector)->_Myfirst <= _Ptr && _Ptr <= ((_Myvec *)_Pvector)->_Mylast);

	cmp	DWORD PTR __Pvector$[ebp], 0
	je	SHORT $LN1@Vector_con@2
	mov	eax, DWORD PTR __Pvector$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	cmp	ecx, DWORD PTR __Ptr$[ebp]
	ja	SHORT $LN1@Vector_con@2
	mov	edx, DWORD PTR __Pvector$[ebp]
	mov	eax, DWORD PTR __Ptr$[ebp]
	cmp	eax, DWORD PTR [edx+16]
	jbe	SHORT $LN2@Vector_con@2
$LN1@Vector_con@2:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@Vector_con@2:

; 79   : 		this->_Set_container(_Pvector);

	mov	ecx, DWORD PTR __Pvector$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Set_container@_Iterator_base_aux@std@@QAEXQBV_Container_base_aux@2@@Z ; std::_Iterator_base_aux::_Set_container

; 80   : 		_Myptr = _Ptr;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR [edx+4], eax

; 81   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAE@PAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PBV_Container_base_aux@1@@Z ENDP ; std::_Vector_const_iterator<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::_Vector_const_iterator<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >
_TEXT	ENDS
PUBLIC	??0?$_Ranit@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@HPBU123@ABU123@@std@@QAE@XZ ; std::_Ranit<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,int,Ogre::KeyFrameArray<float>::CONTROL_POINT_T const *,Ogre::KeyFrameArray<float>::CONTROL_POINT_T const &>::_Ranit<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,int,Ogre::KeyFrameArray<float>::CONTROL_POINT_T const *,Ogre::KeyFrameArray<float>::CONTROL_POINT_T const &>
; Function compile flags: /Odtp
;	COMDAT ??0?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAE@PAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAE@PAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PBV_Container_base_aux@1@@Z PROC ; std::_Vector_const_iterator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::_Vector_const_iterator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >, COMDAT
; _this$ = ecx

; 76   : 	_Vector_const_iterator(_Tptr _Ptr, const _Container_base *_Pvector)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Ranit@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@HPBU123@ABU123@@std@@QAE@XZ

; 77   : 		{	// construct with pointer _Ptr
; 78   : 		_SCL_SECURE_VALIDATE(_Pvector != NULL && ((_Myvec *)_Pvector)->_Myfirst <= _Ptr && _Ptr <= ((_Myvec *)_Pvector)->_Mylast);

	cmp	DWORD PTR __Pvector$[ebp], 0
	je	SHORT $LN1@Vector_con@3
	mov	eax, DWORD PTR __Pvector$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	cmp	ecx, DWORD PTR __Ptr$[ebp]
	ja	SHORT $LN1@Vector_con@3
	mov	edx, DWORD PTR __Pvector$[ebp]
	mov	eax, DWORD PTR __Ptr$[ebp]
	cmp	eax, DWORD PTR [edx+16]
	jbe	SHORT $LN2@Vector_con@3
$LN1@Vector_con@3:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@Vector_con@3:

; 79   : 		this->_Set_container(_Pvector);

	mov	ecx, DWORD PTR __Pvector$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Set_container@_Iterator_base_aux@std@@QAEXQBV_Container_base_aux@2@@Z ; std::_Iterator_base_aux::_Set_container

; 80   : 		_Myptr = _Ptr;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR [edx+4], eax

; 81   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAE@PAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PBV_Container_base_aux@1@@Z ENDP ; std::_Vector_const_iterator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::_Vector_const_iterator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >
_TEXT	ENDS
PUBLIC	??0?$_Ranit@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@HPBU123@ABU123@@std@@QAE@XZ ; std::_Ranit<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,int,Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T const *,Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T const &>::_Ranit<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,int,Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T const *,Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T const &>
; Function compile flags: /Odtp
;	COMDAT ??0?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAE@PAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAE@PAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PBV_Container_base_aux@1@@Z PROC ; std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >, COMDAT
; _this$ = ecx

; 76   : 	_Vector_const_iterator(_Tptr _Ptr, const _Container_base *_Pvector)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Ranit@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@HPBU123@ABU123@@std@@QAE@XZ

; 77   : 		{	// construct with pointer _Ptr
; 78   : 		_SCL_SECURE_VALIDATE(_Pvector != NULL && ((_Myvec *)_Pvector)->_Myfirst <= _Ptr && _Ptr <= ((_Myvec *)_Pvector)->_Mylast);

	cmp	DWORD PTR __Pvector$[ebp], 0
	je	SHORT $LN1@Vector_con@4
	mov	eax, DWORD PTR __Pvector$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	cmp	ecx, DWORD PTR __Ptr$[ebp]
	ja	SHORT $LN1@Vector_con@4
	mov	edx, DWORD PTR __Pvector$[ebp]
	mov	eax, DWORD PTR __Ptr$[ebp]
	cmp	eax, DWORD PTR [edx+16]
	jbe	SHORT $LN2@Vector_con@4
$LN1@Vector_con@4:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@Vector_con@4:

; 79   : 		this->_Set_container(_Pvector);

	mov	ecx, DWORD PTR __Pvector$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Set_container@_Iterator_base_aux@std@@QAEXQBV_Container_base_aux@2@@Z ; std::_Iterator_base_aux::_Set_container

; 80   : 		_Myptr = _Ptr;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR [edx+4], eax

; 81   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAE@PAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PBV_Container_base_aux@1@@Z ENDP ; std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >
_TEXT	ENDS
PUBLIC	??0?$_Ranit@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@HPBU123@ABU123@@std@@QAE@XZ ; std::_Ranit<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,int,Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T const *,Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T const &>::_Ranit<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,int,Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T const *,Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T const &>
; Function compile flags: /Odtp
;	COMDAT ??0?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAE@PAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAE@PAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PBV_Container_base_aux@1@@Z PROC ; std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >, COMDAT
; _this$ = ecx

; 76   : 	_Vector_const_iterator(_Tptr _Ptr, const _Container_base *_Pvector)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Ranit@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@HPBU123@ABU123@@std@@QAE@XZ

; 77   : 		{	// construct with pointer _Ptr
; 78   : 		_SCL_SECURE_VALIDATE(_Pvector != NULL && ((_Myvec *)_Pvector)->_Myfirst <= _Ptr && _Ptr <= ((_Myvec *)_Pvector)->_Mylast);

	cmp	DWORD PTR __Pvector$[ebp], 0
	je	SHORT $LN1@Vector_con@5
	mov	eax, DWORD PTR __Pvector$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	cmp	ecx, DWORD PTR __Ptr$[ebp]
	ja	SHORT $LN1@Vector_con@5
	mov	edx, DWORD PTR __Pvector$[ebp]
	mov	eax, DWORD PTR __Ptr$[ebp]
	cmp	eax, DWORD PTR [edx+16]
	jbe	SHORT $LN2@Vector_con@5
$LN1@Vector_con@5:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@Vector_con@5:

; 79   : 		this->_Set_container(_Pvector);

	mov	ecx, DWORD PTR __Pvector$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Set_container@_Iterator_base_aux@std@@QAEXQBV_Container_base_aux@2@@Z ; std::_Iterator_base_aux::_Set_container

; 80   : 		_Myptr = _Ptr;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR [edx+4], eax

; 81   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAE@PAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PBV_Container_base_aux@1@@Z ENDP ; std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >
_TEXT	ENDS
PUBLIC	??0?$_Ranit@PAVShaderContext@Ogre@@HPBQAV12@ABQAV12@@std@@QAE@XZ ; std::_Ranit<Ogre::ShaderContext *,int,Ogre::ShaderContext * const *,Ogre::ShaderContext * const &>::_Ranit<Ogre::ShaderContext *,int,Ogre::ShaderContext * const *,Ogre::ShaderContext * const &>
; Function compile flags: /Odtp
;	COMDAT ??0?$_Vector_const_iterator@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@QAE@PAPAVShaderContext@Ogre@@PBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@QAE@PAPAVShaderContext@Ogre@@PBV_Container_base_aux@1@@Z PROC ; std::_Vector_const_iterator<Ogre::ShaderContext *,std::allocator<Ogre::ShaderContext *> >::_Vector_const_iterator<Ogre::ShaderContext *,std::allocator<Ogre::ShaderContext *> >, COMDAT
; _this$ = ecx

; 76   : 	_Vector_const_iterator(_Tptr _Ptr, const _Container_base *_Pvector)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Ranit@PAVShaderContext@Ogre@@HPBQAV12@ABQAV12@@std@@QAE@XZ

; 77   : 		{	// construct with pointer _Ptr
; 78   : 		_SCL_SECURE_VALIDATE(_Pvector != NULL && ((_Myvec *)_Pvector)->_Myfirst <= _Ptr && _Ptr <= ((_Myvec *)_Pvector)->_Mylast);

	cmp	DWORD PTR __Pvector$[ebp], 0
	je	SHORT $LN1@Vector_con@6
	mov	eax, DWORD PTR __Pvector$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	cmp	ecx, DWORD PTR __Ptr$[ebp]
	ja	SHORT $LN1@Vector_con@6
	mov	edx, DWORD PTR __Pvector$[ebp]
	mov	eax, DWORD PTR __Ptr$[ebp]
	cmp	eax, DWORD PTR [edx+16]
	jbe	SHORT $LN2@Vector_con@6
$LN1@Vector_con@6:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@Vector_con@6:

; 79   : 		this->_Set_container(_Pvector);

	mov	ecx, DWORD PTR __Pvector$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Set_container@_Iterator_base_aux@std@@QAEXQBV_Container_base_aux@2@@Z ; std::_Iterator_base_aux::_Set_container

; 80   : 		_Myptr = _Ptr;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR [edx+4], eax

; 81   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Vector_const_iterator@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@QAE@PAPAVShaderContext@Ogre@@PBV_Container_base_aux@1@@Z ENDP ; std::_Vector_const_iterator<Ogre::ShaderContext *,std::allocator<Ogre::ShaderContext *> >::_Vector_const_iterator<Ogre::ShaderContext *,std::allocator<Ogre::ShaderContext *> >
_TEXT	ENDS
PUBLIC	??0?$_Ranit@UContextQueDesc@Ogre@@HPBU12@ABU12@@std@@QAE@XZ ; std::_Ranit<Ogre::ContextQueDesc,int,Ogre::ContextQueDesc const *,Ogre::ContextQueDesc const &>::_Ranit<Ogre::ContextQueDesc,int,Ogre::ContextQueDesc const *,Ogre::ContextQueDesc const &>
; Function compile flags: /Odtp
;	COMDAT ??0?$_Vector_const_iterator@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@QAE@PAUContextQueDesc@Ogre@@PBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@QAE@PAUContextQueDesc@Ogre@@PBV_Container_base_aux@1@@Z PROC ; std::_Vector_const_iterator<Ogre::ContextQueDesc,std::allocator<Ogre::ContextQueDesc> >::_Vector_const_iterator<Ogre::ContextQueDesc,std::allocator<Ogre::ContextQueDesc> >, COMDAT
; _this$ = ecx

; 76   : 	_Vector_const_iterator(_Tptr _Ptr, const _Container_base *_Pvector)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Ranit@UContextQueDesc@Ogre@@HPBU12@ABU12@@std@@QAE@XZ

; 77   : 		{	// construct with pointer _Ptr
; 78   : 		_SCL_SECURE_VALIDATE(_Pvector != NULL && ((_Myvec *)_Pvector)->_Myfirst <= _Ptr && _Ptr <= ((_Myvec *)_Pvector)->_Mylast);

	cmp	DWORD PTR __Pvector$[ebp], 0
	je	SHORT $LN1@Vector_con@7
	mov	eax, DWORD PTR __Pvector$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	cmp	ecx, DWORD PTR __Ptr$[ebp]
	ja	SHORT $LN1@Vector_con@7
	mov	edx, DWORD PTR __Pvector$[ebp]
	mov	eax, DWORD PTR __Ptr$[ebp]
	cmp	eax, DWORD PTR [edx+16]
	jbe	SHORT $LN2@Vector_con@7
$LN1@Vector_con@7:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@Vector_con@7:

; 79   : 		this->_Set_container(_Pvector);

	mov	ecx, DWORD PTR __Pvector$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Set_container@_Iterator_base_aux@std@@QAEXQBV_Container_base_aux@2@@Z ; std::_Iterator_base_aux::_Set_container

; 80   : 		_Myptr = _Ptr;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR [edx+4], eax

; 81   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Vector_const_iterator@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@QAE@PAUContextQueDesc@Ogre@@PBV_Container_base_aux@1@@Z ENDP ; std::_Vector_const_iterator<Ogre::ContextQueDesc,std::allocator<Ogre::ContextQueDesc> >::_Vector_const_iterator<Ogre::ContextQueDesc,std::allocator<Ogre::ContextQueDesc> >
_TEXT	ENDS
PUBLIC	??0?$_Ranit@EHPBEABE@std@@QAE@XZ		; std::_Ranit<unsigned char,int,unsigned char const *,unsigned char const &>::_Ranit<unsigned char,int,unsigned char const *,unsigned char const &>
; Function compile flags: /Odtp
;	COMDAT ??0?$_Vector_const_iterator@EV?$allocator@E@std@@@std@@QAE@PAEPBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@EV?$allocator@E@std@@@std@@QAE@PAEPBV_Container_base_aux@1@@Z PROC ; std::_Vector_const_iterator<unsigned char,std::allocator<unsigned char> >::_Vector_const_iterator<unsigned char,std::allocator<unsigned char> >, COMDAT
; _this$ = ecx

; 76   : 	_Vector_const_iterator(_Tptr _Ptr, const _Container_base *_Pvector)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Ranit@EHPBEABE@std@@QAE@XZ

; 77   : 		{	// construct with pointer _Ptr
; 78   : 		_SCL_SECURE_VALIDATE(_Pvector != NULL && ((_Myvec *)_Pvector)->_Myfirst <= _Ptr && _Ptr <= ((_Myvec *)_Pvector)->_Mylast);

	cmp	DWORD PTR __Pvector$[ebp], 0
	je	SHORT $LN1@Vector_con@8
	mov	eax, DWORD PTR __Pvector$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	cmp	ecx, DWORD PTR __Ptr$[ebp]
	ja	SHORT $LN1@Vector_con@8
	mov	edx, DWORD PTR __Pvector$[ebp]
	mov	eax, DWORD PTR __Ptr$[ebp]
	cmp	eax, DWORD PTR [edx+16]
	jbe	SHORT $LN2@Vector_con@8
$LN1@Vector_con@8:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@Vector_con@8:

; 79   : 		this->_Set_container(_Pvector);

	mov	ecx, DWORD PTR __Pvector$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Set_container@_Iterator_base_aux@std@@QAEXQBV_Container_base_aux@2@@Z ; std::_Iterator_base_aux::_Set_container

; 80   : 		_Myptr = _Ptr;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR [edx+4], eax

; 81   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Vector_const_iterator@EV?$allocator@E@std@@@std@@QAE@PAEPBV_Container_base_aux@1@@Z ENDP ; std::_Vector_const_iterator<unsigned char,std::allocator<unsigned char> >::_Vector_const_iterator<unsigned char,std::allocator<unsigned char> >
_TEXT	ENDS
PUBLIC	??0?$_Ranit@UValueParam@ShaderContextPool@Ogre@@HPBU123@ABU123@@std@@QAE@XZ ; std::_Ranit<Ogre::ShaderContextPool::ValueParam,int,Ogre::ShaderContextPool::ValueParam const *,Ogre::ShaderContextPool::ValueParam const &>::_Ranit<Ogre::ShaderContextPool::ValueParam,int,Ogre::ShaderContextPool::ValueParam const *,Ogre::ShaderContextPool::ValueParam const &>
; Function compile flags: /Odtp
;	COMDAT ??0?$_Vector_const_iterator@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@QAE@PAUValueParam@ShaderContextPool@Ogre@@PBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@QAE@PAUValueParam@ShaderContextPool@Ogre@@PBV_Container_base_aux@1@@Z PROC ; std::_Vector_const_iterator<Ogre::ShaderContextPool::ValueParam,std::allocator<Ogre::ShaderContextPool::ValueParam> >::_Vector_const_iterator<Ogre::ShaderContextPool::ValueParam,std::allocator<Ogre::ShaderContextPool::ValueParam> >, COMDAT
; _this$ = ecx

; 76   : 	_Vector_const_iterator(_Tptr _Ptr, const _Container_base *_Pvector)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Ranit@UValueParam@ShaderContextPool@Ogre@@HPBU123@ABU123@@std@@QAE@XZ

; 77   : 		{	// construct with pointer _Ptr
; 78   : 		_SCL_SECURE_VALIDATE(_Pvector != NULL && ((_Myvec *)_Pvector)->_Myfirst <= _Ptr && _Ptr <= ((_Myvec *)_Pvector)->_Mylast);

	cmp	DWORD PTR __Pvector$[ebp], 0
	je	SHORT $LN1@Vector_con@9
	mov	eax, DWORD PTR __Pvector$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	cmp	ecx, DWORD PTR __Ptr$[ebp]
	ja	SHORT $LN1@Vector_con@9
	mov	edx, DWORD PTR __Pvector$[ebp]
	mov	eax, DWORD PTR __Ptr$[ebp]
	cmp	eax, DWORD PTR [edx+16]
	jbe	SHORT $LN2@Vector_con@9
$LN1@Vector_con@9:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@Vector_con@9:

; 79   : 		this->_Set_container(_Pvector);

	mov	ecx, DWORD PTR __Pvector$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Set_container@_Iterator_base_aux@std@@QAEXQBV_Container_base_aux@2@@Z ; std::_Iterator_base_aux::_Set_container

; 80   : 		_Myptr = _Ptr;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR [edx+4], eax

; 81   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Vector_const_iterator@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@QAE@PAUValueParam@ShaderContextPool@Ogre@@PBV_Container_base_aux@1@@Z ENDP ; std::_Vector_const_iterator<Ogre::ShaderContextPool::ValueParam,std::allocator<Ogre::ShaderContextPool::ValueParam> >::_Vector_const_iterator<Ogre::ShaderContextPool::ValueParam,std::allocator<Ogre::ShaderContextPool::ValueParam> >
_TEXT	ENDS
PUBLIC	??0?$_Ranit@UTexParam@ShaderContextPool@Ogre@@HPBU123@ABU123@@std@@QAE@XZ ; std::_Ranit<Ogre::ShaderContextPool::TexParam,int,Ogre::ShaderContextPool::TexParam const *,Ogre::ShaderContextPool::TexParam const &>::_Ranit<Ogre::ShaderContextPool::TexParam,int,Ogre::ShaderContextPool::TexParam const *,Ogre::ShaderContextPool::TexParam const &>
; Function compile flags: /Odtp
;	COMDAT ??0?$_Vector_const_iterator@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@QAE@PAUTexParam@ShaderContextPool@Ogre@@PBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@QAE@PAUTexParam@ShaderContextPool@Ogre@@PBV_Container_base_aux@1@@Z PROC ; std::_Vector_const_iterator<Ogre::ShaderContextPool::TexParam,std::allocator<Ogre::ShaderContextPool::TexParam> >::_Vector_const_iterator<Ogre::ShaderContextPool::TexParam,std::allocator<Ogre::ShaderContextPool::TexParam> >, COMDAT
; _this$ = ecx

; 76   : 	_Vector_const_iterator(_Tptr _Ptr, const _Container_base *_Pvector)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Ranit@UTexParam@ShaderContextPool@Ogre@@HPBU123@ABU123@@std@@QAE@XZ

; 77   : 		{	// construct with pointer _Ptr
; 78   : 		_SCL_SECURE_VALIDATE(_Pvector != NULL && ((_Myvec *)_Pvector)->_Myfirst <= _Ptr && _Ptr <= ((_Myvec *)_Pvector)->_Mylast);

	cmp	DWORD PTR __Pvector$[ebp], 0
	je	SHORT $LN1@Vector_con@10
	mov	eax, DWORD PTR __Pvector$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	cmp	ecx, DWORD PTR __Ptr$[ebp]
	ja	SHORT $LN1@Vector_con@10
	mov	edx, DWORD PTR __Pvector$[ebp]
	mov	eax, DWORD PTR __Ptr$[ebp]
	cmp	eax, DWORD PTR [edx+16]
	jbe	SHORT $LN2@Vector_con@10
$LN1@Vector_con@10:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@Vector_con@10:

; 79   : 		this->_Set_container(_Pvector);

	mov	ecx, DWORD PTR __Pvector$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Set_container@_Iterator_base_aux@std@@QAEXQBV_Container_base_aux@2@@Z ; std::_Iterator_base_aux::_Set_container

; 80   : 		_Myptr = _Ptr;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR [edx+4], eax

; 81   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Vector_const_iterator@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@QAE@PAUTexParam@ShaderContextPool@Ogre@@PBV_Container_base_aux@1@@Z ENDP ; std::_Vector_const_iterator<Ogre::ShaderContextPool::TexParam,std::allocator<Ogre::ShaderContextPool::TexParam> >::_Vector_const_iterator<Ogre::ShaderContextPool::TexParam,std::allocator<Ogre::ShaderContextPool::TexParam> >
_TEXT	ENDS
PUBLIC	??0?$_Ranit@DHPBDABD@std@@QAE@XZ		; std::_Ranit<char,int,char const *,char const &>::_Ranit<char,int,char const *,char const &>
; Function compile flags: /Odtp
;	COMDAT ??0?$_Vector_const_iterator@DV?$allocator@D@std@@@std@@QAE@PADPBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@DV?$allocator@D@std@@@std@@QAE@PADPBV_Container_base_aux@1@@Z PROC ; std::_Vector_const_iterator<char,std::allocator<char> >::_Vector_const_iterator<char,std::allocator<char> >, COMDAT
; _this$ = ecx

; 76   : 	_Vector_const_iterator(_Tptr _Ptr, const _Container_base *_Pvector)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Ranit@DHPBDABD@std@@QAE@XZ

; 77   : 		{	// construct with pointer _Ptr
; 78   : 		_SCL_SECURE_VALIDATE(_Pvector != NULL && ((_Myvec *)_Pvector)->_Myfirst <= _Ptr && _Ptr <= ((_Myvec *)_Pvector)->_Mylast);

	cmp	DWORD PTR __Pvector$[ebp], 0
	je	SHORT $LN1@Vector_con@11
	mov	eax, DWORD PTR __Pvector$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	cmp	ecx, DWORD PTR __Ptr$[ebp]
	ja	SHORT $LN1@Vector_con@11
	mov	edx, DWORD PTR __Pvector$[ebp]
	mov	eax, DWORD PTR __Ptr$[ebp]
	cmp	eax, DWORD PTR [edx+16]
	jbe	SHORT $LN2@Vector_con@11
$LN1@Vector_con@11:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@Vector_con@11:

; 79   : 		this->_Set_container(_Pvector);

	mov	ecx, DWORD PTR __Pvector$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Set_container@_Iterator_base_aux@std@@QAEXQBV_Container_base_aux@2@@Z ; std::_Iterator_base_aux::_Set_container

; 80   : 		_Myptr = _Ptr;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR [edx+4], eax

; 81   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Vector_const_iterator@DV?$allocator@D@std@@@std@@QAE@PADPBV_Container_base_aux@1@@Z ENDP ; std::_Vector_const_iterator<char,std::allocator<char> >::_Vector_const_iterator<char,std::allocator<char> >
_TEXT	ENDS
PUBLIC	??0?$_Ranit@PAVSurfaceData@Ogre@@HPBQAV12@ABQAV12@@std@@QAE@XZ ; std::_Ranit<Ogre::SurfaceData *,int,Ogre::SurfaceData * const *,Ogre::SurfaceData * const &>::_Ranit<Ogre::SurfaceData *,int,Ogre::SurfaceData * const *,Ogre::SurfaceData * const &>
; Function compile flags: /Odtp
;	COMDAT ??0?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE@PAPAVSurfaceData@Ogre@@PBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE@PAPAVSurfaceData@Ogre@@PBV_Container_base_aux@1@@Z PROC ; std::_Vector_const_iterator<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::_Vector_const_iterator<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >, COMDAT
; _this$ = ecx

; 76   : 	_Vector_const_iterator(_Tptr _Ptr, const _Container_base *_Pvector)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Ranit@PAVSurfaceData@Ogre@@HPBQAV12@ABQAV12@@std@@QAE@XZ

; 77   : 		{	// construct with pointer _Ptr
; 78   : 		_SCL_SECURE_VALIDATE(_Pvector != NULL && ((_Myvec *)_Pvector)->_Myfirst <= _Ptr && _Ptr <= ((_Myvec *)_Pvector)->_Mylast);

	cmp	DWORD PTR __Pvector$[ebp], 0
	je	SHORT $LN1@Vector_con@12
	mov	eax, DWORD PTR __Pvector$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	cmp	ecx, DWORD PTR __Ptr$[ebp]
	ja	SHORT $LN1@Vector_con@12
	mov	edx, DWORD PTR __Pvector$[ebp]
	mov	eax, DWORD PTR __Ptr$[ebp]
	cmp	eax, DWORD PTR [edx+16]
	jbe	SHORT $LN2@Vector_con@12
$LN1@Vector_con@12:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@Vector_con@12:

; 79   : 		this->_Set_container(_Pvector);

	mov	ecx, DWORD PTR __Pvector$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Set_container@_Iterator_base_aux@std@@QAEXQBV_Container_base_aux@2@@Z ; std::_Iterator_base_aux::_Set_container

; 80   : 		_Myptr = _Ptr;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR [edx+4], eax

; 81   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE@PAPAVSurfaceData@Ogre@@PBV_Container_base_aux@1@@Z ENDP ; std::_Vector_const_iterator<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::_Vector_const_iterator<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >
_TEXT	ENDS
PUBLIC	??0?$_Ranit@URecord@CullResult@Ogre@@HPBU123@ABU123@@std@@QAE@XZ ; std::_Ranit<Ogre::CullResult::Record,int,Ogre::CullResult::Record const *,Ogre::CullResult::Record const &>::_Ranit<Ogre::CullResult::Record,int,Ogre::CullResult::Record const *,Ogre::CullResult::Record const &>
; Function compile flags: /Odtp
;	COMDAT ??0?$_Vector_const_iterator@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@QAE@PAURecord@CullResult@Ogre@@PBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@QAE@PAURecord@CullResult@Ogre@@PBV_Container_base_aux@1@@Z PROC ; std::_Vector_const_iterator<Ogre::CullResult::Record,std::allocator<Ogre::CullResult::Record> >::_Vector_const_iterator<Ogre::CullResult::Record,std::allocator<Ogre::CullResult::Record> >, COMDAT
; _this$ = ecx

; 76   : 	_Vector_const_iterator(_Tptr _Ptr, const _Container_base *_Pvector)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Ranit@URecord@CullResult@Ogre@@HPBU123@ABU123@@std@@QAE@XZ

; 77   : 		{	// construct with pointer _Ptr
; 78   : 		_SCL_SECURE_VALIDATE(_Pvector != NULL && ((_Myvec *)_Pvector)->_Myfirst <= _Ptr && _Ptr <= ((_Myvec *)_Pvector)->_Mylast);

	cmp	DWORD PTR __Pvector$[ebp], 0
	je	SHORT $LN1@Vector_con@13
	mov	eax, DWORD PTR __Pvector$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	cmp	ecx, DWORD PTR __Ptr$[ebp]
	ja	SHORT $LN1@Vector_con@13
	mov	edx, DWORD PTR __Pvector$[ebp]
	mov	eax, DWORD PTR __Ptr$[ebp]
	cmp	eax, DWORD PTR [edx+16]
	jbe	SHORT $LN2@Vector_con@13
$LN1@Vector_con@13:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@Vector_con@13:

; 79   : 		this->_Set_container(_Pvector);

	mov	ecx, DWORD PTR __Pvector$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Set_container@_Iterator_base_aux@std@@QAEXQBV_Container_base_aux@2@@Z ; std::_Iterator_base_aux::_Set_container

; 80   : 		_Myptr = _Ptr;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR [edx+4], eax

; 81   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Vector_const_iterator@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@QAE@PAURecord@CullResult@Ogre@@PBV_Container_base_aux@1@@Z ENDP ; std::_Vector_const_iterator<Ogre::CullResult::Record,std::allocator<Ogre::CullResult::Record> >::_Vector_const_iterator<Ogre::CullResult::Record,std::allocator<Ogre::CullResult::Record> >
_TEXT	ENDS
PUBLIC	??0?$_Ranit@PAVEffectObject@Ogre@@HPBQAV12@ABQAV12@@std@@QAE@XZ ; std::_Ranit<Ogre::EffectObject *,int,Ogre::EffectObject * const *,Ogre::EffectObject * const &>::_Ranit<Ogre::EffectObject *,int,Ogre::EffectObject * const *,Ogre::EffectObject * const &>
; Function compile flags: /Odtp
;	COMDAT ??0?$_Vector_const_iterator@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@QAE@PAPAVEffectObject@Ogre@@PBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@QAE@PAPAVEffectObject@Ogre@@PBV_Container_base_aux@1@@Z PROC ; std::_Vector_const_iterator<Ogre::EffectObject *,std::allocator<Ogre::EffectObject *> >::_Vector_const_iterator<Ogre::EffectObject *,std::allocator<Ogre::EffectObject *> >, COMDAT
; _this$ = ecx

; 76   : 	_Vector_const_iterator(_Tptr _Ptr, const _Container_base *_Pvector)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Ranit@PAVEffectObject@Ogre@@HPBQAV12@ABQAV12@@std@@QAE@XZ

; 77   : 		{	// construct with pointer _Ptr
; 78   : 		_SCL_SECURE_VALIDATE(_Pvector != NULL && ((_Myvec *)_Pvector)->_Myfirst <= _Ptr && _Ptr <= ((_Myvec *)_Pvector)->_Mylast);

	cmp	DWORD PTR __Pvector$[ebp], 0
	je	SHORT $LN1@Vector_con@14
	mov	eax, DWORD PTR __Pvector$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	cmp	ecx, DWORD PTR __Ptr$[ebp]
	ja	SHORT $LN1@Vector_con@14
	mov	edx, DWORD PTR __Pvector$[ebp]
	mov	eax, DWORD PTR __Ptr$[ebp]
	cmp	eax, DWORD PTR [edx+16]
	jbe	SHORT $LN2@Vector_con@14
$LN1@Vector_con@14:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@Vector_con@14:

; 79   : 		this->_Set_container(_Pvector);

	mov	ecx, DWORD PTR __Pvector$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Set_container@_Iterator_base_aux@std@@QAEXQBV_Container_base_aux@2@@Z ; std::_Iterator_base_aux::_Set_container

; 80   : 		_Myptr = _Ptr;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR [edx+4], eax

; 81   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Vector_const_iterator@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@QAE@PAPAVEffectObject@Ogre@@PBV_Container_base_aux@1@@Z ENDP ; std::_Vector_const_iterator<Ogre::EffectObject *,std::allocator<Ogre::EffectObject *> >::_Vector_const_iterator<Ogre::EffectObject *,std::allocator<Ogre::EffectObject *> >
_TEXT	ENDS
PUBLIC	??0?$_Ranit@PAVSoundNode@Ogre@@HPBQAV12@ABQAV12@@std@@QAE@XZ ; std::_Ranit<Ogre::SoundNode *,int,Ogre::SoundNode * const *,Ogre::SoundNode * const &>::_Ranit<Ogre::SoundNode *,int,Ogre::SoundNode * const *,Ogre::SoundNode * const &>
; Function compile flags: /Odtp
;	COMDAT ??0?$_Vector_const_iterator@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@QAE@PAPAVSoundNode@Ogre@@PBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@QAE@PAPAVSoundNode@Ogre@@PBV_Container_base_aux@1@@Z PROC ; std::_Vector_const_iterator<Ogre::SoundNode *,std::allocator<Ogre::SoundNode *> >::_Vector_const_iterator<Ogre::SoundNode *,std::allocator<Ogre::SoundNode *> >, COMDAT
; _this$ = ecx

; 76   : 	_Vector_const_iterator(_Tptr _Ptr, const _Container_base *_Pvector)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Ranit@PAVSoundNode@Ogre@@HPBQAV12@ABQAV12@@std@@QAE@XZ

; 77   : 		{	// construct with pointer _Ptr
; 78   : 		_SCL_SECURE_VALIDATE(_Pvector != NULL && ((_Myvec *)_Pvector)->_Myfirst <= _Ptr && _Ptr <= ((_Myvec *)_Pvector)->_Mylast);

	cmp	DWORD PTR __Pvector$[ebp], 0
	je	SHORT $LN1@Vector_con@15
	mov	eax, DWORD PTR __Pvector$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	cmp	ecx, DWORD PTR __Ptr$[ebp]
	ja	SHORT $LN1@Vector_con@15
	mov	edx, DWORD PTR __Pvector$[ebp]
	mov	eax, DWORD PTR __Ptr$[ebp]
	cmp	eax, DWORD PTR [edx+16]
	jbe	SHORT $LN2@Vector_con@15
$LN1@Vector_con@15:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@Vector_con@15:

; 79   : 		this->_Set_container(_Pvector);

	mov	ecx, DWORD PTR __Pvector$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Set_container@_Iterator_base_aux@std@@QAEXQBV_Container_base_aux@2@@Z ; std::_Iterator_base_aux::_Set_container

; 80   : 		_Myptr = _Ptr;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR [edx+4], eax

; 81   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Vector_const_iterator@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@QAE@PAPAVSoundNode@Ogre@@PBV_Container_base_aux@1@@Z ENDP ; std::_Vector_const_iterator<Ogre::SoundNode *,std::allocator<Ogre::SoundNode *> >::_Vector_const_iterator<Ogre::SoundNode *,std::allocator<Ogre::SoundNode *> >
_TEXT	ENDS
PUBLIC	??0?$_Ranit@PAVRenderableObject@Ogre@@HPBQAV12@ABQAV12@@std@@QAE@XZ ; std::_Ranit<Ogre::RenderableObject *,int,Ogre::RenderableObject * const *,Ogre::RenderableObject * const &>::_Ranit<Ogre::RenderableObject *,int,Ogre::RenderableObject * const *,Ogre::RenderableObject * const &>
; Function compile flags: /Odtp
;	COMDAT ??0?$_Vector_const_iterator@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@QAE@PAPAVRenderableObject@Ogre@@PBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@QAE@PAPAVRenderableObject@Ogre@@PBV_Container_base_aux@1@@Z PROC ; std::_Vector_const_iterator<Ogre::RenderableObject *,std::allocator<Ogre::RenderableObject *> >::_Vector_const_iterator<Ogre::RenderableObject *,std::allocator<Ogre::RenderableObject *> >, COMDAT
; _this$ = ecx

; 76   : 	_Vector_const_iterator(_Tptr _Ptr, const _Container_base *_Pvector)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Ranit@PAVRenderableObject@Ogre@@HPBQAV12@ABQAV12@@std@@QAE@XZ

; 77   : 		{	// construct with pointer _Ptr
; 78   : 		_SCL_SECURE_VALIDATE(_Pvector != NULL && ((_Myvec *)_Pvector)->_Myfirst <= _Ptr && _Ptr <= ((_Myvec *)_Pvector)->_Mylast);

	cmp	DWORD PTR __Pvector$[ebp], 0
	je	SHORT $LN1@Vector_con@16
	mov	eax, DWORD PTR __Pvector$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	cmp	ecx, DWORD PTR __Ptr$[ebp]
	ja	SHORT $LN1@Vector_con@16
	mov	edx, DWORD PTR __Pvector$[ebp]
	mov	eax, DWORD PTR __Ptr$[ebp]
	cmp	eax, DWORD PTR [edx+16]
	jbe	SHORT $LN2@Vector_con@16
$LN1@Vector_con@16:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@Vector_con@16:

; 79   : 		this->_Set_container(_Pvector);

	mov	ecx, DWORD PTR __Pvector$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Set_container@_Iterator_base_aux@std@@QAEXQBV_Container_base_aux@2@@Z ; std::_Iterator_base_aux::_Set_container

; 80   : 		_Myptr = _Ptr;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR [edx+4], eax

; 81   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Vector_const_iterator@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@QAE@PAPAVRenderableObject@Ogre@@PBV_Container_base_aux@1@@Z ENDP ; std::_Vector_const_iterator<Ogre::RenderableObject *,std::allocator<Ogre::RenderableObject *> >::_Vector_const_iterator<Ogre::RenderableObject *,std::allocator<Ogre::RenderableObject *> >
_TEXT	ENDS
PUBLIC	??0?$_Ranit@PAVLight@Ogre@@HPBQAV12@ABQAV12@@std@@QAE@XZ ; std::_Ranit<Ogre::Light *,int,Ogre::Light * const *,Ogre::Light * const &>::_Ranit<Ogre::Light *,int,Ogre::Light * const *,Ogre::Light * const &>
; Function compile flags: /Odtp
;	COMDAT ??0?$_Vector_const_iterator@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@QAE@PAPAVLight@Ogre@@PBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@QAE@PAPAVLight@Ogre@@PBV_Container_base_aux@1@@Z PROC ; std::_Vector_const_iterator<Ogre::Light *,std::allocator<Ogre::Light *> >::_Vector_const_iterator<Ogre::Light *,std::allocator<Ogre::Light *> >, COMDAT
; _this$ = ecx

; 76   : 	_Vector_const_iterator(_Tptr _Ptr, const _Container_base *_Pvector)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Ranit@PAVLight@Ogre@@HPBQAV12@ABQAV12@@std@@QAE@XZ

; 77   : 		{	// construct with pointer _Ptr
; 78   : 		_SCL_SECURE_VALIDATE(_Pvector != NULL && ((_Myvec *)_Pvector)->_Myfirst <= _Ptr && _Ptr <= ((_Myvec *)_Pvector)->_Mylast);

	cmp	DWORD PTR __Pvector$[ebp], 0
	je	SHORT $LN1@Vector_con@17
	mov	eax, DWORD PTR __Pvector$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	cmp	ecx, DWORD PTR __Ptr$[ebp]
	ja	SHORT $LN1@Vector_con@17
	mov	edx, DWORD PTR __Pvector$[ebp]
	mov	eax, DWORD PTR __Ptr$[ebp]
	cmp	eax, DWORD PTR [edx+16]
	jbe	SHORT $LN2@Vector_con@17
$LN1@Vector_con@17:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@Vector_con@17:

; 79   : 		this->_Set_container(_Pvector);

	mov	ecx, DWORD PTR __Pvector$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Set_container@_Iterator_base_aux@std@@QAEXQBV_Container_base_aux@2@@Z ; std::_Iterator_base_aux::_Set_container

; 80   : 		_Myptr = _Ptr;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR [edx+4], eax

; 81   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Vector_const_iterator@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@QAE@PAPAVLight@Ogre@@PBV_Container_base_aux@1@@Z ENDP ; std::_Vector_const_iterator<Ogre::Light *,std::allocator<Ogre::Light *> >::_Vector_const_iterator<Ogre::Light *,std::allocator<Ogre::Light *> >
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0length_error@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0length_error@std@@QAE@ABV01@@Z$0
__ehfuncinfo$??0length_error@std@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0length_error@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0length_error@std@@QAE@ABV01@@Z PROC			; std::length_error::length_error, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0length_error@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0logic_error@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7length_error@std@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0length_error@std@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1logic_error@std@@UAE@XZ		; std::logic_error::~logic_error
__ehhandler$??0length_error@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0length_error@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0length_error@std@@QAE@ABV01@@Z ENDP			; std::length_error::length_error
PUBLIC	??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@UAnimRange@BaseKeyFrameArray@Ogre@@HPBU345@ABU345@V_Iterator_base_aux@2@@std@@QAE@XZ ; std::_Iterator_with_base<std::random_access_iterator_tag,Ogre::BaseKeyFrameArray::AnimRange,int,Ogre::BaseKeyFrameArray::AnimRange const *,Ogre::BaseKeyFrameArray::AnimRange const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,Ogre::BaseKeyFrameArray::AnimRange,int,Ogre::BaseKeyFrameArray::AnimRange const *,Ogre::BaseKeyFrameArray::AnimRange const &,std::_Iterator_base_aux>
; Function compile flags: /Odtp
;	COMDAT ??0?$_Ranit@UAnimRange@BaseKeyFrameArray@Ogre@@HPBU123@ABU123@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Ranit@UAnimRange@BaseKeyFrameArray@Ogre@@HPBU123@ABU123@@std@@QAE@XZ PROC ; std::_Ranit<Ogre::BaseKeyFrameArray::AnimRange,int,Ogre::BaseKeyFrameArray::AnimRange const *,Ogre::BaseKeyFrameArray::AnimRange const &>::_Ranit<Ogre::BaseKeyFrameArray::AnimRange,int,Ogre::BaseKeyFrameArray::AnimRange const *,Ogre::BaseKeyFrameArray::AnimRange const &>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@UAnimRange@BaseKeyFrameArray@Ogre@@HPBU345@ABU345@V_Iterator_base_aux@2@@std@@QAE@XZ
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Ranit@UAnimRange@BaseKeyFrameArray@Ogre@@HPBU123@ABU123@@std@@QAE@XZ ENDP ; std::_Ranit<Ogre::BaseKeyFrameArray::AnimRange,int,Ogre::BaseKeyFrameArray::AnimRange const *,Ogre::BaseKeyFrameArray::AnimRange const &>::_Ranit<Ogre::BaseKeyFrameArray::AnimRange,int,Ogre::BaseKeyFrameArray::AnimRange const *,Ogre::BaseKeyFrameArray::AnimRange const &>
_TEXT	ENDS
PUBLIC	??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@HPBU345@ABU345@V_Iterator_base_aux@2@@std@@QAE@XZ ; std::_Iterator_with_base<std::random_access_iterator_tag,Ogre::KeyFrameArray<float>::KEYFRAME_T,int,Ogre::KeyFrameArray<float>::KEYFRAME_T const *,Ogre::KeyFrameArray<float>::KEYFRAME_T const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,Ogre::KeyFrameArray<float>::KEYFRAME_T,int,Ogre::KeyFrameArray<float>::KEYFRAME_T const *,Ogre::KeyFrameArray<float>::KEYFRAME_T const &,std::_Iterator_base_aux>
; Function compile flags: /Odtp
;	COMDAT ??0?$_Ranit@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@HPBU123@ABU123@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Ranit@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@HPBU123@ABU123@@std@@QAE@XZ PROC ; std::_Ranit<Ogre::KeyFrameArray<float>::KEYFRAME_T,int,Ogre::KeyFrameArray<float>::KEYFRAME_T const *,Ogre::KeyFrameArray<float>::KEYFRAME_T const &>::_Ranit<Ogre::KeyFrameArray<float>::KEYFRAME_T,int,Ogre::KeyFrameArray<float>::KEYFRAME_T const *,Ogre::KeyFrameArray<float>::KEYFRAME_T const &>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@HPBU345@ABU345@V_Iterator_base_aux@2@@std@@QAE@XZ
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Ranit@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@HPBU123@ABU123@@std@@QAE@XZ ENDP ; std::_Ranit<Ogre::KeyFrameArray<float>::KEYFRAME_T,int,Ogre::KeyFrameArray<float>::KEYFRAME_T const *,Ogre::KeyFrameArray<float>::KEYFRAME_T const &>::_Ranit<Ogre::KeyFrameArray<float>::KEYFRAME_T,int,Ogre::KeyFrameArray<float>::KEYFRAME_T const *,Ogre::KeyFrameArray<float>::KEYFRAME_T const &>
_TEXT	ENDS
PUBLIC	??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@HPBU345@ABU345@V_Iterator_base_aux@2@@std@@QAE@XZ ; std::_Iterator_with_base<std::random_access_iterator_tag,Ogre::KeyFrameArray<float>::CONTROL_POINT_T,int,Ogre::KeyFrameArray<float>::CONTROL_POINT_T const *,Ogre::KeyFrameArray<float>::CONTROL_POINT_T const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,Ogre::KeyFrameArray<float>::CONTROL_POINT_T,int,Ogre::KeyFrameArray<float>::CONTROL_POINT_T const *,Ogre::KeyFrameArray<float>::CONTROL_POINT_T const &,std::_Iterator_base_aux>
; Function compile flags: /Odtp
;	COMDAT ??0?$_Ranit@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@HPBU123@ABU123@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Ranit@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@HPBU123@ABU123@@std@@QAE@XZ PROC ; std::_Ranit<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,int,Ogre::KeyFrameArray<float>::CONTROL_POINT_T const *,Ogre::KeyFrameArray<float>::CONTROL_POINT_T const &>::_Ranit<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,int,Ogre::KeyFrameArray<float>::CONTROL_POINT_T const *,Ogre::KeyFrameArray<float>::CONTROL_POINT_T const &>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@HPBU345@ABU345@V_Iterator_base_aux@2@@std@@QAE@XZ
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Ranit@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@HPBU123@ABU123@@std@@QAE@XZ ENDP ; std::_Ranit<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,int,Ogre::KeyFrameArray<float>::CONTROL_POINT_T const *,Ogre::KeyFrameArray<float>::CONTROL_POINT_T const &>::_Ranit<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,int,Ogre::KeyFrameArray<float>::CONTROL_POINT_T const *,Ogre::KeyFrameArray<float>::CONTROL_POINT_T const &>
_TEXT	ENDS
PUBLIC	??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@HPBU345@ABU345@V_Iterator_base_aux@2@@std@@QAE@XZ ; std::_Iterator_with_base<std::random_access_iterator_tag,Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,int,Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T const *,Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,int,Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T const *,Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T const &,std::_Iterator_base_aux>
; Function compile flags: /Odtp
;	COMDAT ??0?$_Ranit@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@HPBU123@ABU123@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Ranit@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@HPBU123@ABU123@@std@@QAE@XZ PROC ; std::_Ranit<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,int,Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T const *,Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T const &>::_Ranit<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,int,Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T const *,Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T const &>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@HPBU345@ABU345@V_Iterator_base_aux@2@@std@@QAE@XZ
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Ranit@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@HPBU123@ABU123@@std@@QAE@XZ ENDP ; std::_Ranit<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,int,Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T const *,Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T const &>::_Ranit<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,int,Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T const *,Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T const &>
_TEXT	ENDS
PUBLIC	??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@HPBU345@ABU345@V_Iterator_base_aux@2@@std@@QAE@XZ ; std::_Iterator_with_base<std::random_access_iterator_tag,Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,int,Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T const *,Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,int,Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T const *,Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T const &,std::_Iterator_base_aux>
; Function compile flags: /Odtp
;	COMDAT ??0?$_Ranit@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@HPBU123@ABU123@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Ranit@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@HPBU123@ABU123@@std@@QAE@XZ PROC ; std::_Ranit<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,int,Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T const *,Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T const &>::_Ranit<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,int,Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T const *,Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T const &>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@HPBU345@ABU345@V_Iterator_base_aux@2@@std@@QAE@XZ
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Ranit@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@HPBU123@ABU123@@std@@QAE@XZ ENDP ; std::_Ranit<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,int,Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T const *,Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T const &>::_Ranit<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,int,Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T const *,Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T const &>
_TEXT	ENDS
PUBLIC	??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@PAVShaderContext@Ogre@@HPBQAV34@ABQAV34@V_Iterator_base_aux@2@@std@@QAE@XZ ; std::_Iterator_with_base<std::random_access_iterator_tag,Ogre::ShaderContext *,int,Ogre::ShaderContext * const *,Ogre::ShaderContext * const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,Ogre::ShaderContext *,int,Ogre::ShaderContext * const *,Ogre::ShaderContext * const &,std::_Iterator_base_aux>
; Function compile flags: /Odtp
;	COMDAT ??0?$_Ranit@PAVShaderContext@Ogre@@HPBQAV12@ABQAV12@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Ranit@PAVShaderContext@Ogre@@HPBQAV12@ABQAV12@@std@@QAE@XZ PROC ; std::_Ranit<Ogre::ShaderContext *,int,Ogre::ShaderContext * const *,Ogre::ShaderContext * const &>::_Ranit<Ogre::ShaderContext *,int,Ogre::ShaderContext * const *,Ogre::ShaderContext * const &>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@PAVShaderContext@Ogre@@HPBQAV34@ABQAV34@V_Iterator_base_aux@2@@std@@QAE@XZ
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Ranit@PAVShaderContext@Ogre@@HPBQAV12@ABQAV12@@std@@QAE@XZ ENDP ; std::_Ranit<Ogre::ShaderContext *,int,Ogre::ShaderContext * const *,Ogre::ShaderContext * const &>::_Ranit<Ogre::ShaderContext *,int,Ogre::ShaderContext * const *,Ogre::ShaderContext * const &>
_TEXT	ENDS
PUBLIC	??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@UContextQueDesc@Ogre@@HPBU34@ABU34@V_Iterator_base_aux@2@@std@@QAE@XZ ; std::_Iterator_with_base<std::random_access_iterator_tag,Ogre::ContextQueDesc,int,Ogre::ContextQueDesc const *,Ogre::ContextQueDesc const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,Ogre::ContextQueDesc,int,Ogre::ContextQueDesc const *,Ogre::ContextQueDesc const &,std::_Iterator_base_aux>
; Function compile flags: /Odtp
;	COMDAT ??0?$_Ranit@UContextQueDesc@Ogre@@HPBU12@ABU12@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Ranit@UContextQueDesc@Ogre@@HPBU12@ABU12@@std@@QAE@XZ PROC ; std::_Ranit<Ogre::ContextQueDesc,int,Ogre::ContextQueDesc const *,Ogre::ContextQueDesc const &>::_Ranit<Ogre::ContextQueDesc,int,Ogre::ContextQueDesc const *,Ogre::ContextQueDesc const &>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@UContextQueDesc@Ogre@@HPBU34@ABU34@V_Iterator_base_aux@2@@std@@QAE@XZ
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Ranit@UContextQueDesc@Ogre@@HPBU12@ABU12@@std@@QAE@XZ ENDP ; std::_Ranit<Ogre::ContextQueDesc,int,Ogre::ContextQueDesc const *,Ogre::ContextQueDesc const &>::_Ranit<Ogre::ContextQueDesc,int,Ogre::ContextQueDesc const *,Ogre::ContextQueDesc const &>
_TEXT	ENDS
PUBLIC	??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@EHPBEABEV_Iterator_base_aux@2@@std@@QAE@XZ ; std::_Iterator_with_base<std::random_access_iterator_tag,unsigned char,int,unsigned char const *,unsigned char const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,unsigned char,int,unsigned char const *,unsigned char const &,std::_Iterator_base_aux>
; Function compile flags: /Odtp
;	COMDAT ??0?$_Ranit@EHPBEABE@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Ranit@EHPBEABE@std@@QAE@XZ PROC			; std::_Ranit<unsigned char,int,unsigned char const *,unsigned char const &>::_Ranit<unsigned char,int,unsigned char const *,unsigned char const &>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@EHPBEABEV_Iterator_base_aux@2@@std@@QAE@XZ
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Ranit@EHPBEABE@std@@QAE@XZ ENDP			; std::_Ranit<unsigned char,int,unsigned char const *,unsigned char const &>::_Ranit<unsigned char,int,unsigned char const *,unsigned char const &>
_TEXT	ENDS
PUBLIC	??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@UValueParam@ShaderContextPool@Ogre@@HPBU345@ABU345@V_Iterator_base_aux@2@@std@@QAE@XZ ; std::_Iterator_with_base<std::random_access_iterator_tag,Ogre::ShaderContextPool::ValueParam,int,Ogre::ShaderContextPool::ValueParam const *,Ogre::ShaderContextPool::ValueParam const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,Ogre::ShaderContextPool::ValueParam,int,Ogre::ShaderContextPool::ValueParam const *,Ogre::ShaderContextPool::ValueParam const &,std::_Iterator_base_aux>
; Function compile flags: /Odtp
;	COMDAT ??0?$_Ranit@UValueParam@ShaderContextPool@Ogre@@HPBU123@ABU123@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Ranit@UValueParam@ShaderContextPool@Ogre@@HPBU123@ABU123@@std@@QAE@XZ PROC ; std::_Ranit<Ogre::ShaderContextPool::ValueParam,int,Ogre::ShaderContextPool::ValueParam const *,Ogre::ShaderContextPool::ValueParam const &>::_Ranit<Ogre::ShaderContextPool::ValueParam,int,Ogre::ShaderContextPool::ValueParam const *,Ogre::ShaderContextPool::ValueParam const &>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@UValueParam@ShaderContextPool@Ogre@@HPBU345@ABU345@V_Iterator_base_aux@2@@std@@QAE@XZ
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Ranit@UValueParam@ShaderContextPool@Ogre@@HPBU123@ABU123@@std@@QAE@XZ ENDP ; std::_Ranit<Ogre::ShaderContextPool::ValueParam,int,Ogre::ShaderContextPool::ValueParam const *,Ogre::ShaderContextPool::ValueParam const &>::_Ranit<Ogre::ShaderContextPool::ValueParam,int,Ogre::ShaderContextPool::ValueParam const *,Ogre::ShaderContextPool::ValueParam const &>
_TEXT	ENDS
PUBLIC	??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@UTexParam@ShaderContextPool@Ogre@@HPBU345@ABU345@V_Iterator_base_aux@2@@std@@QAE@XZ ; std::_Iterator_with_base<std::random_access_iterator_tag,Ogre::ShaderContextPool::TexParam,int,Ogre::ShaderContextPool::TexParam const *,Ogre::ShaderContextPool::TexParam const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,Ogre::ShaderContextPool::TexParam,int,Ogre::ShaderContextPool::TexParam const *,Ogre::ShaderContextPool::TexParam const &,std::_Iterator_base_aux>
; Function compile flags: /Odtp
;	COMDAT ??0?$_Ranit@UTexParam@ShaderContextPool@Ogre@@HPBU123@ABU123@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Ranit@UTexParam@ShaderContextPool@Ogre@@HPBU123@ABU123@@std@@QAE@XZ PROC ; std::_Ranit<Ogre::ShaderContextPool::TexParam,int,Ogre::ShaderContextPool::TexParam const *,Ogre::ShaderContextPool::TexParam const &>::_Ranit<Ogre::ShaderContextPool::TexParam,int,Ogre::ShaderContextPool::TexParam const *,Ogre::ShaderContextPool::TexParam const &>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@UTexParam@ShaderContextPool@Ogre@@HPBU345@ABU345@V_Iterator_base_aux@2@@std@@QAE@XZ
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Ranit@UTexParam@ShaderContextPool@Ogre@@HPBU123@ABU123@@std@@QAE@XZ ENDP ; std::_Ranit<Ogre::ShaderContextPool::TexParam,int,Ogre::ShaderContextPool::TexParam const *,Ogre::ShaderContextPool::TexParam const &>::_Ranit<Ogre::ShaderContextPool::TexParam,int,Ogre::ShaderContextPool::TexParam const *,Ogre::ShaderContextPool::TexParam const &>
_TEXT	ENDS
PUBLIC	??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@DHPBDABDV_Iterator_base_aux@2@@std@@QAE@XZ ; std::_Iterator_with_base<std::random_access_iterator_tag,char,int,char const *,char const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,char,int,char const *,char const &,std::_Iterator_base_aux>
; Function compile flags: /Odtp
;	COMDAT ??0?$_Ranit@DHPBDABD@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Ranit@DHPBDABD@std@@QAE@XZ PROC			; std::_Ranit<char,int,char const *,char const &>::_Ranit<char,int,char const *,char const &>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@DHPBDABDV_Iterator_base_aux@2@@std@@QAE@XZ
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Ranit@DHPBDABD@std@@QAE@XZ ENDP			; std::_Ranit<char,int,char const *,char const &>::_Ranit<char,int,char const *,char const &>
_TEXT	ENDS
PUBLIC	??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@PAVSurfaceData@Ogre@@HPBQAV34@ABQAV34@V_Iterator_base_aux@2@@std@@QAE@XZ ; std::_Iterator_with_base<std::random_access_iterator_tag,Ogre::SurfaceData *,int,Ogre::SurfaceData * const *,Ogre::SurfaceData * const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,Ogre::SurfaceData *,int,Ogre::SurfaceData * const *,Ogre::SurfaceData * const &,std::_Iterator_base_aux>
; Function compile flags: /Odtp
;	COMDAT ??0?$_Ranit@PAVSurfaceData@Ogre@@HPBQAV12@ABQAV12@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Ranit@PAVSurfaceData@Ogre@@HPBQAV12@ABQAV12@@std@@QAE@XZ PROC ; std::_Ranit<Ogre::SurfaceData *,int,Ogre::SurfaceData * const *,Ogre::SurfaceData * const &>::_Ranit<Ogre::SurfaceData *,int,Ogre::SurfaceData * const *,Ogre::SurfaceData * const &>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@PAVSurfaceData@Ogre@@HPBQAV34@ABQAV34@V_Iterator_base_aux@2@@std@@QAE@XZ
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Ranit@PAVSurfaceData@Ogre@@HPBQAV12@ABQAV12@@std@@QAE@XZ ENDP ; std::_Ranit<Ogre::SurfaceData *,int,Ogre::SurfaceData * const *,Ogre::SurfaceData * const &>::_Ranit<Ogre::SurfaceData *,int,Ogre::SurfaceData * const *,Ogre::SurfaceData * const &>
_TEXT	ENDS
PUBLIC	??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@URecord@CullResult@Ogre@@HPBU345@ABU345@V_Iterator_base_aux@2@@std@@QAE@XZ ; std::_Iterator_with_base<std::random_access_iterator_tag,Ogre::CullResult::Record,int,Ogre::CullResult::Record const *,Ogre::CullResult::Record const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,Ogre::CullResult::Record,int,Ogre::CullResult::Record const *,Ogre::CullResult::Record const &,std::_Iterator_base_aux>
; Function compile flags: /Odtp
;	COMDAT ??0?$_Ranit@URecord@CullResult@Ogre@@HPBU123@ABU123@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Ranit@URecord@CullResult@Ogre@@HPBU123@ABU123@@std@@QAE@XZ PROC ; std::_Ranit<Ogre::CullResult::Record,int,Ogre::CullResult::Record const *,Ogre::CullResult::Record const &>::_Ranit<Ogre::CullResult::Record,int,Ogre::CullResult::Record const *,Ogre::CullResult::Record const &>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@URecord@CullResult@Ogre@@HPBU345@ABU345@V_Iterator_base_aux@2@@std@@QAE@XZ
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Ranit@URecord@CullResult@Ogre@@HPBU123@ABU123@@std@@QAE@XZ ENDP ; std::_Ranit<Ogre::CullResult::Record,int,Ogre::CullResult::Record const *,Ogre::CullResult::Record const &>::_Ranit<Ogre::CullResult::Record,int,Ogre::CullResult::Record const *,Ogre::CullResult::Record const &>
_TEXT	ENDS
PUBLIC	??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@PAVEffectObject@Ogre@@HPBQAV34@ABQAV34@V_Iterator_base_aux@2@@std@@QAE@XZ ; std::_Iterator_with_base<std::random_access_iterator_tag,Ogre::EffectObject *,int,Ogre::EffectObject * const *,Ogre::EffectObject * const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,Ogre::EffectObject *,int,Ogre::EffectObject * const *,Ogre::EffectObject * const &,std::_Iterator_base_aux>
; Function compile flags: /Odtp
;	COMDAT ??0?$_Ranit@PAVEffectObject@Ogre@@HPBQAV12@ABQAV12@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Ranit@PAVEffectObject@Ogre@@HPBQAV12@ABQAV12@@std@@QAE@XZ PROC ; std::_Ranit<Ogre::EffectObject *,int,Ogre::EffectObject * const *,Ogre::EffectObject * const &>::_Ranit<Ogre::EffectObject *,int,Ogre::EffectObject * const *,Ogre::EffectObject * const &>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@PAVEffectObject@Ogre@@HPBQAV34@ABQAV34@V_Iterator_base_aux@2@@std@@QAE@XZ
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Ranit@PAVEffectObject@Ogre@@HPBQAV12@ABQAV12@@std@@QAE@XZ ENDP ; std::_Ranit<Ogre::EffectObject *,int,Ogre::EffectObject * const *,Ogre::EffectObject * const &>::_Ranit<Ogre::EffectObject *,int,Ogre::EffectObject * const *,Ogre::EffectObject * const &>
_TEXT	ENDS
PUBLIC	??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@PAVSoundNode@Ogre@@HPBQAV34@ABQAV34@V_Iterator_base_aux@2@@std@@QAE@XZ ; std::_Iterator_with_base<std::random_access_iterator_tag,Ogre::SoundNode *,int,Ogre::SoundNode * const *,Ogre::SoundNode * const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,Ogre::SoundNode *,int,Ogre::SoundNode * const *,Ogre::SoundNode * const &,std::_Iterator_base_aux>
; Function compile flags: /Odtp
;	COMDAT ??0?$_Ranit@PAVSoundNode@Ogre@@HPBQAV12@ABQAV12@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Ranit@PAVSoundNode@Ogre@@HPBQAV12@ABQAV12@@std@@QAE@XZ PROC ; std::_Ranit<Ogre::SoundNode *,int,Ogre::SoundNode * const *,Ogre::SoundNode * const &>::_Ranit<Ogre::SoundNode *,int,Ogre::SoundNode * const *,Ogre::SoundNode * const &>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@PAVSoundNode@Ogre@@HPBQAV34@ABQAV34@V_Iterator_base_aux@2@@std@@QAE@XZ
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Ranit@PAVSoundNode@Ogre@@HPBQAV12@ABQAV12@@std@@QAE@XZ ENDP ; std::_Ranit<Ogre::SoundNode *,int,Ogre::SoundNode * const *,Ogre::SoundNode * const &>::_Ranit<Ogre::SoundNode *,int,Ogre::SoundNode * const *,Ogre::SoundNode * const &>
_TEXT	ENDS
PUBLIC	??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@PAVRenderableObject@Ogre@@HPBQAV34@ABQAV34@V_Iterator_base_aux@2@@std@@QAE@XZ ; std::_Iterator_with_base<std::random_access_iterator_tag,Ogre::RenderableObject *,int,Ogre::RenderableObject * const *,Ogre::RenderableObject * const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,Ogre::RenderableObject *,int,Ogre::RenderableObject * const *,Ogre::RenderableObject * const &,std::_Iterator_base_aux>
; Function compile flags: /Odtp
;	COMDAT ??0?$_Ranit@PAVRenderableObject@Ogre@@HPBQAV12@ABQAV12@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Ranit@PAVRenderableObject@Ogre@@HPBQAV12@ABQAV12@@std@@QAE@XZ PROC ; std::_Ranit<Ogre::RenderableObject *,int,Ogre::RenderableObject * const *,Ogre::RenderableObject * const &>::_Ranit<Ogre::RenderableObject *,int,Ogre::RenderableObject * const *,Ogre::RenderableObject * const &>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@PAVRenderableObject@Ogre@@HPBQAV34@ABQAV34@V_Iterator_base_aux@2@@std@@QAE@XZ
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Ranit@PAVRenderableObject@Ogre@@HPBQAV12@ABQAV12@@std@@QAE@XZ ENDP ; std::_Ranit<Ogre::RenderableObject *,int,Ogre::RenderableObject * const *,Ogre::RenderableObject * const &>::_Ranit<Ogre::RenderableObject *,int,Ogre::RenderableObject * const *,Ogre::RenderableObject * const &>
_TEXT	ENDS
PUBLIC	??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@PAVLight@Ogre@@HPBQAV34@ABQAV34@V_Iterator_base_aux@2@@std@@QAE@XZ ; std::_Iterator_with_base<std::random_access_iterator_tag,Ogre::Light *,int,Ogre::Light * const *,Ogre::Light * const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,Ogre::Light *,int,Ogre::Light * const *,Ogre::Light * const &,std::_Iterator_base_aux>
; Function compile flags: /Odtp
;	COMDAT ??0?$_Ranit@PAVLight@Ogre@@HPBQAV12@ABQAV12@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Ranit@PAVLight@Ogre@@HPBQAV12@ABQAV12@@std@@QAE@XZ PROC ; std::_Ranit<Ogre::Light *,int,Ogre::Light * const *,Ogre::Light * const &>::_Ranit<Ogre::Light *,int,Ogre::Light * const *,Ogre::Light * const &>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@PAVLight@Ogre@@HPBQAV34@ABQAV34@V_Iterator_base_aux@2@@std@@QAE@XZ
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Ranit@PAVLight@Ogre@@HPBQAV12@ABQAV12@@std@@QAE@XZ ENDP ; std::_Ranit<Ogre::Light *,int,Ogre::Light * const *,Ogre::Light * const &>::_Ranit<Ogre::Light *,int,Ogre::Light * const *,Ogre::Light * const &>
_TEXT	ENDS
PUBLIC	??0_Iterator_base_aux@std@@QAE@XZ		; std::_Iterator_base_aux::_Iterator_base_aux
; Function compile flags: /Odtp
;	COMDAT ??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@UAnimRange@BaseKeyFrameArray@Ogre@@HPBU345@ABU345@V_Iterator_base_aux@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@UAnimRange@BaseKeyFrameArray@Ogre@@HPBU345@ABU345@V_Iterator_base_aux@2@@std@@QAE@XZ PROC ; std::_Iterator_with_base<std::random_access_iterator_tag,Ogre::BaseKeyFrameArray::AnimRange,int,Ogre::BaseKeyFrameArray::AnimRange const *,Ogre::BaseKeyFrameArray::AnimRange const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,Ogre::BaseKeyFrameArray::AnimRange,int,Ogre::BaseKeyFrameArray::AnimRange const *,Ogre::BaseKeyFrameArray::AnimRange const &,std::_Iterator_base_aux>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Iterator_base_aux@std@@QAE@XZ	; std::_Iterator_base_aux::_Iterator_base_aux
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@UAnimRange@BaseKeyFrameArray@Ogre@@HPBU345@ABU345@V_Iterator_base_aux@2@@std@@QAE@XZ ENDP ; std::_Iterator_with_base<std::random_access_iterator_tag,Ogre::BaseKeyFrameArray::AnimRange,int,Ogre::BaseKeyFrameArray::AnimRange const *,Ogre::BaseKeyFrameArray::AnimRange const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,Ogre::BaseKeyFrameArray::AnimRange,int,Ogre::BaseKeyFrameArray::AnimRange const *,Ogre::BaseKeyFrameArray::AnimRange const &,std::_Iterator_base_aux>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??0_Iterator_base_aux@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_Iterator_base_aux@std@@QAE@XZ PROC			; std::_Iterator_base_aux::_Iterator_base_aux, COMDAT
; _this$ = ecx

; 448  : 	_Iterator_base_aux()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0_Iterator_base_aux@std@@QAE@XZ ENDP			; std::_Iterator_base_aux::_Iterator_base_aux
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@HPBU345@ABU345@V_Iterator_base_aux@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@HPBU345@ABU345@V_Iterator_base_aux@2@@std@@QAE@XZ PROC ; std::_Iterator_with_base<std::random_access_iterator_tag,Ogre::KeyFrameArray<float>::KEYFRAME_T,int,Ogre::KeyFrameArray<float>::KEYFRAME_T const *,Ogre::KeyFrameArray<float>::KEYFRAME_T const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,Ogre::KeyFrameArray<float>::KEYFRAME_T,int,Ogre::KeyFrameArray<float>::KEYFRAME_T const *,Ogre::KeyFrameArray<float>::KEYFRAME_T const &,std::_Iterator_base_aux>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Iterator_base_aux@std@@QAE@XZ	; std::_Iterator_base_aux::_Iterator_base_aux
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@HPBU345@ABU345@V_Iterator_base_aux@2@@std@@QAE@XZ ENDP ; std::_Iterator_with_base<std::random_access_iterator_tag,Ogre::KeyFrameArray<float>::KEYFRAME_T,int,Ogre::KeyFrameArray<float>::KEYFRAME_T const *,Ogre::KeyFrameArray<float>::KEYFRAME_T const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,Ogre::KeyFrameArray<float>::KEYFRAME_T,int,Ogre::KeyFrameArray<float>::KEYFRAME_T const *,Ogre::KeyFrameArray<float>::KEYFRAME_T const &,std::_Iterator_base_aux>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@HPBU345@ABU345@V_Iterator_base_aux@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@HPBU345@ABU345@V_Iterator_base_aux@2@@std@@QAE@XZ PROC ; std::_Iterator_with_base<std::random_access_iterator_tag,Ogre::KeyFrameArray<float>::CONTROL_POINT_T,int,Ogre::KeyFrameArray<float>::CONTROL_POINT_T const *,Ogre::KeyFrameArray<float>::CONTROL_POINT_T const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,Ogre::KeyFrameArray<float>::CONTROL_POINT_T,int,Ogre::KeyFrameArray<float>::CONTROL_POINT_T const *,Ogre::KeyFrameArray<float>::CONTROL_POINT_T const &,std::_Iterator_base_aux>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Iterator_base_aux@std@@QAE@XZ	; std::_Iterator_base_aux::_Iterator_base_aux
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@HPBU345@ABU345@V_Iterator_base_aux@2@@std@@QAE@XZ ENDP ; std::_Iterator_with_base<std::random_access_iterator_tag,Ogre::KeyFrameArray<float>::CONTROL_POINT_T,int,Ogre::KeyFrameArray<float>::CONTROL_POINT_T const *,Ogre::KeyFrameArray<float>::CONTROL_POINT_T const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,Ogre::KeyFrameArray<float>::CONTROL_POINT_T,int,Ogre::KeyFrameArray<float>::CONTROL_POINT_T const *,Ogre::KeyFrameArray<float>::CONTROL_POINT_T const &,std::_Iterator_base_aux>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@HPBU345@ABU345@V_Iterator_base_aux@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@HPBU345@ABU345@V_Iterator_base_aux@2@@std@@QAE@XZ PROC ; std::_Iterator_with_base<std::random_access_iterator_tag,Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,int,Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T const *,Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,int,Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T const *,Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T const &,std::_Iterator_base_aux>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Iterator_base_aux@std@@QAE@XZ	; std::_Iterator_base_aux::_Iterator_base_aux
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@HPBU345@ABU345@V_Iterator_base_aux@2@@std@@QAE@XZ ENDP ; std::_Iterator_with_base<std::random_access_iterator_tag,Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,int,Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T const *,Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,int,Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T const *,Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T const &,std::_Iterator_base_aux>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@HPBU345@ABU345@V_Iterator_base_aux@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@HPBU345@ABU345@V_Iterator_base_aux@2@@std@@QAE@XZ PROC ; std::_Iterator_with_base<std::random_access_iterator_tag,Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,int,Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T const *,Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,int,Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T const *,Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T const &,std::_Iterator_base_aux>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Iterator_base_aux@std@@QAE@XZ	; std::_Iterator_base_aux::_Iterator_base_aux
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@HPBU345@ABU345@V_Iterator_base_aux@2@@std@@QAE@XZ ENDP ; std::_Iterator_with_base<std::random_access_iterator_tag,Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,int,Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T const *,Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,int,Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T const *,Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T const &,std::_Iterator_base_aux>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@PAVShaderContext@Ogre@@HPBQAV34@ABQAV34@V_Iterator_base_aux@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@PAVShaderContext@Ogre@@HPBQAV34@ABQAV34@V_Iterator_base_aux@2@@std@@QAE@XZ PROC ; std::_Iterator_with_base<std::random_access_iterator_tag,Ogre::ShaderContext *,int,Ogre::ShaderContext * const *,Ogre::ShaderContext * const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,Ogre::ShaderContext *,int,Ogre::ShaderContext * const *,Ogre::ShaderContext * const &,std::_Iterator_base_aux>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Iterator_base_aux@std@@QAE@XZ	; std::_Iterator_base_aux::_Iterator_base_aux
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@PAVShaderContext@Ogre@@HPBQAV34@ABQAV34@V_Iterator_base_aux@2@@std@@QAE@XZ ENDP ; std::_Iterator_with_base<std::random_access_iterator_tag,Ogre::ShaderContext *,int,Ogre::ShaderContext * const *,Ogre::ShaderContext * const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,Ogre::ShaderContext *,int,Ogre::ShaderContext * const *,Ogre::ShaderContext * const &,std::_Iterator_base_aux>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@UContextQueDesc@Ogre@@HPBU34@ABU34@V_Iterator_base_aux@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@UContextQueDesc@Ogre@@HPBU34@ABU34@V_Iterator_base_aux@2@@std@@QAE@XZ PROC ; std::_Iterator_with_base<std::random_access_iterator_tag,Ogre::ContextQueDesc,int,Ogre::ContextQueDesc const *,Ogre::ContextQueDesc const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,Ogre::ContextQueDesc,int,Ogre::ContextQueDesc const *,Ogre::ContextQueDesc const &,std::_Iterator_base_aux>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Iterator_base_aux@std@@QAE@XZ	; std::_Iterator_base_aux::_Iterator_base_aux
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@UContextQueDesc@Ogre@@HPBU34@ABU34@V_Iterator_base_aux@2@@std@@QAE@XZ ENDP ; std::_Iterator_with_base<std::random_access_iterator_tag,Ogre::ContextQueDesc,int,Ogre::ContextQueDesc const *,Ogre::ContextQueDesc const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,Ogre::ContextQueDesc,int,Ogre::ContextQueDesc const *,Ogre::ContextQueDesc const &,std::_Iterator_base_aux>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@EHPBEABEV_Iterator_base_aux@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@EHPBEABEV_Iterator_base_aux@2@@std@@QAE@XZ PROC ; std::_Iterator_with_base<std::random_access_iterator_tag,unsigned char,int,unsigned char const *,unsigned char const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,unsigned char,int,unsigned char const *,unsigned char const &,std::_Iterator_base_aux>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Iterator_base_aux@std@@QAE@XZ	; std::_Iterator_base_aux::_Iterator_base_aux
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@EHPBEABEV_Iterator_base_aux@2@@std@@QAE@XZ ENDP ; std::_Iterator_with_base<std::random_access_iterator_tag,unsigned char,int,unsigned char const *,unsigned char const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,unsigned char,int,unsigned char const *,unsigned char const &,std::_Iterator_base_aux>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@UValueParam@ShaderContextPool@Ogre@@HPBU345@ABU345@V_Iterator_base_aux@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@UValueParam@ShaderContextPool@Ogre@@HPBU345@ABU345@V_Iterator_base_aux@2@@std@@QAE@XZ PROC ; std::_Iterator_with_base<std::random_access_iterator_tag,Ogre::ShaderContextPool::ValueParam,int,Ogre::ShaderContextPool::ValueParam const *,Ogre::ShaderContextPool::ValueParam const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,Ogre::ShaderContextPool::ValueParam,int,Ogre::ShaderContextPool::ValueParam const *,Ogre::ShaderContextPool::ValueParam const &,std::_Iterator_base_aux>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Iterator_base_aux@std@@QAE@XZ	; std::_Iterator_base_aux::_Iterator_base_aux
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@UValueParam@ShaderContextPool@Ogre@@HPBU345@ABU345@V_Iterator_base_aux@2@@std@@QAE@XZ ENDP ; std::_Iterator_with_base<std::random_access_iterator_tag,Ogre::ShaderContextPool::ValueParam,int,Ogre::ShaderContextPool::ValueParam const *,Ogre::ShaderContextPool::ValueParam const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,Ogre::ShaderContextPool::ValueParam,int,Ogre::ShaderContextPool::ValueParam const *,Ogre::ShaderContextPool::ValueParam const &,std::_Iterator_base_aux>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@UTexParam@ShaderContextPool@Ogre@@HPBU345@ABU345@V_Iterator_base_aux@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@UTexParam@ShaderContextPool@Ogre@@HPBU345@ABU345@V_Iterator_base_aux@2@@std@@QAE@XZ PROC ; std::_Iterator_with_base<std::random_access_iterator_tag,Ogre::ShaderContextPool::TexParam,int,Ogre::ShaderContextPool::TexParam const *,Ogre::ShaderContextPool::TexParam const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,Ogre::ShaderContextPool::TexParam,int,Ogre::ShaderContextPool::TexParam const *,Ogre::ShaderContextPool::TexParam const &,std::_Iterator_base_aux>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Iterator_base_aux@std@@QAE@XZ	; std::_Iterator_base_aux::_Iterator_base_aux
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@UTexParam@ShaderContextPool@Ogre@@HPBU345@ABU345@V_Iterator_base_aux@2@@std@@QAE@XZ ENDP ; std::_Iterator_with_base<std::random_access_iterator_tag,Ogre::ShaderContextPool::TexParam,int,Ogre::ShaderContextPool::TexParam const *,Ogre::ShaderContextPool::TexParam const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,Ogre::ShaderContextPool::TexParam,int,Ogre::ShaderContextPool::TexParam const *,Ogre::ShaderContextPool::TexParam const &,std::_Iterator_base_aux>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@DHPBDABDV_Iterator_base_aux@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@DHPBDABDV_Iterator_base_aux@2@@std@@QAE@XZ PROC ; std::_Iterator_with_base<std::random_access_iterator_tag,char,int,char const *,char const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,char,int,char const *,char const &,std::_Iterator_base_aux>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Iterator_base_aux@std@@QAE@XZ	; std::_Iterator_base_aux::_Iterator_base_aux
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@DHPBDABDV_Iterator_base_aux@2@@std@@QAE@XZ ENDP ; std::_Iterator_with_base<std::random_access_iterator_tag,char,int,char const *,char const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,char,int,char const *,char const &,std::_Iterator_base_aux>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@PAVSurfaceData@Ogre@@HPBQAV34@ABQAV34@V_Iterator_base_aux@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@PAVSurfaceData@Ogre@@HPBQAV34@ABQAV34@V_Iterator_base_aux@2@@std@@QAE@XZ PROC ; std::_Iterator_with_base<std::random_access_iterator_tag,Ogre::SurfaceData *,int,Ogre::SurfaceData * const *,Ogre::SurfaceData * const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,Ogre::SurfaceData *,int,Ogre::SurfaceData * const *,Ogre::SurfaceData * const &,std::_Iterator_base_aux>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Iterator_base_aux@std@@QAE@XZ	; std::_Iterator_base_aux::_Iterator_base_aux
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@PAVSurfaceData@Ogre@@HPBQAV34@ABQAV34@V_Iterator_base_aux@2@@std@@QAE@XZ ENDP ; std::_Iterator_with_base<std::random_access_iterator_tag,Ogre::SurfaceData *,int,Ogre::SurfaceData * const *,Ogre::SurfaceData * const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,Ogre::SurfaceData *,int,Ogre::SurfaceData * const *,Ogre::SurfaceData * const &,std::_Iterator_base_aux>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@URecord@CullResult@Ogre@@HPBU345@ABU345@V_Iterator_base_aux@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@URecord@CullResult@Ogre@@HPBU345@ABU345@V_Iterator_base_aux@2@@std@@QAE@XZ PROC ; std::_Iterator_with_base<std::random_access_iterator_tag,Ogre::CullResult::Record,int,Ogre::CullResult::Record const *,Ogre::CullResult::Record const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,Ogre::CullResult::Record,int,Ogre::CullResult::Record const *,Ogre::CullResult::Record const &,std::_Iterator_base_aux>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Iterator_base_aux@std@@QAE@XZ	; std::_Iterator_base_aux::_Iterator_base_aux
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@URecord@CullResult@Ogre@@HPBU345@ABU345@V_Iterator_base_aux@2@@std@@QAE@XZ ENDP ; std::_Iterator_with_base<std::random_access_iterator_tag,Ogre::CullResult::Record,int,Ogre::CullResult::Record const *,Ogre::CullResult::Record const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,Ogre::CullResult::Record,int,Ogre::CullResult::Record const *,Ogre::CullResult::Record const &,std::_Iterator_base_aux>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@PAVEffectObject@Ogre@@HPBQAV34@ABQAV34@V_Iterator_base_aux@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@PAVEffectObject@Ogre@@HPBQAV34@ABQAV34@V_Iterator_base_aux@2@@std@@QAE@XZ PROC ; std::_Iterator_with_base<std::random_access_iterator_tag,Ogre::EffectObject *,int,Ogre::EffectObject * const *,Ogre::EffectObject * const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,Ogre::EffectObject *,int,Ogre::EffectObject * const *,Ogre::EffectObject * const &,std::_Iterator_base_aux>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Iterator_base_aux@std@@QAE@XZ	; std::_Iterator_base_aux::_Iterator_base_aux
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@PAVEffectObject@Ogre@@HPBQAV34@ABQAV34@V_Iterator_base_aux@2@@std@@QAE@XZ ENDP ; std::_Iterator_with_base<std::random_access_iterator_tag,Ogre::EffectObject *,int,Ogre::EffectObject * const *,Ogre::EffectObject * const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,Ogre::EffectObject *,int,Ogre::EffectObject * const *,Ogre::EffectObject * const &,std::_Iterator_base_aux>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@PAVSoundNode@Ogre@@HPBQAV34@ABQAV34@V_Iterator_base_aux@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@PAVSoundNode@Ogre@@HPBQAV34@ABQAV34@V_Iterator_base_aux@2@@std@@QAE@XZ PROC ; std::_Iterator_with_base<std::random_access_iterator_tag,Ogre::SoundNode *,int,Ogre::SoundNode * const *,Ogre::SoundNode * const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,Ogre::SoundNode *,int,Ogre::SoundNode * const *,Ogre::SoundNode * const &,std::_Iterator_base_aux>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Iterator_base_aux@std@@QAE@XZ	; std::_Iterator_base_aux::_Iterator_base_aux
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@PAVSoundNode@Ogre@@HPBQAV34@ABQAV34@V_Iterator_base_aux@2@@std@@QAE@XZ ENDP ; std::_Iterator_with_base<std::random_access_iterator_tag,Ogre::SoundNode *,int,Ogre::SoundNode * const *,Ogre::SoundNode * const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,Ogre::SoundNode *,int,Ogre::SoundNode * const *,Ogre::SoundNode * const &,std::_Iterator_base_aux>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@PAVRenderableObject@Ogre@@HPBQAV34@ABQAV34@V_Iterator_base_aux@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@PAVRenderableObject@Ogre@@HPBQAV34@ABQAV34@V_Iterator_base_aux@2@@std@@QAE@XZ PROC ; std::_Iterator_with_base<std::random_access_iterator_tag,Ogre::RenderableObject *,int,Ogre::RenderableObject * const *,Ogre::RenderableObject * const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,Ogre::RenderableObject *,int,Ogre::RenderableObject * const *,Ogre::RenderableObject * const &,std::_Iterator_base_aux>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Iterator_base_aux@std@@QAE@XZ	; std::_Iterator_base_aux::_Iterator_base_aux
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@PAVRenderableObject@Ogre@@HPBQAV34@ABQAV34@V_Iterator_base_aux@2@@std@@QAE@XZ ENDP ; std::_Iterator_with_base<std::random_access_iterator_tag,Ogre::RenderableObject *,int,Ogre::RenderableObject * const *,Ogre::RenderableObject * const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,Ogre::RenderableObject *,int,Ogre::RenderableObject * const *,Ogre::RenderableObject * const &,std::_Iterator_base_aux>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@PAVLight@Ogre@@HPBQAV34@ABQAV34@V_Iterator_base_aux@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@PAVLight@Ogre@@HPBQAV34@ABQAV34@V_Iterator_base_aux@2@@std@@QAE@XZ PROC ; std::_Iterator_with_base<std::random_access_iterator_tag,Ogre::Light *,int,Ogre::Light * const *,Ogre::Light * const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,Ogre::Light *,int,Ogre::Light * const *,Ogre::Light * const &,std::_Iterator_base_aux>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Iterator_base_aux@std@@QAE@XZ	; std::_Iterator_base_aux::_Iterator_base_aux
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@PAVLight@Ogre@@HPBQAV34@ABQAV34@V_Iterator_base_aux@2@@std@@QAE@XZ ENDP ; std::_Iterator_with_base<std::random_access_iterator_tag,Ogre::Light *,int,Ogre::Light * const *,Ogre::Light * const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,Ogre::Light *,int,Ogre::Light * const *,Ogre::Light * const &,std::_Iterator_base_aux>
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAE@PAUAnimRange@BaseKeyFrameArray@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::_Vector_iterator<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?begin@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@2@XZ PROC ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::begin, COMDAT
; _this$ = ecx

; 640  : 		{	// return iterator for beginning of mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 641  : 		return (iterator(_Myfirst, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAE@PAUAnimRange@BaseKeyFrameArray@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::_Vector_iterator<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 642  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?begin@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@2@XZ ENDP ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::begin
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?end@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@2@XZ PROC ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::end, COMDAT
; _this$ = ecx

; 650  : 		{	// return iterator for end of mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 651  : 		return (iterator(_Mylast, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAE@PAUAnimRange@BaseKeyFrameArray@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::_Vector_iterator<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 652  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?end@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@2@XZ ENDP ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::end
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::operator!=
PUBLIC	?_Make_iter@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@2@V?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@2@@Z ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::_Make_iter
; Function compile flags: /Odtp
;	COMDAT ?erase@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@2@V?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@2@0@Z
_TEXT	SEGMENT
_this$ = -24						; size = 4
__Ptr$78622 = -20					; size = 4
__Last$ = -16						; size = 8
__First$ = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 8
__Last_arg$ = 20					; size = 8
?erase@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@2@V?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@2@0@Z PROC ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::erase, COMDAT
; _this$ = ecx

; 1028 : 		{	// erase [_First, _Last)

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	eax, DWORD PTR __First_arg$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __First_arg$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Make_iter@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@2@V?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@2@@Z ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::_Make_iter

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);

	mov	eax, DWORD PTR __Last_arg$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __Last_arg$[ebp]
	push	ecx
	lea	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Make_iter@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@2@V?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@2@@Z ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::_Make_iter

; 1031 : 
; 1032 : 		if (_First != _Last)

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	call	??9?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::operator!=
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@erase@15

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	edx, DWORD PTR __First$[ebp+4]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp+4]
	push	edx
	call	??$unchecked_copy@PAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@@stdext@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@00@Z ; stdext::unchecked_copy<Ogre::BaseKeyFrameArray::AnimRange *,Ogre::BaseKeyFrameArray::AnimRange *>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR __Ptr$78622[ebp], eax

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Ptr$78622[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAEXPAUAnimRange@BaseKeyFrameArray@Ogre@@0@Z ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::_Destroy

; 1049 : 			_Mylast = _Ptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Ptr$78622[ebp]
	mov	DWORD PTR [eax+16], ecx
$LN1@erase@15:

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);

	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR __First$[ebp+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1055 : #endif
; 1056 : 		}

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?erase@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@2@V?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@2@0@Z ENDP ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::erase
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@QBEIXZ
_TEXT	SEGMENT
tv65 = -12						; size = 4
_this$ = -8						; size = 4
__Count$ = -4						; size = 4
?max_size@?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@QBEIXZ PROC ; std::allocator<Ogre::BaseKeyFrameArray::AnimRange>::max_size, COMDAT
; _this$ = ecx

; 164  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);

	mov	DWORD PTR __Count$[ebp], 536870911	; 1fffffffH

; 166  : 		return (0 < _Count ? _Count : 1);

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN3@max_size
	mov	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR tv65[ebp], eax
	jmp	SHORT $LN4@max_size
$LN3@max_size:
	mov	DWORD PTR tv65[ebp], 1
$LN4@max_size:
	mov	eax, DWORD PTR tv65[ebp]

; 167  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@QBEIXZ ENDP ; std::allocator<Ogre::BaseKeyFrameArray::AnimRange>::max_size
_TEXT	ENDS
PUBLIC	??$_Allocate@V_Aux_cont@std@@@std@@YAPAV_Aux_cont@0@IPAV10@@Z ; std::_Allocate<std::_Aux_cont>
; Function compile flags: /Odtp
;	COMDAT ?allocate@?$allocator@V_Aux_cont@std@@@std@@QAEPAV_Aux_cont@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@V_Aux_cont@std@@@std@@QAEPAV_Aux_cont@2@I@Z PROC ; std::allocator<std::_Aux_cont>::allocate, COMDAT
; _this$ = ecx

; 144  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@V_Aux_cont@std@@@std@@YAPAV_Aux_cont@0@IPAV10@@Z ; std::_Allocate<std::_Aux_cont>
	add	esp, 8

; 146  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@V_Aux_cont@std@@@std@@QAEPAV_Aux_cont@2@I@Z ENDP ; std::allocator<std::_Aux_cont>::allocate
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAE@PAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::_Vector_iterator<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?begin@?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@2@XZ PROC ; std::vector<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::begin, COMDAT
; _this$ = ecx

; 640  : 		{	// return iterator for beginning of mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 641  : 		return (iterator(_Myfirst, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAE@PAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::_Vector_iterator<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 642  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?begin@?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@2@XZ ENDP ; std::vector<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::begin
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?end@?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@2@XZ PROC ; std::vector<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::end, COMDAT
; _this$ = ecx

; 650  : 		{	// return iterator for end of mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 651  : 		return (iterator(_Mylast, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAE@PAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::_Vector_iterator<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 652  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?end@?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@2@XZ ENDP ; std::vector<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::end
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::operator!=
PUBLIC	?_Make_iter@?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@2@V?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@2@@Z ; std::vector<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::_Make_iter
; Function compile flags: /Odtp
;	COMDAT ?erase@?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@2@V?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@2@0@Z
_TEXT	SEGMENT
_this$ = -24						; size = 4
__Ptr$78652 = -20					; size = 4
__Last$ = -16						; size = 8
__First$ = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 8
__Last_arg$ = 20					; size = 8
?erase@?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@2@V?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@2@0@Z PROC ; std::vector<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::erase, COMDAT
; _this$ = ecx

; 1028 : 		{	// erase [_First, _Last)

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	eax, DWORD PTR __First_arg$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __First_arg$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Make_iter@?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@2@V?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@2@@Z ; std::vector<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::_Make_iter

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);

	mov	eax, DWORD PTR __Last_arg$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __Last_arg$[ebp]
	push	ecx
	lea	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Make_iter@?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@2@V?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@2@@Z ; std::vector<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::_Make_iter

; 1031 : 
; 1032 : 		if (_First != _Last)

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	call	??9?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::operator!=
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@erase@16

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	edx, DWORD PTR __First$[ebp+4]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp+4]
	push	edx
	call	??$unchecked_copy@PAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU123@@stdext@@YAPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU123@00@Z ; stdext::unchecked_copy<Ogre::KeyFrameArray<float>::KEYFRAME_T *,Ogre::KeyFrameArray<float>::KEYFRAME_T *>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR __Ptr$78652[ebp], eax

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Ptr$78652[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAEXPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@0@Z ; std::vector<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::_Destroy

; 1049 : 			_Mylast = _Ptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Ptr$78652[ebp]
	mov	DWORD PTR [eax+16], ecx
$LN1@erase@16:

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);

	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR __First$[ebp+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1055 : #endif
; 1056 : 		}

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?erase@?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@2@V?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@2@0@Z ENDP ; std::vector<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::erase
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@QBEIXZ
_TEXT	SEGMENT
tv65 = -12						; size = 4
_this$ = -8						; size = 4
__Count$ = -4						; size = 4
?max_size@?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@QBEIXZ PROC ; std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T>::max_size, COMDAT
; _this$ = ecx

; 164  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);

	mov	DWORD PTR __Count$[ebp], 536870911	; 1fffffffH

; 166  : 		return (0 < _Count ? _Count : 1);

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN3@max_size@2
	mov	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR tv65[ebp], eax
	jmp	SHORT $LN4@max_size@2
$LN3@max_size@2:
	mov	DWORD PTR tv65[ebp], 1
$LN4@max_size@2:
	mov	eax, DWORD PTR tv65[ebp]

; 167  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@QBEIXZ ENDP ; std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T>::max_size
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAE@PAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::_Vector_iterator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?begin@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@2@XZ PROC ; std::vector<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::begin, COMDAT
; _this$ = ecx

; 640  : 		{	// return iterator for beginning of mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 641  : 		return (iterator(_Myfirst, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAE@PAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::_Vector_iterator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 642  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?begin@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@2@XZ ENDP ; std::vector<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::begin
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?end@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@2@XZ PROC ; std::vector<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::end, COMDAT
; _this$ = ecx

; 650  : 		{	// return iterator for end of mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 651  : 		return (iterator(_Mylast, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAE@PAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::_Vector_iterator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 652  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?end@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@2@XZ ENDP ; std::vector<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::end
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::operator!=
PUBLIC	?_Make_iter@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@2@V?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@2@@Z ; std::vector<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::_Make_iter
; Function compile flags: /Odtp
;	COMDAT ?erase@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@2@V?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@2@0@Z
_TEXT	SEGMENT
_this$ = -24						; size = 4
__Ptr$78674 = -20					; size = 4
__Last$ = -16						; size = 8
__First$ = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 8
__Last_arg$ = 20					; size = 8
?erase@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@2@V?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@2@0@Z PROC ; std::vector<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::erase, COMDAT
; _this$ = ecx

; 1028 : 		{	// erase [_First, _Last)

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	eax, DWORD PTR __First_arg$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __First_arg$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Make_iter@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@2@V?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@2@@Z ; std::vector<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::_Make_iter

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);

	mov	eax, DWORD PTR __Last_arg$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __Last_arg$[ebp]
	push	ecx
	lea	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Make_iter@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@2@V?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@2@@Z ; std::vector<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::_Make_iter

; 1031 : 
; 1032 : 		if (_First != _Last)

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	call	??9?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::operator!=
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@erase@17

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	edx, DWORD PTR __First$[ebp+4]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp+4]
	push	edx
	call	??$unchecked_copy@PAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU123@@stdext@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU123@00@Z ; stdext::unchecked_copy<Ogre::KeyFrameArray<float>::CONTROL_POINT_T *,Ogre::KeyFrameArray<float>::CONTROL_POINT_T *>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR __Ptr$78674[ebp], eax

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Ptr$78674[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAEXPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@0@Z ; std::vector<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::_Destroy

; 1049 : 			_Mylast = _Ptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Ptr$78674[ebp]
	mov	DWORD PTR [eax+16], ecx
$LN1@erase@17:

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);

	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR __First$[ebp+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1055 : #endif
; 1056 : 		}

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?erase@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@2@V?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@2@0@Z ENDP ; std::vector<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::erase
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@QBEIXZ
_TEXT	SEGMENT
tv65 = -12						; size = 4
_this$ = -8						; size = 4
__Count$ = -4						; size = 4
?max_size@?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@QBEIXZ PROC ; std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T>::max_size, COMDAT
; _this$ = ecx

; 164  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);

	mov	DWORD PTR __Count$[ebp], 536870911	; 1fffffffH

; 166  : 		return (0 < _Count ? _Count : 1);

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN3@max_size@3
	mov	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR tv65[ebp], eax
	jmp	SHORT $LN4@max_size@3
$LN3@max_size@3:
	mov	DWORD PTR tv65[ebp], 1
$LN4@max_size@3:
	mov	eax, DWORD PTR tv65[ebp]

; 167  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@QBEIXZ ENDP ; std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T>::max_size
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAE@PAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::_Vector_iterator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?begin@?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@2@XZ PROC ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::begin, COMDAT
; _this$ = ecx

; 640  : 		{	// return iterator for beginning of mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 641  : 		return (iterator(_Myfirst, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAE@PAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::_Vector_iterator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 642  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?begin@?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@2@XZ ENDP ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::begin
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?end@?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@2@XZ PROC ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::end, COMDAT
; _this$ = ecx

; 650  : 		{	// return iterator for end of mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 651  : 		return (iterator(_Mylast, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAE@PAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::_Vector_iterator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 652  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?end@?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@2@XZ ENDP ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::end
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::operator!=
PUBLIC	?_Make_iter@?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@2@V?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@2@@Z ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::_Make_iter
; Function compile flags: /Odtp
;	COMDAT ?erase@?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@2@V?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@2@0@Z
_TEXT	SEGMENT
_this$ = -24						; size = 4
__Ptr$78696 = -20					; size = 4
__Last$ = -16						; size = 8
__First$ = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 8
__Last_arg$ = 20					; size = 8
?erase@?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@2@V?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@2@0@Z PROC ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::erase, COMDAT
; _this$ = ecx

; 1028 : 		{	// erase [_First, _Last)

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	eax, DWORD PTR __First_arg$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __First_arg$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Make_iter@?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@2@V?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@2@@Z ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::_Make_iter

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);

	mov	eax, DWORD PTR __Last_arg$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __Last_arg$[ebp]
	push	ecx
	lea	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Make_iter@?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@2@V?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@2@@Z ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::_Make_iter

; 1031 : 
; 1032 : 		if (_First != _Last)

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	call	??9?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::operator!=
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@erase@18

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	edx, DWORD PTR __First$[ebp+4]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp+4]
	push	edx
	call	??$unchecked_copy@PAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@@stdext@@YAPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@00@Z ; stdext::unchecked_copy<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T *>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR __Ptr$78696[ebp], eax

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Ptr$78696[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAEXPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@0@Z ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::_Destroy

; 1049 : 			_Mylast = _Ptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Ptr$78696[ebp]
	mov	DWORD PTR [eax+16], ecx
$LN1@erase@18:

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);

	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR __First$[ebp+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1055 : #endif
; 1056 : 		}

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?erase@?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@2@V?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@2@0@Z ENDP ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::erase
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@QBEIXZ
_TEXT	SEGMENT
tv65 = -12						; size = 4
_this$ = -8						; size = 4
__Count$ = -4						; size = 4
?max_size@?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@QBEIXZ PROC ; std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T>::max_size, COMDAT
; _this$ = ecx

; 164  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);

	mov	DWORD PTR __Count$[ebp], 214748364	; 0cccccccH

; 166  : 		return (0 < _Count ? _Count : 1);

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN3@max_size@4
	mov	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR tv65[ebp], eax
	jmp	SHORT $LN4@max_size@4
$LN3@max_size@4:
	mov	DWORD PTR tv65[ebp], 1
$LN4@max_size@4:
	mov	eax, DWORD PTR tv65[ebp]

; 167  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@QBEIXZ ENDP ; std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T>::max_size
_TEXT	ENDS
PUBLIC	??0?$_Vector_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAE@PAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::_Vector_iterator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?begin@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@2@XZ PROC ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::begin, COMDAT
; _this$ = ecx

; 640  : 		{	// return iterator for beginning of mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 641  : 		return (iterator(_Myfirst, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAE@PAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::_Vector_iterator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 642  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?begin@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@2@XZ ENDP ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::begin
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?end@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@2@XZ PROC ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::end, COMDAT
; _this$ = ecx

; 650  : 		{	// return iterator for end of mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 651  : 		return (iterator(_Mylast, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAE@PAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::_Vector_iterator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 652  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?end@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@2@XZ ENDP ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::end
_TEXT	ENDS
PUBLIC	??9?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::operator!=
PUBLIC	?_Make_iter@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@2@V?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@2@@Z ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::_Make_iter
; Function compile flags: /Odtp
;	COMDAT ?erase@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@2@V?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@2@0@Z
_TEXT	SEGMENT
_this$ = -24						; size = 4
__Ptr$78718 = -20					; size = 4
__Last$ = -16						; size = 8
__First$ = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 8
__Last_arg$ = 20					; size = 8
?erase@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@2@V?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@2@0@Z PROC ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::erase, COMDAT
; _this$ = ecx

; 1028 : 		{	// erase [_First, _Last)

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	eax, DWORD PTR __First_arg$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __First_arg$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Make_iter@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@2@V?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@2@@Z ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::_Make_iter

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);

	mov	eax, DWORD PTR __Last_arg$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __Last_arg$[ebp]
	push	ecx
	lea	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Make_iter@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@2@V?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@2@@Z ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::_Make_iter

; 1031 : 
; 1032 : 		if (_First != _Last)

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	call	??9?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::operator!=
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@erase@19

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	edx, DWORD PTR __First$[ebp+4]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp+4]
	push	edx
	call	??$unchecked_copy@PAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@@stdext@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@00@Z ; stdext::unchecked_copy<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T *>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR __Ptr$78718[ebp], eax

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Ptr$78718[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAEXPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@0@Z ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::_Destroy

; 1049 : 			_Mylast = _Ptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Ptr$78718[ebp]
	mov	DWORD PTR [eax+16], ecx
$LN1@erase@19:

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);

	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR __First$[ebp+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1055 : #endif
; 1056 : 		}

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?erase@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@2@V?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@2@0@Z ENDP ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::erase
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@QBEIXZ
_TEXT	SEGMENT
tv65 = -12						; size = 4
_this$ = -8						; size = 4
__Count$ = -4						; size = 4
?max_size@?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@QBEIXZ PROC ; std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T>::max_size, COMDAT
; _this$ = ecx

; 164  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);

	mov	DWORD PTR __Count$[ebp], 134217727	; 07ffffffH

; 166  : 		return (0 < _Count ? _Count : 1);

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN3@max_size@5
	mov	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR tv65[ebp], eax
	jmp	SHORT $LN4@max_size@5
$LN3@max_size@5:
	mov	DWORD PTR tv65[ebp], 1
$LN4@max_size@5:
	mov	eax, DWORD PTR tv65[ebp]

; 167  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@QBEIXZ ENDP ; std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T>::max_size
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?_Make_iter@?$vector@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 8
?_Make_iter@?$vector@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@2@@Z PROC ; std::vector<Ogre::ShaderContext *,std::allocator<Ogre::ShaderContext *> >::_Make_iter, COMDAT
; _this$ = ecx

; 660  : 		{	// make iterator from const_iterator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 661  : 		return (iterator(_Where._Myptr, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp+4]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@QAE@PAPAVShaderContext@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::ShaderContext *,std::allocator<Ogre::ShaderContext *> >::_Vector_iterator<Ogre::ShaderContext *,std::allocator<Ogre::ShaderContext *> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 662  : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?_Make_iter@?$vector@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@2@@Z ENDP ; std::vector<Ogre::ShaderContext *,std::allocator<Ogre::ShaderContext *> >::_Make_iter
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@PAVShaderContext@Ogre@@@std@@QBEIXZ
_TEXT	SEGMENT
tv65 = -12						; size = 4
_this$ = -8						; size = 4
__Count$ = -4						; size = 4
?max_size@?$allocator@PAVShaderContext@Ogre@@@std@@QBEIXZ PROC ; std::allocator<Ogre::ShaderContext *>::max_size, COMDAT
; _this$ = ecx

; 164  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);

	mov	DWORD PTR __Count$[ebp], 1073741823	; 3fffffffH

; 166  : 		return (0 < _Count ? _Count : 1);

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN3@max_size@6
	mov	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR tv65[ebp], eax
	jmp	SHORT $LN4@max_size@6
$LN3@max_size@6:
	mov	DWORD PTR tv65[ebp], 1
$LN4@max_size@6:
	mov	eax, DWORD PTR tv65[ebp]

; 167  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$allocator@PAVShaderContext@Ogre@@@std@@QBEIXZ ENDP ; std::allocator<Ogre::ShaderContext *>::max_size
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?_Make_iter@?$vector@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@2@V?$_Vector_const_iterator@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 8
?_Make_iter@?$vector@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@2@V?$_Vector_const_iterator@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@2@@Z PROC ; std::vector<Ogre::ContextQueDesc,std::allocator<Ogre::ContextQueDesc> >::_Make_iter, COMDAT
; _this$ = ecx

; 660  : 		{	// make iterator from const_iterator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 661  : 		return (iterator(_Where._Myptr, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp+4]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@QAE@PAUContextQueDesc@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::ContextQueDesc,std::allocator<Ogre::ContextQueDesc> >::_Vector_iterator<Ogre::ContextQueDesc,std::allocator<Ogre::ContextQueDesc> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 662  : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?_Make_iter@?$vector@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@2@V?$_Vector_const_iterator@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@2@@Z ENDP ; std::vector<Ogre::ContextQueDesc,std::allocator<Ogre::ContextQueDesc> >::_Make_iter
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@UContextQueDesc@Ogre@@@std@@QBEIXZ
_TEXT	SEGMENT
tv65 = -12						; size = 4
_this$ = -8						; size = 4
__Count$ = -4						; size = 4
?max_size@?$allocator@UContextQueDesc@Ogre@@@std@@QBEIXZ PROC ; std::allocator<Ogre::ContextQueDesc>::max_size, COMDAT
; _this$ = ecx

; 164  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);

	mov	DWORD PTR __Count$[ebp], 27531841	; 01a41a41H

; 166  : 		return (0 < _Count ? _Count : 1);

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN3@max_size@7
	mov	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR tv65[ebp], eax
	jmp	SHORT $LN4@max_size@7
$LN3@max_size@7:
	mov	DWORD PTR tv65[ebp], 1
$LN4@max_size@7:
	mov	eax, DWORD PTR tv65[ebp]

; 167  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$allocator@UContextQueDesc@Ogre@@@std@@QBEIXZ ENDP ; std::allocator<Ogre::ContextQueDesc>::max_size
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?_Make_iter@?$vector@EV?$allocator@E@std@@@std@@QBE?AV?$_Vector_iterator@EV?$allocator@E@std@@@2@V?$_Vector_const_iterator@EV?$allocator@E@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 8
?_Make_iter@?$vector@EV?$allocator@E@std@@@std@@QBE?AV?$_Vector_iterator@EV?$allocator@E@std@@@2@V?$_Vector_const_iterator@EV?$allocator@E@std@@@2@@Z PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::_Make_iter, COMDAT
; _this$ = ecx

; 660  : 		{	// make iterator from const_iterator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 661  : 		return (iterator(_Where._Myptr, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp+4]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@EV?$allocator@E@std@@@std@@QAE@PAEPBV_Container_base_aux@1@@Z ; std::_Vector_iterator<unsigned char,std::allocator<unsigned char> >::_Vector_iterator<unsigned char,std::allocator<unsigned char> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 662  : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?_Make_iter@?$vector@EV?$allocator@E@std@@@std@@QBE?AV?$_Vector_iterator@EV?$allocator@E@std@@@2@V?$_Vector_const_iterator@EV?$allocator@E@std@@@2@@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::_Make_iter
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@E@std@@QBEIXZ
_TEXT	SEGMENT
tv65 = -12						; size = 4
_this$ = -8						; size = 4
__Count$ = -4						; size = 4
?max_size@?$allocator@E@std@@QBEIXZ PROC		; std::allocator<unsigned char>::max_size, COMDAT
; _this$ = ecx

; 164  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);

	mov	DWORD PTR __Count$[ebp], -1

; 166  : 		return (0 < _Count ? _Count : 1);

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN3@max_size@8
	mov	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR tv65[ebp], eax
	jmp	SHORT $LN4@max_size@8
$LN3@max_size@8:
	mov	DWORD PTR tv65[ebp], 1
$LN4@max_size@8:
	mov	eax, DWORD PTR tv65[ebp]

; 167  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$allocator@E@std@@QBEIXZ ENDP		; std::allocator<unsigned char>::max_size
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?_Make_iter@?$vector@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@2@V?$_Vector_const_iterator@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 8
?_Make_iter@?$vector@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@2@V?$_Vector_const_iterator@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@2@@Z PROC ; std::vector<Ogre::ShaderContextPool::ValueParam,std::allocator<Ogre::ShaderContextPool::ValueParam> >::_Make_iter, COMDAT
; _this$ = ecx

; 660  : 		{	// make iterator from const_iterator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 661  : 		return (iterator(_Where._Myptr, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp+4]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@QAE@PAUValueParam@ShaderContextPool@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::ShaderContextPool::ValueParam,std::allocator<Ogre::ShaderContextPool::ValueParam> >::_Vector_iterator<Ogre::ShaderContextPool::ValueParam,std::allocator<Ogre::ShaderContextPool::ValueParam> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 662  : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?_Make_iter@?$vector@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@2@V?$_Vector_const_iterator@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@2@@Z ENDP ; std::vector<Ogre::ShaderContextPool::ValueParam,std::allocator<Ogre::ShaderContextPool::ValueParam> >::_Make_iter
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@QBEIXZ
_TEXT	SEGMENT
tv65 = -12						; size = 4
_this$ = -8						; size = 4
__Count$ = -4						; size = 4
?max_size@?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@QBEIXZ PROC ; std::allocator<Ogre::ShaderContextPool::ValueParam>::max_size, COMDAT
; _this$ = ecx

; 164  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);

	mov	DWORD PTR __Count$[ebp], 268435455	; 0fffffffH

; 166  : 		return (0 < _Count ? _Count : 1);

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN3@max_size@9
	mov	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR tv65[ebp], eax
	jmp	SHORT $LN4@max_size@9
$LN3@max_size@9:
	mov	DWORD PTR tv65[ebp], 1
$LN4@max_size@9:
	mov	eax, DWORD PTR tv65[ebp]

; 167  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@QBEIXZ ENDP ; std::allocator<Ogre::ShaderContextPool::ValueParam>::max_size
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?_Make_iter@?$vector@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@2@V?$_Vector_const_iterator@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 8
?_Make_iter@?$vector@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@2@V?$_Vector_const_iterator@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@2@@Z PROC ; std::vector<Ogre::ShaderContextPool::TexParam,std::allocator<Ogre::ShaderContextPool::TexParam> >::_Make_iter, COMDAT
; _this$ = ecx

; 660  : 		{	// make iterator from const_iterator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 661  : 		return (iterator(_Where._Myptr, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp+4]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@QAE@PAUTexParam@ShaderContextPool@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::ShaderContextPool::TexParam,std::allocator<Ogre::ShaderContextPool::TexParam> >::_Vector_iterator<Ogre::ShaderContextPool::TexParam,std::allocator<Ogre::ShaderContextPool::TexParam> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 662  : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?_Make_iter@?$vector@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@2@V?$_Vector_const_iterator@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@2@@Z ENDP ; std::vector<Ogre::ShaderContextPool::TexParam,std::allocator<Ogre::ShaderContextPool::TexParam> >::_Make_iter
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@QBEIXZ
_TEXT	SEGMENT
tv65 = -12						; size = 4
_this$ = -8						; size = 4
__Count$ = -4						; size = 4
?max_size@?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@QBEIXZ PROC ; std::allocator<Ogre::ShaderContextPool::TexParam>::max_size, COMDAT
; _this$ = ecx

; 164  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);

	mov	DWORD PTR __Count$[ebp], 536870911	; 1fffffffH

; 166  : 		return (0 < _Count ? _Count : 1);

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN3@max_size@10
	mov	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR tv65[ebp], eax
	jmp	SHORT $LN4@max_size@10
$LN3@max_size@10:
	mov	DWORD PTR tv65[ebp], 1
$LN4@max_size@10:
	mov	eax, DWORD PTR tv65[ebp]

; 167  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@QBEIXZ ENDP ; std::allocator<Ogre::ShaderContextPool::TexParam>::max_size
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?_Make_iter@?$vector@PAVMaterialParam@Ogre@@V?$allocator@PAVMaterialParam@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVMaterialParam@Ogre@@V?$allocator@PAVMaterialParam@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVMaterialParam@Ogre@@V?$allocator@PAVMaterialParam@Ogre@@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 8
?_Make_iter@?$vector@PAVMaterialParam@Ogre@@V?$allocator@PAVMaterialParam@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVMaterialParam@Ogre@@V?$allocator@PAVMaterialParam@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVMaterialParam@Ogre@@V?$allocator@PAVMaterialParam@Ogre@@@std@@@2@@Z PROC ; std::vector<Ogre::MaterialParam *,std::allocator<Ogre::MaterialParam *> >::_Make_iter, COMDAT
; _this$ = ecx

; 660  : 		{	// make iterator from const_iterator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 661  : 		return (iterator(_Where._Myptr, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp+4]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@PAVMaterialParam@Ogre@@V?$allocator@PAVMaterialParam@Ogre@@@std@@@std@@QAE@PAPAVMaterialParam@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::MaterialParam *,std::allocator<Ogre::MaterialParam *> >::_Vector_iterator<Ogre::MaterialParam *,std::allocator<Ogre::MaterialParam *> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 662  : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?_Make_iter@?$vector@PAVMaterialParam@Ogre@@V?$allocator@PAVMaterialParam@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVMaterialParam@Ogre@@V?$allocator@PAVMaterialParam@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVMaterialParam@Ogre@@V?$allocator@PAVMaterialParam@Ogre@@@std@@@2@@Z ENDP ; std::vector<Ogre::MaterialParam *,std::allocator<Ogre::MaterialParam *> >::_Make_iter
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@PAVMaterialParam@Ogre@@@std@@QBEIXZ
_TEXT	SEGMENT
tv65 = -12						; size = 4
_this$ = -8						; size = 4
__Count$ = -4						; size = 4
?max_size@?$allocator@PAVMaterialParam@Ogre@@@std@@QBEIXZ PROC ; std::allocator<Ogre::MaterialParam *>::max_size, COMDAT
; _this$ = ecx

; 164  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);

	mov	DWORD PTR __Count$[ebp], 1073741823	; 3fffffffH

; 166  : 		return (0 < _Count ? _Count : 1);

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN3@max_size@11
	mov	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR tv65[ebp], eax
	jmp	SHORT $LN4@max_size@11
$LN3@max_size@11:
	mov	DWORD PTR tv65[ebp], 1
$LN4@max_size@11:
	mov	eax, DWORD PTR tv65[ebp]

; 167  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$allocator@PAVMaterialParam@Ogre@@@std@@QBEIXZ ENDP ; std::allocator<Ogre::MaterialParam *>::max_size
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?_Make_iter@?$vector@DV?$allocator@D@std@@@std@@QBE?AV?$_Vector_iterator@DV?$allocator@D@std@@@2@V?$_Vector_const_iterator@DV?$allocator@D@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 8
?_Make_iter@?$vector@DV?$allocator@D@std@@@std@@QBE?AV?$_Vector_iterator@DV?$allocator@D@std@@@2@V?$_Vector_const_iterator@DV?$allocator@D@std@@@2@@Z PROC ; std::vector<char,std::allocator<char> >::_Make_iter, COMDAT
; _this$ = ecx

; 660  : 		{	// make iterator from const_iterator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 661  : 		return (iterator(_Where._Myptr, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp+4]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@DV?$allocator@D@std@@@std@@QAE@PADPBV_Container_base_aux@1@@Z ; std::_Vector_iterator<char,std::allocator<char> >::_Vector_iterator<char,std::allocator<char> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 662  : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?_Make_iter@?$vector@DV?$allocator@D@std@@@std@@QBE?AV?$_Vector_iterator@DV?$allocator@D@std@@@2@V?$_Vector_const_iterator@DV?$allocator@D@std@@@2@@Z ENDP ; std::vector<char,std::allocator<char> >::_Make_iter
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Make_iter@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 8
?_Make_iter@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@2@@Z PROC ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::_Make_iter, COMDAT
; _this$ = ecx

; 660  : 		{	// make iterator from const_iterator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 661  : 		return (iterator(_Where._Myptr, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp+4]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE@PAPAVSurfaceData@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::_Vector_iterator<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 662  : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?_Make_iter@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@2@@Z ENDP ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::_Make_iter
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@PAVSurfaceData@Ogre@@@std@@QBEIXZ
_TEXT	SEGMENT
tv65 = -12						; size = 4
_this$ = -8						; size = 4
__Count$ = -4						; size = 4
?max_size@?$allocator@PAVSurfaceData@Ogre@@@std@@QBEIXZ PROC ; std::allocator<Ogre::SurfaceData *>::max_size, COMDAT
; _this$ = ecx

; 164  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);

	mov	DWORD PTR __Count$[ebp], 1073741823	; 3fffffffH

; 166  : 		return (0 < _Count ? _Count : 1);

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN3@max_size@12
	mov	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR tv65[ebp], eax
	jmp	SHORT $LN4@max_size@12
$LN3@max_size@12:
	mov	DWORD PTR tv65[ebp], 1
$LN4@max_size@12:
	mov	eax, DWORD PTR tv65[ebp]

; 167  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$allocator@PAVSurfaceData@Ogre@@@std@@QBEIXZ ENDP ; std::allocator<Ogre::SurfaceData *>::max_size
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?_Make_iter@?$vector@GV?$allocator@G@std@@@std@@QBE?AV?$_Vector_iterator@GV?$allocator@G@std@@@2@V?$_Vector_const_iterator@GV?$allocator@G@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 8
?_Make_iter@?$vector@GV?$allocator@G@std@@@std@@QBE?AV?$_Vector_iterator@GV?$allocator@G@std@@@2@V?$_Vector_const_iterator@GV?$allocator@G@std@@@2@@Z PROC ; std::vector<unsigned short,std::allocator<unsigned short> >::_Make_iter, COMDAT
; _this$ = ecx

; 660  : 		{	// make iterator from const_iterator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 661  : 		return (iterator(_Where._Myptr, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp+4]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@GV?$allocator@G@std@@@std@@QAE@PAGPBV_Container_base_aux@1@@Z ; std::_Vector_iterator<unsigned short,std::allocator<unsigned short> >::_Vector_iterator<unsigned short,std::allocator<unsigned short> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 662  : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?_Make_iter@?$vector@GV?$allocator@G@std@@@std@@QBE?AV?$_Vector_iterator@GV?$allocator@G@std@@@2@V?$_Vector_const_iterator@GV?$allocator@G@std@@@2@@Z ENDP ; std::vector<unsigned short,std::allocator<unsigned short> >::_Make_iter
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@G@std@@QBEIXZ
_TEXT	SEGMENT
tv65 = -12						; size = 4
_this$ = -8						; size = 4
__Count$ = -4						; size = 4
?max_size@?$allocator@G@std@@QBEIXZ PROC		; std::allocator<unsigned short>::max_size, COMDAT
; _this$ = ecx

; 164  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);

	mov	DWORD PTR __Count$[ebp], 2147483647	; 7fffffffH

; 166  : 		return (0 < _Count ? _Count : 1);

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN3@max_size@13
	mov	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR tv65[ebp], eax
	jmp	SHORT $LN4@max_size@13
$LN3@max_size@13:
	mov	DWORD PTR tv65[ebp], 1
$LN4@max_size@13:
	mov	eax, DWORD PTR tv65[ebp]

; 167  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$allocator@G@std@@QBEIXZ ENDP		; std::allocator<unsigned short>::max_size
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?_Make_iter@?$vector@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@2@V?$_Vector_const_iterator@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 8
?_Make_iter@?$vector@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@2@V?$_Vector_const_iterator@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@2@@Z PROC ; std::vector<Ogre::CullResult::Record,std::allocator<Ogre::CullResult::Record> >::_Make_iter, COMDAT
; _this$ = ecx

; 660  : 		{	// make iterator from const_iterator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 661  : 		return (iterator(_Where._Myptr, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp+4]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@QAE@PAURecord@CullResult@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::CullResult::Record,std::allocator<Ogre::CullResult::Record> >::_Vector_iterator<Ogre::CullResult::Record,std::allocator<Ogre::CullResult::Record> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 662  : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?_Make_iter@?$vector@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@2@V?$_Vector_const_iterator@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@2@@Z ENDP ; std::vector<Ogre::CullResult::Record,std::allocator<Ogre::CullResult::Record> >::_Make_iter
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@URecord@CullResult@Ogre@@@std@@QBEIXZ
_TEXT	SEGMENT
tv65 = -12						; size = 4
_this$ = -8						; size = 4
__Count$ = -4						; size = 4
?max_size@?$allocator@URecord@CullResult@Ogre@@@std@@QBEIXZ PROC ; std::allocator<Ogre::CullResult::Record>::max_size, COMDAT
; _this$ = ecx

; 164  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);

	mov	DWORD PTR __Count$[ebp], 268435455	; 0fffffffH

; 166  : 		return (0 < _Count ? _Count : 1);

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN3@max_size@14
	mov	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR tv65[ebp], eax
	jmp	SHORT $LN4@max_size@14
$LN3@max_size@14:
	mov	DWORD PTR tv65[ebp], 1
$LN4@max_size@14:
	mov	eax, DWORD PTR tv65[ebp]

; 167  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$allocator@URecord@CullResult@Ogre@@@std@@QBEIXZ ENDP ; std::allocator<Ogre::CullResult::Record>::max_size
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?_Make_iter@?$vector@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 8
?_Make_iter@?$vector@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@2@@Z PROC ; std::vector<Ogre::EffectObject *,std::allocator<Ogre::EffectObject *> >::_Make_iter, COMDAT
; _this$ = ecx

; 660  : 		{	// make iterator from const_iterator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 661  : 		return (iterator(_Where._Myptr, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp+4]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@QAE@PAPAVEffectObject@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::EffectObject *,std::allocator<Ogre::EffectObject *> >::_Vector_iterator<Ogre::EffectObject *,std::allocator<Ogre::EffectObject *> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 662  : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?_Make_iter@?$vector@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@2@@Z ENDP ; std::vector<Ogre::EffectObject *,std::allocator<Ogre::EffectObject *> >::_Make_iter
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@PAVEffectObject@Ogre@@@std@@QBEIXZ
_TEXT	SEGMENT
tv65 = -12						; size = 4
_this$ = -8						; size = 4
__Count$ = -4						; size = 4
?max_size@?$allocator@PAVEffectObject@Ogre@@@std@@QBEIXZ PROC ; std::allocator<Ogre::EffectObject *>::max_size, COMDAT
; _this$ = ecx

; 164  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);

	mov	DWORD PTR __Count$[ebp], 1073741823	; 3fffffffH

; 166  : 		return (0 < _Count ? _Count : 1);

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN3@max_size@15
	mov	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR tv65[ebp], eax
	jmp	SHORT $LN4@max_size@15
$LN3@max_size@15:
	mov	DWORD PTR tv65[ebp], 1
$LN4@max_size@15:
	mov	eax, DWORD PTR tv65[ebp]

; 167  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$allocator@PAVEffectObject@Ogre@@@std@@QBEIXZ ENDP ; std::allocator<Ogre::EffectObject *>::max_size
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?_Make_iter@?$vector@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 8
?_Make_iter@?$vector@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@2@@Z PROC ; std::vector<Ogre::SoundNode *,std::allocator<Ogre::SoundNode *> >::_Make_iter, COMDAT
; _this$ = ecx

; 660  : 		{	// make iterator from const_iterator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 661  : 		return (iterator(_Where._Myptr, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp+4]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@QAE@PAPAVSoundNode@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::SoundNode *,std::allocator<Ogre::SoundNode *> >::_Vector_iterator<Ogre::SoundNode *,std::allocator<Ogre::SoundNode *> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 662  : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?_Make_iter@?$vector@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@2@@Z ENDP ; std::vector<Ogre::SoundNode *,std::allocator<Ogre::SoundNode *> >::_Make_iter
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@PAVSoundNode@Ogre@@@std@@QBEIXZ
_TEXT	SEGMENT
tv65 = -12						; size = 4
_this$ = -8						; size = 4
__Count$ = -4						; size = 4
?max_size@?$allocator@PAVSoundNode@Ogre@@@std@@QBEIXZ PROC ; std::allocator<Ogre::SoundNode *>::max_size, COMDAT
; _this$ = ecx

; 164  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);

	mov	DWORD PTR __Count$[ebp], 1073741823	; 3fffffffH

; 166  : 		return (0 < _Count ? _Count : 1);

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN3@max_size@16
	mov	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR tv65[ebp], eax
	jmp	SHORT $LN4@max_size@16
$LN3@max_size@16:
	mov	DWORD PTR tv65[ebp], 1
$LN4@max_size@16:
	mov	eax, DWORD PTR tv65[ebp]

; 167  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$allocator@PAVSoundNode@Ogre@@@std@@QBEIXZ ENDP ; std::allocator<Ogre::SoundNode *>::max_size
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?_Make_iter@?$vector@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 8
?_Make_iter@?$vector@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@2@@Z PROC ; std::vector<Ogre::RenderableObject *,std::allocator<Ogre::RenderableObject *> >::_Make_iter, COMDAT
; _this$ = ecx

; 660  : 		{	// make iterator from const_iterator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 661  : 		return (iterator(_Where._Myptr, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp+4]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@QAE@PAPAVRenderableObject@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::RenderableObject *,std::allocator<Ogre::RenderableObject *> >::_Vector_iterator<Ogre::RenderableObject *,std::allocator<Ogre::RenderableObject *> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 662  : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?_Make_iter@?$vector@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@2@@Z ENDP ; std::vector<Ogre::RenderableObject *,std::allocator<Ogre::RenderableObject *> >::_Make_iter
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@PAVRenderableObject@Ogre@@@std@@QBEIXZ
_TEXT	SEGMENT
tv65 = -12						; size = 4
_this$ = -8						; size = 4
__Count$ = -4						; size = 4
?max_size@?$allocator@PAVRenderableObject@Ogre@@@std@@QBEIXZ PROC ; std::allocator<Ogre::RenderableObject *>::max_size, COMDAT
; _this$ = ecx

; 164  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);

	mov	DWORD PTR __Count$[ebp], 1073741823	; 3fffffffH

; 166  : 		return (0 < _Count ? _Count : 1);

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN3@max_size@17
	mov	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR tv65[ebp], eax
	jmp	SHORT $LN4@max_size@17
$LN3@max_size@17:
	mov	DWORD PTR tv65[ebp], 1
$LN4@max_size@17:
	mov	eax, DWORD PTR tv65[ebp]

; 167  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$allocator@PAVRenderableObject@Ogre@@@std@@QBEIXZ ENDP ; std::allocator<Ogre::RenderableObject *>::max_size
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?_Make_iter@?$vector@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 8
?_Make_iter@?$vector@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@2@@Z PROC ; std::vector<Ogre::Light *,std::allocator<Ogre::Light *> >::_Make_iter, COMDAT
; _this$ = ecx

; 660  : 		{	// make iterator from const_iterator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 661  : 		return (iterator(_Where._Myptr, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp+4]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@QAE@PAPAVLight@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::Light *,std::allocator<Ogre::Light *> >::_Vector_iterator<Ogre::Light *,std::allocator<Ogre::Light *> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 662  : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?_Make_iter@?$vector@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@2@V?$_Vector_const_iterator@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@2@@Z ENDP ; std::vector<Ogre::Light *,std::allocator<Ogre::Light *> >::_Make_iter
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@PAVLight@Ogre@@@std@@QBEIXZ
_TEXT	SEGMENT
tv65 = -12						; size = 4
_this$ = -8						; size = 4
__Count$ = -4						; size = 4
?max_size@?$allocator@PAVLight@Ogre@@@std@@QBEIXZ PROC	; std::allocator<Ogre::Light *>::max_size, COMDAT
; _this$ = ecx

; 164  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);

	mov	DWORD PTR __Count$[ebp], 1073741823	; 3fffffffH

; 166  : 		return (0 < _Count ? _Count : 1);

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN3@max_size@18
	mov	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR tv65[ebp], eax
	jmp	SHORT $LN4@max_size@18
$LN3@max_size@18:
	mov	DWORD PTR tv65[ebp], 1
$LN4@max_size@18:
	mov	eax, DWORD PTR tv65[ebp]

; 167  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$allocator@PAVLight@Ogre@@@std@@QBEIXZ ENDP	; std::allocator<Ogre::Light *>::max_size
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Ogre::ShaderContext *,std::allocator<Ogre::ShaderContext *> >::operator==
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??9?$_Vector_const_iterator@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<Ogre::ShaderContext *,std::allocator<Ogre::ShaderContext *> >::operator!=, COMDAT
; _this$ = ecx

; 215  : 		{	// test for iterator inequality

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??8?$_Vector_const_iterator@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Ogre::ShaderContext *,std::allocator<Ogre::ShaderContext *> >::operator==
	movzx	eax, al
	neg	eax
	sbb	eax, eax
	add	eax, 1

; 217  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??9?$_Vector_const_iterator@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<Ogre::ShaderContext *,std::allocator<Ogre::ShaderContext *> >::operator!=
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Ogre::ContextQueDesc,std::allocator<Ogre::ContextQueDesc> >::operator==
; Function compile flags: /Odtp
;	COMDAT ??9?$_Vector_const_iterator@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<Ogre::ContextQueDesc,std::allocator<Ogre::ContextQueDesc> >::operator!=, COMDAT
; _this$ = ecx

; 215  : 		{	// test for iterator inequality

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??8?$_Vector_const_iterator@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Ogre::ContextQueDesc,std::allocator<Ogre::ContextQueDesc> >::operator==
	movzx	eax, al
	neg	eax
	sbb	eax, eax
	add	eax, 1

; 217  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??9?$_Vector_const_iterator@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<Ogre::ContextQueDesc,std::allocator<Ogre::ContextQueDesc> >::operator!=
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@EV?$allocator@E@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<unsigned char,std::allocator<unsigned char> >::operator==
; Function compile flags: /Odtp
;	COMDAT ??9?$_Vector_const_iterator@EV?$allocator@E@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@EV?$allocator@E@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<unsigned char,std::allocator<unsigned char> >::operator!=, COMDAT
; _this$ = ecx

; 215  : 		{	// test for iterator inequality

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??8?$_Vector_const_iterator@EV?$allocator@E@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<unsigned char,std::allocator<unsigned char> >::operator==
	movzx	eax, al
	neg	eax
	sbb	eax, eax
	add	eax, 1

; 217  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??9?$_Vector_const_iterator@EV?$allocator@E@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<unsigned char,std::allocator<unsigned char> >::operator!=
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Ogre::ShaderContextPool::ValueParam,std::allocator<Ogre::ShaderContextPool::ValueParam> >::operator==
; Function compile flags: /Odtp
;	COMDAT ??9?$_Vector_const_iterator@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<Ogre::ShaderContextPool::ValueParam,std::allocator<Ogre::ShaderContextPool::ValueParam> >::operator!=, COMDAT
; _this$ = ecx

; 215  : 		{	// test for iterator inequality

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??8?$_Vector_const_iterator@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Ogre::ShaderContextPool::ValueParam,std::allocator<Ogre::ShaderContextPool::ValueParam> >::operator==
	movzx	eax, al
	neg	eax
	sbb	eax, eax
	add	eax, 1

; 217  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??9?$_Vector_const_iterator@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<Ogre::ShaderContextPool::ValueParam,std::allocator<Ogre::ShaderContextPool::ValueParam> >::operator!=
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Ogre::ShaderContextPool::TexParam,std::allocator<Ogre::ShaderContextPool::TexParam> >::operator==
; Function compile flags: /Odtp
;	COMDAT ??9?$_Vector_const_iterator@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<Ogre::ShaderContextPool::TexParam,std::allocator<Ogre::ShaderContextPool::TexParam> >::operator!=, COMDAT
; _this$ = ecx

; 215  : 		{	// test for iterator inequality

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??8?$_Vector_const_iterator@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Ogre::ShaderContextPool::TexParam,std::allocator<Ogre::ShaderContextPool::TexParam> >::operator==
	movzx	eax, al
	neg	eax
	sbb	eax, eax
	add	eax, 1

; 217  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??9?$_Vector_const_iterator@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<Ogre::ShaderContextPool::TexParam,std::allocator<Ogre::ShaderContextPool::TexParam> >::operator!=
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@DV?$allocator@D@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<char,std::allocator<char> >::operator==
; Function compile flags: /Odtp
;	COMDAT ??9?$_Vector_const_iterator@DV?$allocator@D@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@DV?$allocator@D@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<char,std::allocator<char> >::operator!=, COMDAT
; _this$ = ecx

; 215  : 		{	// test for iterator inequality

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??8?$_Vector_const_iterator@DV?$allocator@D@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<char,std::allocator<char> >::operator==
	movzx	eax, al
	neg	eax
	sbb	eax, eax
	add	eax, 1

; 217  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??9?$_Vector_const_iterator@DV?$allocator@D@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<char,std::allocator<char> >::operator!=
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::operator==
; Function compile flags: /Odtp
;	COMDAT ??9?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::operator!=, COMDAT
; _this$ = ecx

; 215  : 		{	// test for iterator inequality

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??8?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::operator==
	movzx	eax, al
	neg	eax
	sbb	eax, eax
	add	eax, 1

; 217  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??9?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::operator!=
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Ogre::CullResult::Record,std::allocator<Ogre::CullResult::Record> >::operator==
; Function compile flags: /Odtp
;	COMDAT ??9?$_Vector_const_iterator@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<Ogre::CullResult::Record,std::allocator<Ogre::CullResult::Record> >::operator!=, COMDAT
; _this$ = ecx

; 215  : 		{	// test for iterator inequality

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??8?$_Vector_const_iterator@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Ogre::CullResult::Record,std::allocator<Ogre::CullResult::Record> >::operator==
	movzx	eax, al
	neg	eax
	sbb	eax, eax
	add	eax, 1

; 217  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??9?$_Vector_const_iterator@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<Ogre::CullResult::Record,std::allocator<Ogre::CullResult::Record> >::operator!=
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Ogre::EffectObject *,std::allocator<Ogre::EffectObject *> >::operator==
; Function compile flags: /Odtp
;	COMDAT ??9?$_Vector_const_iterator@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<Ogre::EffectObject *,std::allocator<Ogre::EffectObject *> >::operator!=, COMDAT
; _this$ = ecx

; 215  : 		{	// test for iterator inequality

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??8?$_Vector_const_iterator@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Ogre::EffectObject *,std::allocator<Ogre::EffectObject *> >::operator==
	movzx	eax, al
	neg	eax
	sbb	eax, eax
	add	eax, 1

; 217  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??9?$_Vector_const_iterator@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<Ogre::EffectObject *,std::allocator<Ogre::EffectObject *> >::operator!=
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Ogre::SoundNode *,std::allocator<Ogre::SoundNode *> >::operator==
; Function compile flags: /Odtp
;	COMDAT ??9?$_Vector_const_iterator@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<Ogre::SoundNode *,std::allocator<Ogre::SoundNode *> >::operator!=, COMDAT
; _this$ = ecx

; 215  : 		{	// test for iterator inequality

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??8?$_Vector_const_iterator@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Ogre::SoundNode *,std::allocator<Ogre::SoundNode *> >::operator==
	movzx	eax, al
	neg	eax
	sbb	eax, eax
	add	eax, 1

; 217  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??9?$_Vector_const_iterator@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<Ogre::SoundNode *,std::allocator<Ogre::SoundNode *> >::operator!=
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Ogre::RenderableObject *,std::allocator<Ogre::RenderableObject *> >::operator==
; Function compile flags: /Odtp
;	COMDAT ??9?$_Vector_const_iterator@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<Ogre::RenderableObject *,std::allocator<Ogre::RenderableObject *> >::operator!=, COMDAT
; _this$ = ecx

; 215  : 		{	// test for iterator inequality

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??8?$_Vector_const_iterator@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Ogre::RenderableObject *,std::allocator<Ogre::RenderableObject *> >::operator==
	movzx	eax, al
	neg	eax
	sbb	eax, eax
	add	eax, 1

; 217  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??9?$_Vector_const_iterator@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<Ogre::RenderableObject *,std::allocator<Ogre::RenderableObject *> >::operator!=
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Ogre::Light *,std::allocator<Ogre::Light *> >::operator==
; Function compile flags: /Odtp
;	COMDAT ??9?$_Vector_const_iterator@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<Ogre::Light *,std::allocator<Ogre::Light *> >::operator!=, COMDAT
; _this$ = ecx

; 215  : 		{	// test for iterator inequality

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??8?$_Vector_const_iterator@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Ogre::Light *,std::allocator<Ogre::Light *> >::operator==
	movzx	eax, al
	neg	eax
	sbb	eax, eax
	add	eax, 1

; 217  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??9?$_Vector_const_iterator@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<Ogre::Light *,std::allocator<Ogre::Light *> >::operator!=
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0?$_Vector_iterator@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@QAE@PAPAVShaderContext@Ogre@@PBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@QAE@PAPAVShaderContext@Ogre@@PBV_Container_base_aux@1@@Z PROC ; std::_Vector_iterator<Ogre::ShaderContext *,std::allocator<Ogre::ShaderContext *> >::_Vector_iterator<Ogre::ShaderContext *,std::allocator<Ogre::ShaderContext *> >, COMDAT
; _this$ = ecx

; 327  : 		{	// construct with pointer _Ptr

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Pvector$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_const_iterator@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@QAE@PAPAVShaderContext@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<Ogre::ShaderContext *,std::allocator<Ogre::ShaderContext *> >::_Vector_const_iterator<Ogre::ShaderContext *,std::allocator<Ogre::ShaderContext *> >

; 328  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Vector_iterator@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@QAE@PAPAVShaderContext@Ogre@@PBV_Container_base_aux@1@@Z ENDP ; std::_Vector_iterator<Ogre::ShaderContext *,std::allocator<Ogre::ShaderContext *> >::_Vector_iterator<Ogre::ShaderContext *,std::allocator<Ogre::ShaderContext *> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0?$_Vector_iterator@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@QAE@PAUContextQueDesc@Ogre@@PBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@QAE@PAUContextQueDesc@Ogre@@PBV_Container_base_aux@1@@Z PROC ; std::_Vector_iterator<Ogre::ContextQueDesc,std::allocator<Ogre::ContextQueDesc> >::_Vector_iterator<Ogre::ContextQueDesc,std::allocator<Ogre::ContextQueDesc> >, COMDAT
; _this$ = ecx

; 327  : 		{	// construct with pointer _Ptr

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Pvector$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_const_iterator@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@QAE@PAUContextQueDesc@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<Ogre::ContextQueDesc,std::allocator<Ogre::ContextQueDesc> >::_Vector_const_iterator<Ogre::ContextQueDesc,std::allocator<Ogre::ContextQueDesc> >

; 328  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Vector_iterator@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@QAE@PAUContextQueDesc@Ogre@@PBV_Container_base_aux@1@@Z ENDP ; std::_Vector_iterator<Ogre::ContextQueDesc,std::allocator<Ogre::ContextQueDesc> >::_Vector_iterator<Ogre::ContextQueDesc,std::allocator<Ogre::ContextQueDesc> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0?$_Vector_iterator@EV?$allocator@E@std@@@std@@QAE@PAEPBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@EV?$allocator@E@std@@@std@@QAE@PAEPBV_Container_base_aux@1@@Z PROC ; std::_Vector_iterator<unsigned char,std::allocator<unsigned char> >::_Vector_iterator<unsigned char,std::allocator<unsigned char> >, COMDAT
; _this$ = ecx

; 327  : 		{	// construct with pointer _Ptr

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Pvector$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_const_iterator@EV?$allocator@E@std@@@std@@QAE@PAEPBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<unsigned char,std::allocator<unsigned char> >::_Vector_const_iterator<unsigned char,std::allocator<unsigned char> >

; 328  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Vector_iterator@EV?$allocator@E@std@@@std@@QAE@PAEPBV_Container_base_aux@1@@Z ENDP ; std::_Vector_iterator<unsigned char,std::allocator<unsigned char> >::_Vector_iterator<unsigned char,std::allocator<unsigned char> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0?$_Vector_iterator@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@QAE@PAUValueParam@ShaderContextPool@Ogre@@PBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@QAE@PAUValueParam@ShaderContextPool@Ogre@@PBV_Container_base_aux@1@@Z PROC ; std::_Vector_iterator<Ogre::ShaderContextPool::ValueParam,std::allocator<Ogre::ShaderContextPool::ValueParam> >::_Vector_iterator<Ogre::ShaderContextPool::ValueParam,std::allocator<Ogre::ShaderContextPool::ValueParam> >, COMDAT
; _this$ = ecx

; 327  : 		{	// construct with pointer _Ptr

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Pvector$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_const_iterator@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@QAE@PAUValueParam@ShaderContextPool@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<Ogre::ShaderContextPool::ValueParam,std::allocator<Ogre::ShaderContextPool::ValueParam> >::_Vector_const_iterator<Ogre::ShaderContextPool::ValueParam,std::allocator<Ogre::ShaderContextPool::ValueParam> >

; 328  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Vector_iterator@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@QAE@PAUValueParam@ShaderContextPool@Ogre@@PBV_Container_base_aux@1@@Z ENDP ; std::_Vector_iterator<Ogre::ShaderContextPool::ValueParam,std::allocator<Ogre::ShaderContextPool::ValueParam> >::_Vector_iterator<Ogre::ShaderContextPool::ValueParam,std::allocator<Ogre::ShaderContextPool::ValueParam> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0?$_Vector_iterator@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@QAE@PAUTexParam@ShaderContextPool@Ogre@@PBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@QAE@PAUTexParam@ShaderContextPool@Ogre@@PBV_Container_base_aux@1@@Z PROC ; std::_Vector_iterator<Ogre::ShaderContextPool::TexParam,std::allocator<Ogre::ShaderContextPool::TexParam> >::_Vector_iterator<Ogre::ShaderContextPool::TexParam,std::allocator<Ogre::ShaderContextPool::TexParam> >, COMDAT
; _this$ = ecx

; 327  : 		{	// construct with pointer _Ptr

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Pvector$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_const_iterator@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@QAE@PAUTexParam@ShaderContextPool@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<Ogre::ShaderContextPool::TexParam,std::allocator<Ogre::ShaderContextPool::TexParam> >::_Vector_const_iterator<Ogre::ShaderContextPool::TexParam,std::allocator<Ogre::ShaderContextPool::TexParam> >

; 328  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Vector_iterator@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@QAE@PAUTexParam@ShaderContextPool@Ogre@@PBV_Container_base_aux@1@@Z ENDP ; std::_Vector_iterator<Ogre::ShaderContextPool::TexParam,std::allocator<Ogre::ShaderContextPool::TexParam> >::_Vector_iterator<Ogre::ShaderContextPool::TexParam,std::allocator<Ogre::ShaderContextPool::TexParam> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@PAVMaterialParam@Ogre@@V?$allocator@PAVMaterialParam@Ogre@@@std@@@std@@QAE@PAPAVMaterialParam@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<Ogre::MaterialParam *,std::allocator<Ogre::MaterialParam *> >::_Vector_const_iterator<Ogre::MaterialParam *,std::allocator<Ogre::MaterialParam *> >
; Function compile flags: /Odtp
;	COMDAT ??0?$_Vector_iterator@PAVMaterialParam@Ogre@@V?$allocator@PAVMaterialParam@Ogre@@@std@@@std@@QAE@PAPAVMaterialParam@Ogre@@PBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@PAVMaterialParam@Ogre@@V?$allocator@PAVMaterialParam@Ogre@@@std@@@std@@QAE@PAPAVMaterialParam@Ogre@@PBV_Container_base_aux@1@@Z PROC ; std::_Vector_iterator<Ogre::MaterialParam *,std::allocator<Ogre::MaterialParam *> >::_Vector_iterator<Ogre::MaterialParam *,std::allocator<Ogre::MaterialParam *> >, COMDAT
; _this$ = ecx

; 327  : 		{	// construct with pointer _Ptr

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Pvector$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_const_iterator@PAVMaterialParam@Ogre@@V?$allocator@PAVMaterialParam@Ogre@@@std@@@std@@QAE@PAPAVMaterialParam@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<Ogre::MaterialParam *,std::allocator<Ogre::MaterialParam *> >::_Vector_const_iterator<Ogre::MaterialParam *,std::allocator<Ogre::MaterialParam *> >

; 328  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Vector_iterator@PAVMaterialParam@Ogre@@V?$allocator@PAVMaterialParam@Ogre@@@std@@@std@@QAE@PAPAVMaterialParam@Ogre@@PBV_Container_base_aux@1@@Z ENDP ; std::_Vector_iterator<Ogre::MaterialParam *,std::allocator<Ogre::MaterialParam *> >::_Vector_iterator<Ogre::MaterialParam *,std::allocator<Ogre::MaterialParam *> >
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@PAVMaterialParam@Ogre@@V?$allocator@PAVMaterialParam@Ogre@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Ogre::MaterialParam *,std::allocator<Ogre::MaterialParam *> >::operator==
; Function compile flags: /Odtp
;	COMDAT ??9?$_Vector_const_iterator@PAVMaterialParam@Ogre@@V?$allocator@PAVMaterialParam@Ogre@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@PAVMaterialParam@Ogre@@V?$allocator@PAVMaterialParam@Ogre@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<Ogre::MaterialParam *,std::allocator<Ogre::MaterialParam *> >::operator!=, COMDAT
; _this$ = ecx

; 215  : 		{	// test for iterator inequality

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??8?$_Vector_const_iterator@PAVMaterialParam@Ogre@@V?$allocator@PAVMaterialParam@Ogre@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Ogre::MaterialParam *,std::allocator<Ogre::MaterialParam *> >::operator==
	movzx	eax, al
	neg	eax
	sbb	eax, eax
	add	eax, 1

; 217  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??9?$_Vector_const_iterator@PAVMaterialParam@Ogre@@V?$allocator@PAVMaterialParam@Ogre@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<Ogre::MaterialParam *,std::allocator<Ogre::MaterialParam *> >::operator!=
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0?$_Vector_iterator@DV?$allocator@D@std@@@std@@QAE@PADPBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@DV?$allocator@D@std@@@std@@QAE@PADPBV_Container_base_aux@1@@Z PROC ; std::_Vector_iterator<char,std::allocator<char> >::_Vector_iterator<char,std::allocator<char> >, COMDAT
; _this$ = ecx

; 327  : 		{	// construct with pointer _Ptr

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Pvector$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_const_iterator@DV?$allocator@D@std@@@std@@QAE@PADPBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<char,std::allocator<char> >::_Vector_const_iterator<char,std::allocator<char> >

; 328  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Vector_iterator@DV?$allocator@D@std@@@std@@QAE@PADPBV_Container_base_aux@1@@Z ENDP ; std::_Vector_iterator<char,std::allocator<char> >::_Vector_iterator<char,std::allocator<char> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0?$_Vector_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE@PAPAVSurfaceData@Ogre@@PBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE@PAPAVSurfaceData@Ogre@@PBV_Container_base_aux@1@@Z PROC ; std::_Vector_iterator<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::_Vector_iterator<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >, COMDAT
; _this$ = ecx

; 327  : 		{	// construct with pointer _Ptr

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Pvector$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE@PAPAVSurfaceData@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::_Vector_const_iterator<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >

; 328  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Vector_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QAE@PAPAVSurfaceData@Ogre@@PBV_Container_base_aux@1@@Z ENDP ; std::_Vector_iterator<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::_Vector_iterator<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >
_TEXT	ENDS
PUBLIC	??0?$_Vector_const_iterator@GV?$allocator@G@std@@@std@@QAE@PAGPBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<unsigned short,std::allocator<unsigned short> >::_Vector_const_iterator<unsigned short,std::allocator<unsigned short> >
; Function compile flags: /Odtp
;	COMDAT ??0?$_Vector_iterator@GV?$allocator@G@std@@@std@@QAE@PAGPBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@GV?$allocator@G@std@@@std@@QAE@PAGPBV_Container_base_aux@1@@Z PROC ; std::_Vector_iterator<unsigned short,std::allocator<unsigned short> >::_Vector_iterator<unsigned short,std::allocator<unsigned short> >, COMDAT
; _this$ = ecx

; 327  : 		{	// construct with pointer _Ptr

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Pvector$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_const_iterator@GV?$allocator@G@std@@@std@@QAE@PAGPBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<unsigned short,std::allocator<unsigned short> >::_Vector_const_iterator<unsigned short,std::allocator<unsigned short> >

; 328  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Vector_iterator@GV?$allocator@G@std@@@std@@QAE@PAGPBV_Container_base_aux@1@@Z ENDP ; std::_Vector_iterator<unsigned short,std::allocator<unsigned short> >::_Vector_iterator<unsigned short,std::allocator<unsigned short> >
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@GV?$allocator@G@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<unsigned short,std::allocator<unsigned short> >::operator==
; Function compile flags: /Odtp
;	COMDAT ??9?$_Vector_const_iterator@GV?$allocator@G@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@GV?$allocator@G@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<unsigned short,std::allocator<unsigned short> >::operator!=, COMDAT
; _this$ = ecx

; 215  : 		{	// test for iterator inequality

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??8?$_Vector_const_iterator@GV?$allocator@G@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<unsigned short,std::allocator<unsigned short> >::operator==
	movzx	eax, al
	neg	eax
	sbb	eax, eax
	add	eax, 1

; 217  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??9?$_Vector_const_iterator@GV?$allocator@G@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<unsigned short,std::allocator<unsigned short> >::operator!=
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0?$_Vector_iterator@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@QAE@PAURecord@CullResult@Ogre@@PBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@QAE@PAURecord@CullResult@Ogre@@PBV_Container_base_aux@1@@Z PROC ; std::_Vector_iterator<Ogre::CullResult::Record,std::allocator<Ogre::CullResult::Record> >::_Vector_iterator<Ogre::CullResult::Record,std::allocator<Ogre::CullResult::Record> >, COMDAT
; _this$ = ecx

; 327  : 		{	// construct with pointer _Ptr

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Pvector$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_const_iterator@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@QAE@PAURecord@CullResult@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<Ogre::CullResult::Record,std::allocator<Ogre::CullResult::Record> >::_Vector_const_iterator<Ogre::CullResult::Record,std::allocator<Ogre::CullResult::Record> >

; 328  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Vector_iterator@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@QAE@PAURecord@CullResult@Ogre@@PBV_Container_base_aux@1@@Z ENDP ; std::_Vector_iterator<Ogre::CullResult::Record,std::allocator<Ogre::CullResult::Record> >::_Vector_iterator<Ogre::CullResult::Record,std::allocator<Ogre::CullResult::Record> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0?$_Vector_iterator@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@QAE@PAPAVEffectObject@Ogre@@PBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@QAE@PAPAVEffectObject@Ogre@@PBV_Container_base_aux@1@@Z PROC ; std::_Vector_iterator<Ogre::EffectObject *,std::allocator<Ogre::EffectObject *> >::_Vector_iterator<Ogre::EffectObject *,std::allocator<Ogre::EffectObject *> >, COMDAT
; _this$ = ecx

; 327  : 		{	// construct with pointer _Ptr

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Pvector$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_const_iterator@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@QAE@PAPAVEffectObject@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<Ogre::EffectObject *,std::allocator<Ogre::EffectObject *> >::_Vector_const_iterator<Ogre::EffectObject *,std::allocator<Ogre::EffectObject *> >

; 328  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Vector_iterator@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@QAE@PAPAVEffectObject@Ogre@@PBV_Container_base_aux@1@@Z ENDP ; std::_Vector_iterator<Ogre::EffectObject *,std::allocator<Ogre::EffectObject *> >::_Vector_iterator<Ogre::EffectObject *,std::allocator<Ogre::EffectObject *> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0?$_Vector_iterator@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@QAE@PAPAVSoundNode@Ogre@@PBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@QAE@PAPAVSoundNode@Ogre@@PBV_Container_base_aux@1@@Z PROC ; std::_Vector_iterator<Ogre::SoundNode *,std::allocator<Ogre::SoundNode *> >::_Vector_iterator<Ogre::SoundNode *,std::allocator<Ogre::SoundNode *> >, COMDAT
; _this$ = ecx

; 327  : 		{	// construct with pointer _Ptr

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Pvector$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_const_iterator@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@QAE@PAPAVSoundNode@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<Ogre::SoundNode *,std::allocator<Ogre::SoundNode *> >::_Vector_const_iterator<Ogre::SoundNode *,std::allocator<Ogre::SoundNode *> >

; 328  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Vector_iterator@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@QAE@PAPAVSoundNode@Ogre@@PBV_Container_base_aux@1@@Z ENDP ; std::_Vector_iterator<Ogre::SoundNode *,std::allocator<Ogre::SoundNode *> >::_Vector_iterator<Ogre::SoundNode *,std::allocator<Ogre::SoundNode *> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0?$_Vector_iterator@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@QAE@PAPAVRenderableObject@Ogre@@PBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@QAE@PAPAVRenderableObject@Ogre@@PBV_Container_base_aux@1@@Z PROC ; std::_Vector_iterator<Ogre::RenderableObject *,std::allocator<Ogre::RenderableObject *> >::_Vector_iterator<Ogre::RenderableObject *,std::allocator<Ogre::RenderableObject *> >, COMDAT
; _this$ = ecx

; 327  : 		{	// construct with pointer _Ptr

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Pvector$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_const_iterator@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@QAE@PAPAVRenderableObject@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<Ogre::RenderableObject *,std::allocator<Ogre::RenderableObject *> >::_Vector_const_iterator<Ogre::RenderableObject *,std::allocator<Ogre::RenderableObject *> >

; 328  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Vector_iterator@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@QAE@PAPAVRenderableObject@Ogre@@PBV_Container_base_aux@1@@Z ENDP ; std::_Vector_iterator<Ogre::RenderableObject *,std::allocator<Ogre::RenderableObject *> >::_Vector_iterator<Ogre::RenderableObject *,std::allocator<Ogre::RenderableObject *> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0?$_Vector_iterator@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@QAE@PAPAVLight@Ogre@@PBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@QAE@PAPAVLight@Ogre@@PBV_Container_base_aux@1@@Z PROC ; std::_Vector_iterator<Ogre::Light *,std::allocator<Ogre::Light *> >::_Vector_iterator<Ogre::Light *,std::allocator<Ogre::Light *> >, COMDAT
; _this$ = ecx

; 327  : 		{	// construct with pointer _Ptr

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Pvector$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_const_iterator@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@QAE@PAPAVLight@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<Ogre::Light *,std::allocator<Ogre::Light *> >::_Vector_const_iterator<Ogre::Light *,std::allocator<Ogre::Light *> >

; 328  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Vector_iterator@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@QAE@PAPAVLight@Ogre@@PBV_Container_base_aux@1@@Z ENDP ; std::_Vector_iterator<Ogre::Light *,std::allocator<Ogre::Light *> >::_Vector_iterator<Ogre::Light *,std::allocator<Ogre::Light *> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Make_iter@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@2@V?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 8
?_Make_iter@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@2@V?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@2@@Z PROC ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::_Make_iter, COMDAT
; _this$ = ecx

; 660  : 		{	// make iterator from const_iterator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 661  : 		return (iterator(_Where._Myptr, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp+4]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAE@PAUAnimRange@BaseKeyFrameArray@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::_Vector_iterator<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 662  : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?_Make_iter@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@2@V?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@2@@Z ENDP ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::_Make_iter
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Make_iter@?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@2@V?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 8
?_Make_iter@?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@2@V?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@2@@Z PROC ; std::vector<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::_Make_iter, COMDAT
; _this$ = ecx

; 660  : 		{	// make iterator from const_iterator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 661  : 		return (iterator(_Where._Myptr, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp+4]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAE@PAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::_Vector_iterator<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 662  : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?_Make_iter@?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@2@V?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@2@@Z ENDP ; std::vector<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::_Make_iter
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Make_iter@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@2@V?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 8
?_Make_iter@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@2@V?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@2@@Z PROC ; std::vector<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::_Make_iter, COMDAT
; _this$ = ecx

; 660  : 		{	// make iterator from const_iterator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 661  : 		return (iterator(_Where._Myptr, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp+4]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAE@PAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::_Vector_iterator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 662  : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?_Make_iter@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@2@V?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@2@@Z ENDP ; std::vector<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::_Make_iter
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Make_iter@?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@2@V?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 8
?_Make_iter@?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@2@V?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@2@@Z PROC ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::_Make_iter, COMDAT
; _this$ = ecx

; 660  : 		{	// make iterator from const_iterator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 661  : 		return (iterator(_Where._Myptr, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp+4]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAE@PAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::_Vector_iterator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 662  : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?_Make_iter@?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@2@V?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@2@@Z ENDP ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::_Make_iter
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Make_iter@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@2@V?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 8
?_Make_iter@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@2@V?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@2@@Z PROC ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::_Make_iter, COMDAT
; _this$ = ecx

; 660  : 		{	// make iterator from const_iterator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 661  : 		return (iterator(_Where._Myptr, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp+4]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAE@PAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::_Vector_iterator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 662  : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?_Make_iter@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QBE?AV?$_Vector_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@2@V?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@2@@Z ENDP ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::_Make_iter
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::operator==
; Function compile flags: /Odtp
;	COMDAT ??9?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::operator!=, COMDAT
; _this$ = ecx

; 215  : 		{	// test for iterator inequality

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??8?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::operator==
	movzx	eax, al
	neg	eax
	sbb	eax, eax
	add	eax, 1

; 217  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??9?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::operator!=
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::operator==
; Function compile flags: /Odtp
;	COMDAT ??9?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::operator!=, COMDAT
; _this$ = ecx

; 215  : 		{	// test for iterator inequality

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??8?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::operator==
	movzx	eax, al
	neg	eax
	sbb	eax, eax
	add	eax, 1

; 217  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??9?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::operator!=
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::operator==
; Function compile flags: /Odtp
;	COMDAT ??9?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::operator!=, COMDAT
; _this$ = ecx

; 215  : 		{	// test for iterator inequality

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??8?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::operator==
	movzx	eax, al
	neg	eax
	sbb	eax, eax
	add	eax, 1

; 217  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??9?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::operator!=
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::operator==
; Function compile flags: /Odtp
;	COMDAT ??9?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::operator!=, COMDAT
; _this$ = ecx

; 215  : 		{	// test for iterator inequality

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??8?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::operator==
	movzx	eax, al
	neg	eax
	sbb	eax, eax
	add	eax, 1

; 217  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??9?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::operator!=
_TEXT	ENDS
PUBLIC	??8?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::operator==
; Function compile flags: /Odtp
;	COMDAT ??9?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::operator!=, COMDAT
; _this$ = ecx

; 215  : 		{	// test for iterator inequality

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??8?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::operator==
	movzx	eax, al
	neg	eax
	sbb	eax, eax
	add	eax, 1

; 217  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??9?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::operator!=
_TEXT	ENDS
PUBLIC	?_Same_container@_Iterator_base_aux@std@@QBE_NABV12@@Z ; std::_Iterator_base_aux::_Same_container
PUBLIC	?_Has_container@_Iterator_base_aux@std@@QBE_NXZ	; std::_Iterator_base_aux::_Has_container
; Function compile flags: /Odtp
;	COMDAT ??8?$_Vector_const_iterator@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<Ogre::ShaderContext *,std::allocator<Ogre::ShaderContext *> >::operator==, COMDAT
; _this$ = ecx

; 203  : 		{	// test for iterator equality

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Has_container@_Iterator_base_aux@std@@QBE_NXZ ; std::_Iterator_base_aux::_Has_container
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@operator@41
	mov	ecx, DWORD PTR __Right$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Same_container@_Iterator_base_aux@std@@QBE_NABV12@@Z ; std::_Iterator_base_aux::_Same_container
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN2@operator@41
$LN1@operator@41:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@operator@41:

; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [eax+4]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+4]
	sete	al

; 212  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??8?$_Vector_const_iterator@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<Ogre::ShaderContext *,std::allocator<Ogre::ShaderContext *> >::operator==
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ?_Same_container@_Iterator_base_aux@std@@QBE_NABV12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Other$ = 8						; size = 4
?_Same_container@_Iterator_base_aux@std@@QBE_NABV12@@Z PROC ; std::_Iterator_base_aux::_Same_container, COMDAT
; _this$ = ecx

; 462  : 		{	// Accelerate the comparison by not going through the aux object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 463  : 		return _Myaux == _Other._Myaux;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Other$[ebp]
	mov	edx, DWORD PTR [eax]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx]
	sete	al

; 464  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Same_container@_Iterator_base_aux@std@@QBE_NABV12@@Z ENDP ; std::_Iterator_base_aux::_Same_container
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Has_container@_Iterator_base_aux@std@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Has_container@_Iterator_base_aux@std@@QBE_NXZ PROC	; std::_Iterator_base_aux::_Has_container, COMDAT
; _this$ = ecx

; 467  : 		{	// Accelerate the comparison by not going through the aux object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 468  : 		return _Myaux != 0;

	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	cmp	DWORD PTR [eax], 0
	setne	cl
	mov	al, cl

; 469  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Has_container@_Iterator_base_aux@std@@QBE_NXZ ENDP	; std::_Iterator_base_aux::_Has_container
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ??8?$_Vector_const_iterator@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<Ogre::ContextQueDesc,std::allocator<Ogre::ContextQueDesc> >::operator==, COMDAT
; _this$ = ecx

; 203  : 		{	// test for iterator equality

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Has_container@_Iterator_base_aux@std@@QBE_NXZ ; std::_Iterator_base_aux::_Has_container
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@operator@42
	mov	ecx, DWORD PTR __Right$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Same_container@_Iterator_base_aux@std@@QBE_NABV12@@Z ; std::_Iterator_base_aux::_Same_container
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN2@operator@42
$LN1@operator@42:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@operator@42:

; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [eax+4]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+4]
	sete	al

; 212  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??8?$_Vector_const_iterator@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<Ogre::ContextQueDesc,std::allocator<Ogre::ContextQueDesc> >::operator==
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??8?$_Vector_const_iterator@EV?$allocator@E@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@EV?$allocator@E@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<unsigned char,std::allocator<unsigned char> >::operator==, COMDAT
; _this$ = ecx

; 203  : 		{	// test for iterator equality

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Has_container@_Iterator_base_aux@std@@QBE_NXZ ; std::_Iterator_base_aux::_Has_container
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@operator@43
	mov	ecx, DWORD PTR __Right$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Same_container@_Iterator_base_aux@std@@QBE_NABV12@@Z ; std::_Iterator_base_aux::_Same_container
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN2@operator@43
$LN1@operator@43:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@operator@43:

; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [eax+4]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+4]
	sete	al

; 212  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??8?$_Vector_const_iterator@EV?$allocator@E@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<unsigned char,std::allocator<unsigned char> >::operator==
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??8?$_Vector_const_iterator@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<Ogre::ShaderContextPool::ValueParam,std::allocator<Ogre::ShaderContextPool::ValueParam> >::operator==, COMDAT
; _this$ = ecx

; 203  : 		{	// test for iterator equality

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Has_container@_Iterator_base_aux@std@@QBE_NXZ ; std::_Iterator_base_aux::_Has_container
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@operator@44
	mov	ecx, DWORD PTR __Right$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Same_container@_Iterator_base_aux@std@@QBE_NABV12@@Z ; std::_Iterator_base_aux::_Same_container
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN2@operator@44
$LN1@operator@44:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@operator@44:

; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [eax+4]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+4]
	sete	al

; 212  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??8?$_Vector_const_iterator@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<Ogre::ShaderContextPool::ValueParam,std::allocator<Ogre::ShaderContextPool::ValueParam> >::operator==
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??8?$_Vector_const_iterator@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<Ogre::ShaderContextPool::TexParam,std::allocator<Ogre::ShaderContextPool::TexParam> >::operator==, COMDAT
; _this$ = ecx

; 203  : 		{	// test for iterator equality

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Has_container@_Iterator_base_aux@std@@QBE_NXZ ; std::_Iterator_base_aux::_Has_container
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@operator@45
	mov	ecx, DWORD PTR __Right$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Same_container@_Iterator_base_aux@std@@QBE_NABV12@@Z ; std::_Iterator_base_aux::_Same_container
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN2@operator@45
$LN1@operator@45:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@operator@45:

; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [eax+4]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+4]
	sete	al

; 212  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??8?$_Vector_const_iterator@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<Ogre::ShaderContextPool::TexParam,std::allocator<Ogre::ShaderContextPool::TexParam> >::operator==
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??8?$_Vector_const_iterator@DV?$allocator@D@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@DV?$allocator@D@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<char,std::allocator<char> >::operator==, COMDAT
; _this$ = ecx

; 203  : 		{	// test for iterator equality

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Has_container@_Iterator_base_aux@std@@QBE_NXZ ; std::_Iterator_base_aux::_Has_container
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@operator@46
	mov	ecx, DWORD PTR __Right$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Same_container@_Iterator_base_aux@std@@QBE_NABV12@@Z ; std::_Iterator_base_aux::_Same_container
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN2@operator@46
$LN1@operator@46:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@operator@46:

; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [eax+4]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+4]
	sete	al

; 212  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??8?$_Vector_const_iterator@DV?$allocator@D@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<char,std::allocator<char> >::operator==
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??8?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::operator==, COMDAT
; _this$ = ecx

; 203  : 		{	// test for iterator equality

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Has_container@_Iterator_base_aux@std@@QBE_NXZ ; std::_Iterator_base_aux::_Has_container
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@operator@47
	mov	ecx, DWORD PTR __Right$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Same_container@_Iterator_base_aux@std@@QBE_NABV12@@Z ; std::_Iterator_base_aux::_Same_container
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN2@operator@47
$LN1@operator@47:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@operator@47:

; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [eax+4]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+4]
	sete	al

; 212  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??8?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::operator==
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??8?$_Vector_const_iterator@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<Ogre::CullResult::Record,std::allocator<Ogre::CullResult::Record> >::operator==, COMDAT
; _this$ = ecx

; 203  : 		{	// test for iterator equality

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Has_container@_Iterator_base_aux@std@@QBE_NXZ ; std::_Iterator_base_aux::_Has_container
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@operator@48
	mov	ecx, DWORD PTR __Right$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Same_container@_Iterator_base_aux@std@@QBE_NABV12@@Z ; std::_Iterator_base_aux::_Same_container
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN2@operator@48
$LN1@operator@48:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@operator@48:

; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [eax+4]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+4]
	sete	al

; 212  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??8?$_Vector_const_iterator@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<Ogre::CullResult::Record,std::allocator<Ogre::CullResult::Record> >::operator==
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??8?$_Vector_const_iterator@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<Ogre::EffectObject *,std::allocator<Ogre::EffectObject *> >::operator==, COMDAT
; _this$ = ecx

; 203  : 		{	// test for iterator equality

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Has_container@_Iterator_base_aux@std@@QBE_NXZ ; std::_Iterator_base_aux::_Has_container
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@operator@49
	mov	ecx, DWORD PTR __Right$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Same_container@_Iterator_base_aux@std@@QBE_NABV12@@Z ; std::_Iterator_base_aux::_Same_container
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN2@operator@49
$LN1@operator@49:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@operator@49:

; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [eax+4]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+4]
	sete	al

; 212  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??8?$_Vector_const_iterator@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<Ogre::EffectObject *,std::allocator<Ogre::EffectObject *> >::operator==
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??8?$_Vector_const_iterator@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<Ogre::SoundNode *,std::allocator<Ogre::SoundNode *> >::operator==, COMDAT
; _this$ = ecx

; 203  : 		{	// test for iterator equality

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Has_container@_Iterator_base_aux@std@@QBE_NXZ ; std::_Iterator_base_aux::_Has_container
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@operator@50
	mov	ecx, DWORD PTR __Right$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Same_container@_Iterator_base_aux@std@@QBE_NABV12@@Z ; std::_Iterator_base_aux::_Same_container
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN2@operator@50
$LN1@operator@50:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@operator@50:

; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [eax+4]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+4]
	sete	al

; 212  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??8?$_Vector_const_iterator@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<Ogre::SoundNode *,std::allocator<Ogre::SoundNode *> >::operator==
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??8?$_Vector_const_iterator@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<Ogre::RenderableObject *,std::allocator<Ogre::RenderableObject *> >::operator==, COMDAT
; _this$ = ecx

; 203  : 		{	// test for iterator equality

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Has_container@_Iterator_base_aux@std@@QBE_NXZ ; std::_Iterator_base_aux::_Has_container
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@operator@51
	mov	ecx, DWORD PTR __Right$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Same_container@_Iterator_base_aux@std@@QBE_NABV12@@Z ; std::_Iterator_base_aux::_Same_container
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN2@operator@51
$LN1@operator@51:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@operator@51:

; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [eax+4]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+4]
	sete	al

; 212  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??8?$_Vector_const_iterator@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<Ogre::RenderableObject *,std::allocator<Ogre::RenderableObject *> >::operator==
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??8?$_Vector_const_iterator@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<Ogre::Light *,std::allocator<Ogre::Light *> >::operator==, COMDAT
; _this$ = ecx

; 203  : 		{	// test for iterator equality

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Has_container@_Iterator_base_aux@std@@QBE_NXZ ; std::_Iterator_base_aux::_Has_container
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@operator@52
	mov	ecx, DWORD PTR __Right$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Same_container@_Iterator_base_aux@std@@QBE_NABV12@@Z ; std::_Iterator_base_aux::_Same_container
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN2@operator@52
$LN1@operator@52:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@operator@52:

; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [eax+4]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+4]
	sete	al

; 212  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??8?$_Vector_const_iterator@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<Ogre::Light *,std::allocator<Ogre::Light *> >::operator==
_TEXT	ENDS
PUBLIC	??0?$_Ranit@PAVMaterialParam@Ogre@@HPBQAV12@ABQAV12@@std@@QAE@XZ ; std::_Ranit<Ogre::MaterialParam *,int,Ogre::MaterialParam * const *,Ogre::MaterialParam * const &>::_Ranit<Ogre::MaterialParam *,int,Ogre::MaterialParam * const *,Ogre::MaterialParam * const &>
; Function compile flags: /Odtp
;	COMDAT ??0?$_Vector_const_iterator@PAVMaterialParam@Ogre@@V?$allocator@PAVMaterialParam@Ogre@@@std@@@std@@QAE@PAPAVMaterialParam@Ogre@@PBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@PAVMaterialParam@Ogre@@V?$allocator@PAVMaterialParam@Ogre@@@std@@@std@@QAE@PAPAVMaterialParam@Ogre@@PBV_Container_base_aux@1@@Z PROC ; std::_Vector_const_iterator<Ogre::MaterialParam *,std::allocator<Ogre::MaterialParam *> >::_Vector_const_iterator<Ogre::MaterialParam *,std::allocator<Ogre::MaterialParam *> >, COMDAT
; _this$ = ecx

; 76   : 	_Vector_const_iterator(_Tptr _Ptr, const _Container_base *_Pvector)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Ranit@PAVMaterialParam@Ogre@@HPBQAV12@ABQAV12@@std@@QAE@XZ

; 77   : 		{	// construct with pointer _Ptr
; 78   : 		_SCL_SECURE_VALIDATE(_Pvector != NULL && ((_Myvec *)_Pvector)->_Myfirst <= _Ptr && _Ptr <= ((_Myvec *)_Pvector)->_Mylast);

	cmp	DWORD PTR __Pvector$[ebp], 0
	je	SHORT $LN1@Vector_con@18
	mov	eax, DWORD PTR __Pvector$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	cmp	ecx, DWORD PTR __Ptr$[ebp]
	ja	SHORT $LN1@Vector_con@18
	mov	edx, DWORD PTR __Pvector$[ebp]
	mov	eax, DWORD PTR __Ptr$[ebp]
	cmp	eax, DWORD PTR [edx+16]
	jbe	SHORT $LN2@Vector_con@18
$LN1@Vector_con@18:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@Vector_con@18:

; 79   : 		this->_Set_container(_Pvector);

	mov	ecx, DWORD PTR __Pvector$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Set_container@_Iterator_base_aux@std@@QAEXQBV_Container_base_aux@2@@Z ; std::_Iterator_base_aux::_Set_container

; 80   : 		_Myptr = _Ptr;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR [edx+4], eax

; 81   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Vector_const_iterator@PAVMaterialParam@Ogre@@V?$allocator@PAVMaterialParam@Ogre@@@std@@@std@@QAE@PAPAVMaterialParam@Ogre@@PBV_Container_base_aux@1@@Z ENDP ; std::_Vector_const_iterator<Ogre::MaterialParam *,std::allocator<Ogre::MaterialParam *> >::_Vector_const_iterator<Ogre::MaterialParam *,std::allocator<Ogre::MaterialParam *> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??8?$_Vector_const_iterator@PAVMaterialParam@Ogre@@V?$allocator@PAVMaterialParam@Ogre@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@PAVMaterialParam@Ogre@@V?$allocator@PAVMaterialParam@Ogre@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<Ogre::MaterialParam *,std::allocator<Ogre::MaterialParam *> >::operator==, COMDAT
; _this$ = ecx

; 203  : 		{	// test for iterator equality

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Has_container@_Iterator_base_aux@std@@QBE_NXZ ; std::_Iterator_base_aux::_Has_container
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@operator@53
	mov	ecx, DWORD PTR __Right$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Same_container@_Iterator_base_aux@std@@QBE_NABV12@@Z ; std::_Iterator_base_aux::_Same_container
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN2@operator@53
$LN1@operator@53:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@operator@53:

; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [eax+4]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+4]
	sete	al

; 212  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??8?$_Vector_const_iterator@PAVMaterialParam@Ogre@@V?$allocator@PAVMaterialParam@Ogre@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<Ogre::MaterialParam *,std::allocator<Ogre::MaterialParam *> >::operator==
_TEXT	ENDS
PUBLIC	??0?$_Ranit@GHPBGABG@std@@QAE@XZ		; std::_Ranit<unsigned short,int,unsigned short const *,unsigned short const &>::_Ranit<unsigned short,int,unsigned short const *,unsigned short const &>
; Function compile flags: /Odtp
;	COMDAT ??0?$_Vector_const_iterator@GV?$allocator@G@std@@@std@@QAE@PAGPBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@GV?$allocator@G@std@@@std@@QAE@PAGPBV_Container_base_aux@1@@Z PROC ; std::_Vector_const_iterator<unsigned short,std::allocator<unsigned short> >::_Vector_const_iterator<unsigned short,std::allocator<unsigned short> >, COMDAT
; _this$ = ecx

; 76   : 	_Vector_const_iterator(_Tptr _Ptr, const _Container_base *_Pvector)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Ranit@GHPBGABG@std@@QAE@XZ

; 77   : 		{	// construct with pointer _Ptr
; 78   : 		_SCL_SECURE_VALIDATE(_Pvector != NULL && ((_Myvec *)_Pvector)->_Myfirst <= _Ptr && _Ptr <= ((_Myvec *)_Pvector)->_Mylast);

	cmp	DWORD PTR __Pvector$[ebp], 0
	je	SHORT $LN1@Vector_con@19
	mov	eax, DWORD PTR __Pvector$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	cmp	ecx, DWORD PTR __Ptr$[ebp]
	ja	SHORT $LN1@Vector_con@19
	mov	edx, DWORD PTR __Pvector$[ebp]
	mov	eax, DWORD PTR __Ptr$[ebp]
	cmp	eax, DWORD PTR [edx+16]
	jbe	SHORT $LN2@Vector_con@19
$LN1@Vector_con@19:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@Vector_con@19:

; 79   : 		this->_Set_container(_Pvector);

	mov	ecx, DWORD PTR __Pvector$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Set_container@_Iterator_base_aux@std@@QAEXQBV_Container_base_aux@2@@Z ; std::_Iterator_base_aux::_Set_container

; 80   : 		_Myptr = _Ptr;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR [edx+4], eax

; 81   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Vector_const_iterator@GV?$allocator@G@std@@@std@@QAE@PAGPBV_Container_base_aux@1@@Z ENDP ; std::_Vector_const_iterator<unsigned short,std::allocator<unsigned short> >::_Vector_const_iterator<unsigned short,std::allocator<unsigned short> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??8?$_Vector_const_iterator@GV?$allocator@G@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@GV?$allocator@G@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<unsigned short,std::allocator<unsigned short> >::operator==, COMDAT
; _this$ = ecx

; 203  : 		{	// test for iterator equality

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Has_container@_Iterator_base_aux@std@@QBE_NXZ ; std::_Iterator_base_aux::_Has_container
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@operator@54
	mov	ecx, DWORD PTR __Right$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Same_container@_Iterator_base_aux@std@@QBE_NABV12@@Z ; std::_Iterator_base_aux::_Same_container
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN2@operator@54
$LN1@operator@54:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@operator@54:

; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [eax+4]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+4]
	sete	al

; 212  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??8?$_Vector_const_iterator@GV?$allocator@G@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<unsigned short,std::allocator<unsigned short> >::operator==
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0?$_Vector_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAE@PAUAnimRange@BaseKeyFrameArray@Ogre@@PBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAE@PAUAnimRange@BaseKeyFrameArray@Ogre@@PBV_Container_base_aux@1@@Z PROC ; std::_Vector_iterator<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::_Vector_iterator<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >, COMDAT
; _this$ = ecx

; 327  : 		{	// construct with pointer _Ptr

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Pvector$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAE@PAUAnimRange@BaseKeyFrameArray@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::_Vector_const_iterator<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >

; 328  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Vector_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAE@PAUAnimRange@BaseKeyFrameArray@Ogre@@PBV_Container_base_aux@1@@Z ENDP ; std::_Vector_iterator<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::_Vector_iterator<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0?$_Vector_iterator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAE@PAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAE@PAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PBV_Container_base_aux@1@@Z PROC ; std::_Vector_iterator<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::_Vector_iterator<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >, COMDAT
; _this$ = ecx

; 327  : 		{	// construct with pointer _Ptr

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Pvector$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAE@PAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::_Vector_const_iterator<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >

; 328  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Vector_iterator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAE@PAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PBV_Container_base_aux@1@@Z ENDP ; std::_Vector_iterator<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::_Vector_iterator<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0?$_Vector_iterator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAE@PAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAE@PAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PBV_Container_base_aux@1@@Z PROC ; std::_Vector_iterator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::_Vector_iterator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >, COMDAT
; _this$ = ecx

; 327  : 		{	// construct with pointer _Ptr

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Pvector$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAE@PAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::_Vector_const_iterator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >

; 328  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Vector_iterator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAE@PAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PBV_Container_base_aux@1@@Z ENDP ; std::_Vector_iterator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::_Vector_iterator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0?$_Vector_iterator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAE@PAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAE@PAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PBV_Container_base_aux@1@@Z PROC ; std::_Vector_iterator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::_Vector_iterator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >, COMDAT
; _this$ = ecx

; 327  : 		{	// construct with pointer _Ptr

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Pvector$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAE@PAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >

; 328  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Vector_iterator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAE@PAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PBV_Container_base_aux@1@@Z ENDP ; std::_Vector_iterator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::_Vector_iterator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0?$_Vector_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAE@PAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAE@PAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PBV_Container_base_aux@1@@Z PROC ; std::_Vector_iterator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::_Vector_iterator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >, COMDAT
; _this$ = ecx

; 327  : 		{	// construct with pointer _Ptr

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Pvector$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAE@PAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >

; 328  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Vector_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAE@PAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PBV_Container_base_aux@1@@Z ENDP ; std::_Vector_iterator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::_Vector_iterator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >
_TEXT	ENDS
PUBLIC	??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@PAVMaterialParam@Ogre@@HPBQAV34@ABQAV34@V_Iterator_base_aux@2@@std@@QAE@XZ ; std::_Iterator_with_base<std::random_access_iterator_tag,Ogre::MaterialParam *,int,Ogre::MaterialParam * const *,Ogre::MaterialParam * const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,Ogre::MaterialParam *,int,Ogre::MaterialParam * const *,Ogre::MaterialParam * const &,std::_Iterator_base_aux>
; Function compile flags: /Odtp
;	COMDAT ??0?$_Ranit@PAVMaterialParam@Ogre@@HPBQAV12@ABQAV12@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Ranit@PAVMaterialParam@Ogre@@HPBQAV12@ABQAV12@@std@@QAE@XZ PROC ; std::_Ranit<Ogre::MaterialParam *,int,Ogre::MaterialParam * const *,Ogre::MaterialParam * const &>::_Ranit<Ogre::MaterialParam *,int,Ogre::MaterialParam * const *,Ogre::MaterialParam * const &>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@PAVMaterialParam@Ogre@@HPBQAV34@ABQAV34@V_Iterator_base_aux@2@@std@@QAE@XZ
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Ranit@PAVMaterialParam@Ogre@@HPBQAV12@ABQAV12@@std@@QAE@XZ ENDP ; std::_Ranit<Ogre::MaterialParam *,int,Ogre::MaterialParam * const *,Ogre::MaterialParam * const &>::_Ranit<Ogre::MaterialParam *,int,Ogre::MaterialParam * const *,Ogre::MaterialParam * const &>
_TEXT	ENDS
PUBLIC	??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@GHPBGABGV_Iterator_base_aux@2@@std@@QAE@XZ ; std::_Iterator_with_base<std::random_access_iterator_tag,unsigned short,int,unsigned short const *,unsigned short const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,unsigned short,int,unsigned short const *,unsigned short const &,std::_Iterator_base_aux>
; Function compile flags: /Odtp
;	COMDAT ??0?$_Ranit@GHPBGABG@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Ranit@GHPBGABG@std@@QAE@XZ PROC			; std::_Ranit<unsigned short,int,unsigned short const *,unsigned short const &>::_Ranit<unsigned short,int,unsigned short const *,unsigned short const &>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@GHPBGABGV_Iterator_base_aux@2@@std@@QAE@XZ
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Ranit@GHPBGABG@std@@QAE@XZ ENDP			; std::_Ranit<unsigned short,int,unsigned short const *,unsigned short const &>::_Ranit<unsigned short,int,unsigned short const *,unsigned short const &>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@PAVMaterialParam@Ogre@@HPBQAV34@ABQAV34@V_Iterator_base_aux@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@PAVMaterialParam@Ogre@@HPBQAV34@ABQAV34@V_Iterator_base_aux@2@@std@@QAE@XZ PROC ; std::_Iterator_with_base<std::random_access_iterator_tag,Ogre::MaterialParam *,int,Ogre::MaterialParam * const *,Ogre::MaterialParam * const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,Ogre::MaterialParam *,int,Ogre::MaterialParam * const *,Ogre::MaterialParam * const &,std::_Iterator_base_aux>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Iterator_base_aux@std@@QAE@XZ	; std::_Iterator_base_aux::_Iterator_base_aux
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@PAVMaterialParam@Ogre@@HPBQAV34@ABQAV34@V_Iterator_base_aux@2@@std@@QAE@XZ ENDP ; std::_Iterator_with_base<std::random_access_iterator_tag,Ogre::MaterialParam *,int,Ogre::MaterialParam * const *,Ogre::MaterialParam * const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,Ogre::MaterialParam *,int,Ogre::MaterialParam * const *,Ogre::MaterialParam * const &,std::_Iterator_base_aux>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@GHPBGABGV_Iterator_base_aux@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@GHPBGABGV_Iterator_base_aux@2@@std@@QAE@XZ PROC ; std::_Iterator_with_base<std::random_access_iterator_tag,unsigned short,int,unsigned short const *,unsigned short const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,unsigned short,int,unsigned short const *,unsigned short const &,std::_Iterator_base_aux>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Iterator_base_aux@std@@QAE@XZ	; std::_Iterator_base_aux::_Iterator_base_aux
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@GHPBGABGV_Iterator_base_aux@2@@std@@QAE@XZ ENDP ; std::_Iterator_with_base<std::random_access_iterator_tag,unsigned short,int,unsigned short const *,unsigned short const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,unsigned short,int,unsigned short const *,unsigned short const &,std::_Iterator_base_aux>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??8?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::operator==, COMDAT
; _this$ = ecx

; 203  : 		{	// test for iterator equality

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Has_container@_Iterator_base_aux@std@@QBE_NXZ ; std::_Iterator_base_aux::_Has_container
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@operator@55
	mov	ecx, DWORD PTR __Right$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Same_container@_Iterator_base_aux@std@@QBE_NABV12@@Z ; std::_Iterator_base_aux::_Same_container
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN2@operator@55
$LN1@operator@55:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@operator@55:

; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [eax+4]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+4]
	sete	al

; 212  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??8?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::operator==
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??8?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::operator==, COMDAT
; _this$ = ecx

; 203  : 		{	// test for iterator equality

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Has_container@_Iterator_base_aux@std@@QBE_NXZ ; std::_Iterator_base_aux::_Has_container
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@operator@56
	mov	ecx, DWORD PTR __Right$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Same_container@_Iterator_base_aux@std@@QBE_NABV12@@Z ; std::_Iterator_base_aux::_Same_container
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN2@operator@56
$LN1@operator@56:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@operator@56:

; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [eax+4]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+4]
	sete	al

; 212  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??8?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::operator==
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??8?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::operator==, COMDAT
; _this$ = ecx

; 203  : 		{	// test for iterator equality

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Has_container@_Iterator_base_aux@std@@QBE_NXZ ; std::_Iterator_base_aux::_Has_container
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@operator@57
	mov	ecx, DWORD PTR __Right$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Same_container@_Iterator_base_aux@std@@QBE_NABV12@@Z ; std::_Iterator_base_aux::_Same_container
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN2@operator@57
$LN1@operator@57:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@operator@57:

; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [eax+4]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+4]
	sete	al

; 212  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??8?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::operator==
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??8?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::operator==, COMDAT
; _this$ = ecx

; 203  : 		{	// test for iterator equality

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Has_container@_Iterator_base_aux@std@@QBE_NXZ ; std::_Iterator_base_aux::_Has_container
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@operator@58
	mov	ecx, DWORD PTR __Right$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Same_container@_Iterator_base_aux@std@@QBE_NABV12@@Z ; std::_Iterator_base_aux::_Same_container
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN2@operator@58
$LN1@operator@58:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@operator@58:

; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [eax+4]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+4]
	sete	al

; 212  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??8?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::operator==
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??8?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::operator==, COMDAT
; _this$ = ecx

; 203  : 		{	// test for iterator equality

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Has_container@_Iterator_base_aux@std@@QBE_NXZ ; std::_Iterator_base_aux::_Has_container
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@operator@59
	mov	ecx, DWORD PTR __Right$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Same_container@_Iterator_base_aux@std@@QBE_NABV12@@Z ; std::_Iterator_base_aux::_Same_container
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN2@operator@59
$LN1@operator@59:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@operator@59:

; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [eax+4]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+4]
	sete	al

; 212  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??8?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::operator==
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogremath.h
_TEXT	ENDS
;	COMDAT ??$Abs@M@Ogre@@YAMABM@Z
_TEXT	SEGMENT
tv68 = -4						; size = 4
_x$ = 8							; size = 4
??$Abs@M@Ogre@@YAMABM@Z PROC				; Ogre::Abs<float>, COMDAT

; 125  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 126  : 		return (x<0.0f) ? (-x) : x;

	mov	eax, DWORD PTR _x$[ebp]
	fld	DWORD PTR [eax]
	fcomp	QWORD PTR __real@0000000000000000
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN3@Abs
	mov	ecx, DWORD PTR _x$[ebp]
	fld	DWORD PTR [ecx]
	fchs
	fstp	DWORD PTR tv68[ebp]
	jmp	SHORT $LN4@Abs
$LN3@Abs:
	mov	edx, DWORD PTR _x$[ebp]
	fld	DWORD PTR [edx]
	fstp	DWORD PTR tv68[ebp]
$LN4@Abs:
	fld	DWORD PTR tv68[ebp]

; 127  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$Abs@M@Ogre@@YAMABM@Z ENDP				; Ogre::Abs<float>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$Max@M@Ogre@@YAMABM0@Z
_TEXT	SEGMENT
tv67 = -4						; size = 4
_a$ = 8							; size = 4
_b$ = 12						; size = 4
??$Max@M@Ogre@@YAMABM0@Z PROC				; Ogre::Max<float>, COMDAT

; 120  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 121  : 		return ( (a) > (b) ? (a) : (b) );

	mov	eax, DWORD PTR _a$[ebp]
	fld	DWORD PTR [eax]
	mov	ecx, DWORD PTR _b$[ebp]
	fld	DWORD PTR [ecx]
	fcompp
	fnstsw	ax
	test	ah, 5
	jp	SHORT $LN3@Max
	mov	edx, DWORD PTR _a$[ebp]
	fld	DWORD PTR [edx]
	fstp	DWORD PTR tv67[ebp]
	jmp	SHORT $LN4@Max
$LN3@Max:
	mov	eax, DWORD PTR _b$[ebp]
	fld	DWORD PTR [eax]
	fstp	DWORD PTR tv67[ebp]
$LN4@Max:
	fld	DWORD PTR tv67[ebp]

; 122  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$Max@M@Ogre@@YAMABM0@Z ENDP				; Ogre::Max<float>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$Min@M@Ogre@@YAMABM0@Z
_TEXT	SEGMENT
tv67 = -4						; size = 4
_a$ = 8							; size = 4
_b$ = 12						; size = 4
??$Min@M@Ogre@@YAMABM0@Z PROC				; Ogre::Min<float>, COMDAT

; 115  : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 116  : 		return ( (a) < (b) ? (a) : (b) );

	mov	eax, DWORD PTR _a$[ebp]
	fld	DWORD PTR [eax]
	mov	ecx, DWORD PTR _b$[ebp]
	fld	DWORD PTR [ecx]
	fcompp
	fnstsw	ax
	test	ah, 65					; 00000041H
	jne	SHORT $LN3@Min
	mov	edx, DWORD PTR _a$[ebp]
	fld	DWORD PTR [edx]
	fstp	DWORD PTR tv67[ebp]
	jmp	SHORT $LN4@Min
$LN3@Min:
	mov	eax, DWORD PTR _b$[ebp]
	fld	DWORD PTR [eax]
	fstp	DWORD PTR tv67[ebp]
$LN4@Min:
	fld	DWORD PTR tv67[ebp]

; 117  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$Min@M@Ogre@@YAMABM0@Z ENDP				; Ogre::Min<float>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$Clamp@H@Ogre@@YAHABH00@Z
_TEXT	SEGMENT
tv66 = -8						; size = 4
tv67 = -4						; size = 4
_x$ = 8							; size = 4
_lo$ = 12						; size = 4
_hi$ = 16						; size = 4
??$Clamp@H@Ogre@@YAHABH00@Z PROC			; Ogre::Clamp<int>, COMDAT

; 110  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 111  : 		return ( ( x < lo ) ? lo : ( x > hi ) ? hi : x );

	mov	eax, DWORD PTR _x$[ebp]
	mov	ecx, DWORD PTR _lo$[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx]
	jge	SHORT $LN5@Clamp
	mov	eax, DWORD PTR _lo$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv67[ebp], ecx
	jmp	SHORT $LN6@Clamp
$LN5@Clamp:
	mov	edx, DWORD PTR _x$[ebp]
	mov	eax, DWORD PTR _hi$[ebp]
	mov	ecx, DWORD PTR [edx]
	cmp	ecx, DWORD PTR [eax]
	jle	SHORT $LN3@Clamp
	mov	edx, DWORD PTR _hi$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR tv66[ebp], eax
	jmp	SHORT $LN4@Clamp
$LN3@Clamp:
	mov	ecx, DWORD PTR _x$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR tv66[ebp], edx
$LN4@Clamp:
	mov	eax, DWORD PTR tv66[ebp]
	mov	DWORD PTR tv67[ebp], eax
$LN6@Clamp:
	mov	eax, DWORD PTR tv67[ebp]

; 112  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$Clamp@H@Ogre@@YAHABH00@Z ENDP			; Ogre::Clamp<int>
_TEXT	ENDS
PUBLIC	?resize@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAEXI@Z ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::resize
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogrearchive.h
;	COMDAT ??$serializeRawArray@UAnimRange@BaseKeyFrameArray@Ogre@@@Archive@Ogre@@QAEAAV01@AAV?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_num$ = -4						; size = 4
_array$ = 8						; size = 4
??$serializeRawArray@UAnimRange@BaseKeyFrameArray@Ogre@@@Archive@Ogre@@QAEAAV01@AAV?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@@Z PROC ; Ogre::Archive::serializeRawArray<Ogre::BaseKeyFrameArray::AnimRange>, COMDAT
; _this$ = ecx

; 121  : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 122  : 			uint num;
; 123  : 			if(isLoading())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?isLoading@Archive@Ogre@@QAE_NXZ	; Ogre::Archive::isLoading
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN4@serializeR

; 124  : 			{
; 125  : 				read(&num, sizeof(num));

	push	4
	lea	ecx, DWORD PTR _num$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?read@Archive@Ogre@@QAEXPAXI@Z		; Ogre::Archive::read

; 126  : 				array.resize(num);

	mov	edx, DWORD PTR _num$[ebp]
	push	edx
	mov	ecx, DWORD PTR _array$[ebp]
	call	?resize@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAEXI@Z ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::resize

; 127  : 				if(num > 0) read(&array[0], num*sizeof(T));

	cmp	DWORD PTR _num$[ebp], 0
	jbe	SHORT $LN3@serializeR
	mov	eax, DWORD PTR _num$[ebp]
	shl	eax, 3
	push	eax
	push	0
	mov	ecx, DWORD PTR _array$[ebp]
	call	??A?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAEAAUAnimRange@BaseKeyFrameArray@Ogre@@I@Z ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::operator[]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?read@Archive@Ogre@@QAEXPAXI@Z		; Ogre::Archive::read
$LN3@serializeR:

; 128  : 			}
; 129  : 			else

	jmp	SHORT $LN2@serializeR
$LN4@serializeR:

; 130  : 			{
; 131  : 				num = (uint)array.size();

	mov	ecx, DWORD PTR _array$[ebp]
	call	?size@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::size
	mov	DWORD PTR _num$[ebp], eax

; 132  : 				write(&num, sizeof(num));

	push	4
	lea	ecx, DWORD PTR _num$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?write@Archive@Ogre@@QAEXPBXI@Z		; Ogre::Archive::write

; 133  : 				if(num > 0) write(&array[0], num*sizeof(T));

	cmp	DWORD PTR _num$[ebp], 0
	jbe	SHORT $LN2@serializeR
	mov	edx, DWORD PTR _num$[ebp]
	shl	edx, 3
	push	edx
	push	0
	mov	ecx, DWORD PTR _array$[ebp]
	call	??A?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAEAAUAnimRange@BaseKeyFrameArray@Ogre@@I@Z ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::operator[]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?write@Archive@Ogre@@QAEXPBXI@Z		; Ogre::Archive::write
$LN2@serializeR:

; 134  : 			}
; 135  : 
; 136  : 			return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 137  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??$serializeRawArray@UAnimRange@BaseKeyFrameArray@Ogre@@@Archive@Ogre@@QAEAAV01@AAV?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@@Z ENDP ; Ogre::Archive::serializeRawArray<Ogre::BaseKeyFrameArray::AnimRange>
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@PAUAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@2@@stdext@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@V?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@0PAU123@AAV?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@5@@Z ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >,Ogre::BaseKeyFrameArray::AnimRange *,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??$_Ucopy@V?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAEPAUAnimRange@BaseKeyFrameArray@Ogre@@V?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@1@0PAU234@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 8
__Last$ = 16						; size = 8
__Ptr$ = 24						; size = 4
??$_Ucopy@V?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAEPAUAnimRange@BaseKeyFrameArray@Ogre@@V?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@1@0PAU234@@Z PROC ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::_Ucopy<std::_Vector_const_iterator<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> > >, COMDAT
; _this$ = ecx

; 1138 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1139 : 		{	// copy initializing [_First, _Last), using allocator
; 1140 : 		return (_STDEXT unchecked_uninitialized_copy(_First, _Last,
; 1141 : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp+4]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@PAUAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@2@@stdext@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@V?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@0PAU123@AAV?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@5@@Z ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >,Ogre::BaseKeyFrameArray::AnimRange *,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >
	add	esp, 24					; 00000018H

; 1142 : 		}

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
??$_Ucopy@V?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAEPAUAnimRange@BaseKeyFrameArray@Ogre@@V?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@1@0PAU234@@Z ENDP ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::_Ucopy<std::_Vector_const_iterator<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> > >
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogrearchive.h
_TEXT	ENDS
;	COMDAT ??$serializeRawType@W4InterpolType@Ogre@@@Archive@Ogre@@QAEXAAW4InterpolType@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_value$ = 8						; size = 4
??$serializeRawType@W4InterpolType@Ogre@@@Archive@Ogre@@QAEXAAW4InterpolType@1@@Z PROC ; Ogre::Archive::serializeRawType<enum Ogre::InterpolType>, COMDAT
; _this$ = ecx

; 97   : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 98   : 			serialize(&value, sizeof(T));

	push	4
	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?serialize@Archive@Ogre@@QAEAAV12@PAXI@Z ; Ogre::Archive::serialize

; 99   : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??$serializeRawType@W4InterpolType@Ogre@@@Archive@Ogre@@QAEXAAW4InterpolType@1@@Z ENDP ; Ogre::Archive::serializeRawType<enum Ogre::InterpolType>
_TEXT	ENDS
PUBLIC	?resize@?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAEXI@Z ; std::vector<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::resize
; Function compile flags: /Odtp
;	COMDAT ??$serializeRawArray@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@Archive@Ogre@@QAEAAV01@AAV?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_num$ = -4						; size = 4
_array$ = 8						; size = 4
??$serializeRawArray@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@Archive@Ogre@@QAEAAV01@AAV?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@@Z PROC ; Ogre::Archive::serializeRawArray<Ogre::KeyFrameArray<float>::KEYFRAME_T>, COMDAT
; _this$ = ecx

; 121  : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 122  : 			uint num;
; 123  : 			if(isLoading())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?isLoading@Archive@Ogre@@QAE_NXZ	; Ogre::Archive::isLoading
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN4@serializeR@2

; 124  : 			{
; 125  : 				read(&num, sizeof(num));

	push	4
	lea	ecx, DWORD PTR _num$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?read@Archive@Ogre@@QAEXPAXI@Z		; Ogre::Archive::read

; 126  : 				array.resize(num);

	mov	edx, DWORD PTR _num$[ebp]
	push	edx
	mov	ecx, DWORD PTR _array$[ebp]
	call	?resize@?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAEXI@Z ; std::vector<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::resize

; 127  : 				if(num > 0) read(&array[0], num*sizeof(T));

	cmp	DWORD PTR _num$[ebp], 0
	jbe	SHORT $LN3@serializeR@2
	mov	eax, DWORD PTR _num$[ebp]
	shl	eax, 3
	push	eax
	push	0
	mov	ecx, DWORD PTR _array$[ebp]
	call	??A?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAEAAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@I@Z ; std::vector<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::operator[]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?read@Archive@Ogre@@QAEXPAXI@Z		; Ogre::Archive::read
$LN3@serializeR@2:

; 128  : 			}
; 129  : 			else

	jmp	SHORT $LN2@serializeR@2
$LN4@serializeR@2:

; 130  : 			{
; 131  : 				num = (uint)array.size();

	mov	ecx, DWORD PTR _array$[ebp]
	call	?size@?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::size
	mov	DWORD PTR _num$[ebp], eax

; 132  : 				write(&num, sizeof(num));

	push	4
	lea	ecx, DWORD PTR _num$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?write@Archive@Ogre@@QAEXPBXI@Z		; Ogre::Archive::write

; 133  : 				if(num > 0) write(&array[0], num*sizeof(T));

	cmp	DWORD PTR _num$[ebp], 0
	jbe	SHORT $LN2@serializeR@2
	mov	edx, DWORD PTR _num$[ebp]
	shl	edx, 3
	push	edx
	push	0
	mov	ecx, DWORD PTR _array$[ebp]
	call	??A?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAEAAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@I@Z ; std::vector<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::operator[]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?write@Archive@Ogre@@QAEXPBXI@Z		; Ogre::Archive::write
$LN2@serializeR@2:

; 134  : 			}
; 135  : 
; 136  : 			return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 137  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??$serializeRawArray@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@Archive@Ogre@@QAEAAV01@AAV?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@@Z ENDP ; Ogre::Archive::serializeRawArray<Ogre::KeyFrameArray<float>::KEYFRAME_T>
_TEXT	ENDS
PUBLIC	?resize@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAEXI@Z ; std::vector<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::resize
; Function compile flags: /Odtp
;	COMDAT ??$serializeRawArray@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@Archive@Ogre@@QAEAAV01@AAV?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_num$ = -4						; size = 4
_array$ = 8						; size = 4
??$serializeRawArray@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@Archive@Ogre@@QAEAAV01@AAV?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@@Z PROC ; Ogre::Archive::serializeRawArray<Ogre::KeyFrameArray<float>::CONTROL_POINT_T>, COMDAT
; _this$ = ecx

; 121  : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 122  : 			uint num;
; 123  : 			if(isLoading())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?isLoading@Archive@Ogre@@QAE_NXZ	; Ogre::Archive::isLoading
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN4@serializeR@3

; 124  : 			{
; 125  : 				read(&num, sizeof(num));

	push	4
	lea	ecx, DWORD PTR _num$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?read@Archive@Ogre@@QAEXPAXI@Z		; Ogre::Archive::read

; 126  : 				array.resize(num);

	mov	edx, DWORD PTR _num$[ebp]
	push	edx
	mov	ecx, DWORD PTR _array$[ebp]
	call	?resize@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAEXI@Z ; std::vector<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::resize

; 127  : 				if(num > 0) read(&array[0], num*sizeof(T));

	cmp	DWORD PTR _num$[ebp], 0
	jbe	SHORT $LN3@serializeR@3
	mov	eax, DWORD PTR _num$[ebp]
	shl	eax, 3
	push	eax
	push	0
	mov	ecx, DWORD PTR _array$[ebp]
	call	??A?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAEAAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@I@Z ; std::vector<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::operator[]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?read@Archive@Ogre@@QAEXPAXI@Z		; Ogre::Archive::read
$LN3@serializeR@3:

; 128  : 			}
; 129  : 			else

	jmp	SHORT $LN2@serializeR@3
$LN4@serializeR@3:

; 130  : 			{
; 131  : 				num = (uint)array.size();

	mov	ecx, DWORD PTR _array$[ebp]
	call	?size@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::size
	mov	DWORD PTR _num$[ebp], eax

; 132  : 				write(&num, sizeof(num));

	push	4
	lea	ecx, DWORD PTR _num$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?write@Archive@Ogre@@QAEXPBXI@Z		; Ogre::Archive::write

; 133  : 				if(num > 0) write(&array[0], num*sizeof(T));

	cmp	DWORD PTR _num$[ebp], 0
	jbe	SHORT $LN2@serializeR@3
	mov	edx, DWORD PTR _num$[ebp]
	shl	edx, 3
	push	edx
	push	0
	mov	ecx, DWORD PTR _array$[ebp]
	call	??A?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAEAAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@I@Z ; std::vector<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::operator[]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?write@Archive@Ogre@@QAEXPBXI@Z		; Ogre::Archive::write
$LN2@serializeR@3:

; 134  : 			}
; 135  : 
; 136  : 			return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 137  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??$serializeRawArray@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@Archive@Ogre@@QAEAAV01@AAV?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@@Z ENDP ; Ogre::Archive::serializeRawArray<Ogre::KeyFrameArray<float>::CONTROL_POINT_T>
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@PAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@2@@stdext@@YAPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@0PAU123@AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@5@@Z ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >,Ogre::KeyFrameArray<float>::KEYFRAME_T *,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??$_Ucopy@V?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@@?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAEPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@1@0PAU234@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 8
__Last$ = 16						; size = 8
__Ptr$ = 24						; size = 4
??$_Ucopy@V?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@@?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAEPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@1@0PAU234@@Z PROC ; std::vector<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::_Ucopy<std::_Vector_const_iterator<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> > >, COMDAT
; _this$ = ecx

; 1138 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1139 : 		{	// copy initializing [_First, _Last), using allocator
; 1140 : 		return (_STDEXT unchecked_uninitialized_copy(_First, _Last,
; 1141 : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp+4]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@PAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@2@@stdext@@YAPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@0PAU123@AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@5@@Z ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >,Ogre::KeyFrameArray<float>::KEYFRAME_T *,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >
	add	esp, 24					; 00000018H

; 1142 : 		}

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
??$_Ucopy@V?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@@?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAEPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@1@0PAU234@@Z ENDP ; std::vector<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::_Ucopy<std::_Vector_const_iterator<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> > >
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@PAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@2@@stdext@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@0PAU123@AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@5@@Z ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >,Ogre::KeyFrameArray<float>::CONTROL_POINT_T *,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >
; Function compile flags: /Odtp
;	COMDAT ??$_Ucopy@V?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAEPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@1@0PAU234@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 8
__Last$ = 16						; size = 8
__Ptr$ = 24						; size = 4
??$_Ucopy@V?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAEPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@1@0PAU234@@Z PROC ; std::vector<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::_Ucopy<std::_Vector_const_iterator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> > >, COMDAT
; _this$ = ecx

; 1138 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1139 : 		{	// copy initializing [_First, _Last), using allocator
; 1140 : 		return (_STDEXT unchecked_uninitialized_copy(_First, _Last,
; 1141 : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp+4]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@PAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@2@@stdext@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@0PAU123@AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@5@@Z ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >,Ogre::KeyFrameArray<float>::CONTROL_POINT_T *,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >
	add	esp, 24					; 00000018H

; 1142 : 		}

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
??$_Ucopy@V?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAEPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@1@0PAU234@@Z ENDP ; std::vector<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::_Ucopy<std::_Vector_const_iterator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> > >
_TEXT	ENDS
PUBLIC	?resize@?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAEXI@Z ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::resize
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogrearchive.h
;	COMDAT ??$serializeRawArray@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@Archive@Ogre@@QAEAAV01@AAV?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_num$ = -4						; size = 4
_array$ = 8						; size = 4
??$serializeRawArray@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@Archive@Ogre@@QAEAAV01@AAV?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@@Z PROC ; Ogre::Archive::serializeRawArray<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T>, COMDAT
; _this$ = ecx

; 121  : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 122  : 			uint num;
; 123  : 			if(isLoading())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?isLoading@Archive@Ogre@@QAE_NXZ	; Ogre::Archive::isLoading
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN4@serializeR@4

; 124  : 			{
; 125  : 				read(&num, sizeof(num));

	push	4
	lea	ecx, DWORD PTR _num$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?read@Archive@Ogre@@QAEXPAXI@Z		; Ogre::Archive::read

; 126  : 				array.resize(num);

	mov	edx, DWORD PTR _num$[ebp]
	push	edx
	mov	ecx, DWORD PTR _array$[ebp]
	call	?resize@?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAEXI@Z ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::resize

; 127  : 				if(num > 0) read(&array[0], num*sizeof(T));

	cmp	DWORD PTR _num$[ebp], 0
	jbe	SHORT $LN3@serializeR@4
	mov	eax, DWORD PTR _num$[ebp]
	imul	eax, 20					; 00000014H
	push	eax
	push	0
	mov	ecx, DWORD PTR _array$[ebp]
	call	??A?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAEAAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@I@Z ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::operator[]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?read@Archive@Ogre@@QAEXPAXI@Z		; Ogre::Archive::read
$LN3@serializeR@4:

; 128  : 			}
; 129  : 			else

	jmp	SHORT $LN2@serializeR@4
$LN4@serializeR@4:

; 130  : 			{
; 131  : 				num = (uint)array.size();

	mov	ecx, DWORD PTR _array$[ebp]
	call	?size@?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::size
	mov	DWORD PTR _num$[ebp], eax

; 132  : 				write(&num, sizeof(num));

	push	4
	lea	ecx, DWORD PTR _num$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?write@Archive@Ogre@@QAEXPBXI@Z		; Ogre::Archive::write

; 133  : 				if(num > 0) write(&array[0], num*sizeof(T));

	cmp	DWORD PTR _num$[ebp], 0
	jbe	SHORT $LN2@serializeR@4
	mov	edx, DWORD PTR _num$[ebp]
	imul	edx, 20					; 00000014H
	push	edx
	push	0
	mov	ecx, DWORD PTR _array$[ebp]
	call	??A?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAEAAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@I@Z ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::operator[]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?write@Archive@Ogre@@QAEXPBXI@Z		; Ogre::Archive::write
$LN2@serializeR@4:

; 134  : 			}
; 135  : 
; 136  : 			return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 137  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??$serializeRawArray@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@Archive@Ogre@@QAEAAV01@AAV?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@@Z ENDP ; Ogre::Archive::serializeRawArray<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T>
_TEXT	ENDS
PUBLIC	?resize@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAEXI@Z ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::resize
; Function compile flags: /Odtp
;	COMDAT ??$serializeRawArray@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@Archive@Ogre@@QAEAAV01@AAV?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_num$ = -4						; size = 4
_array$ = 8						; size = 4
??$serializeRawArray@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@Archive@Ogre@@QAEAAV01@AAV?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@@Z PROC ; Ogre::Archive::serializeRawArray<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T>, COMDAT
; _this$ = ecx

; 121  : 		{

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 122  : 			uint num;
; 123  : 			if(isLoading())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?isLoading@Archive@Ogre@@QAE_NXZ	; Ogre::Archive::isLoading
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN4@serializeR@5

; 124  : 			{
; 125  : 				read(&num, sizeof(num));

	push	4
	lea	ecx, DWORD PTR _num$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?read@Archive@Ogre@@QAEXPAXI@Z		; Ogre::Archive::read

; 126  : 				array.resize(num);

	mov	edx, DWORD PTR _num$[ebp]
	push	edx
	mov	ecx, DWORD PTR _array$[ebp]
	call	?resize@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAEXI@Z ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::resize

; 127  : 				if(num > 0) read(&array[0], num*sizeof(T));

	cmp	DWORD PTR _num$[ebp], 0
	jbe	SHORT $LN3@serializeR@5
	mov	eax, DWORD PTR _num$[ebp]
	shl	eax, 5
	push	eax
	push	0
	mov	ecx, DWORD PTR _array$[ebp]
	call	??A?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAEAAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@I@Z ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::operator[]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?read@Archive@Ogre@@QAEXPAXI@Z		; Ogre::Archive::read
$LN3@serializeR@5:

; 128  : 			}
; 129  : 			else

	jmp	SHORT $LN2@serializeR@5
$LN4@serializeR@5:

; 130  : 			{
; 131  : 				num = (uint)array.size();

	mov	ecx, DWORD PTR _array$[ebp]
	call	?size@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::size
	mov	DWORD PTR _num$[ebp], eax

; 132  : 				write(&num, sizeof(num));

	push	4
	lea	ecx, DWORD PTR _num$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?write@Archive@Ogre@@QAEXPBXI@Z		; Ogre::Archive::write

; 133  : 				if(num > 0) write(&array[0], num*sizeof(T));

	cmp	DWORD PTR _num$[ebp], 0
	jbe	SHORT $LN2@serializeR@5
	mov	edx, DWORD PTR _num$[ebp]
	shl	edx, 5
	push	edx
	push	0
	mov	ecx, DWORD PTR _array$[ebp]
	call	??A?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAEAAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@I@Z ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::operator[]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?write@Archive@Ogre@@QAEXPBXI@Z		; Ogre::Archive::write
$LN2@serializeR@5:

; 134  : 			}
; 135  : 
; 136  : 			return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 137  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??$serializeRawArray@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@Archive@Ogre@@QAEAAV01@AAV?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@@Z ENDP ; Ogre::Archive::serializeRawArray<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T>
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@PAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@2@@stdext@@YAPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@0PAU123@AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@5@@Z ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >,Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T *,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??$_Ucopy@V?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@@?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAEPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@1@0PAU234@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 8
__Last$ = 16						; size = 8
__Ptr$ = 24						; size = 4
??$_Ucopy@V?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@@?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAEPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@1@0PAU234@@Z PROC ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::_Ucopy<std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> > >, COMDAT
; _this$ = ecx

; 1138 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1139 : 		{	// copy initializing [_First, _Last), using allocator
; 1140 : 		return (_STDEXT unchecked_uninitialized_copy(_First, _Last,
; 1141 : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp+4]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@PAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@2@@stdext@@YAPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@0PAU123@AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@5@@Z ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >,Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T *,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >
	add	esp, 24					; 00000018H

; 1142 : 		}

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
??$_Ucopy@V?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@@?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAEPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@1@0PAU234@@Z ENDP ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::_Ucopy<std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> > >
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@PAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@2@@stdext@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@0PAU123@AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@5@@Z ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >,Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T *,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >
; Function compile flags: /Odtp
;	COMDAT ??$_Ucopy@V?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAEPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@1@0PAU234@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 8
__Last$ = 16						; size = 8
__Ptr$ = 24						; size = 4
??$_Ucopy@V?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAEPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@1@0PAU234@@Z PROC ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::_Ucopy<std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> > >, COMDAT
; _this$ = ecx

; 1138 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1139 : 		{	// copy initializing [_First, _Last), using allocator
; 1140 : 		return (_STDEXT unchecked_uninitialized_copy(_First, _Last,
; 1141 : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp+4]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@PAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@2@@stdext@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@0PAU123@AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@5@@Z ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >,Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T *,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >
	add	esp, 24					; 00000018H

; 1142 : 		}

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
??$_Ucopy@V?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAEPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@1@0PAU234@@Z ENDP ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::_Ucopy<std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> > >
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@PAPAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@2@@stdext@@YAPAPAVShaderContext@Ogre@@V?$_Vector_const_iterator@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@0PAPAV12@AAV?$allocator@PAVShaderContext@Ogre@@@4@@Z ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<Ogre::ShaderContext *,std::allocator<Ogre::ShaderContext *> >,Ogre::ShaderContext * *,std::allocator<Ogre::ShaderContext *> >
; Function compile flags: /Odtp
;	COMDAT ??$_Ucopy@V?$_Vector_const_iterator@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@@?$vector@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@IAEPAPAVShaderContext@Ogre@@V?$_Vector_const_iterator@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@1@0PAPAV23@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 8
__Last$ = 16						; size = 8
__Ptr$ = 24						; size = 4
??$_Ucopy@V?$_Vector_const_iterator@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@@?$vector@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@IAEPAPAVShaderContext@Ogre@@V?$_Vector_const_iterator@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@1@0PAPAV23@@Z PROC ; std::vector<Ogre::ShaderContext *,std::allocator<Ogre::ShaderContext *> >::_Ucopy<std::_Vector_const_iterator<Ogre::ShaderContext *,std::allocator<Ogre::ShaderContext *> > >, COMDAT
; _this$ = ecx

; 1138 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1139 : 		{	// copy initializing [_First, _Last), using allocator
; 1140 : 		return (_STDEXT unchecked_uninitialized_copy(_First, _Last,
; 1141 : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp+4]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@PAPAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@2@@stdext@@YAPAPAVShaderContext@Ogre@@V?$_Vector_const_iterator@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@0PAPAV12@AAV?$allocator@PAVShaderContext@Ogre@@@4@@Z ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<Ogre::ShaderContext *,std::allocator<Ogre::ShaderContext *> >,Ogre::ShaderContext * *,std::allocator<Ogre::ShaderContext *> >
	add	esp, 24					; 00000018H

; 1142 : 		}

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
??$_Ucopy@V?$_Vector_const_iterator@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@@?$vector@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@IAEPAPAVShaderContext@Ogre@@V?$_Vector_const_iterator@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@1@0PAPAV23@@Z ENDP ; std::vector<Ogre::ShaderContext *,std::allocator<Ogre::ShaderContext *> >::_Ucopy<std::_Vector_const_iterator<Ogre::ShaderContext *,std::allocator<Ogre::ShaderContext *> > >
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAPAVShaderContext@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@@std@@YAPAPAVShaderContext@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<Ogre::ShaderContext * *,Ogre::ShaderContext * *,std::random_access_iterator_tag>
PUBLIC	??$_Checked_base@PAPAVShaderContext@Ogre@@@std@@YAPAPAVShaderContext@Ogre@@AAPAPAV12@@Z ; std::_Checked_base<Ogre::ShaderContext * *>
PUBLIC	??$_Iter_random@PAPAVShaderContext@Ogre@@PAPAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVShaderContext@Ogre@@0@Z ; std::_Iter_random<Ogre::ShaderContext * *,Ogre::ShaderContext * *>
PUBLIC	??$_Ptr_cat@PAPAVShaderContext@Ogre@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVShaderContext@Ogre@@0@Z ; std::_Ptr_cat<Ogre::ShaderContext * *,Ogre::ShaderContext * *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$unchecked_copy@PAPAVShaderContext@Ogre@@PAPAV12@@stdext@@YAPAPAVShaderContext@Ogre@@PAPAV12@00@Z
_TEXT	SEGMENT
$T97474 = -3						; size = 1
$T97473 = -2						; size = 1
$T97472 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAPAVShaderContext@Ogre@@PAPAV12@@stdext@@YAPAPAVShaderContext@Ogre@@PAPAV12@00@Z PROC ; stdext::unchecked_copy<Ogre::ShaderContext * *,Ogre::ShaderContext * *>, COMDAT

; 3604 : 	{	// copy [_First, _Last) to [_Dest, ...)

	push	ebp
	mov	ebp, esp
	push	ecx

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T97472[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAPAVShaderContext@Ogre@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVShaderContext@Ogre@@0@Z ; std::_Ptr_cat<Ogre::ShaderContext * *,Ogre::ShaderContext * *>
	add	esp, 8
	mov	BYTE PTR $T97473[ebp], al
	movzx	eax, BYTE PTR $T97472[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T97473[ebp]
	push	ecx
	lea	edx, DWORD PTR __Dest$[ebp]
	push	edx
	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T97474[ebp]
	push	ecx
	call	??$_Iter_random@PAPAVShaderContext@Ogre@@PAPAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVShaderContext@Ogre@@0@Z ; std::_Iter_random<Ogre::ShaderContext * *,Ogre::ShaderContext * *>
	add	esp, 12					; 0000000cH
	movzx	edx, BYTE PTR [eax]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@PAPAVShaderContext@Ogre@@@std@@YAPAPAVShaderContext@Ogre@@AAPAPAV12@@Z ; std::_Checked_base<Ogre::ShaderContext * *>
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@PAPAVShaderContext@Ogre@@@std@@YAPAPAVShaderContext@Ogre@@AAPAPAV12@@Z ; std::_Checked_base<Ogre::ShaderContext * *>
	add	esp, 4
	push	eax
	call	??$_Copy_opt@PAPAVShaderContext@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@@std@@YAPAPAVShaderContext@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<Ogre::ShaderContext * *,Ogre::ShaderContext * *,std::random_access_iterator_tag>
	add	esp, 24					; 00000018H

; 3607 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_copy@PAPAVShaderContext@Ogre@@PAPAV12@@stdext@@YAPAPAVShaderContext@Ogre@@PAPAV12@00@Z ENDP ; stdext::unchecked_copy<Ogre::ShaderContext * *,Ogre::ShaderContext * *>
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@PAPAVShaderContext@Ogre@@PAPAV12@V?$allocator@PAVShaderContext@Ogre@@@std@@@stdext@@YAPAPAVShaderContext@Ogre@@PAPAV12@00AAV?$allocator@PAVShaderContext@Ogre@@@std@@@Z ; stdext::unchecked_uninitialized_copy<Ogre::ShaderContext * *,Ogre::ShaderContext * *,std::allocator<Ogre::ShaderContext *> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??$_Ucopy@PAPAVShaderContext@Ogre@@@?$vector@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@IAEPAPAVShaderContext@Ogre@@PAPAV23@00@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Ucopy@PAPAVShaderContext@Ogre@@@?$vector@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@IAEPAPAVShaderContext@Ogre@@PAPAV23@00@Z PROC ; std::vector<Ogre::ShaderContext *,std::allocator<Ogre::ShaderContext *> >::_Ucopy<Ogre::ShaderContext * *>, COMDAT
; _this$ = ecx

; 1138 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1139 : 		{	// copy initializing [_First, _Last), using allocator
; 1140 : 		return (_STDEXT unchecked_uninitialized_copy(_First, _Last,
; 1141 : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$unchecked_uninitialized_copy@PAPAVShaderContext@Ogre@@PAPAV12@V?$allocator@PAVShaderContext@Ogre@@@std@@@stdext@@YAPAPAVShaderContext@Ogre@@PAPAV12@00AAV?$allocator@PAVShaderContext@Ogre@@@std@@@Z ; stdext::unchecked_uninitialized_copy<Ogre::ShaderContext * *,Ogre::ShaderContext * *,std::allocator<Ogre::ShaderContext *> >
	add	esp, 16					; 00000010H

; 1142 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??$_Ucopy@PAPAVShaderContext@Ogre@@@?$vector@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@IAEPAPAVShaderContext@Ogre@@PAPAV23@00@Z ENDP ; std::vector<Ogre::ShaderContext *,std::allocator<Ogre::ShaderContext *> >::_Ucopy<Ogre::ShaderContext * *>
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@PAUContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@2@@stdext@@YAPAUContextQueDesc@Ogre@@V?$_Vector_const_iterator@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@0PAU12@AAV?$allocator@UContextQueDesc@Ogre@@@4@@Z ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<Ogre::ContextQueDesc,std::allocator<Ogre::ContextQueDesc> >,Ogre::ContextQueDesc *,std::allocator<Ogre::ContextQueDesc> >
; Function compile flags: /Odtp
;	COMDAT ??$_Ucopy@V?$_Vector_const_iterator@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@@?$vector@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@IAEPAUContextQueDesc@Ogre@@V?$_Vector_const_iterator@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@1@0PAU23@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 8
__Last$ = 16						; size = 8
__Ptr$ = 24						; size = 4
??$_Ucopy@V?$_Vector_const_iterator@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@@?$vector@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@IAEPAUContextQueDesc@Ogre@@V?$_Vector_const_iterator@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@1@0PAU23@@Z PROC ; std::vector<Ogre::ContextQueDesc,std::allocator<Ogre::ContextQueDesc> >::_Ucopy<std::_Vector_const_iterator<Ogre::ContextQueDesc,std::allocator<Ogre::ContextQueDesc> > >, COMDAT
; _this$ = ecx

; 1138 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1139 : 		{	// copy initializing [_First, _Last), using allocator
; 1140 : 		return (_STDEXT unchecked_uninitialized_copy(_First, _Last,
; 1141 : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp+4]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@PAUContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@2@@stdext@@YAPAUContextQueDesc@Ogre@@V?$_Vector_const_iterator@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@0PAU12@AAV?$allocator@UContextQueDesc@Ogre@@@4@@Z ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<Ogre::ContextQueDesc,std::allocator<Ogre::ContextQueDesc> >,Ogre::ContextQueDesc *,std::allocator<Ogre::ContextQueDesc> >
	add	esp, 24					; 00000018H

; 1142 : 		}

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
??$_Ucopy@V?$_Vector_const_iterator@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@@?$vector@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@IAEPAUContextQueDesc@Ogre@@V?$_Vector_const_iterator@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@1@0PAU23@@Z ENDP ; std::vector<Ogre::ContextQueDesc,std::allocator<Ogre::ContextQueDesc> >::_Ucopy<std::_Vector_const_iterator<Ogre::ContextQueDesc,std::allocator<Ogre::ContextQueDesc> > >
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAUContextQueDesc@Ogre@@PAU12@@std@@YAPAUContextQueDesc@Ogre@@PAU12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<Ogre::ContextQueDesc *,Ogre::ContextQueDesc *>
PUBLIC	??$_Checked_base@PAUContextQueDesc@Ogre@@@std@@YAPAUContextQueDesc@Ogre@@AAPAU12@@Z ; std::_Checked_base<Ogre::ContextQueDesc *>
PUBLIC	??$_Iter_random@PAUContextQueDesc@Ogre@@PAU12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUContextQueDesc@Ogre@@0@Z ; std::_Iter_random<Ogre::ContextQueDesc *,Ogre::ContextQueDesc *>
PUBLIC	??$_Ptr_cat@PAUContextQueDesc@Ogre@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUContextQueDesc@Ogre@@0@Z ; std::_Ptr_cat<Ogre::ContextQueDesc *,Ogre::ContextQueDesc *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$unchecked_copy@PAUContextQueDesc@Ogre@@PAU12@@stdext@@YAPAUContextQueDesc@Ogre@@PAU12@00@Z
_TEXT	SEGMENT
$T97483 = -3						; size = 1
$T97482 = -2						; size = 1
$T97481 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAUContextQueDesc@Ogre@@PAU12@@stdext@@YAPAUContextQueDesc@Ogre@@PAU12@00@Z PROC ; stdext::unchecked_copy<Ogre::ContextQueDesc *,Ogre::ContextQueDesc *>, COMDAT

; 3604 : 	{	// copy [_First, _Last) to [_Dest, ...)

	push	ebp
	mov	ebp, esp
	push	ecx

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T97481[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAUContextQueDesc@Ogre@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUContextQueDesc@Ogre@@0@Z ; std::_Ptr_cat<Ogre::ContextQueDesc *,Ogre::ContextQueDesc *>
	add	esp, 8
	mov	BYTE PTR $T97482[ebp], al
	movzx	eax, BYTE PTR $T97481[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T97482[ebp]
	push	ecx
	lea	edx, DWORD PTR __Dest$[ebp]
	push	edx
	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T97483[ebp]
	push	ecx
	call	??$_Iter_random@PAUContextQueDesc@Ogre@@PAU12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUContextQueDesc@Ogre@@0@Z ; std::_Iter_random<Ogre::ContextQueDesc *,Ogre::ContextQueDesc *>
	add	esp, 12					; 0000000cH
	movzx	edx, BYTE PTR [eax]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@PAUContextQueDesc@Ogre@@@std@@YAPAUContextQueDesc@Ogre@@AAPAU12@@Z ; std::_Checked_base<Ogre::ContextQueDesc *>
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@PAUContextQueDesc@Ogre@@@std@@YAPAUContextQueDesc@Ogre@@AAPAU12@@Z ; std::_Checked_base<Ogre::ContextQueDesc *>
	add	esp, 4
	push	eax
	call	??$_Copy_opt@PAUContextQueDesc@Ogre@@PAU12@@std@@YAPAUContextQueDesc@Ogre@@PAU12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<Ogre::ContextQueDesc *,Ogre::ContextQueDesc *>
	add	esp, 24					; 00000018H

; 3607 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_copy@PAUContextQueDesc@Ogre@@PAU12@@stdext@@YAPAUContextQueDesc@Ogre@@PAU12@00@Z ENDP ; stdext::unchecked_copy<Ogre::ContextQueDesc *,Ogre::ContextQueDesc *>
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@PAUContextQueDesc@Ogre@@PAU12@V?$allocator@UContextQueDesc@Ogre@@@std@@@stdext@@YAPAUContextQueDesc@Ogre@@PAU12@00AAV?$allocator@UContextQueDesc@Ogre@@@std@@@Z ; stdext::unchecked_uninitialized_copy<Ogre::ContextQueDesc *,Ogre::ContextQueDesc *,std::allocator<Ogre::ContextQueDesc> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??$_Ucopy@PAUContextQueDesc@Ogre@@@?$vector@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@IAEPAUContextQueDesc@Ogre@@PAU23@00@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Ucopy@PAUContextQueDesc@Ogre@@@?$vector@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@IAEPAUContextQueDesc@Ogre@@PAU23@00@Z PROC ; std::vector<Ogre::ContextQueDesc,std::allocator<Ogre::ContextQueDesc> >::_Ucopy<Ogre::ContextQueDesc *>, COMDAT
; _this$ = ecx

; 1138 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1139 : 		{	// copy initializing [_First, _Last), using allocator
; 1140 : 		return (_STDEXT unchecked_uninitialized_copy(_First, _Last,
; 1141 : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$unchecked_uninitialized_copy@PAUContextQueDesc@Ogre@@PAU12@V?$allocator@UContextQueDesc@Ogre@@@std@@@stdext@@YAPAUContextQueDesc@Ogre@@PAU12@00AAV?$allocator@UContextQueDesc@Ogre@@@std@@@Z ; stdext::unchecked_uninitialized_copy<Ogre::ContextQueDesc *,Ogre::ContextQueDesc *,std::allocator<Ogre::ContextQueDesc> >
	add	esp, 16					; 00000010H

; 1142 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??$_Ucopy@PAUContextQueDesc@Ogre@@@?$vector@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@IAEPAUContextQueDesc@Ogre@@PAU23@00@Z ENDP ; std::vector<Ogre::ContextQueDesc,std::allocator<Ogre::ContextQueDesc> >::_Ucopy<Ogre::ContextQueDesc *>
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@EV?$allocator@E@std@@@std@@PAEV?$allocator@E@2@@stdext@@YAPAEV?$_Vector_const_iterator@EV?$allocator@E@std@@@std@@0PAEAAV?$allocator@E@2@@Z ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<unsigned char,std::allocator<unsigned char> >,unsigned char *,std::allocator<unsigned char> >
; Function compile flags: /Odtp
;	COMDAT ??$_Ucopy@V?$_Vector_const_iterator@EV?$allocator@E@std@@@std@@@?$vector@EV?$allocator@E@std@@@std@@IAEPAEV?$_Vector_const_iterator@EV?$allocator@E@std@@@1@0PAE@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 8
__Last$ = 16						; size = 8
__Ptr$ = 24						; size = 4
??$_Ucopy@V?$_Vector_const_iterator@EV?$allocator@E@std@@@std@@@?$vector@EV?$allocator@E@std@@@std@@IAEPAEV?$_Vector_const_iterator@EV?$allocator@E@std@@@1@0PAE@Z PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::_Ucopy<std::_Vector_const_iterator<unsigned char,std::allocator<unsigned char> > >, COMDAT
; _this$ = ecx

; 1138 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1139 : 		{	// copy initializing [_First, _Last), using allocator
; 1140 : 		return (_STDEXT unchecked_uninitialized_copy(_First, _Last,
; 1141 : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp+4]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@EV?$allocator@E@std@@@std@@PAEV?$allocator@E@2@@stdext@@YAPAEV?$_Vector_const_iterator@EV?$allocator@E@std@@@std@@0PAEAAV?$allocator@E@2@@Z ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<unsigned char,std::allocator<unsigned char> >,unsigned char *,std::allocator<unsigned char> >
	add	esp, 24					; 00000018H

; 1142 : 		}

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
??$_Ucopy@V?$_Vector_const_iterator@EV?$allocator@E@std@@@std@@@?$vector@EV?$allocator@E@std@@@std@@IAEPAEV?$_Vector_const_iterator@EV?$allocator@E@std@@@1@0PAE@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::_Ucopy<std::_Vector_const_iterator<unsigned char,std::allocator<unsigned char> > >
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAEPAEUrandom_access_iterator_tag@std@@@std@@YAPAEPAE00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<unsigned char *,unsigned char *,std::random_access_iterator_tag>
PUBLIC	??$_Checked_base@PAE@std@@YAPAEAAPAE@Z		; std::_Checked_base<unsigned char *>
PUBLIC	??$_Iter_random@PAEPAE@std@@YA?AUrandom_access_iterator_tag@0@ABQAE0@Z ; std::_Iter_random<unsigned char *,unsigned char *>
PUBLIC	??$_Ptr_cat@PAEPAE@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAE0@Z ; std::_Ptr_cat<unsigned char *,unsigned char *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$unchecked_copy@PAEPAE@stdext@@YAPAEPAE00@Z
_TEXT	SEGMENT
$T97492 = -3						; size = 1
$T97491 = -2						; size = 1
$T97490 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAEPAE@stdext@@YAPAEPAE00@Z PROC	; stdext::unchecked_copy<unsigned char *,unsigned char *>, COMDAT

; 3604 : 	{	// copy [_First, _Last) to [_Dest, ...)

	push	ebp
	mov	ebp, esp
	push	ecx

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T97490[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAEPAE@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAE0@Z ; std::_Ptr_cat<unsigned char *,unsigned char *>
	add	esp, 8
	mov	BYTE PTR $T97491[ebp], al
	movzx	eax, BYTE PTR $T97490[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T97491[ebp]
	push	ecx
	lea	edx, DWORD PTR __Dest$[ebp]
	push	edx
	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T97492[ebp]
	push	ecx
	call	??$_Iter_random@PAEPAE@std@@YA?AUrandom_access_iterator_tag@0@ABQAE0@Z ; std::_Iter_random<unsigned char *,unsigned char *>
	add	esp, 12					; 0000000cH
	movzx	edx, BYTE PTR [eax]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@PAE@std@@YAPAEAAPAE@Z	; std::_Checked_base<unsigned char *>
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@PAE@std@@YAPAEAAPAE@Z	; std::_Checked_base<unsigned char *>
	add	esp, 4
	push	eax
	call	??$_Copy_opt@PAEPAEUrandom_access_iterator_tag@std@@@std@@YAPAEPAE00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<unsigned char *,unsigned char *,std::random_access_iterator_tag>
	add	esp, 24					; 00000018H

; 3607 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_copy@PAEPAE@stdext@@YAPAEPAE00@Z ENDP	; stdext::unchecked_copy<unsigned char *,unsigned char *>
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@PAEPAEV?$allocator@E@std@@@stdext@@YAPAEPAE00AAV?$allocator@E@std@@@Z ; stdext::unchecked_uninitialized_copy<unsigned char *,unsigned char *,std::allocator<unsigned char> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??$_Ucopy@PAE@?$vector@EV?$allocator@E@std@@@std@@IAEPAEPAE00@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Ucopy@PAE@?$vector@EV?$allocator@E@std@@@std@@IAEPAEPAE00@Z PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::_Ucopy<unsigned char *>, COMDAT
; _this$ = ecx

; 1138 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1139 : 		{	// copy initializing [_First, _Last), using allocator
; 1140 : 		return (_STDEXT unchecked_uninitialized_copy(_First, _Last,
; 1141 : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$unchecked_uninitialized_copy@PAEPAEV?$allocator@E@std@@@stdext@@YAPAEPAE00AAV?$allocator@E@std@@@Z ; stdext::unchecked_uninitialized_copy<unsigned char *,unsigned char *,std::allocator<unsigned char> >
	add	esp, 16					; 00000010H

; 1142 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??$_Ucopy@PAE@?$vector@EV?$allocator@E@std@@@std@@IAEPAEPAE00@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::_Ucopy<unsigned char *>
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@PAUValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@2@@stdext@@YAPAUValueParam@ShaderContextPool@Ogre@@V?$_Vector_const_iterator@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@0PAU123@AAV?$allocator@UValueParam@ShaderContextPool@Ogre@@@5@@Z ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<Ogre::ShaderContextPool::ValueParam,std::allocator<Ogre::ShaderContextPool::ValueParam> >,Ogre::ShaderContextPool::ValueParam *,std::allocator<Ogre::ShaderContextPool::ValueParam> >
; Function compile flags: /Odtp
;	COMDAT ??$_Ucopy@V?$_Vector_const_iterator@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@@?$vector@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@IAEPAUValueParam@ShaderContextPool@Ogre@@V?$_Vector_const_iterator@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@1@0PAU234@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 8
__Last$ = 16						; size = 8
__Ptr$ = 24						; size = 4
??$_Ucopy@V?$_Vector_const_iterator@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@@?$vector@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@IAEPAUValueParam@ShaderContextPool@Ogre@@V?$_Vector_const_iterator@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@1@0PAU234@@Z PROC ; std::vector<Ogre::ShaderContextPool::ValueParam,std::allocator<Ogre::ShaderContextPool::ValueParam> >::_Ucopy<std::_Vector_const_iterator<Ogre::ShaderContextPool::ValueParam,std::allocator<Ogre::ShaderContextPool::ValueParam> > >, COMDAT
; _this$ = ecx

; 1138 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1139 : 		{	// copy initializing [_First, _Last), using allocator
; 1140 : 		return (_STDEXT unchecked_uninitialized_copy(_First, _Last,
; 1141 : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp+4]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@PAUValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@2@@stdext@@YAPAUValueParam@ShaderContextPool@Ogre@@V?$_Vector_const_iterator@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@0PAU123@AAV?$allocator@UValueParam@ShaderContextPool@Ogre@@@5@@Z ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<Ogre::ShaderContextPool::ValueParam,std::allocator<Ogre::ShaderContextPool::ValueParam> >,Ogre::ShaderContextPool::ValueParam *,std::allocator<Ogre::ShaderContextPool::ValueParam> >
	add	esp, 24					; 00000018H

; 1142 : 		}

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
??$_Ucopy@V?$_Vector_const_iterator@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@@?$vector@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@IAEPAUValueParam@ShaderContextPool@Ogre@@V?$_Vector_const_iterator@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@1@0PAU234@@Z ENDP ; std::vector<Ogre::ShaderContextPool::ValueParam,std::allocator<Ogre::ShaderContextPool::ValueParam> >::_Ucopy<std::_Vector_const_iterator<Ogre::ShaderContextPool::ValueParam,std::allocator<Ogre::ShaderContextPool::ValueParam> > >
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAUValueParam@ShaderContextPool@Ogre@@PAU123@@std@@YAPAUValueParam@ShaderContextPool@Ogre@@PAU123@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<Ogre::ShaderContextPool::ValueParam *,Ogre::ShaderContextPool::ValueParam *>
PUBLIC	??$_Checked_base@PAUValueParam@ShaderContextPool@Ogre@@@std@@YAPAUValueParam@ShaderContextPool@Ogre@@AAPAU123@@Z ; std::_Checked_base<Ogre::ShaderContextPool::ValueParam *>
PUBLIC	??$_Iter_random@PAUValueParam@ShaderContextPool@Ogre@@PAU123@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUValueParam@ShaderContextPool@Ogre@@0@Z ; std::_Iter_random<Ogre::ShaderContextPool::ValueParam *,Ogre::ShaderContextPool::ValueParam *>
PUBLIC	??$_Ptr_cat@PAUValueParam@ShaderContextPool@Ogre@@PAU123@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUValueParam@ShaderContextPool@Ogre@@0@Z ; std::_Ptr_cat<Ogre::ShaderContextPool::ValueParam *,Ogre::ShaderContextPool::ValueParam *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$unchecked_copy@PAUValueParam@ShaderContextPool@Ogre@@PAU123@@stdext@@YAPAUValueParam@ShaderContextPool@Ogre@@PAU123@00@Z
_TEXT	SEGMENT
$T97501 = -3						; size = 1
$T97500 = -2						; size = 1
$T97499 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAUValueParam@ShaderContextPool@Ogre@@PAU123@@stdext@@YAPAUValueParam@ShaderContextPool@Ogre@@PAU123@00@Z PROC ; stdext::unchecked_copy<Ogre::ShaderContextPool::ValueParam *,Ogre::ShaderContextPool::ValueParam *>, COMDAT

; 3604 : 	{	// copy [_First, _Last) to [_Dest, ...)

	push	ebp
	mov	ebp, esp
	push	ecx

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T97499[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAUValueParam@ShaderContextPool@Ogre@@PAU123@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUValueParam@ShaderContextPool@Ogre@@0@Z ; std::_Ptr_cat<Ogre::ShaderContextPool::ValueParam *,Ogre::ShaderContextPool::ValueParam *>
	add	esp, 8
	mov	BYTE PTR $T97500[ebp], al
	movzx	eax, BYTE PTR $T97499[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T97500[ebp]
	push	ecx
	lea	edx, DWORD PTR __Dest$[ebp]
	push	edx
	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T97501[ebp]
	push	ecx
	call	??$_Iter_random@PAUValueParam@ShaderContextPool@Ogre@@PAU123@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUValueParam@ShaderContextPool@Ogre@@0@Z ; std::_Iter_random<Ogre::ShaderContextPool::ValueParam *,Ogre::ShaderContextPool::ValueParam *>
	add	esp, 12					; 0000000cH
	movzx	edx, BYTE PTR [eax]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@PAUValueParam@ShaderContextPool@Ogre@@@std@@YAPAUValueParam@ShaderContextPool@Ogre@@AAPAU123@@Z ; std::_Checked_base<Ogre::ShaderContextPool::ValueParam *>
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@PAUValueParam@ShaderContextPool@Ogre@@@std@@YAPAUValueParam@ShaderContextPool@Ogre@@AAPAU123@@Z ; std::_Checked_base<Ogre::ShaderContextPool::ValueParam *>
	add	esp, 4
	push	eax
	call	??$_Copy_opt@PAUValueParam@ShaderContextPool@Ogre@@PAU123@@std@@YAPAUValueParam@ShaderContextPool@Ogre@@PAU123@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<Ogre::ShaderContextPool::ValueParam *,Ogre::ShaderContextPool::ValueParam *>
	add	esp, 24					; 00000018H

; 3607 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_copy@PAUValueParam@ShaderContextPool@Ogre@@PAU123@@stdext@@YAPAUValueParam@ShaderContextPool@Ogre@@PAU123@00@Z ENDP ; stdext::unchecked_copy<Ogre::ShaderContextPool::ValueParam *,Ogre::ShaderContextPool::ValueParam *>
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@PAUValueParam@ShaderContextPool@Ogre@@PAU123@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@stdext@@YAPAUValueParam@ShaderContextPool@Ogre@@PAU123@00AAV?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@Z ; stdext::unchecked_uninitialized_copy<Ogre::ShaderContextPool::ValueParam *,Ogre::ShaderContextPool::ValueParam *,std::allocator<Ogre::ShaderContextPool::ValueParam> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??$_Ucopy@PAUValueParam@ShaderContextPool@Ogre@@@?$vector@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@IAEPAUValueParam@ShaderContextPool@Ogre@@PAU234@00@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Ucopy@PAUValueParam@ShaderContextPool@Ogre@@@?$vector@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@IAEPAUValueParam@ShaderContextPool@Ogre@@PAU234@00@Z PROC ; std::vector<Ogre::ShaderContextPool::ValueParam,std::allocator<Ogre::ShaderContextPool::ValueParam> >::_Ucopy<Ogre::ShaderContextPool::ValueParam *>, COMDAT
; _this$ = ecx

; 1138 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1139 : 		{	// copy initializing [_First, _Last), using allocator
; 1140 : 		return (_STDEXT unchecked_uninitialized_copy(_First, _Last,
; 1141 : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$unchecked_uninitialized_copy@PAUValueParam@ShaderContextPool@Ogre@@PAU123@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@stdext@@YAPAUValueParam@ShaderContextPool@Ogre@@PAU123@00AAV?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@Z ; stdext::unchecked_uninitialized_copy<Ogre::ShaderContextPool::ValueParam *,Ogre::ShaderContextPool::ValueParam *,std::allocator<Ogre::ShaderContextPool::ValueParam> >
	add	esp, 16					; 00000010H

; 1142 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??$_Ucopy@PAUValueParam@ShaderContextPool@Ogre@@@?$vector@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@IAEPAUValueParam@ShaderContextPool@Ogre@@PAU234@00@Z ENDP ; std::vector<Ogre::ShaderContextPool::ValueParam,std::allocator<Ogre::ShaderContextPool::ValueParam> >::_Ucopy<Ogre::ShaderContextPool::ValueParam *>
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@PAUTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@2@@stdext@@YAPAUTexParam@ShaderContextPool@Ogre@@V?$_Vector_const_iterator@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@0PAU123@AAV?$allocator@UTexParam@ShaderContextPool@Ogre@@@5@@Z ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<Ogre::ShaderContextPool::TexParam,std::allocator<Ogre::ShaderContextPool::TexParam> >,Ogre::ShaderContextPool::TexParam *,std::allocator<Ogre::ShaderContextPool::TexParam> >
; Function compile flags: /Odtp
;	COMDAT ??$_Ucopy@V?$_Vector_const_iterator@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@@?$vector@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@IAEPAUTexParam@ShaderContextPool@Ogre@@V?$_Vector_const_iterator@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@1@0PAU234@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 8
__Last$ = 16						; size = 8
__Ptr$ = 24						; size = 4
??$_Ucopy@V?$_Vector_const_iterator@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@@?$vector@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@IAEPAUTexParam@ShaderContextPool@Ogre@@V?$_Vector_const_iterator@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@1@0PAU234@@Z PROC ; std::vector<Ogre::ShaderContextPool::TexParam,std::allocator<Ogre::ShaderContextPool::TexParam> >::_Ucopy<std::_Vector_const_iterator<Ogre::ShaderContextPool::TexParam,std::allocator<Ogre::ShaderContextPool::TexParam> > >, COMDAT
; _this$ = ecx

; 1138 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1139 : 		{	// copy initializing [_First, _Last), using allocator
; 1140 : 		return (_STDEXT unchecked_uninitialized_copy(_First, _Last,
; 1141 : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp+4]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@PAUTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@2@@stdext@@YAPAUTexParam@ShaderContextPool@Ogre@@V?$_Vector_const_iterator@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@0PAU123@AAV?$allocator@UTexParam@ShaderContextPool@Ogre@@@5@@Z ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<Ogre::ShaderContextPool::TexParam,std::allocator<Ogre::ShaderContextPool::TexParam> >,Ogre::ShaderContextPool::TexParam *,std::allocator<Ogre::ShaderContextPool::TexParam> >
	add	esp, 24					; 00000018H

; 1142 : 		}

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
??$_Ucopy@V?$_Vector_const_iterator@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@@?$vector@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@IAEPAUTexParam@ShaderContextPool@Ogre@@V?$_Vector_const_iterator@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@1@0PAU234@@Z ENDP ; std::vector<Ogre::ShaderContextPool::TexParam,std::allocator<Ogre::ShaderContextPool::TexParam> >::_Ucopy<std::_Vector_const_iterator<Ogre::ShaderContextPool::TexParam,std::allocator<Ogre::ShaderContextPool::TexParam> > >
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAUTexParam@ShaderContextPool@Ogre@@PAU123@@std@@YAPAUTexParam@ShaderContextPool@Ogre@@PAU123@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<Ogre::ShaderContextPool::TexParam *,Ogre::ShaderContextPool::TexParam *>
PUBLIC	??$_Checked_base@PAUTexParam@ShaderContextPool@Ogre@@@std@@YAPAUTexParam@ShaderContextPool@Ogre@@AAPAU123@@Z ; std::_Checked_base<Ogre::ShaderContextPool::TexParam *>
PUBLIC	??$_Iter_random@PAUTexParam@ShaderContextPool@Ogre@@PAU123@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUTexParam@ShaderContextPool@Ogre@@0@Z ; std::_Iter_random<Ogre::ShaderContextPool::TexParam *,Ogre::ShaderContextPool::TexParam *>
PUBLIC	??$_Ptr_cat@PAUTexParam@ShaderContextPool@Ogre@@PAU123@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUTexParam@ShaderContextPool@Ogre@@0@Z ; std::_Ptr_cat<Ogre::ShaderContextPool::TexParam *,Ogre::ShaderContextPool::TexParam *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$unchecked_copy@PAUTexParam@ShaderContextPool@Ogre@@PAU123@@stdext@@YAPAUTexParam@ShaderContextPool@Ogre@@PAU123@00@Z
_TEXT	SEGMENT
$T97510 = -3						; size = 1
$T97509 = -2						; size = 1
$T97508 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAUTexParam@ShaderContextPool@Ogre@@PAU123@@stdext@@YAPAUTexParam@ShaderContextPool@Ogre@@PAU123@00@Z PROC ; stdext::unchecked_copy<Ogre::ShaderContextPool::TexParam *,Ogre::ShaderContextPool::TexParam *>, COMDAT

; 3604 : 	{	// copy [_First, _Last) to [_Dest, ...)

	push	ebp
	mov	ebp, esp
	push	ecx

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T97508[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAUTexParam@ShaderContextPool@Ogre@@PAU123@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUTexParam@ShaderContextPool@Ogre@@0@Z ; std::_Ptr_cat<Ogre::ShaderContextPool::TexParam *,Ogre::ShaderContextPool::TexParam *>
	add	esp, 8
	mov	BYTE PTR $T97509[ebp], al
	movzx	eax, BYTE PTR $T97508[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T97509[ebp]
	push	ecx
	lea	edx, DWORD PTR __Dest$[ebp]
	push	edx
	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T97510[ebp]
	push	ecx
	call	??$_Iter_random@PAUTexParam@ShaderContextPool@Ogre@@PAU123@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUTexParam@ShaderContextPool@Ogre@@0@Z ; std::_Iter_random<Ogre::ShaderContextPool::TexParam *,Ogre::ShaderContextPool::TexParam *>
	add	esp, 12					; 0000000cH
	movzx	edx, BYTE PTR [eax]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@PAUTexParam@ShaderContextPool@Ogre@@@std@@YAPAUTexParam@ShaderContextPool@Ogre@@AAPAU123@@Z ; std::_Checked_base<Ogre::ShaderContextPool::TexParam *>
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@PAUTexParam@ShaderContextPool@Ogre@@@std@@YAPAUTexParam@ShaderContextPool@Ogre@@AAPAU123@@Z ; std::_Checked_base<Ogre::ShaderContextPool::TexParam *>
	add	esp, 4
	push	eax
	call	??$_Copy_opt@PAUTexParam@ShaderContextPool@Ogre@@PAU123@@std@@YAPAUTexParam@ShaderContextPool@Ogre@@PAU123@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<Ogre::ShaderContextPool::TexParam *,Ogre::ShaderContextPool::TexParam *>
	add	esp, 24					; 00000018H

; 3607 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_copy@PAUTexParam@ShaderContextPool@Ogre@@PAU123@@stdext@@YAPAUTexParam@ShaderContextPool@Ogre@@PAU123@00@Z ENDP ; stdext::unchecked_copy<Ogre::ShaderContextPool::TexParam *,Ogre::ShaderContextPool::TexParam *>
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@PAUTexParam@ShaderContextPool@Ogre@@PAU123@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@stdext@@YAPAUTexParam@ShaderContextPool@Ogre@@PAU123@00AAV?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@Z ; stdext::unchecked_uninitialized_copy<Ogre::ShaderContextPool::TexParam *,Ogre::ShaderContextPool::TexParam *,std::allocator<Ogre::ShaderContextPool::TexParam> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??$_Ucopy@PAUTexParam@ShaderContextPool@Ogre@@@?$vector@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@IAEPAUTexParam@ShaderContextPool@Ogre@@PAU234@00@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Ucopy@PAUTexParam@ShaderContextPool@Ogre@@@?$vector@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@IAEPAUTexParam@ShaderContextPool@Ogre@@PAU234@00@Z PROC ; std::vector<Ogre::ShaderContextPool::TexParam,std::allocator<Ogre::ShaderContextPool::TexParam> >::_Ucopy<Ogre::ShaderContextPool::TexParam *>, COMDAT
; _this$ = ecx

; 1138 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1139 : 		{	// copy initializing [_First, _Last), using allocator
; 1140 : 		return (_STDEXT unchecked_uninitialized_copy(_First, _Last,
; 1141 : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$unchecked_uninitialized_copy@PAUTexParam@ShaderContextPool@Ogre@@PAU123@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@stdext@@YAPAUTexParam@ShaderContextPool@Ogre@@PAU123@00AAV?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@Z ; stdext::unchecked_uninitialized_copy<Ogre::ShaderContextPool::TexParam *,Ogre::ShaderContextPool::TexParam *,std::allocator<Ogre::ShaderContextPool::TexParam> >
	add	esp, 16					; 00000010H

; 1142 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??$_Ucopy@PAUTexParam@ShaderContextPool@Ogre@@@?$vector@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@IAEPAUTexParam@ShaderContextPool@Ogre@@PAU234@00@Z ENDP ; std::vector<Ogre::ShaderContextPool::TexParam,std::allocator<Ogre::ShaderContextPool::TexParam> >::_Ucopy<Ogre::ShaderContextPool::TexParam *>
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAPAVMaterialParam@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@@std@@YAPAPAVMaterialParam@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<Ogre::MaterialParam * *,Ogre::MaterialParam * *,std::random_access_iterator_tag>
PUBLIC	??$_Checked_base@PAPAVMaterialParam@Ogre@@@std@@YAPAPAVMaterialParam@Ogre@@AAPAPAV12@@Z ; std::_Checked_base<Ogre::MaterialParam * *>
PUBLIC	??$_Iter_random@PAPAVMaterialParam@Ogre@@PAPAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVMaterialParam@Ogre@@0@Z ; std::_Iter_random<Ogre::MaterialParam * *,Ogre::MaterialParam * *>
PUBLIC	??$_Ptr_cat@PAPAVMaterialParam@Ogre@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVMaterialParam@Ogre@@0@Z ; std::_Ptr_cat<Ogre::MaterialParam * *,Ogre::MaterialParam * *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$unchecked_copy@PAPAVMaterialParam@Ogre@@PAPAV12@@stdext@@YAPAPAVMaterialParam@Ogre@@PAPAV12@00@Z
_TEXT	SEGMENT
$T97517 = -3						; size = 1
$T97516 = -2						; size = 1
$T97515 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAPAVMaterialParam@Ogre@@PAPAV12@@stdext@@YAPAPAVMaterialParam@Ogre@@PAPAV12@00@Z PROC ; stdext::unchecked_copy<Ogre::MaterialParam * *,Ogre::MaterialParam * *>, COMDAT

; 3604 : 	{	// copy [_First, _Last) to [_Dest, ...)

	push	ebp
	mov	ebp, esp
	push	ecx

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T97515[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAPAVMaterialParam@Ogre@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVMaterialParam@Ogre@@0@Z ; std::_Ptr_cat<Ogre::MaterialParam * *,Ogre::MaterialParam * *>
	add	esp, 8
	mov	BYTE PTR $T97516[ebp], al
	movzx	eax, BYTE PTR $T97515[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T97516[ebp]
	push	ecx
	lea	edx, DWORD PTR __Dest$[ebp]
	push	edx
	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T97517[ebp]
	push	ecx
	call	??$_Iter_random@PAPAVMaterialParam@Ogre@@PAPAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVMaterialParam@Ogre@@0@Z ; std::_Iter_random<Ogre::MaterialParam * *,Ogre::MaterialParam * *>
	add	esp, 12					; 0000000cH
	movzx	edx, BYTE PTR [eax]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@PAPAVMaterialParam@Ogre@@@std@@YAPAPAVMaterialParam@Ogre@@AAPAPAV12@@Z ; std::_Checked_base<Ogre::MaterialParam * *>
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@PAPAVMaterialParam@Ogre@@@std@@YAPAPAVMaterialParam@Ogre@@AAPAPAV12@@Z ; std::_Checked_base<Ogre::MaterialParam * *>
	add	esp, 4
	push	eax
	call	??$_Copy_opt@PAPAVMaterialParam@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@@std@@YAPAPAVMaterialParam@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<Ogre::MaterialParam * *,Ogre::MaterialParam * *,std::random_access_iterator_tag>
	add	esp, 24					; 00000018H

; 3607 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_copy@PAPAVMaterialParam@Ogre@@PAPAV12@@stdext@@YAPAPAVMaterialParam@Ogre@@PAPAV12@00@Z ENDP ; stdext::unchecked_copy<Ogre::MaterialParam * *,Ogre::MaterialParam * *>
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@PAPAVMaterialParam@Ogre@@PAPAV12@V?$allocator@PAVMaterialParam@Ogre@@@std@@@stdext@@YAPAPAVMaterialParam@Ogre@@PAPAV12@00AAV?$allocator@PAVMaterialParam@Ogre@@@std@@@Z ; stdext::unchecked_uninitialized_copy<Ogre::MaterialParam * *,Ogre::MaterialParam * *,std::allocator<Ogre::MaterialParam *> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??$_Ucopy@PAPAVMaterialParam@Ogre@@@?$vector@PAVMaterialParam@Ogre@@V?$allocator@PAVMaterialParam@Ogre@@@std@@@std@@IAEPAPAVMaterialParam@Ogre@@PAPAV23@00@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Ucopy@PAPAVMaterialParam@Ogre@@@?$vector@PAVMaterialParam@Ogre@@V?$allocator@PAVMaterialParam@Ogre@@@std@@@std@@IAEPAPAVMaterialParam@Ogre@@PAPAV23@00@Z PROC ; std::vector<Ogre::MaterialParam *,std::allocator<Ogre::MaterialParam *> >::_Ucopy<Ogre::MaterialParam * *>, COMDAT
; _this$ = ecx

; 1138 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1139 : 		{	// copy initializing [_First, _Last), using allocator
; 1140 : 		return (_STDEXT unchecked_uninitialized_copy(_First, _Last,
; 1141 : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$unchecked_uninitialized_copy@PAPAVMaterialParam@Ogre@@PAPAV12@V?$allocator@PAVMaterialParam@Ogre@@@std@@@stdext@@YAPAPAVMaterialParam@Ogre@@PAPAV12@00AAV?$allocator@PAVMaterialParam@Ogre@@@std@@@Z ; stdext::unchecked_uninitialized_copy<Ogre::MaterialParam * *,Ogre::MaterialParam * *,std::allocator<Ogre::MaterialParam *> >
	add	esp, 16					; 00000010H

; 1142 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??$_Ucopy@PAPAVMaterialParam@Ogre@@@?$vector@PAVMaterialParam@Ogre@@V?$allocator@PAVMaterialParam@Ogre@@@std@@@std@@IAEPAPAVMaterialParam@Ogre@@PAPAV23@00@Z ENDP ; std::vector<Ogre::MaterialParam *,std::allocator<Ogre::MaterialParam *> >::_Ucopy<Ogre::MaterialParam * *>
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@DV?$allocator@D@std@@@std@@PADV?$allocator@D@2@@stdext@@YAPADV?$_Vector_const_iterator@DV?$allocator@D@std@@@std@@0PADAAV?$allocator@D@2@@Z ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<char,std::allocator<char> >,char *,std::allocator<char> >
; Function compile flags: /Odtp
;	COMDAT ??$_Ucopy@V?$_Vector_const_iterator@DV?$allocator@D@std@@@std@@@?$vector@DV?$allocator@D@std@@@std@@IAEPADV?$_Vector_const_iterator@DV?$allocator@D@std@@@1@0PAD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 8
__Last$ = 16						; size = 8
__Ptr$ = 24						; size = 4
??$_Ucopy@V?$_Vector_const_iterator@DV?$allocator@D@std@@@std@@@?$vector@DV?$allocator@D@std@@@std@@IAEPADV?$_Vector_const_iterator@DV?$allocator@D@std@@@1@0PAD@Z PROC ; std::vector<char,std::allocator<char> >::_Ucopy<std::_Vector_const_iterator<char,std::allocator<char> > >, COMDAT
; _this$ = ecx

; 1138 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1139 : 		{	// copy initializing [_First, _Last), using allocator
; 1140 : 		return (_STDEXT unchecked_uninitialized_copy(_First, _Last,
; 1141 : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp+4]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@DV?$allocator@D@std@@@std@@PADV?$allocator@D@2@@stdext@@YAPADV?$_Vector_const_iterator@DV?$allocator@D@std@@@std@@0PADAAV?$allocator@D@2@@Z ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<char,std::allocator<char> >,char *,std::allocator<char> >
	add	esp, 24					; 00000018H

; 1142 : 		}

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
??$_Ucopy@V?$_Vector_const_iterator@DV?$allocator@D@std@@@std@@@?$vector@DV?$allocator@D@std@@@std@@IAEPADV?$_Vector_const_iterator@DV?$allocator@D@std@@@1@0PAD@Z ENDP ; std::vector<char,std::allocator<char> >::_Ucopy<std::_Vector_const_iterator<char,std::allocator<char> > >
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PADPADUrandom_access_iterator_tag@std@@@std@@YAPADPAD00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<char *,char *,std::random_access_iterator_tag>
PUBLIC	??$_Checked_base@PAD@std@@YAPADAAPAD@Z		; std::_Checked_base<char *>
PUBLIC	??$_Iter_random@PADPAD@std@@YA?AUrandom_access_iterator_tag@0@ABQAD0@Z ; std::_Iter_random<char *,char *>
PUBLIC	??$_Ptr_cat@PADPAD@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAD0@Z ; std::_Ptr_cat<char *,char *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$unchecked_copy@PADPAD@stdext@@YAPADPAD00@Z
_TEXT	SEGMENT
$T97526 = -3						; size = 1
$T97525 = -2						; size = 1
$T97524 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PADPAD@stdext@@YAPADPAD00@Z PROC	; stdext::unchecked_copy<char *,char *>, COMDAT

; 3604 : 	{	// copy [_First, _Last) to [_Dest, ...)

	push	ebp
	mov	ebp, esp
	push	ecx

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T97524[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PADPAD@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAD0@Z ; std::_Ptr_cat<char *,char *>
	add	esp, 8
	mov	BYTE PTR $T97525[ebp], al
	movzx	eax, BYTE PTR $T97524[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T97525[ebp]
	push	ecx
	lea	edx, DWORD PTR __Dest$[ebp]
	push	edx
	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T97526[ebp]
	push	ecx
	call	??$_Iter_random@PADPAD@std@@YA?AUrandom_access_iterator_tag@0@ABQAD0@Z ; std::_Iter_random<char *,char *>
	add	esp, 12					; 0000000cH
	movzx	edx, BYTE PTR [eax]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@PAD@std@@YAPADAAPAD@Z	; std::_Checked_base<char *>
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@PAD@std@@YAPADAAPAD@Z	; std::_Checked_base<char *>
	add	esp, 4
	push	eax
	call	??$_Copy_opt@PADPADUrandom_access_iterator_tag@std@@@std@@YAPADPAD00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<char *,char *,std::random_access_iterator_tag>
	add	esp, 24					; 00000018H

; 3607 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_copy@PADPAD@stdext@@YAPADPAD00@Z ENDP	; stdext::unchecked_copy<char *,char *>
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@PADPADV?$allocator@D@std@@@stdext@@YAPADPAD00AAV?$allocator@D@std@@@Z ; stdext::unchecked_uninitialized_copy<char *,char *,std::allocator<char> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??$_Ucopy@PAD@?$vector@DV?$allocator@D@std@@@std@@IAEPADPAD00@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Ucopy@PAD@?$vector@DV?$allocator@D@std@@@std@@IAEPADPAD00@Z PROC ; std::vector<char,std::allocator<char> >::_Ucopy<char *>, COMDAT
; _this$ = ecx

; 1138 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1139 : 		{	// copy initializing [_First, _Last), using allocator
; 1140 : 		return (_STDEXT unchecked_uninitialized_copy(_First, _Last,
; 1141 : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$unchecked_uninitialized_copy@PADPADV?$allocator@D@std@@@stdext@@YAPADPAD00AAV?$allocator@D@std@@@Z ; stdext::unchecked_uninitialized_copy<char *,char *,std::allocator<char> >
	add	esp, 16					; 00000010H

; 1142 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??$_Ucopy@PAD@?$vector@DV?$allocator@D@std@@@std@@IAEPADPAD00@Z ENDP ; std::vector<char,std::allocator<char> >::_Ucopy<char *>
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@PAPAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@2@@stdext@@YAPAPAVSurfaceData@Ogre@@V?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@0PAPAV12@AAV?$allocator@PAVSurfaceData@Ogre@@@4@@Z ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >,Ogre::SurfaceData * *,std::allocator<Ogre::SurfaceData *> >
; Function compile flags: /Odtp
;	COMDAT ??$_Ucopy@V?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAEPAPAVSurfaceData@Ogre@@V?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@1@0PAPAV23@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 8
__Last$ = 16						; size = 8
__Ptr$ = 24						; size = 4
??$_Ucopy@V?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAEPAPAVSurfaceData@Ogre@@V?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@1@0PAPAV23@@Z PROC ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::_Ucopy<std::_Vector_const_iterator<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> > >, COMDAT
; _this$ = ecx

; 1138 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1139 : 		{	// copy initializing [_First, _Last), using allocator
; 1140 : 		return (_STDEXT unchecked_uninitialized_copy(_First, _Last,
; 1141 : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp+4]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@PAPAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@2@@stdext@@YAPAPAVSurfaceData@Ogre@@V?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@0PAPAV12@AAV?$allocator@PAVSurfaceData@Ogre@@@4@@Z ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >,Ogre::SurfaceData * *,std::allocator<Ogre::SurfaceData *> >
	add	esp, 24					; 00000018H

; 1142 : 		}

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
??$_Ucopy@V?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAEPAPAVSurfaceData@Ogre@@V?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@1@0PAPAV23@@Z ENDP ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::_Ucopy<std::_Vector_const_iterator<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> > >
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAPAVSurfaceData@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@@std@@YAPAPAVSurfaceData@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<Ogre::SurfaceData * *,Ogre::SurfaceData * *,std::random_access_iterator_tag>
PUBLIC	??$_Checked_base@PAPAVSurfaceData@Ogre@@@std@@YAPAPAVSurfaceData@Ogre@@AAPAPAV12@@Z ; std::_Checked_base<Ogre::SurfaceData * *>
PUBLIC	??$_Iter_random@PAPAVSurfaceData@Ogre@@PAPAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVSurfaceData@Ogre@@0@Z ; std::_Iter_random<Ogre::SurfaceData * *,Ogre::SurfaceData * *>
PUBLIC	??$_Ptr_cat@PAPAVSurfaceData@Ogre@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVSurfaceData@Ogre@@0@Z ; std::_Ptr_cat<Ogre::SurfaceData * *,Ogre::SurfaceData * *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$unchecked_copy@PAPAVSurfaceData@Ogre@@PAPAV12@@stdext@@YAPAPAVSurfaceData@Ogre@@PAPAV12@00@Z
_TEXT	SEGMENT
$T97535 = -3						; size = 1
$T97534 = -2						; size = 1
$T97533 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAPAVSurfaceData@Ogre@@PAPAV12@@stdext@@YAPAPAVSurfaceData@Ogre@@PAPAV12@00@Z PROC ; stdext::unchecked_copy<Ogre::SurfaceData * *,Ogre::SurfaceData * *>, COMDAT

; 3604 : 	{	// copy [_First, _Last) to [_Dest, ...)

	push	ebp
	mov	ebp, esp
	push	ecx

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T97533[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAPAVSurfaceData@Ogre@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVSurfaceData@Ogre@@0@Z ; std::_Ptr_cat<Ogre::SurfaceData * *,Ogre::SurfaceData * *>
	add	esp, 8
	mov	BYTE PTR $T97534[ebp], al
	movzx	eax, BYTE PTR $T97533[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T97534[ebp]
	push	ecx
	lea	edx, DWORD PTR __Dest$[ebp]
	push	edx
	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T97535[ebp]
	push	ecx
	call	??$_Iter_random@PAPAVSurfaceData@Ogre@@PAPAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVSurfaceData@Ogre@@0@Z ; std::_Iter_random<Ogre::SurfaceData * *,Ogre::SurfaceData * *>
	add	esp, 12					; 0000000cH
	movzx	edx, BYTE PTR [eax]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@PAPAVSurfaceData@Ogre@@@std@@YAPAPAVSurfaceData@Ogre@@AAPAPAV12@@Z ; std::_Checked_base<Ogre::SurfaceData * *>
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@PAPAVSurfaceData@Ogre@@@std@@YAPAPAVSurfaceData@Ogre@@AAPAPAV12@@Z ; std::_Checked_base<Ogre::SurfaceData * *>
	add	esp, 4
	push	eax
	call	??$_Copy_opt@PAPAVSurfaceData@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@@std@@YAPAPAVSurfaceData@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<Ogre::SurfaceData * *,Ogre::SurfaceData * *,std::random_access_iterator_tag>
	add	esp, 24					; 00000018H

; 3607 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_copy@PAPAVSurfaceData@Ogre@@PAPAV12@@stdext@@YAPAPAVSurfaceData@Ogre@@PAPAV12@00@Z ENDP ; stdext::unchecked_copy<Ogre::SurfaceData * *,Ogre::SurfaceData * *>
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@PAPAVSurfaceData@Ogre@@PAPAV12@V?$allocator@PAVSurfaceData@Ogre@@@std@@@stdext@@YAPAPAVSurfaceData@Ogre@@PAPAV12@00AAV?$allocator@PAVSurfaceData@Ogre@@@std@@@Z ; stdext::unchecked_uninitialized_copy<Ogre::SurfaceData * *,Ogre::SurfaceData * *,std::allocator<Ogre::SurfaceData *> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??$_Ucopy@PAPAVSurfaceData@Ogre@@@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAEPAPAVSurfaceData@Ogre@@PAPAV23@00@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Ucopy@PAPAVSurfaceData@Ogre@@@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAEPAPAVSurfaceData@Ogre@@PAPAV23@00@Z PROC ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::_Ucopy<Ogre::SurfaceData * *>, COMDAT
; _this$ = ecx

; 1138 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1139 : 		{	// copy initializing [_First, _Last), using allocator
; 1140 : 		return (_STDEXT unchecked_uninitialized_copy(_First, _Last,
; 1141 : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$unchecked_uninitialized_copy@PAPAVSurfaceData@Ogre@@PAPAV12@V?$allocator@PAVSurfaceData@Ogre@@@std@@@stdext@@YAPAPAVSurfaceData@Ogre@@PAPAV12@00AAV?$allocator@PAVSurfaceData@Ogre@@@std@@@Z ; stdext::unchecked_uninitialized_copy<Ogre::SurfaceData * *,Ogre::SurfaceData * *,std::allocator<Ogre::SurfaceData *> >
	add	esp, 16					; 00000010H

; 1142 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??$_Ucopy@PAPAVSurfaceData@Ogre@@@?$vector@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@IAEPAPAVSurfaceData@Ogre@@PAPAV23@00@Z ENDP ; std::vector<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::_Ucopy<Ogre::SurfaceData * *>
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAGPAGUrandom_access_iterator_tag@std@@@std@@YAPAGPAG00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<unsigned short *,unsigned short *,std::random_access_iterator_tag>
PUBLIC	??$_Checked_base@PAG@std@@YAPAGAAPAG@Z		; std::_Checked_base<unsigned short *>
PUBLIC	??$_Iter_random@PAGPAG@std@@YA?AUrandom_access_iterator_tag@0@ABQAG0@Z ; std::_Iter_random<unsigned short *,unsigned short *>
PUBLIC	??$_Ptr_cat@PAGPAG@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAG0@Z ; std::_Ptr_cat<unsigned short *,unsigned short *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$unchecked_copy@PAGPAG@stdext@@YAPAGPAG00@Z
_TEXT	SEGMENT
$T97542 = -3						; size = 1
$T97541 = -2						; size = 1
$T97540 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAGPAG@stdext@@YAPAGPAG00@Z PROC	; stdext::unchecked_copy<unsigned short *,unsigned short *>, COMDAT

; 3604 : 	{	// copy [_First, _Last) to [_Dest, ...)

	push	ebp
	mov	ebp, esp
	push	ecx

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T97540[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAGPAG@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAG0@Z ; std::_Ptr_cat<unsigned short *,unsigned short *>
	add	esp, 8
	mov	BYTE PTR $T97541[ebp], al
	movzx	eax, BYTE PTR $T97540[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T97541[ebp]
	push	ecx
	lea	edx, DWORD PTR __Dest$[ebp]
	push	edx
	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T97542[ebp]
	push	ecx
	call	??$_Iter_random@PAGPAG@std@@YA?AUrandom_access_iterator_tag@0@ABQAG0@Z ; std::_Iter_random<unsigned short *,unsigned short *>
	add	esp, 12					; 0000000cH
	movzx	edx, BYTE PTR [eax]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@PAG@std@@YAPAGAAPAG@Z	; std::_Checked_base<unsigned short *>
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@PAG@std@@YAPAGAAPAG@Z	; std::_Checked_base<unsigned short *>
	add	esp, 4
	push	eax
	call	??$_Copy_opt@PAGPAGUrandom_access_iterator_tag@std@@@std@@YAPAGPAG00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<unsigned short *,unsigned short *,std::random_access_iterator_tag>
	add	esp, 24					; 00000018H

; 3607 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_copy@PAGPAG@stdext@@YAPAGPAG00@Z ENDP	; stdext::unchecked_copy<unsigned short *,unsigned short *>
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@PAGPAGV?$allocator@G@std@@@stdext@@YAPAGPAG00AAV?$allocator@G@std@@@Z ; stdext::unchecked_uninitialized_copy<unsigned short *,unsigned short *,std::allocator<unsigned short> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??$_Ucopy@PAG@?$vector@GV?$allocator@G@std@@@std@@IAEPAGPAG00@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Ucopy@PAG@?$vector@GV?$allocator@G@std@@@std@@IAEPAGPAG00@Z PROC ; std::vector<unsigned short,std::allocator<unsigned short> >::_Ucopy<unsigned short *>, COMDAT
; _this$ = ecx

; 1138 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1139 : 		{	// copy initializing [_First, _Last), using allocator
; 1140 : 		return (_STDEXT unchecked_uninitialized_copy(_First, _Last,
; 1141 : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$unchecked_uninitialized_copy@PAGPAGV?$allocator@G@std@@@stdext@@YAPAGPAG00AAV?$allocator@G@std@@@Z ; stdext::unchecked_uninitialized_copy<unsigned short *,unsigned short *,std::allocator<unsigned short> >
	add	esp, 16					; 00000010H

; 1142 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??$_Ucopy@PAG@?$vector@GV?$allocator@G@std@@@std@@IAEPAGPAG00@Z ENDP ; std::vector<unsigned short,std::allocator<unsigned short> >::_Ucopy<unsigned short *>
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@PAURecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@2@@stdext@@YAPAURecord@CullResult@Ogre@@V?$_Vector_const_iterator@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@0PAU123@AAV?$allocator@URecord@CullResult@Ogre@@@5@@Z ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<Ogre::CullResult::Record,std::allocator<Ogre::CullResult::Record> >,Ogre::CullResult::Record *,std::allocator<Ogre::CullResult::Record> >
; Function compile flags: /Odtp
;	COMDAT ??$_Ucopy@V?$_Vector_const_iterator@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@@?$vector@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@IAEPAURecord@CullResult@Ogre@@V?$_Vector_const_iterator@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@1@0PAU234@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 8
__Last$ = 16						; size = 8
__Ptr$ = 24						; size = 4
??$_Ucopy@V?$_Vector_const_iterator@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@@?$vector@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@IAEPAURecord@CullResult@Ogre@@V?$_Vector_const_iterator@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@1@0PAU234@@Z PROC ; std::vector<Ogre::CullResult::Record,std::allocator<Ogre::CullResult::Record> >::_Ucopy<std::_Vector_const_iterator<Ogre::CullResult::Record,std::allocator<Ogre::CullResult::Record> > >, COMDAT
; _this$ = ecx

; 1138 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1139 : 		{	// copy initializing [_First, _Last), using allocator
; 1140 : 		return (_STDEXT unchecked_uninitialized_copy(_First, _Last,
; 1141 : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp+4]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@PAURecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@2@@stdext@@YAPAURecord@CullResult@Ogre@@V?$_Vector_const_iterator@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@0PAU123@AAV?$allocator@URecord@CullResult@Ogre@@@5@@Z ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<Ogre::CullResult::Record,std::allocator<Ogre::CullResult::Record> >,Ogre::CullResult::Record *,std::allocator<Ogre::CullResult::Record> >
	add	esp, 24					; 00000018H

; 1142 : 		}

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
??$_Ucopy@V?$_Vector_const_iterator@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@@?$vector@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@IAEPAURecord@CullResult@Ogre@@V?$_Vector_const_iterator@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@1@0PAU234@@Z ENDP ; std::vector<Ogre::CullResult::Record,std::allocator<Ogre::CullResult::Record> >::_Ucopy<std::_Vector_const_iterator<Ogre::CullResult::Record,std::allocator<Ogre::CullResult::Record> > >
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAURecord@CullResult@Ogre@@PAU123@@std@@YAPAURecord@CullResult@Ogre@@PAU123@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<Ogre::CullResult::Record *,Ogre::CullResult::Record *>
PUBLIC	??$_Checked_base@PAURecord@CullResult@Ogre@@@std@@YAPAURecord@CullResult@Ogre@@AAPAU123@@Z ; std::_Checked_base<Ogre::CullResult::Record *>
PUBLIC	??$_Iter_random@PAURecord@CullResult@Ogre@@PAU123@@std@@YA?AUrandom_access_iterator_tag@0@ABQAURecord@CullResult@Ogre@@0@Z ; std::_Iter_random<Ogre::CullResult::Record *,Ogre::CullResult::Record *>
PUBLIC	??$_Ptr_cat@PAURecord@CullResult@Ogre@@PAU123@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAURecord@CullResult@Ogre@@0@Z ; std::_Ptr_cat<Ogre::CullResult::Record *,Ogre::CullResult::Record *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$unchecked_copy@PAURecord@CullResult@Ogre@@PAU123@@stdext@@YAPAURecord@CullResult@Ogre@@PAU123@00@Z
_TEXT	SEGMENT
$T97551 = -3						; size = 1
$T97550 = -2						; size = 1
$T97549 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAURecord@CullResult@Ogre@@PAU123@@stdext@@YAPAURecord@CullResult@Ogre@@PAU123@00@Z PROC ; stdext::unchecked_copy<Ogre::CullResult::Record *,Ogre::CullResult::Record *>, COMDAT

; 3604 : 	{	// copy [_First, _Last) to [_Dest, ...)

	push	ebp
	mov	ebp, esp
	push	ecx

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T97549[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAURecord@CullResult@Ogre@@PAU123@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAURecord@CullResult@Ogre@@0@Z ; std::_Ptr_cat<Ogre::CullResult::Record *,Ogre::CullResult::Record *>
	add	esp, 8
	mov	BYTE PTR $T97550[ebp], al
	movzx	eax, BYTE PTR $T97549[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T97550[ebp]
	push	ecx
	lea	edx, DWORD PTR __Dest$[ebp]
	push	edx
	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T97551[ebp]
	push	ecx
	call	??$_Iter_random@PAURecord@CullResult@Ogre@@PAU123@@std@@YA?AUrandom_access_iterator_tag@0@ABQAURecord@CullResult@Ogre@@0@Z ; std::_Iter_random<Ogre::CullResult::Record *,Ogre::CullResult::Record *>
	add	esp, 12					; 0000000cH
	movzx	edx, BYTE PTR [eax]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@PAURecord@CullResult@Ogre@@@std@@YAPAURecord@CullResult@Ogre@@AAPAU123@@Z ; std::_Checked_base<Ogre::CullResult::Record *>
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@PAURecord@CullResult@Ogre@@@std@@YAPAURecord@CullResult@Ogre@@AAPAU123@@Z ; std::_Checked_base<Ogre::CullResult::Record *>
	add	esp, 4
	push	eax
	call	??$_Copy_opt@PAURecord@CullResult@Ogre@@PAU123@@std@@YAPAURecord@CullResult@Ogre@@PAU123@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<Ogre::CullResult::Record *,Ogre::CullResult::Record *>
	add	esp, 24					; 00000018H

; 3607 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_copy@PAURecord@CullResult@Ogre@@PAU123@@stdext@@YAPAURecord@CullResult@Ogre@@PAU123@00@Z ENDP ; stdext::unchecked_copy<Ogre::CullResult::Record *,Ogre::CullResult::Record *>
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@PAURecord@CullResult@Ogre@@PAU123@V?$allocator@URecord@CullResult@Ogre@@@std@@@stdext@@YAPAURecord@CullResult@Ogre@@PAU123@00AAV?$allocator@URecord@CullResult@Ogre@@@std@@@Z ; stdext::unchecked_uninitialized_copy<Ogre::CullResult::Record *,Ogre::CullResult::Record *,std::allocator<Ogre::CullResult::Record> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??$_Ucopy@PAURecord@CullResult@Ogre@@@?$vector@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@IAEPAURecord@CullResult@Ogre@@PAU234@00@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Ucopy@PAURecord@CullResult@Ogre@@@?$vector@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@IAEPAURecord@CullResult@Ogre@@PAU234@00@Z PROC ; std::vector<Ogre::CullResult::Record,std::allocator<Ogre::CullResult::Record> >::_Ucopy<Ogre::CullResult::Record *>, COMDAT
; _this$ = ecx

; 1138 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1139 : 		{	// copy initializing [_First, _Last), using allocator
; 1140 : 		return (_STDEXT unchecked_uninitialized_copy(_First, _Last,
; 1141 : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$unchecked_uninitialized_copy@PAURecord@CullResult@Ogre@@PAU123@V?$allocator@URecord@CullResult@Ogre@@@std@@@stdext@@YAPAURecord@CullResult@Ogre@@PAU123@00AAV?$allocator@URecord@CullResult@Ogre@@@std@@@Z ; stdext::unchecked_uninitialized_copy<Ogre::CullResult::Record *,Ogre::CullResult::Record *,std::allocator<Ogre::CullResult::Record> >
	add	esp, 16					; 00000010H

; 1142 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??$_Ucopy@PAURecord@CullResult@Ogre@@@?$vector@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@IAEPAURecord@CullResult@Ogre@@PAU234@00@Z ENDP ; std::vector<Ogre::CullResult::Record,std::allocator<Ogre::CullResult::Record> >::_Ucopy<Ogre::CullResult::Record *>
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@PAPAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@2@@stdext@@YAPAPAVEffectObject@Ogre@@V?$_Vector_const_iterator@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@0PAPAV12@AAV?$allocator@PAVEffectObject@Ogre@@@4@@Z ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<Ogre::EffectObject *,std::allocator<Ogre::EffectObject *> >,Ogre::EffectObject * *,std::allocator<Ogre::EffectObject *> >
; Function compile flags: /Odtp
;	COMDAT ??$_Ucopy@V?$_Vector_const_iterator@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@@?$vector@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@IAEPAPAVEffectObject@Ogre@@V?$_Vector_const_iterator@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@1@0PAPAV23@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 8
__Last$ = 16						; size = 8
__Ptr$ = 24						; size = 4
??$_Ucopy@V?$_Vector_const_iterator@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@@?$vector@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@IAEPAPAVEffectObject@Ogre@@V?$_Vector_const_iterator@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@1@0PAPAV23@@Z PROC ; std::vector<Ogre::EffectObject *,std::allocator<Ogre::EffectObject *> >::_Ucopy<std::_Vector_const_iterator<Ogre::EffectObject *,std::allocator<Ogre::EffectObject *> > >, COMDAT
; _this$ = ecx

; 1138 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1139 : 		{	// copy initializing [_First, _Last), using allocator
; 1140 : 		return (_STDEXT unchecked_uninitialized_copy(_First, _Last,
; 1141 : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp+4]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@PAPAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@2@@stdext@@YAPAPAVEffectObject@Ogre@@V?$_Vector_const_iterator@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@0PAPAV12@AAV?$allocator@PAVEffectObject@Ogre@@@4@@Z ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<Ogre::EffectObject *,std::allocator<Ogre::EffectObject *> >,Ogre::EffectObject * *,std::allocator<Ogre::EffectObject *> >
	add	esp, 24					; 00000018H

; 1142 : 		}

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
??$_Ucopy@V?$_Vector_const_iterator@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@@?$vector@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@IAEPAPAVEffectObject@Ogre@@V?$_Vector_const_iterator@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@1@0PAPAV23@@Z ENDP ; std::vector<Ogre::EffectObject *,std::allocator<Ogre::EffectObject *> >::_Ucopy<std::_Vector_const_iterator<Ogre::EffectObject *,std::allocator<Ogre::EffectObject *> > >
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAPAVEffectObject@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@@std@@YAPAPAVEffectObject@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<Ogre::EffectObject * *,Ogre::EffectObject * *,std::random_access_iterator_tag>
PUBLIC	??$_Checked_base@PAPAVEffectObject@Ogre@@@std@@YAPAPAVEffectObject@Ogre@@AAPAPAV12@@Z ; std::_Checked_base<Ogre::EffectObject * *>
PUBLIC	??$_Iter_random@PAPAVEffectObject@Ogre@@PAPAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVEffectObject@Ogre@@0@Z ; std::_Iter_random<Ogre::EffectObject * *,Ogre::EffectObject * *>
PUBLIC	??$_Ptr_cat@PAPAVEffectObject@Ogre@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVEffectObject@Ogre@@0@Z ; std::_Ptr_cat<Ogre::EffectObject * *,Ogre::EffectObject * *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$unchecked_copy@PAPAVEffectObject@Ogre@@PAPAV12@@stdext@@YAPAPAVEffectObject@Ogre@@PAPAV12@00@Z
_TEXT	SEGMENT
$T97560 = -3						; size = 1
$T97559 = -2						; size = 1
$T97558 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAPAVEffectObject@Ogre@@PAPAV12@@stdext@@YAPAPAVEffectObject@Ogre@@PAPAV12@00@Z PROC ; stdext::unchecked_copy<Ogre::EffectObject * *,Ogre::EffectObject * *>, COMDAT

; 3604 : 	{	// copy [_First, _Last) to [_Dest, ...)

	push	ebp
	mov	ebp, esp
	push	ecx

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T97558[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAPAVEffectObject@Ogre@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVEffectObject@Ogre@@0@Z ; std::_Ptr_cat<Ogre::EffectObject * *,Ogre::EffectObject * *>
	add	esp, 8
	mov	BYTE PTR $T97559[ebp], al
	movzx	eax, BYTE PTR $T97558[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T97559[ebp]
	push	ecx
	lea	edx, DWORD PTR __Dest$[ebp]
	push	edx
	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T97560[ebp]
	push	ecx
	call	??$_Iter_random@PAPAVEffectObject@Ogre@@PAPAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVEffectObject@Ogre@@0@Z ; std::_Iter_random<Ogre::EffectObject * *,Ogre::EffectObject * *>
	add	esp, 12					; 0000000cH
	movzx	edx, BYTE PTR [eax]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@PAPAVEffectObject@Ogre@@@std@@YAPAPAVEffectObject@Ogre@@AAPAPAV12@@Z ; std::_Checked_base<Ogre::EffectObject * *>
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@PAPAVEffectObject@Ogre@@@std@@YAPAPAVEffectObject@Ogre@@AAPAPAV12@@Z ; std::_Checked_base<Ogre::EffectObject * *>
	add	esp, 4
	push	eax
	call	??$_Copy_opt@PAPAVEffectObject@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@@std@@YAPAPAVEffectObject@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<Ogre::EffectObject * *,Ogre::EffectObject * *,std::random_access_iterator_tag>
	add	esp, 24					; 00000018H

; 3607 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_copy@PAPAVEffectObject@Ogre@@PAPAV12@@stdext@@YAPAPAVEffectObject@Ogre@@PAPAV12@00@Z ENDP ; stdext::unchecked_copy<Ogre::EffectObject * *,Ogre::EffectObject * *>
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@PAPAVEffectObject@Ogre@@PAPAV12@V?$allocator@PAVEffectObject@Ogre@@@std@@@stdext@@YAPAPAVEffectObject@Ogre@@PAPAV12@00AAV?$allocator@PAVEffectObject@Ogre@@@std@@@Z ; stdext::unchecked_uninitialized_copy<Ogre::EffectObject * *,Ogre::EffectObject * *,std::allocator<Ogre::EffectObject *> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??$_Ucopy@PAPAVEffectObject@Ogre@@@?$vector@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@IAEPAPAVEffectObject@Ogre@@PAPAV23@00@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Ucopy@PAPAVEffectObject@Ogre@@@?$vector@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@IAEPAPAVEffectObject@Ogre@@PAPAV23@00@Z PROC ; std::vector<Ogre::EffectObject *,std::allocator<Ogre::EffectObject *> >::_Ucopy<Ogre::EffectObject * *>, COMDAT
; _this$ = ecx

; 1138 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1139 : 		{	// copy initializing [_First, _Last), using allocator
; 1140 : 		return (_STDEXT unchecked_uninitialized_copy(_First, _Last,
; 1141 : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$unchecked_uninitialized_copy@PAPAVEffectObject@Ogre@@PAPAV12@V?$allocator@PAVEffectObject@Ogre@@@std@@@stdext@@YAPAPAVEffectObject@Ogre@@PAPAV12@00AAV?$allocator@PAVEffectObject@Ogre@@@std@@@Z ; stdext::unchecked_uninitialized_copy<Ogre::EffectObject * *,Ogre::EffectObject * *,std::allocator<Ogre::EffectObject *> >
	add	esp, 16					; 00000010H

; 1142 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??$_Ucopy@PAPAVEffectObject@Ogre@@@?$vector@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@IAEPAPAVEffectObject@Ogre@@PAPAV23@00@Z ENDP ; std::vector<Ogre::EffectObject *,std::allocator<Ogre::EffectObject *> >::_Ucopy<Ogre::EffectObject * *>
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@PAPAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@2@@stdext@@YAPAPAVSoundNode@Ogre@@V?$_Vector_const_iterator@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@0PAPAV12@AAV?$allocator@PAVSoundNode@Ogre@@@4@@Z ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<Ogre::SoundNode *,std::allocator<Ogre::SoundNode *> >,Ogre::SoundNode * *,std::allocator<Ogre::SoundNode *> >
; Function compile flags: /Odtp
;	COMDAT ??$_Ucopy@V?$_Vector_const_iterator@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@@?$vector@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@IAEPAPAVSoundNode@Ogre@@V?$_Vector_const_iterator@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@1@0PAPAV23@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 8
__Last$ = 16						; size = 8
__Ptr$ = 24						; size = 4
??$_Ucopy@V?$_Vector_const_iterator@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@@?$vector@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@IAEPAPAVSoundNode@Ogre@@V?$_Vector_const_iterator@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@1@0PAPAV23@@Z PROC ; std::vector<Ogre::SoundNode *,std::allocator<Ogre::SoundNode *> >::_Ucopy<std::_Vector_const_iterator<Ogre::SoundNode *,std::allocator<Ogre::SoundNode *> > >, COMDAT
; _this$ = ecx

; 1138 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1139 : 		{	// copy initializing [_First, _Last), using allocator
; 1140 : 		return (_STDEXT unchecked_uninitialized_copy(_First, _Last,
; 1141 : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp+4]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@PAPAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@2@@stdext@@YAPAPAVSoundNode@Ogre@@V?$_Vector_const_iterator@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@0PAPAV12@AAV?$allocator@PAVSoundNode@Ogre@@@4@@Z ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<Ogre::SoundNode *,std::allocator<Ogre::SoundNode *> >,Ogre::SoundNode * *,std::allocator<Ogre::SoundNode *> >
	add	esp, 24					; 00000018H

; 1142 : 		}

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
??$_Ucopy@V?$_Vector_const_iterator@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@@?$vector@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@IAEPAPAVSoundNode@Ogre@@V?$_Vector_const_iterator@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@1@0PAPAV23@@Z ENDP ; std::vector<Ogre::SoundNode *,std::allocator<Ogre::SoundNode *> >::_Ucopy<std::_Vector_const_iterator<Ogre::SoundNode *,std::allocator<Ogre::SoundNode *> > >
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAPAVSoundNode@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@@std@@YAPAPAVSoundNode@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<Ogre::SoundNode * *,Ogre::SoundNode * *,std::random_access_iterator_tag>
PUBLIC	??$_Checked_base@PAPAVSoundNode@Ogre@@@std@@YAPAPAVSoundNode@Ogre@@AAPAPAV12@@Z ; std::_Checked_base<Ogre::SoundNode * *>
PUBLIC	??$_Iter_random@PAPAVSoundNode@Ogre@@PAPAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVSoundNode@Ogre@@0@Z ; std::_Iter_random<Ogre::SoundNode * *,Ogre::SoundNode * *>
PUBLIC	??$_Ptr_cat@PAPAVSoundNode@Ogre@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVSoundNode@Ogre@@0@Z ; std::_Ptr_cat<Ogre::SoundNode * *,Ogre::SoundNode * *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$unchecked_copy@PAPAVSoundNode@Ogre@@PAPAV12@@stdext@@YAPAPAVSoundNode@Ogre@@PAPAV12@00@Z
_TEXT	SEGMENT
$T97569 = -3						; size = 1
$T97568 = -2						; size = 1
$T97567 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAPAVSoundNode@Ogre@@PAPAV12@@stdext@@YAPAPAVSoundNode@Ogre@@PAPAV12@00@Z PROC ; stdext::unchecked_copy<Ogre::SoundNode * *,Ogre::SoundNode * *>, COMDAT

; 3604 : 	{	// copy [_First, _Last) to [_Dest, ...)

	push	ebp
	mov	ebp, esp
	push	ecx

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T97567[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAPAVSoundNode@Ogre@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVSoundNode@Ogre@@0@Z ; std::_Ptr_cat<Ogre::SoundNode * *,Ogre::SoundNode * *>
	add	esp, 8
	mov	BYTE PTR $T97568[ebp], al
	movzx	eax, BYTE PTR $T97567[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T97568[ebp]
	push	ecx
	lea	edx, DWORD PTR __Dest$[ebp]
	push	edx
	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T97569[ebp]
	push	ecx
	call	??$_Iter_random@PAPAVSoundNode@Ogre@@PAPAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVSoundNode@Ogre@@0@Z ; std::_Iter_random<Ogre::SoundNode * *,Ogre::SoundNode * *>
	add	esp, 12					; 0000000cH
	movzx	edx, BYTE PTR [eax]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@PAPAVSoundNode@Ogre@@@std@@YAPAPAVSoundNode@Ogre@@AAPAPAV12@@Z ; std::_Checked_base<Ogre::SoundNode * *>
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@PAPAVSoundNode@Ogre@@@std@@YAPAPAVSoundNode@Ogre@@AAPAPAV12@@Z ; std::_Checked_base<Ogre::SoundNode * *>
	add	esp, 4
	push	eax
	call	??$_Copy_opt@PAPAVSoundNode@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@@std@@YAPAPAVSoundNode@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<Ogre::SoundNode * *,Ogre::SoundNode * *,std::random_access_iterator_tag>
	add	esp, 24					; 00000018H

; 3607 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_copy@PAPAVSoundNode@Ogre@@PAPAV12@@stdext@@YAPAPAVSoundNode@Ogre@@PAPAV12@00@Z ENDP ; stdext::unchecked_copy<Ogre::SoundNode * *,Ogre::SoundNode * *>
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@PAPAVSoundNode@Ogre@@PAPAV12@V?$allocator@PAVSoundNode@Ogre@@@std@@@stdext@@YAPAPAVSoundNode@Ogre@@PAPAV12@00AAV?$allocator@PAVSoundNode@Ogre@@@std@@@Z ; stdext::unchecked_uninitialized_copy<Ogre::SoundNode * *,Ogre::SoundNode * *,std::allocator<Ogre::SoundNode *> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??$_Ucopy@PAPAVSoundNode@Ogre@@@?$vector@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@IAEPAPAVSoundNode@Ogre@@PAPAV23@00@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Ucopy@PAPAVSoundNode@Ogre@@@?$vector@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@IAEPAPAVSoundNode@Ogre@@PAPAV23@00@Z PROC ; std::vector<Ogre::SoundNode *,std::allocator<Ogre::SoundNode *> >::_Ucopy<Ogre::SoundNode * *>, COMDAT
; _this$ = ecx

; 1138 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1139 : 		{	// copy initializing [_First, _Last), using allocator
; 1140 : 		return (_STDEXT unchecked_uninitialized_copy(_First, _Last,
; 1141 : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$unchecked_uninitialized_copy@PAPAVSoundNode@Ogre@@PAPAV12@V?$allocator@PAVSoundNode@Ogre@@@std@@@stdext@@YAPAPAVSoundNode@Ogre@@PAPAV12@00AAV?$allocator@PAVSoundNode@Ogre@@@std@@@Z ; stdext::unchecked_uninitialized_copy<Ogre::SoundNode * *,Ogre::SoundNode * *,std::allocator<Ogre::SoundNode *> >
	add	esp, 16					; 00000010H

; 1142 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??$_Ucopy@PAPAVSoundNode@Ogre@@@?$vector@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@IAEPAPAVSoundNode@Ogre@@PAPAV23@00@Z ENDP ; std::vector<Ogre::SoundNode *,std::allocator<Ogre::SoundNode *> >::_Ucopy<Ogre::SoundNode * *>
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@PAPAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@2@@stdext@@YAPAPAVRenderableObject@Ogre@@V?$_Vector_const_iterator@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@0PAPAV12@AAV?$allocator@PAVRenderableObject@Ogre@@@4@@Z ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<Ogre::RenderableObject *,std::allocator<Ogre::RenderableObject *> >,Ogre::RenderableObject * *,std::allocator<Ogre::RenderableObject *> >
; Function compile flags: /Odtp
;	COMDAT ??$_Ucopy@V?$_Vector_const_iterator@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@@?$vector@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@IAEPAPAVRenderableObject@Ogre@@V?$_Vector_const_iterator@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@1@0PAPAV23@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 8
__Last$ = 16						; size = 8
__Ptr$ = 24						; size = 4
??$_Ucopy@V?$_Vector_const_iterator@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@@?$vector@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@IAEPAPAVRenderableObject@Ogre@@V?$_Vector_const_iterator@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@1@0PAPAV23@@Z PROC ; std::vector<Ogre::RenderableObject *,std::allocator<Ogre::RenderableObject *> >::_Ucopy<std::_Vector_const_iterator<Ogre::RenderableObject *,std::allocator<Ogre::RenderableObject *> > >, COMDAT
; _this$ = ecx

; 1138 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1139 : 		{	// copy initializing [_First, _Last), using allocator
; 1140 : 		return (_STDEXT unchecked_uninitialized_copy(_First, _Last,
; 1141 : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp+4]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@PAPAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@2@@stdext@@YAPAPAVRenderableObject@Ogre@@V?$_Vector_const_iterator@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@0PAPAV12@AAV?$allocator@PAVRenderableObject@Ogre@@@4@@Z ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<Ogre::RenderableObject *,std::allocator<Ogre::RenderableObject *> >,Ogre::RenderableObject * *,std::allocator<Ogre::RenderableObject *> >
	add	esp, 24					; 00000018H

; 1142 : 		}

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
??$_Ucopy@V?$_Vector_const_iterator@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@@?$vector@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@IAEPAPAVRenderableObject@Ogre@@V?$_Vector_const_iterator@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@1@0PAPAV23@@Z ENDP ; std::vector<Ogre::RenderableObject *,std::allocator<Ogre::RenderableObject *> >::_Ucopy<std::_Vector_const_iterator<Ogre::RenderableObject *,std::allocator<Ogre::RenderableObject *> > >
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAPAVRenderableObject@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@@std@@YAPAPAVRenderableObject@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<Ogre::RenderableObject * *,Ogre::RenderableObject * *,std::random_access_iterator_tag>
PUBLIC	??$_Checked_base@PAPAVRenderableObject@Ogre@@@std@@YAPAPAVRenderableObject@Ogre@@AAPAPAV12@@Z ; std::_Checked_base<Ogre::RenderableObject * *>
PUBLIC	??$_Iter_random@PAPAVRenderableObject@Ogre@@PAPAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVRenderableObject@Ogre@@0@Z ; std::_Iter_random<Ogre::RenderableObject * *,Ogre::RenderableObject * *>
PUBLIC	??$_Ptr_cat@PAPAVRenderableObject@Ogre@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVRenderableObject@Ogre@@0@Z ; std::_Ptr_cat<Ogre::RenderableObject * *,Ogre::RenderableObject * *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$unchecked_copy@PAPAVRenderableObject@Ogre@@PAPAV12@@stdext@@YAPAPAVRenderableObject@Ogre@@PAPAV12@00@Z
_TEXT	SEGMENT
$T97578 = -3						; size = 1
$T97577 = -2						; size = 1
$T97576 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAPAVRenderableObject@Ogre@@PAPAV12@@stdext@@YAPAPAVRenderableObject@Ogre@@PAPAV12@00@Z PROC ; stdext::unchecked_copy<Ogre::RenderableObject * *,Ogre::RenderableObject * *>, COMDAT

; 3604 : 	{	// copy [_First, _Last) to [_Dest, ...)

	push	ebp
	mov	ebp, esp
	push	ecx

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T97576[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAPAVRenderableObject@Ogre@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVRenderableObject@Ogre@@0@Z ; std::_Ptr_cat<Ogre::RenderableObject * *,Ogre::RenderableObject * *>
	add	esp, 8
	mov	BYTE PTR $T97577[ebp], al
	movzx	eax, BYTE PTR $T97576[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T97577[ebp]
	push	ecx
	lea	edx, DWORD PTR __Dest$[ebp]
	push	edx
	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T97578[ebp]
	push	ecx
	call	??$_Iter_random@PAPAVRenderableObject@Ogre@@PAPAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVRenderableObject@Ogre@@0@Z ; std::_Iter_random<Ogre::RenderableObject * *,Ogre::RenderableObject * *>
	add	esp, 12					; 0000000cH
	movzx	edx, BYTE PTR [eax]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@PAPAVRenderableObject@Ogre@@@std@@YAPAPAVRenderableObject@Ogre@@AAPAPAV12@@Z ; std::_Checked_base<Ogre::RenderableObject * *>
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@PAPAVRenderableObject@Ogre@@@std@@YAPAPAVRenderableObject@Ogre@@AAPAPAV12@@Z ; std::_Checked_base<Ogre::RenderableObject * *>
	add	esp, 4
	push	eax
	call	??$_Copy_opt@PAPAVRenderableObject@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@@std@@YAPAPAVRenderableObject@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<Ogre::RenderableObject * *,Ogre::RenderableObject * *,std::random_access_iterator_tag>
	add	esp, 24					; 00000018H

; 3607 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_copy@PAPAVRenderableObject@Ogre@@PAPAV12@@stdext@@YAPAPAVRenderableObject@Ogre@@PAPAV12@00@Z ENDP ; stdext::unchecked_copy<Ogre::RenderableObject * *,Ogre::RenderableObject * *>
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@PAPAVRenderableObject@Ogre@@PAPAV12@V?$allocator@PAVRenderableObject@Ogre@@@std@@@stdext@@YAPAPAVRenderableObject@Ogre@@PAPAV12@00AAV?$allocator@PAVRenderableObject@Ogre@@@std@@@Z ; stdext::unchecked_uninitialized_copy<Ogre::RenderableObject * *,Ogre::RenderableObject * *,std::allocator<Ogre::RenderableObject *> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??$_Ucopy@PAPAVRenderableObject@Ogre@@@?$vector@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@IAEPAPAVRenderableObject@Ogre@@PAPAV23@00@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Ucopy@PAPAVRenderableObject@Ogre@@@?$vector@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@IAEPAPAVRenderableObject@Ogre@@PAPAV23@00@Z PROC ; std::vector<Ogre::RenderableObject *,std::allocator<Ogre::RenderableObject *> >::_Ucopy<Ogre::RenderableObject * *>, COMDAT
; _this$ = ecx

; 1138 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1139 : 		{	// copy initializing [_First, _Last), using allocator
; 1140 : 		return (_STDEXT unchecked_uninitialized_copy(_First, _Last,
; 1141 : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$unchecked_uninitialized_copy@PAPAVRenderableObject@Ogre@@PAPAV12@V?$allocator@PAVRenderableObject@Ogre@@@std@@@stdext@@YAPAPAVRenderableObject@Ogre@@PAPAV12@00AAV?$allocator@PAVRenderableObject@Ogre@@@std@@@Z ; stdext::unchecked_uninitialized_copy<Ogre::RenderableObject * *,Ogre::RenderableObject * *,std::allocator<Ogre::RenderableObject *> >
	add	esp, 16					; 00000010H

; 1142 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??$_Ucopy@PAPAVRenderableObject@Ogre@@@?$vector@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@IAEPAPAVRenderableObject@Ogre@@PAPAV23@00@Z ENDP ; std::vector<Ogre::RenderableObject *,std::allocator<Ogre::RenderableObject *> >::_Ucopy<Ogre::RenderableObject * *>
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@PAPAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@2@@stdext@@YAPAPAVLight@Ogre@@V?$_Vector_const_iterator@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@0PAPAV12@AAV?$allocator@PAVLight@Ogre@@@4@@Z ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<Ogre::Light *,std::allocator<Ogre::Light *> >,Ogre::Light * *,std::allocator<Ogre::Light *> >
; Function compile flags: /Odtp
;	COMDAT ??$_Ucopy@V?$_Vector_const_iterator@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@@?$vector@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@IAEPAPAVLight@Ogre@@V?$_Vector_const_iterator@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@1@0PAPAV23@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 8
__Last$ = 16						; size = 8
__Ptr$ = 24						; size = 4
??$_Ucopy@V?$_Vector_const_iterator@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@@?$vector@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@IAEPAPAVLight@Ogre@@V?$_Vector_const_iterator@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@1@0PAPAV23@@Z PROC ; std::vector<Ogre::Light *,std::allocator<Ogre::Light *> >::_Ucopy<std::_Vector_const_iterator<Ogre::Light *,std::allocator<Ogre::Light *> > >, COMDAT
; _this$ = ecx

; 1138 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1139 : 		{	// copy initializing [_First, _Last), using allocator
; 1140 : 		return (_STDEXT unchecked_uninitialized_copy(_First, _Last,
; 1141 : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp+4]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@PAPAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@2@@stdext@@YAPAPAVLight@Ogre@@V?$_Vector_const_iterator@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@0PAPAV12@AAV?$allocator@PAVLight@Ogre@@@4@@Z ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<Ogre::Light *,std::allocator<Ogre::Light *> >,Ogre::Light * *,std::allocator<Ogre::Light *> >
	add	esp, 24					; 00000018H

; 1142 : 		}

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
??$_Ucopy@V?$_Vector_const_iterator@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@@?$vector@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@IAEPAPAVLight@Ogre@@V?$_Vector_const_iterator@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@1@0PAPAV23@@Z ENDP ; std::vector<Ogre::Light *,std::allocator<Ogre::Light *> >::_Ucopy<std::_Vector_const_iterator<Ogre::Light *,std::allocator<Ogre::Light *> > >
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAPAVLight@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@@std@@YAPAPAVLight@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<Ogre::Light * *,Ogre::Light * *,std::random_access_iterator_tag>
PUBLIC	??$_Checked_base@PAPAVLight@Ogre@@@std@@YAPAPAVLight@Ogre@@AAPAPAV12@@Z ; std::_Checked_base<Ogre::Light * *>
PUBLIC	??$_Iter_random@PAPAVLight@Ogre@@PAPAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVLight@Ogre@@0@Z ; std::_Iter_random<Ogre::Light * *,Ogre::Light * *>
PUBLIC	??$_Ptr_cat@PAPAVLight@Ogre@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVLight@Ogre@@0@Z ; std::_Ptr_cat<Ogre::Light * *,Ogre::Light * *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$unchecked_copy@PAPAVLight@Ogre@@PAPAV12@@stdext@@YAPAPAVLight@Ogre@@PAPAV12@00@Z
_TEXT	SEGMENT
$T97587 = -3						; size = 1
$T97586 = -2						; size = 1
$T97585 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAPAVLight@Ogre@@PAPAV12@@stdext@@YAPAPAVLight@Ogre@@PAPAV12@00@Z PROC ; stdext::unchecked_copy<Ogre::Light * *,Ogre::Light * *>, COMDAT

; 3604 : 	{	// copy [_First, _Last) to [_Dest, ...)

	push	ebp
	mov	ebp, esp
	push	ecx

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T97585[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAPAVLight@Ogre@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVLight@Ogre@@0@Z ; std::_Ptr_cat<Ogre::Light * *,Ogre::Light * *>
	add	esp, 8
	mov	BYTE PTR $T97586[ebp], al
	movzx	eax, BYTE PTR $T97585[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T97586[ebp]
	push	ecx
	lea	edx, DWORD PTR __Dest$[ebp]
	push	edx
	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T97587[ebp]
	push	ecx
	call	??$_Iter_random@PAPAVLight@Ogre@@PAPAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVLight@Ogre@@0@Z ; std::_Iter_random<Ogre::Light * *,Ogre::Light * *>
	add	esp, 12					; 0000000cH
	movzx	edx, BYTE PTR [eax]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@PAPAVLight@Ogre@@@std@@YAPAPAVLight@Ogre@@AAPAPAV12@@Z ; std::_Checked_base<Ogre::Light * *>
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@PAPAVLight@Ogre@@@std@@YAPAPAVLight@Ogre@@AAPAPAV12@@Z ; std::_Checked_base<Ogre::Light * *>
	add	esp, 4
	push	eax
	call	??$_Copy_opt@PAPAVLight@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@@std@@YAPAPAVLight@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<Ogre::Light * *,Ogre::Light * *,std::random_access_iterator_tag>
	add	esp, 24					; 00000018H

; 3607 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_copy@PAPAVLight@Ogre@@PAPAV12@@stdext@@YAPAPAVLight@Ogre@@PAPAV12@00@Z ENDP ; stdext::unchecked_copy<Ogre::Light * *,Ogre::Light * *>
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@PAPAVLight@Ogre@@PAPAV12@V?$allocator@PAVLight@Ogre@@@std@@@stdext@@YAPAPAVLight@Ogre@@PAPAV12@00AAV?$allocator@PAVLight@Ogre@@@std@@@Z ; stdext::unchecked_uninitialized_copy<Ogre::Light * *,Ogre::Light * *,std::allocator<Ogre::Light *> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??$_Ucopy@PAPAVLight@Ogre@@@?$vector@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@IAEPAPAVLight@Ogre@@PAPAV23@00@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Ucopy@PAPAVLight@Ogre@@@?$vector@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@IAEPAPAVLight@Ogre@@PAPAV23@00@Z PROC ; std::vector<Ogre::Light *,std::allocator<Ogre::Light *> >::_Ucopy<Ogre::Light * *>, COMDAT
; _this$ = ecx

; 1138 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1139 : 		{	// copy initializing [_First, _Last), using allocator
; 1140 : 		return (_STDEXT unchecked_uninitialized_copy(_First, _Last,
; 1141 : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$unchecked_uninitialized_copy@PAPAVLight@Ogre@@PAPAV12@V?$allocator@PAVLight@Ogre@@@std@@@stdext@@YAPAPAVLight@Ogre@@PAPAV12@00AAV?$allocator@PAVLight@Ogre@@@std@@@Z ; stdext::unchecked_uninitialized_copy<Ogre::Light * *,Ogre::Light * *,std::allocator<Ogre::Light *> >
	add	esp, 16					; 00000010H

; 1142 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??$_Ucopy@PAPAVLight@Ogre@@@?$vector@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@IAEPAPAVLight@Ogre@@PAPAV23@00@Z ENDP ; std::vector<Ogre::Light *,std::allocator<Ogre::Light *> >::_Ucopy<Ogre::Light * *>
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@@std@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<Ogre::BaseKeyFrameArray::AnimRange *,Ogre::BaseKeyFrameArray::AnimRange *>
PUBLIC	??$_Checked_base@PAUAnimRange@BaseKeyFrameArray@Ogre@@@std@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@AAPAU123@@Z ; std::_Checked_base<Ogre::BaseKeyFrameArray::AnimRange *>
PUBLIC	??$_Iter_random@PAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUAnimRange@BaseKeyFrameArray@Ogre@@0@Z ; std::_Iter_random<Ogre::BaseKeyFrameArray::AnimRange *,Ogre::BaseKeyFrameArray::AnimRange *>
PUBLIC	??$_Ptr_cat@PAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUAnimRange@BaseKeyFrameArray@Ogre@@0@Z ; std::_Ptr_cat<Ogre::BaseKeyFrameArray::AnimRange *,Ogre::BaseKeyFrameArray::AnimRange *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$unchecked_copy@PAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@@stdext@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@00@Z
_TEXT	SEGMENT
$T97594 = -3						; size = 1
$T97593 = -2						; size = 1
$T97592 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@@stdext@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@00@Z PROC ; stdext::unchecked_copy<Ogre::BaseKeyFrameArray::AnimRange *,Ogre::BaseKeyFrameArray::AnimRange *>, COMDAT

; 3604 : 	{	// copy [_First, _Last) to [_Dest, ...)

	push	ebp
	mov	ebp, esp
	push	ecx

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T97592[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUAnimRange@BaseKeyFrameArray@Ogre@@0@Z ; std::_Ptr_cat<Ogre::BaseKeyFrameArray::AnimRange *,Ogre::BaseKeyFrameArray::AnimRange *>
	add	esp, 8
	mov	BYTE PTR $T97593[ebp], al
	movzx	eax, BYTE PTR $T97592[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T97593[ebp]
	push	ecx
	lea	edx, DWORD PTR __Dest$[ebp]
	push	edx
	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T97594[ebp]
	push	ecx
	call	??$_Iter_random@PAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUAnimRange@BaseKeyFrameArray@Ogre@@0@Z ; std::_Iter_random<Ogre::BaseKeyFrameArray::AnimRange *,Ogre::BaseKeyFrameArray::AnimRange *>
	add	esp, 12					; 0000000cH
	movzx	edx, BYTE PTR [eax]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@PAUAnimRange@BaseKeyFrameArray@Ogre@@@std@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@AAPAU123@@Z ; std::_Checked_base<Ogre::BaseKeyFrameArray::AnimRange *>
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@PAUAnimRange@BaseKeyFrameArray@Ogre@@@std@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@AAPAU123@@Z ; std::_Checked_base<Ogre::BaseKeyFrameArray::AnimRange *>
	add	esp, 4
	push	eax
	call	??$_Copy_opt@PAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@@std@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<Ogre::BaseKeyFrameArray::AnimRange *,Ogre::BaseKeyFrameArray::AnimRange *>
	add	esp, 24					; 00000018H

; 3607 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_copy@PAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@@stdext@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@00@Z ENDP ; stdext::unchecked_copy<Ogre::BaseKeyFrameArray::AnimRange *,Ogre::BaseKeyFrameArray::AnimRange *>
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@PAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@stdext@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@00AAV?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@Z ; stdext::unchecked_uninitialized_copy<Ogre::BaseKeyFrameArray::AnimRange *,Ogre::BaseKeyFrameArray::AnimRange *,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??$_Ucopy@PAUAnimRange@BaseKeyFrameArray@Ogre@@@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAEPAUAnimRange@BaseKeyFrameArray@Ogre@@PAU234@00@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Ucopy@PAUAnimRange@BaseKeyFrameArray@Ogre@@@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAEPAUAnimRange@BaseKeyFrameArray@Ogre@@PAU234@00@Z PROC ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::_Ucopy<Ogre::BaseKeyFrameArray::AnimRange *>, COMDAT
; _this$ = ecx

; 1138 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1139 : 		{	// copy initializing [_First, _Last), using allocator
; 1140 : 		return (_STDEXT unchecked_uninitialized_copy(_First, _Last,
; 1141 : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$unchecked_uninitialized_copy@PAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@stdext@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@00AAV?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@Z ; stdext::unchecked_uninitialized_copy<Ogre::BaseKeyFrameArray::AnimRange *,Ogre::BaseKeyFrameArray::AnimRange *,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >
	add	esp, 16					; 00000010H

; 1142 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??$_Ucopy@PAUAnimRange@BaseKeyFrameArray@Ogre@@@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAEPAUAnimRange@BaseKeyFrameArray@Ogre@@PAU234@00@Z ENDP ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::_Ucopy<Ogre::BaseKeyFrameArray::AnimRange *>
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogrekeyframearray.h
_TEXT	ENDS
;	COMDAT ??$KEYFRAME_LERP@M@Ogre@@YAXAAMMABM1@Z
_TEXT	SEGMENT
_dest$ = 8						; size = 4
_t$ = 12						; size = 4
_src1$ = 16						; size = 4
_src2$ = 20						; size = 4
??$KEYFRAME_LERP@M@Ogre@@YAXAAMMABM1@Z PROC		; Ogre::KEYFRAME_LERP<float>, COMDAT

; 24   : 	{

	push	ebp
	mov	ebp, esp

; 25   : 		dest = Lerp(src1, src2, t);

	push	ecx
	fld	DWORD PTR _t$[ebp]
	fstp	DWORD PTR [esp]
	mov	eax, DWORD PTR _src2$[ebp]
	push	ecx
	fld	DWORD PTR [eax]
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _src1$[ebp]
	push	ecx
	fld	DWORD PTR [ecx]
	fstp	DWORD PTR [esp]
	call	?Lerp@Ogre@@YAMMMM@Z			; Ogre::Lerp
	add	esp, 12					; 0000000cH
	mov	edx, DWORD PTR _dest$[ebp]
	fstp	DWORD PTR [edx]

; 26   : 	}

	pop	ebp
	ret	0
??$KEYFRAME_LERP@M@Ogre@@YAXAAMMABM1@Z ENDP		; Ogre::KEYFRAME_LERP<float>
_TEXT	ENDS
PUBLIC	__real@c000000000000000
PUBLIC	__real@4008000000000000
;	COMDAT __real@c000000000000000
CONST	SEGMENT
__real@c000000000000000 DQ 0c000000000000000r	; -2
CONST	ENDS
;	COMDAT __real@4008000000000000
CONST	SEGMENT
__real@4008000000000000 DQ 04008000000000000r	; 3
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ??$KEYFRAME_HERMITE@M@Ogre@@YAXAAMMABM111@Z
_TEXT	SEGMENT
_h3$ = -16						; size = 4
_h4$ = -12						; size = 4
_h1$ = -8						; size = 4
_h2$ = -4						; size = 4
_dest$ = 8						; size = 4
_r$ = 12						; size = 4
_v1$ = 16						; size = 4
_v2$ = 20						; size = 4
_in$ = 24						; size = 4
_out$ = 28						; size = 4
??$KEYFRAME_HERMITE@M@Ogre@@YAXAAMMABM111@Z PROC	; Ogre::KEYFRAME_HERMITE<float>, COMDAT

; 35   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 36   : 		// basis functions
; 37   : 		float h1 = 2.0f*r*r*r - 3.0f*r*r + 1.0f;

	fld	DWORD PTR _r$[ebp]
	fmul	QWORD PTR __real@4000000000000000
	fmul	DWORD PTR _r$[ebp]
	fmul	DWORD PTR _r$[ebp]
	fld	DWORD PTR _r$[ebp]
	fmul	QWORD PTR __real@4008000000000000
	fmul	DWORD PTR _r$[ebp]
	fsubp	ST(1), ST(0)
	fadd	QWORD PTR __real@3ff0000000000000
	fstp	DWORD PTR _h1$[ebp]

; 38   : 		float h2 = -2.0f*r*r*r + 3.0f*r*r;

	fld	DWORD PTR _r$[ebp]
	fmul	QWORD PTR __real@c000000000000000
	fmul	DWORD PTR _r$[ebp]
	fmul	DWORD PTR _r$[ebp]
	fld	DWORD PTR _r$[ebp]
	fmul	QWORD PTR __real@4008000000000000
	fmul	DWORD PTR _r$[ebp]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR _h2$[ebp]

; 39   : 		float h3 = r*r*r - 2.0f*r*r + r;

	fld	DWORD PTR _r$[ebp]
	fmul	DWORD PTR _r$[ebp]
	fmul	DWORD PTR _r$[ebp]
	fld	DWORD PTR _r$[ebp]
	fmul	QWORD PTR __real@4000000000000000
	fmul	DWORD PTR _r$[ebp]
	fsubp	ST(1), ST(0)
	fadd	DWORD PTR _r$[ebp]
	fstp	DWORD PTR _h3$[ebp]

; 40   : 		float h4 = r*r*r - r*r;

	fld	DWORD PTR _r$[ebp]
	fmul	DWORD PTR _r$[ebp]
	fmul	DWORD PTR _r$[ebp]
	fld	DWORD PTR _r$[ebp]
	fmul	DWORD PTR _r$[ebp]
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR _h4$[ebp]

; 41   : 
; 42   : 		// interpolation
; 43   : 		dest = v1*h1 + v2*h2 + in*h3 + out*h4;

	mov	eax, DWORD PTR _v1$[ebp]
	fld	DWORD PTR [eax]
	fmul	DWORD PTR _h1$[ebp]
	mov	ecx, DWORD PTR _v2$[ebp]
	fld	DWORD PTR [ecx]
	fmul	DWORD PTR _h2$[ebp]
	faddp	ST(1), ST(0)
	mov	edx, DWORD PTR _in$[ebp]
	fld	DWORD PTR [edx]
	fmul	DWORD PTR _h3$[ebp]
	faddp	ST(1), ST(0)
	mov	eax, DWORD PTR _out$[ebp]
	fld	DWORD PTR [eax]
	fmul	DWORD PTR _h4$[ebp]
	faddp	ST(1), ST(0)
	mov	ecx, DWORD PTR _dest$[ebp]
	fstp	DWORD PTR [ecx]

; 44   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$KEYFRAME_HERMITE@M@Ogre@@YAXAAMMABM111@Z ENDP	; Ogre::KEYFRAME_HERMITE<float>
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU123@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU123@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<Ogre::KeyFrameArray<float>::KEYFRAME_T *,Ogre::KeyFrameArray<float>::KEYFRAME_T *>
PUBLIC	??$_Checked_base@PAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@AAPAU123@@Z ; std::_Checked_base<Ogre::KeyFrameArray<float>::KEYFRAME_T *>
PUBLIC	??$_Iter_random@PAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU123@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@0@Z ; std::_Iter_random<Ogre::KeyFrameArray<float>::KEYFRAME_T *,Ogre::KeyFrameArray<float>::KEYFRAME_T *>
PUBLIC	??$_Ptr_cat@PAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU123@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@0@Z ; std::_Ptr_cat<Ogre::KeyFrameArray<float>::KEYFRAME_T *,Ogre::KeyFrameArray<float>::KEYFRAME_T *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$unchecked_copy@PAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU123@@stdext@@YAPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU123@00@Z
_TEXT	SEGMENT
$T97609 = -3						; size = 1
$T97608 = -2						; size = 1
$T97607 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU123@@stdext@@YAPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU123@00@Z PROC ; stdext::unchecked_copy<Ogre::KeyFrameArray<float>::KEYFRAME_T *,Ogre::KeyFrameArray<float>::KEYFRAME_T *>, COMDAT

; 3604 : 	{	// copy [_First, _Last) to [_Dest, ...)

	push	ebp
	mov	ebp, esp
	push	ecx

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T97607[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU123@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@0@Z ; std::_Ptr_cat<Ogre::KeyFrameArray<float>::KEYFRAME_T *,Ogre::KeyFrameArray<float>::KEYFRAME_T *>
	add	esp, 8
	mov	BYTE PTR $T97608[ebp], al
	movzx	eax, BYTE PTR $T97607[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T97608[ebp]
	push	ecx
	lea	edx, DWORD PTR __Dest$[ebp]
	push	edx
	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T97609[ebp]
	push	ecx
	call	??$_Iter_random@PAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU123@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@0@Z ; std::_Iter_random<Ogre::KeyFrameArray<float>::KEYFRAME_T *,Ogre::KeyFrameArray<float>::KEYFRAME_T *>
	add	esp, 12					; 0000000cH
	movzx	edx, BYTE PTR [eax]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@PAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@AAPAU123@@Z ; std::_Checked_base<Ogre::KeyFrameArray<float>::KEYFRAME_T *>
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@PAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@AAPAU123@@Z ; std::_Checked_base<Ogre::KeyFrameArray<float>::KEYFRAME_T *>
	add	esp, 4
	push	eax
	call	??$_Copy_opt@PAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU123@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU123@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<Ogre::KeyFrameArray<float>::KEYFRAME_T *,Ogre::KeyFrameArray<float>::KEYFRAME_T *>
	add	esp, 24					; 00000018H

; 3607 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_copy@PAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU123@@stdext@@YAPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU123@00@Z ENDP ; stdext::unchecked_copy<Ogre::KeyFrameArray<float>::KEYFRAME_T *,Ogre::KeyFrameArray<float>::KEYFRAME_T *>
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@PAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@stdext@@YAPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU123@00AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@Z ; stdext::unchecked_uninitialized_copy<Ogre::KeyFrameArray<float>::KEYFRAME_T *,Ogre::KeyFrameArray<float>::KEYFRAME_T *,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??$_Ucopy@PAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAEPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU234@00@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Ucopy@PAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAEPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU234@00@Z PROC ; std::vector<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::_Ucopy<Ogre::KeyFrameArray<float>::KEYFRAME_T *>, COMDAT
; _this$ = ecx

; 1138 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1139 : 		{	// copy initializing [_First, _Last), using allocator
; 1140 : 		return (_STDEXT unchecked_uninitialized_copy(_First, _Last,
; 1141 : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$unchecked_uninitialized_copy@PAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@stdext@@YAPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU123@00AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@Z ; stdext::unchecked_uninitialized_copy<Ogre::KeyFrameArray<float>::KEYFRAME_T *,Ogre::KeyFrameArray<float>::KEYFRAME_T *,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >
	add	esp, 16					; 00000010H

; 1142 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??$_Ucopy@PAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAEPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU234@00@Z ENDP ; std::vector<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::_Ucopy<Ogre::KeyFrameArray<float>::KEYFRAME_T *>
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU123@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU123@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<Ogre::KeyFrameArray<float>::CONTROL_POINT_T *,Ogre::KeyFrameArray<float>::CONTROL_POINT_T *>
PUBLIC	??$_Checked_base@PAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@AAPAU123@@Z ; std::_Checked_base<Ogre::KeyFrameArray<float>::CONTROL_POINT_T *>
PUBLIC	??$_Iter_random@PAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU123@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@0@Z ; std::_Iter_random<Ogre::KeyFrameArray<float>::CONTROL_POINT_T *,Ogre::KeyFrameArray<float>::CONTROL_POINT_T *>
PUBLIC	??$_Ptr_cat@PAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU123@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@0@Z ; std::_Ptr_cat<Ogre::KeyFrameArray<float>::CONTROL_POINT_T *,Ogre::KeyFrameArray<float>::CONTROL_POINT_T *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$unchecked_copy@PAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU123@@stdext@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU123@00@Z
_TEXT	SEGMENT
$T97616 = -3						; size = 1
$T97615 = -2						; size = 1
$T97614 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU123@@stdext@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU123@00@Z PROC ; stdext::unchecked_copy<Ogre::KeyFrameArray<float>::CONTROL_POINT_T *,Ogre::KeyFrameArray<float>::CONTROL_POINT_T *>, COMDAT

; 3604 : 	{	// copy [_First, _Last) to [_Dest, ...)

	push	ebp
	mov	ebp, esp
	push	ecx

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T97614[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU123@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@0@Z ; std::_Ptr_cat<Ogre::KeyFrameArray<float>::CONTROL_POINT_T *,Ogre::KeyFrameArray<float>::CONTROL_POINT_T *>
	add	esp, 8
	mov	BYTE PTR $T97615[ebp], al
	movzx	eax, BYTE PTR $T97614[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T97615[ebp]
	push	ecx
	lea	edx, DWORD PTR __Dest$[ebp]
	push	edx
	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T97616[ebp]
	push	ecx
	call	??$_Iter_random@PAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU123@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@0@Z ; std::_Iter_random<Ogre::KeyFrameArray<float>::CONTROL_POINT_T *,Ogre::KeyFrameArray<float>::CONTROL_POINT_T *>
	add	esp, 12					; 0000000cH
	movzx	edx, BYTE PTR [eax]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@PAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@AAPAU123@@Z ; std::_Checked_base<Ogre::KeyFrameArray<float>::CONTROL_POINT_T *>
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@PAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@AAPAU123@@Z ; std::_Checked_base<Ogre::KeyFrameArray<float>::CONTROL_POINT_T *>
	add	esp, 4
	push	eax
	call	??$_Copy_opt@PAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU123@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU123@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<Ogre::KeyFrameArray<float>::CONTROL_POINT_T *,Ogre::KeyFrameArray<float>::CONTROL_POINT_T *>
	add	esp, 24					; 00000018H

; 3607 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_copy@PAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU123@@stdext@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU123@00@Z ENDP ; stdext::unchecked_copy<Ogre::KeyFrameArray<float>::CONTROL_POINT_T *,Ogre::KeyFrameArray<float>::CONTROL_POINT_T *>
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@PAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@stdext@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU123@00AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@Z ; stdext::unchecked_uninitialized_copy<Ogre::KeyFrameArray<float>::CONTROL_POINT_T *,Ogre::KeyFrameArray<float>::CONTROL_POINT_T *,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??$_Ucopy@PAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAEPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU234@00@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Ucopy@PAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAEPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU234@00@Z PROC ; std::vector<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::_Ucopy<Ogre::KeyFrameArray<float>::CONTROL_POINT_T *>, COMDAT
; _this$ = ecx

; 1138 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1139 : 		{	// copy initializing [_First, _Last), using allocator
; 1140 : 		return (_STDEXT unchecked_uninitialized_copy(_First, _Last,
; 1141 : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$unchecked_uninitialized_copy@PAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@stdext@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU123@00AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@Z ; stdext::unchecked_uninitialized_copy<Ogre::KeyFrameArray<float>::CONTROL_POINT_T *,Ogre::KeyFrameArray<float>::CONTROL_POINT_T *,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >
	add	esp, 16					; 00000010H

; 1142 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??$_Ucopy@PAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAEPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU234@00@Z ENDP ; std::vector<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::_Ucopy<Ogre::KeyFrameArray<float>::CONTROL_POINT_T *>
_TEXT	ENDS
PUBLIC	?Lerp@Ogre@@YA?AVColourValue@1@ABV21@0M@Z	; Ogre::Lerp
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogrekeyframearray.h
;	COMDAT ??$KEYFRAME_LERP@VColourValue@Ogre@@@Ogre@@YAXAAVColourValue@0@MABV10@1@Z
_TEXT	SEGMENT
$T97621 = -16						; size = 16
_dest$ = 8						; size = 4
_t$ = 12						; size = 4
_src1$ = 16						; size = 4
_src2$ = 20						; size = 4
??$KEYFRAME_LERP@VColourValue@Ogre@@@Ogre@@YAXAAVColourValue@0@MABV10@1@Z PROC ; Ogre::KEYFRAME_LERP<Ogre::ColourValue>, COMDAT

; 24   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 25   : 		dest = Lerp(src1, src2, t);

	push	ecx
	fld	DWORD PTR _t$[ebp]
	fstp	DWORD PTR [esp]
	mov	eax, DWORD PTR _src2$[ebp]
	push	eax
	mov	ecx, DWORD PTR _src1$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T97621[ebp]
	push	edx
	call	?Lerp@Ogre@@YA?AVColourValue@1@ABV21@0M@Z ; Ogre::Lerp
	add	esp, 16					; 00000010H
	mov	ecx, DWORD PTR _dest$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], eax

; 26   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$KEYFRAME_LERP@VColourValue@Ogre@@@Ogre@@YAXAAVColourValue@0@MABV10@1@Z ENDP ; Ogre::KEYFRAME_LERP<Ogre::ColourValue>
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogrecolourvalue.h
_TEXT	ENDS
;	COMDAT ?Lerp@Ogre@@YA?AVColourValue@1@ABV21@0M@Z
_TEXT	SEGMENT
tv165 = -16						; size = 4
tv160 = -12						; size = 4
tv155 = -8						; size = 4
tv150 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_v1$ = 12						; size = 4
_v2$ = 16						; size = 4
_t$ = 20						; size = 4
?Lerp@Ogre@@YA?AVColourValue@1@ABV21@0M@Z PROC		; Ogre::Lerp, COMDAT

; 323  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 324  : 		return ColourValue(v1.r+(v2.r-v1.r)*t, v1.g+(v2.g-v1.g)*t,v1.b+(v2.b-v1.b)*t, v1.a+(v2.a-v1.a)*t);

	mov	eax, DWORD PTR _v2$[ebp]
	fld	DWORD PTR [eax+12]
	mov	ecx, DWORD PTR _v1$[ebp]
	fsub	DWORD PTR [ecx+12]
	fmul	DWORD PTR _t$[ebp]
	mov	edx, DWORD PTR _v1$[ebp]
	fadd	DWORD PTR [edx+12]
	fstp	DWORD PTR tv150[ebp]
	fld	DWORD PTR tv150[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	eax, DWORD PTR _v2$[ebp]
	fld	DWORD PTR [eax+8]
	mov	ecx, DWORD PTR _v1$[ebp]
	fsub	DWORD PTR [ecx+8]
	fmul	DWORD PTR _t$[ebp]
	mov	edx, DWORD PTR _v1$[ebp]
	fadd	DWORD PTR [edx+8]
	fstp	DWORD PTR tv155[ebp]
	fld	DWORD PTR tv155[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	eax, DWORD PTR _v2$[ebp]
	fld	DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _v1$[ebp]
	fsub	DWORD PTR [ecx+4]
	fmul	DWORD PTR _t$[ebp]
	mov	edx, DWORD PTR _v1$[ebp]
	fadd	DWORD PTR [edx+4]
	fstp	DWORD PTR tv160[ebp]
	fld	DWORD PTR tv160[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	eax, DWORD PTR _v2$[ebp]
	fld	DWORD PTR [eax]
	mov	ecx, DWORD PTR _v1$[ebp]
	fsub	DWORD PTR [ecx]
	fmul	DWORD PTR _t$[ebp]
	mov	edx, DWORD PTR _v1$[ebp]
	fadd	DWORD PTR [edx]
	fstp	DWORD PTR tv165[ebp]
	fld	DWORD PTR tv165[ebp]
	push	ecx
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0ColourValue@Ogre@@QAE@MMMM@Z		; Ogre::ColourValue::ColourValue
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 325  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?Lerp@Ogre@@YA?AVColourValue@1@ABV21@0M@Z ENDP		; Ogre::Lerp
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogrekeyframearray.h
_TEXT	ENDS
;	COMDAT ??$KEYFRAME_HERMITE@VColourValue@Ogre@@@Ogre@@YAXAAVColourValue@0@MABV10@111@Z
_TEXT	SEGMENT
$T97632 = -128						; size = 16
$T97631 = -112						; size = 16
$T97630 = -96						; size = 16
$T97629 = -80						; size = 16
$T97628 = -64						; size = 16
$T97627 = -48						; size = 16
$T97626 = -32						; size = 16
_h3$ = -16						; size = 4
_h4$ = -12						; size = 4
_h1$ = -8						; size = 4
_h2$ = -4						; size = 4
_dest$ = 8						; size = 4
_r$ = 12						; size = 4
_v1$ = 16						; size = 4
_v2$ = 20						; size = 4
_in$ = 24						; size = 4
_out$ = 28						; size = 4
??$KEYFRAME_HERMITE@VColourValue@Ogre@@@Ogre@@YAXAAVColourValue@0@MABV10@111@Z PROC ; Ogre::KEYFRAME_HERMITE<Ogre::ColourValue>, COMDAT

; 35   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 128				; 00000080H

; 36   : 		// basis functions
; 37   : 		float h1 = 2.0f*r*r*r - 3.0f*r*r + 1.0f;

	fld	DWORD PTR _r$[ebp]
	fmul	QWORD PTR __real@4000000000000000
	fmul	DWORD PTR _r$[ebp]
	fmul	DWORD PTR _r$[ebp]
	fld	DWORD PTR _r$[ebp]
	fmul	QWORD PTR __real@4008000000000000
	fmul	DWORD PTR _r$[ebp]
	fsubp	ST(1), ST(0)
	fadd	QWORD PTR __real@3ff0000000000000
	fstp	DWORD PTR _h1$[ebp]

; 38   : 		float h2 = -2.0f*r*r*r + 3.0f*r*r;

	fld	DWORD PTR _r$[ebp]
	fmul	QWORD PTR __real@c000000000000000
	fmul	DWORD PTR _r$[ebp]
	fmul	DWORD PTR _r$[ebp]
	fld	DWORD PTR _r$[ebp]
	fmul	QWORD PTR __real@4008000000000000
	fmul	DWORD PTR _r$[ebp]
	faddp	ST(1), ST(0)
	fstp	DWORD PTR _h2$[ebp]

; 39   : 		float h3 = r*r*r - 2.0f*r*r + r;

	fld	DWORD PTR _r$[ebp]
	fmul	DWORD PTR _r$[ebp]
	fmul	DWORD PTR _r$[ebp]
	fld	DWORD PTR _r$[ebp]
	fmul	QWORD PTR __real@4000000000000000
	fmul	DWORD PTR _r$[ebp]
	fsubp	ST(1), ST(0)
	fadd	DWORD PTR _r$[ebp]
	fstp	DWORD PTR _h3$[ebp]

; 40   : 		float h4 = r*r*r - r*r;

	fld	DWORD PTR _r$[ebp]
	fmul	DWORD PTR _r$[ebp]
	fmul	DWORD PTR _r$[ebp]
	fld	DWORD PTR _r$[ebp]
	fmul	DWORD PTR _r$[ebp]
	fsubp	ST(1), ST(0)
	fstp	DWORD PTR _h4$[ebp]

; 41   : 
; 42   : 		// interpolation
; 43   : 		dest = v1*h1 + v2*h2 + in*h3 + out*h4;

	push	ecx
	fld	DWORD PTR _h4$[ebp]
	fstp	DWORD PTR [esp]
	lea	eax, DWORD PTR $T97631[ebp]
	push	eax
	mov	ecx, DWORD PTR _out$[ebp]
	call	??DColourValue@Ogre@@QBE?AV01@M@Z	; Ogre::ColourValue::operator*
	push	eax
	lea	ecx, DWORD PTR $T97632[ebp]
	push	ecx
	push	ecx
	fld	DWORD PTR _h3$[ebp]
	fstp	DWORD PTR [esp]
	lea	edx, DWORD PTR $T97629[ebp]
	push	edx
	mov	ecx, DWORD PTR _in$[ebp]
	call	??DColourValue@Ogre@@QBE?AV01@M@Z	; Ogre::ColourValue::operator*
	push	eax
	lea	eax, DWORD PTR $T97630[ebp]
	push	eax
	push	ecx
	fld	DWORD PTR _h2$[ebp]
	fstp	DWORD PTR [esp]
	lea	ecx, DWORD PTR $T97627[ebp]
	push	ecx
	mov	ecx, DWORD PTR _v2$[ebp]
	call	??DColourValue@Ogre@@QBE?AV01@M@Z	; Ogre::ColourValue::operator*
	push	eax
	lea	edx, DWORD PTR $T97628[ebp]
	push	edx
	push	ecx
	fld	DWORD PTR _h1$[ebp]
	fstp	DWORD PTR [esp]
	lea	eax, DWORD PTR $T97626[ebp]
	push	eax
	mov	ecx, DWORD PTR _v1$[ebp]
	call	??DColourValue@Ogre@@QBE?AV01@M@Z	; Ogre::ColourValue::operator*
	mov	ecx, eax
	call	??HColourValue@Ogre@@QBE?AV01@ABV01@@Z	; Ogre::ColourValue::operator+
	mov	ecx, eax
	call	??HColourValue@Ogre@@QBE?AV01@ABV01@@Z	; Ogre::ColourValue::operator+
	mov	ecx, eax
	call	??HColourValue@Ogre@@QBE?AV01@ABV01@@Z	; Ogre::ColourValue::operator+
	mov	ecx, DWORD PTR _dest$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], eax

; 44   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$KEYFRAME_HERMITE@VColourValue@Ogre@@@Ogre@@YAXAAVColourValue@0@MABV10@111@Z ENDP ; Ogre::KEYFRAME_HERMITE<Ogre::ColourValue>
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T *>
PUBLIC	??$_Checked_base@PAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@AAPAU123@@Z ; std::_Checked_base<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T *>
PUBLIC	??$_Iter_random@PAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@0@Z ; std::_Iter_random<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T *>
PUBLIC	??$_Ptr_cat@PAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@0@Z ; std::_Ptr_cat<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$unchecked_copy@PAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@@stdext@@YAPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@00@Z
_TEXT	SEGMENT
$T97637 = -3						; size = 1
$T97636 = -2						; size = 1
$T97635 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@@stdext@@YAPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@00@Z PROC ; stdext::unchecked_copy<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T *>, COMDAT

; 3604 : 	{	// copy [_First, _Last) to [_Dest, ...)

	push	ebp
	mov	ebp, esp
	push	ecx

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T97635[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@0@Z ; std::_Ptr_cat<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T *>
	add	esp, 8
	mov	BYTE PTR $T97636[ebp], al
	movzx	eax, BYTE PTR $T97635[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T97636[ebp]
	push	ecx
	lea	edx, DWORD PTR __Dest$[ebp]
	push	edx
	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T97637[ebp]
	push	ecx
	call	??$_Iter_random@PAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@0@Z ; std::_Iter_random<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T *>
	add	esp, 12					; 0000000cH
	movzx	edx, BYTE PTR [eax]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@PAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@AAPAU123@@Z ; std::_Checked_base<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T *>
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@PAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@AAPAU123@@Z ; std::_Checked_base<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T *>
	add	esp, 4
	push	eax
	call	??$_Copy_opt@PAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T *>
	add	esp, 24					; 00000018H

; 3607 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_copy@PAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@@stdext@@YAPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@00@Z ENDP ; stdext::unchecked_copy<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T *>
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@PAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@stdext@@YAPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@Z ; stdext::unchecked_uninitialized_copy<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T *,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??$_Ucopy@PAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAEPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU234@00@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Ucopy@PAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAEPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU234@00@Z PROC ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::_Ucopy<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T *>, COMDAT
; _this$ = ecx

; 1138 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1139 : 		{	// copy initializing [_First, _Last), using allocator
; 1140 : 		return (_STDEXT unchecked_uninitialized_copy(_First, _Last,
; 1141 : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$unchecked_uninitialized_copy@PAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@stdext@@YAPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@Z ; stdext::unchecked_uninitialized_copy<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T *,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >
	add	esp, 16					; 00000010H

; 1142 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??$_Ucopy@PAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAEPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU234@00@Z ENDP ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::_Ucopy<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T *>
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T *>
PUBLIC	??$_Checked_base@PAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@AAPAU123@@Z ; std::_Checked_base<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T *>
PUBLIC	??$_Iter_random@PAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@0@Z ; std::_Iter_random<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T *>
PUBLIC	??$_Ptr_cat@PAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@0@Z ; std::_Ptr_cat<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$unchecked_copy@PAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@@stdext@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@00@Z
_TEXT	SEGMENT
$T97644 = -3						; size = 1
$T97643 = -2						; size = 1
$T97642 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@@stdext@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@00@Z PROC ; stdext::unchecked_copy<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T *>, COMDAT

; 3604 : 	{	// copy [_First, _Last) to [_Dest, ...)

	push	ebp
	mov	ebp, esp
	push	ecx

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T97642[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@0@Z ; std::_Ptr_cat<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T *>
	add	esp, 8
	mov	BYTE PTR $T97643[ebp], al
	movzx	eax, BYTE PTR $T97642[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T97643[ebp]
	push	ecx
	lea	edx, DWORD PTR __Dest$[ebp]
	push	edx
	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T97644[ebp]
	push	ecx
	call	??$_Iter_random@PAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@0@Z ; std::_Iter_random<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T *>
	add	esp, 12					; 0000000cH
	movzx	edx, BYTE PTR [eax]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@PAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@AAPAU123@@Z ; std::_Checked_base<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T *>
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@PAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@AAPAU123@@Z ; std::_Checked_base<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T *>
	add	esp, 4
	push	eax
	call	??$_Copy_opt@PAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T *>
	add	esp, 24					; 00000018H

; 3607 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_copy@PAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@@stdext@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@00@Z ENDP ; stdext::unchecked_copy<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T *>
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_copy@PAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@stdext@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@Z ; stdext::unchecked_uninitialized_copy<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T *,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??$_Ucopy@PAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAEPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU234@00@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Ucopy@PAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAEPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU234@00@Z PROC ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::_Ucopy<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T *>, COMDAT
; _this$ = ecx

; 1138 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1139 : 		{	// copy initializing [_First, _Last), using allocator
; 1140 : 		return (_STDEXT unchecked_uninitialized_copy(_First, _Last,
; 1141 : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$unchecked_uninitialized_copy@PAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@stdext@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@Z ; stdext::unchecked_uninitialized_copy<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T *,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >
	add	esp, 16					; 00000010H

; 1142 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??$_Ucopy@PAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAEPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU234@00@Z ENDP ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::_Ucopy<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T *>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@YAXPAPAVShaderContext@Ogre@@0AAV?$allocator@PAVShaderContext@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<Ogre::ShaderContext *> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@YAXPAPAVShaderContext@Ogre@@0AAV?$allocator@PAVShaderContext@Ogre@@@0@@Z
_TEXT	SEGMENT
$T97649 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@YAXPAPAVShaderContext@Ogre@@0AAV?$allocator@PAVShaderContext@Ogre@@@0@@Z PROC ; std::_Destroy_range<std::allocator<Ogre::ShaderContext *> >, COMDAT

; 224  : 	{	// destroy [_First, _Last)

	push	ebp
	mov	ebp, esp
	push	ecx

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Ptr_cat@PAPAVShaderContext@Ogre@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVShaderContext@Ogre@@0@Z ; std::_Ptr_cat<Ogre::ShaderContext * *,Ogre::ShaderContext * *>
	add	esp, 8
	mov	BYTE PTR $T97649[ebp], al
	movzx	edx, BYTE PTR $T97649[ebp]
	push	edx
	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Destroy_range@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@YAXPAPAVShaderContext@Ogre@@0AAV?$allocator@PAVShaderContext@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<Ogre::ShaderContext *> >
	add	esp, 16					; 00000010H

; 226  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Destroy_range@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@YAXPAPAVShaderContext@Ogre@@0AAV?$allocator@PAVShaderContext@Ogre@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<Ogre::ShaderContext *> >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@YAXPAUContextQueDesc@Ogre@@0AAV?$allocator@UContextQueDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<Ogre::ContextQueDesc> >
; Function compile flags: /Odtp
;	COMDAT ??$_Destroy_range@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@YAXPAUContextQueDesc@Ogre@@0AAV?$allocator@UContextQueDesc@Ogre@@@0@@Z
_TEXT	SEGMENT
$T97652 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@YAXPAUContextQueDesc@Ogre@@0AAV?$allocator@UContextQueDesc@Ogre@@@0@@Z PROC ; std::_Destroy_range<std::allocator<Ogre::ContextQueDesc> >, COMDAT

; 224  : 	{	// destroy [_First, _Last)

	push	ebp
	mov	ebp, esp
	push	ecx

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Ptr_cat@PAUContextQueDesc@Ogre@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUContextQueDesc@Ogre@@0@Z ; std::_Ptr_cat<Ogre::ContextQueDesc *,Ogre::ContextQueDesc *>
	add	esp, 8
	mov	BYTE PTR $T97652[ebp], al
	movzx	edx, BYTE PTR $T97652[ebp]
	push	edx
	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Destroy_range@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@YAXPAUContextQueDesc@Ogre@@0AAV?$allocator@UContextQueDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<Ogre::ContextQueDesc> >
	add	esp, 16					; 00000010H

; 226  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Destroy_range@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@YAXPAUContextQueDesc@Ogre@@0AAV?$allocator@UContextQueDesc@Ogre@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<Ogre::ContextQueDesc> >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@E@std@@@std@@YAXPAE0AAV?$allocator@E@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<unsigned char> >
; Function compile flags: /Odtp
;	COMDAT ??$_Destroy_range@V?$allocator@E@std@@@std@@YAXPAE0AAV?$allocator@E@0@@Z
_TEXT	SEGMENT
$T97655 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@E@std@@@std@@YAXPAE0AAV?$allocator@E@0@@Z PROC ; std::_Destroy_range<std::allocator<unsigned char> >, COMDAT

; 224  : 	{	// destroy [_First, _Last)

	push	ebp
	mov	ebp, esp
	push	ecx

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Ptr_cat@PAEPAE@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAE0@Z ; std::_Ptr_cat<unsigned char *,unsigned char *>
	add	esp, 8
	mov	BYTE PTR $T97655[ebp], al
	movzx	edx, BYTE PTR $T97655[ebp]
	push	edx
	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Destroy_range@V?$allocator@E@std@@@std@@YAXPAE0AAV?$allocator@E@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<unsigned char> >
	add	esp, 16					; 00000010H

; 226  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Destroy_range@V?$allocator@E@std@@@std@@YAXPAE0AAV?$allocator@E@0@@Z ENDP ; std::_Destroy_range<std::allocator<unsigned char> >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@YAXPAUValueParam@ShaderContextPool@Ogre@@0AAV?$allocator@UValueParam@ShaderContextPool@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<Ogre::ShaderContextPool::ValueParam> >
; Function compile flags: /Odtp
;	COMDAT ??$_Destroy_range@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@YAXPAUValueParam@ShaderContextPool@Ogre@@0AAV?$allocator@UValueParam@ShaderContextPool@Ogre@@@0@@Z
_TEXT	SEGMENT
$T97658 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@YAXPAUValueParam@ShaderContextPool@Ogre@@0AAV?$allocator@UValueParam@ShaderContextPool@Ogre@@@0@@Z PROC ; std::_Destroy_range<std::allocator<Ogre::ShaderContextPool::ValueParam> >, COMDAT

; 224  : 	{	// destroy [_First, _Last)

	push	ebp
	mov	ebp, esp
	push	ecx

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Ptr_cat@PAUValueParam@ShaderContextPool@Ogre@@PAU123@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUValueParam@ShaderContextPool@Ogre@@0@Z ; std::_Ptr_cat<Ogre::ShaderContextPool::ValueParam *,Ogre::ShaderContextPool::ValueParam *>
	add	esp, 8
	mov	BYTE PTR $T97658[ebp], al
	movzx	edx, BYTE PTR $T97658[ebp]
	push	edx
	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Destroy_range@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@YAXPAUValueParam@ShaderContextPool@Ogre@@0AAV?$allocator@UValueParam@ShaderContextPool@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<Ogre::ShaderContextPool::ValueParam> >
	add	esp, 16					; 00000010H

; 226  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Destroy_range@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@YAXPAUValueParam@ShaderContextPool@Ogre@@0AAV?$allocator@UValueParam@ShaderContextPool@Ogre@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<Ogre::ShaderContextPool::ValueParam> >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@YAXPAUTexParam@ShaderContextPool@Ogre@@0AAV?$allocator@UTexParam@ShaderContextPool@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<Ogre::ShaderContextPool::TexParam> >
; Function compile flags: /Odtp
;	COMDAT ??$_Destroy_range@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@YAXPAUTexParam@ShaderContextPool@Ogre@@0AAV?$allocator@UTexParam@ShaderContextPool@Ogre@@@0@@Z
_TEXT	SEGMENT
$T97661 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@YAXPAUTexParam@ShaderContextPool@Ogre@@0AAV?$allocator@UTexParam@ShaderContextPool@Ogre@@@0@@Z PROC ; std::_Destroy_range<std::allocator<Ogre::ShaderContextPool::TexParam> >, COMDAT

; 224  : 	{	// destroy [_First, _Last)

	push	ebp
	mov	ebp, esp
	push	ecx

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Ptr_cat@PAUTexParam@ShaderContextPool@Ogre@@PAU123@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUTexParam@ShaderContextPool@Ogre@@0@Z ; std::_Ptr_cat<Ogre::ShaderContextPool::TexParam *,Ogre::ShaderContextPool::TexParam *>
	add	esp, 8
	mov	BYTE PTR $T97661[ebp], al
	movzx	edx, BYTE PTR $T97661[ebp]
	push	edx
	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Destroy_range@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@YAXPAUTexParam@ShaderContextPool@Ogre@@0AAV?$allocator@UTexParam@ShaderContextPool@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<Ogre::ShaderContextPool::TexParam> >
	add	esp, 16					; 00000010H

; 226  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Destroy_range@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@YAXPAUTexParam@ShaderContextPool@Ogre@@0AAV?$allocator@UTexParam@ShaderContextPool@Ogre@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<Ogre::ShaderContextPool::TexParam> >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAVMaterialParam@Ogre@@@std@@@std@@YAXPAPAVMaterialParam@Ogre@@0AAV?$allocator@PAVMaterialParam@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<Ogre::MaterialParam *> >
; Function compile flags: /Odtp
;	COMDAT ??$_Destroy_range@V?$allocator@PAVMaterialParam@Ogre@@@std@@@std@@YAXPAPAVMaterialParam@Ogre@@0AAV?$allocator@PAVMaterialParam@Ogre@@@0@@Z
_TEXT	SEGMENT
$T97664 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@PAVMaterialParam@Ogre@@@std@@@std@@YAXPAPAVMaterialParam@Ogre@@0AAV?$allocator@PAVMaterialParam@Ogre@@@0@@Z PROC ; std::_Destroy_range<std::allocator<Ogre::MaterialParam *> >, COMDAT

; 224  : 	{	// destroy [_First, _Last)

	push	ebp
	mov	ebp, esp
	push	ecx

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Ptr_cat@PAPAVMaterialParam@Ogre@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVMaterialParam@Ogre@@0@Z ; std::_Ptr_cat<Ogre::MaterialParam * *,Ogre::MaterialParam * *>
	add	esp, 8
	mov	BYTE PTR $T97664[ebp], al
	movzx	edx, BYTE PTR $T97664[ebp]
	push	edx
	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Destroy_range@V?$allocator@PAVMaterialParam@Ogre@@@std@@@std@@YAXPAPAVMaterialParam@Ogre@@0AAV?$allocator@PAVMaterialParam@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<Ogre::MaterialParam *> >
	add	esp, 16					; 00000010H

; 226  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Destroy_range@V?$allocator@PAVMaterialParam@Ogre@@@std@@@std@@YAXPAPAVMaterialParam@Ogre@@0AAV?$allocator@PAVMaterialParam@Ogre@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<Ogre::MaterialParam *> >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@D@std@@@std@@YAXPAD0AAV?$allocator@D@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<char> >
; Function compile flags: /Odtp
;	COMDAT ??$_Destroy_range@V?$allocator@D@std@@@std@@YAXPAD0AAV?$allocator@D@0@@Z
_TEXT	SEGMENT
$T97667 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@D@std@@@std@@YAXPAD0AAV?$allocator@D@0@@Z PROC ; std::_Destroy_range<std::allocator<char> >, COMDAT

; 224  : 	{	// destroy [_First, _Last)

	push	ebp
	mov	ebp, esp
	push	ecx

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Ptr_cat@PADPAD@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAD0@Z ; std::_Ptr_cat<char *,char *>
	add	esp, 8
	mov	BYTE PTR $T97667[ebp], al
	movzx	edx, BYTE PTR $T97667[ebp]
	push	edx
	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Destroy_range@V?$allocator@D@std@@@std@@YAXPAD0AAV?$allocator@D@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<char> >
	add	esp, 16					; 00000010H

; 226  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Destroy_range@V?$allocator@D@std@@@std@@YAXPAD0AAV?$allocator@D@0@@Z ENDP ; std::_Destroy_range<std::allocator<char> >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@YAXPAPAVSurfaceData@Ogre@@0AAV?$allocator@PAVSurfaceData@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<Ogre::SurfaceData *> >
; Function compile flags: /Odtp
;	COMDAT ??$_Destroy_range@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@YAXPAPAVSurfaceData@Ogre@@0AAV?$allocator@PAVSurfaceData@Ogre@@@0@@Z
_TEXT	SEGMENT
$T97670 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@YAXPAPAVSurfaceData@Ogre@@0AAV?$allocator@PAVSurfaceData@Ogre@@@0@@Z PROC ; std::_Destroy_range<std::allocator<Ogre::SurfaceData *> >, COMDAT

; 224  : 	{	// destroy [_First, _Last)

	push	ebp
	mov	ebp, esp
	push	ecx

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Ptr_cat@PAPAVSurfaceData@Ogre@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVSurfaceData@Ogre@@0@Z ; std::_Ptr_cat<Ogre::SurfaceData * *,Ogre::SurfaceData * *>
	add	esp, 8
	mov	BYTE PTR $T97670[ebp], al
	movzx	edx, BYTE PTR $T97670[ebp]
	push	edx
	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Destroy_range@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@YAXPAPAVSurfaceData@Ogre@@0AAV?$allocator@PAVSurfaceData@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<Ogre::SurfaceData *> >
	add	esp, 16					; 00000010H

; 226  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Destroy_range@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@YAXPAPAVSurfaceData@Ogre@@0AAV?$allocator@PAVSurfaceData@Ogre@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<Ogre::SurfaceData *> >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@G@std@@@std@@YAXPAG0AAV?$allocator@G@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<unsigned short> >
; Function compile flags: /Odtp
;	COMDAT ??$_Destroy_range@V?$allocator@G@std@@@std@@YAXPAG0AAV?$allocator@G@0@@Z
_TEXT	SEGMENT
$T97673 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@G@std@@@std@@YAXPAG0AAV?$allocator@G@0@@Z PROC ; std::_Destroy_range<std::allocator<unsigned short> >, COMDAT

; 224  : 	{	// destroy [_First, _Last)

	push	ebp
	mov	ebp, esp
	push	ecx

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Ptr_cat@PAGPAG@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAG0@Z ; std::_Ptr_cat<unsigned short *,unsigned short *>
	add	esp, 8
	mov	BYTE PTR $T97673[ebp], al
	movzx	edx, BYTE PTR $T97673[ebp]
	push	edx
	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Destroy_range@V?$allocator@G@std@@@std@@YAXPAG0AAV?$allocator@G@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<unsigned short> >
	add	esp, 16					; 00000010H

; 226  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Destroy_range@V?$allocator@G@std@@@std@@YAXPAG0AAV?$allocator@G@0@@Z ENDP ; std::_Destroy_range<std::allocator<unsigned short> >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@YAXPAURecord@CullResult@Ogre@@0AAV?$allocator@URecord@CullResult@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<Ogre::CullResult::Record> >
; Function compile flags: /Odtp
;	COMDAT ??$_Destroy_range@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@YAXPAURecord@CullResult@Ogre@@0AAV?$allocator@URecord@CullResult@Ogre@@@0@@Z
_TEXT	SEGMENT
$T97676 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@YAXPAURecord@CullResult@Ogre@@0AAV?$allocator@URecord@CullResult@Ogre@@@0@@Z PROC ; std::_Destroy_range<std::allocator<Ogre::CullResult::Record> >, COMDAT

; 224  : 	{	// destroy [_First, _Last)

	push	ebp
	mov	ebp, esp
	push	ecx

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Ptr_cat@PAURecord@CullResult@Ogre@@PAU123@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAURecord@CullResult@Ogre@@0@Z ; std::_Ptr_cat<Ogre::CullResult::Record *,Ogre::CullResult::Record *>
	add	esp, 8
	mov	BYTE PTR $T97676[ebp], al
	movzx	edx, BYTE PTR $T97676[ebp]
	push	edx
	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Destroy_range@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@YAXPAURecord@CullResult@Ogre@@0AAV?$allocator@URecord@CullResult@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<Ogre::CullResult::Record> >
	add	esp, 16					; 00000010H

; 226  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Destroy_range@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@YAXPAURecord@CullResult@Ogre@@0AAV?$allocator@URecord@CullResult@Ogre@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<Ogre::CullResult::Record> >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@YAXPAPAVEffectObject@Ogre@@0AAV?$allocator@PAVEffectObject@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<Ogre::EffectObject *> >
; Function compile flags: /Odtp
;	COMDAT ??$_Destroy_range@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@YAXPAPAVEffectObject@Ogre@@0AAV?$allocator@PAVEffectObject@Ogre@@@0@@Z
_TEXT	SEGMENT
$T97679 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@YAXPAPAVEffectObject@Ogre@@0AAV?$allocator@PAVEffectObject@Ogre@@@0@@Z PROC ; std::_Destroy_range<std::allocator<Ogre::EffectObject *> >, COMDAT

; 224  : 	{	// destroy [_First, _Last)

	push	ebp
	mov	ebp, esp
	push	ecx

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Ptr_cat@PAPAVEffectObject@Ogre@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVEffectObject@Ogre@@0@Z ; std::_Ptr_cat<Ogre::EffectObject * *,Ogre::EffectObject * *>
	add	esp, 8
	mov	BYTE PTR $T97679[ebp], al
	movzx	edx, BYTE PTR $T97679[ebp]
	push	edx
	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Destroy_range@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@YAXPAPAVEffectObject@Ogre@@0AAV?$allocator@PAVEffectObject@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<Ogre::EffectObject *> >
	add	esp, 16					; 00000010H

; 226  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Destroy_range@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@YAXPAPAVEffectObject@Ogre@@0AAV?$allocator@PAVEffectObject@Ogre@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<Ogre::EffectObject *> >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@YAXPAPAVSoundNode@Ogre@@0AAV?$allocator@PAVSoundNode@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<Ogre::SoundNode *> >
; Function compile flags: /Odtp
;	COMDAT ??$_Destroy_range@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@YAXPAPAVSoundNode@Ogre@@0AAV?$allocator@PAVSoundNode@Ogre@@@0@@Z
_TEXT	SEGMENT
$T97682 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@YAXPAPAVSoundNode@Ogre@@0AAV?$allocator@PAVSoundNode@Ogre@@@0@@Z PROC ; std::_Destroy_range<std::allocator<Ogre::SoundNode *> >, COMDAT

; 224  : 	{	// destroy [_First, _Last)

	push	ebp
	mov	ebp, esp
	push	ecx

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Ptr_cat@PAPAVSoundNode@Ogre@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVSoundNode@Ogre@@0@Z ; std::_Ptr_cat<Ogre::SoundNode * *,Ogre::SoundNode * *>
	add	esp, 8
	mov	BYTE PTR $T97682[ebp], al
	movzx	edx, BYTE PTR $T97682[ebp]
	push	edx
	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Destroy_range@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@YAXPAPAVSoundNode@Ogre@@0AAV?$allocator@PAVSoundNode@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<Ogre::SoundNode *> >
	add	esp, 16					; 00000010H

; 226  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Destroy_range@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@YAXPAPAVSoundNode@Ogre@@0AAV?$allocator@PAVSoundNode@Ogre@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<Ogre::SoundNode *> >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@YAXPAPAVRenderableObject@Ogre@@0AAV?$allocator@PAVRenderableObject@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<Ogre::RenderableObject *> >
; Function compile flags: /Odtp
;	COMDAT ??$_Destroy_range@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@YAXPAPAVRenderableObject@Ogre@@0AAV?$allocator@PAVRenderableObject@Ogre@@@0@@Z
_TEXT	SEGMENT
$T97685 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@YAXPAPAVRenderableObject@Ogre@@0AAV?$allocator@PAVRenderableObject@Ogre@@@0@@Z PROC ; std::_Destroy_range<std::allocator<Ogre::RenderableObject *> >, COMDAT

; 224  : 	{	// destroy [_First, _Last)

	push	ebp
	mov	ebp, esp
	push	ecx

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Ptr_cat@PAPAVRenderableObject@Ogre@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVRenderableObject@Ogre@@0@Z ; std::_Ptr_cat<Ogre::RenderableObject * *,Ogre::RenderableObject * *>
	add	esp, 8
	mov	BYTE PTR $T97685[ebp], al
	movzx	edx, BYTE PTR $T97685[ebp]
	push	edx
	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Destroy_range@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@YAXPAPAVRenderableObject@Ogre@@0AAV?$allocator@PAVRenderableObject@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<Ogre::RenderableObject *> >
	add	esp, 16					; 00000010H

; 226  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Destroy_range@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@YAXPAPAVRenderableObject@Ogre@@0AAV?$allocator@PAVRenderableObject@Ogre@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<Ogre::RenderableObject *> >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@PAVLight@Ogre@@@std@@@std@@YAXPAPAVLight@Ogre@@0AAV?$allocator@PAVLight@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<Ogre::Light *> >
; Function compile flags: /Odtp
;	COMDAT ??$_Destroy_range@V?$allocator@PAVLight@Ogre@@@std@@@std@@YAXPAPAVLight@Ogre@@0AAV?$allocator@PAVLight@Ogre@@@0@@Z
_TEXT	SEGMENT
$T97688 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@PAVLight@Ogre@@@std@@@std@@YAXPAPAVLight@Ogre@@0AAV?$allocator@PAVLight@Ogre@@@0@@Z PROC ; std::_Destroy_range<std::allocator<Ogre::Light *> >, COMDAT

; 224  : 	{	// destroy [_First, _Last)

	push	ebp
	mov	ebp, esp
	push	ecx

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Ptr_cat@PAPAVLight@Ogre@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVLight@Ogre@@0@Z ; std::_Ptr_cat<Ogre::Light * *,Ogre::Light * *>
	add	esp, 8
	mov	BYTE PTR $T97688[ebp], al
	movzx	edx, BYTE PTR $T97688[ebp]
	push	edx
	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Destroy_range@V?$allocator@PAVLight@Ogre@@@std@@@std@@YAXPAPAVLight@Ogre@@0AAV?$allocator@PAVLight@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<Ogre::Light *> >
	add	esp, 16					; 00000010H

; 226  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Destroy_range@V?$allocator@PAVLight@Ogre@@@std@@@std@@YAXPAPAVLight@Ogre@@0AAV?$allocator@PAVLight@Ogre@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<Ogre::Light *> >
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@YAXPAUAnimRange@BaseKeyFrameArray@Ogre@@0AAV?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >
; Function compile flags: /Odtp
;	COMDAT ??$_Destroy_range@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@YAXPAUAnimRange@BaseKeyFrameArray@Ogre@@0AAV?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@0@@Z
_TEXT	SEGMENT
$T97691 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@YAXPAUAnimRange@BaseKeyFrameArray@Ogre@@0AAV?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@0@@Z PROC ; std::_Destroy_range<std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >, COMDAT

; 224  : 	{	// destroy [_First, _Last)

	push	ebp
	mov	ebp, esp
	push	ecx

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Ptr_cat@PAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUAnimRange@BaseKeyFrameArray@Ogre@@0@Z ; std::_Ptr_cat<Ogre::BaseKeyFrameArray::AnimRange *,Ogre::BaseKeyFrameArray::AnimRange *>
	add	esp, 8
	mov	BYTE PTR $T97691[ebp], al
	movzx	edx, BYTE PTR $T97691[ebp]
	push	edx
	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Destroy_range@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@YAXPAUAnimRange@BaseKeyFrameArray@Ogre@@0AAV?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >
	add	esp, 16					; 00000010H

; 226  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Destroy_range@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@YAXPAUAnimRange@BaseKeyFrameArray@Ogre@@0AAV?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$?0UAnimRange@BaseKeyFrameArray@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??$?0UAnimRange@BaseKeyFrameArray@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@1@@Z PROC ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::BaseKeyFrameArray::AnimRange>, COMDAT
; _this$ = ecx

; 128  : 		allocator(const allocator<_Other>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0UAnimRange@BaseKeyFrameArray@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@1@@Z ENDP ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::BaseKeyFrameArray::AnimRange>
_TEXT	ENDS
PUBLIC	__TI2?AVbad_alloc@std@@
PUBLIC	??0bad_alloc@std@@QAE@PBD@Z			; std::bad_alloc::bad_alloc
PUBLIC	??1bad_alloc@std@@UAE@XZ			; std::bad_alloc::~bad_alloc
PUBLIC	__CTA2?AVbad_alloc@std@@
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
EXTRN	??2@YAPAXI@Z:PROC				; operator new
;	COMDAT ??_R0?AVbad_alloc@std@@@8
_DATA	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_alloc@std@@
xdata$x	SEGMENT
__CTA2?AVbad_alloc@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI2?AVbad_alloc@std@@
xdata$x	SEGMENT
__TI2?AVbad_alloc@std@@ DD 00H
	DD	FLAT:??1bad_alloc@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVbad_alloc@std@@
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??$_Allocate@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@IPAU123@@Z
_TEXT	SEGMENT
$T97696 = -12						; size = 12
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@IPAU123@@Z PROC ; std::_Allocate<Ogre::BaseKeyFrameArray::AnimRange>, COMDAT

; 36   : 	{	// check for integer overflow

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 37   : 	if (_Count <= 0)

	cmp	DWORD PTR __Count$[ebp], 0
	ja	SHORT $LN3@Allocate

; 38   : 		_Count = 0;

	mov	DWORD PTR __Count$[ebp], 0
	jmp	SHORT $LN2@Allocate
$LN3@Allocate:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Count$[ebp]
	cmp	eax, 8
	jae	SHORT $LN2@Allocate

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	push	0
	lea	ecx, DWORD PTR $T97696[ebp]
	call	??0bad_alloc@std@@QAE@PBD@Z		; std::bad_alloc::bad_alloc
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	eax, DWORD PTR $T97696[ebp]
	push	eax
	call	__CxxThrowException@8
$LN2@Allocate:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 3
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
$LN5@Allocate:

; 44   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@IPAU123@@Z ENDP ; std::_Allocate<Ogre::BaseKeyFrameArray::AnimRange>
_TEXT	ENDS
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	__imp_??0exception@std@@QAE@ABQBD@Z:PROC
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	?what@exception@std@@UBEPBDXZ:PROC		; std::exception::what
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0bad_alloc@std@@QAE@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0bad_alloc@std@@QAE@PBD@Z$0
__ehfuncinfo$??0bad_alloc@std@@QAE@PBD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0bad_alloc@std@@QAE@PBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@PBD@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Message$ = 8						; size = 4
??0bad_alloc@std@@QAE@PBD@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx

; 371  : 		{	// construct from message string

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0bad_alloc@std@@QAE@PBD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	lea	eax, DWORD PTR __Message$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7bad_alloc@std@@6B@

; 372  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0bad_alloc@std@@QAE@PBD@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??0bad_alloc@std@@QAE@PBD@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0bad_alloc@std@@QAE@PBD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0bad_alloc@std@@QAE@PBD@Z ENDP			; std::bad_alloc::bad_alloc
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1bad_alloc@std@@UAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1bad_alloc@std@@UAE@XZ$0
__ehfuncinfo$??1bad_alloc@std@@UAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1bad_alloc@std@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1bad_alloc@std@@UAE@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
; _this$ = ecx

; 380  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1bad_alloc@std@@UAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 381  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1bad_alloc@std@@UAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??1bad_alloc@std@@UAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1bad_alloc@std@@UAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1bad_alloc@std@@UAE@XZ ENDP				; std::bad_alloc::~bad_alloc
; Function compile flags: /Odtp
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1bad_alloc@std@@UAE@XZ		; std::bad_alloc::~bad_alloc
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@32
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@32:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@0AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@0AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@0@@Z
_TEXT	SEGMENT
$T97719 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@0AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@0@@Z PROC ; std::_Destroy_range<std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >, COMDAT

; 224  : 	{	// destroy [_First, _Last)

	push	ebp
	mov	ebp, esp
	push	ecx

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Ptr_cat@PAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU123@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@0@Z ; std::_Ptr_cat<Ogre::KeyFrameArray<float>::KEYFRAME_T *,Ogre::KeyFrameArray<float>::KEYFRAME_T *>
	add	esp, 8
	mov	BYTE PTR $T97719[ebp], al
	movzx	edx, BYTE PTR $T97719[ebp]
	push	edx
	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Destroy_range@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@0AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >
	add	esp, 16					; 00000010H

; 226  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Destroy_range@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@0AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$?0UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??$?0UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@1@@Z PROC ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::KeyFrameArray<float>::KEYFRAME_T>, COMDAT
; _this$ = ecx

; 128  : 		allocator(const allocator<_Other>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@1@@Z ENDP ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::KeyFrameArray<float>::KEYFRAME_T>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Allocate@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@IPAU123@@Z
_TEXT	SEGMENT
$T97724 = -12						; size = 12
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@IPAU123@@Z PROC ; std::_Allocate<Ogre::KeyFrameArray<float>::KEYFRAME_T>, COMDAT

; 36   : 	{	// check for integer overflow

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 37   : 	if (_Count <= 0)

	cmp	DWORD PTR __Count$[ebp], 0
	ja	SHORT $LN3@Allocate@2

; 38   : 		_Count = 0;

	mov	DWORD PTR __Count$[ebp], 0
	jmp	SHORT $LN2@Allocate@2
$LN3@Allocate@2:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Count$[ebp]
	cmp	eax, 8
	jae	SHORT $LN2@Allocate@2

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	push	0
	lea	ecx, DWORD PTR $T97724[ebp]
	call	??0bad_alloc@std@@QAE@PBD@Z		; std::bad_alloc::bad_alloc
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	eax, DWORD PTR $T97724[ebp]
	push	eax
	call	__CxxThrowException@8
$LN2@Allocate@2:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 3
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
$LN5@Allocate@2:

; 44   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@IPAU123@@Z ENDP ; std::_Allocate<Ogre::KeyFrameArray<float>::KEYFRAME_T>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@0AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >
; Function compile flags: /Odtp
;	COMDAT ??$_Destroy_range@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@0AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@0@@Z
_TEXT	SEGMENT
$T97727 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@0AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@0@@Z PROC ; std::_Destroy_range<std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >, COMDAT

; 224  : 	{	// destroy [_First, _Last)

	push	ebp
	mov	ebp, esp
	push	ecx

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Ptr_cat@PAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU123@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@0@Z ; std::_Ptr_cat<Ogre::KeyFrameArray<float>::CONTROL_POINT_T *,Ogre::KeyFrameArray<float>::CONTROL_POINT_T *>
	add	esp, 8
	mov	BYTE PTR $T97727[ebp], al
	movzx	edx, BYTE PTR $T97727[ebp]
	push	edx
	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Destroy_range@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@0AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >
	add	esp, 16					; 00000010H

; 226  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Destroy_range@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@0AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$?0UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??$?0UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@1@@Z PROC ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::KeyFrameArray<float>::CONTROL_POINT_T>, COMDAT
; _this$ = ecx

; 128  : 		allocator(const allocator<_Other>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@1@@Z ENDP ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::KeyFrameArray<float>::CONTROL_POINT_T>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Allocate@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@IPAU123@@Z
_TEXT	SEGMENT
$T97732 = -12						; size = 12
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@IPAU123@@Z PROC ; std::_Allocate<Ogre::KeyFrameArray<float>::CONTROL_POINT_T>, COMDAT

; 36   : 	{	// check for integer overflow

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 37   : 	if (_Count <= 0)

	cmp	DWORD PTR __Count$[ebp], 0
	ja	SHORT $LN3@Allocate@3

; 38   : 		_Count = 0;

	mov	DWORD PTR __Count$[ebp], 0
	jmp	SHORT $LN2@Allocate@3
$LN3@Allocate@3:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Count$[ebp]
	cmp	eax, 8
	jae	SHORT $LN2@Allocate@3

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	push	0
	lea	ecx, DWORD PTR $T97732[ebp]
	call	??0bad_alloc@std@@QAE@PBD@Z		; std::bad_alloc::bad_alloc
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	eax, DWORD PTR $T97732[ebp]
	push	eax
	call	__CxxThrowException@8
$LN2@Allocate@3:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 3
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
$LN5@Allocate@3:

; 44   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@IPAU123@@Z ENDP ; std::_Allocate<Ogre::KeyFrameArray<float>::CONTROL_POINT_T>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@0AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >
; Function compile flags: /Odtp
;	COMDAT ??$_Destroy_range@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@0AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@0@@Z
_TEXT	SEGMENT
$T97735 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@0AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@0@@Z PROC ; std::_Destroy_range<std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >, COMDAT

; 224  : 	{	// destroy [_First, _Last)

	push	ebp
	mov	ebp, esp
	push	ecx

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Ptr_cat@PAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@0@Z ; std::_Ptr_cat<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T *>
	add	esp, 8
	mov	BYTE PTR $T97735[ebp], al
	movzx	edx, BYTE PTR $T97735[ebp]
	push	edx
	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Destroy_range@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@0AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >
	add	esp, 16					; 00000010H

; 226  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Destroy_range@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@0AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$?0UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??$?0UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@1@@Z PROC ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T>, COMDAT
; _this$ = ecx

; 128  : 		allocator(const allocator<_Other>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@1@@Z ENDP ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Allocate@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@IPAU123@@Z
_TEXT	SEGMENT
$T97740 = -12						; size = 12
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@IPAU123@@Z PROC ; std::_Allocate<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T>, COMDAT

; 36   : 	{	// check for integer overflow

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 37   : 	if (_Count <= 0)

	cmp	DWORD PTR __Count$[ebp], 0
	ja	SHORT $LN3@Allocate@4

; 38   : 		_Count = 0;

	mov	DWORD PTR __Count$[ebp], 0
	jmp	SHORT $LN2@Allocate@4
$LN3@Allocate@4:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Count$[ebp]
	cmp	eax, 20					; 00000014H
	jae	SHORT $LN2@Allocate@4

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	push	0
	lea	ecx, DWORD PTR $T97740[ebp]
	call	??0bad_alloc@std@@QAE@PBD@Z		; std::bad_alloc::bad_alloc
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	eax, DWORD PTR $T97740[ebp]
	push	eax
	call	__CxxThrowException@8
$LN2@Allocate@4:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	mov	ecx, DWORD PTR __Count$[ebp]
	imul	ecx, 20					; 00000014H
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
$LN5@Allocate@4:

; 44   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@IPAU123@@Z ENDP ; std::_Allocate<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T>
_TEXT	ENDS
PUBLIC	??$_Destroy_range@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@0AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >
; Function compile flags: /Odtp
;	COMDAT ??$_Destroy_range@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@0AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@0@@Z
_TEXT	SEGMENT
$T97743 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@0AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@0@@Z PROC ; std::_Destroy_range<std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >, COMDAT

; 224  : 	{	// destroy [_First, _Last)

	push	ebp
	mov	ebp, esp
	push	ecx

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Ptr_cat@PAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@0@Z ; std::_Ptr_cat<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T *>
	add	esp, 8
	mov	BYTE PTR $T97743[ebp], al
	movzx	edx, BYTE PTR $T97743[ebp]
	push	edx
	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Destroy_range@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@0AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >
	add	esp, 16					; 00000010H

; 226  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Destroy_range@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@0AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$?0UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??$?0UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@1@@Z PROC ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T>, COMDAT
; _this$ = ecx

; 128  : 		allocator(const allocator<_Other>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@1@@Z ENDP ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Allocate@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@IPAU123@@Z
_TEXT	SEGMENT
$T97748 = -12						; size = 12
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@IPAU123@@Z PROC ; std::_Allocate<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T>, COMDAT

; 36   : 	{	// check for integer overflow

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 37   : 	if (_Count <= 0)

	cmp	DWORD PTR __Count$[ebp], 0
	ja	SHORT $LN3@Allocate@5

; 38   : 		_Count = 0;

	mov	DWORD PTR __Count$[ebp], 0
	jmp	SHORT $LN2@Allocate@5
$LN3@Allocate@5:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Count$[ebp]
	cmp	eax, 32					; 00000020H
	jae	SHORT $LN2@Allocate@5

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	push	0
	lea	ecx, DWORD PTR $T97748[ebp]
	call	??0bad_alloc@std@@QAE@PBD@Z		; std::bad_alloc::bad_alloc
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	eax, DWORD PTR $T97748[ebp]
	push	eax
	call	__CxxThrowException@8
$LN2@Allocate@5:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 5
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
$LN5@Allocate@5:

; 44   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@IPAU123@@Z ENDP ; std::_Allocate<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$?0PAVShaderContext@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@PAVShaderContext@Ogre@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??$?0PAVShaderContext@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@PAVShaderContext@Ogre@@@1@@Z PROC ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::ShaderContext *>, COMDAT
; _this$ = ecx

; 128  : 		allocator(const allocator<_Other>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0PAVShaderContext@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@PAVShaderContext@Ogre@@@1@@Z ENDP ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::ShaderContext *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Allocate@PAVShaderContext@Ogre@@@std@@YAPAPAVShaderContext@Ogre@@IPAPAV12@@Z
_TEXT	SEGMENT
$T97753 = -12						; size = 12
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@PAVShaderContext@Ogre@@@std@@YAPAPAVShaderContext@Ogre@@IPAPAV12@@Z PROC ; std::_Allocate<Ogre::ShaderContext *>, COMDAT

; 36   : 	{	// check for integer overflow

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 37   : 	if (_Count <= 0)

	cmp	DWORD PTR __Count$[ebp], 0
	ja	SHORT $LN3@Allocate@6

; 38   : 		_Count = 0;

	mov	DWORD PTR __Count$[ebp], 0
	jmp	SHORT $LN2@Allocate@6
$LN3@Allocate@6:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Count$[ebp]
	cmp	eax, 4
	jae	SHORT $LN2@Allocate@6

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	push	0
	lea	ecx, DWORD PTR $T97753[ebp]
	call	??0bad_alloc@std@@QAE@PBD@Z		; std::bad_alloc::bad_alloc
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	eax, DWORD PTR $T97753[ebp]
	push	eax
	call	__CxxThrowException@8
$LN2@Allocate@6:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 2
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
$LN5@Allocate@6:

; 44   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@PAVShaderContext@Ogre@@@std@@YAPAPAVShaderContext@Ogre@@IPAPAV12@@Z ENDP ; std::_Allocate<Ogre::ShaderContext *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$?0UContextQueDesc@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@UContextQueDesc@Ogre@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??$?0UContextQueDesc@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@UContextQueDesc@Ogre@@@1@@Z PROC ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::ContextQueDesc>, COMDAT
; _this$ = ecx

; 128  : 		allocator(const allocator<_Other>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0UContextQueDesc@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@UContextQueDesc@Ogre@@@1@@Z ENDP ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::ContextQueDesc>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Allocate@UContextQueDesc@Ogre@@@std@@YAPAUContextQueDesc@Ogre@@IPAU12@@Z
_TEXT	SEGMENT
$T97758 = -12						; size = 12
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@UContextQueDesc@Ogre@@@std@@YAPAUContextQueDesc@Ogre@@IPAU12@@Z PROC ; std::_Allocate<Ogre::ContextQueDesc>, COMDAT

; 36   : 	{	// check for integer overflow

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 37   : 	if (_Count <= 0)

	cmp	DWORD PTR __Count$[ebp], 0
	ja	SHORT $LN3@Allocate@7

; 38   : 		_Count = 0;

	mov	DWORD PTR __Count$[ebp], 0
	jmp	SHORT $LN2@Allocate@7
$LN3@Allocate@7:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Count$[ebp]
	cmp	eax, 156				; 0000009cH
	jae	SHORT $LN2@Allocate@7

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	push	0
	lea	ecx, DWORD PTR $T97758[ebp]
	call	??0bad_alloc@std@@QAE@PBD@Z		; std::bad_alloc::bad_alloc
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	eax, DWORD PTR $T97758[ebp]
	push	eax
	call	__CxxThrowException@8
$LN2@Allocate@7:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	mov	ecx, DWORD PTR __Count$[ebp]
	imul	ecx, 156				; 0000009cH
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
$LN5@Allocate@7:

; 44   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@UContextQueDesc@Ogre@@@std@@YAPAUContextQueDesc@Ogre@@IPAU12@@Z ENDP ; std::_Allocate<Ogre::ContextQueDesc>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$?0E@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@E@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??$?0E@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@E@1@@Z PROC ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><unsigned char>, COMDAT
; _this$ = ecx

; 128  : 		allocator(const allocator<_Other>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0E@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@E@1@@Z ENDP ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><unsigned char>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Allocate@E@std@@YAPAEIPAE@Z
_TEXT	SEGMENT
$T97763 = -12						; size = 12
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@E@std@@YAPAEIPAE@Z PROC			; std::_Allocate<unsigned char>, COMDAT

; 36   : 	{	// check for integer overflow

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 37   : 	if (_Count <= 0)

	cmp	DWORD PTR __Count$[ebp], 0
	ja	SHORT $LN3@Allocate@8

; 38   : 		_Count = 0;

	mov	DWORD PTR __Count$[ebp], 0
	jmp	SHORT $LN2@Allocate@8
$LN3@Allocate@8:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Count$[ebp]
	cmp	eax, 1
	jae	SHORT $LN2@Allocate@8

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	push	0
	lea	ecx, DWORD PTR $T97763[ebp]
	call	??0bad_alloc@std@@QAE@PBD@Z		; std::bad_alloc::bad_alloc
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	eax, DWORD PTR $T97763[ebp]
	push	eax
	call	__CxxThrowException@8
$LN2@Allocate@8:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
$LN5@Allocate@8:

; 44   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@E@std@@YAPAEIPAE@Z ENDP			; std::_Allocate<unsigned char>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$?0UValueParam@ShaderContextPool@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@UValueParam@ShaderContextPool@Ogre@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??$?0UValueParam@ShaderContextPool@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@UValueParam@ShaderContextPool@Ogre@@@1@@Z PROC ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::ShaderContextPool::ValueParam>, COMDAT
; _this$ = ecx

; 128  : 		allocator(const allocator<_Other>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0UValueParam@ShaderContextPool@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@UValueParam@ShaderContextPool@Ogre@@@1@@Z ENDP ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::ShaderContextPool::ValueParam>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Allocate@UValueParam@ShaderContextPool@Ogre@@@std@@YAPAUValueParam@ShaderContextPool@Ogre@@IPAU123@@Z
_TEXT	SEGMENT
$T97768 = -12						; size = 12
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@UValueParam@ShaderContextPool@Ogre@@@std@@YAPAUValueParam@ShaderContextPool@Ogre@@IPAU123@@Z PROC ; std::_Allocate<Ogre::ShaderContextPool::ValueParam>, COMDAT

; 36   : 	{	// check for integer overflow

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 37   : 	if (_Count <= 0)

	cmp	DWORD PTR __Count$[ebp], 0
	ja	SHORT $LN3@Allocate@9

; 38   : 		_Count = 0;

	mov	DWORD PTR __Count$[ebp], 0
	jmp	SHORT $LN2@Allocate@9
$LN3@Allocate@9:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Count$[ebp]
	cmp	eax, 16					; 00000010H
	jae	SHORT $LN2@Allocate@9

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	push	0
	lea	ecx, DWORD PTR $T97768[ebp]
	call	??0bad_alloc@std@@QAE@PBD@Z		; std::bad_alloc::bad_alloc
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	eax, DWORD PTR $T97768[ebp]
	push	eax
	call	__CxxThrowException@8
$LN2@Allocate@9:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 4
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
$LN5@Allocate@9:

; 44   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@UValueParam@ShaderContextPool@Ogre@@@std@@YAPAUValueParam@ShaderContextPool@Ogre@@IPAU123@@Z ENDP ; std::_Allocate<Ogre::ShaderContextPool::ValueParam>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$?0UTexParam@ShaderContextPool@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@UTexParam@ShaderContextPool@Ogre@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??$?0UTexParam@ShaderContextPool@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@UTexParam@ShaderContextPool@Ogre@@@1@@Z PROC ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::ShaderContextPool::TexParam>, COMDAT
; _this$ = ecx

; 128  : 		allocator(const allocator<_Other>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0UTexParam@ShaderContextPool@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@UTexParam@ShaderContextPool@Ogre@@@1@@Z ENDP ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::ShaderContextPool::TexParam>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Allocate@UTexParam@ShaderContextPool@Ogre@@@std@@YAPAUTexParam@ShaderContextPool@Ogre@@IPAU123@@Z
_TEXT	SEGMENT
$T97773 = -12						; size = 12
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@UTexParam@ShaderContextPool@Ogre@@@std@@YAPAUTexParam@ShaderContextPool@Ogre@@IPAU123@@Z PROC ; std::_Allocate<Ogre::ShaderContextPool::TexParam>, COMDAT

; 36   : 	{	// check for integer overflow

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 37   : 	if (_Count <= 0)

	cmp	DWORD PTR __Count$[ebp], 0
	ja	SHORT $LN3@Allocate@10

; 38   : 		_Count = 0;

	mov	DWORD PTR __Count$[ebp], 0
	jmp	SHORT $LN2@Allocate@10
$LN3@Allocate@10:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Count$[ebp]
	cmp	eax, 8
	jae	SHORT $LN2@Allocate@10

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	push	0
	lea	ecx, DWORD PTR $T97773[ebp]
	call	??0bad_alloc@std@@QAE@PBD@Z		; std::bad_alloc::bad_alloc
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	eax, DWORD PTR $T97773[ebp]
	push	eax
	call	__CxxThrowException@8
$LN2@Allocate@10:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 3
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
$LN5@Allocate@10:

; 44   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@UTexParam@ShaderContextPool@Ogre@@@std@@YAPAUTexParam@ShaderContextPool@Ogre@@IPAU123@@Z ENDP ; std::_Allocate<Ogre::ShaderContextPool::TexParam>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Allocate@PAVMaterialParam@Ogre@@@std@@YAPAPAVMaterialParam@Ogre@@IPAPAV12@@Z
_TEXT	SEGMENT
$T97776 = -12						; size = 12
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@PAVMaterialParam@Ogre@@@std@@YAPAPAVMaterialParam@Ogre@@IPAPAV12@@Z PROC ; std::_Allocate<Ogre::MaterialParam *>, COMDAT

; 36   : 	{	// check for integer overflow

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 37   : 	if (_Count <= 0)

	cmp	DWORD PTR __Count$[ebp], 0
	ja	SHORT $LN3@Allocate@11

; 38   : 		_Count = 0;

	mov	DWORD PTR __Count$[ebp], 0
	jmp	SHORT $LN2@Allocate@11
$LN3@Allocate@11:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Count$[ebp]
	cmp	eax, 4
	jae	SHORT $LN2@Allocate@11

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	push	0
	lea	ecx, DWORD PTR $T97776[ebp]
	call	??0bad_alloc@std@@QAE@PBD@Z		; std::bad_alloc::bad_alloc
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	eax, DWORD PTR $T97776[ebp]
	push	eax
	call	__CxxThrowException@8
$LN2@Allocate@11:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 2
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
$LN5@Allocate@11:

; 44   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@PAVMaterialParam@Ogre@@@std@@YAPAPAVMaterialParam@Ogre@@IPAPAV12@@Z ENDP ; std::_Allocate<Ogre::MaterialParam *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$?0D@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@D@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??$?0D@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@D@1@@Z PROC ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><char>, COMDAT
; _this$ = ecx

; 128  : 		allocator(const allocator<_Other>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0D@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@D@1@@Z ENDP ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><char>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$?0PAVSurfaceData@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@PAVSurfaceData@Ogre@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??$?0PAVSurfaceData@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@PAVSurfaceData@Ogre@@@1@@Z PROC ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::SurfaceData *>, COMDAT
; _this$ = ecx

; 128  : 		allocator(const allocator<_Other>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0PAVSurfaceData@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@PAVSurfaceData@Ogre@@@1@@Z ENDP ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::SurfaceData *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Allocate@PAVSurfaceData@Ogre@@@std@@YAPAPAVSurfaceData@Ogre@@IPAPAV12@@Z
_TEXT	SEGMENT
$T97783 = -12						; size = 12
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@PAVSurfaceData@Ogre@@@std@@YAPAPAVSurfaceData@Ogre@@IPAPAV12@@Z PROC ; std::_Allocate<Ogre::SurfaceData *>, COMDAT

; 36   : 	{	// check for integer overflow

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 37   : 	if (_Count <= 0)

	cmp	DWORD PTR __Count$[ebp], 0
	ja	SHORT $LN3@Allocate@12

; 38   : 		_Count = 0;

	mov	DWORD PTR __Count$[ebp], 0
	jmp	SHORT $LN2@Allocate@12
$LN3@Allocate@12:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Count$[ebp]
	cmp	eax, 4
	jae	SHORT $LN2@Allocate@12

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	push	0
	lea	ecx, DWORD PTR $T97783[ebp]
	call	??0bad_alloc@std@@QAE@PBD@Z		; std::bad_alloc::bad_alloc
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	eax, DWORD PTR $T97783[ebp]
	push	eax
	call	__CxxThrowException@8
$LN2@Allocate@12:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 2
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
$LN5@Allocate@12:

; 44   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@PAVSurfaceData@Ogre@@@std@@YAPAPAVSurfaceData@Ogre@@IPAPAV12@@Z ENDP ; std::_Allocate<Ogre::SurfaceData *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Allocate@G@std@@YAPAGIPAG@Z
_TEXT	SEGMENT
$T97786 = -12						; size = 12
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@G@std@@YAPAGIPAG@Z PROC			; std::_Allocate<unsigned short>, COMDAT

; 36   : 	{	// check for integer overflow

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 37   : 	if (_Count <= 0)

	cmp	DWORD PTR __Count$[ebp], 0
	ja	SHORT $LN3@Allocate@13

; 38   : 		_Count = 0;

	mov	DWORD PTR __Count$[ebp], 0
	jmp	SHORT $LN2@Allocate@13
$LN3@Allocate@13:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Count$[ebp]
	cmp	eax, 2
	jae	SHORT $LN2@Allocate@13

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	push	0
	lea	ecx, DWORD PTR $T97786[ebp]
	call	??0bad_alloc@std@@QAE@PBD@Z		; std::bad_alloc::bad_alloc
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	eax, DWORD PTR $T97786[ebp]
	push	eax
	call	__CxxThrowException@8
$LN2@Allocate@13:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 1
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
$LN5@Allocate@13:

; 44   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@G@std@@YAPAGIPAG@Z ENDP			; std::_Allocate<unsigned short>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$?0URecord@CullResult@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@URecord@CullResult@Ogre@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??$?0URecord@CullResult@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@URecord@CullResult@Ogre@@@1@@Z PROC ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::CullResult::Record>, COMDAT
; _this$ = ecx

; 128  : 		allocator(const allocator<_Other>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0URecord@CullResult@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@URecord@CullResult@Ogre@@@1@@Z ENDP ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::CullResult::Record>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Allocate@URecord@CullResult@Ogre@@@std@@YAPAURecord@CullResult@Ogre@@IPAU123@@Z
_TEXT	SEGMENT
$T97791 = -12						; size = 12
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@URecord@CullResult@Ogre@@@std@@YAPAURecord@CullResult@Ogre@@IPAU123@@Z PROC ; std::_Allocate<Ogre::CullResult::Record>, COMDAT

; 36   : 	{	// check for integer overflow

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 37   : 	if (_Count <= 0)

	cmp	DWORD PTR __Count$[ebp], 0
	ja	SHORT $LN3@Allocate@14

; 38   : 		_Count = 0;

	mov	DWORD PTR __Count$[ebp], 0
	jmp	SHORT $LN2@Allocate@14
$LN3@Allocate@14:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Count$[ebp]
	cmp	eax, 16					; 00000010H
	jae	SHORT $LN2@Allocate@14

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	push	0
	lea	ecx, DWORD PTR $T97791[ebp]
	call	??0bad_alloc@std@@QAE@PBD@Z		; std::bad_alloc::bad_alloc
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	eax, DWORD PTR $T97791[ebp]
	push	eax
	call	__CxxThrowException@8
$LN2@Allocate@14:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 4
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
$LN5@Allocate@14:

; 44   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@URecord@CullResult@Ogre@@@std@@YAPAURecord@CullResult@Ogre@@IPAU123@@Z ENDP ; std::_Allocate<Ogre::CullResult::Record>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$?0PAVEffectObject@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@PAVEffectObject@Ogre@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??$?0PAVEffectObject@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@PAVEffectObject@Ogre@@@1@@Z PROC ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::EffectObject *>, COMDAT
; _this$ = ecx

; 128  : 		allocator(const allocator<_Other>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0PAVEffectObject@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@PAVEffectObject@Ogre@@@1@@Z ENDP ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::EffectObject *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Allocate@PAVEffectObject@Ogre@@@std@@YAPAPAVEffectObject@Ogre@@IPAPAV12@@Z
_TEXT	SEGMENT
$T97796 = -12						; size = 12
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@PAVEffectObject@Ogre@@@std@@YAPAPAVEffectObject@Ogre@@IPAPAV12@@Z PROC ; std::_Allocate<Ogre::EffectObject *>, COMDAT

; 36   : 	{	// check for integer overflow

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 37   : 	if (_Count <= 0)

	cmp	DWORD PTR __Count$[ebp], 0
	ja	SHORT $LN3@Allocate@15

; 38   : 		_Count = 0;

	mov	DWORD PTR __Count$[ebp], 0
	jmp	SHORT $LN2@Allocate@15
$LN3@Allocate@15:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Count$[ebp]
	cmp	eax, 4
	jae	SHORT $LN2@Allocate@15

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	push	0
	lea	ecx, DWORD PTR $T97796[ebp]
	call	??0bad_alloc@std@@QAE@PBD@Z		; std::bad_alloc::bad_alloc
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	eax, DWORD PTR $T97796[ebp]
	push	eax
	call	__CxxThrowException@8
$LN2@Allocate@15:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 2
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
$LN5@Allocate@15:

; 44   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@PAVEffectObject@Ogre@@@std@@YAPAPAVEffectObject@Ogre@@IPAPAV12@@Z ENDP ; std::_Allocate<Ogre::EffectObject *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$?0PAVSoundNode@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@PAVSoundNode@Ogre@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??$?0PAVSoundNode@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@PAVSoundNode@Ogre@@@1@@Z PROC ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::SoundNode *>, COMDAT
; _this$ = ecx

; 128  : 		allocator(const allocator<_Other>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0PAVSoundNode@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@PAVSoundNode@Ogre@@@1@@Z ENDP ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::SoundNode *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Allocate@PAVSoundNode@Ogre@@@std@@YAPAPAVSoundNode@Ogre@@IPAPAV12@@Z
_TEXT	SEGMENT
$T97801 = -12						; size = 12
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@PAVSoundNode@Ogre@@@std@@YAPAPAVSoundNode@Ogre@@IPAPAV12@@Z PROC ; std::_Allocate<Ogre::SoundNode *>, COMDAT

; 36   : 	{	// check for integer overflow

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 37   : 	if (_Count <= 0)

	cmp	DWORD PTR __Count$[ebp], 0
	ja	SHORT $LN3@Allocate@16

; 38   : 		_Count = 0;

	mov	DWORD PTR __Count$[ebp], 0
	jmp	SHORT $LN2@Allocate@16
$LN3@Allocate@16:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Count$[ebp]
	cmp	eax, 4
	jae	SHORT $LN2@Allocate@16

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	push	0
	lea	ecx, DWORD PTR $T97801[ebp]
	call	??0bad_alloc@std@@QAE@PBD@Z		; std::bad_alloc::bad_alloc
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	eax, DWORD PTR $T97801[ebp]
	push	eax
	call	__CxxThrowException@8
$LN2@Allocate@16:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 2
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
$LN5@Allocate@16:

; 44   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@PAVSoundNode@Ogre@@@std@@YAPAPAVSoundNode@Ogre@@IPAPAV12@@Z ENDP ; std::_Allocate<Ogre::SoundNode *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$?0PAVRenderableObject@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@PAVRenderableObject@Ogre@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??$?0PAVRenderableObject@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@PAVRenderableObject@Ogre@@@1@@Z PROC ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::RenderableObject *>, COMDAT
; _this$ = ecx

; 128  : 		allocator(const allocator<_Other>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0PAVRenderableObject@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@PAVRenderableObject@Ogre@@@1@@Z ENDP ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::RenderableObject *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Allocate@PAVRenderableObject@Ogre@@@std@@YAPAPAVRenderableObject@Ogre@@IPAPAV12@@Z
_TEXT	SEGMENT
$T97806 = -12						; size = 12
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@PAVRenderableObject@Ogre@@@std@@YAPAPAVRenderableObject@Ogre@@IPAPAV12@@Z PROC ; std::_Allocate<Ogre::RenderableObject *>, COMDAT

; 36   : 	{	// check for integer overflow

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 37   : 	if (_Count <= 0)

	cmp	DWORD PTR __Count$[ebp], 0
	ja	SHORT $LN3@Allocate@17

; 38   : 		_Count = 0;

	mov	DWORD PTR __Count$[ebp], 0
	jmp	SHORT $LN2@Allocate@17
$LN3@Allocate@17:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Count$[ebp]
	cmp	eax, 4
	jae	SHORT $LN2@Allocate@17

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	push	0
	lea	ecx, DWORD PTR $T97806[ebp]
	call	??0bad_alloc@std@@QAE@PBD@Z		; std::bad_alloc::bad_alloc
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	eax, DWORD PTR $T97806[ebp]
	push	eax
	call	__CxxThrowException@8
$LN2@Allocate@17:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 2
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
$LN5@Allocate@17:

; 44   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@PAVRenderableObject@Ogre@@@std@@YAPAPAVRenderableObject@Ogre@@IPAPAV12@@Z ENDP ; std::_Allocate<Ogre::RenderableObject *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$?0PAVLight@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@PAVLight@Ogre@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??$?0PAVLight@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@PAVLight@Ogre@@@1@@Z PROC ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::Light *>, COMDAT
; _this$ = ecx

; 128  : 		allocator(const allocator<_Other>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0PAVLight@Ogre@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@PAVLight@Ogre@@@1@@Z ENDP ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Ogre::Light *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Allocate@PAVLight@Ogre@@@std@@YAPAPAVLight@Ogre@@IPAPAV12@@Z
_TEXT	SEGMENT
$T97811 = -12						; size = 12
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@PAVLight@Ogre@@@std@@YAPAPAVLight@Ogre@@IPAPAV12@@Z PROC ; std::_Allocate<Ogre::Light *>, COMDAT

; 36   : 	{	// check for integer overflow

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 37   : 	if (_Count <= 0)

	cmp	DWORD PTR __Count$[ebp], 0
	ja	SHORT $LN3@Allocate@18

; 38   : 		_Count = 0;

	mov	DWORD PTR __Count$[ebp], 0
	jmp	SHORT $LN2@Allocate@18
$LN3@Allocate@18:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Count$[ebp]
	cmp	eax, 4
	jae	SHORT $LN2@Allocate@18

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	push	0
	lea	ecx, DWORD PTR $T97811[ebp]
	call	??0bad_alloc@std@@QAE@PBD@Z		; std::bad_alloc::bad_alloc
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	eax, DWORD PTR $T97811[ebp]
	push	eax
	call	__CxxThrowException@8
$LN2@Allocate@18:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 2
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
$LN5@Allocate@18:

; 44   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@PAVLight@Ogre@@@std@@YAPAPAVLight@Ogre@@IPAPAV12@@Z ENDP ; std::_Allocate<Ogre::Light *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Allocate@V_Aux_cont@std@@@std@@YAPAV_Aux_cont@0@IPAV10@@Z
_TEXT	SEGMENT
$T97814 = -12						; size = 12
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@V_Aux_cont@std@@@std@@YAPAV_Aux_cont@0@IPAV10@@Z PROC ; std::_Allocate<std::_Aux_cont>, COMDAT

; 36   : 	{	// check for integer overflow

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 37   : 	if (_Count <= 0)

	cmp	DWORD PTR __Count$[ebp], 0
	ja	SHORT $LN3@Allocate@19

; 38   : 		_Count = 0;

	mov	DWORD PTR __Count$[ebp], 0
	jmp	SHORT $LN2@Allocate@19
$LN3@Allocate@19:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Count$[ebp]
	cmp	eax, 4
	jae	SHORT $LN2@Allocate@19

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	push	0
	lea	ecx, DWORD PTR $T97814[ebp]
	call	??0bad_alloc@std@@QAE@PBD@Z		; std::bad_alloc::bad_alloc
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	eax, DWORD PTR $T97814[ebp]
	push	eax
	call	__CxxThrowException@8
$LN2@Allocate@19:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 2
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
$LN5@Allocate@19:

; 44   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@V_Aux_cont@std@@@std@@YAPAV_Aux_cont@0@IPAV10@@Z ENDP ; std::_Allocate<std::_Aux_cont>
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0bad_alloc@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0bad_alloc@std@@QAE@ABV01@@Z$0
__ehfuncinfo$??0bad_alloc@std@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0bad_alloc@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0bad_alloc@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7bad_alloc@std@@6B@
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0bad_alloc@std@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??0bad_alloc@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0bad_alloc@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
PUBLIC	?resize@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAEXIUAnimRange@BaseKeyFrameArray@Ogre@@@Z ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::resize
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?resize@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
$T97826 = -8						; size = 8
__Newsize$ = 8						; size = 4
?resize@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAEXI@Z PROC ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::resize, COMDAT
; _this$ = ecx

; 712  : 		{	// determine new length, padding with _Ty() elements as needed

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 713  : 		resize(_Newsize, _Ty());

	xor	eax, eax
	mov	DWORD PTR $T97826[ebp], eax
	mov	DWORD PTR $T97826[ebp+4], eax
	mov	ecx, DWORD PTR $T97826[ebp+4]
	push	ecx
	mov	edx, DWORD PTR $T97826[ebp]
	push	edx
	mov	eax, DWORD PTR __Newsize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?resize@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAEXIUAnimRange@BaseKeyFrameArray@Ogre@@@Z ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::resize

; 714  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?resize@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAEXI@Z ENDP ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::resize
_TEXT	ENDS
PUBLIC	?resize@?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAEXIUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@Z ; std::vector<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::resize
; Function compile flags: /Odtp
;	COMDAT ?resize@?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
$T97829 = -8						; size = 8
__Newsize$ = 8						; size = 4
?resize@?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAEXI@Z PROC ; std::vector<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::resize, COMDAT
; _this$ = ecx

; 712  : 		{	// determine new length, padding with _Ty() elements as needed

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 713  : 		resize(_Newsize, _Ty());

	xor	eax, eax
	mov	DWORD PTR $T97829[ebp], eax
	mov	DWORD PTR $T97829[ebp+4], eax
	mov	ecx, DWORD PTR $T97829[ebp+4]
	push	ecx
	mov	edx, DWORD PTR $T97829[ebp]
	push	edx
	mov	eax, DWORD PTR __Newsize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?resize@?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAEXIUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@Z ; std::vector<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::resize

; 714  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?resize@?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAEXI@Z ENDP ; std::vector<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::resize
_TEXT	ENDS
PUBLIC	?resize@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAEXIUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@Z ; std::vector<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::resize
; Function compile flags: /Odtp
;	COMDAT ?resize@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
$T97832 = -8						; size = 8
__Newsize$ = 8						; size = 4
?resize@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAEXI@Z PROC ; std::vector<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::resize, COMDAT
; _this$ = ecx

; 712  : 		{	// determine new length, padding with _Ty() elements as needed

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 713  : 		resize(_Newsize, _Ty());

	xor	eax, eax
	mov	DWORD PTR $T97832[ebp], eax
	mov	DWORD PTR $T97832[ebp+4], eax
	mov	ecx, DWORD PTR $T97832[ebp+4]
	push	ecx
	mov	edx, DWORD PTR $T97832[ebp]
	push	edx
	mov	eax, DWORD PTR __Newsize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?resize@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAEXIUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@Z ; std::vector<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::resize

; 714  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?resize@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAEXI@Z ENDP ; std::vector<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::resize
_TEXT	ENDS
PUBLIC	?resize@?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAEXIUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@Z ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::resize
PUBLIC	??0KEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@QAE@XZ ; Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T::KEYFRAME_T
; Function compile flags: /Odtp
;	COMDAT ?resize@?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -24						; size = 4
$T97835 = -20						; size = 20
__Newsize$ = 8						; size = 4
?resize@?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAEXI@Z PROC ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::resize, COMDAT
; _this$ = ecx

; 712  : 		{	// determine new length, padding with _Ty() elements as needed

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 713  : 		resize(_Newsize, _Ty());

	lea	ecx, DWORD PTR $T97835[ebp]
	call	??0KEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@QAE@XZ
	sub	esp, 20					; 00000014H
	mov	ecx, esp
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], edx
	mov	eax, DWORD PTR [eax+16]
	mov	DWORD PTR [ecx+16], eax
	mov	ecx, DWORD PTR __Newsize$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?resize@?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAEXIUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@Z ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::resize

; 714  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?resize@?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAEXI@Z ENDP ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::resize
_TEXT	ENDS
PUBLIC	?resize@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAEXIUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@Z ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::resize
PUBLIC	??0CONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@QAE@XZ ; Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T::CONTROL_POINT_T
; Function compile flags: /Odtp
;	COMDAT ?resize@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -36						; size = 4
$T97838 = -32						; size = 32
__Newsize$ = 8						; size = 4
?resize@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAEXI@Z PROC ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::resize, COMDAT
; _this$ = ecx

; 712  : 		{	// determine new length, padding with _Ty() elements as needed

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 713  : 		resize(_Newsize, _Ty());

	lea	ecx, DWORD PTR $T97838[ebp]
	call	??0CONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@QAE@XZ
	sub	esp, 32					; 00000020H
	mov	ecx, 8
	mov	esi, eax
	mov	edi, esp
	rep movsd
	mov	eax, DWORD PTR __Newsize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?resize@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAEXIUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@Z ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::resize

; 714  : 		}

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?resize@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAEXI@Z ENDP ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::resize
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0KEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0KEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@QAE@XZ PROC ; Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T::KEYFRAME_T, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	fld1
	fstp	DWORD PTR [esp]
	push	ecx
	fld1
	fstp	DWORD PTR [esp]
	push	ecx
	fld1
	fstp	DWORD PTR [esp]
	push	ecx
	fld1
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??0ColourValue@Ogre@@QAE@MMMM@Z		; Ogre::ColourValue::ColourValue
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0KEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@QAE@XZ ENDP ; Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T::KEYFRAME_T
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0CONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@QAE@XZ PROC ; Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T::CONTROL_POINT_T, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	fld1
	fstp	DWORD PTR [esp]
	push	ecx
	fld1
	fstp	DWORD PTR [esp]
	push	ecx
	fld1
	fstp	DWORD PTR [esp]
	push	ecx
	fld1
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0ColourValue@Ogre@@QAE@MMMM@Z		; Ogre::ColourValue::ColourValue
	push	ecx
	fld1
	fstp	DWORD PTR [esp]
	push	ecx
	fld1
	fstp	DWORD PTR [esp]
	push	ecx
	fld1
	fstp	DWORD PTR [esp]
	push	ecx
	fld1
	fstp	DWORD PTR [esp]
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 16					; 00000010H
	call	??0ColourValue@Ogre@@QAE@MMMM@Z		; Ogre::ColourValue::ColourValue
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0CONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@QAE@XZ ENDP ; Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T::CONTROL_POINT_T
_TEXT	ENDS
PUBLIC	??H?$_Vector_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::operator+
PUBLIC	?_Insert_n@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@2@IABUAnimRange@BaseKeyFrameArray@Ogre@@@Z ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::_Insert_n
; Function compile flags: /Odtp
;	COMDAT ?resize@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAEXIUAnimRange@BaseKeyFrameArray@Ogre@@@Z
_TEXT	SEGMENT
_this$ = -68						; size = 4
$T97852 = -64						; size = 8
$T97851 = -56						; size = 8
$T97850 = -48						; size = 8
$T97849 = -40						; size = 8
$T97848 = -32						; size = 8
$T97847 = -24						; size = 8
$T97846 = -16						; size = 8
$T97845 = -8						; size = 8
__Newsize$ = 8						; size = 4
__Val$ = 12						; size = 8
?resize@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAEXIUAnimRange@BaseKeyFrameArray@Ogre@@@Z PROC ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::resize, COMDAT
; _this$ = ecx

; 717  : 		{	// determine new length, padding with _Val elements as needed

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	mov	DWORD PTR _this$[ebp], ecx

; 718  : 		if (size() < _Newsize)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::size
	cmp	eax, DWORD PTR __Newsize$[ebp]
	jae	SHORT $LN3@resize

; 719  : 			_Insert_n(end(), _Newsize - size(), _Val);

	lea	eax, DWORD PTR $T97846[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@2@XZ ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::end
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T97845[ebp], ecx
	mov	DWORD PTR $T97845[ebp+4], edx
	lea	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::size
	mov	ecx, DWORD PTR __Newsize$[ebp]
	sub	ecx, eax
	push	ecx
	mov	edx, DWORD PTR $T97845[ebp+4]
	push	edx
	mov	eax, DWORD PTR $T97845[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert_n@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@2@IABUAnimRange@BaseKeyFrameArray@Ogre@@@Z ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::_Insert_n
	jmp	SHORT $LN4@resize
$LN3@resize:

; 720  : 		else if (_Newsize < size())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::size
	cmp	DWORD PTR __Newsize$[ebp], eax
	jae	SHORT $LN4@resize

; 721  : 			erase(begin() + _Newsize, end());

	lea	ecx, DWORD PTR $T97848[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@2@XZ ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::end
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR $T97847[ebp], edx
	mov	DWORD PTR $T97847[ebp+4], eax
	mov	ecx, DWORD PTR __Newsize$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T97851[ebp]
	push	edx
	lea	eax, DWORD PTR $T97850[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@2@XZ ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::begin
	mov	ecx, eax
	call	??H?$_Vector_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::operator+
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T97849[ebp], ecx
	mov	DWORD PTR $T97849[ebp+4], edx
	mov	eax, DWORD PTR $T97847[ebp+4]
	push	eax
	mov	ecx, DWORD PTR $T97847[ebp]
	push	ecx
	mov	edx, DWORD PTR $T97849[ebp+4]
	push	edx
	mov	eax, DWORD PTR $T97849[ebp]
	push	eax
	lea	ecx, DWORD PTR $T97852[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@2@V?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@2@0@Z ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::erase
$LN4@resize:

; 722  : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?resize@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAEXIUAnimRange@BaseKeyFrameArray@Ogre@@@Z ENDP ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::resize
_TEXT	ENDS
PUBLIC	??H?$_Vector_iterator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::operator+
PUBLIC	?_Insert_n@?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@2@IABUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@Z ; std::vector<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::_Insert_n
; Function compile flags: /Odtp
;	COMDAT ?resize@?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAEXIUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@Z
_TEXT	SEGMENT
_this$ = -68						; size = 4
$T97862 = -64						; size = 8
$T97861 = -56						; size = 8
$T97860 = -48						; size = 8
$T97859 = -40						; size = 8
$T97858 = -32						; size = 8
$T97857 = -24						; size = 8
$T97856 = -16						; size = 8
$T97855 = -8						; size = 8
__Newsize$ = 8						; size = 4
__Val$ = 12						; size = 8
?resize@?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAEXIUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@Z PROC ; std::vector<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::resize, COMDAT
; _this$ = ecx

; 717  : 		{	// determine new length, padding with _Val elements as needed

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	mov	DWORD PTR _this$[ebp], ecx

; 718  : 		if (size() < _Newsize)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::size
	cmp	eax, DWORD PTR __Newsize$[ebp]
	jae	SHORT $LN3@resize@2

; 719  : 			_Insert_n(end(), _Newsize - size(), _Val);

	lea	eax, DWORD PTR $T97856[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@2@XZ ; std::vector<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::end
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T97855[ebp], ecx
	mov	DWORD PTR $T97855[ebp+4], edx
	lea	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::size
	mov	ecx, DWORD PTR __Newsize$[ebp]
	sub	ecx, eax
	push	ecx
	mov	edx, DWORD PTR $T97855[ebp+4]
	push	edx
	mov	eax, DWORD PTR $T97855[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert_n@?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@2@IABUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@Z ; std::vector<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::_Insert_n
	jmp	SHORT $LN4@resize@2
$LN3@resize@2:

; 720  : 		else if (_Newsize < size())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::size
	cmp	DWORD PTR __Newsize$[ebp], eax
	jae	SHORT $LN4@resize@2

; 721  : 			erase(begin() + _Newsize, end());

	lea	ecx, DWORD PTR $T97858[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@2@XZ ; std::vector<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::end
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR $T97857[ebp], edx
	mov	DWORD PTR $T97857[ebp+4], eax
	mov	ecx, DWORD PTR __Newsize$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T97861[ebp]
	push	edx
	lea	eax, DWORD PTR $T97860[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@2@XZ ; std::vector<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::begin
	mov	ecx, eax
	call	??H?$_Vector_iterator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::operator+
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T97859[ebp], ecx
	mov	DWORD PTR $T97859[ebp+4], edx
	mov	eax, DWORD PTR $T97857[ebp+4]
	push	eax
	mov	ecx, DWORD PTR $T97857[ebp]
	push	ecx
	mov	edx, DWORD PTR $T97859[ebp+4]
	push	edx
	mov	eax, DWORD PTR $T97859[ebp]
	push	eax
	lea	ecx, DWORD PTR $T97862[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@2@V?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@2@0@Z ; std::vector<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::erase
$LN4@resize@2:

; 722  : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?resize@?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAEXIUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@Z ENDP ; std::vector<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::resize
_TEXT	ENDS
PUBLIC	??H?$_Vector_iterator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::operator+
PUBLIC	?_Insert_n@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@2@IABUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@Z ; std::vector<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::_Insert_n
; Function compile flags: /Odtp
;	COMDAT ?resize@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAEXIUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@Z
_TEXT	SEGMENT
_this$ = -68						; size = 4
$T97872 = -64						; size = 8
$T97871 = -56						; size = 8
$T97870 = -48						; size = 8
$T97869 = -40						; size = 8
$T97868 = -32						; size = 8
$T97867 = -24						; size = 8
$T97866 = -16						; size = 8
$T97865 = -8						; size = 8
__Newsize$ = 8						; size = 4
__Val$ = 12						; size = 8
?resize@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAEXIUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@Z PROC ; std::vector<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::resize, COMDAT
; _this$ = ecx

; 717  : 		{	// determine new length, padding with _Val elements as needed

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	mov	DWORD PTR _this$[ebp], ecx

; 718  : 		if (size() < _Newsize)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::size
	cmp	eax, DWORD PTR __Newsize$[ebp]
	jae	SHORT $LN3@resize@3

; 719  : 			_Insert_n(end(), _Newsize - size(), _Val);

	lea	eax, DWORD PTR $T97866[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@2@XZ ; std::vector<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::end
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T97865[ebp], ecx
	mov	DWORD PTR $T97865[ebp+4], edx
	lea	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::size
	mov	ecx, DWORD PTR __Newsize$[ebp]
	sub	ecx, eax
	push	ecx
	mov	edx, DWORD PTR $T97865[ebp+4]
	push	edx
	mov	eax, DWORD PTR $T97865[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert_n@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@2@IABUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@Z ; std::vector<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::_Insert_n
	jmp	SHORT $LN4@resize@3
$LN3@resize@3:

; 720  : 		else if (_Newsize < size())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::size
	cmp	DWORD PTR __Newsize$[ebp], eax
	jae	SHORT $LN4@resize@3

; 721  : 			erase(begin() + _Newsize, end());

	lea	ecx, DWORD PTR $T97868[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@2@XZ ; std::vector<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::end
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR $T97867[ebp], edx
	mov	DWORD PTR $T97867[ebp+4], eax
	mov	ecx, DWORD PTR __Newsize$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T97871[ebp]
	push	edx
	lea	eax, DWORD PTR $T97870[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@2@XZ ; std::vector<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::begin
	mov	ecx, eax
	call	??H?$_Vector_iterator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::operator+
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T97869[ebp], ecx
	mov	DWORD PTR $T97869[ebp+4], edx
	mov	eax, DWORD PTR $T97867[ebp+4]
	push	eax
	mov	ecx, DWORD PTR $T97867[ebp]
	push	ecx
	mov	edx, DWORD PTR $T97869[ebp+4]
	push	edx
	mov	eax, DWORD PTR $T97869[ebp]
	push	eax
	lea	ecx, DWORD PTR $T97872[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@2@V?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@2@0@Z ; std::vector<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::erase
$LN4@resize@3:

; 722  : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?resize@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAEXIUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@Z ENDP ; std::vector<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::resize
_TEXT	ENDS
PUBLIC	??H?$_Vector_iterator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::operator+
PUBLIC	?_Insert_n@?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@2@IABUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@Z ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::_Insert_n
; Function compile flags: /Odtp
;	COMDAT ?resize@?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAEXIUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@Z
_TEXT	SEGMENT
_this$ = -68						; size = 4
$T97882 = -64						; size = 8
$T97881 = -56						; size = 8
$T97880 = -48						; size = 8
$T97879 = -40						; size = 8
$T97878 = -32						; size = 8
$T97877 = -24						; size = 8
$T97876 = -16						; size = 8
$T97875 = -8						; size = 8
__Newsize$ = 8						; size = 4
__Val$ = 12						; size = 20
?resize@?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAEXIUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@Z PROC ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::resize, COMDAT
; _this$ = ecx

; 717  : 		{	// determine new length, padding with _Val elements as needed

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	mov	DWORD PTR _this$[ebp], ecx

; 718  : 		if (size() < _Newsize)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::size
	cmp	eax, DWORD PTR __Newsize$[ebp]
	jae	SHORT $LN3@resize@4

; 719  : 			_Insert_n(end(), _Newsize - size(), _Val);

	lea	eax, DWORD PTR $T97876[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@2@XZ ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::end
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T97875[ebp], ecx
	mov	DWORD PTR $T97875[ebp+4], edx
	lea	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::size
	mov	ecx, DWORD PTR __Newsize$[ebp]
	sub	ecx, eax
	push	ecx
	mov	edx, DWORD PTR $T97875[ebp+4]
	push	edx
	mov	eax, DWORD PTR $T97875[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert_n@?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@2@IABUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@Z ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::_Insert_n
	jmp	SHORT $LN4@resize@4
$LN3@resize@4:

; 720  : 		else if (_Newsize < size())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::size
	cmp	DWORD PTR __Newsize$[ebp], eax
	jae	SHORT $LN4@resize@4

; 721  : 			erase(begin() + _Newsize, end());

	lea	ecx, DWORD PTR $T97878[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@2@XZ ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::end
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR $T97877[ebp], edx
	mov	DWORD PTR $T97877[ebp+4], eax
	mov	ecx, DWORD PTR __Newsize$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T97881[ebp]
	push	edx
	lea	eax, DWORD PTR $T97880[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@2@XZ ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::begin
	mov	ecx, eax
	call	??H?$_Vector_iterator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::operator+
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T97879[ebp], ecx
	mov	DWORD PTR $T97879[ebp+4], edx
	mov	eax, DWORD PTR $T97877[ebp+4]
	push	eax
	mov	ecx, DWORD PTR $T97877[ebp]
	push	ecx
	mov	edx, DWORD PTR $T97879[ebp+4]
	push	edx
	mov	eax, DWORD PTR $T97879[ebp]
	push	eax
	lea	ecx, DWORD PTR $T97882[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@2@V?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@2@0@Z ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::erase
$LN4@resize@4:

; 722  : 		}

	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
?resize@?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAEXIUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@Z ENDP ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::resize
_TEXT	ENDS
PUBLIC	??H?$_Vector_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::operator+
PUBLIC	?_Insert_n@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@2@IABUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@Z ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::_Insert_n
; Function compile flags: /Odtp
;	COMDAT ?resize@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAEXIUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@Z
_TEXT	SEGMENT
_this$ = -68						; size = 4
$T97892 = -64						; size = 8
$T97891 = -56						; size = 8
$T97890 = -48						; size = 8
$T97889 = -40						; size = 8
$T97888 = -32						; size = 8
$T97887 = -24						; size = 8
$T97886 = -16						; size = 8
$T97885 = -8						; size = 8
__Newsize$ = 8						; size = 4
__Val$ = 12						; size = 32
?resize@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAEXIUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@Z PROC ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::resize, COMDAT
; _this$ = ecx

; 717  : 		{	// determine new length, padding with _Val elements as needed

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	mov	DWORD PTR _this$[ebp], ecx

; 718  : 		if (size() < _Newsize)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::size
	cmp	eax, DWORD PTR __Newsize$[ebp]
	jae	SHORT $LN3@resize@5

; 719  : 			_Insert_n(end(), _Newsize - size(), _Val);

	lea	eax, DWORD PTR $T97886[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@2@XZ ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::end
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T97885[ebp], ecx
	mov	DWORD PTR $T97885[ebp+4], edx
	lea	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::size
	mov	ecx, DWORD PTR __Newsize$[ebp]
	sub	ecx, eax
	push	ecx
	mov	edx, DWORD PTR $T97885[ebp+4]
	push	edx
	mov	eax, DWORD PTR $T97885[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert_n@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@2@IABUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@Z ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::_Insert_n
	jmp	SHORT $LN4@resize@5
$LN3@resize@5:

; 720  : 		else if (_Newsize < size())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::size
	cmp	DWORD PTR __Newsize$[ebp], eax
	jae	SHORT $LN4@resize@5

; 721  : 			erase(begin() + _Newsize, end());

	lea	ecx, DWORD PTR $T97888[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@2@XZ ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::end
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR $T97887[ebp], edx
	mov	DWORD PTR $T97887[ebp+4], eax
	mov	ecx, DWORD PTR __Newsize$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T97891[ebp]
	push	edx
	lea	eax, DWORD PTR $T97890[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@2@XZ ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::begin
	mov	ecx, eax
	call	??H?$_Vector_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::operator+
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T97889[ebp], ecx
	mov	DWORD PTR $T97889[ebp+4], edx
	mov	eax, DWORD PTR $T97887[ebp+4]
	push	eax
	mov	ecx, DWORD PTR $T97887[ebp]
	push	ecx
	mov	edx, DWORD PTR $T97889[ebp+4]
	push	edx
	mov	eax, DWORD PTR $T97889[ebp]
	push	eax
	lea	ecx, DWORD PTR $T97892[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAE?AV?$_Vector_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@2@V?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@2@0@Z ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::erase
$LN4@resize@5:

; 722  : 		}

	mov	esp, ebp
	pop	ebp
	ret	36					; 00000024H
?resize@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAEXIUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@Z ENDP ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::resize
_TEXT	ENDS
PUBLIC	??$_Unchecked_move_backward@PAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@@stdext@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@00@Z ; stdext::_Unchecked_move_backward<Ogre::BaseKeyFrameArray::AnimRange *,Ogre::BaseKeyFrameArray::AnimRange *>
PUBLIC	??$fill@PAUAnimRange@BaseKeyFrameArray@Ogre@@U123@@std@@YAXPAUAnimRange@BaseKeyFrameArray@Ogre@@0ABU123@@Z ; std::fill<Ogre::BaseKeyFrameArray::AnimRange *,Ogre::BaseKeyFrameArray::AnimRange>
PUBLIC	??$_Umove@PAUAnimRange@BaseKeyFrameArray@Ogre@@@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAEPAUAnimRange@BaseKeyFrameArray@Ogre@@PAU234@00@Z ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::_Umove<Ogre::BaseKeyFrameArray::AnimRange *>
PUBLIC	?_Ufill@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAEPAUAnimRange@BaseKeyFrameArray@Ogre@@PAU345@IABU345@@Z ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::_Ufill
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Insert_n@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@2@IABUAnimRange@BaseKeyFrameArray@Ogre@@@Z$5 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@2@IABUAnimRange@BaseKeyFrameArray@Ogre@@@Z$2
__catchsym$?_Insert_n@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@2@IABUAnimRange@BaseKeyFrameArray@Ogre@@@Z$4 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@2@IABUAnimRange@BaseKeyFrameArray@Ogre@@@Z$0
__unwindtable$?_Insert_n@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@2@IABUAnimRange@BaseKeyFrameArray@Ogre@@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$?_Insert_n@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@2@IABUAnimRange@BaseKeyFrameArray@Ogre@@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Insert_n@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@2@IABUAnimRange@BaseKeyFrameArray@Ogre@@@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Insert_n@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@2@IABUAnimRange@BaseKeyFrameArray@Ogre@@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__tryblocktable$?_Insert_n@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@2@IABUAnimRange@BaseKeyFrameArray@Ogre@@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@2@IABUAnimRange@BaseKeyFrameArray@Ogre@@@Z$4
	DD	02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@2@IABUAnimRange@BaseKeyFrameArray@Ogre@@@Z$5
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?_Insert_n@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@2@IABUAnimRange@BaseKeyFrameArray@Ogre@@@Z
_TEXT	SEGMENT
tv84 = -60						; size = 4
_this$ = -56						; size = 4
__Tmp$83437 = -52					; size = 8
__Oldend$83438 = -44					; size = 4
__Tmp$83427 = -40					; size = 8
__Ncopied$83414 = -32					; size = 4
__Newvec$83412 = -28					; size = 4
__Whereoff$83413 = -24					; size = 4
__Capacity$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Where$ = 8						; size = 8
__Count$ = 16						; size = 4
__Val$ = 20						; size = 4
?_Insert_n@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@2@IABUAnimRange@BaseKeyFrameArray@Ogre@@@Z PROC ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::_Insert_n, COMDAT
; _this$ = ecx

; 1153 : 		{	// insert _Count * _Val at _Where

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Insert_n@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@2@IABUAnimRange@BaseKeyFrameArray@Ogre@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 44					; 0000002cH
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1154 : 
; 1155 :  #if _HAS_ITERATOR_DEBUGGING
; 1156 : 		if (_Where._Mycont != this
; 1157 : 			|| _Where._Myptr < _Myfirst || _Mylast < _Where._Myptr)
; 1158 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1159 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1160 : 
; 1161 : 		size_type _Capacity = capacity();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?capacity@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::capacity
	mov	DWORD PTR __Capacity$[ebp], eax

; 1162 : 
; 1163 : 		if (_Count == 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN14@Insert_n
	jmp	$LN16@Insert_n
$LN14@Insert_n:

; 1164 : 			;
; 1165 : 		else if (max_size() - size() < _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::max_size
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::size
	sub	esi, eax
	cmp	esi, DWORD PTR __Count$[ebp]
	jae	SHORT $LN12@Insert_n

; 1166 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@KAXXZ ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::_Xlen
	jmp	$LN16@Insert_n
$LN12@Insert_n:

; 1167 : 		else if (_Capacity < size() + _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::size
	add	eax, DWORD PTR __Count$[ebp]
	cmp	DWORD PTR __Capacity$[ebp], eax
	jae	$LN10@Insert_n

; 1168 : 			{	// not enough room, reallocate
; 1169 : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1170 : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::max_size
	mov	ecx, DWORD PTR __Capacity$[ebp]
	shr	ecx, 1
	sub	eax, ecx
	cmp	eax, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN17@Insert_n
	mov	DWORD PTR tv84[ebp], 0
	jmp	SHORT $LN18@Insert_n
$LN17@Insert_n:
	mov	edx, DWORD PTR __Capacity$[ebp]
	shr	edx, 1
	add	edx, DWORD PTR __Capacity$[ebp]
	mov	DWORD PTR tv84[ebp], edx
$LN18@Insert_n:
	mov	eax, DWORD PTR tv84[ebp]
	mov	DWORD PTR __Capacity$[ebp], eax

; 1171 : 			if (_Capacity < size() + _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::size
	add	eax, DWORD PTR __Count$[ebp]
	cmp	DWORD PTR __Capacity$[ebp], eax
	jae	SHORT $LN9@Insert_n

; 1172 : 				_Capacity = size() + _Count;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::size
	add	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Capacity$[ebp], eax
$LN9@Insert_n:

; 1173 : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

	mov	ecx, DWORD PTR __Capacity$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?allocate@?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@QAEPAUAnimRange@BaseKeyFrameArray@Ogre@@I@Z ; std::allocator<Ogre::BaseKeyFrameArray::AnimRange>::allocate
	mov	DWORD PTR __Newvec$83412[ebp], eax

; 1174 : 			size_type _Whereoff = _VEC_ITER_BASE(_Where) - _Myfirst;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Where$[ebp+4]
	sub	eax, DWORD PTR [edx+12]
	sar	eax, 3
	mov	DWORD PTR __Whereoff$83413[ebp], eax

; 1175 : 			int _Ncopied = 0;

	mov	DWORD PTR __Ncopied$83414[ebp], 0

; 1176 : 
; 1177 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1178 : 			_Ufill(_Newvec + _Whereoff, _Count, _Val);	// add new stuff

	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __Whereoff$83413[ebp]
	mov	ecx, DWORD PTR __Newvec$83412[ebp]
	lea	edx, DWORD PTR [ecx+eax*8]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Ufill@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAEPAUAnimRange@BaseKeyFrameArray@Ogre@@PAU345@IABU345@@Z ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::_Ufill

; 1179 : 			++_Ncopied;

	mov	eax, DWORD PTR __Ncopied$83414[ebp]
	add	eax, 1
	mov	DWORD PTR __Ncopied$83414[ebp], eax

; 1180 : 			_Umove(this->_Myfirst, _VEC_ITER_BASE(_Where),
; 1181 : 				_Newvec);	// move prefix

	mov	ecx, DWORD PTR __Newvec$83412[ebp]
	push	ecx
	mov	edx, DWORD PTR __Where$[ebp+4]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Umove@PAUAnimRange@BaseKeyFrameArray@Ogre@@@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAEPAUAnimRange@BaseKeyFrameArray@Ogre@@PAU234@00@Z ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::_Umove<Ogre::BaseKeyFrameArray::AnimRange *>

; 1182 : 			++_Ncopied;

	mov	edx, DWORD PTR __Ncopied$83414[ebp]
	add	edx, 1
	mov	DWORD PTR __Ncopied$83414[ebp], edx

; 1183 : 			_Umove(_VEC_ITER_BASE(_Where), this->_Mylast,
; 1184 : 				_Newvec + (_Whereoff + _Count));	// move suffix

	mov	eax, DWORD PTR __Whereoff$83413[ebp]
	add	eax, DWORD PTR __Count$[ebp]
	mov	ecx, DWORD PTR __Newvec$83412[ebp]
	lea	edx, DWORD PTR [ecx+eax*8]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Where$[ebp+4]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Umove@PAUAnimRange@BaseKeyFrameArray@Ogre@@@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAEPAUAnimRange@BaseKeyFrameArray@Ogre@@PAU234@00@Z ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::_Umove<Ogre::BaseKeyFrameArray::AnimRange *>
	jmp	SHORT $LN19@Insert_n
__catch$?_Insert_n@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@2@IABUAnimRange@BaseKeyFrameArray@Ogre@@@Z$0:

; 1185 : 			_CATCH_ALL
; 1186 : 			if (1 < _Ncopied)

	cmp	DWORD PTR __Ncopied$83414[ebp], 1
	jle	SHORT $LN7@Insert_n

; 1187 : 				_Destroy(_Newvec, _Newvec + _Whereoff);

	mov	eax, DWORD PTR __Whereoff$83413[ebp]
	mov	ecx, DWORD PTR __Newvec$83412[ebp]
	lea	edx, DWORD PTR [ecx+eax*8]
	push	edx
	mov	eax, DWORD PTR __Newvec$83412[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAEXPAUAnimRange@BaseKeyFrameArray@Ogre@@0@Z ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::_Destroy
$LN7@Insert_n:

; 1188 : 			if (0 < _Ncopied)

	cmp	DWORD PTR __Ncopied$83414[ebp], 0
	jle	SHORT $LN6@Insert_n

; 1189 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);

	mov	ecx, DWORD PTR __Whereoff$83413[ebp]
	mov	edx, DWORD PTR __Newvec$83412[ebp]
	lea	eax, DWORD PTR [edx+ecx*8]
	mov	ecx, DWORD PTR __Count$[ebp]
	lea	edx, DWORD PTR [eax+ecx*8]
	push	edx
	mov	eax, DWORD PTR __Whereoff$83413[ebp]
	mov	ecx, DWORD PTR __Newvec$83412[ebp]
	lea	edx, DWORD PTR [ecx+eax*8]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAEXPAUAnimRange@BaseKeyFrameArray@Ogre@@0@Z ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::_Destroy
$LN6@Insert_n:

; 1190 : 			this->_Alval.deallocate(_Newvec, _Capacity);

	mov	eax, DWORD PTR __Capacity$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Newvec$83412[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?deallocate@?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@QAEXPAUAnimRange@BaseKeyFrameArray@Ogre@@I@Z ; std::allocator<Ogre::BaseKeyFrameArray::AnimRange>::deallocate

; 1191 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1192 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$?_Insert_n@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@2@IABUAnimRange@BaseKeyFrameArray@Ogre@@@Z$1
	ret	0
$LN19@Insert_n:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Insert_n@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@2@IABUAnimRange@BaseKeyFrameArray@Ogre@@@Z$1:

; 1193 : 
; 1194 : 			_Count += size();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::size
	add	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Count$[ebp], eax

; 1195 : 			if (_Myfirst != 0)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+12], 0
	je	SHORT $LN5@Insert_n

; 1196 : 				{	// destroy and deallocate old array
; 1197 : 				_Destroy(_Myfirst, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAEXPAUAnimRange@BaseKeyFrameArray@Ogre@@0@Z ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::_Destroy

; 1198 : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+20]
	sub	eax, DWORD PTR [edx+12]
	sar	eax, 3
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?deallocate@?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@QAEXPAUAnimRange@BaseKeyFrameArray@Ogre@@I@Z ; std::allocator<Ogre::BaseKeyFrameArray::AnimRange>::deallocate
$LN5@Insert_n:

; 1199 : 				}
; 1200 : 
; 1201 :  #if _HAS_ITERATOR_DEBUGGING
; 1202 : 			this->_Orphan_all();
; 1203 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1204 : 
; 1205 : 			_Myend = _Newvec + _Capacity;

	mov	eax, DWORD PTR __Capacity$[ebp]
	mov	ecx, DWORD PTR __Newvec$83412[ebp]
	lea	edx, DWORD PTR [ecx+eax*8]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], edx

; 1206 : 			_Mylast = _Newvec + _Count;

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Newvec$83412[ebp]
	lea	eax, DWORD PTR [edx+ecx*8]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 1207 : 			_Myfirst = _Newvec;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Newvec$83412[ebp]
	mov	DWORD PTR [edx+12], eax
	jmp	$LN16@Insert_n
$LN10@Insert_n:

; 1208 : 			}
; 1209 : 		else if ((size_type)(_Mylast - _VEC_ITER_BASE(_Where)) < _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	sub	edx, DWORD PTR __Where$[ebp+4]
	sar	edx, 3
	cmp	edx, DWORD PTR __Count$[ebp]
	jae	$LN3@Insert_n

; 1210 : 			{	// new stuff spills off end
; 1211 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR __Tmp$83427[ebp], ecx
	mov	DWORD PTR __Tmp$83427[ebp+4], edx

; 1212 : 
; 1213 : 			_Umove(_VEC_ITER_BASE(_Where), _Mylast,
; 1214 : 				_VEC_ITER_BASE(_Where) + _Count);	// copy suffix

	mov	eax, DWORD PTR __Count$[ebp]
	mov	ecx, DWORD PTR __Where$[ebp+4]
	lea	edx, DWORD PTR [ecx+eax*8]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Where$[ebp+4]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Umove@PAUAnimRange@BaseKeyFrameArray@Ogre@@@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAEPAUAnimRange@BaseKeyFrameArray@Ogre@@PAU234@00@Z ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::_Umove<Ogre::BaseKeyFrameArray::AnimRange *>

; 1215 : 
; 1216 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 2

; 1217 : 			_Ufill(_Mylast, _Count - (_Mylast - _VEC_ITER_BASE(_Where)),
; 1218 : 				_Tmp);	// insert new stuff off end

	lea	eax, DWORD PTR __Tmp$83427[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	sub	edx, DWORD PTR __Where$[ebp+4]
	sar	edx, 3
	mov	eax, DWORD PTR __Count$[ebp]
	sub	eax, edx
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Ufill@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAEPAUAnimRange@BaseKeyFrameArray@Ogre@@PAU345@IABU345@@Z ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::_Ufill
	jmp	SHORT $LN21@Insert_n
__catch$?_Insert_n@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@2@IABUAnimRange@BaseKeyFrameArray@Ogre@@@Z$2:

; 1219 : 			_CATCH_ALL
; 1220 : 			_Destroy(_VEC_ITER_BASE(_Where) + _Count, _Mylast + _Count);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR __Count$[ebp]
	lea	eax, DWORD PTR [ecx+edx*8]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Where$[ebp+4]
	lea	eax, DWORD PTR [edx+ecx*8]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAEXPAUAnimRange@BaseKeyFrameArray@Ogre@@0@Z ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::_Destroy

; 1221 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1222 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$?_Insert_n@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@2@IABUAnimRange@BaseKeyFrameArray@Ogre@@@Z$3
	ret	0
$LN21@Insert_n:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Insert_n@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@2@IABUAnimRange@BaseKeyFrameArray@Ogre@@@Z$3:

; 1223 : 
; 1224 : 			_Mylast += _Count;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR __Count$[ebp]
	lea	ecx, DWORD PTR [edx+eax*8]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+16], ecx

; 1225 : 
; 1226 :  #if _HAS_ITERATOR_DEBUGGING
; 1227 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1228 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1229 : 
; 1230 : 			std::fill(_VEC_ITER_BASE(_Where), _Mylast - _Count,
; 1231 : 				_Tmp);	// insert up to old end

	lea	eax, DWORD PTR __Tmp$83427[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 3
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	sub	eax, ecx
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp+4]
	push	ecx
	call	??$fill@PAUAnimRange@BaseKeyFrameArray@Ogre@@U123@@std@@YAXPAUAnimRange@BaseKeyFrameArray@Ogre@@0ABU123@@Z ; std::fill<Ogre::BaseKeyFrameArray::AnimRange *,Ogre::BaseKeyFrameArray::AnimRange>
	add	esp, 12					; 0000000cH

; 1232 : 			}
; 1233 : 		else

	jmp	SHORT $LN16@Insert_n
$LN3@Insert_n:

; 1234 : 			{	// new stuff can all be assigned
; 1235 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	edx, DWORD PTR __Val$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR __Tmp$83437[ebp], eax
	mov	DWORD PTR __Tmp$83437[ebp+4], ecx

; 1236 : 
; 1237 : 			pointer _Oldend = _Mylast;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR __Oldend$83438[ebp], eax

; 1238 : 			_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1239 : 				_Mylast);	// copy suffix

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR __Oldend$83438[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 3
	mov	edx, DWORD PTR __Oldend$83438[ebp]
	sub	edx, ecx
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Umove@PAUAnimRange@BaseKeyFrameArray@Ogre@@@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAEPAUAnimRange@BaseKeyFrameArray@Ogre@@PAU234@00@Z ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::_Umove<Ogre::BaseKeyFrameArray::AnimRange *>
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 1240 : 
; 1241 :  #if _HAS_ITERATOR_DEBUGGING
; 1242 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1243 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1244 : 
; 1245 : 			_STDEXT _Unchecked_move_backward(_VEC_ITER_BASE(_Where), _Oldend - _Count,
; 1246 : 				_Oldend);	// copy hole

	mov	edx, DWORD PTR __Oldend$83438[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 3
	mov	ecx, DWORD PTR __Oldend$83438[ebp]
	sub	ecx, eax
	push	ecx
	mov	edx, DWORD PTR __Where$[ebp+4]
	push	edx
	call	??$_Unchecked_move_backward@PAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@@stdext@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@00@Z ; stdext::_Unchecked_move_backward<Ogre::BaseKeyFrameArray::AnimRange *,Ogre::BaseKeyFrameArray::AnimRange *>
	add	esp, 12					; 0000000cH

; 1247 : 			std::fill(_VEC_ITER_BASE(_Where), _VEC_ITER_BASE(_Where) + _Count,
; 1248 : 				_Tmp);	// insert into hole

	lea	eax, DWORD PTR __Tmp$83437[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Where$[ebp+4]
	lea	eax, DWORD PTR [edx+ecx*8]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp+4]
	push	ecx
	call	??$fill@PAUAnimRange@BaseKeyFrameArray@Ogre@@U123@@std@@YAXPAUAnimRange@BaseKeyFrameArray@Ogre@@0ABU123@@Z ; std::fill<Ogre::BaseKeyFrameArray::AnimRange *,Ogre::BaseKeyFrameArray::AnimRange>
	add	esp, 12					; 0000000cH
$LN16@Insert_n:

; 1249 : 			}
; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Insert_n@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@2@IABUAnimRange@BaseKeyFrameArray@Ogre@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-64]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Insert_n@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@2@IABUAnimRange@BaseKeyFrameArray@Ogre@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Insert_n@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@2@IABUAnimRange@BaseKeyFrameArray@Ogre@@@Z ENDP ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::_Insert_n
PUBLIC	??$_Unchecked_move_backward@PAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU123@@stdext@@YAPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU123@00@Z ; stdext::_Unchecked_move_backward<Ogre::KeyFrameArray<float>::KEYFRAME_T *,Ogre::KeyFrameArray<float>::KEYFRAME_T *>
PUBLIC	??$fill@PAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@U123@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@0ABU123@@Z ; std::fill<Ogre::KeyFrameArray<float>::KEYFRAME_T *,Ogre::KeyFrameArray<float>::KEYFRAME_T>
PUBLIC	??$_Umove@PAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAEPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU234@00@Z ; std::vector<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::_Umove<Ogre::KeyFrameArray<float>::KEYFRAME_T *>
PUBLIC	?_Ufill@?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAEPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU345@IABU345@@Z ; std::vector<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::_Ufill
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Insert_n@?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@2@IABUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@Z$5 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@2@IABUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@Z$2
__catchsym$?_Insert_n@?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@2@IABUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@Z$4 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@2@IABUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@Z$0
__unwindtable$?_Insert_n@?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@2@IABUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$?_Insert_n@?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@2@IABUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Insert_n@?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@2@IABUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Insert_n@?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@2@IABUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__tryblocktable$?_Insert_n@?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@2@IABUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@2@IABUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@Z$4
	DD	02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@2@IABUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@Z$5
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?_Insert_n@?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@2@IABUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@Z
_TEXT	SEGMENT
tv84 = -60						; size = 4
_this$ = -56						; size = 4
__Tmp$83480 = -52					; size = 8
__Oldend$83481 = -44					; size = 4
__Tmp$83470 = -40					; size = 8
__Ncopied$83457 = -32					; size = 4
__Newvec$83455 = -28					; size = 4
__Whereoff$83456 = -24					; size = 4
__Capacity$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Where$ = 8						; size = 8
__Count$ = 16						; size = 4
__Val$ = 20						; size = 4
?_Insert_n@?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@2@IABUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@Z PROC ; std::vector<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::_Insert_n, COMDAT
; _this$ = ecx

; 1153 : 		{	// insert _Count * _Val at _Where

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Insert_n@?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@2@IABUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 44					; 0000002cH
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1154 : 
; 1155 :  #if _HAS_ITERATOR_DEBUGGING
; 1156 : 		if (_Where._Mycont != this
; 1157 : 			|| _Where._Myptr < _Myfirst || _Mylast < _Where._Myptr)
; 1158 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1159 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1160 : 
; 1161 : 		size_type _Capacity = capacity();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?capacity@?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::capacity
	mov	DWORD PTR __Capacity$[ebp], eax

; 1162 : 
; 1163 : 		if (_Count == 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN14@Insert_n@2
	jmp	$LN16@Insert_n@2
$LN14@Insert_n@2:

; 1164 : 			;
; 1165 : 		else if (max_size() - size() < _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::max_size
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::size
	sub	esi, eax
	cmp	esi, DWORD PTR __Count$[ebp]
	jae	SHORT $LN12@Insert_n@2

; 1166 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@KAXXZ ; std::vector<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::_Xlen
	jmp	$LN16@Insert_n@2
$LN12@Insert_n@2:

; 1167 : 		else if (_Capacity < size() + _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::size
	add	eax, DWORD PTR __Count$[ebp]
	cmp	DWORD PTR __Capacity$[ebp], eax
	jae	$LN10@Insert_n@2

; 1168 : 			{	// not enough room, reallocate
; 1169 : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1170 : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::max_size
	mov	ecx, DWORD PTR __Capacity$[ebp]
	shr	ecx, 1
	sub	eax, ecx
	cmp	eax, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN17@Insert_n@2
	mov	DWORD PTR tv84[ebp], 0
	jmp	SHORT $LN18@Insert_n@2
$LN17@Insert_n@2:
	mov	edx, DWORD PTR __Capacity$[ebp]
	shr	edx, 1
	add	edx, DWORD PTR __Capacity$[ebp]
	mov	DWORD PTR tv84[ebp], edx
$LN18@Insert_n@2:
	mov	eax, DWORD PTR tv84[ebp]
	mov	DWORD PTR __Capacity$[ebp], eax

; 1171 : 			if (_Capacity < size() + _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::size
	add	eax, DWORD PTR __Count$[ebp]
	cmp	DWORD PTR __Capacity$[ebp], eax
	jae	SHORT $LN9@Insert_n@2

; 1172 : 				_Capacity = size() + _Count;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::size
	add	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Capacity$[ebp], eax
$LN9@Insert_n@2:

; 1173 : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

	mov	ecx, DWORD PTR __Capacity$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?allocate@?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@QAEPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@I@Z ; std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T>::allocate
	mov	DWORD PTR __Newvec$83455[ebp], eax

; 1174 : 			size_type _Whereoff = _VEC_ITER_BASE(_Where) - _Myfirst;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Where$[ebp+4]
	sub	eax, DWORD PTR [edx+12]
	sar	eax, 3
	mov	DWORD PTR __Whereoff$83456[ebp], eax

; 1175 : 			int _Ncopied = 0;

	mov	DWORD PTR __Ncopied$83457[ebp], 0

; 1176 : 
; 1177 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1178 : 			_Ufill(_Newvec + _Whereoff, _Count, _Val);	// add new stuff

	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __Whereoff$83456[ebp]
	mov	ecx, DWORD PTR __Newvec$83455[ebp]
	lea	edx, DWORD PTR [ecx+eax*8]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Ufill@?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAEPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU345@IABU345@@Z ; std::vector<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::_Ufill

; 1179 : 			++_Ncopied;

	mov	eax, DWORD PTR __Ncopied$83457[ebp]
	add	eax, 1
	mov	DWORD PTR __Ncopied$83457[ebp], eax

; 1180 : 			_Umove(this->_Myfirst, _VEC_ITER_BASE(_Where),
; 1181 : 				_Newvec);	// move prefix

	mov	ecx, DWORD PTR __Newvec$83455[ebp]
	push	ecx
	mov	edx, DWORD PTR __Where$[ebp+4]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Umove@PAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAEPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU234@00@Z ; std::vector<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::_Umove<Ogre::KeyFrameArray<float>::KEYFRAME_T *>

; 1182 : 			++_Ncopied;

	mov	edx, DWORD PTR __Ncopied$83457[ebp]
	add	edx, 1
	mov	DWORD PTR __Ncopied$83457[ebp], edx

; 1183 : 			_Umove(_VEC_ITER_BASE(_Where), this->_Mylast,
; 1184 : 				_Newvec + (_Whereoff + _Count));	// move suffix

	mov	eax, DWORD PTR __Whereoff$83456[ebp]
	add	eax, DWORD PTR __Count$[ebp]
	mov	ecx, DWORD PTR __Newvec$83455[ebp]
	lea	edx, DWORD PTR [ecx+eax*8]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Where$[ebp+4]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Umove@PAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAEPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU234@00@Z ; std::vector<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::_Umove<Ogre::KeyFrameArray<float>::KEYFRAME_T *>
	jmp	SHORT $LN19@Insert_n@2
__catch$?_Insert_n@?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@2@IABUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@Z$0:

; 1185 : 			_CATCH_ALL
; 1186 : 			if (1 < _Ncopied)

	cmp	DWORD PTR __Ncopied$83457[ebp], 1
	jle	SHORT $LN7@Insert_n@2

; 1187 : 				_Destroy(_Newvec, _Newvec + _Whereoff);

	mov	eax, DWORD PTR __Whereoff$83456[ebp]
	mov	ecx, DWORD PTR __Newvec$83455[ebp]
	lea	edx, DWORD PTR [ecx+eax*8]
	push	edx
	mov	eax, DWORD PTR __Newvec$83455[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAEXPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@0@Z ; std::vector<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::_Destroy
$LN7@Insert_n@2:

; 1188 : 			if (0 < _Ncopied)

	cmp	DWORD PTR __Ncopied$83457[ebp], 0
	jle	SHORT $LN6@Insert_n@2

; 1189 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);

	mov	ecx, DWORD PTR __Whereoff$83456[ebp]
	mov	edx, DWORD PTR __Newvec$83455[ebp]
	lea	eax, DWORD PTR [edx+ecx*8]
	mov	ecx, DWORD PTR __Count$[ebp]
	lea	edx, DWORD PTR [eax+ecx*8]
	push	edx
	mov	eax, DWORD PTR __Whereoff$83456[ebp]
	mov	ecx, DWORD PTR __Newvec$83455[ebp]
	lea	edx, DWORD PTR [ecx+eax*8]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAEXPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@0@Z ; std::vector<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::_Destroy
$LN6@Insert_n@2:

; 1190 : 			this->_Alval.deallocate(_Newvec, _Capacity);

	mov	eax, DWORD PTR __Capacity$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Newvec$83455[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?deallocate@?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@QAEXPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@I@Z ; std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T>::deallocate

; 1191 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1192 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$?_Insert_n@?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@2@IABUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@Z$1
	ret	0
$LN19@Insert_n@2:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Insert_n@?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@2@IABUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@Z$1:

; 1193 : 
; 1194 : 			_Count += size();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::size
	add	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Count$[ebp], eax

; 1195 : 			if (_Myfirst != 0)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+12], 0
	je	SHORT $LN5@Insert_n@2

; 1196 : 				{	// destroy and deallocate old array
; 1197 : 				_Destroy(_Myfirst, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAEXPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@0@Z ; std::vector<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::_Destroy

; 1198 : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+20]
	sub	eax, DWORD PTR [edx+12]
	sar	eax, 3
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?deallocate@?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@QAEXPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@I@Z ; std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T>::deallocate
$LN5@Insert_n@2:

; 1199 : 				}
; 1200 : 
; 1201 :  #if _HAS_ITERATOR_DEBUGGING
; 1202 : 			this->_Orphan_all();
; 1203 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1204 : 
; 1205 : 			_Myend = _Newvec + _Capacity;

	mov	eax, DWORD PTR __Capacity$[ebp]
	mov	ecx, DWORD PTR __Newvec$83455[ebp]
	lea	edx, DWORD PTR [ecx+eax*8]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], edx

; 1206 : 			_Mylast = _Newvec + _Count;

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Newvec$83455[ebp]
	lea	eax, DWORD PTR [edx+ecx*8]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 1207 : 			_Myfirst = _Newvec;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Newvec$83455[ebp]
	mov	DWORD PTR [edx+12], eax
	jmp	$LN16@Insert_n@2
$LN10@Insert_n@2:

; 1208 : 			}
; 1209 : 		else if ((size_type)(_Mylast - _VEC_ITER_BASE(_Where)) < _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	sub	edx, DWORD PTR __Where$[ebp+4]
	sar	edx, 3
	cmp	edx, DWORD PTR __Count$[ebp]
	jae	$LN3@Insert_n@2

; 1210 : 			{	// new stuff spills off end
; 1211 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR __Tmp$83470[ebp], ecx
	mov	DWORD PTR __Tmp$83470[ebp+4], edx

; 1212 : 
; 1213 : 			_Umove(_VEC_ITER_BASE(_Where), _Mylast,
; 1214 : 				_VEC_ITER_BASE(_Where) + _Count);	// copy suffix

	mov	eax, DWORD PTR __Count$[ebp]
	mov	ecx, DWORD PTR __Where$[ebp+4]
	lea	edx, DWORD PTR [ecx+eax*8]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Where$[ebp+4]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Umove@PAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAEPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU234@00@Z ; std::vector<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::_Umove<Ogre::KeyFrameArray<float>::KEYFRAME_T *>

; 1215 : 
; 1216 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 2

; 1217 : 			_Ufill(_Mylast, _Count - (_Mylast - _VEC_ITER_BASE(_Where)),
; 1218 : 				_Tmp);	// insert new stuff off end

	lea	eax, DWORD PTR __Tmp$83470[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	sub	edx, DWORD PTR __Where$[ebp+4]
	sar	edx, 3
	mov	eax, DWORD PTR __Count$[ebp]
	sub	eax, edx
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Ufill@?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAEPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU345@IABU345@@Z ; std::vector<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::_Ufill
	jmp	SHORT $LN21@Insert_n@2
__catch$?_Insert_n@?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@2@IABUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@Z$2:

; 1219 : 			_CATCH_ALL
; 1220 : 			_Destroy(_VEC_ITER_BASE(_Where) + _Count, _Mylast + _Count);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR __Count$[ebp]
	lea	eax, DWORD PTR [ecx+edx*8]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Where$[ebp+4]
	lea	eax, DWORD PTR [edx+ecx*8]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAEXPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@0@Z ; std::vector<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::_Destroy

; 1221 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1222 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$?_Insert_n@?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@2@IABUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@Z$3
	ret	0
$LN21@Insert_n@2:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Insert_n@?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@2@IABUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@Z$3:

; 1223 : 
; 1224 : 			_Mylast += _Count;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR __Count$[ebp]
	lea	ecx, DWORD PTR [edx+eax*8]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+16], ecx

; 1225 : 
; 1226 :  #if _HAS_ITERATOR_DEBUGGING
; 1227 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1228 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1229 : 
; 1230 : 			std::fill(_VEC_ITER_BASE(_Where), _Mylast - _Count,
; 1231 : 				_Tmp);	// insert up to old end

	lea	eax, DWORD PTR __Tmp$83470[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 3
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	sub	eax, ecx
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp+4]
	push	ecx
	call	??$fill@PAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@U123@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@0ABU123@@Z ; std::fill<Ogre::KeyFrameArray<float>::KEYFRAME_T *,Ogre::KeyFrameArray<float>::KEYFRAME_T>
	add	esp, 12					; 0000000cH

; 1232 : 			}
; 1233 : 		else

	jmp	SHORT $LN16@Insert_n@2
$LN3@Insert_n@2:

; 1234 : 			{	// new stuff can all be assigned
; 1235 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	edx, DWORD PTR __Val$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR __Tmp$83480[ebp], eax
	mov	DWORD PTR __Tmp$83480[ebp+4], ecx

; 1236 : 
; 1237 : 			pointer _Oldend = _Mylast;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR __Oldend$83481[ebp], eax

; 1238 : 			_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1239 : 				_Mylast);	// copy suffix

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR __Oldend$83481[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 3
	mov	edx, DWORD PTR __Oldend$83481[ebp]
	sub	edx, ecx
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Umove@PAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAEPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU234@00@Z ; std::vector<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::_Umove<Ogre::KeyFrameArray<float>::KEYFRAME_T *>
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 1240 : 
; 1241 :  #if _HAS_ITERATOR_DEBUGGING
; 1242 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1243 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1244 : 
; 1245 : 			_STDEXT _Unchecked_move_backward(_VEC_ITER_BASE(_Where), _Oldend - _Count,
; 1246 : 				_Oldend);	// copy hole

	mov	edx, DWORD PTR __Oldend$83481[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 3
	mov	ecx, DWORD PTR __Oldend$83481[ebp]
	sub	ecx, eax
	push	ecx
	mov	edx, DWORD PTR __Where$[ebp+4]
	push	edx
	call	??$_Unchecked_move_backward@PAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU123@@stdext@@YAPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU123@00@Z ; stdext::_Unchecked_move_backward<Ogre::KeyFrameArray<float>::KEYFRAME_T *,Ogre::KeyFrameArray<float>::KEYFRAME_T *>
	add	esp, 12					; 0000000cH

; 1247 : 			std::fill(_VEC_ITER_BASE(_Where), _VEC_ITER_BASE(_Where) + _Count,
; 1248 : 				_Tmp);	// insert into hole

	lea	eax, DWORD PTR __Tmp$83480[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Where$[ebp+4]
	lea	eax, DWORD PTR [edx+ecx*8]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp+4]
	push	ecx
	call	??$fill@PAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@U123@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@0ABU123@@Z ; std::fill<Ogre::KeyFrameArray<float>::KEYFRAME_T *,Ogre::KeyFrameArray<float>::KEYFRAME_T>
	add	esp, 12					; 0000000cH
$LN16@Insert_n@2:

; 1249 : 			}
; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Insert_n@?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@2@IABUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-64]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Insert_n@?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@2@IABUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Insert_n@?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@2@IABUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@Z ENDP ; std::vector<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::_Insert_n
PUBLIC	??$_Unchecked_move_backward@PAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU123@@stdext@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU123@00@Z ; stdext::_Unchecked_move_backward<Ogre::KeyFrameArray<float>::CONTROL_POINT_T *,Ogre::KeyFrameArray<float>::CONTROL_POINT_T *>
PUBLIC	??$fill@PAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@U123@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@0ABU123@@Z ; std::fill<Ogre::KeyFrameArray<float>::CONTROL_POINT_T *,Ogre::KeyFrameArray<float>::CONTROL_POINT_T>
PUBLIC	??$_Umove@PAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAEPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU234@00@Z ; std::vector<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::_Umove<Ogre::KeyFrameArray<float>::CONTROL_POINT_T *>
PUBLIC	?_Ufill@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAEPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU345@IABU345@@Z ; std::vector<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::_Ufill
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Insert_n@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@2@IABUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@Z$5 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@2@IABUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@Z$2
__catchsym$?_Insert_n@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@2@IABUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@Z$4 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@2@IABUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@Z$0
__unwindtable$?_Insert_n@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@2@IABUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$?_Insert_n@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@2@IABUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Insert_n@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@2@IABUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Insert_n@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@2@IABUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__tryblocktable$?_Insert_n@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@2@IABUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@2@IABUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@Z$4
	DD	02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@2@IABUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@Z$5
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?_Insert_n@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@2@IABUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@Z
_TEXT	SEGMENT
tv84 = -60						; size = 4
_this$ = -56						; size = 4
__Tmp$83523 = -52					; size = 8
__Oldend$83524 = -44					; size = 4
__Tmp$83513 = -40					; size = 8
__Ncopied$83500 = -32					; size = 4
__Newvec$83498 = -28					; size = 4
__Whereoff$83499 = -24					; size = 4
__Capacity$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Where$ = 8						; size = 8
__Count$ = 16						; size = 4
__Val$ = 20						; size = 4
?_Insert_n@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@2@IABUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@Z PROC ; std::vector<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::_Insert_n, COMDAT
; _this$ = ecx

; 1153 : 		{	// insert _Count * _Val at _Where

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Insert_n@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@2@IABUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 44					; 0000002cH
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1154 : 
; 1155 :  #if _HAS_ITERATOR_DEBUGGING
; 1156 : 		if (_Where._Mycont != this
; 1157 : 			|| _Where._Myptr < _Myfirst || _Mylast < _Where._Myptr)
; 1158 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1159 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1160 : 
; 1161 : 		size_type _Capacity = capacity();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?capacity@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::capacity
	mov	DWORD PTR __Capacity$[ebp], eax

; 1162 : 
; 1163 : 		if (_Count == 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN14@Insert_n@3
	jmp	$LN16@Insert_n@3
$LN14@Insert_n@3:

; 1164 : 			;
; 1165 : 		else if (max_size() - size() < _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::max_size
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::size
	sub	esi, eax
	cmp	esi, DWORD PTR __Count$[ebp]
	jae	SHORT $LN12@Insert_n@3

; 1166 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@KAXXZ ; std::vector<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::_Xlen
	jmp	$LN16@Insert_n@3
$LN12@Insert_n@3:

; 1167 : 		else if (_Capacity < size() + _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::size
	add	eax, DWORD PTR __Count$[ebp]
	cmp	DWORD PTR __Capacity$[ebp], eax
	jae	$LN10@Insert_n@3

; 1168 : 			{	// not enough room, reallocate
; 1169 : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1170 : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::max_size
	mov	ecx, DWORD PTR __Capacity$[ebp]
	shr	ecx, 1
	sub	eax, ecx
	cmp	eax, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN17@Insert_n@3
	mov	DWORD PTR tv84[ebp], 0
	jmp	SHORT $LN18@Insert_n@3
$LN17@Insert_n@3:
	mov	edx, DWORD PTR __Capacity$[ebp]
	shr	edx, 1
	add	edx, DWORD PTR __Capacity$[ebp]
	mov	DWORD PTR tv84[ebp], edx
$LN18@Insert_n@3:
	mov	eax, DWORD PTR tv84[ebp]
	mov	DWORD PTR __Capacity$[ebp], eax

; 1171 : 			if (_Capacity < size() + _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::size
	add	eax, DWORD PTR __Count$[ebp]
	cmp	DWORD PTR __Capacity$[ebp], eax
	jae	SHORT $LN9@Insert_n@3

; 1172 : 				_Capacity = size() + _Count;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::size
	add	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Capacity$[ebp], eax
$LN9@Insert_n@3:

; 1173 : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

	mov	ecx, DWORD PTR __Capacity$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?allocate@?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@QAEPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@I@Z ; std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T>::allocate
	mov	DWORD PTR __Newvec$83498[ebp], eax

; 1174 : 			size_type _Whereoff = _VEC_ITER_BASE(_Where) - _Myfirst;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Where$[ebp+4]
	sub	eax, DWORD PTR [edx+12]
	sar	eax, 3
	mov	DWORD PTR __Whereoff$83499[ebp], eax

; 1175 : 			int _Ncopied = 0;

	mov	DWORD PTR __Ncopied$83500[ebp], 0

; 1176 : 
; 1177 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1178 : 			_Ufill(_Newvec + _Whereoff, _Count, _Val);	// add new stuff

	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __Whereoff$83499[ebp]
	mov	ecx, DWORD PTR __Newvec$83498[ebp]
	lea	edx, DWORD PTR [ecx+eax*8]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Ufill@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAEPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU345@IABU345@@Z ; std::vector<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::_Ufill

; 1179 : 			++_Ncopied;

	mov	eax, DWORD PTR __Ncopied$83500[ebp]
	add	eax, 1
	mov	DWORD PTR __Ncopied$83500[ebp], eax

; 1180 : 			_Umove(this->_Myfirst, _VEC_ITER_BASE(_Where),
; 1181 : 				_Newvec);	// move prefix

	mov	ecx, DWORD PTR __Newvec$83498[ebp]
	push	ecx
	mov	edx, DWORD PTR __Where$[ebp+4]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Umove@PAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAEPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU234@00@Z ; std::vector<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::_Umove<Ogre::KeyFrameArray<float>::CONTROL_POINT_T *>

; 1182 : 			++_Ncopied;

	mov	edx, DWORD PTR __Ncopied$83500[ebp]
	add	edx, 1
	mov	DWORD PTR __Ncopied$83500[ebp], edx

; 1183 : 			_Umove(_VEC_ITER_BASE(_Where), this->_Mylast,
; 1184 : 				_Newvec + (_Whereoff + _Count));	// move suffix

	mov	eax, DWORD PTR __Whereoff$83499[ebp]
	add	eax, DWORD PTR __Count$[ebp]
	mov	ecx, DWORD PTR __Newvec$83498[ebp]
	lea	edx, DWORD PTR [ecx+eax*8]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Where$[ebp+4]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Umove@PAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAEPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU234@00@Z ; std::vector<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::_Umove<Ogre::KeyFrameArray<float>::CONTROL_POINT_T *>
	jmp	SHORT $LN19@Insert_n@3
__catch$?_Insert_n@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@2@IABUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@Z$0:

; 1185 : 			_CATCH_ALL
; 1186 : 			if (1 < _Ncopied)

	cmp	DWORD PTR __Ncopied$83500[ebp], 1
	jle	SHORT $LN7@Insert_n@3

; 1187 : 				_Destroy(_Newvec, _Newvec + _Whereoff);

	mov	eax, DWORD PTR __Whereoff$83499[ebp]
	mov	ecx, DWORD PTR __Newvec$83498[ebp]
	lea	edx, DWORD PTR [ecx+eax*8]
	push	edx
	mov	eax, DWORD PTR __Newvec$83498[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAEXPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@0@Z ; std::vector<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::_Destroy
$LN7@Insert_n@3:

; 1188 : 			if (0 < _Ncopied)

	cmp	DWORD PTR __Ncopied$83500[ebp], 0
	jle	SHORT $LN6@Insert_n@3

; 1189 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);

	mov	ecx, DWORD PTR __Whereoff$83499[ebp]
	mov	edx, DWORD PTR __Newvec$83498[ebp]
	lea	eax, DWORD PTR [edx+ecx*8]
	mov	ecx, DWORD PTR __Count$[ebp]
	lea	edx, DWORD PTR [eax+ecx*8]
	push	edx
	mov	eax, DWORD PTR __Whereoff$83499[ebp]
	mov	ecx, DWORD PTR __Newvec$83498[ebp]
	lea	edx, DWORD PTR [ecx+eax*8]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAEXPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@0@Z ; std::vector<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::_Destroy
$LN6@Insert_n@3:

; 1190 : 			this->_Alval.deallocate(_Newvec, _Capacity);

	mov	eax, DWORD PTR __Capacity$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Newvec$83498[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?deallocate@?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@QAEXPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@I@Z ; std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T>::deallocate

; 1191 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1192 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$?_Insert_n@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@2@IABUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@Z$1
	ret	0
$LN19@Insert_n@3:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Insert_n@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@2@IABUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@Z$1:

; 1193 : 
; 1194 : 			_Count += size();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::size
	add	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Count$[ebp], eax

; 1195 : 			if (_Myfirst != 0)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+12], 0
	je	SHORT $LN5@Insert_n@3

; 1196 : 				{	// destroy and deallocate old array
; 1197 : 				_Destroy(_Myfirst, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAEXPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@0@Z ; std::vector<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::_Destroy

; 1198 : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+20]
	sub	eax, DWORD PTR [edx+12]
	sar	eax, 3
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?deallocate@?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@QAEXPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@I@Z ; std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T>::deallocate
$LN5@Insert_n@3:

; 1199 : 				}
; 1200 : 
; 1201 :  #if _HAS_ITERATOR_DEBUGGING
; 1202 : 			this->_Orphan_all();
; 1203 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1204 : 
; 1205 : 			_Myend = _Newvec + _Capacity;

	mov	eax, DWORD PTR __Capacity$[ebp]
	mov	ecx, DWORD PTR __Newvec$83498[ebp]
	lea	edx, DWORD PTR [ecx+eax*8]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], edx

; 1206 : 			_Mylast = _Newvec + _Count;

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Newvec$83498[ebp]
	lea	eax, DWORD PTR [edx+ecx*8]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 1207 : 			_Myfirst = _Newvec;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Newvec$83498[ebp]
	mov	DWORD PTR [edx+12], eax
	jmp	$LN16@Insert_n@3
$LN10@Insert_n@3:

; 1208 : 			}
; 1209 : 		else if ((size_type)(_Mylast - _VEC_ITER_BASE(_Where)) < _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	sub	edx, DWORD PTR __Where$[ebp+4]
	sar	edx, 3
	cmp	edx, DWORD PTR __Count$[ebp]
	jae	$LN3@Insert_n@3

; 1210 : 			{	// new stuff spills off end
; 1211 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR __Tmp$83513[ebp], ecx
	mov	DWORD PTR __Tmp$83513[ebp+4], edx

; 1212 : 
; 1213 : 			_Umove(_VEC_ITER_BASE(_Where), _Mylast,
; 1214 : 				_VEC_ITER_BASE(_Where) + _Count);	// copy suffix

	mov	eax, DWORD PTR __Count$[ebp]
	mov	ecx, DWORD PTR __Where$[ebp+4]
	lea	edx, DWORD PTR [ecx+eax*8]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Where$[ebp+4]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Umove@PAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAEPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU234@00@Z ; std::vector<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::_Umove<Ogre::KeyFrameArray<float>::CONTROL_POINT_T *>

; 1215 : 
; 1216 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 2

; 1217 : 			_Ufill(_Mylast, _Count - (_Mylast - _VEC_ITER_BASE(_Where)),
; 1218 : 				_Tmp);	// insert new stuff off end

	lea	eax, DWORD PTR __Tmp$83513[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	sub	edx, DWORD PTR __Where$[ebp+4]
	sar	edx, 3
	mov	eax, DWORD PTR __Count$[ebp]
	sub	eax, edx
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Ufill@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAEPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU345@IABU345@@Z ; std::vector<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::_Ufill
	jmp	SHORT $LN21@Insert_n@3
__catch$?_Insert_n@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@2@IABUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@Z$2:

; 1219 : 			_CATCH_ALL
; 1220 : 			_Destroy(_VEC_ITER_BASE(_Where) + _Count, _Mylast + _Count);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR __Count$[ebp]
	lea	eax, DWORD PTR [ecx+edx*8]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Where$[ebp+4]
	lea	eax, DWORD PTR [edx+ecx*8]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAEXPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@0@Z ; std::vector<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::_Destroy

; 1221 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1222 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$?_Insert_n@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@2@IABUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@Z$3
	ret	0
$LN21@Insert_n@3:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Insert_n@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@2@IABUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@Z$3:

; 1223 : 
; 1224 : 			_Mylast += _Count;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR __Count$[ebp]
	lea	ecx, DWORD PTR [edx+eax*8]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+16], ecx

; 1225 : 
; 1226 :  #if _HAS_ITERATOR_DEBUGGING
; 1227 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1228 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1229 : 
; 1230 : 			std::fill(_VEC_ITER_BASE(_Where), _Mylast - _Count,
; 1231 : 				_Tmp);	// insert up to old end

	lea	eax, DWORD PTR __Tmp$83513[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 3
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	sub	eax, ecx
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp+4]
	push	ecx
	call	??$fill@PAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@U123@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@0ABU123@@Z ; std::fill<Ogre::KeyFrameArray<float>::CONTROL_POINT_T *,Ogre::KeyFrameArray<float>::CONTROL_POINT_T>
	add	esp, 12					; 0000000cH

; 1232 : 			}
; 1233 : 		else

	jmp	SHORT $LN16@Insert_n@3
$LN3@Insert_n@3:

; 1234 : 			{	// new stuff can all be assigned
; 1235 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	edx, DWORD PTR __Val$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR __Tmp$83523[ebp], eax
	mov	DWORD PTR __Tmp$83523[ebp+4], ecx

; 1236 : 
; 1237 : 			pointer _Oldend = _Mylast;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR __Oldend$83524[ebp], eax

; 1238 : 			_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1239 : 				_Mylast);	// copy suffix

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR __Oldend$83524[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 3
	mov	edx, DWORD PTR __Oldend$83524[ebp]
	sub	edx, ecx
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Umove@PAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAEPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU234@00@Z ; std::vector<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::_Umove<Ogre::KeyFrameArray<float>::CONTROL_POINT_T *>
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 1240 : 
; 1241 :  #if _HAS_ITERATOR_DEBUGGING
; 1242 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1243 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1244 : 
; 1245 : 			_STDEXT _Unchecked_move_backward(_VEC_ITER_BASE(_Where), _Oldend - _Count,
; 1246 : 				_Oldend);	// copy hole

	mov	edx, DWORD PTR __Oldend$83524[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 3
	mov	ecx, DWORD PTR __Oldend$83524[ebp]
	sub	ecx, eax
	push	ecx
	mov	edx, DWORD PTR __Where$[ebp+4]
	push	edx
	call	??$_Unchecked_move_backward@PAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU123@@stdext@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU123@00@Z ; stdext::_Unchecked_move_backward<Ogre::KeyFrameArray<float>::CONTROL_POINT_T *,Ogre::KeyFrameArray<float>::CONTROL_POINT_T *>
	add	esp, 12					; 0000000cH

; 1247 : 			std::fill(_VEC_ITER_BASE(_Where), _VEC_ITER_BASE(_Where) + _Count,
; 1248 : 				_Tmp);	// insert into hole

	lea	eax, DWORD PTR __Tmp$83523[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Where$[ebp+4]
	lea	eax, DWORD PTR [edx+ecx*8]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp+4]
	push	ecx
	call	??$fill@PAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@U123@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@0ABU123@@Z ; std::fill<Ogre::KeyFrameArray<float>::CONTROL_POINT_T *,Ogre::KeyFrameArray<float>::CONTROL_POINT_T>
	add	esp, 12					; 0000000cH
$LN16@Insert_n@3:

; 1249 : 			}
; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Insert_n@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@2@IABUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-64]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Insert_n@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@2@IABUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Insert_n@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@2@IABUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@Z ENDP ; std::vector<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::_Insert_n
PUBLIC	??$_Unchecked_move_backward@PAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@@stdext@@YAPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@00@Z ; stdext::_Unchecked_move_backward<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T *>
PUBLIC	??$fill@PAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@U123@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@0ABU123@@Z ; std::fill<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T>
PUBLIC	??$_Umove@PAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAEPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU234@00@Z ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::_Umove<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T *>
PUBLIC	?_Ufill@?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAEPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU345@IABU345@@Z ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::_Ufill
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Insert_n@?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@2@IABUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@Z$5 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@2@IABUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@Z$2
__catchsym$?_Insert_n@?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@2@IABUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@Z$4 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@2@IABUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@Z$0
__unwindtable$?_Insert_n@?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@2@IABUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$?_Insert_n@?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@2@IABUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Insert_n@?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@2@IABUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Insert_n@?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@2@IABUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__tryblocktable$?_Insert_n@?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@2@IABUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@2@IABUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@Z$4
	DD	02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@2@IABUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@Z$5
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?_Insert_n@?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@2@IABUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@Z
_TEXT	SEGMENT
tv84 = -84						; size = 4
_this$ = -80						; size = 4
__Tmp$83566 = -76					; size = 20
__Oldend$83567 = -56					; size = 4
__Tmp$83556 = -52					; size = 20
__Ncopied$83543 = -32					; size = 4
__Newvec$83541 = -28					; size = 4
__Whereoff$83542 = -24					; size = 4
__Capacity$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Where$ = 8						; size = 8
__Count$ = 16						; size = 4
__Val$ = 20						; size = 4
?_Insert_n@?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@2@IABUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@Z PROC ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::_Insert_n, COMDAT
; _this$ = ecx

; 1153 : 		{	// insert _Count * _Val at _Where

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Insert_n@?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@2@IABUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1154 : 
; 1155 :  #if _HAS_ITERATOR_DEBUGGING
; 1156 : 		if (_Where._Mycont != this
; 1157 : 			|| _Where._Myptr < _Myfirst || _Mylast < _Where._Myptr)
; 1158 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1159 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1160 : 
; 1161 : 		size_type _Capacity = capacity();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?capacity@?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::capacity
	mov	DWORD PTR __Capacity$[ebp], eax

; 1162 : 
; 1163 : 		if (_Count == 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN14@Insert_n@4
	jmp	$LN16@Insert_n@4
$LN14@Insert_n@4:

; 1164 : 			;
; 1165 : 		else if (max_size() - size() < _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::max_size
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::size
	sub	esi, eax
	cmp	esi, DWORD PTR __Count$[ebp]
	jae	SHORT $LN12@Insert_n@4

; 1166 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@KAXXZ ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::_Xlen
	jmp	$LN16@Insert_n@4
$LN12@Insert_n@4:

; 1167 : 		else if (_Capacity < size() + _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::size
	add	eax, DWORD PTR __Count$[ebp]
	cmp	DWORD PTR __Capacity$[ebp], eax
	jae	$LN10@Insert_n@4

; 1168 : 			{	// not enough room, reallocate
; 1169 : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1170 : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::max_size
	mov	ecx, DWORD PTR __Capacity$[ebp]
	shr	ecx, 1
	sub	eax, ecx
	cmp	eax, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN17@Insert_n@4
	mov	DWORD PTR tv84[ebp], 0
	jmp	SHORT $LN18@Insert_n@4
$LN17@Insert_n@4:
	mov	edx, DWORD PTR __Capacity$[ebp]
	shr	edx, 1
	add	edx, DWORD PTR __Capacity$[ebp]
	mov	DWORD PTR tv84[ebp], edx
$LN18@Insert_n@4:
	mov	eax, DWORD PTR tv84[ebp]
	mov	DWORD PTR __Capacity$[ebp], eax

; 1171 : 			if (_Capacity < size() + _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::size
	add	eax, DWORD PTR __Count$[ebp]
	cmp	DWORD PTR __Capacity$[ebp], eax
	jae	SHORT $LN9@Insert_n@4

; 1172 : 				_Capacity = size() + _Count;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::size
	add	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Capacity$[ebp], eax
$LN9@Insert_n@4:

; 1173 : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

	mov	ecx, DWORD PTR __Capacity$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?allocate@?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@QAEPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@I@Z ; std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T>::allocate
	mov	DWORD PTR __Newvec$83541[ebp], eax

; 1174 : 			size_type _Whereoff = _VEC_ITER_BASE(_Where) - _Myfirst;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Where$[ebp+4]
	sub	eax, DWORD PTR [edx+12]
	cdq
	mov	ecx, 20					; 00000014H
	idiv	ecx
	mov	DWORD PTR __Whereoff$83542[ebp], eax

; 1175 : 			int _Ncopied = 0;

	mov	DWORD PTR __Ncopied$83543[ebp], 0

; 1176 : 
; 1177 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1178 : 			_Ufill(_Newvec + _Whereoff, _Count, _Val);	// add new stuff

	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Whereoff$83542[ebp]
	imul	ecx, 20					; 00000014H
	add	ecx, DWORD PTR __Newvec$83541[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Ufill@?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAEPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU345@IABU345@@Z ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::_Ufill

; 1179 : 			++_Ncopied;

	mov	edx, DWORD PTR __Ncopied$83543[ebp]
	add	edx, 1
	mov	DWORD PTR __Ncopied$83543[ebp], edx

; 1180 : 			_Umove(this->_Myfirst, _VEC_ITER_BASE(_Where),
; 1181 : 				_Newvec);	// move prefix

	mov	eax, DWORD PTR __Newvec$83541[ebp]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Umove@PAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAEPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU234@00@Z ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::_Umove<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T *>

; 1182 : 			++_Ncopied;

	mov	ecx, DWORD PTR __Ncopied$83543[ebp]
	add	ecx, 1
	mov	DWORD PTR __Ncopied$83543[ebp], ecx

; 1183 : 			_Umove(_VEC_ITER_BASE(_Where), this->_Mylast,
; 1184 : 				_Newvec + (_Whereoff + _Count));	// move suffix

	mov	edx, DWORD PTR __Whereoff$83542[ebp]
	add	edx, DWORD PTR __Count$[ebp]
	imul	edx, 20					; 00000014H
	add	edx, DWORD PTR __Newvec$83541[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Where$[ebp+4]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Umove@PAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAEPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU234@00@Z ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::_Umove<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T *>
	jmp	SHORT $LN19@Insert_n@4
__catch$?_Insert_n@?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@2@IABUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@Z$0:

; 1185 : 			_CATCH_ALL
; 1186 : 			if (1 < _Ncopied)

	cmp	DWORD PTR __Ncopied$83543[ebp], 1
	jle	SHORT $LN7@Insert_n@4

; 1187 : 				_Destroy(_Newvec, _Newvec + _Whereoff);

	mov	eax, DWORD PTR __Whereoff$83542[ebp]
	imul	eax, 20					; 00000014H
	add	eax, DWORD PTR __Newvec$83541[ebp]
	push	eax
	mov	ecx, DWORD PTR __Newvec$83541[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAEXPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@0@Z ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::_Destroy
$LN7@Insert_n@4:

; 1188 : 			if (0 < _Ncopied)

	cmp	DWORD PTR __Ncopied$83543[ebp], 0
	jle	SHORT $LN6@Insert_n@4

; 1189 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);

	mov	edx, DWORD PTR __Whereoff$83542[ebp]
	imul	edx, 20					; 00000014H
	add	edx, DWORD PTR __Newvec$83541[ebp]
	mov	eax, DWORD PTR __Count$[ebp]
	imul	eax, 20					; 00000014H
	add	edx, eax
	push	edx
	mov	ecx, DWORD PTR __Whereoff$83542[ebp]
	imul	ecx, 20					; 00000014H
	add	ecx, DWORD PTR __Newvec$83541[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAEXPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@0@Z ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::_Destroy
$LN6@Insert_n@4:

; 1190 : 			this->_Alval.deallocate(_Newvec, _Capacity);

	mov	edx, DWORD PTR __Capacity$[ebp]
	push	edx
	mov	eax, DWORD PTR __Newvec$83541[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?deallocate@?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@QAEXPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@I@Z ; std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T>::deallocate

; 1191 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1192 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$?_Insert_n@?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@2@IABUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@Z$1
	ret	0
$LN19@Insert_n@4:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Insert_n@?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@2@IABUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@Z$1:

; 1193 : 
; 1194 : 			_Count += size();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::size
	add	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Count$[ebp], eax

; 1195 : 			if (_Myfirst != 0)

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+12], 0
	je	SHORT $LN5@Insert_n@4

; 1196 : 				{	// destroy and deallocate old array
; 1197 : 				_Destroy(_Myfirst, _Mylast);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAEXPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@0@Z ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::_Destroy

; 1198 : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+20]
	sub	eax, DWORD PTR [ecx+12]
	cdq
	mov	ecx, 20					; 00000014H
	idiv	ecx
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?deallocate@?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@QAEXPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@I@Z ; std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T>::deallocate
$LN5@Insert_n@4:

; 1199 : 				}
; 1200 : 
; 1201 :  #if _HAS_ITERATOR_DEBUGGING
; 1202 : 			this->_Orphan_all();
; 1203 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1204 : 
; 1205 : 			_Myend = _Newvec + _Capacity;

	mov	ecx, DWORD PTR __Capacity$[ebp]
	imul	ecx, 20					; 00000014H
	add	ecx, DWORD PTR __Newvec$83541[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+20], ecx

; 1206 : 			_Mylast = _Newvec + _Count;

	mov	eax, DWORD PTR __Count$[ebp]
	imul	eax, 20					; 00000014H
	add	eax, DWORD PTR __Newvec$83541[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 1207 : 			_Myfirst = _Newvec;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Newvec$83541[ebp]
	mov	DWORD PTR [edx+12], eax
	jmp	$LN16@Insert_n@4
$LN10@Insert_n@4:

; 1208 : 			}
; 1209 : 		else if ((size_type)(_Mylast - _VEC_ITER_BASE(_Where)) < _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+16]
	sub	eax, DWORD PTR __Where$[ebp+4]
	cdq
	mov	ecx, 20					; 00000014H
	idiv	ecx
	cmp	eax, DWORD PTR __Count$[ebp]
	jae	$LN3@Insert_n@4

; 1210 : 			{	// new stuff spills off end
; 1211 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	edx, DWORD PTR __Val$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR __Tmp$83556[ebp], eax
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR __Tmp$83556[ebp+4], ecx
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR __Tmp$83556[ebp+8], eax
	mov	ecx, DWORD PTR [edx+12]
	mov	DWORD PTR __Tmp$83556[ebp+12], ecx
	mov	edx, DWORD PTR [edx+16]
	mov	DWORD PTR __Tmp$83556[ebp+16], edx

; 1212 : 
; 1213 : 			_Umove(_VEC_ITER_BASE(_Where), _Mylast,
; 1214 : 				_VEC_ITER_BASE(_Where) + _Count);	// copy suffix

	mov	eax, DWORD PTR __Count$[ebp]
	imul	eax, 20					; 00000014H
	add	eax, DWORD PTR __Where$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR __Where$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Umove@PAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAEPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU234@00@Z ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::_Umove<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T *>

; 1215 : 
; 1216 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 2

; 1217 : 			_Ufill(_Mylast, _Count - (_Mylast - _VEC_ITER_BASE(_Where)),
; 1218 : 				_Tmp);	// insert new stuff off end

	lea	ecx, DWORD PTR __Tmp$83556[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	sub	eax, DWORD PTR __Where$[ebp+4]
	cdq
	mov	ecx, 20					; 00000014H
	idiv	ecx
	mov	edx, DWORD PTR __Count$[ebp]
	sub	edx, eax
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Ufill@?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAEPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU345@IABU345@@Z ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::_Ufill
	jmp	SHORT $LN21@Insert_n@4
__catch$?_Insert_n@?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@2@IABUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@Z$2:

; 1219 : 			_CATCH_ALL
; 1220 : 			_Destroy(_VEC_ITER_BASE(_Where) + _Count, _Mylast + _Count);

	mov	edx, DWORD PTR __Count$[ebp]
	imul	edx, 20					; 00000014H
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+16]
	push	edx
	mov	ecx, DWORD PTR __Count$[ebp]
	imul	ecx, 20					; 00000014H
	add	ecx, DWORD PTR __Where$[ebp+4]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAEXPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@0@Z ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::_Destroy

; 1221 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1222 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$?_Insert_n@?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@2@IABUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@Z$3
	ret	0
$LN21@Insert_n@4:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Insert_n@?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@2@IABUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@Z$3:

; 1223 : 
; 1224 : 			_Mylast += _Count;

	mov	edx, DWORD PTR __Count$[ebp]
	imul	edx, 20					; 00000014H
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+16]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], edx

; 1225 : 
; 1226 :  #if _HAS_ITERATOR_DEBUGGING
; 1227 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1228 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1229 : 
; 1230 : 			std::fill(_VEC_ITER_BASE(_Where), _Mylast - _Count,
; 1231 : 				_Tmp);	// insert up to old end

	lea	edx, DWORD PTR __Tmp$83556[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	imul	eax, 20					; 00000014H
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	sub	edx, eax
	push	edx
	mov	eax, DWORD PTR __Where$[ebp+4]
	push	eax
	call	??$fill@PAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@U123@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@0ABU123@@Z ; std::fill<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T>
	add	esp, 12					; 0000000cH

; 1232 : 			}
; 1233 : 		else

	jmp	$LN16@Insert_n@4
$LN3@Insert_n@4:

; 1234 : 			{	// new stuff can all be assigned
; 1235 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	ecx, DWORD PTR __Val$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR __Tmp$83566[ebp], edx
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR __Tmp$83566[ebp+4], eax
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR __Tmp$83566[ebp+8], edx
	mov	eax, DWORD PTR [ecx+12]
	mov	DWORD PTR __Tmp$83566[ebp+12], eax
	mov	ecx, DWORD PTR [ecx+16]
	mov	DWORD PTR __Tmp$83566[ebp+16], ecx

; 1236 : 
; 1237 : 			pointer _Oldend = _Mylast;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR __Oldend$83567[ebp], eax

; 1238 : 			_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1239 : 				_Mylast);	// copy suffix

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR __Oldend$83567[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	imul	ecx, 20					; 00000014H
	mov	edx, DWORD PTR __Oldend$83567[ebp]
	sub	edx, ecx
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Umove@PAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAEPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU234@00@Z ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::_Umove<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T *>
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 1240 : 
; 1241 :  #if _HAS_ITERATOR_DEBUGGING
; 1242 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1243 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1244 : 
; 1245 : 			_STDEXT _Unchecked_move_backward(_VEC_ITER_BASE(_Where), _Oldend - _Count,
; 1246 : 				_Oldend);	// copy hole

	mov	edx, DWORD PTR __Oldend$83567[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	imul	eax, 20					; 00000014H
	mov	ecx, DWORD PTR __Oldend$83567[ebp]
	sub	ecx, eax
	push	ecx
	mov	edx, DWORD PTR __Where$[ebp+4]
	push	edx
	call	??$_Unchecked_move_backward@PAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@@stdext@@YAPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@00@Z ; stdext::_Unchecked_move_backward<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T *>
	add	esp, 12					; 0000000cH

; 1247 : 			std::fill(_VEC_ITER_BASE(_Where), _VEC_ITER_BASE(_Where) + _Count,
; 1248 : 				_Tmp);	// insert into hole

	lea	eax, DWORD PTR __Tmp$83566[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	imul	ecx, 20					; 00000014H
	add	ecx, DWORD PTR __Where$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR __Where$[ebp+4]
	push	edx
	call	??$fill@PAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@U123@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@0ABU123@@Z ; std::fill<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T>
	add	esp, 12					; 0000000cH
$LN16@Insert_n@4:

; 1249 : 			}
; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Insert_n@?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@2@IABUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-88]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Insert_n@?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@2@IABUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Insert_n@?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@2@IABUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@Z ENDP ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::_Insert_n
PUBLIC	??$_Unchecked_move_backward@PAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@@stdext@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@00@Z ; stdext::_Unchecked_move_backward<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T *>
PUBLIC	??$fill@PAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@U123@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@0ABU123@@Z ; std::fill<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T>
PUBLIC	??$_Umove@PAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAEPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU234@00@Z ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::_Umove<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T *>
PUBLIC	?_Ufill@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAEPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU345@IABU345@@Z ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::_Ufill
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Insert_n@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@2@IABUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@Z$5 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@2@IABUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@Z$2
__catchsym$?_Insert_n@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@2@IABUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@Z$4 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@2@IABUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@Z$0
__unwindtable$?_Insert_n@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@2@IABUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$?_Insert_n@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@2@IABUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Insert_n@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@2@IABUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Insert_n@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@2@IABUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
__tryblocktable$?_Insert_n@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@2@IABUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@2@IABUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@Z$4
	DD	02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@2@IABUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@Z$5
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?_Insert_n@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@2@IABUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@Z
_TEXT	SEGMENT
tv84 = -108						; size = 4
_this$ = -104						; size = 4
__Tmp$83609 = -100					; size = 32
__Oldend$83610 = -68					; size = 4
__Tmp$83599 = -64					; size = 32
__Ncopied$83586 = -32					; size = 4
__Newvec$83584 = -28					; size = 4
__Whereoff$83585 = -24					; size = 4
__Capacity$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Where$ = 8						; size = 8
__Count$ = 16						; size = 4
__Val$ = 20						; size = 4
?_Insert_n@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@2@IABUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@Z PROC ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::_Insert_n, COMDAT
; _this$ = ecx

; 1153 : 		{	// insert _Count * _Val at _Where

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Insert_n@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@2@IABUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 92					; 0000005cH
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1154 : 
; 1155 :  #if _HAS_ITERATOR_DEBUGGING
; 1156 : 		if (_Where._Mycont != this
; 1157 : 			|| _Where._Myptr < _Myfirst || _Mylast < _Where._Myptr)
; 1158 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1159 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1160 : 
; 1161 : 		size_type _Capacity = capacity();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?capacity@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::capacity
	mov	DWORD PTR __Capacity$[ebp], eax

; 1162 : 
; 1163 : 		if (_Count == 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN14@Insert_n@5
	jmp	$LN16@Insert_n@5
$LN14@Insert_n@5:

; 1164 : 			;
; 1165 : 		else if (max_size() - size() < _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::max_size
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::size
	sub	esi, eax
	cmp	esi, DWORD PTR __Count$[ebp]
	jae	SHORT $LN12@Insert_n@5

; 1166 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@KAXXZ ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::_Xlen
	jmp	$LN16@Insert_n@5
$LN12@Insert_n@5:

; 1167 : 		else if (_Capacity < size() + _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::size
	add	eax, DWORD PTR __Count$[ebp]
	cmp	DWORD PTR __Capacity$[ebp], eax
	jae	$LN10@Insert_n@5

; 1168 : 			{	// not enough room, reallocate
; 1169 : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1170 : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::max_size
	mov	ecx, DWORD PTR __Capacity$[ebp]
	shr	ecx, 1
	sub	eax, ecx
	cmp	eax, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN17@Insert_n@5
	mov	DWORD PTR tv84[ebp], 0
	jmp	SHORT $LN18@Insert_n@5
$LN17@Insert_n@5:
	mov	edx, DWORD PTR __Capacity$[ebp]
	shr	edx, 1
	add	edx, DWORD PTR __Capacity$[ebp]
	mov	DWORD PTR tv84[ebp], edx
$LN18@Insert_n@5:
	mov	eax, DWORD PTR tv84[ebp]
	mov	DWORD PTR __Capacity$[ebp], eax

; 1171 : 			if (_Capacity < size() + _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::size
	add	eax, DWORD PTR __Count$[ebp]
	cmp	DWORD PTR __Capacity$[ebp], eax
	jae	SHORT $LN9@Insert_n@5

; 1172 : 				_Capacity = size() + _Count;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::size
	add	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Capacity$[ebp], eax
$LN9@Insert_n@5:

; 1173 : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

	mov	ecx, DWORD PTR __Capacity$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?allocate@?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@QAEPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@I@Z ; std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T>::allocate
	mov	DWORD PTR __Newvec$83584[ebp], eax

; 1174 : 			size_type _Whereoff = _VEC_ITER_BASE(_Where) - _Myfirst;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Where$[ebp+4]
	sub	eax, DWORD PTR [edx+12]
	sar	eax, 5
	mov	DWORD PTR __Whereoff$83585[ebp], eax

; 1175 : 			int _Ncopied = 0;

	mov	DWORD PTR __Ncopied$83586[ebp], 0

; 1176 : 
; 1177 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1178 : 			_Ufill(_Newvec + _Whereoff, _Count, _Val);	// add new stuff

	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __Whereoff$83585[ebp]
	shl	eax, 5
	add	eax, DWORD PTR __Newvec$83584[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Ufill@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAEPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU345@IABU345@@Z ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::_Ufill

; 1179 : 			++_Ncopied;

	mov	ecx, DWORD PTR __Ncopied$83586[ebp]
	add	ecx, 1
	mov	DWORD PTR __Ncopied$83586[ebp], ecx

; 1180 : 			_Umove(this->_Myfirst, _VEC_ITER_BASE(_Where),
; 1181 : 				_Newvec);	// move prefix

	mov	edx, DWORD PTR __Newvec$83584[ebp]
	push	edx
	mov	eax, DWORD PTR __Where$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Umove@PAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAEPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU234@00@Z ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::_Umove<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T *>

; 1182 : 			++_Ncopied;

	mov	eax, DWORD PTR __Ncopied$83586[ebp]
	add	eax, 1
	mov	DWORD PTR __Ncopied$83586[ebp], eax

; 1183 : 			_Umove(_VEC_ITER_BASE(_Where), this->_Mylast,
; 1184 : 				_Newvec + (_Whereoff + _Count));	// move suffix

	mov	ecx, DWORD PTR __Whereoff$83585[ebp]
	add	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 5
	add	ecx, DWORD PTR __Newvec$83584[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp+4]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Umove@PAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAEPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU234@00@Z ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::_Umove<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T *>
	jmp	SHORT $LN19@Insert_n@5
__catch$?_Insert_n@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@2@IABUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@Z$0:

; 1185 : 			_CATCH_ALL
; 1186 : 			if (1 < _Ncopied)

	cmp	DWORD PTR __Ncopied$83586[ebp], 1
	jle	SHORT $LN7@Insert_n@5

; 1187 : 				_Destroy(_Newvec, _Newvec + _Whereoff);

	mov	edx, DWORD PTR __Whereoff$83585[ebp]
	shl	edx, 5
	add	edx, DWORD PTR __Newvec$83584[ebp]
	push	edx
	mov	eax, DWORD PTR __Newvec$83584[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAEXPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@0@Z ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::_Destroy
$LN7@Insert_n@5:

; 1188 : 			if (0 < _Ncopied)

	cmp	DWORD PTR __Ncopied$83586[ebp], 0
	jle	SHORT $LN6@Insert_n@5

; 1189 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);

	mov	ecx, DWORD PTR __Whereoff$83585[ebp]
	shl	ecx, 5
	add	ecx, DWORD PTR __Newvec$83584[ebp]
	mov	edx, DWORD PTR __Count$[ebp]
	shl	edx, 5
	add	ecx, edx
	push	ecx
	mov	eax, DWORD PTR __Whereoff$83585[ebp]
	shl	eax, 5
	add	eax, DWORD PTR __Newvec$83584[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAEXPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@0@Z ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::_Destroy
$LN6@Insert_n@5:

; 1190 : 			this->_Alval.deallocate(_Newvec, _Capacity);

	mov	ecx, DWORD PTR __Capacity$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Newvec$83584[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?deallocate@?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@QAEXPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@I@Z ; std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T>::deallocate

; 1191 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1192 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$?_Insert_n@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@2@IABUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@Z$1
	ret	0
$LN19@Insert_n@5:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Insert_n@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@2@IABUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@Z$1:

; 1193 : 
; 1194 : 			_Count += size();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QBEIXZ ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::size
	add	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Count$[ebp], eax

; 1195 : 			if (_Myfirst != 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	je	SHORT $LN5@Insert_n@5

; 1196 : 				{	// destroy and deallocate old array
; 1197 : 				_Destroy(_Myfirst, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAEXPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@0@Z ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::_Destroy

; 1198 : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+20]
	sub	ecx, DWORD PTR [eax+12]
	sar	ecx, 5
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?deallocate@?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@QAEXPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@I@Z ; std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T>::deallocate
$LN5@Insert_n@5:

; 1199 : 				}
; 1200 : 
; 1201 :  #if _HAS_ITERATOR_DEBUGGING
; 1202 : 			this->_Orphan_all();
; 1203 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1204 : 
; 1205 : 			_Myend = _Newvec + _Capacity;

	mov	ecx, DWORD PTR __Capacity$[ebp]
	shl	ecx, 5
	add	ecx, DWORD PTR __Newvec$83584[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+20], ecx

; 1206 : 			_Mylast = _Newvec + _Count;

	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 5
	add	eax, DWORD PTR __Newvec$83584[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 1207 : 			_Myfirst = _Newvec;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Newvec$83584[ebp]
	mov	DWORD PTR [edx+12], eax
	jmp	$LN16@Insert_n@5
$LN10@Insert_n@5:

; 1208 : 			}
; 1209 : 		else if ((size_type)(_Mylast - _VEC_ITER_BASE(_Where)) < _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	sub	edx, DWORD PTR __Where$[ebp+4]
	sar	edx, 5
	cmp	edx, DWORD PTR __Count$[ebp]
	jae	$LN3@Insert_n@5

; 1210 : 			{	// new stuff spills off end
; 1211 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	esi, DWORD PTR __Val$[ebp]
	mov	ecx, 8
	lea	edi, DWORD PTR __Tmp$83599[ebp]
	rep movsd

; 1212 : 
; 1213 : 			_Umove(_VEC_ITER_BASE(_Where), _Mylast,
; 1214 : 				_VEC_ITER_BASE(_Where) + _Count);	// copy suffix

	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 5
	add	eax, DWORD PTR __Where$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR __Where$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Umove@PAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAEPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU234@00@Z ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::_Umove<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T *>

; 1215 : 
; 1216 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 2

; 1217 : 			_Ufill(_Mylast, _Count - (_Mylast - _VEC_ITER_BASE(_Where)),
; 1218 : 				_Tmp);	// insert new stuff off end

	lea	ecx, DWORD PTR __Tmp$83599[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	sub	eax, DWORD PTR __Where$[ebp+4]
	sar	eax, 5
	mov	ecx, DWORD PTR __Count$[ebp]
	sub	ecx, eax
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Ufill@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAEPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU345@IABU345@@Z ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::_Ufill
	jmp	SHORT $LN21@Insert_n@5
__catch$?_Insert_n@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@2@IABUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@Z$2:

; 1219 : 			_CATCH_ALL
; 1220 : 			_Destroy(_VEC_ITER_BASE(_Where) + _Count, _Mylast + _Count);

	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 5
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+16]
	push	ecx
	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 5
	add	eax, DWORD PTR __Where$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAEXPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@0@Z ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::_Destroy

; 1221 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1222 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$?_Insert_n@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@2@IABUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@Z$3
	ret	0
$LN21@Insert_n@5:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Insert_n@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@2@IABUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@Z$3:

; 1223 : 
; 1224 : 			_Mylast += _Count;

	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 5
	mov	edx, DWORD PTR _this$[ebp]
	add	ecx, DWORD PTR [edx+16]
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+16], ecx

; 1225 : 
; 1226 :  #if _HAS_ITERATOR_DEBUGGING
; 1227 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1228 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1229 : 
; 1230 : 			std::fill(_VEC_ITER_BASE(_Where), _Mylast - _Count,
; 1231 : 				_Tmp);	// insert up to old end

	lea	ecx, DWORD PTR __Tmp$83599[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count$[ebp]
	shl	edx, 5
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	sub	ecx, edx
	push	ecx
	mov	edx, DWORD PTR __Where$[ebp+4]
	push	edx
	call	??$fill@PAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@U123@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@0ABU123@@Z ; std::fill<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T>
	add	esp, 12					; 0000000cH

; 1232 : 			}
; 1233 : 		else

	jmp	SHORT $LN16@Insert_n@5
$LN3@Insert_n@5:

; 1234 : 			{	// new stuff can all be assigned
; 1235 : 			_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	esi, DWORD PTR __Val$[ebp]
	mov	ecx, 8
	lea	edi, DWORD PTR __Tmp$83609[ebp]
	rep movsd

; 1236 : 
; 1237 : 			pointer _Oldend = _Mylast;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR __Oldend$83610[ebp], ecx

; 1238 : 			_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1239 : 				_Mylast);	// copy suffix

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR __Oldend$83610[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count$[ebp]
	shl	edx, 5
	mov	eax, DWORD PTR __Oldend$83610[ebp]
	sub	eax, edx
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Umove@PAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAEPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU234@00@Z ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::_Umove<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T *>
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 1240 : 
; 1241 :  #if _HAS_ITERATOR_DEBUGGING
; 1242 : 			_Orphan_range(_Where._Myptr, _Mylast);
; 1243 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1244 : 
; 1245 : 			_STDEXT _Unchecked_move_backward(_VEC_ITER_BASE(_Where), _Oldend - _Count,
; 1246 : 				_Oldend);	// copy hole

	mov	edx, DWORD PTR __Oldend$83610[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 5
	mov	ecx, DWORD PTR __Oldend$83610[ebp]
	sub	ecx, eax
	push	ecx
	mov	edx, DWORD PTR __Where$[ebp+4]
	push	edx
	call	??$_Unchecked_move_backward@PAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@@stdext@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@00@Z ; stdext::_Unchecked_move_backward<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T *>
	add	esp, 12					; 0000000cH

; 1247 : 			std::fill(_VEC_ITER_BASE(_Where), _VEC_ITER_BASE(_Where) + _Count,
; 1248 : 				_Tmp);	// insert into hole

	lea	eax, DWORD PTR __Tmp$83609[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 5
	add	ecx, DWORD PTR __Where$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR __Where$[ebp+4]
	push	edx
	call	??$fill@PAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@U123@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@0ABU123@@Z ; std::fill<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T>
	add	esp, 12					; 0000000cH
$LN16@Insert_n@5:

; 1249 : 			}
; 1250 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Insert_n@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@2@IABUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-112]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Insert_n@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@2@IABUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Insert_n@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAEXV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@2@IABUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@Z ENDP ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::_Insert_n
PUBLIC	??Y?$_Vector_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::operator+=
; Function compile flags: /Odtp
;	COMDAT ??H?$_Vector_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
__Tmp$ = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Vector_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::operator+, COMDAT
; _this$ = ecx

; 380  : 		{	// return this + integer

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 381  : 		_Myt _Tmp = *this;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR __Tmp$[ebp], ecx
	mov	DWORD PTR __Tmp$[ebp+4], edx

; 382  : 		return (_Tmp += _Off);

	mov	eax, DWORD PTR __Off$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Tmp$[ebp]
	call	??Y?$_Vector_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::operator+=
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 383  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
??H?$_Vector_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::operator+
_TEXT	ENDS
PUBLIC	??Y?$_Vector_iterator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::operator+=
; Function compile flags: /Odtp
;	COMDAT ??H?$_Vector_iterator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
__Tmp$ = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Vector_iterator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::operator+, COMDAT
; _this$ = ecx

; 380  : 		{	// return this + integer

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 381  : 		_Myt _Tmp = *this;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR __Tmp$[ebp], ecx
	mov	DWORD PTR __Tmp$[ebp+4], edx

; 382  : 		return (_Tmp += _Off);

	mov	eax, DWORD PTR __Off$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Tmp$[ebp]
	call	??Y?$_Vector_iterator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::operator+=
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 383  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
??H?$_Vector_iterator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::operator+
_TEXT	ENDS
PUBLIC	??Y?$_Vector_iterator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::operator+=
; Function compile flags: /Odtp
;	COMDAT ??H?$_Vector_iterator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
__Tmp$ = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Vector_iterator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::operator+, COMDAT
; _this$ = ecx

; 380  : 		{	// return this + integer

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 381  : 		_Myt _Tmp = *this;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR __Tmp$[ebp], ecx
	mov	DWORD PTR __Tmp$[ebp+4], edx

; 382  : 		return (_Tmp += _Off);

	mov	eax, DWORD PTR __Off$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Tmp$[ebp]
	call	??Y?$_Vector_iterator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::operator+=
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 383  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
??H?$_Vector_iterator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::operator+
_TEXT	ENDS
PUBLIC	??Y?$_Vector_iterator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::operator+=
; Function compile flags: /Odtp
;	COMDAT ??H?$_Vector_iterator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
__Tmp$ = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Vector_iterator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::operator+, COMDAT
; _this$ = ecx

; 380  : 		{	// return this + integer

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 381  : 		_Myt _Tmp = *this;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR __Tmp$[ebp], ecx
	mov	DWORD PTR __Tmp$[ebp+4], edx

; 382  : 		return (_Tmp += _Off);

	mov	eax, DWORD PTR __Off$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Tmp$[ebp]
	call	??Y?$_Vector_iterator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::operator+=
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 383  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
??H?$_Vector_iterator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::operator+
_TEXT	ENDS
PUBLIC	??Y?$_Vector_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::operator+=
; Function compile flags: /Odtp
;	COMDAT ??H?$_Vector_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
__Tmp$ = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Vector_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::operator+, COMDAT
; _this$ = ecx

; 380  : 		{	// return this + integer

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 381  : 		_Myt _Tmp = *this;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR __Tmp$[ebp], ecx
	mov	DWORD PTR __Tmp$[ebp+4], edx

; 382  : 		return (_Tmp += _Off);

	mov	eax, DWORD PTR __Off$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Tmp$[ebp]
	call	??Y?$_Vector_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::operator+=
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 383  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
??H?$_Vector_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::operator+
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_fill_n@PAUAnimRange@BaseKeyFrameArray@Ogre@@IU123@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@stdext@@YAXPAUAnimRange@BaseKeyFrameArray@Ogre@@IABU123@AAV?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@Z ; stdext::unchecked_uninitialized_fill_n<Ogre::BaseKeyFrameArray::AnimRange *,unsigned int,Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >
; Function compile flags: /Odtp
;	COMDAT ?_Ufill@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAEPAUAnimRange@BaseKeyFrameArray@Ogre@@PAU345@IABU345@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Ufill@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAEPAUAnimRange@BaseKeyFrameArray@Ogre@@PAU345@IABU345@@Z PROC ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::_Ufill, COMDAT
; _this$ = ecx

; 1253 : 		{	// copy initializing _Count * _Val, using allocator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1254 : 		_STDEXT unchecked_uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??$unchecked_uninitialized_fill_n@PAUAnimRange@BaseKeyFrameArray@Ogre@@IU123@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@stdext@@YAXPAUAnimRange@BaseKeyFrameArray@Ogre@@IABU123@AAV?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@Z ; stdext::unchecked_uninitialized_fill_n<Ogre::BaseKeyFrameArray::AnimRange *,unsigned int,Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >
	add	esp, 16					; 00000010H

; 1255 : 		return (_Ptr + _Count);

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Ptr$[ebp]
	lea	eax, DWORD PTR [edx+ecx*8]

; 1256 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?_Ufill@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAEPAUAnimRange@BaseKeyFrameArray@Ogre@@PAU345@IABU345@@Z ENDP ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::_Ufill
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_fill_n@PAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@IU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@stdext@@YAXPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@IABU123@AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@Z ; stdext::unchecked_uninitialized_fill_n<Ogre::KeyFrameArray<float>::KEYFRAME_T *,unsigned int,Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >
; Function compile flags: /Odtp
;	COMDAT ?_Ufill@?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAEPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU345@IABU345@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Ufill@?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAEPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU345@IABU345@@Z PROC ; std::vector<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::_Ufill, COMDAT
; _this$ = ecx

; 1253 : 		{	// copy initializing _Count * _Val, using allocator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1254 : 		_STDEXT unchecked_uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??$unchecked_uninitialized_fill_n@PAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@IU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@stdext@@YAXPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@IABU123@AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@Z ; stdext::unchecked_uninitialized_fill_n<Ogre::KeyFrameArray<float>::KEYFRAME_T *,unsigned int,Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >
	add	esp, 16					; 00000010H

; 1255 : 		return (_Ptr + _Count);

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Ptr$[ebp]
	lea	eax, DWORD PTR [edx+ecx*8]

; 1256 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?_Ufill@?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAEPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU345@IABU345@@Z ENDP ; std::vector<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::_Ufill
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_fill_n@PAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@IU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@stdext@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@IABU123@AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@Z ; stdext::unchecked_uninitialized_fill_n<Ogre::KeyFrameArray<float>::CONTROL_POINT_T *,unsigned int,Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >
; Function compile flags: /Odtp
;	COMDAT ?_Ufill@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAEPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU345@IABU345@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Ufill@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAEPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU345@IABU345@@Z PROC ; std::vector<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::_Ufill, COMDAT
; _this$ = ecx

; 1253 : 		{	// copy initializing _Count * _Val, using allocator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1254 : 		_STDEXT unchecked_uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??$unchecked_uninitialized_fill_n@PAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@IU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@stdext@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@IABU123@AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@Z ; stdext::unchecked_uninitialized_fill_n<Ogre::KeyFrameArray<float>::CONTROL_POINT_T *,unsigned int,Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >
	add	esp, 16					; 00000010H

; 1255 : 		return (_Ptr + _Count);

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Ptr$[ebp]
	lea	eax, DWORD PTR [edx+ecx*8]

; 1256 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?_Ufill@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAEPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU345@IABU345@@Z ENDP ; std::vector<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::_Ufill
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_fill_n@PAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@IU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@stdext@@YAXPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@IABU123@AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@Z ; stdext::unchecked_uninitialized_fill_n<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T *,unsigned int,Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >
; Function compile flags: /Odtp
;	COMDAT ?_Ufill@?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAEPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU345@IABU345@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Ufill@?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAEPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU345@IABU345@@Z PROC ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::_Ufill, COMDAT
; _this$ = ecx

; 1253 : 		{	// copy initializing _Count * _Val, using allocator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1254 : 		_STDEXT unchecked_uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??$unchecked_uninitialized_fill_n@PAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@IU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@stdext@@YAXPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@IABU123@AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@Z ; stdext::unchecked_uninitialized_fill_n<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T *,unsigned int,Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >
	add	esp, 16					; 00000010H

; 1255 : 		return (_Ptr + _Count);

	mov	eax, DWORD PTR __Count$[ebp]
	imul	eax, 20					; 00000014H
	add	eax, DWORD PTR __Ptr$[ebp]

; 1256 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?_Ufill@?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAEPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU345@IABU345@@Z ENDP ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::_Ufill
_TEXT	ENDS
PUBLIC	??$unchecked_uninitialized_fill_n@PAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@IU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@stdext@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@IABU123@AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@Z ; stdext::unchecked_uninitialized_fill_n<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T *,unsigned int,Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >
; Function compile flags: /Odtp
;	COMDAT ?_Ufill@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAEPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU345@IABU345@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Ufill@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAEPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU345@IABU345@@Z PROC ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::_Ufill, COMDAT
; _this$ = ecx

; 1253 : 		{	// copy initializing _Count * _Val, using allocator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1254 : 		_STDEXT unchecked_uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??$unchecked_uninitialized_fill_n@PAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@IU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@stdext@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@IABU123@AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@Z ; stdext::unchecked_uninitialized_fill_n<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T *,unsigned int,Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >
	add	esp, 16					; 00000010H

; 1255 : 		return (_Ptr + _Count);

	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 5
	add	eax, DWORD PTR __Ptr$[ebp]

; 1256 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?_Ufill@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAEPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU345@IABU345@@Z ENDP ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::_Ufill
_TEXT	ENDS
PUBLIC	??Y?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::operator+=
; Function compile flags: /Odtp
;	COMDAT ??Y?$_Vector_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
??Y?$_Vector_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::operator+=, COMDAT
; _this$ = ecx

; 374  : 		{	// increment by integer

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 375  : 		(*(_Mybase *)this) += _Off;

	mov	eax, DWORD PTR __Off$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??Y?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::operator+=

; 376  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 377  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??Y?$_Vector_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::operator+=
_TEXT	ENDS
PUBLIC	??Y?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::operator+=
; Function compile flags: /Odtp
;	COMDAT ??Y?$_Vector_iterator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
??Y?$_Vector_iterator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::operator+=, COMDAT
; _this$ = ecx

; 374  : 		{	// increment by integer

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 375  : 		(*(_Mybase *)this) += _Off;

	mov	eax, DWORD PTR __Off$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??Y?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::operator+=

; 376  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 377  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??Y?$_Vector_iterator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::operator+=
_TEXT	ENDS
PUBLIC	??Y?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::operator+=
; Function compile flags: /Odtp
;	COMDAT ??Y?$_Vector_iterator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
??Y?$_Vector_iterator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::operator+=, COMDAT
; _this$ = ecx

; 374  : 		{	// increment by integer

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 375  : 		(*(_Mybase *)this) += _Off;

	mov	eax, DWORD PTR __Off$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??Y?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::operator+=

; 376  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 377  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??Y?$_Vector_iterator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::operator+=
_TEXT	ENDS
PUBLIC	??Y?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::operator+=
; Function compile flags: /Odtp
;	COMDAT ??Y?$_Vector_iterator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
??Y?$_Vector_iterator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::operator+=, COMDAT
; _this$ = ecx

; 374  : 		{	// increment by integer

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 375  : 		(*(_Mybase *)this) += _Off;

	mov	eax, DWORD PTR __Off$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??Y?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::operator+=

; 376  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 377  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??Y?$_Vector_iterator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::operator+=
_TEXT	ENDS
PUBLIC	??Y?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::operator+=
; Function compile flags: /Odtp
;	COMDAT ??Y?$_Vector_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
??Y?$_Vector_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::operator+=, COMDAT
; _this$ = ecx

; 374  : 		{	// increment by integer

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 375  : 		(*(_Mybase *)this) += _Off;

	mov	eax, DWORD PTR __Off$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??Y?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::operator+=

; 376  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 377  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??Y?$_Vector_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::operator+=
_TEXT	ENDS
PUBLIC	?_Getmycont@_Iterator_base_aux@std@@QBEPBV_Container_base_aux@2@XZ ; std::_Iterator_base_aux::_Getmycont
; Function compile flags: /Odtp
;	COMDAT ??Y?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
??Y?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::operator+=, COMDAT
; _this$ = ecx

; 159  : 		{	// increment by integer

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 160  : 		_SCL_SECURE_VALIDATE(this->_Has_container());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Has_container@_Iterator_base_aux@std@@QBE_NXZ ; std::_Iterator_base_aux::_Has_container
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN3@operator@60
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN3@operator@60:

; 161  : 		_SCL_SECURE_VALIDATE_RANGE(

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR __Off$[ebp]
	lea	esi, DWORD PTR [edx+eax*8]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getmycont@_Iterator_base_aux@std@@QBEPBV_Container_base_aux@2@XZ ; std::_Iterator_base_aux::_Getmycont
	cmp	esi, DWORD PTR [eax+16]
	ja	SHORT $LN1@operator@60
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR __Off$[ebp]
	lea	esi, DWORD PTR [edx+eax*8]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getmycont@_Iterator_base_aux@std@@QBEPBV_Container_base_aux@2@XZ ; std::_Iterator_base_aux::_Getmycont
	cmp	esi, DWORD PTR [eax+12]
	jae	SHORT $LN2@operator@60
$LN1@operator@60:

; 162  : 			_Myptr + _Off <= ((_Myvec *)(this->_Getmycont()))->_Mylast &&
; 163  : 			_Myptr + _Off >= ((_Myvec *)(this->_Getmycont()))->_Myfirst);

	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@operator@60:

; 164  : 		_Myptr += _Off;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR __Off$[ebp]
	lea	ecx, DWORD PTR [edx+eax*8]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 165  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 166  : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
??Y?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::operator+=
_TEXT	ENDS
PUBLIC	?_Getcont@_Aux_cont@std@@QBEPBV_Container_base_aux@2@XZ ; std::_Aux_cont::_Getcont
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ?_Getmycont@_Iterator_base_aux@std@@QBEPBV_Container_base_aux@2@XZ
_TEXT	SEGMENT
tv67 = -8						; size = 4
_this$ = -4						; size = 4
?_Getmycont@_Iterator_base_aux@std@@QBEPBV_Container_base_aux@2@XZ PROC ; std::_Iterator_base_aux::_Getmycont, COMDAT
; _this$ = ecx

; 457  : 		{	// Go through the aux object to get the container

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 458  : 		return _Myaux ? _Myaux->_Getcont() : 0;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN3@Getmycont
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?_Getcont@_Aux_cont@std@@QBEPBV_Container_base_aux@2@XZ ; std::_Aux_cont::_Getcont
	mov	DWORD PTR tv67[ebp], eax
	jmp	SHORT $LN4@Getmycont
$LN3@Getmycont:
	mov	DWORD PTR tv67[ebp], 0
$LN4@Getmycont:
	mov	eax, DWORD PTR tv67[ebp]

; 459  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Getmycont@_Iterator_base_aux@std@@QBEPBV_Container_base_aux@2@XZ ENDP ; std::_Iterator_base_aux::_Getmycont
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Getcont@_Aux_cont@std@@QBEPBV_Container_base_aux@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Getcont@_Aux_cont@std@@QBEPBV_Container_base_aux@2@XZ PROC ; std::_Aux_cont::_Getcont, COMDAT
; _this$ = ecx

; 368  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 369  : 		return _Mycontainer;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 370  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Getcont@_Aux_cont@std@@QBEPBV_Container_base_aux@2@XZ ENDP ; std::_Aux_cont::_Getcont
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ??Y?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
??Y?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::operator+=, COMDAT
; _this$ = ecx

; 159  : 		{	// increment by integer

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 160  : 		_SCL_SECURE_VALIDATE(this->_Has_container());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Has_container@_Iterator_base_aux@std@@QBE_NXZ ; std::_Iterator_base_aux::_Has_container
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN3@operator@61
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN3@operator@61:

; 161  : 		_SCL_SECURE_VALIDATE_RANGE(

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR __Off$[ebp]
	lea	esi, DWORD PTR [edx+eax*8]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getmycont@_Iterator_base_aux@std@@QBEPBV_Container_base_aux@2@XZ ; std::_Iterator_base_aux::_Getmycont
	cmp	esi, DWORD PTR [eax+16]
	ja	SHORT $LN1@operator@61
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR __Off$[ebp]
	lea	esi, DWORD PTR [edx+eax*8]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getmycont@_Iterator_base_aux@std@@QBEPBV_Container_base_aux@2@XZ ; std::_Iterator_base_aux::_Getmycont
	cmp	esi, DWORD PTR [eax+12]
	jae	SHORT $LN2@operator@61
$LN1@operator@61:

; 162  : 			_Myptr + _Off <= ((_Myvec *)(this->_Getmycont()))->_Mylast &&
; 163  : 			_Myptr + _Off >= ((_Myvec *)(this->_Getmycont()))->_Myfirst);

	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@operator@61:

; 164  : 		_Myptr += _Off;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR __Off$[ebp]
	lea	ecx, DWORD PTR [edx+eax*8]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 165  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 166  : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
??Y?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::operator+=
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??Y?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
??Y?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::operator+=, COMDAT
; _this$ = ecx

; 159  : 		{	// increment by integer

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 160  : 		_SCL_SECURE_VALIDATE(this->_Has_container());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Has_container@_Iterator_base_aux@std@@QBE_NXZ ; std::_Iterator_base_aux::_Has_container
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN3@operator@62
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN3@operator@62:

; 161  : 		_SCL_SECURE_VALIDATE_RANGE(

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR __Off$[ebp]
	lea	esi, DWORD PTR [edx+eax*8]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getmycont@_Iterator_base_aux@std@@QBEPBV_Container_base_aux@2@XZ ; std::_Iterator_base_aux::_Getmycont
	cmp	esi, DWORD PTR [eax+16]
	ja	SHORT $LN1@operator@62
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR __Off$[ebp]
	lea	esi, DWORD PTR [edx+eax*8]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getmycont@_Iterator_base_aux@std@@QBEPBV_Container_base_aux@2@XZ ; std::_Iterator_base_aux::_Getmycont
	cmp	esi, DWORD PTR [eax+12]
	jae	SHORT $LN2@operator@62
$LN1@operator@62:

; 162  : 			_Myptr + _Off <= ((_Myvec *)(this->_Getmycont()))->_Mylast &&
; 163  : 			_Myptr + _Off >= ((_Myvec *)(this->_Getmycont()))->_Myfirst);

	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@operator@62:

; 164  : 		_Myptr += _Off;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR __Off$[ebp]
	lea	ecx, DWORD PTR [edx+eax*8]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 165  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 166  : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
??Y?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::operator+=
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??Y?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
??Y?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::operator+=, COMDAT
; _this$ = ecx

; 159  : 		{	// increment by integer

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 160  : 		_SCL_SECURE_VALIDATE(this->_Has_container());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Has_container@_Iterator_base_aux@std@@QBE_NXZ ; std::_Iterator_base_aux::_Has_container
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN3@operator@63
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN3@operator@63:

; 161  : 		_SCL_SECURE_VALIDATE_RANGE(

	mov	esi, DWORD PTR __Off$[ebp]
	imul	esi, 20					; 00000014H
	mov	ecx, DWORD PTR _this$[ebp]
	add	esi, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getmycont@_Iterator_base_aux@std@@QBEPBV_Container_base_aux@2@XZ ; std::_Iterator_base_aux::_Getmycont
	cmp	esi, DWORD PTR [eax+16]
	ja	SHORT $LN1@operator@63
	mov	esi, DWORD PTR __Off$[ebp]
	imul	esi, 20					; 00000014H
	mov	edx, DWORD PTR _this$[ebp]
	add	esi, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getmycont@_Iterator_base_aux@std@@QBEPBV_Container_base_aux@2@XZ ; std::_Iterator_base_aux::_Getmycont
	cmp	esi, DWORD PTR [eax+12]
	jae	SHORT $LN2@operator@63
$LN1@operator@63:

; 162  : 			_Myptr + _Off <= ((_Myvec *)(this->_Getmycont()))->_Mylast &&
; 163  : 			_Myptr + _Off >= ((_Myvec *)(this->_Getmycont()))->_Myfirst);

	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@operator@63:

; 164  : 		_Myptr += _Off;

	mov	eax, DWORD PTR __Off$[ebp]
	imul	eax, 20					; 00000014H
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], eax

; 165  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 166  : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
??Y?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::operator+=
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??Y?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
??Y?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::operator+=, COMDAT
; _this$ = ecx

; 159  : 		{	// increment by integer

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 160  : 		_SCL_SECURE_VALIDATE(this->_Has_container());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Has_container@_Iterator_base_aux@std@@QBE_NXZ ; std::_Iterator_base_aux::_Has_container
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN3@operator@64
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN3@operator@64:

; 161  : 		_SCL_SECURE_VALIDATE_RANGE(

	mov	esi, DWORD PTR __Off$[ebp]
	shl	esi, 5
	mov	ecx, DWORD PTR _this$[ebp]
	add	esi, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getmycont@_Iterator_base_aux@std@@QBEPBV_Container_base_aux@2@XZ ; std::_Iterator_base_aux::_Getmycont
	cmp	esi, DWORD PTR [eax+16]
	ja	SHORT $LN1@operator@64
	mov	esi, DWORD PTR __Off$[ebp]
	shl	esi, 5
	mov	edx, DWORD PTR _this$[ebp]
	add	esi, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getmycont@_Iterator_base_aux@std@@QBEPBV_Container_base_aux@2@XZ ; std::_Iterator_base_aux::_Getmycont
	cmp	esi, DWORD PTR [eax+12]
	jae	SHORT $LN2@operator@64
$LN1@operator@64:

; 162  : 			_Myptr + _Off <= ((_Myvec *)(this->_Getmycont()))->_Mylast &&
; 163  : 			_Myptr + _Off >= ((_Myvec *)(this->_Getmycont()))->_Myfirst);

	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@operator@64:

; 164  : 		_Myptr += _Off;

	mov	eax, DWORD PTR __Off$[ebp]
	shl	eax, 5
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+4]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], eax

; 165  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 166  : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
??Y?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::operator+=
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PBUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@PBU123@0PAU123@AAV?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Ogre::BaseKeyFrameArray::AnimRange const *,Ogre::BaseKeyFrameArray::AnimRange *,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >
PUBLIC	??$_Checked_base@V?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@@std@@YAPBUAnimRange@BaseKeyFrameArray@Ogre@@AAV?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> > >
PUBLIC	??$_Ptr_cat@V?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@PAUAnimRange@BaseKeyFrameArray@Ogre@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@0@AAPAUAnimRange@BaseKeyFrameArray@Ogre@@@Z ; std::_Ptr_cat<std::_Vector_const_iterator<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >,Ogre::BaseKeyFrameArray::AnimRange *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@PAUAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@2@@stdext@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@V?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@0PAU123@AAV?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@5@@Z
_TEXT	SEGMENT
$T98057 = -2						; size = 1
$T98056 = -1						; size = 1
__First$ = 8						; size = 8
__Last$ = 16						; size = 8
__Dest$ = 24						; size = 4
__Al$ = 28						; size = 4
??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@PAUAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@2@@stdext@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@V?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@0PAU123@AAV?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@5@@Z PROC ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >,Ogre::BaseKeyFrameArray::AnimRange *,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T98056[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@V?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@PAUAnimRange@BaseKeyFrameArray@Ogre@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@0@AAPAUAnimRange@BaseKeyFrameArray@Ogre@@@Z ; std::_Ptr_cat<std::_Vector_const_iterator<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >,Ogre::BaseKeyFrameArray::AnimRange *>
	add	esp, 8
	mov	BYTE PTR $T98057[ebp], al
	movzx	eax, BYTE PTR $T98056[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T98057[ebp]
	push	ecx
	mov	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@V?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@@std@@YAPBUAnimRange@BaseKeyFrameArray@Ogre@@AAV?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> > >
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@V?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@@std@@YAPBUAnimRange@BaseKeyFrameArray@Ogre@@AAV?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> > >
	add	esp, 4
	push	eax
	call	??$_Uninit_copy@PBUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@PBU123@0PAU123@AAV?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Ogre::BaseKeyFrameArray::AnimRange const *,Ogre::BaseKeyFrameArray::AnimRange *,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >
	add	esp, 24					; 00000018H

; 823  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@PAUAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@2@@stdext@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@V?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@0PAU123@AAV?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@5@@Z ENDP ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >,Ogre::BaseKeyFrameArray::AnimRange *,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PBUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PBU123@0PAU123@AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Ogre::KeyFrameArray<float>::KEYFRAME_T const *,Ogre::KeyFrameArray<float>::KEYFRAME_T *,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >
PUBLIC	??$_Checked_base@V?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@@std@@YAPBUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@AAV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> > >
PUBLIC	??$_Ptr_cat@V?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@PAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@0@AAPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@Z ; std::_Ptr_cat<std::_Vector_const_iterator<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >,Ogre::KeyFrameArray<float>::KEYFRAME_T *>
; Function compile flags: /Odtp
;	COMDAT ??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@PAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@2@@stdext@@YAPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@0PAU123@AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@5@@Z
_TEXT	SEGMENT
$T98061 = -2						; size = 1
$T98060 = -1						; size = 1
__First$ = 8						; size = 8
__Last$ = 16						; size = 8
__Dest$ = 24						; size = 4
__Al$ = 28						; size = 4
??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@PAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@2@@stdext@@YAPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@0PAU123@AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@5@@Z PROC ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >,Ogre::KeyFrameArray<float>::KEYFRAME_T *,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T98060[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@V?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@PAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@0@AAPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@Z ; std::_Ptr_cat<std::_Vector_const_iterator<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >,Ogre::KeyFrameArray<float>::KEYFRAME_T *>
	add	esp, 8
	mov	BYTE PTR $T98061[ebp], al
	movzx	eax, BYTE PTR $T98060[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T98061[ebp]
	push	ecx
	mov	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@V?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@@std@@YAPBUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@AAV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> > >
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@V?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@@std@@YAPBUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@AAV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> > >
	add	esp, 4
	push	eax
	call	??$_Uninit_copy@PBUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PBU123@0PAU123@AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Ogre::KeyFrameArray<float>::KEYFRAME_T const *,Ogre::KeyFrameArray<float>::KEYFRAME_T *,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >
	add	esp, 24					; 00000018H

; 823  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@PAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@2@@stdext@@YAPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@0PAU123@AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@5@@Z ENDP ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >,Ogre::KeyFrameArray<float>::KEYFRAME_T *,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PBUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PBU123@0PAU123@AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Ogre::KeyFrameArray<float>::CONTROL_POINT_T const *,Ogre::KeyFrameArray<float>::CONTROL_POINT_T *,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >
PUBLIC	??$_Checked_base@V?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@@std@@YAPBUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@AAV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> > >
PUBLIC	??$_Ptr_cat@V?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@PAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@0@AAPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@Z ; std::_Ptr_cat<std::_Vector_const_iterator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >,Ogre::KeyFrameArray<float>::CONTROL_POINT_T *>
; Function compile flags: /Odtp
;	COMDAT ??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@PAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@2@@stdext@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@0PAU123@AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@5@@Z
_TEXT	SEGMENT
$T98065 = -2						; size = 1
$T98064 = -1						; size = 1
__First$ = 8						; size = 8
__Last$ = 16						; size = 8
__Dest$ = 24						; size = 4
__Al$ = 28						; size = 4
??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@PAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@2@@stdext@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@0PAU123@AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@5@@Z PROC ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >,Ogre::KeyFrameArray<float>::CONTROL_POINT_T *,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T98064[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@V?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@PAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@0@AAPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@Z ; std::_Ptr_cat<std::_Vector_const_iterator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >,Ogre::KeyFrameArray<float>::CONTROL_POINT_T *>
	add	esp, 8
	mov	BYTE PTR $T98065[ebp], al
	movzx	eax, BYTE PTR $T98064[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T98065[ebp]
	push	ecx
	mov	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@V?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@@std@@YAPBUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@AAV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> > >
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@V?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@@std@@YAPBUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@AAV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> > >
	add	esp, 4
	push	eax
	call	??$_Uninit_copy@PBUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PBU123@0PAU123@AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Ogre::KeyFrameArray<float>::CONTROL_POINT_T const *,Ogre::KeyFrameArray<float>::CONTROL_POINT_T *,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >
	add	esp, 24					; 00000018H

; 823  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@PAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@2@@stdext@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@0PAU123@AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@5@@Z ENDP ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >,Ogre::KeyFrameArray<float>::CONTROL_POINT_T *,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PBUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PBU123@0PAU123@AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T const *,Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T *,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >
PUBLIC	??$_Checked_base@V?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@@std@@YAPBUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@AAV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> > >
PUBLIC	??$_Ptr_cat@V?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@PAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@0@AAPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@Z ; std::_Ptr_cat<std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >,Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T *>
; Function compile flags: /Odtp
;	COMDAT ??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@PAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@2@@stdext@@YAPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@0PAU123@AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@5@@Z
_TEXT	SEGMENT
$T98069 = -2						; size = 1
$T98068 = -1						; size = 1
__First$ = 8						; size = 8
__Last$ = 16						; size = 8
__Dest$ = 24						; size = 4
__Al$ = 28						; size = 4
??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@PAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@2@@stdext@@YAPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@0PAU123@AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@5@@Z PROC ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >,Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T *,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T98068[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@V?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@PAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@0@AAPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@Z ; std::_Ptr_cat<std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >,Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T *>
	add	esp, 8
	mov	BYTE PTR $T98069[ebp], al
	movzx	eax, BYTE PTR $T98068[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T98069[ebp]
	push	ecx
	mov	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@V?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@@std@@YAPBUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@AAV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> > >
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@V?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@@std@@YAPBUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@AAV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> > >
	add	esp, 4
	push	eax
	call	??$_Uninit_copy@PBUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PBU123@0PAU123@AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T const *,Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T *,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >
	add	esp, 24					; 00000018H

; 823  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@PAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@2@@stdext@@YAPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@0PAU123@AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@5@@Z ENDP ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >,Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T *,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PBUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PBU123@0PAU123@AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T const *,Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T *,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >
PUBLIC	??$_Checked_base@V?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@@std@@YAPBUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@AAV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> > >
PUBLIC	??$_Ptr_cat@V?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@PAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@0@AAPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@Z ; std::_Ptr_cat<std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >,Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T *>
; Function compile flags: /Odtp
;	COMDAT ??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@PAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@2@@stdext@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@0PAU123@AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@5@@Z
_TEXT	SEGMENT
$T98073 = -2						; size = 1
$T98072 = -1						; size = 1
__First$ = 8						; size = 8
__Last$ = 16						; size = 8
__Dest$ = 24						; size = 4
__Al$ = 28						; size = 4
??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@PAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@2@@stdext@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@0PAU123@AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@5@@Z PROC ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >,Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T *,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T98072[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@V?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@PAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@0@AAPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@Z ; std::_Ptr_cat<std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >,Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T *>
	add	esp, 8
	mov	BYTE PTR $T98073[ebp], al
	movzx	eax, BYTE PTR $T98072[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T98073[ebp]
	push	ecx
	mov	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@V?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@@std@@YAPBUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@AAV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> > >
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@V?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@@std@@YAPBUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@AAV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> > >
	add	esp, 4
	push	eax
	call	??$_Uninit_copy@PBUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PBU123@0PAU123@AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T const *,Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T *,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >
	add	esp, 24					; 00000018H

; 823  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@PAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@2@@stdext@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@0PAU123@AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@5@@Z ENDP ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >,Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T *,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PBQAVShaderContext@Ogre@@PAPAV12@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@YAPAPAVShaderContext@Ogre@@PBQAV12@0PAPAV12@AAV?$allocator@PAVShaderContext@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Ogre::ShaderContext * const *,Ogre::ShaderContext * *,std::allocator<Ogre::ShaderContext *> >
PUBLIC	??$_Checked_base@V?$_Vector_const_iterator@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@@std@@YAPBQAVShaderContext@Ogre@@AAV?$_Vector_const_iterator@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::ShaderContext *,std::allocator<Ogre::ShaderContext *> > >
PUBLIC	??$_Ptr_cat@V?$_Vector_const_iterator@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@PAPAVShaderContext@Ogre@@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@0@AAPAPAVShaderContext@Ogre@@@Z ; std::_Ptr_cat<std::_Vector_const_iterator<Ogre::ShaderContext *,std::allocator<Ogre::ShaderContext *> >,Ogre::ShaderContext * *>
; Function compile flags: /Odtp
;	COMDAT ??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@PAPAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@2@@stdext@@YAPAPAVShaderContext@Ogre@@V?$_Vector_const_iterator@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@0PAPAV12@AAV?$allocator@PAVShaderContext@Ogre@@@4@@Z
_TEXT	SEGMENT
$T98077 = -2						; size = 1
$T98076 = -1						; size = 1
__First$ = 8						; size = 8
__Last$ = 16						; size = 8
__Dest$ = 24						; size = 4
__Al$ = 28						; size = 4
??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@PAPAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@2@@stdext@@YAPAPAVShaderContext@Ogre@@V?$_Vector_const_iterator@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@0PAPAV12@AAV?$allocator@PAVShaderContext@Ogre@@@4@@Z PROC ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<Ogre::ShaderContext *,std::allocator<Ogre::ShaderContext *> >,Ogre::ShaderContext * *,std::allocator<Ogre::ShaderContext *> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T98076[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@V?$_Vector_const_iterator@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@PAPAVShaderContext@Ogre@@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@0@AAPAPAVShaderContext@Ogre@@@Z ; std::_Ptr_cat<std::_Vector_const_iterator<Ogre::ShaderContext *,std::allocator<Ogre::ShaderContext *> >,Ogre::ShaderContext * *>
	add	esp, 8
	mov	BYTE PTR $T98077[ebp], al
	movzx	eax, BYTE PTR $T98076[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T98077[ebp]
	push	ecx
	mov	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@V?$_Vector_const_iterator@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@@std@@YAPBQAVShaderContext@Ogre@@AAV?$_Vector_const_iterator@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::ShaderContext *,std::allocator<Ogre::ShaderContext *> > >
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@V?$_Vector_const_iterator@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@@std@@YAPBQAVShaderContext@Ogre@@AAV?$_Vector_const_iterator@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::ShaderContext *,std::allocator<Ogre::ShaderContext *> > >
	add	esp, 4
	push	eax
	call	??$_Uninit_copy@PBQAVShaderContext@Ogre@@PAPAV12@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@YAPAPAVShaderContext@Ogre@@PBQAV12@0PAPAV12@AAV?$allocator@PAVShaderContext@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Ogre::ShaderContext * const *,Ogre::ShaderContext * *,std::allocator<Ogre::ShaderContext *> >
	add	esp, 24					; 00000018H

; 823  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@PAPAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@2@@stdext@@YAPAPAVShaderContext@Ogre@@V?$_Vector_const_iterator@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@0PAPAV12@AAV?$allocator@PAVShaderContext@Ogre@@@4@@Z ENDP ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<Ogre::ShaderContext *,std::allocator<Ogre::ShaderContext *> >,Ogre::ShaderContext * *,std::allocator<Ogre::ShaderContext *> >
_TEXT	ENDS
PUBLIC	??$_Checked_base@PAPAVShaderContext@Ogre@@@std@@YAPAPAVShaderContext@Ogre@@AAPAPAV12@U_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<Ogre::ShaderContext * *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Checked_base@PAPAVShaderContext@Ogre@@@std@@YAPAPAVShaderContext@Ogre@@AAPAPAV12@@Z
_TEXT	SEGMENT
__Base_tag$ = -1					; size = 1
__It$ = 8						; size = 4
??$_Checked_base@PAPAVShaderContext@Ogre@@@std@@YAPAPAVShaderContext@Ogre@@AAPAPAV12@@Z PROC ; std::_Checked_base<Ogre::ShaderContext * *>, COMDAT

; 1163 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1164 : 		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
; 1165 : 		return _Checked_base(_It, _Base_tag);

	movzx	eax, BYTE PTR __Base_tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR __It$[ebp]
	push	ecx
	call	??$_Checked_base@PAPAVShaderContext@Ogre@@@std@@YAPAPAVShaderContext@Ogre@@AAPAPAV12@U_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<Ogre::ShaderContext * *>
	add	esp, 8

; 1166 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Checked_base@PAPAVShaderContext@Ogre@@@std@@YAPAPAVShaderContext@Ogre@@AAPAPAV12@@Z ENDP ; std::_Checked_base<Ogre::ShaderContext * *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Iter_random@PAPAVShaderContext@Ogre@@PAPAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVShaderContext@Ogre@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAPAVShaderContext@Ogre@@PAPAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVShaderContext@Ogre@@0@Z PROC ; std::_Iter_random<Ogre::ShaderContext * *,Ogre::ShaderContext * *>, COMDAT

; 993  : 	{	// return category from iterator argument

	push	ebp
	mov	ebp, esp
	push	ecx

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 998  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Iter_random@PAPAVShaderContext@Ogre@@PAPAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVShaderContext@Ogre@@0@Z ENDP ; std::_Iter_random<Ogre::ShaderContext * *,Ogre::ShaderContext * *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAPAVShaderContext@Ogre@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVShaderContext@Ogre@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAPAVShaderContext@Ogre@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVShaderContext@Ogre@@0@Z PROC ; std::_Ptr_cat<Ogre::ShaderContext * *,Ogre::ShaderContext * *>, COMDAT

; 1509 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 1512 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Ptr_cat@PAPAVShaderContext@Ogre@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVShaderContext@Ogre@@0@Z ENDP ; std::_Ptr_cat<Ogre::ShaderContext * *,Ogre::ShaderContext * *>
_TEXT	ENDS
EXTRN	__imp__memmove_s:PROC
; Function compile flags: /Odtp
;	COMDAT ??$_Copy_opt@PAPAVShaderContext@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@@std@@YAPAPAVShaderContext@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Off$ = -8						; size = 4
__Result$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAPAVShaderContext@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@@std@@YAPAPAVShaderContext@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<Ogre::ShaderContext * *,Ogre::ShaderContext * *,std::random_access_iterator_tag>, COMDAT

; 2494 : 	{	// copy [_First, _Last) to [_Dest, ...), pointers to scalars

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 2495 : 
; 2496 :  #if _HAS_ITERATOR_DEBUGGING
; 2497 : 	_DEBUG_RANGE(_First, _Last);
; 2498 : 	if (_First != _Last)
; 2499 : 		_DEBUG_POINTER(_Dest);
; 2500 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2501 : 
; 2502 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 2
	mov	DWORD PTR __Off$[ebp], eax

; 2503 : 	// if _OutIt is range checked, this will make sure there is enough space for the memmove
; 2504 : 	_OutIt _Result = _Dest + _Off;

	mov	ecx, DWORD PTR __Off$[ebp]
	mov	edx, DWORD PTR __Dest$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR __Result$[ebp], eax

; 2505 : 	if (_Off > 0)

	cmp	DWORD PTR __Off$[ebp], 0
	jle	SHORT $LN1@Copy_opt

; 2506 : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Off * sizeof (*_First), &*_First, _Off * sizeof (*_First));

	mov	ecx, DWORD PTR __Off$[ebp]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	eax, DWORD PTR __Off$[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN1@Copy_opt:

; 2507 : 	return _Result;

	mov	eax, DWORD PTR __Result$[ebp]

; 2508 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Copy_opt@PAPAVShaderContext@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@@std@@YAPAPAVShaderContext@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<Ogre::ShaderContext * *,Ogre::ShaderContext * *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PAPAVShaderContext@Ogre@@PAPAV12@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@YAPAPAVShaderContext@Ogre@@PAPAV12@00AAV?$allocator@PAVShaderContext@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Ogre::ShaderContext * *,Ogre::ShaderContext * *,std::allocator<Ogre::ShaderContext *> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_copy@PAPAVShaderContext@Ogre@@PAPAV12@V?$allocator@PAVShaderContext@Ogre@@@std@@@stdext@@YAPAPAVShaderContext@Ogre@@PAPAV12@00AAV?$allocator@PAVShaderContext@Ogre@@@std@@@Z
_TEXT	SEGMENT
$T98089 = -2						; size = 1
$T98088 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@PAPAVShaderContext@Ogre@@PAPAV12@V?$allocator@PAVShaderContext@Ogre@@@std@@@stdext@@YAPAPAVShaderContext@Ogre@@PAPAV12@00AAV?$allocator@PAVShaderContext@Ogre@@@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<Ogre::ShaderContext * *,Ogre::ShaderContext * *,std::allocator<Ogre::ShaderContext *> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T98088[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAPAVShaderContext@Ogre@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVShaderContext@Ogre@@0@Z ; std::_Ptr_cat<Ogre::ShaderContext * *,Ogre::ShaderContext * *>
	add	esp, 8
	mov	BYTE PTR $T98089[ebp], al
	movzx	eax, BYTE PTR $T98088[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T98089[ebp]
	push	ecx
	mov	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@PAPAVShaderContext@Ogre@@@std@@YAPAPAVShaderContext@Ogre@@AAPAPAV12@@Z ; std::_Checked_base<Ogre::ShaderContext * *>
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@PAPAVShaderContext@Ogre@@@std@@YAPAPAVShaderContext@Ogre@@AAPAPAV12@@Z ; std::_Checked_base<Ogre::ShaderContext * *>
	add	esp, 4
	push	eax
	call	??$_Uninit_copy@PAPAVShaderContext@Ogre@@PAPAV12@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@YAPAPAVShaderContext@Ogre@@PAPAV12@00AAV?$allocator@PAVShaderContext@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Ogre::ShaderContext * *,Ogre::ShaderContext * *,std::allocator<Ogre::ShaderContext *> >
	add	esp, 24					; 00000018H

; 823  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_copy@PAPAVShaderContext@Ogre@@PAPAV12@V?$allocator@PAVShaderContext@Ogre@@@std@@@stdext@@YAPAPAVShaderContext@Ogre@@PAPAV12@00AAV?$allocator@PAVShaderContext@Ogre@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<Ogre::ShaderContext * *,Ogre::ShaderContext * *,std::allocator<Ogre::ShaderContext *> >
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PBUContextQueDesc@Ogre@@PAU12@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@YAPAUContextQueDesc@Ogre@@PBU12@0PAU12@AAV?$allocator@UContextQueDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Ogre::ContextQueDesc const *,Ogre::ContextQueDesc *,std::allocator<Ogre::ContextQueDesc> >
PUBLIC	??$_Checked_base@V?$_Vector_const_iterator@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@@std@@YAPBUContextQueDesc@Ogre@@AAV?$_Vector_const_iterator@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::ContextQueDesc,std::allocator<Ogre::ContextQueDesc> > >
PUBLIC	??$_Ptr_cat@V?$_Vector_const_iterator@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@PAUContextQueDesc@Ogre@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@0@AAPAUContextQueDesc@Ogre@@@Z ; std::_Ptr_cat<std::_Vector_const_iterator<Ogre::ContextQueDesc,std::allocator<Ogre::ContextQueDesc> >,Ogre::ContextQueDesc *>
; Function compile flags: /Odtp
;	COMDAT ??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@PAUContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@2@@stdext@@YAPAUContextQueDesc@Ogre@@V?$_Vector_const_iterator@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@0PAU12@AAV?$allocator@UContextQueDesc@Ogre@@@4@@Z
_TEXT	SEGMENT
$T98093 = -2						; size = 1
$T98092 = -1						; size = 1
__First$ = 8						; size = 8
__Last$ = 16						; size = 8
__Dest$ = 24						; size = 4
__Al$ = 28						; size = 4
??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@PAUContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@2@@stdext@@YAPAUContextQueDesc@Ogre@@V?$_Vector_const_iterator@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@0PAU12@AAV?$allocator@UContextQueDesc@Ogre@@@4@@Z PROC ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<Ogre::ContextQueDesc,std::allocator<Ogre::ContextQueDesc> >,Ogre::ContextQueDesc *,std::allocator<Ogre::ContextQueDesc> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T98092[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@V?$_Vector_const_iterator@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@PAUContextQueDesc@Ogre@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@0@AAPAUContextQueDesc@Ogre@@@Z ; std::_Ptr_cat<std::_Vector_const_iterator<Ogre::ContextQueDesc,std::allocator<Ogre::ContextQueDesc> >,Ogre::ContextQueDesc *>
	add	esp, 8
	mov	BYTE PTR $T98093[ebp], al
	movzx	eax, BYTE PTR $T98092[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T98093[ebp]
	push	ecx
	mov	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@V?$_Vector_const_iterator@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@@std@@YAPBUContextQueDesc@Ogre@@AAV?$_Vector_const_iterator@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::ContextQueDesc,std::allocator<Ogre::ContextQueDesc> > >
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@V?$_Vector_const_iterator@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@@std@@YAPBUContextQueDesc@Ogre@@AAV?$_Vector_const_iterator@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::ContextQueDesc,std::allocator<Ogre::ContextQueDesc> > >
	add	esp, 4
	push	eax
	call	??$_Uninit_copy@PBUContextQueDesc@Ogre@@PAU12@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@YAPAUContextQueDesc@Ogre@@PBU12@0PAU12@AAV?$allocator@UContextQueDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Ogre::ContextQueDesc const *,Ogre::ContextQueDesc *,std::allocator<Ogre::ContextQueDesc> >
	add	esp, 24					; 00000018H

; 823  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@PAUContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@2@@stdext@@YAPAUContextQueDesc@Ogre@@V?$_Vector_const_iterator@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@0PAU12@AAV?$allocator@UContextQueDesc@Ogre@@@4@@Z ENDP ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<Ogre::ContextQueDesc,std::allocator<Ogre::ContextQueDesc> >,Ogre::ContextQueDesc *,std::allocator<Ogre::ContextQueDesc> >
_TEXT	ENDS
PUBLIC	??$_Checked_base@PAUContextQueDesc@Ogre@@@std@@YAPAUContextQueDesc@Ogre@@AAPAU12@U_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<Ogre::ContextQueDesc *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Checked_base@PAUContextQueDesc@Ogre@@@std@@YAPAUContextQueDesc@Ogre@@AAPAU12@@Z
_TEXT	SEGMENT
__Base_tag$ = -1					; size = 1
__It$ = 8						; size = 4
??$_Checked_base@PAUContextQueDesc@Ogre@@@std@@YAPAUContextQueDesc@Ogre@@AAPAU12@@Z PROC ; std::_Checked_base<Ogre::ContextQueDesc *>, COMDAT

; 1163 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1164 : 		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
; 1165 : 		return _Checked_base(_It, _Base_tag);

	movzx	eax, BYTE PTR __Base_tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR __It$[ebp]
	push	ecx
	call	??$_Checked_base@PAUContextQueDesc@Ogre@@@std@@YAPAUContextQueDesc@Ogre@@AAPAU12@U_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<Ogre::ContextQueDesc *>
	add	esp, 8

; 1166 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Checked_base@PAUContextQueDesc@Ogre@@@std@@YAPAUContextQueDesc@Ogre@@AAPAU12@@Z ENDP ; std::_Checked_base<Ogre::ContextQueDesc *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Iter_random@PAUContextQueDesc@Ogre@@PAU12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUContextQueDesc@Ogre@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAUContextQueDesc@Ogre@@PAU12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUContextQueDesc@Ogre@@0@Z PROC ; std::_Iter_random<Ogre::ContextQueDesc *,Ogre::ContextQueDesc *>, COMDAT

; 993  : 	{	// return category from iterator argument

	push	ebp
	mov	ebp, esp
	push	ecx

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 998  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Iter_random@PAUContextQueDesc@Ogre@@PAU12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUContextQueDesc@Ogre@@0@Z ENDP ; std::_Iter_random<Ogre::ContextQueDesc *,Ogre::ContextQueDesc *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAUContextQueDesc@Ogre@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUContextQueDesc@Ogre@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAUContextQueDesc@Ogre@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUContextQueDesc@Ogre@@0@Z PROC ; std::_Ptr_cat<Ogre::ContextQueDesc *,Ogre::ContextQueDesc *>, COMDAT

; 1509 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 1512 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Ptr_cat@PAUContextQueDesc@Ogre@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUContextQueDesc@Ogre@@0@Z ENDP ; std::_Ptr_cat<Ogre::ContextQueDesc *,Ogre::ContextQueDesc *>
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAUContextQueDesc@Ogre@@PAU12@Uforward_iterator_tag@std@@@std@@YAPAUContextQueDesc@Ogre@@PAU12@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<Ogre::ContextQueDesc *,Ogre::ContextQueDesc *,std::forward_iterator_tag>
; Function compile flags: /Odtp
;	COMDAT ??$_Copy_opt@PAUContextQueDesc@Ogre@@PAU12@@std@@YAPAUContextQueDesc@Ogre@@PAU12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T98104 = -7						; size = 1
$T98103 = -6						; size = 1
$T98102 = -5						; size = 1
__Result$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAUContextQueDesc@Ogre@@PAU12@@std@@YAPAUContextQueDesc@Ogre@@PAU12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<Ogre::ContextQueDesc *,Ogre::ContextQueDesc *>, COMDAT

; 2481 : 	{	// copy [_First, _Last) to [_Dest, ...), random_access iterators

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 2482 : 	// if _OutIt is range checked, this will make sure there is enough space for the copy
; 2483 : 	_OutIt _Result = _Dest + (_Last - _First);

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	cdq
	mov	ecx, 156				; 0000009cH
	idiv	ecx
	imul	eax, 156				; 0000009cH
	add	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Result$[ebp], eax

; 2484 : 	_Copy_opt(_First, _Last, _CHECKED_BASE(_Dest), 
; 2485 : 		forward_iterator_tag(), _Nonscalar_ptr_iterator_tag(), _Range_checked_iterator_tag());

	xor	edx, edx
	mov	BYTE PTR $T98102[ebp], dl
	xor	eax, eax
	mov	BYTE PTR $T98103[ebp], al
	movzx	ecx, BYTE PTR $T98102[ebp]
	push	ecx
	movzx	edx, BYTE PTR $T98103[ebp]
	push	edx
	movzx	eax, BYTE PTR $T98104[ebp]
	push	eax
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	??$_Checked_base@PAUContextQueDesc@Ogre@@@std@@YAPAUContextQueDesc@Ogre@@AAPAU12@@Z ; std::_Checked_base<Ogre::ContextQueDesc *>
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Copy_opt@PAUContextQueDesc@Ogre@@PAU12@Uforward_iterator_tag@std@@@std@@YAPAUContextQueDesc@Ogre@@PAU12@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<Ogre::ContextQueDesc *,Ogre::ContextQueDesc *,std::forward_iterator_tag>
	add	esp, 24					; 00000018H

; 2486 : 	return _Result;

	mov	eax, DWORD PTR __Result$[ebp]

; 2487 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Copy_opt@PAUContextQueDesc@Ogre@@PAU12@@std@@YAPAUContextQueDesc@Ogre@@PAU12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<Ogre::ContextQueDesc *,Ogre::ContextQueDesc *>
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PAUContextQueDesc@Ogre@@PAU12@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@YAPAUContextQueDesc@Ogre@@PAU12@00AAV?$allocator@UContextQueDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Ogre::ContextQueDesc *,Ogre::ContextQueDesc *,std::allocator<Ogre::ContextQueDesc> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_copy@PAUContextQueDesc@Ogre@@PAU12@V?$allocator@UContextQueDesc@Ogre@@@std@@@stdext@@YAPAUContextQueDesc@Ogre@@PAU12@00AAV?$allocator@UContextQueDesc@Ogre@@@std@@@Z
_TEXT	SEGMENT
$T98108 = -2						; size = 1
$T98107 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@PAUContextQueDesc@Ogre@@PAU12@V?$allocator@UContextQueDesc@Ogre@@@std@@@stdext@@YAPAUContextQueDesc@Ogre@@PAU12@00AAV?$allocator@UContextQueDesc@Ogre@@@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<Ogre::ContextQueDesc *,Ogre::ContextQueDesc *,std::allocator<Ogre::ContextQueDesc> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T98107[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAUContextQueDesc@Ogre@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUContextQueDesc@Ogre@@0@Z ; std::_Ptr_cat<Ogre::ContextQueDesc *,Ogre::ContextQueDesc *>
	add	esp, 8
	mov	BYTE PTR $T98108[ebp], al
	movzx	eax, BYTE PTR $T98107[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T98108[ebp]
	push	ecx
	mov	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@PAUContextQueDesc@Ogre@@@std@@YAPAUContextQueDesc@Ogre@@AAPAU12@@Z ; std::_Checked_base<Ogre::ContextQueDesc *>
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@PAUContextQueDesc@Ogre@@@std@@YAPAUContextQueDesc@Ogre@@AAPAU12@@Z ; std::_Checked_base<Ogre::ContextQueDesc *>
	add	esp, 4
	push	eax
	call	??$_Uninit_copy@PAUContextQueDesc@Ogre@@PAU12@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@YAPAUContextQueDesc@Ogre@@PAU12@00AAV?$allocator@UContextQueDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Ogre::ContextQueDesc *,Ogre::ContextQueDesc *,std::allocator<Ogre::ContextQueDesc> >
	add	esp, 24					; 00000018H

; 823  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_copy@PAUContextQueDesc@Ogre@@PAU12@V?$allocator@UContextQueDesc@Ogre@@@std@@@stdext@@YAPAUContextQueDesc@Ogre@@PAU12@00AAV?$allocator@UContextQueDesc@Ogre@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<Ogre::ContextQueDesc *,Ogre::ContextQueDesc *,std::allocator<Ogre::ContextQueDesc> >
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PBEPAEV?$allocator@E@std@@@std@@YAPAEPBE0PAEAAV?$allocator@E@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<unsigned char const *,unsigned char *,std::allocator<unsigned char> >
PUBLIC	??$_Checked_base@V?$_Vector_const_iterator@EV?$allocator@E@std@@@std@@@std@@YAPBEAAV?$_Vector_const_iterator@EV?$allocator@E@std@@@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<unsigned char,std::allocator<unsigned char> > >
PUBLIC	??$_Ptr_cat@V?$_Vector_const_iterator@EV?$allocator@E@std@@@std@@PAE@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@EV?$allocator@E@std@@@0@AAPAE@Z ; std::_Ptr_cat<std::_Vector_const_iterator<unsigned char,std::allocator<unsigned char> >,unsigned char *>
; Function compile flags: /Odtp
;	COMDAT ??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@EV?$allocator@E@std@@@std@@PAEV?$allocator@E@2@@stdext@@YAPAEV?$_Vector_const_iterator@EV?$allocator@E@std@@@std@@0PAEAAV?$allocator@E@2@@Z
_TEXT	SEGMENT
$T98112 = -2						; size = 1
$T98111 = -1						; size = 1
__First$ = 8						; size = 8
__Last$ = 16						; size = 8
__Dest$ = 24						; size = 4
__Al$ = 28						; size = 4
??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@EV?$allocator@E@std@@@std@@PAEV?$allocator@E@2@@stdext@@YAPAEV?$_Vector_const_iterator@EV?$allocator@E@std@@@std@@0PAEAAV?$allocator@E@2@@Z PROC ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<unsigned char,std::allocator<unsigned char> >,unsigned char *,std::allocator<unsigned char> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T98111[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@V?$_Vector_const_iterator@EV?$allocator@E@std@@@std@@PAE@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@EV?$allocator@E@std@@@0@AAPAE@Z ; std::_Ptr_cat<std::_Vector_const_iterator<unsigned char,std::allocator<unsigned char> >,unsigned char *>
	add	esp, 8
	mov	BYTE PTR $T98112[ebp], al
	movzx	eax, BYTE PTR $T98111[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T98112[ebp]
	push	ecx
	mov	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@V?$_Vector_const_iterator@EV?$allocator@E@std@@@std@@@std@@YAPBEAAV?$_Vector_const_iterator@EV?$allocator@E@std@@@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<unsigned char,std::allocator<unsigned char> > >
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@V?$_Vector_const_iterator@EV?$allocator@E@std@@@std@@@std@@YAPBEAAV?$_Vector_const_iterator@EV?$allocator@E@std@@@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<unsigned char,std::allocator<unsigned char> > >
	add	esp, 4
	push	eax
	call	??$_Uninit_copy@PBEPAEV?$allocator@E@std@@@std@@YAPAEPBE0PAEAAV?$allocator@E@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<unsigned char const *,unsigned char *,std::allocator<unsigned char> >
	add	esp, 24					; 00000018H

; 823  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@EV?$allocator@E@std@@@std@@PAEV?$allocator@E@2@@stdext@@YAPAEV?$_Vector_const_iterator@EV?$allocator@E@std@@@std@@0PAEAAV?$allocator@E@2@@Z ENDP ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<unsigned char,std::allocator<unsigned char> >,unsigned char *,std::allocator<unsigned char> >
_TEXT	ENDS
PUBLIC	??$_Checked_base@PAE@std@@YAPAEAAPAEU_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<unsigned char *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Checked_base@PAE@std@@YAPAEAAPAE@Z
_TEXT	SEGMENT
__Base_tag$ = -1					; size = 1
__It$ = 8						; size = 4
??$_Checked_base@PAE@std@@YAPAEAAPAE@Z PROC		; std::_Checked_base<unsigned char *>, COMDAT

; 1163 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1164 : 		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
; 1165 : 		return _Checked_base(_It, _Base_tag);

	movzx	eax, BYTE PTR __Base_tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR __It$[ebp]
	push	ecx
	call	??$_Checked_base@PAE@std@@YAPAEAAPAEU_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<unsigned char *>
	add	esp, 8

; 1166 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Checked_base@PAE@std@@YAPAEAAPAE@Z ENDP		; std::_Checked_base<unsigned char *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Iter_random@PAEPAE@std@@YA?AUrandom_access_iterator_tag@0@ABQAE0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAEPAE@std@@YA?AUrandom_access_iterator_tag@0@ABQAE0@Z PROC ; std::_Iter_random<unsigned char *,unsigned char *>, COMDAT

; 993  : 	{	// return category from iterator argument

	push	ebp
	mov	ebp, esp
	push	ecx

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 998  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Iter_random@PAEPAE@std@@YA?AUrandom_access_iterator_tag@0@ABQAE0@Z ENDP ; std::_Iter_random<unsigned char *,unsigned char *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAEPAE@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAE0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAEPAE@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAE0@Z PROC ; std::_Ptr_cat<unsigned char *,unsigned char *>, COMDAT

; 1509 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 1512 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Ptr_cat@PAEPAE@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAE0@Z ENDP ; std::_Ptr_cat<unsigned char *,unsigned char *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Copy_opt@PAEPAEUrandom_access_iterator_tag@std@@@std@@YAPAEPAE00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Off$ = -8						; size = 4
__Result$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAEPAEUrandom_access_iterator_tag@std@@@std@@YAPAEPAE00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<unsigned char *,unsigned char *,std::random_access_iterator_tag>, COMDAT

; 2494 : 	{	// copy [_First, _Last) to [_Dest, ...), pointers to scalars

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 2495 : 
; 2496 :  #if _HAS_ITERATOR_DEBUGGING
; 2497 : 	_DEBUG_RANGE(_First, _Last);
; 2498 : 	if (_First != _Last)
; 2499 : 		_DEBUG_POINTER(_Dest);
; 2500 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2501 : 
; 2502 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Off$[ebp], eax

; 2503 : 	// if _OutIt is range checked, this will make sure there is enough space for the memmove
; 2504 : 	_OutIt _Result = _Dest + _Off;

	mov	ecx, DWORD PTR __Dest$[ebp]
	add	ecx, DWORD PTR __Off$[ebp]
	mov	DWORD PTR __Result$[ebp], ecx

; 2505 : 	if (_Off > 0)

	cmp	DWORD PTR __Off$[ebp], 0
	jle	SHORT $LN1@Copy_opt@2

; 2506 : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Off * sizeof (*_First), &*_First, _Off * sizeof (*_First));

	mov	edx, DWORD PTR __Off$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Off$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN1@Copy_opt@2:

; 2507 : 	return _Result;

	mov	eax, DWORD PTR __Result$[ebp]

; 2508 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Copy_opt@PAEPAEUrandom_access_iterator_tag@std@@@std@@YAPAEPAE00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<unsigned char *,unsigned char *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PAEPAEV?$allocator@E@std@@@std@@YAPAEPAE00AAV?$allocator@E@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<unsigned char *,unsigned char *,std::allocator<unsigned char> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_copy@PAEPAEV?$allocator@E@std@@@stdext@@YAPAEPAE00AAV?$allocator@E@std@@@Z
_TEXT	SEGMENT
$T98124 = -2						; size = 1
$T98123 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@PAEPAEV?$allocator@E@std@@@stdext@@YAPAEPAE00AAV?$allocator@E@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<unsigned char *,unsigned char *,std::allocator<unsigned char> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T98123[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAEPAE@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAE0@Z ; std::_Ptr_cat<unsigned char *,unsigned char *>
	add	esp, 8
	mov	BYTE PTR $T98124[ebp], al
	movzx	eax, BYTE PTR $T98123[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T98124[ebp]
	push	ecx
	mov	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@PAE@std@@YAPAEAAPAE@Z	; std::_Checked_base<unsigned char *>
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@PAE@std@@YAPAEAAPAE@Z	; std::_Checked_base<unsigned char *>
	add	esp, 4
	push	eax
	call	??$_Uninit_copy@PAEPAEV?$allocator@E@std@@@std@@YAPAEPAE00AAV?$allocator@E@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<unsigned char *,unsigned char *,std::allocator<unsigned char> >
	add	esp, 24					; 00000018H

; 823  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_copy@PAEPAEV?$allocator@E@std@@@stdext@@YAPAEPAE00AAV?$allocator@E@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<unsigned char *,unsigned char *,std::allocator<unsigned char> >
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PBUValueParam@ShaderContextPool@Ogre@@PAU123@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@YAPAUValueParam@ShaderContextPool@Ogre@@PBU123@0PAU123@AAV?$allocator@UValueParam@ShaderContextPool@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Ogre::ShaderContextPool::ValueParam const *,Ogre::ShaderContextPool::ValueParam *,std::allocator<Ogre::ShaderContextPool::ValueParam> >
PUBLIC	??$_Checked_base@V?$_Vector_const_iterator@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@@std@@YAPBUValueParam@ShaderContextPool@Ogre@@AAV?$_Vector_const_iterator@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::ShaderContextPool::ValueParam,std::allocator<Ogre::ShaderContextPool::ValueParam> > >
PUBLIC	??$_Ptr_cat@V?$_Vector_const_iterator@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@PAUValueParam@ShaderContextPool@Ogre@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@0@AAPAUValueParam@ShaderContextPool@Ogre@@@Z ; std::_Ptr_cat<std::_Vector_const_iterator<Ogre::ShaderContextPool::ValueParam,std::allocator<Ogre::ShaderContextPool::ValueParam> >,Ogre::ShaderContextPool::ValueParam *>
; Function compile flags: /Odtp
;	COMDAT ??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@PAUValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@2@@stdext@@YAPAUValueParam@ShaderContextPool@Ogre@@V?$_Vector_const_iterator@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@0PAU123@AAV?$allocator@UValueParam@ShaderContextPool@Ogre@@@5@@Z
_TEXT	SEGMENT
$T98128 = -2						; size = 1
$T98127 = -1						; size = 1
__First$ = 8						; size = 8
__Last$ = 16						; size = 8
__Dest$ = 24						; size = 4
__Al$ = 28						; size = 4
??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@PAUValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@2@@stdext@@YAPAUValueParam@ShaderContextPool@Ogre@@V?$_Vector_const_iterator@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@0PAU123@AAV?$allocator@UValueParam@ShaderContextPool@Ogre@@@5@@Z PROC ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<Ogre::ShaderContextPool::ValueParam,std::allocator<Ogre::ShaderContextPool::ValueParam> >,Ogre::ShaderContextPool::ValueParam *,std::allocator<Ogre::ShaderContextPool::ValueParam> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T98127[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@V?$_Vector_const_iterator@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@PAUValueParam@ShaderContextPool@Ogre@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@0@AAPAUValueParam@ShaderContextPool@Ogre@@@Z ; std::_Ptr_cat<std::_Vector_const_iterator<Ogre::ShaderContextPool::ValueParam,std::allocator<Ogre::ShaderContextPool::ValueParam> >,Ogre::ShaderContextPool::ValueParam *>
	add	esp, 8
	mov	BYTE PTR $T98128[ebp], al
	movzx	eax, BYTE PTR $T98127[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T98128[ebp]
	push	ecx
	mov	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@V?$_Vector_const_iterator@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@@std@@YAPBUValueParam@ShaderContextPool@Ogre@@AAV?$_Vector_const_iterator@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::ShaderContextPool::ValueParam,std::allocator<Ogre::ShaderContextPool::ValueParam> > >
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@V?$_Vector_const_iterator@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@@std@@YAPBUValueParam@ShaderContextPool@Ogre@@AAV?$_Vector_const_iterator@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::ShaderContextPool::ValueParam,std::allocator<Ogre::ShaderContextPool::ValueParam> > >
	add	esp, 4
	push	eax
	call	??$_Uninit_copy@PBUValueParam@ShaderContextPool@Ogre@@PAU123@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@YAPAUValueParam@ShaderContextPool@Ogre@@PBU123@0PAU123@AAV?$allocator@UValueParam@ShaderContextPool@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Ogre::ShaderContextPool::ValueParam const *,Ogre::ShaderContextPool::ValueParam *,std::allocator<Ogre::ShaderContextPool::ValueParam> >
	add	esp, 24					; 00000018H

; 823  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@PAUValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@2@@stdext@@YAPAUValueParam@ShaderContextPool@Ogre@@V?$_Vector_const_iterator@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@0PAU123@AAV?$allocator@UValueParam@ShaderContextPool@Ogre@@@5@@Z ENDP ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<Ogre::ShaderContextPool::ValueParam,std::allocator<Ogre::ShaderContextPool::ValueParam> >,Ogre::ShaderContextPool::ValueParam *,std::allocator<Ogre::ShaderContextPool::ValueParam> >
_TEXT	ENDS
PUBLIC	??$_Checked_base@PAUValueParam@ShaderContextPool@Ogre@@@std@@YAPAUValueParam@ShaderContextPool@Ogre@@AAPAU123@U_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<Ogre::ShaderContextPool::ValueParam *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Checked_base@PAUValueParam@ShaderContextPool@Ogre@@@std@@YAPAUValueParam@ShaderContextPool@Ogre@@AAPAU123@@Z
_TEXT	SEGMENT
__Base_tag$ = -1					; size = 1
__It$ = 8						; size = 4
??$_Checked_base@PAUValueParam@ShaderContextPool@Ogre@@@std@@YAPAUValueParam@ShaderContextPool@Ogre@@AAPAU123@@Z PROC ; std::_Checked_base<Ogre::ShaderContextPool::ValueParam *>, COMDAT

; 1163 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1164 : 		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
; 1165 : 		return _Checked_base(_It, _Base_tag);

	movzx	eax, BYTE PTR __Base_tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR __It$[ebp]
	push	ecx
	call	??$_Checked_base@PAUValueParam@ShaderContextPool@Ogre@@@std@@YAPAUValueParam@ShaderContextPool@Ogre@@AAPAU123@U_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<Ogre::ShaderContextPool::ValueParam *>
	add	esp, 8

; 1166 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Checked_base@PAUValueParam@ShaderContextPool@Ogre@@@std@@YAPAUValueParam@ShaderContextPool@Ogre@@AAPAU123@@Z ENDP ; std::_Checked_base<Ogre::ShaderContextPool::ValueParam *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Iter_random@PAUValueParam@ShaderContextPool@Ogre@@PAU123@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUValueParam@ShaderContextPool@Ogre@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAUValueParam@ShaderContextPool@Ogre@@PAU123@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUValueParam@ShaderContextPool@Ogre@@0@Z PROC ; std::_Iter_random<Ogre::ShaderContextPool::ValueParam *,Ogre::ShaderContextPool::ValueParam *>, COMDAT

; 993  : 	{	// return category from iterator argument

	push	ebp
	mov	ebp, esp
	push	ecx

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 998  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Iter_random@PAUValueParam@ShaderContextPool@Ogre@@PAU123@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUValueParam@ShaderContextPool@Ogre@@0@Z ENDP ; std::_Iter_random<Ogre::ShaderContextPool::ValueParam *,Ogre::ShaderContextPool::ValueParam *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAUValueParam@ShaderContextPool@Ogre@@PAU123@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUValueParam@ShaderContextPool@Ogre@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAUValueParam@ShaderContextPool@Ogre@@PAU123@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUValueParam@ShaderContextPool@Ogre@@0@Z PROC ; std::_Ptr_cat<Ogre::ShaderContextPool::ValueParam *,Ogre::ShaderContextPool::ValueParam *>, COMDAT

; 1509 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 1512 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Ptr_cat@PAUValueParam@ShaderContextPool@Ogre@@PAU123@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUValueParam@ShaderContextPool@Ogre@@0@Z ENDP ; std::_Ptr_cat<Ogre::ShaderContextPool::ValueParam *,Ogre::ShaderContextPool::ValueParam *>
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAUValueParam@ShaderContextPool@Ogre@@PAU123@Uforward_iterator_tag@std@@@std@@YAPAUValueParam@ShaderContextPool@Ogre@@PAU123@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<Ogre::ShaderContextPool::ValueParam *,Ogre::ShaderContextPool::ValueParam *,std::forward_iterator_tag>
; Function compile flags: /Odtp
;	COMDAT ??$_Copy_opt@PAUValueParam@ShaderContextPool@Ogre@@PAU123@@std@@YAPAUValueParam@ShaderContextPool@Ogre@@PAU123@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T98139 = -7						; size = 1
$T98138 = -6						; size = 1
$T98137 = -5						; size = 1
__Result$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAUValueParam@ShaderContextPool@Ogre@@PAU123@@std@@YAPAUValueParam@ShaderContextPool@Ogre@@PAU123@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<Ogre::ShaderContextPool::ValueParam *,Ogre::ShaderContextPool::ValueParam *>, COMDAT

; 2481 : 	{	// copy [_First, _Last) to [_Dest, ...), random_access iterators

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 2482 : 	// if _OutIt is range checked, this will make sure there is enough space for the copy
; 2483 : 	_OutIt _Result = _Dest + (_Last - _First);

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 4
	shl	eax, 4
	add	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Result$[ebp], eax

; 2484 : 	_Copy_opt(_First, _Last, _CHECKED_BASE(_Dest), 
; 2485 : 		forward_iterator_tag(), _Nonscalar_ptr_iterator_tag(), _Range_checked_iterator_tag());

	xor	ecx, ecx
	mov	BYTE PTR $T98137[ebp], cl
	xor	edx, edx
	mov	BYTE PTR $T98138[ebp], dl
	movzx	eax, BYTE PTR $T98137[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T98138[ebp]
	push	ecx
	movzx	edx, BYTE PTR $T98139[ebp]
	push	edx
	lea	eax, DWORD PTR __Dest$[ebp]
	push	eax
	call	??$_Checked_base@PAUValueParam@ShaderContextPool@Ogre@@@std@@YAPAUValueParam@ShaderContextPool@Ogre@@AAPAU123@@Z ; std::_Checked_base<Ogre::ShaderContextPool::ValueParam *>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Copy_opt@PAUValueParam@ShaderContextPool@Ogre@@PAU123@Uforward_iterator_tag@std@@@std@@YAPAUValueParam@ShaderContextPool@Ogre@@PAU123@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<Ogre::ShaderContextPool::ValueParam *,Ogre::ShaderContextPool::ValueParam *,std::forward_iterator_tag>
	add	esp, 24					; 00000018H

; 2486 : 	return _Result;

	mov	eax, DWORD PTR __Result$[ebp]

; 2487 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Copy_opt@PAUValueParam@ShaderContextPool@Ogre@@PAU123@@std@@YAPAUValueParam@ShaderContextPool@Ogre@@PAU123@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<Ogre::ShaderContextPool::ValueParam *,Ogre::ShaderContextPool::ValueParam *>
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PAUValueParam@ShaderContextPool@Ogre@@PAU123@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@YAPAUValueParam@ShaderContextPool@Ogre@@PAU123@00AAV?$allocator@UValueParam@ShaderContextPool@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Ogre::ShaderContextPool::ValueParam *,Ogre::ShaderContextPool::ValueParam *,std::allocator<Ogre::ShaderContextPool::ValueParam> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_copy@PAUValueParam@ShaderContextPool@Ogre@@PAU123@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@stdext@@YAPAUValueParam@ShaderContextPool@Ogre@@PAU123@00AAV?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@Z
_TEXT	SEGMENT
$T98143 = -2						; size = 1
$T98142 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@PAUValueParam@ShaderContextPool@Ogre@@PAU123@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@stdext@@YAPAUValueParam@ShaderContextPool@Ogre@@PAU123@00AAV?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<Ogre::ShaderContextPool::ValueParam *,Ogre::ShaderContextPool::ValueParam *,std::allocator<Ogre::ShaderContextPool::ValueParam> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T98142[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAUValueParam@ShaderContextPool@Ogre@@PAU123@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUValueParam@ShaderContextPool@Ogre@@0@Z ; std::_Ptr_cat<Ogre::ShaderContextPool::ValueParam *,Ogre::ShaderContextPool::ValueParam *>
	add	esp, 8
	mov	BYTE PTR $T98143[ebp], al
	movzx	eax, BYTE PTR $T98142[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T98143[ebp]
	push	ecx
	mov	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@PAUValueParam@ShaderContextPool@Ogre@@@std@@YAPAUValueParam@ShaderContextPool@Ogre@@AAPAU123@@Z ; std::_Checked_base<Ogre::ShaderContextPool::ValueParam *>
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@PAUValueParam@ShaderContextPool@Ogre@@@std@@YAPAUValueParam@ShaderContextPool@Ogre@@AAPAU123@@Z ; std::_Checked_base<Ogre::ShaderContextPool::ValueParam *>
	add	esp, 4
	push	eax
	call	??$_Uninit_copy@PAUValueParam@ShaderContextPool@Ogre@@PAU123@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@YAPAUValueParam@ShaderContextPool@Ogre@@PAU123@00AAV?$allocator@UValueParam@ShaderContextPool@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Ogre::ShaderContextPool::ValueParam *,Ogre::ShaderContextPool::ValueParam *,std::allocator<Ogre::ShaderContextPool::ValueParam> >
	add	esp, 24					; 00000018H

; 823  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_copy@PAUValueParam@ShaderContextPool@Ogre@@PAU123@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@stdext@@YAPAUValueParam@ShaderContextPool@Ogre@@PAU123@00AAV?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<Ogre::ShaderContextPool::ValueParam *,Ogre::ShaderContextPool::ValueParam *,std::allocator<Ogre::ShaderContextPool::ValueParam> >
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PBUTexParam@ShaderContextPool@Ogre@@PAU123@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@YAPAUTexParam@ShaderContextPool@Ogre@@PBU123@0PAU123@AAV?$allocator@UTexParam@ShaderContextPool@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Ogre::ShaderContextPool::TexParam const *,Ogre::ShaderContextPool::TexParam *,std::allocator<Ogre::ShaderContextPool::TexParam> >
PUBLIC	??$_Checked_base@V?$_Vector_const_iterator@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@@std@@YAPBUTexParam@ShaderContextPool@Ogre@@AAV?$_Vector_const_iterator@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::ShaderContextPool::TexParam,std::allocator<Ogre::ShaderContextPool::TexParam> > >
PUBLIC	??$_Ptr_cat@V?$_Vector_const_iterator@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@PAUTexParam@ShaderContextPool@Ogre@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@0@AAPAUTexParam@ShaderContextPool@Ogre@@@Z ; std::_Ptr_cat<std::_Vector_const_iterator<Ogre::ShaderContextPool::TexParam,std::allocator<Ogre::ShaderContextPool::TexParam> >,Ogre::ShaderContextPool::TexParam *>
; Function compile flags: /Odtp
;	COMDAT ??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@PAUTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@2@@stdext@@YAPAUTexParam@ShaderContextPool@Ogre@@V?$_Vector_const_iterator@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@0PAU123@AAV?$allocator@UTexParam@ShaderContextPool@Ogre@@@5@@Z
_TEXT	SEGMENT
$T98147 = -2						; size = 1
$T98146 = -1						; size = 1
__First$ = 8						; size = 8
__Last$ = 16						; size = 8
__Dest$ = 24						; size = 4
__Al$ = 28						; size = 4
??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@PAUTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@2@@stdext@@YAPAUTexParam@ShaderContextPool@Ogre@@V?$_Vector_const_iterator@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@0PAU123@AAV?$allocator@UTexParam@ShaderContextPool@Ogre@@@5@@Z PROC ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<Ogre::ShaderContextPool::TexParam,std::allocator<Ogre::ShaderContextPool::TexParam> >,Ogre::ShaderContextPool::TexParam *,std::allocator<Ogre::ShaderContextPool::TexParam> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T98146[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@V?$_Vector_const_iterator@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@PAUTexParam@ShaderContextPool@Ogre@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@0@AAPAUTexParam@ShaderContextPool@Ogre@@@Z ; std::_Ptr_cat<std::_Vector_const_iterator<Ogre::ShaderContextPool::TexParam,std::allocator<Ogre::ShaderContextPool::TexParam> >,Ogre::ShaderContextPool::TexParam *>
	add	esp, 8
	mov	BYTE PTR $T98147[ebp], al
	movzx	eax, BYTE PTR $T98146[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T98147[ebp]
	push	ecx
	mov	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@V?$_Vector_const_iterator@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@@std@@YAPBUTexParam@ShaderContextPool@Ogre@@AAV?$_Vector_const_iterator@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::ShaderContextPool::TexParam,std::allocator<Ogre::ShaderContextPool::TexParam> > >
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@V?$_Vector_const_iterator@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@@std@@YAPBUTexParam@ShaderContextPool@Ogre@@AAV?$_Vector_const_iterator@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::ShaderContextPool::TexParam,std::allocator<Ogre::ShaderContextPool::TexParam> > >
	add	esp, 4
	push	eax
	call	??$_Uninit_copy@PBUTexParam@ShaderContextPool@Ogre@@PAU123@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@YAPAUTexParam@ShaderContextPool@Ogre@@PBU123@0PAU123@AAV?$allocator@UTexParam@ShaderContextPool@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Ogre::ShaderContextPool::TexParam const *,Ogre::ShaderContextPool::TexParam *,std::allocator<Ogre::ShaderContextPool::TexParam> >
	add	esp, 24					; 00000018H

; 823  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@PAUTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@2@@stdext@@YAPAUTexParam@ShaderContextPool@Ogre@@V?$_Vector_const_iterator@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@0PAU123@AAV?$allocator@UTexParam@ShaderContextPool@Ogre@@@5@@Z ENDP ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<Ogre::ShaderContextPool::TexParam,std::allocator<Ogre::ShaderContextPool::TexParam> >,Ogre::ShaderContextPool::TexParam *,std::allocator<Ogre::ShaderContextPool::TexParam> >
_TEXT	ENDS
PUBLIC	??$_Checked_base@PAUTexParam@ShaderContextPool@Ogre@@@std@@YAPAUTexParam@ShaderContextPool@Ogre@@AAPAU123@U_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<Ogre::ShaderContextPool::TexParam *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Checked_base@PAUTexParam@ShaderContextPool@Ogre@@@std@@YAPAUTexParam@ShaderContextPool@Ogre@@AAPAU123@@Z
_TEXT	SEGMENT
__Base_tag$ = -1					; size = 1
__It$ = 8						; size = 4
??$_Checked_base@PAUTexParam@ShaderContextPool@Ogre@@@std@@YAPAUTexParam@ShaderContextPool@Ogre@@AAPAU123@@Z PROC ; std::_Checked_base<Ogre::ShaderContextPool::TexParam *>, COMDAT

; 1163 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1164 : 		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
; 1165 : 		return _Checked_base(_It, _Base_tag);

	movzx	eax, BYTE PTR __Base_tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR __It$[ebp]
	push	ecx
	call	??$_Checked_base@PAUTexParam@ShaderContextPool@Ogre@@@std@@YAPAUTexParam@ShaderContextPool@Ogre@@AAPAU123@U_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<Ogre::ShaderContextPool::TexParam *>
	add	esp, 8

; 1166 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Checked_base@PAUTexParam@ShaderContextPool@Ogre@@@std@@YAPAUTexParam@ShaderContextPool@Ogre@@AAPAU123@@Z ENDP ; std::_Checked_base<Ogre::ShaderContextPool::TexParam *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Iter_random@PAUTexParam@ShaderContextPool@Ogre@@PAU123@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUTexParam@ShaderContextPool@Ogre@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAUTexParam@ShaderContextPool@Ogre@@PAU123@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUTexParam@ShaderContextPool@Ogre@@0@Z PROC ; std::_Iter_random<Ogre::ShaderContextPool::TexParam *,Ogre::ShaderContextPool::TexParam *>, COMDAT

; 993  : 	{	// return category from iterator argument

	push	ebp
	mov	ebp, esp
	push	ecx

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 998  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Iter_random@PAUTexParam@ShaderContextPool@Ogre@@PAU123@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUTexParam@ShaderContextPool@Ogre@@0@Z ENDP ; std::_Iter_random<Ogre::ShaderContextPool::TexParam *,Ogre::ShaderContextPool::TexParam *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAUTexParam@ShaderContextPool@Ogre@@PAU123@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUTexParam@ShaderContextPool@Ogre@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAUTexParam@ShaderContextPool@Ogre@@PAU123@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUTexParam@ShaderContextPool@Ogre@@0@Z PROC ; std::_Ptr_cat<Ogre::ShaderContextPool::TexParam *,Ogre::ShaderContextPool::TexParam *>, COMDAT

; 1509 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 1512 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Ptr_cat@PAUTexParam@ShaderContextPool@Ogre@@PAU123@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUTexParam@ShaderContextPool@Ogre@@0@Z ENDP ; std::_Ptr_cat<Ogre::ShaderContextPool::TexParam *,Ogre::ShaderContextPool::TexParam *>
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAUTexParam@ShaderContextPool@Ogre@@PAU123@Uforward_iterator_tag@std@@@std@@YAPAUTexParam@ShaderContextPool@Ogre@@PAU123@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<Ogre::ShaderContextPool::TexParam *,Ogre::ShaderContextPool::TexParam *,std::forward_iterator_tag>
; Function compile flags: /Odtp
;	COMDAT ??$_Copy_opt@PAUTexParam@ShaderContextPool@Ogre@@PAU123@@std@@YAPAUTexParam@ShaderContextPool@Ogre@@PAU123@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T98158 = -7						; size = 1
$T98157 = -6						; size = 1
$T98156 = -5						; size = 1
__Result$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAUTexParam@ShaderContextPool@Ogre@@PAU123@@std@@YAPAUTexParam@ShaderContextPool@Ogre@@PAU123@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<Ogre::ShaderContextPool::TexParam *,Ogre::ShaderContextPool::TexParam *>, COMDAT

; 2481 : 	{	// copy [_First, _Last) to [_Dest, ...), random_access iterators

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 2482 : 	// if _OutIt is range checked, this will make sure there is enough space for the copy
; 2483 : 	_OutIt _Result = _Dest + (_Last - _First);

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 3
	mov	ecx, DWORD PTR __Dest$[ebp]
	lea	edx, DWORD PTR [ecx+eax*8]
	mov	DWORD PTR __Result$[ebp], edx

; 2484 : 	_Copy_opt(_First, _Last, _CHECKED_BASE(_Dest), 
; 2485 : 		forward_iterator_tag(), _Nonscalar_ptr_iterator_tag(), _Range_checked_iterator_tag());

	xor	eax, eax
	mov	BYTE PTR $T98156[ebp], al
	xor	ecx, ecx
	mov	BYTE PTR $T98157[ebp], cl
	movzx	edx, BYTE PTR $T98156[ebp]
	push	edx
	movzx	eax, BYTE PTR $T98157[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T98158[ebp]
	push	ecx
	lea	edx, DWORD PTR __Dest$[ebp]
	push	edx
	call	??$_Checked_base@PAUTexParam@ShaderContextPool@Ogre@@@std@@YAPAUTexParam@ShaderContextPool@Ogre@@AAPAU123@@Z ; std::_Checked_base<Ogre::ShaderContextPool::TexParam *>
	add	esp, 4
	push	eax
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Copy_opt@PAUTexParam@ShaderContextPool@Ogre@@PAU123@Uforward_iterator_tag@std@@@std@@YAPAUTexParam@ShaderContextPool@Ogre@@PAU123@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<Ogre::ShaderContextPool::TexParam *,Ogre::ShaderContextPool::TexParam *,std::forward_iterator_tag>
	add	esp, 24					; 00000018H

; 2486 : 	return _Result;

	mov	eax, DWORD PTR __Result$[ebp]

; 2487 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Copy_opt@PAUTexParam@ShaderContextPool@Ogre@@PAU123@@std@@YAPAUTexParam@ShaderContextPool@Ogre@@PAU123@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<Ogre::ShaderContextPool::TexParam *,Ogre::ShaderContextPool::TexParam *>
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PAUTexParam@ShaderContextPool@Ogre@@PAU123@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@YAPAUTexParam@ShaderContextPool@Ogre@@PAU123@00AAV?$allocator@UTexParam@ShaderContextPool@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Ogre::ShaderContextPool::TexParam *,Ogre::ShaderContextPool::TexParam *,std::allocator<Ogre::ShaderContextPool::TexParam> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_copy@PAUTexParam@ShaderContextPool@Ogre@@PAU123@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@stdext@@YAPAUTexParam@ShaderContextPool@Ogre@@PAU123@00AAV?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@Z
_TEXT	SEGMENT
$T98162 = -2						; size = 1
$T98161 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@PAUTexParam@ShaderContextPool@Ogre@@PAU123@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@stdext@@YAPAUTexParam@ShaderContextPool@Ogre@@PAU123@00AAV?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<Ogre::ShaderContextPool::TexParam *,Ogre::ShaderContextPool::TexParam *,std::allocator<Ogre::ShaderContextPool::TexParam> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T98161[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAUTexParam@ShaderContextPool@Ogre@@PAU123@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUTexParam@ShaderContextPool@Ogre@@0@Z ; std::_Ptr_cat<Ogre::ShaderContextPool::TexParam *,Ogre::ShaderContextPool::TexParam *>
	add	esp, 8
	mov	BYTE PTR $T98162[ebp], al
	movzx	eax, BYTE PTR $T98161[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T98162[ebp]
	push	ecx
	mov	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@PAUTexParam@ShaderContextPool@Ogre@@@std@@YAPAUTexParam@ShaderContextPool@Ogre@@AAPAU123@@Z ; std::_Checked_base<Ogre::ShaderContextPool::TexParam *>
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@PAUTexParam@ShaderContextPool@Ogre@@@std@@YAPAUTexParam@ShaderContextPool@Ogre@@AAPAU123@@Z ; std::_Checked_base<Ogre::ShaderContextPool::TexParam *>
	add	esp, 4
	push	eax
	call	??$_Uninit_copy@PAUTexParam@ShaderContextPool@Ogre@@PAU123@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@YAPAUTexParam@ShaderContextPool@Ogre@@PAU123@00AAV?$allocator@UTexParam@ShaderContextPool@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Ogre::ShaderContextPool::TexParam *,Ogre::ShaderContextPool::TexParam *,std::allocator<Ogre::ShaderContextPool::TexParam> >
	add	esp, 24					; 00000018H

; 823  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_copy@PAUTexParam@ShaderContextPool@Ogre@@PAU123@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@stdext@@YAPAUTexParam@ShaderContextPool@Ogre@@PAU123@00AAV?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<Ogre::ShaderContextPool::TexParam *,Ogre::ShaderContextPool::TexParam *,std::allocator<Ogre::ShaderContextPool::TexParam> >
_TEXT	ENDS
PUBLIC	??$_Checked_base@PAPAVMaterialParam@Ogre@@@std@@YAPAPAVMaterialParam@Ogre@@AAPAPAV12@U_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<Ogre::MaterialParam * *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Checked_base@PAPAVMaterialParam@Ogre@@@std@@YAPAPAVMaterialParam@Ogre@@AAPAPAV12@@Z
_TEXT	SEGMENT
__Base_tag$ = -1					; size = 1
__It$ = 8						; size = 4
??$_Checked_base@PAPAVMaterialParam@Ogre@@@std@@YAPAPAVMaterialParam@Ogre@@AAPAPAV12@@Z PROC ; std::_Checked_base<Ogre::MaterialParam * *>, COMDAT

; 1163 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1164 : 		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
; 1165 : 		return _Checked_base(_It, _Base_tag);

	movzx	eax, BYTE PTR __Base_tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR __It$[ebp]
	push	ecx
	call	??$_Checked_base@PAPAVMaterialParam@Ogre@@@std@@YAPAPAVMaterialParam@Ogre@@AAPAPAV12@U_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<Ogre::MaterialParam * *>
	add	esp, 8

; 1166 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Checked_base@PAPAVMaterialParam@Ogre@@@std@@YAPAPAVMaterialParam@Ogre@@AAPAPAV12@@Z ENDP ; std::_Checked_base<Ogre::MaterialParam * *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Iter_random@PAPAVMaterialParam@Ogre@@PAPAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVMaterialParam@Ogre@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAPAVMaterialParam@Ogre@@PAPAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVMaterialParam@Ogre@@0@Z PROC ; std::_Iter_random<Ogre::MaterialParam * *,Ogre::MaterialParam * *>, COMDAT

; 993  : 	{	// return category from iterator argument

	push	ebp
	mov	ebp, esp
	push	ecx

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 998  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Iter_random@PAPAVMaterialParam@Ogre@@PAPAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVMaterialParam@Ogre@@0@Z ENDP ; std::_Iter_random<Ogre::MaterialParam * *,Ogre::MaterialParam * *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAPAVMaterialParam@Ogre@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVMaterialParam@Ogre@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAPAVMaterialParam@Ogre@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVMaterialParam@Ogre@@0@Z PROC ; std::_Ptr_cat<Ogre::MaterialParam * *,Ogre::MaterialParam * *>, COMDAT

; 1509 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 1512 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Ptr_cat@PAPAVMaterialParam@Ogre@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVMaterialParam@Ogre@@0@Z ENDP ; std::_Ptr_cat<Ogre::MaterialParam * *,Ogre::MaterialParam * *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Copy_opt@PAPAVMaterialParam@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@@std@@YAPAPAVMaterialParam@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Off$ = -8						; size = 4
__Result$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAPAVMaterialParam@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@@std@@YAPAPAVMaterialParam@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<Ogre::MaterialParam * *,Ogre::MaterialParam * *,std::random_access_iterator_tag>, COMDAT

; 2494 : 	{	// copy [_First, _Last) to [_Dest, ...), pointers to scalars

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 2495 : 
; 2496 :  #if _HAS_ITERATOR_DEBUGGING
; 2497 : 	_DEBUG_RANGE(_First, _Last);
; 2498 : 	if (_First != _Last)
; 2499 : 		_DEBUG_POINTER(_Dest);
; 2500 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2501 : 
; 2502 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 2
	mov	DWORD PTR __Off$[ebp], eax

; 2503 : 	// if _OutIt is range checked, this will make sure there is enough space for the memmove
; 2504 : 	_OutIt _Result = _Dest + _Off;

	mov	ecx, DWORD PTR __Off$[ebp]
	mov	edx, DWORD PTR __Dest$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR __Result$[ebp], eax

; 2505 : 	if (_Off > 0)

	cmp	DWORD PTR __Off$[ebp], 0
	jle	SHORT $LN1@Copy_opt@3

; 2506 : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Off * sizeof (*_First), &*_First, _Off * sizeof (*_First));

	mov	ecx, DWORD PTR __Off$[ebp]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	eax, DWORD PTR __Off$[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN1@Copy_opt@3:

; 2507 : 	return _Result;

	mov	eax, DWORD PTR __Result$[ebp]

; 2508 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Copy_opt@PAPAVMaterialParam@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@@std@@YAPAPAVMaterialParam@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<Ogre::MaterialParam * *,Ogre::MaterialParam * *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PAPAVMaterialParam@Ogre@@PAPAV12@V?$allocator@PAVMaterialParam@Ogre@@@std@@@std@@YAPAPAVMaterialParam@Ogre@@PAPAV12@00AAV?$allocator@PAVMaterialParam@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Ogre::MaterialParam * *,Ogre::MaterialParam * *,std::allocator<Ogre::MaterialParam *> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_copy@PAPAVMaterialParam@Ogre@@PAPAV12@V?$allocator@PAVMaterialParam@Ogre@@@std@@@stdext@@YAPAPAVMaterialParam@Ogre@@PAPAV12@00AAV?$allocator@PAVMaterialParam@Ogre@@@std@@@Z
_TEXT	SEGMENT
$T98174 = -2						; size = 1
$T98173 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@PAPAVMaterialParam@Ogre@@PAPAV12@V?$allocator@PAVMaterialParam@Ogre@@@std@@@stdext@@YAPAPAVMaterialParam@Ogre@@PAPAV12@00AAV?$allocator@PAVMaterialParam@Ogre@@@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<Ogre::MaterialParam * *,Ogre::MaterialParam * *,std::allocator<Ogre::MaterialParam *> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T98173[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAPAVMaterialParam@Ogre@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVMaterialParam@Ogre@@0@Z ; std::_Ptr_cat<Ogre::MaterialParam * *,Ogre::MaterialParam * *>
	add	esp, 8
	mov	BYTE PTR $T98174[ebp], al
	movzx	eax, BYTE PTR $T98173[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T98174[ebp]
	push	ecx
	mov	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@PAPAVMaterialParam@Ogre@@@std@@YAPAPAVMaterialParam@Ogre@@AAPAPAV12@@Z ; std::_Checked_base<Ogre::MaterialParam * *>
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@PAPAVMaterialParam@Ogre@@@std@@YAPAPAVMaterialParam@Ogre@@AAPAPAV12@@Z ; std::_Checked_base<Ogre::MaterialParam * *>
	add	esp, 4
	push	eax
	call	??$_Uninit_copy@PAPAVMaterialParam@Ogre@@PAPAV12@V?$allocator@PAVMaterialParam@Ogre@@@std@@@std@@YAPAPAVMaterialParam@Ogre@@PAPAV12@00AAV?$allocator@PAVMaterialParam@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Ogre::MaterialParam * *,Ogre::MaterialParam * *,std::allocator<Ogre::MaterialParam *> >
	add	esp, 24					; 00000018H

; 823  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_copy@PAPAVMaterialParam@Ogre@@PAPAV12@V?$allocator@PAVMaterialParam@Ogre@@@std@@@stdext@@YAPAPAVMaterialParam@Ogre@@PAPAV12@00AAV?$allocator@PAVMaterialParam@Ogre@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<Ogre::MaterialParam * *,Ogre::MaterialParam * *,std::allocator<Ogre::MaterialParam *> >
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PBDPADV?$allocator@D@std@@@std@@YAPADPBD0PADAAV?$allocator@D@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<char const *,char *,std::allocator<char> >
PUBLIC	??$_Checked_base@V?$_Vector_const_iterator@DV?$allocator@D@std@@@std@@@std@@YAPBDAAV?$_Vector_const_iterator@DV?$allocator@D@std@@@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<char,std::allocator<char> > >
PUBLIC	??$_Ptr_cat@V?$_Vector_const_iterator@DV?$allocator@D@std@@@std@@PAD@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@DV?$allocator@D@std@@@0@AAPAD@Z ; std::_Ptr_cat<std::_Vector_const_iterator<char,std::allocator<char> >,char *>
; Function compile flags: /Odtp
;	COMDAT ??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@DV?$allocator@D@std@@@std@@PADV?$allocator@D@2@@stdext@@YAPADV?$_Vector_const_iterator@DV?$allocator@D@std@@@std@@0PADAAV?$allocator@D@2@@Z
_TEXT	SEGMENT
$T98178 = -2						; size = 1
$T98177 = -1						; size = 1
__First$ = 8						; size = 8
__Last$ = 16						; size = 8
__Dest$ = 24						; size = 4
__Al$ = 28						; size = 4
??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@DV?$allocator@D@std@@@std@@PADV?$allocator@D@2@@stdext@@YAPADV?$_Vector_const_iterator@DV?$allocator@D@std@@@std@@0PADAAV?$allocator@D@2@@Z PROC ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<char,std::allocator<char> >,char *,std::allocator<char> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T98177[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@V?$_Vector_const_iterator@DV?$allocator@D@std@@@std@@PAD@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@DV?$allocator@D@std@@@0@AAPAD@Z ; std::_Ptr_cat<std::_Vector_const_iterator<char,std::allocator<char> >,char *>
	add	esp, 8
	mov	BYTE PTR $T98178[ebp], al
	movzx	eax, BYTE PTR $T98177[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T98178[ebp]
	push	ecx
	mov	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@V?$_Vector_const_iterator@DV?$allocator@D@std@@@std@@@std@@YAPBDAAV?$_Vector_const_iterator@DV?$allocator@D@std@@@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<char,std::allocator<char> > >
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@V?$_Vector_const_iterator@DV?$allocator@D@std@@@std@@@std@@YAPBDAAV?$_Vector_const_iterator@DV?$allocator@D@std@@@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<char,std::allocator<char> > >
	add	esp, 4
	push	eax
	call	??$_Uninit_copy@PBDPADV?$allocator@D@std@@@std@@YAPADPBD0PADAAV?$allocator@D@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<char const *,char *,std::allocator<char> >
	add	esp, 24					; 00000018H

; 823  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@DV?$allocator@D@std@@@std@@PADV?$allocator@D@2@@stdext@@YAPADV?$_Vector_const_iterator@DV?$allocator@D@std@@@std@@0PADAAV?$allocator@D@2@@Z ENDP ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<char,std::allocator<char> >,char *,std::allocator<char> >
_TEXT	ENDS
PUBLIC	??$_Checked_base@PAD@std@@YAPADAAPADU_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<char *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Checked_base@PAD@std@@YAPADAAPAD@Z
_TEXT	SEGMENT
__Base_tag$ = -1					; size = 1
__It$ = 8						; size = 4
??$_Checked_base@PAD@std@@YAPADAAPAD@Z PROC		; std::_Checked_base<char *>, COMDAT

; 1163 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1164 : 		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
; 1165 : 		return _Checked_base(_It, _Base_tag);

	movzx	eax, BYTE PTR __Base_tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR __It$[ebp]
	push	ecx
	call	??$_Checked_base@PAD@std@@YAPADAAPADU_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<char *>
	add	esp, 8

; 1166 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Checked_base@PAD@std@@YAPADAAPAD@Z ENDP		; std::_Checked_base<char *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Iter_random@PADPAD@std@@YA?AUrandom_access_iterator_tag@0@ABQAD0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PADPAD@std@@YA?AUrandom_access_iterator_tag@0@ABQAD0@Z PROC ; std::_Iter_random<char *,char *>, COMDAT

; 993  : 	{	// return category from iterator argument

	push	ebp
	mov	ebp, esp
	push	ecx

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 998  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Iter_random@PADPAD@std@@YA?AUrandom_access_iterator_tag@0@ABQAD0@Z ENDP ; std::_Iter_random<char *,char *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PADPAD@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAD0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PADPAD@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAD0@Z PROC ; std::_Ptr_cat<char *,char *>, COMDAT

; 1509 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 1512 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Ptr_cat@PADPAD@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAD0@Z ENDP ; std::_Ptr_cat<char *,char *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Copy_opt@PADPADUrandom_access_iterator_tag@std@@@std@@YAPADPAD00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Off$ = -8						; size = 4
__Result$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PADPADUrandom_access_iterator_tag@std@@@std@@YAPADPAD00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<char *,char *,std::random_access_iterator_tag>, COMDAT

; 2494 : 	{	// copy [_First, _Last) to [_Dest, ...), pointers to scalars

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 2495 : 
; 2496 :  #if _HAS_ITERATOR_DEBUGGING
; 2497 : 	_DEBUG_RANGE(_First, _Last);
; 2498 : 	if (_First != _Last)
; 2499 : 		_DEBUG_POINTER(_Dest);
; 2500 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2501 : 
; 2502 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Off$[ebp], eax

; 2503 : 	// if _OutIt is range checked, this will make sure there is enough space for the memmove
; 2504 : 	_OutIt _Result = _Dest + _Off;

	mov	ecx, DWORD PTR __Dest$[ebp]
	add	ecx, DWORD PTR __Off$[ebp]
	mov	DWORD PTR __Result$[ebp], ecx

; 2505 : 	if (_Off > 0)

	cmp	DWORD PTR __Off$[ebp], 0
	jle	SHORT $LN1@Copy_opt@4

; 2506 : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Off * sizeof (*_First), &*_First, _Off * sizeof (*_First));

	mov	edx, DWORD PTR __Off$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Off$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN1@Copy_opt@4:

; 2507 : 	return _Result;

	mov	eax, DWORD PTR __Result$[ebp]

; 2508 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Copy_opt@PADPADUrandom_access_iterator_tag@std@@@std@@YAPADPAD00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<char *,char *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PADPADV?$allocator@D@std@@@std@@YAPADPAD00AAV?$allocator@D@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<char *,char *,std::allocator<char> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_copy@PADPADV?$allocator@D@std@@@stdext@@YAPADPAD00AAV?$allocator@D@std@@@Z
_TEXT	SEGMENT
$T98190 = -2						; size = 1
$T98189 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@PADPADV?$allocator@D@std@@@stdext@@YAPADPAD00AAV?$allocator@D@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<char *,char *,std::allocator<char> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T98189[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PADPAD@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAD0@Z ; std::_Ptr_cat<char *,char *>
	add	esp, 8
	mov	BYTE PTR $T98190[ebp], al
	movzx	eax, BYTE PTR $T98189[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T98190[ebp]
	push	ecx
	mov	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@PAD@std@@YAPADAAPAD@Z	; std::_Checked_base<char *>
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@PAD@std@@YAPADAAPAD@Z	; std::_Checked_base<char *>
	add	esp, 4
	push	eax
	call	??$_Uninit_copy@PADPADV?$allocator@D@std@@@std@@YAPADPAD00AAV?$allocator@D@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<char *,char *,std::allocator<char> >
	add	esp, 24					; 00000018H

; 823  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_copy@PADPADV?$allocator@D@std@@@stdext@@YAPADPAD00AAV?$allocator@D@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<char *,char *,std::allocator<char> >
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PBQAVSurfaceData@Ogre@@PAPAV12@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@YAPAPAVSurfaceData@Ogre@@PBQAV12@0PAPAV12@AAV?$allocator@PAVSurfaceData@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Ogre::SurfaceData * const *,Ogre::SurfaceData * *,std::allocator<Ogre::SurfaceData *> >
PUBLIC	??$_Checked_base@V?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@@std@@YAPBQAVSurfaceData@Ogre@@AAV?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> > >
PUBLIC	??$_Ptr_cat@V?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@PAPAVSurfaceData@Ogre@@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@0@AAPAPAVSurfaceData@Ogre@@@Z ; std::_Ptr_cat<std::_Vector_const_iterator<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >,Ogre::SurfaceData * *>
; Function compile flags: /Odtp
;	COMDAT ??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@PAPAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@2@@stdext@@YAPAPAVSurfaceData@Ogre@@V?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@0PAPAV12@AAV?$allocator@PAVSurfaceData@Ogre@@@4@@Z
_TEXT	SEGMENT
$T98194 = -2						; size = 1
$T98193 = -1						; size = 1
__First$ = 8						; size = 8
__Last$ = 16						; size = 8
__Dest$ = 24						; size = 4
__Al$ = 28						; size = 4
??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@PAPAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@2@@stdext@@YAPAPAVSurfaceData@Ogre@@V?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@0PAPAV12@AAV?$allocator@PAVSurfaceData@Ogre@@@4@@Z PROC ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >,Ogre::SurfaceData * *,std::allocator<Ogre::SurfaceData *> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T98193[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@V?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@PAPAVSurfaceData@Ogre@@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@0@AAPAPAVSurfaceData@Ogre@@@Z ; std::_Ptr_cat<std::_Vector_const_iterator<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >,Ogre::SurfaceData * *>
	add	esp, 8
	mov	BYTE PTR $T98194[ebp], al
	movzx	eax, BYTE PTR $T98193[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T98194[ebp]
	push	ecx
	mov	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@V?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@@std@@YAPBQAVSurfaceData@Ogre@@AAV?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> > >
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@V?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@@std@@YAPBQAVSurfaceData@Ogre@@AAV?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> > >
	add	esp, 4
	push	eax
	call	??$_Uninit_copy@PBQAVSurfaceData@Ogre@@PAPAV12@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@YAPAPAVSurfaceData@Ogre@@PBQAV12@0PAPAV12@AAV?$allocator@PAVSurfaceData@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Ogre::SurfaceData * const *,Ogre::SurfaceData * *,std::allocator<Ogre::SurfaceData *> >
	add	esp, 24					; 00000018H

; 823  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@PAPAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@2@@stdext@@YAPAPAVSurfaceData@Ogre@@V?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@0PAPAV12@AAV?$allocator@PAVSurfaceData@Ogre@@@4@@Z ENDP ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >,Ogre::SurfaceData * *,std::allocator<Ogre::SurfaceData *> >
_TEXT	ENDS
PUBLIC	??$_Checked_base@PAPAVSurfaceData@Ogre@@@std@@YAPAPAVSurfaceData@Ogre@@AAPAPAV12@U_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<Ogre::SurfaceData * *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Checked_base@PAPAVSurfaceData@Ogre@@@std@@YAPAPAVSurfaceData@Ogre@@AAPAPAV12@@Z
_TEXT	SEGMENT
__Base_tag$ = -1					; size = 1
__It$ = 8						; size = 4
??$_Checked_base@PAPAVSurfaceData@Ogre@@@std@@YAPAPAVSurfaceData@Ogre@@AAPAPAV12@@Z PROC ; std::_Checked_base<Ogre::SurfaceData * *>, COMDAT

; 1163 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1164 : 		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
; 1165 : 		return _Checked_base(_It, _Base_tag);

	movzx	eax, BYTE PTR __Base_tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR __It$[ebp]
	push	ecx
	call	??$_Checked_base@PAPAVSurfaceData@Ogre@@@std@@YAPAPAVSurfaceData@Ogre@@AAPAPAV12@U_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<Ogre::SurfaceData * *>
	add	esp, 8

; 1166 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Checked_base@PAPAVSurfaceData@Ogre@@@std@@YAPAPAVSurfaceData@Ogre@@AAPAPAV12@@Z ENDP ; std::_Checked_base<Ogre::SurfaceData * *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Iter_random@PAPAVSurfaceData@Ogre@@PAPAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVSurfaceData@Ogre@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAPAVSurfaceData@Ogre@@PAPAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVSurfaceData@Ogre@@0@Z PROC ; std::_Iter_random<Ogre::SurfaceData * *,Ogre::SurfaceData * *>, COMDAT

; 993  : 	{	// return category from iterator argument

	push	ebp
	mov	ebp, esp
	push	ecx

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 998  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Iter_random@PAPAVSurfaceData@Ogre@@PAPAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVSurfaceData@Ogre@@0@Z ENDP ; std::_Iter_random<Ogre::SurfaceData * *,Ogre::SurfaceData * *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAPAVSurfaceData@Ogre@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVSurfaceData@Ogre@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAPAVSurfaceData@Ogre@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVSurfaceData@Ogre@@0@Z PROC ; std::_Ptr_cat<Ogre::SurfaceData * *,Ogre::SurfaceData * *>, COMDAT

; 1509 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 1512 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Ptr_cat@PAPAVSurfaceData@Ogre@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVSurfaceData@Ogre@@0@Z ENDP ; std::_Ptr_cat<Ogre::SurfaceData * *,Ogre::SurfaceData * *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Copy_opt@PAPAVSurfaceData@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@@std@@YAPAPAVSurfaceData@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Off$ = -8						; size = 4
__Result$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAPAVSurfaceData@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@@std@@YAPAPAVSurfaceData@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<Ogre::SurfaceData * *,Ogre::SurfaceData * *,std::random_access_iterator_tag>, COMDAT

; 2494 : 	{	// copy [_First, _Last) to [_Dest, ...), pointers to scalars

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 2495 : 
; 2496 :  #if _HAS_ITERATOR_DEBUGGING
; 2497 : 	_DEBUG_RANGE(_First, _Last);
; 2498 : 	if (_First != _Last)
; 2499 : 		_DEBUG_POINTER(_Dest);
; 2500 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2501 : 
; 2502 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 2
	mov	DWORD PTR __Off$[ebp], eax

; 2503 : 	// if _OutIt is range checked, this will make sure there is enough space for the memmove
; 2504 : 	_OutIt _Result = _Dest + _Off;

	mov	ecx, DWORD PTR __Off$[ebp]
	mov	edx, DWORD PTR __Dest$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR __Result$[ebp], eax

; 2505 : 	if (_Off > 0)

	cmp	DWORD PTR __Off$[ebp], 0
	jle	SHORT $LN1@Copy_opt@5

; 2506 : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Off * sizeof (*_First), &*_First, _Off * sizeof (*_First));

	mov	ecx, DWORD PTR __Off$[ebp]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	eax, DWORD PTR __Off$[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN1@Copy_opt@5:

; 2507 : 	return _Result;

	mov	eax, DWORD PTR __Result$[ebp]

; 2508 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Copy_opt@PAPAVSurfaceData@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@@std@@YAPAPAVSurfaceData@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<Ogre::SurfaceData * *,Ogre::SurfaceData * *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PAPAVSurfaceData@Ogre@@PAPAV12@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@YAPAPAVSurfaceData@Ogre@@PAPAV12@00AAV?$allocator@PAVSurfaceData@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Ogre::SurfaceData * *,Ogre::SurfaceData * *,std::allocator<Ogre::SurfaceData *> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_copy@PAPAVSurfaceData@Ogre@@PAPAV12@V?$allocator@PAVSurfaceData@Ogre@@@std@@@stdext@@YAPAPAVSurfaceData@Ogre@@PAPAV12@00AAV?$allocator@PAVSurfaceData@Ogre@@@std@@@Z
_TEXT	SEGMENT
$T98206 = -2						; size = 1
$T98205 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@PAPAVSurfaceData@Ogre@@PAPAV12@V?$allocator@PAVSurfaceData@Ogre@@@std@@@stdext@@YAPAPAVSurfaceData@Ogre@@PAPAV12@00AAV?$allocator@PAVSurfaceData@Ogre@@@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<Ogre::SurfaceData * *,Ogre::SurfaceData * *,std::allocator<Ogre::SurfaceData *> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T98205[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAPAVSurfaceData@Ogre@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVSurfaceData@Ogre@@0@Z ; std::_Ptr_cat<Ogre::SurfaceData * *,Ogre::SurfaceData * *>
	add	esp, 8
	mov	BYTE PTR $T98206[ebp], al
	movzx	eax, BYTE PTR $T98205[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T98206[ebp]
	push	ecx
	mov	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@PAPAVSurfaceData@Ogre@@@std@@YAPAPAVSurfaceData@Ogre@@AAPAPAV12@@Z ; std::_Checked_base<Ogre::SurfaceData * *>
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@PAPAVSurfaceData@Ogre@@@std@@YAPAPAVSurfaceData@Ogre@@AAPAPAV12@@Z ; std::_Checked_base<Ogre::SurfaceData * *>
	add	esp, 4
	push	eax
	call	??$_Uninit_copy@PAPAVSurfaceData@Ogre@@PAPAV12@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@YAPAPAVSurfaceData@Ogre@@PAPAV12@00AAV?$allocator@PAVSurfaceData@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Ogre::SurfaceData * *,Ogre::SurfaceData * *,std::allocator<Ogre::SurfaceData *> >
	add	esp, 24					; 00000018H

; 823  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_copy@PAPAVSurfaceData@Ogre@@PAPAV12@V?$allocator@PAVSurfaceData@Ogre@@@std@@@stdext@@YAPAPAVSurfaceData@Ogre@@PAPAV12@00AAV?$allocator@PAVSurfaceData@Ogre@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<Ogre::SurfaceData * *,Ogre::SurfaceData * *,std::allocator<Ogre::SurfaceData *> >
_TEXT	ENDS
PUBLIC	??$_Checked_base@PAG@std@@YAPAGAAPAGU_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<unsigned short *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Checked_base@PAG@std@@YAPAGAAPAG@Z
_TEXT	SEGMENT
__Base_tag$ = -1					; size = 1
__It$ = 8						; size = 4
??$_Checked_base@PAG@std@@YAPAGAAPAG@Z PROC		; std::_Checked_base<unsigned short *>, COMDAT

; 1163 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1164 : 		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
; 1165 : 		return _Checked_base(_It, _Base_tag);

	movzx	eax, BYTE PTR __Base_tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR __It$[ebp]
	push	ecx
	call	??$_Checked_base@PAG@std@@YAPAGAAPAGU_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<unsigned short *>
	add	esp, 8

; 1166 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Checked_base@PAG@std@@YAPAGAAPAG@Z ENDP		; std::_Checked_base<unsigned short *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Iter_random@PAGPAG@std@@YA?AUrandom_access_iterator_tag@0@ABQAG0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAGPAG@std@@YA?AUrandom_access_iterator_tag@0@ABQAG0@Z PROC ; std::_Iter_random<unsigned short *,unsigned short *>, COMDAT

; 993  : 	{	// return category from iterator argument

	push	ebp
	mov	ebp, esp
	push	ecx

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 998  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Iter_random@PAGPAG@std@@YA?AUrandom_access_iterator_tag@0@ABQAG0@Z ENDP ; std::_Iter_random<unsigned short *,unsigned short *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAGPAG@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAG0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAGPAG@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAG0@Z PROC ; std::_Ptr_cat<unsigned short *,unsigned short *>, COMDAT

; 1509 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 1512 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Ptr_cat@PAGPAG@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAG0@Z ENDP ; std::_Ptr_cat<unsigned short *,unsigned short *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Copy_opt@PAGPAGUrandom_access_iterator_tag@std@@@std@@YAPAGPAG00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Off$ = -8						; size = 4
__Result$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAGPAGUrandom_access_iterator_tag@std@@@std@@YAPAGPAG00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<unsigned short *,unsigned short *,std::random_access_iterator_tag>, COMDAT

; 2494 : 	{	// copy [_First, _Last) to [_Dest, ...), pointers to scalars

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 2495 : 
; 2496 :  #if _HAS_ITERATOR_DEBUGGING
; 2497 : 	_DEBUG_RANGE(_First, _Last);
; 2498 : 	if (_First != _Last)
; 2499 : 		_DEBUG_POINTER(_Dest);
; 2500 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2501 : 
; 2502 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 1
	mov	DWORD PTR __Off$[ebp], eax

; 2503 : 	// if _OutIt is range checked, this will make sure there is enough space for the memmove
; 2504 : 	_OutIt _Result = _Dest + _Off;

	mov	ecx, DWORD PTR __Off$[ebp]
	mov	edx, DWORD PTR __Dest$[ebp]
	lea	eax, DWORD PTR [edx+ecx*2]
	mov	DWORD PTR __Result$[ebp], eax

; 2505 : 	if (_Off > 0)

	cmp	DWORD PTR __Off$[ebp], 0
	jle	SHORT $LN1@Copy_opt@6

; 2506 : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Off * sizeof (*_First), &*_First, _Off * sizeof (*_First));

	mov	ecx, DWORD PTR __Off$[ebp]
	shl	ecx, 1
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	eax, DWORD PTR __Off$[ebp]
	shl	eax, 1
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN1@Copy_opt@6:

; 2507 : 	return _Result;

	mov	eax, DWORD PTR __Result$[ebp]

; 2508 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Copy_opt@PAGPAGUrandom_access_iterator_tag@std@@@std@@YAPAGPAG00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<unsigned short *,unsigned short *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PAGPAGV?$allocator@G@std@@@std@@YAPAGPAG00AAV?$allocator@G@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<unsigned short *,unsigned short *,std::allocator<unsigned short> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_copy@PAGPAGV?$allocator@G@std@@@stdext@@YAPAGPAG00AAV?$allocator@G@std@@@Z
_TEXT	SEGMENT
$T98218 = -2						; size = 1
$T98217 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@PAGPAGV?$allocator@G@std@@@stdext@@YAPAGPAG00AAV?$allocator@G@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<unsigned short *,unsigned short *,std::allocator<unsigned short> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T98217[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAGPAG@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAG0@Z ; std::_Ptr_cat<unsigned short *,unsigned short *>
	add	esp, 8
	mov	BYTE PTR $T98218[ebp], al
	movzx	eax, BYTE PTR $T98217[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T98218[ebp]
	push	ecx
	mov	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@PAG@std@@YAPAGAAPAG@Z	; std::_Checked_base<unsigned short *>
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@PAG@std@@YAPAGAAPAG@Z	; std::_Checked_base<unsigned short *>
	add	esp, 4
	push	eax
	call	??$_Uninit_copy@PAGPAGV?$allocator@G@std@@@std@@YAPAGPAG00AAV?$allocator@G@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<unsigned short *,unsigned short *,std::allocator<unsigned short> >
	add	esp, 24					; 00000018H

; 823  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_copy@PAGPAGV?$allocator@G@std@@@stdext@@YAPAGPAG00AAV?$allocator@G@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<unsigned short *,unsigned short *,std::allocator<unsigned short> >
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PBURecord@CullResult@Ogre@@PAU123@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@YAPAURecord@CullResult@Ogre@@PBU123@0PAU123@AAV?$allocator@URecord@CullResult@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Ogre::CullResult::Record const *,Ogre::CullResult::Record *,std::allocator<Ogre::CullResult::Record> >
PUBLIC	??$_Checked_base@V?$_Vector_const_iterator@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@@std@@YAPBURecord@CullResult@Ogre@@AAV?$_Vector_const_iterator@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::CullResult::Record,std::allocator<Ogre::CullResult::Record> > >
PUBLIC	??$_Ptr_cat@V?$_Vector_const_iterator@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@PAURecord@CullResult@Ogre@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@0@AAPAURecord@CullResult@Ogre@@@Z ; std::_Ptr_cat<std::_Vector_const_iterator<Ogre::CullResult::Record,std::allocator<Ogre::CullResult::Record> >,Ogre::CullResult::Record *>
; Function compile flags: /Odtp
;	COMDAT ??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@PAURecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@2@@stdext@@YAPAURecord@CullResult@Ogre@@V?$_Vector_const_iterator@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@0PAU123@AAV?$allocator@URecord@CullResult@Ogre@@@5@@Z
_TEXT	SEGMENT
$T98222 = -2						; size = 1
$T98221 = -1						; size = 1
__First$ = 8						; size = 8
__Last$ = 16						; size = 8
__Dest$ = 24						; size = 4
__Al$ = 28						; size = 4
??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@PAURecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@2@@stdext@@YAPAURecord@CullResult@Ogre@@V?$_Vector_const_iterator@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@0PAU123@AAV?$allocator@URecord@CullResult@Ogre@@@5@@Z PROC ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<Ogre::CullResult::Record,std::allocator<Ogre::CullResult::Record> >,Ogre::CullResult::Record *,std::allocator<Ogre::CullResult::Record> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T98221[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@V?$_Vector_const_iterator@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@PAURecord@CullResult@Ogre@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@0@AAPAURecord@CullResult@Ogre@@@Z ; std::_Ptr_cat<std::_Vector_const_iterator<Ogre::CullResult::Record,std::allocator<Ogre::CullResult::Record> >,Ogre::CullResult::Record *>
	add	esp, 8
	mov	BYTE PTR $T98222[ebp], al
	movzx	eax, BYTE PTR $T98221[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T98222[ebp]
	push	ecx
	mov	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@V?$_Vector_const_iterator@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@@std@@YAPBURecord@CullResult@Ogre@@AAV?$_Vector_const_iterator@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::CullResult::Record,std::allocator<Ogre::CullResult::Record> > >
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@V?$_Vector_const_iterator@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@@std@@YAPBURecord@CullResult@Ogre@@AAV?$_Vector_const_iterator@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::CullResult::Record,std::allocator<Ogre::CullResult::Record> > >
	add	esp, 4
	push	eax
	call	??$_Uninit_copy@PBURecord@CullResult@Ogre@@PAU123@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@YAPAURecord@CullResult@Ogre@@PBU123@0PAU123@AAV?$allocator@URecord@CullResult@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Ogre::CullResult::Record const *,Ogre::CullResult::Record *,std::allocator<Ogre::CullResult::Record> >
	add	esp, 24					; 00000018H

; 823  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@PAURecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@2@@stdext@@YAPAURecord@CullResult@Ogre@@V?$_Vector_const_iterator@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@0PAU123@AAV?$allocator@URecord@CullResult@Ogre@@@5@@Z ENDP ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<Ogre::CullResult::Record,std::allocator<Ogre::CullResult::Record> >,Ogre::CullResult::Record *,std::allocator<Ogre::CullResult::Record> >
_TEXT	ENDS
PUBLIC	??$_Checked_base@PAURecord@CullResult@Ogre@@@std@@YAPAURecord@CullResult@Ogre@@AAPAU123@U_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<Ogre::CullResult::Record *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Checked_base@PAURecord@CullResult@Ogre@@@std@@YAPAURecord@CullResult@Ogre@@AAPAU123@@Z
_TEXT	SEGMENT
__Base_tag$ = -1					; size = 1
__It$ = 8						; size = 4
??$_Checked_base@PAURecord@CullResult@Ogre@@@std@@YAPAURecord@CullResult@Ogre@@AAPAU123@@Z PROC ; std::_Checked_base<Ogre::CullResult::Record *>, COMDAT

; 1163 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1164 : 		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
; 1165 : 		return _Checked_base(_It, _Base_tag);

	movzx	eax, BYTE PTR __Base_tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR __It$[ebp]
	push	ecx
	call	??$_Checked_base@PAURecord@CullResult@Ogre@@@std@@YAPAURecord@CullResult@Ogre@@AAPAU123@U_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<Ogre::CullResult::Record *>
	add	esp, 8

; 1166 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Checked_base@PAURecord@CullResult@Ogre@@@std@@YAPAURecord@CullResult@Ogre@@AAPAU123@@Z ENDP ; std::_Checked_base<Ogre::CullResult::Record *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Iter_random@PAURecord@CullResult@Ogre@@PAU123@@std@@YA?AUrandom_access_iterator_tag@0@ABQAURecord@CullResult@Ogre@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAURecord@CullResult@Ogre@@PAU123@@std@@YA?AUrandom_access_iterator_tag@0@ABQAURecord@CullResult@Ogre@@0@Z PROC ; std::_Iter_random<Ogre::CullResult::Record *,Ogre::CullResult::Record *>, COMDAT

; 993  : 	{	// return category from iterator argument

	push	ebp
	mov	ebp, esp
	push	ecx

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 998  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Iter_random@PAURecord@CullResult@Ogre@@PAU123@@std@@YA?AUrandom_access_iterator_tag@0@ABQAURecord@CullResult@Ogre@@0@Z ENDP ; std::_Iter_random<Ogre::CullResult::Record *,Ogre::CullResult::Record *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAURecord@CullResult@Ogre@@PAU123@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAURecord@CullResult@Ogre@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAURecord@CullResult@Ogre@@PAU123@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAURecord@CullResult@Ogre@@0@Z PROC ; std::_Ptr_cat<Ogre::CullResult::Record *,Ogre::CullResult::Record *>, COMDAT

; 1509 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 1512 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Ptr_cat@PAURecord@CullResult@Ogre@@PAU123@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAURecord@CullResult@Ogre@@0@Z ENDP ; std::_Ptr_cat<Ogre::CullResult::Record *,Ogre::CullResult::Record *>
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAURecord@CullResult@Ogre@@PAU123@Uforward_iterator_tag@std@@@std@@YAPAURecord@CullResult@Ogre@@PAU123@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<Ogre::CullResult::Record *,Ogre::CullResult::Record *,std::forward_iterator_tag>
; Function compile flags: /Odtp
;	COMDAT ??$_Copy_opt@PAURecord@CullResult@Ogre@@PAU123@@std@@YAPAURecord@CullResult@Ogre@@PAU123@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T98233 = -7						; size = 1
$T98232 = -6						; size = 1
$T98231 = -5						; size = 1
__Result$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAURecord@CullResult@Ogre@@PAU123@@std@@YAPAURecord@CullResult@Ogre@@PAU123@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<Ogre::CullResult::Record *,Ogre::CullResult::Record *>, COMDAT

; 2481 : 	{	// copy [_First, _Last) to [_Dest, ...), random_access iterators

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 2482 : 	// if _OutIt is range checked, this will make sure there is enough space for the copy
; 2483 : 	_OutIt _Result = _Dest + (_Last - _First);

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 4
	shl	eax, 4
	add	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Result$[ebp], eax

; 2484 : 	_Copy_opt(_First, _Last, _CHECKED_BASE(_Dest), 
; 2485 : 		forward_iterator_tag(), _Nonscalar_ptr_iterator_tag(), _Range_checked_iterator_tag());

	xor	ecx, ecx
	mov	BYTE PTR $T98231[ebp], cl
	xor	edx, edx
	mov	BYTE PTR $T98232[ebp], dl
	movzx	eax, BYTE PTR $T98231[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T98232[ebp]
	push	ecx
	movzx	edx, BYTE PTR $T98233[ebp]
	push	edx
	lea	eax, DWORD PTR __Dest$[ebp]
	push	eax
	call	??$_Checked_base@PAURecord@CullResult@Ogre@@@std@@YAPAURecord@CullResult@Ogre@@AAPAU123@@Z ; std::_Checked_base<Ogre::CullResult::Record *>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Copy_opt@PAURecord@CullResult@Ogre@@PAU123@Uforward_iterator_tag@std@@@std@@YAPAURecord@CullResult@Ogre@@PAU123@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<Ogre::CullResult::Record *,Ogre::CullResult::Record *,std::forward_iterator_tag>
	add	esp, 24					; 00000018H

; 2486 : 	return _Result;

	mov	eax, DWORD PTR __Result$[ebp]

; 2487 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Copy_opt@PAURecord@CullResult@Ogre@@PAU123@@std@@YAPAURecord@CullResult@Ogre@@PAU123@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<Ogre::CullResult::Record *,Ogre::CullResult::Record *>
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PAURecord@CullResult@Ogre@@PAU123@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@YAPAURecord@CullResult@Ogre@@PAU123@00AAV?$allocator@URecord@CullResult@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Ogre::CullResult::Record *,Ogre::CullResult::Record *,std::allocator<Ogre::CullResult::Record> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_copy@PAURecord@CullResult@Ogre@@PAU123@V?$allocator@URecord@CullResult@Ogre@@@std@@@stdext@@YAPAURecord@CullResult@Ogre@@PAU123@00AAV?$allocator@URecord@CullResult@Ogre@@@std@@@Z
_TEXT	SEGMENT
$T98237 = -2						; size = 1
$T98236 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@PAURecord@CullResult@Ogre@@PAU123@V?$allocator@URecord@CullResult@Ogre@@@std@@@stdext@@YAPAURecord@CullResult@Ogre@@PAU123@00AAV?$allocator@URecord@CullResult@Ogre@@@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<Ogre::CullResult::Record *,Ogre::CullResult::Record *,std::allocator<Ogre::CullResult::Record> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T98236[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAURecord@CullResult@Ogre@@PAU123@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAURecord@CullResult@Ogre@@0@Z ; std::_Ptr_cat<Ogre::CullResult::Record *,Ogre::CullResult::Record *>
	add	esp, 8
	mov	BYTE PTR $T98237[ebp], al
	movzx	eax, BYTE PTR $T98236[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T98237[ebp]
	push	ecx
	mov	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@PAURecord@CullResult@Ogre@@@std@@YAPAURecord@CullResult@Ogre@@AAPAU123@@Z ; std::_Checked_base<Ogre::CullResult::Record *>
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@PAURecord@CullResult@Ogre@@@std@@YAPAURecord@CullResult@Ogre@@AAPAU123@@Z ; std::_Checked_base<Ogre::CullResult::Record *>
	add	esp, 4
	push	eax
	call	??$_Uninit_copy@PAURecord@CullResult@Ogre@@PAU123@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@YAPAURecord@CullResult@Ogre@@PAU123@00AAV?$allocator@URecord@CullResult@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Ogre::CullResult::Record *,Ogre::CullResult::Record *,std::allocator<Ogre::CullResult::Record> >
	add	esp, 24					; 00000018H

; 823  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_copy@PAURecord@CullResult@Ogre@@PAU123@V?$allocator@URecord@CullResult@Ogre@@@std@@@stdext@@YAPAURecord@CullResult@Ogre@@PAU123@00AAV?$allocator@URecord@CullResult@Ogre@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<Ogre::CullResult::Record *,Ogre::CullResult::Record *,std::allocator<Ogre::CullResult::Record> >
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PBQAVEffectObject@Ogre@@PAPAV12@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@YAPAPAVEffectObject@Ogre@@PBQAV12@0PAPAV12@AAV?$allocator@PAVEffectObject@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Ogre::EffectObject * const *,Ogre::EffectObject * *,std::allocator<Ogre::EffectObject *> >
PUBLIC	??$_Checked_base@V?$_Vector_const_iterator@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@@std@@YAPBQAVEffectObject@Ogre@@AAV?$_Vector_const_iterator@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::EffectObject *,std::allocator<Ogre::EffectObject *> > >
PUBLIC	??$_Ptr_cat@V?$_Vector_const_iterator@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@PAPAVEffectObject@Ogre@@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@0@AAPAPAVEffectObject@Ogre@@@Z ; std::_Ptr_cat<std::_Vector_const_iterator<Ogre::EffectObject *,std::allocator<Ogre::EffectObject *> >,Ogre::EffectObject * *>
; Function compile flags: /Odtp
;	COMDAT ??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@PAPAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@2@@stdext@@YAPAPAVEffectObject@Ogre@@V?$_Vector_const_iterator@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@0PAPAV12@AAV?$allocator@PAVEffectObject@Ogre@@@4@@Z
_TEXT	SEGMENT
$T98241 = -2						; size = 1
$T98240 = -1						; size = 1
__First$ = 8						; size = 8
__Last$ = 16						; size = 8
__Dest$ = 24						; size = 4
__Al$ = 28						; size = 4
??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@PAPAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@2@@stdext@@YAPAPAVEffectObject@Ogre@@V?$_Vector_const_iterator@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@0PAPAV12@AAV?$allocator@PAVEffectObject@Ogre@@@4@@Z PROC ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<Ogre::EffectObject *,std::allocator<Ogre::EffectObject *> >,Ogre::EffectObject * *,std::allocator<Ogre::EffectObject *> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T98240[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@V?$_Vector_const_iterator@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@PAPAVEffectObject@Ogre@@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@0@AAPAPAVEffectObject@Ogre@@@Z ; std::_Ptr_cat<std::_Vector_const_iterator<Ogre::EffectObject *,std::allocator<Ogre::EffectObject *> >,Ogre::EffectObject * *>
	add	esp, 8
	mov	BYTE PTR $T98241[ebp], al
	movzx	eax, BYTE PTR $T98240[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T98241[ebp]
	push	ecx
	mov	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@V?$_Vector_const_iterator@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@@std@@YAPBQAVEffectObject@Ogre@@AAV?$_Vector_const_iterator@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::EffectObject *,std::allocator<Ogre::EffectObject *> > >
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@V?$_Vector_const_iterator@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@@std@@YAPBQAVEffectObject@Ogre@@AAV?$_Vector_const_iterator@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::EffectObject *,std::allocator<Ogre::EffectObject *> > >
	add	esp, 4
	push	eax
	call	??$_Uninit_copy@PBQAVEffectObject@Ogre@@PAPAV12@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@YAPAPAVEffectObject@Ogre@@PBQAV12@0PAPAV12@AAV?$allocator@PAVEffectObject@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Ogre::EffectObject * const *,Ogre::EffectObject * *,std::allocator<Ogre::EffectObject *> >
	add	esp, 24					; 00000018H

; 823  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@PAPAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@2@@stdext@@YAPAPAVEffectObject@Ogre@@V?$_Vector_const_iterator@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@0PAPAV12@AAV?$allocator@PAVEffectObject@Ogre@@@4@@Z ENDP ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<Ogre::EffectObject *,std::allocator<Ogre::EffectObject *> >,Ogre::EffectObject * *,std::allocator<Ogre::EffectObject *> >
_TEXT	ENDS
PUBLIC	??$_Checked_base@PAPAVEffectObject@Ogre@@@std@@YAPAPAVEffectObject@Ogre@@AAPAPAV12@U_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<Ogre::EffectObject * *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Checked_base@PAPAVEffectObject@Ogre@@@std@@YAPAPAVEffectObject@Ogre@@AAPAPAV12@@Z
_TEXT	SEGMENT
__Base_tag$ = -1					; size = 1
__It$ = 8						; size = 4
??$_Checked_base@PAPAVEffectObject@Ogre@@@std@@YAPAPAVEffectObject@Ogre@@AAPAPAV12@@Z PROC ; std::_Checked_base<Ogre::EffectObject * *>, COMDAT

; 1163 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1164 : 		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
; 1165 : 		return _Checked_base(_It, _Base_tag);

	movzx	eax, BYTE PTR __Base_tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR __It$[ebp]
	push	ecx
	call	??$_Checked_base@PAPAVEffectObject@Ogre@@@std@@YAPAPAVEffectObject@Ogre@@AAPAPAV12@U_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<Ogre::EffectObject * *>
	add	esp, 8

; 1166 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Checked_base@PAPAVEffectObject@Ogre@@@std@@YAPAPAVEffectObject@Ogre@@AAPAPAV12@@Z ENDP ; std::_Checked_base<Ogre::EffectObject * *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Iter_random@PAPAVEffectObject@Ogre@@PAPAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVEffectObject@Ogre@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAPAVEffectObject@Ogre@@PAPAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVEffectObject@Ogre@@0@Z PROC ; std::_Iter_random<Ogre::EffectObject * *,Ogre::EffectObject * *>, COMDAT

; 993  : 	{	// return category from iterator argument

	push	ebp
	mov	ebp, esp
	push	ecx

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 998  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Iter_random@PAPAVEffectObject@Ogre@@PAPAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVEffectObject@Ogre@@0@Z ENDP ; std::_Iter_random<Ogre::EffectObject * *,Ogre::EffectObject * *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAPAVEffectObject@Ogre@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVEffectObject@Ogre@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAPAVEffectObject@Ogre@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVEffectObject@Ogre@@0@Z PROC ; std::_Ptr_cat<Ogre::EffectObject * *,Ogre::EffectObject * *>, COMDAT

; 1509 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 1512 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Ptr_cat@PAPAVEffectObject@Ogre@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVEffectObject@Ogre@@0@Z ENDP ; std::_Ptr_cat<Ogre::EffectObject * *,Ogre::EffectObject * *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Copy_opt@PAPAVEffectObject@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@@std@@YAPAPAVEffectObject@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Off$ = -8						; size = 4
__Result$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAPAVEffectObject@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@@std@@YAPAPAVEffectObject@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<Ogre::EffectObject * *,Ogre::EffectObject * *,std::random_access_iterator_tag>, COMDAT

; 2494 : 	{	// copy [_First, _Last) to [_Dest, ...), pointers to scalars

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 2495 : 
; 2496 :  #if _HAS_ITERATOR_DEBUGGING
; 2497 : 	_DEBUG_RANGE(_First, _Last);
; 2498 : 	if (_First != _Last)
; 2499 : 		_DEBUG_POINTER(_Dest);
; 2500 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2501 : 
; 2502 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 2
	mov	DWORD PTR __Off$[ebp], eax

; 2503 : 	// if _OutIt is range checked, this will make sure there is enough space for the memmove
; 2504 : 	_OutIt _Result = _Dest + _Off;

	mov	ecx, DWORD PTR __Off$[ebp]
	mov	edx, DWORD PTR __Dest$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR __Result$[ebp], eax

; 2505 : 	if (_Off > 0)

	cmp	DWORD PTR __Off$[ebp], 0
	jle	SHORT $LN1@Copy_opt@7

; 2506 : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Off * sizeof (*_First), &*_First, _Off * sizeof (*_First));

	mov	ecx, DWORD PTR __Off$[ebp]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	eax, DWORD PTR __Off$[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN1@Copy_opt@7:

; 2507 : 	return _Result;

	mov	eax, DWORD PTR __Result$[ebp]

; 2508 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Copy_opt@PAPAVEffectObject@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@@std@@YAPAPAVEffectObject@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<Ogre::EffectObject * *,Ogre::EffectObject * *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PAPAVEffectObject@Ogre@@PAPAV12@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@YAPAPAVEffectObject@Ogre@@PAPAV12@00AAV?$allocator@PAVEffectObject@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Ogre::EffectObject * *,Ogre::EffectObject * *,std::allocator<Ogre::EffectObject *> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_copy@PAPAVEffectObject@Ogre@@PAPAV12@V?$allocator@PAVEffectObject@Ogre@@@std@@@stdext@@YAPAPAVEffectObject@Ogre@@PAPAV12@00AAV?$allocator@PAVEffectObject@Ogre@@@std@@@Z
_TEXT	SEGMENT
$T98253 = -2						; size = 1
$T98252 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@PAPAVEffectObject@Ogre@@PAPAV12@V?$allocator@PAVEffectObject@Ogre@@@std@@@stdext@@YAPAPAVEffectObject@Ogre@@PAPAV12@00AAV?$allocator@PAVEffectObject@Ogre@@@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<Ogre::EffectObject * *,Ogre::EffectObject * *,std::allocator<Ogre::EffectObject *> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T98252[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAPAVEffectObject@Ogre@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVEffectObject@Ogre@@0@Z ; std::_Ptr_cat<Ogre::EffectObject * *,Ogre::EffectObject * *>
	add	esp, 8
	mov	BYTE PTR $T98253[ebp], al
	movzx	eax, BYTE PTR $T98252[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T98253[ebp]
	push	ecx
	mov	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@PAPAVEffectObject@Ogre@@@std@@YAPAPAVEffectObject@Ogre@@AAPAPAV12@@Z ; std::_Checked_base<Ogre::EffectObject * *>
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@PAPAVEffectObject@Ogre@@@std@@YAPAPAVEffectObject@Ogre@@AAPAPAV12@@Z ; std::_Checked_base<Ogre::EffectObject * *>
	add	esp, 4
	push	eax
	call	??$_Uninit_copy@PAPAVEffectObject@Ogre@@PAPAV12@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@YAPAPAVEffectObject@Ogre@@PAPAV12@00AAV?$allocator@PAVEffectObject@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Ogre::EffectObject * *,Ogre::EffectObject * *,std::allocator<Ogre::EffectObject *> >
	add	esp, 24					; 00000018H

; 823  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_copy@PAPAVEffectObject@Ogre@@PAPAV12@V?$allocator@PAVEffectObject@Ogre@@@std@@@stdext@@YAPAPAVEffectObject@Ogre@@PAPAV12@00AAV?$allocator@PAVEffectObject@Ogre@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<Ogre::EffectObject * *,Ogre::EffectObject * *,std::allocator<Ogre::EffectObject *> >
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PBQAVSoundNode@Ogre@@PAPAV12@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@YAPAPAVSoundNode@Ogre@@PBQAV12@0PAPAV12@AAV?$allocator@PAVSoundNode@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Ogre::SoundNode * const *,Ogre::SoundNode * *,std::allocator<Ogre::SoundNode *> >
PUBLIC	??$_Checked_base@V?$_Vector_const_iterator@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@@std@@YAPBQAVSoundNode@Ogre@@AAV?$_Vector_const_iterator@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::SoundNode *,std::allocator<Ogre::SoundNode *> > >
PUBLIC	??$_Ptr_cat@V?$_Vector_const_iterator@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@PAPAVSoundNode@Ogre@@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@0@AAPAPAVSoundNode@Ogre@@@Z ; std::_Ptr_cat<std::_Vector_const_iterator<Ogre::SoundNode *,std::allocator<Ogre::SoundNode *> >,Ogre::SoundNode * *>
; Function compile flags: /Odtp
;	COMDAT ??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@PAPAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@2@@stdext@@YAPAPAVSoundNode@Ogre@@V?$_Vector_const_iterator@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@0PAPAV12@AAV?$allocator@PAVSoundNode@Ogre@@@4@@Z
_TEXT	SEGMENT
$T98257 = -2						; size = 1
$T98256 = -1						; size = 1
__First$ = 8						; size = 8
__Last$ = 16						; size = 8
__Dest$ = 24						; size = 4
__Al$ = 28						; size = 4
??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@PAPAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@2@@stdext@@YAPAPAVSoundNode@Ogre@@V?$_Vector_const_iterator@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@0PAPAV12@AAV?$allocator@PAVSoundNode@Ogre@@@4@@Z PROC ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<Ogre::SoundNode *,std::allocator<Ogre::SoundNode *> >,Ogre::SoundNode * *,std::allocator<Ogre::SoundNode *> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T98256[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@V?$_Vector_const_iterator@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@PAPAVSoundNode@Ogre@@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@0@AAPAPAVSoundNode@Ogre@@@Z ; std::_Ptr_cat<std::_Vector_const_iterator<Ogre::SoundNode *,std::allocator<Ogre::SoundNode *> >,Ogre::SoundNode * *>
	add	esp, 8
	mov	BYTE PTR $T98257[ebp], al
	movzx	eax, BYTE PTR $T98256[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T98257[ebp]
	push	ecx
	mov	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@V?$_Vector_const_iterator@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@@std@@YAPBQAVSoundNode@Ogre@@AAV?$_Vector_const_iterator@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::SoundNode *,std::allocator<Ogre::SoundNode *> > >
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@V?$_Vector_const_iterator@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@@std@@YAPBQAVSoundNode@Ogre@@AAV?$_Vector_const_iterator@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::SoundNode *,std::allocator<Ogre::SoundNode *> > >
	add	esp, 4
	push	eax
	call	??$_Uninit_copy@PBQAVSoundNode@Ogre@@PAPAV12@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@YAPAPAVSoundNode@Ogre@@PBQAV12@0PAPAV12@AAV?$allocator@PAVSoundNode@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Ogre::SoundNode * const *,Ogre::SoundNode * *,std::allocator<Ogre::SoundNode *> >
	add	esp, 24					; 00000018H

; 823  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@PAPAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@2@@stdext@@YAPAPAVSoundNode@Ogre@@V?$_Vector_const_iterator@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@0PAPAV12@AAV?$allocator@PAVSoundNode@Ogre@@@4@@Z ENDP ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<Ogre::SoundNode *,std::allocator<Ogre::SoundNode *> >,Ogre::SoundNode * *,std::allocator<Ogre::SoundNode *> >
_TEXT	ENDS
PUBLIC	??$_Checked_base@PAPAVSoundNode@Ogre@@@std@@YAPAPAVSoundNode@Ogre@@AAPAPAV12@U_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<Ogre::SoundNode * *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Checked_base@PAPAVSoundNode@Ogre@@@std@@YAPAPAVSoundNode@Ogre@@AAPAPAV12@@Z
_TEXT	SEGMENT
__Base_tag$ = -1					; size = 1
__It$ = 8						; size = 4
??$_Checked_base@PAPAVSoundNode@Ogre@@@std@@YAPAPAVSoundNode@Ogre@@AAPAPAV12@@Z PROC ; std::_Checked_base<Ogre::SoundNode * *>, COMDAT

; 1163 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1164 : 		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
; 1165 : 		return _Checked_base(_It, _Base_tag);

	movzx	eax, BYTE PTR __Base_tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR __It$[ebp]
	push	ecx
	call	??$_Checked_base@PAPAVSoundNode@Ogre@@@std@@YAPAPAVSoundNode@Ogre@@AAPAPAV12@U_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<Ogre::SoundNode * *>
	add	esp, 8

; 1166 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Checked_base@PAPAVSoundNode@Ogre@@@std@@YAPAPAVSoundNode@Ogre@@AAPAPAV12@@Z ENDP ; std::_Checked_base<Ogre::SoundNode * *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Iter_random@PAPAVSoundNode@Ogre@@PAPAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVSoundNode@Ogre@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAPAVSoundNode@Ogre@@PAPAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVSoundNode@Ogre@@0@Z PROC ; std::_Iter_random<Ogre::SoundNode * *,Ogre::SoundNode * *>, COMDAT

; 993  : 	{	// return category from iterator argument

	push	ebp
	mov	ebp, esp
	push	ecx

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 998  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Iter_random@PAPAVSoundNode@Ogre@@PAPAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVSoundNode@Ogre@@0@Z ENDP ; std::_Iter_random<Ogre::SoundNode * *,Ogre::SoundNode * *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAPAVSoundNode@Ogre@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVSoundNode@Ogre@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAPAVSoundNode@Ogre@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVSoundNode@Ogre@@0@Z PROC ; std::_Ptr_cat<Ogre::SoundNode * *,Ogre::SoundNode * *>, COMDAT

; 1509 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 1512 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Ptr_cat@PAPAVSoundNode@Ogre@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVSoundNode@Ogre@@0@Z ENDP ; std::_Ptr_cat<Ogre::SoundNode * *,Ogre::SoundNode * *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Copy_opt@PAPAVSoundNode@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@@std@@YAPAPAVSoundNode@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Off$ = -8						; size = 4
__Result$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAPAVSoundNode@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@@std@@YAPAPAVSoundNode@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<Ogre::SoundNode * *,Ogre::SoundNode * *,std::random_access_iterator_tag>, COMDAT

; 2494 : 	{	// copy [_First, _Last) to [_Dest, ...), pointers to scalars

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 2495 : 
; 2496 :  #if _HAS_ITERATOR_DEBUGGING
; 2497 : 	_DEBUG_RANGE(_First, _Last);
; 2498 : 	if (_First != _Last)
; 2499 : 		_DEBUG_POINTER(_Dest);
; 2500 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2501 : 
; 2502 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 2
	mov	DWORD PTR __Off$[ebp], eax

; 2503 : 	// if _OutIt is range checked, this will make sure there is enough space for the memmove
; 2504 : 	_OutIt _Result = _Dest + _Off;

	mov	ecx, DWORD PTR __Off$[ebp]
	mov	edx, DWORD PTR __Dest$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR __Result$[ebp], eax

; 2505 : 	if (_Off > 0)

	cmp	DWORD PTR __Off$[ebp], 0
	jle	SHORT $LN1@Copy_opt@8

; 2506 : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Off * sizeof (*_First), &*_First, _Off * sizeof (*_First));

	mov	ecx, DWORD PTR __Off$[ebp]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	eax, DWORD PTR __Off$[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN1@Copy_opt@8:

; 2507 : 	return _Result;

	mov	eax, DWORD PTR __Result$[ebp]

; 2508 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Copy_opt@PAPAVSoundNode@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@@std@@YAPAPAVSoundNode@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<Ogre::SoundNode * *,Ogre::SoundNode * *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PAPAVSoundNode@Ogre@@PAPAV12@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@YAPAPAVSoundNode@Ogre@@PAPAV12@00AAV?$allocator@PAVSoundNode@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Ogre::SoundNode * *,Ogre::SoundNode * *,std::allocator<Ogre::SoundNode *> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_copy@PAPAVSoundNode@Ogre@@PAPAV12@V?$allocator@PAVSoundNode@Ogre@@@std@@@stdext@@YAPAPAVSoundNode@Ogre@@PAPAV12@00AAV?$allocator@PAVSoundNode@Ogre@@@std@@@Z
_TEXT	SEGMENT
$T98269 = -2						; size = 1
$T98268 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@PAPAVSoundNode@Ogre@@PAPAV12@V?$allocator@PAVSoundNode@Ogre@@@std@@@stdext@@YAPAPAVSoundNode@Ogre@@PAPAV12@00AAV?$allocator@PAVSoundNode@Ogre@@@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<Ogre::SoundNode * *,Ogre::SoundNode * *,std::allocator<Ogre::SoundNode *> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T98268[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAPAVSoundNode@Ogre@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVSoundNode@Ogre@@0@Z ; std::_Ptr_cat<Ogre::SoundNode * *,Ogre::SoundNode * *>
	add	esp, 8
	mov	BYTE PTR $T98269[ebp], al
	movzx	eax, BYTE PTR $T98268[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T98269[ebp]
	push	ecx
	mov	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@PAPAVSoundNode@Ogre@@@std@@YAPAPAVSoundNode@Ogre@@AAPAPAV12@@Z ; std::_Checked_base<Ogre::SoundNode * *>
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@PAPAVSoundNode@Ogre@@@std@@YAPAPAVSoundNode@Ogre@@AAPAPAV12@@Z ; std::_Checked_base<Ogre::SoundNode * *>
	add	esp, 4
	push	eax
	call	??$_Uninit_copy@PAPAVSoundNode@Ogre@@PAPAV12@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@YAPAPAVSoundNode@Ogre@@PAPAV12@00AAV?$allocator@PAVSoundNode@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Ogre::SoundNode * *,Ogre::SoundNode * *,std::allocator<Ogre::SoundNode *> >
	add	esp, 24					; 00000018H

; 823  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_copy@PAPAVSoundNode@Ogre@@PAPAV12@V?$allocator@PAVSoundNode@Ogre@@@std@@@stdext@@YAPAPAVSoundNode@Ogre@@PAPAV12@00AAV?$allocator@PAVSoundNode@Ogre@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<Ogre::SoundNode * *,Ogre::SoundNode * *,std::allocator<Ogre::SoundNode *> >
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PBQAVRenderableObject@Ogre@@PAPAV12@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@YAPAPAVRenderableObject@Ogre@@PBQAV12@0PAPAV12@AAV?$allocator@PAVRenderableObject@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Ogre::RenderableObject * const *,Ogre::RenderableObject * *,std::allocator<Ogre::RenderableObject *> >
PUBLIC	??$_Checked_base@V?$_Vector_const_iterator@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@@std@@YAPBQAVRenderableObject@Ogre@@AAV?$_Vector_const_iterator@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::RenderableObject *,std::allocator<Ogre::RenderableObject *> > >
PUBLIC	??$_Ptr_cat@V?$_Vector_const_iterator@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@PAPAVRenderableObject@Ogre@@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@0@AAPAPAVRenderableObject@Ogre@@@Z ; std::_Ptr_cat<std::_Vector_const_iterator<Ogre::RenderableObject *,std::allocator<Ogre::RenderableObject *> >,Ogre::RenderableObject * *>
; Function compile flags: /Odtp
;	COMDAT ??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@PAPAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@2@@stdext@@YAPAPAVRenderableObject@Ogre@@V?$_Vector_const_iterator@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@0PAPAV12@AAV?$allocator@PAVRenderableObject@Ogre@@@4@@Z
_TEXT	SEGMENT
$T98273 = -2						; size = 1
$T98272 = -1						; size = 1
__First$ = 8						; size = 8
__Last$ = 16						; size = 8
__Dest$ = 24						; size = 4
__Al$ = 28						; size = 4
??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@PAPAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@2@@stdext@@YAPAPAVRenderableObject@Ogre@@V?$_Vector_const_iterator@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@0PAPAV12@AAV?$allocator@PAVRenderableObject@Ogre@@@4@@Z PROC ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<Ogre::RenderableObject *,std::allocator<Ogre::RenderableObject *> >,Ogre::RenderableObject * *,std::allocator<Ogre::RenderableObject *> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T98272[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@V?$_Vector_const_iterator@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@PAPAVRenderableObject@Ogre@@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@0@AAPAPAVRenderableObject@Ogre@@@Z ; std::_Ptr_cat<std::_Vector_const_iterator<Ogre::RenderableObject *,std::allocator<Ogre::RenderableObject *> >,Ogre::RenderableObject * *>
	add	esp, 8
	mov	BYTE PTR $T98273[ebp], al
	movzx	eax, BYTE PTR $T98272[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T98273[ebp]
	push	ecx
	mov	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@V?$_Vector_const_iterator@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@@std@@YAPBQAVRenderableObject@Ogre@@AAV?$_Vector_const_iterator@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::RenderableObject *,std::allocator<Ogre::RenderableObject *> > >
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@V?$_Vector_const_iterator@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@@std@@YAPBQAVRenderableObject@Ogre@@AAV?$_Vector_const_iterator@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::RenderableObject *,std::allocator<Ogre::RenderableObject *> > >
	add	esp, 4
	push	eax
	call	??$_Uninit_copy@PBQAVRenderableObject@Ogre@@PAPAV12@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@YAPAPAVRenderableObject@Ogre@@PBQAV12@0PAPAV12@AAV?$allocator@PAVRenderableObject@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Ogre::RenderableObject * const *,Ogre::RenderableObject * *,std::allocator<Ogre::RenderableObject *> >
	add	esp, 24					; 00000018H

; 823  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@PAPAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@2@@stdext@@YAPAPAVRenderableObject@Ogre@@V?$_Vector_const_iterator@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@0PAPAV12@AAV?$allocator@PAVRenderableObject@Ogre@@@4@@Z ENDP ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<Ogre::RenderableObject *,std::allocator<Ogre::RenderableObject *> >,Ogre::RenderableObject * *,std::allocator<Ogre::RenderableObject *> >
_TEXT	ENDS
PUBLIC	??$_Checked_base@PAPAVRenderableObject@Ogre@@@std@@YAPAPAVRenderableObject@Ogre@@AAPAPAV12@U_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<Ogre::RenderableObject * *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Checked_base@PAPAVRenderableObject@Ogre@@@std@@YAPAPAVRenderableObject@Ogre@@AAPAPAV12@@Z
_TEXT	SEGMENT
__Base_tag$ = -1					; size = 1
__It$ = 8						; size = 4
??$_Checked_base@PAPAVRenderableObject@Ogre@@@std@@YAPAPAVRenderableObject@Ogre@@AAPAPAV12@@Z PROC ; std::_Checked_base<Ogre::RenderableObject * *>, COMDAT

; 1163 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1164 : 		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
; 1165 : 		return _Checked_base(_It, _Base_tag);

	movzx	eax, BYTE PTR __Base_tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR __It$[ebp]
	push	ecx
	call	??$_Checked_base@PAPAVRenderableObject@Ogre@@@std@@YAPAPAVRenderableObject@Ogre@@AAPAPAV12@U_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<Ogre::RenderableObject * *>
	add	esp, 8

; 1166 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Checked_base@PAPAVRenderableObject@Ogre@@@std@@YAPAPAVRenderableObject@Ogre@@AAPAPAV12@@Z ENDP ; std::_Checked_base<Ogre::RenderableObject * *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Iter_random@PAPAVRenderableObject@Ogre@@PAPAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVRenderableObject@Ogre@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAPAVRenderableObject@Ogre@@PAPAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVRenderableObject@Ogre@@0@Z PROC ; std::_Iter_random<Ogre::RenderableObject * *,Ogre::RenderableObject * *>, COMDAT

; 993  : 	{	// return category from iterator argument

	push	ebp
	mov	ebp, esp
	push	ecx

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 998  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Iter_random@PAPAVRenderableObject@Ogre@@PAPAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVRenderableObject@Ogre@@0@Z ENDP ; std::_Iter_random<Ogre::RenderableObject * *,Ogre::RenderableObject * *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAPAVRenderableObject@Ogre@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVRenderableObject@Ogre@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAPAVRenderableObject@Ogre@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVRenderableObject@Ogre@@0@Z PROC ; std::_Ptr_cat<Ogre::RenderableObject * *,Ogre::RenderableObject * *>, COMDAT

; 1509 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 1512 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Ptr_cat@PAPAVRenderableObject@Ogre@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVRenderableObject@Ogre@@0@Z ENDP ; std::_Ptr_cat<Ogre::RenderableObject * *,Ogre::RenderableObject * *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Copy_opt@PAPAVRenderableObject@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@@std@@YAPAPAVRenderableObject@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Off$ = -8						; size = 4
__Result$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAPAVRenderableObject@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@@std@@YAPAPAVRenderableObject@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<Ogre::RenderableObject * *,Ogre::RenderableObject * *,std::random_access_iterator_tag>, COMDAT

; 2494 : 	{	// copy [_First, _Last) to [_Dest, ...), pointers to scalars

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 2495 : 
; 2496 :  #if _HAS_ITERATOR_DEBUGGING
; 2497 : 	_DEBUG_RANGE(_First, _Last);
; 2498 : 	if (_First != _Last)
; 2499 : 		_DEBUG_POINTER(_Dest);
; 2500 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2501 : 
; 2502 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 2
	mov	DWORD PTR __Off$[ebp], eax

; 2503 : 	// if _OutIt is range checked, this will make sure there is enough space for the memmove
; 2504 : 	_OutIt _Result = _Dest + _Off;

	mov	ecx, DWORD PTR __Off$[ebp]
	mov	edx, DWORD PTR __Dest$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR __Result$[ebp], eax

; 2505 : 	if (_Off > 0)

	cmp	DWORD PTR __Off$[ebp], 0
	jle	SHORT $LN1@Copy_opt@9

; 2506 : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Off * sizeof (*_First), &*_First, _Off * sizeof (*_First));

	mov	ecx, DWORD PTR __Off$[ebp]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	eax, DWORD PTR __Off$[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN1@Copy_opt@9:

; 2507 : 	return _Result;

	mov	eax, DWORD PTR __Result$[ebp]

; 2508 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Copy_opt@PAPAVRenderableObject@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@@std@@YAPAPAVRenderableObject@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<Ogre::RenderableObject * *,Ogre::RenderableObject * *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PAPAVRenderableObject@Ogre@@PAPAV12@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@YAPAPAVRenderableObject@Ogre@@PAPAV12@00AAV?$allocator@PAVRenderableObject@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Ogre::RenderableObject * *,Ogre::RenderableObject * *,std::allocator<Ogre::RenderableObject *> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_copy@PAPAVRenderableObject@Ogre@@PAPAV12@V?$allocator@PAVRenderableObject@Ogre@@@std@@@stdext@@YAPAPAVRenderableObject@Ogre@@PAPAV12@00AAV?$allocator@PAVRenderableObject@Ogre@@@std@@@Z
_TEXT	SEGMENT
$T98285 = -2						; size = 1
$T98284 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@PAPAVRenderableObject@Ogre@@PAPAV12@V?$allocator@PAVRenderableObject@Ogre@@@std@@@stdext@@YAPAPAVRenderableObject@Ogre@@PAPAV12@00AAV?$allocator@PAVRenderableObject@Ogre@@@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<Ogre::RenderableObject * *,Ogre::RenderableObject * *,std::allocator<Ogre::RenderableObject *> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T98284[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAPAVRenderableObject@Ogre@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVRenderableObject@Ogre@@0@Z ; std::_Ptr_cat<Ogre::RenderableObject * *,Ogre::RenderableObject * *>
	add	esp, 8
	mov	BYTE PTR $T98285[ebp], al
	movzx	eax, BYTE PTR $T98284[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T98285[ebp]
	push	ecx
	mov	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@PAPAVRenderableObject@Ogre@@@std@@YAPAPAVRenderableObject@Ogre@@AAPAPAV12@@Z ; std::_Checked_base<Ogre::RenderableObject * *>
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@PAPAVRenderableObject@Ogre@@@std@@YAPAPAVRenderableObject@Ogre@@AAPAPAV12@@Z ; std::_Checked_base<Ogre::RenderableObject * *>
	add	esp, 4
	push	eax
	call	??$_Uninit_copy@PAPAVRenderableObject@Ogre@@PAPAV12@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@YAPAPAVRenderableObject@Ogre@@PAPAV12@00AAV?$allocator@PAVRenderableObject@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Ogre::RenderableObject * *,Ogre::RenderableObject * *,std::allocator<Ogre::RenderableObject *> >
	add	esp, 24					; 00000018H

; 823  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_copy@PAPAVRenderableObject@Ogre@@PAPAV12@V?$allocator@PAVRenderableObject@Ogre@@@std@@@stdext@@YAPAPAVRenderableObject@Ogre@@PAPAV12@00AAV?$allocator@PAVRenderableObject@Ogre@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<Ogre::RenderableObject * *,Ogre::RenderableObject * *,std::allocator<Ogre::RenderableObject *> >
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PBQAVLight@Ogre@@PAPAV12@V?$allocator@PAVLight@Ogre@@@std@@@std@@YAPAPAVLight@Ogre@@PBQAV12@0PAPAV12@AAV?$allocator@PAVLight@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Ogre::Light * const *,Ogre::Light * *,std::allocator<Ogre::Light *> >
PUBLIC	??$_Checked_base@V?$_Vector_const_iterator@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@@std@@YAPBQAVLight@Ogre@@AAV?$_Vector_const_iterator@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::Light *,std::allocator<Ogre::Light *> > >
PUBLIC	??$_Ptr_cat@V?$_Vector_const_iterator@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@PAPAVLight@Ogre@@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@0@AAPAPAVLight@Ogre@@@Z ; std::_Ptr_cat<std::_Vector_const_iterator<Ogre::Light *,std::allocator<Ogre::Light *> >,Ogre::Light * *>
; Function compile flags: /Odtp
;	COMDAT ??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@PAPAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@2@@stdext@@YAPAPAVLight@Ogre@@V?$_Vector_const_iterator@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@0PAPAV12@AAV?$allocator@PAVLight@Ogre@@@4@@Z
_TEXT	SEGMENT
$T98289 = -2						; size = 1
$T98288 = -1						; size = 1
__First$ = 8						; size = 8
__Last$ = 16						; size = 8
__Dest$ = 24						; size = 4
__Al$ = 28						; size = 4
??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@PAPAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@2@@stdext@@YAPAPAVLight@Ogre@@V?$_Vector_const_iterator@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@0PAPAV12@AAV?$allocator@PAVLight@Ogre@@@4@@Z PROC ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<Ogre::Light *,std::allocator<Ogre::Light *> >,Ogre::Light * *,std::allocator<Ogre::Light *> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T98288[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@V?$_Vector_const_iterator@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@PAPAVLight@Ogre@@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@0@AAPAPAVLight@Ogre@@@Z ; std::_Ptr_cat<std::_Vector_const_iterator<Ogre::Light *,std::allocator<Ogre::Light *> >,Ogre::Light * *>
	add	esp, 8
	mov	BYTE PTR $T98289[ebp], al
	movzx	eax, BYTE PTR $T98288[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T98289[ebp]
	push	ecx
	mov	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@V?$_Vector_const_iterator@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@@std@@YAPBQAVLight@Ogre@@AAV?$_Vector_const_iterator@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::Light *,std::allocator<Ogre::Light *> > >
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@V?$_Vector_const_iterator@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@@std@@YAPBQAVLight@Ogre@@AAV?$_Vector_const_iterator@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::Light *,std::allocator<Ogre::Light *> > >
	add	esp, 4
	push	eax
	call	??$_Uninit_copy@PBQAVLight@Ogre@@PAPAV12@V?$allocator@PAVLight@Ogre@@@std@@@std@@YAPAPAVLight@Ogre@@PBQAV12@0PAPAV12@AAV?$allocator@PAVLight@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Ogre::Light * const *,Ogre::Light * *,std::allocator<Ogre::Light *> >
	add	esp, 24					; 00000018H

; 823  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@PAPAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@2@@stdext@@YAPAPAVLight@Ogre@@V?$_Vector_const_iterator@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@0PAPAV12@AAV?$allocator@PAVLight@Ogre@@@4@@Z ENDP ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<Ogre::Light *,std::allocator<Ogre::Light *> >,Ogre::Light * *,std::allocator<Ogre::Light *> >
_TEXT	ENDS
PUBLIC	??$_Checked_base@PAPAVLight@Ogre@@@std@@YAPAPAVLight@Ogre@@AAPAPAV12@U_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<Ogre::Light * *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Checked_base@PAPAVLight@Ogre@@@std@@YAPAPAVLight@Ogre@@AAPAPAV12@@Z
_TEXT	SEGMENT
__Base_tag$ = -1					; size = 1
__It$ = 8						; size = 4
??$_Checked_base@PAPAVLight@Ogre@@@std@@YAPAPAVLight@Ogre@@AAPAPAV12@@Z PROC ; std::_Checked_base<Ogre::Light * *>, COMDAT

; 1163 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1164 : 		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
; 1165 : 		return _Checked_base(_It, _Base_tag);

	movzx	eax, BYTE PTR __Base_tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR __It$[ebp]
	push	ecx
	call	??$_Checked_base@PAPAVLight@Ogre@@@std@@YAPAPAVLight@Ogre@@AAPAPAV12@U_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<Ogre::Light * *>
	add	esp, 8

; 1166 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Checked_base@PAPAVLight@Ogre@@@std@@YAPAPAVLight@Ogre@@AAPAPAV12@@Z ENDP ; std::_Checked_base<Ogre::Light * *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Iter_random@PAPAVLight@Ogre@@PAPAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVLight@Ogre@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAPAVLight@Ogre@@PAPAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVLight@Ogre@@0@Z PROC ; std::_Iter_random<Ogre::Light * *,Ogre::Light * *>, COMDAT

; 993  : 	{	// return category from iterator argument

	push	ebp
	mov	ebp, esp
	push	ecx

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 998  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Iter_random@PAPAVLight@Ogre@@PAPAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVLight@Ogre@@0@Z ENDP ; std::_Iter_random<Ogre::Light * *,Ogre::Light * *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAPAVLight@Ogre@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVLight@Ogre@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAPAVLight@Ogre@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVLight@Ogre@@0@Z PROC ; std::_Ptr_cat<Ogre::Light * *,Ogre::Light * *>, COMDAT

; 1509 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 1512 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Ptr_cat@PAPAVLight@Ogre@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVLight@Ogre@@0@Z ENDP ; std::_Ptr_cat<Ogre::Light * *,Ogre::Light * *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Copy_opt@PAPAVLight@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@@std@@YAPAPAVLight@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Off$ = -8						; size = 4
__Result$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAPAVLight@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@@std@@YAPAPAVLight@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<Ogre::Light * *,Ogre::Light * *,std::random_access_iterator_tag>, COMDAT

; 2494 : 	{	// copy [_First, _Last) to [_Dest, ...), pointers to scalars

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 2495 : 
; 2496 :  #if _HAS_ITERATOR_DEBUGGING
; 2497 : 	_DEBUG_RANGE(_First, _Last);
; 2498 : 	if (_First != _Last)
; 2499 : 		_DEBUG_POINTER(_Dest);
; 2500 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 2501 : 
; 2502 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 2
	mov	DWORD PTR __Off$[ebp], eax

; 2503 : 	// if _OutIt is range checked, this will make sure there is enough space for the memmove
; 2504 : 	_OutIt _Result = _Dest + _Off;

	mov	ecx, DWORD PTR __Off$[ebp]
	mov	edx, DWORD PTR __Dest$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR __Result$[ebp], eax

; 2505 : 	if (_Off > 0)

	cmp	DWORD PTR __Off$[ebp], 0
	jle	SHORT $LN1@Copy_opt@10

; 2506 : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Off * sizeof (*_First), &*_First, _Off * sizeof (*_First));

	mov	ecx, DWORD PTR __Off$[ebp]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	eax, DWORD PTR __Off$[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN1@Copy_opt@10:

; 2507 : 	return _Result;

	mov	eax, DWORD PTR __Result$[ebp]

; 2508 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Copy_opt@PAPAVLight@Ogre@@PAPAV12@Urandom_access_iterator_tag@std@@@std@@YAPAPAVLight@Ogre@@PAPAV12@00Urandom_access_iterator_tag@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<Ogre::Light * *,Ogre::Light * *,std::random_access_iterator_tag>
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PAPAVLight@Ogre@@PAPAV12@V?$allocator@PAVLight@Ogre@@@std@@@std@@YAPAPAVLight@Ogre@@PAPAV12@00AAV?$allocator@PAVLight@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Ogre::Light * *,Ogre::Light * *,std::allocator<Ogre::Light *> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_copy@PAPAVLight@Ogre@@PAPAV12@V?$allocator@PAVLight@Ogre@@@std@@@stdext@@YAPAPAVLight@Ogre@@PAPAV12@00AAV?$allocator@PAVLight@Ogre@@@std@@@Z
_TEXT	SEGMENT
$T98301 = -2						; size = 1
$T98300 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@PAPAVLight@Ogre@@PAPAV12@V?$allocator@PAVLight@Ogre@@@std@@@stdext@@YAPAPAVLight@Ogre@@PAPAV12@00AAV?$allocator@PAVLight@Ogre@@@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<Ogre::Light * *,Ogre::Light * *,std::allocator<Ogre::Light *> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T98300[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAPAVLight@Ogre@@PAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVLight@Ogre@@0@Z ; std::_Ptr_cat<Ogre::Light * *,Ogre::Light * *>
	add	esp, 8
	mov	BYTE PTR $T98301[ebp], al
	movzx	eax, BYTE PTR $T98300[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T98301[ebp]
	push	ecx
	mov	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@PAPAVLight@Ogre@@@std@@YAPAPAVLight@Ogre@@AAPAPAV12@@Z ; std::_Checked_base<Ogre::Light * *>
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@PAPAVLight@Ogre@@@std@@YAPAPAVLight@Ogre@@AAPAPAV12@@Z ; std::_Checked_base<Ogre::Light * *>
	add	esp, 4
	push	eax
	call	??$_Uninit_copy@PAPAVLight@Ogre@@PAPAV12@V?$allocator@PAVLight@Ogre@@@std@@@std@@YAPAPAVLight@Ogre@@PAPAV12@00AAV?$allocator@PAVLight@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Ogre::Light * *,Ogre::Light * *,std::allocator<Ogre::Light *> >
	add	esp, 24					; 00000018H

; 823  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_copy@PAPAVLight@Ogre@@PAPAV12@V?$allocator@PAVLight@Ogre@@@std@@@stdext@@YAPAPAVLight@Ogre@@PAPAV12@00AAV?$allocator@PAVLight@Ogre@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<Ogre::Light * *,Ogre::Light * *,std::allocator<Ogre::Light *> >
_TEXT	ENDS
PUBLIC	??$_Checked_base@PAUAnimRange@BaseKeyFrameArray@Ogre@@@std@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@AAPAU123@U_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<Ogre::BaseKeyFrameArray::AnimRange *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Checked_base@PAUAnimRange@BaseKeyFrameArray@Ogre@@@std@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@AAPAU123@@Z
_TEXT	SEGMENT
__Base_tag$ = -1					; size = 1
__It$ = 8						; size = 4
??$_Checked_base@PAUAnimRange@BaseKeyFrameArray@Ogre@@@std@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@AAPAU123@@Z PROC ; std::_Checked_base<Ogre::BaseKeyFrameArray::AnimRange *>, COMDAT

; 1163 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1164 : 		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
; 1165 : 		return _Checked_base(_It, _Base_tag);

	movzx	eax, BYTE PTR __Base_tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR __It$[ebp]
	push	ecx
	call	??$_Checked_base@PAUAnimRange@BaseKeyFrameArray@Ogre@@@std@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@AAPAU123@U_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<Ogre::BaseKeyFrameArray::AnimRange *>
	add	esp, 8

; 1166 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Checked_base@PAUAnimRange@BaseKeyFrameArray@Ogre@@@std@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@AAPAU123@@Z ENDP ; std::_Checked_base<Ogre::BaseKeyFrameArray::AnimRange *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Iter_random@PAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUAnimRange@BaseKeyFrameArray@Ogre@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUAnimRange@BaseKeyFrameArray@Ogre@@0@Z PROC ; std::_Iter_random<Ogre::BaseKeyFrameArray::AnimRange *,Ogre::BaseKeyFrameArray::AnimRange *>, COMDAT

; 993  : 	{	// return category from iterator argument

	push	ebp
	mov	ebp, esp
	push	ecx

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 998  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Iter_random@PAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUAnimRange@BaseKeyFrameArray@Ogre@@0@Z ENDP ; std::_Iter_random<Ogre::BaseKeyFrameArray::AnimRange *,Ogre::BaseKeyFrameArray::AnimRange *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUAnimRange@BaseKeyFrameArray@Ogre@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUAnimRange@BaseKeyFrameArray@Ogre@@0@Z PROC ; std::_Ptr_cat<Ogre::BaseKeyFrameArray::AnimRange *,Ogre::BaseKeyFrameArray::AnimRange *>, COMDAT

; 1509 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 1512 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Ptr_cat@PAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUAnimRange@BaseKeyFrameArray@Ogre@@0@Z ENDP ; std::_Ptr_cat<Ogre::BaseKeyFrameArray::AnimRange *,Ogre::BaseKeyFrameArray::AnimRange *>
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@Uforward_iterator_tag@std@@@std@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<Ogre::BaseKeyFrameArray::AnimRange *,Ogre::BaseKeyFrameArray::AnimRange *,std::forward_iterator_tag>
; Function compile flags: /Odtp
;	COMDAT ??$_Copy_opt@PAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@@std@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T98312 = -7						; size = 1
$T98311 = -6						; size = 1
$T98310 = -5						; size = 1
__Result$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@@std@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<Ogre::BaseKeyFrameArray::AnimRange *,Ogre::BaseKeyFrameArray::AnimRange *>, COMDAT

; 2481 : 	{	// copy [_First, _Last) to [_Dest, ...), random_access iterators

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 2482 : 	// if _OutIt is range checked, this will make sure there is enough space for the copy
; 2483 : 	_OutIt _Result = _Dest + (_Last - _First);

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 3
	mov	ecx, DWORD PTR __Dest$[ebp]
	lea	edx, DWORD PTR [ecx+eax*8]
	mov	DWORD PTR __Result$[ebp], edx

; 2484 : 	_Copy_opt(_First, _Last, _CHECKED_BASE(_Dest), 
; 2485 : 		forward_iterator_tag(), _Nonscalar_ptr_iterator_tag(), _Range_checked_iterator_tag());

	xor	eax, eax
	mov	BYTE PTR $T98310[ebp], al
	xor	ecx, ecx
	mov	BYTE PTR $T98311[ebp], cl
	movzx	edx, BYTE PTR $T98310[ebp]
	push	edx
	movzx	eax, BYTE PTR $T98311[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T98312[ebp]
	push	ecx
	lea	edx, DWORD PTR __Dest$[ebp]
	push	edx
	call	??$_Checked_base@PAUAnimRange@BaseKeyFrameArray@Ogre@@@std@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@AAPAU123@@Z ; std::_Checked_base<Ogre::BaseKeyFrameArray::AnimRange *>
	add	esp, 4
	push	eax
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Copy_opt@PAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@Uforward_iterator_tag@std@@@std@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<Ogre::BaseKeyFrameArray::AnimRange *,Ogre::BaseKeyFrameArray::AnimRange *,std::forward_iterator_tag>
	add	esp, 24					; 00000018H

; 2486 : 	return _Result;

	mov	eax, DWORD PTR __Result$[ebp]

; 2487 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Copy_opt@PAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@@std@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<Ogre::BaseKeyFrameArray::AnimRange *,Ogre::BaseKeyFrameArray::AnimRange *>
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@00AAV?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Ogre::BaseKeyFrameArray::AnimRange *,Ogre::BaseKeyFrameArray::AnimRange *,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_copy@PAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@stdext@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@00AAV?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@Z
_TEXT	SEGMENT
$T98316 = -2						; size = 1
$T98315 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@PAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@stdext@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@00AAV?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<Ogre::BaseKeyFrameArray::AnimRange *,Ogre::BaseKeyFrameArray::AnimRange *,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T98315[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUAnimRange@BaseKeyFrameArray@Ogre@@0@Z ; std::_Ptr_cat<Ogre::BaseKeyFrameArray::AnimRange *,Ogre::BaseKeyFrameArray::AnimRange *>
	add	esp, 8
	mov	BYTE PTR $T98316[ebp], al
	movzx	eax, BYTE PTR $T98315[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T98316[ebp]
	push	ecx
	mov	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@PAUAnimRange@BaseKeyFrameArray@Ogre@@@std@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@AAPAU123@@Z ; std::_Checked_base<Ogre::BaseKeyFrameArray::AnimRange *>
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@PAUAnimRange@BaseKeyFrameArray@Ogre@@@std@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@AAPAU123@@Z ; std::_Checked_base<Ogre::BaseKeyFrameArray::AnimRange *>
	add	esp, 4
	push	eax
	call	??$_Uninit_copy@PAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@00AAV?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Ogre::BaseKeyFrameArray::AnimRange *,Ogre::BaseKeyFrameArray::AnimRange *,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >
	add	esp, 24					; 00000018H

; 823  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_copy@PAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@stdext@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@00AAV?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<Ogre::BaseKeyFrameArray::AnimRange *,Ogre::BaseKeyFrameArray::AnimRange *,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >
_TEXT	ENDS
PUBLIC	??$_Checked_base@PAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@AAPAU123@U_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<Ogre::KeyFrameArray<float>::KEYFRAME_T *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Checked_base@PAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@AAPAU123@@Z
_TEXT	SEGMENT
__Base_tag$ = -1					; size = 1
__It$ = 8						; size = 4
??$_Checked_base@PAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@AAPAU123@@Z PROC ; std::_Checked_base<Ogre::KeyFrameArray<float>::KEYFRAME_T *>, COMDAT

; 1163 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1164 : 		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
; 1165 : 		return _Checked_base(_It, _Base_tag);

	movzx	eax, BYTE PTR __Base_tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR __It$[ebp]
	push	ecx
	call	??$_Checked_base@PAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@AAPAU123@U_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<Ogre::KeyFrameArray<float>::KEYFRAME_T *>
	add	esp, 8

; 1166 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Checked_base@PAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@AAPAU123@@Z ENDP ; std::_Checked_base<Ogre::KeyFrameArray<float>::KEYFRAME_T *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Iter_random@PAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU123@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU123@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@0@Z PROC ; std::_Iter_random<Ogre::KeyFrameArray<float>::KEYFRAME_T *,Ogre::KeyFrameArray<float>::KEYFRAME_T *>, COMDAT

; 993  : 	{	// return category from iterator argument

	push	ebp
	mov	ebp, esp
	push	ecx

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 998  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Iter_random@PAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU123@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@0@Z ENDP ; std::_Iter_random<Ogre::KeyFrameArray<float>::KEYFRAME_T *,Ogre::KeyFrameArray<float>::KEYFRAME_T *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU123@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU123@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@0@Z PROC ; std::_Ptr_cat<Ogre::KeyFrameArray<float>::KEYFRAME_T *,Ogre::KeyFrameArray<float>::KEYFRAME_T *>, COMDAT

; 1509 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 1512 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Ptr_cat@PAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU123@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@0@Z ENDP ; std::_Ptr_cat<Ogre::KeyFrameArray<float>::KEYFRAME_T *,Ogre::KeyFrameArray<float>::KEYFRAME_T *>
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU123@Uforward_iterator_tag@std@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU123@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<Ogre::KeyFrameArray<float>::KEYFRAME_T *,Ogre::KeyFrameArray<float>::KEYFRAME_T *,std::forward_iterator_tag>
; Function compile flags: /Odtp
;	COMDAT ??$_Copy_opt@PAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU123@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU123@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T98327 = -7						; size = 1
$T98326 = -6						; size = 1
$T98325 = -5						; size = 1
__Result$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU123@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU123@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<Ogre::KeyFrameArray<float>::KEYFRAME_T *,Ogre::KeyFrameArray<float>::KEYFRAME_T *>, COMDAT

; 2481 : 	{	// copy [_First, _Last) to [_Dest, ...), random_access iterators

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 2482 : 	// if _OutIt is range checked, this will make sure there is enough space for the copy
; 2483 : 	_OutIt _Result = _Dest + (_Last - _First);

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 3
	mov	ecx, DWORD PTR __Dest$[ebp]
	lea	edx, DWORD PTR [ecx+eax*8]
	mov	DWORD PTR __Result$[ebp], edx

; 2484 : 	_Copy_opt(_First, _Last, _CHECKED_BASE(_Dest), 
; 2485 : 		forward_iterator_tag(), _Nonscalar_ptr_iterator_tag(), _Range_checked_iterator_tag());

	xor	eax, eax
	mov	BYTE PTR $T98325[ebp], al
	xor	ecx, ecx
	mov	BYTE PTR $T98326[ebp], cl
	movzx	edx, BYTE PTR $T98325[ebp]
	push	edx
	movzx	eax, BYTE PTR $T98326[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T98327[ebp]
	push	ecx
	lea	edx, DWORD PTR __Dest$[ebp]
	push	edx
	call	??$_Checked_base@PAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@AAPAU123@@Z ; std::_Checked_base<Ogre::KeyFrameArray<float>::KEYFRAME_T *>
	add	esp, 4
	push	eax
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Copy_opt@PAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU123@Uforward_iterator_tag@std@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU123@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<Ogre::KeyFrameArray<float>::KEYFRAME_T *,Ogre::KeyFrameArray<float>::KEYFRAME_T *,std::forward_iterator_tag>
	add	esp, 24					; 00000018H

; 2486 : 	return _Result;

	mov	eax, DWORD PTR __Result$[ebp]

; 2487 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Copy_opt@PAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU123@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU123@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<Ogre::KeyFrameArray<float>::KEYFRAME_T *,Ogre::KeyFrameArray<float>::KEYFRAME_T *>
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU123@00AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Ogre::KeyFrameArray<float>::KEYFRAME_T *,Ogre::KeyFrameArray<float>::KEYFRAME_T *,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_copy@PAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@stdext@@YAPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU123@00AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@Z
_TEXT	SEGMENT
$T98331 = -2						; size = 1
$T98330 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@PAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@stdext@@YAPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU123@00AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<Ogre::KeyFrameArray<float>::KEYFRAME_T *,Ogre::KeyFrameArray<float>::KEYFRAME_T *,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T98330[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU123@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@0@Z ; std::_Ptr_cat<Ogre::KeyFrameArray<float>::KEYFRAME_T *,Ogre::KeyFrameArray<float>::KEYFRAME_T *>
	add	esp, 8
	mov	BYTE PTR $T98331[ebp], al
	movzx	eax, BYTE PTR $T98330[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T98331[ebp]
	push	ecx
	mov	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@PAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@AAPAU123@@Z ; std::_Checked_base<Ogre::KeyFrameArray<float>::KEYFRAME_T *>
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@PAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@AAPAU123@@Z ; std::_Checked_base<Ogre::KeyFrameArray<float>::KEYFRAME_T *>
	add	esp, 4
	push	eax
	call	??$_Uninit_copy@PAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU123@00AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Ogre::KeyFrameArray<float>::KEYFRAME_T *,Ogre::KeyFrameArray<float>::KEYFRAME_T *,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >
	add	esp, 24					; 00000018H

; 823  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_copy@PAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@stdext@@YAPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU123@00AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<Ogre::KeyFrameArray<float>::KEYFRAME_T *,Ogre::KeyFrameArray<float>::KEYFRAME_T *,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >
_TEXT	ENDS
PUBLIC	??$_Checked_base@PAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@AAPAU123@U_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<Ogre::KeyFrameArray<float>::CONTROL_POINT_T *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Checked_base@PAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@AAPAU123@@Z
_TEXT	SEGMENT
__Base_tag$ = -1					; size = 1
__It$ = 8						; size = 4
??$_Checked_base@PAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@AAPAU123@@Z PROC ; std::_Checked_base<Ogre::KeyFrameArray<float>::CONTROL_POINT_T *>, COMDAT

; 1163 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1164 : 		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
; 1165 : 		return _Checked_base(_It, _Base_tag);

	movzx	eax, BYTE PTR __Base_tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR __It$[ebp]
	push	ecx
	call	??$_Checked_base@PAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@AAPAU123@U_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<Ogre::KeyFrameArray<float>::CONTROL_POINT_T *>
	add	esp, 8

; 1166 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Checked_base@PAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@AAPAU123@@Z ENDP ; std::_Checked_base<Ogre::KeyFrameArray<float>::CONTROL_POINT_T *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Iter_random@PAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU123@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU123@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@0@Z PROC ; std::_Iter_random<Ogre::KeyFrameArray<float>::CONTROL_POINT_T *,Ogre::KeyFrameArray<float>::CONTROL_POINT_T *>, COMDAT

; 993  : 	{	// return category from iterator argument

	push	ebp
	mov	ebp, esp
	push	ecx

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 998  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Iter_random@PAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU123@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@0@Z ENDP ; std::_Iter_random<Ogre::KeyFrameArray<float>::CONTROL_POINT_T *,Ogre::KeyFrameArray<float>::CONTROL_POINT_T *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU123@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU123@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@0@Z PROC ; std::_Ptr_cat<Ogre::KeyFrameArray<float>::CONTROL_POINT_T *,Ogre::KeyFrameArray<float>::CONTROL_POINT_T *>, COMDAT

; 1509 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 1512 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Ptr_cat@PAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU123@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@0@Z ENDP ; std::_Ptr_cat<Ogre::KeyFrameArray<float>::CONTROL_POINT_T *,Ogre::KeyFrameArray<float>::CONTROL_POINT_T *>
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU123@Uforward_iterator_tag@std@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU123@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<Ogre::KeyFrameArray<float>::CONTROL_POINT_T *,Ogre::KeyFrameArray<float>::CONTROL_POINT_T *,std::forward_iterator_tag>
; Function compile flags: /Odtp
;	COMDAT ??$_Copy_opt@PAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU123@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU123@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T98342 = -7						; size = 1
$T98341 = -6						; size = 1
$T98340 = -5						; size = 1
__Result$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU123@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU123@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<Ogre::KeyFrameArray<float>::CONTROL_POINT_T *,Ogre::KeyFrameArray<float>::CONTROL_POINT_T *>, COMDAT

; 2481 : 	{	// copy [_First, _Last) to [_Dest, ...), random_access iterators

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 2482 : 	// if _OutIt is range checked, this will make sure there is enough space for the copy
; 2483 : 	_OutIt _Result = _Dest + (_Last - _First);

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 3
	mov	ecx, DWORD PTR __Dest$[ebp]
	lea	edx, DWORD PTR [ecx+eax*8]
	mov	DWORD PTR __Result$[ebp], edx

; 2484 : 	_Copy_opt(_First, _Last, _CHECKED_BASE(_Dest), 
; 2485 : 		forward_iterator_tag(), _Nonscalar_ptr_iterator_tag(), _Range_checked_iterator_tag());

	xor	eax, eax
	mov	BYTE PTR $T98340[ebp], al
	xor	ecx, ecx
	mov	BYTE PTR $T98341[ebp], cl
	movzx	edx, BYTE PTR $T98340[ebp]
	push	edx
	movzx	eax, BYTE PTR $T98341[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T98342[ebp]
	push	ecx
	lea	edx, DWORD PTR __Dest$[ebp]
	push	edx
	call	??$_Checked_base@PAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@AAPAU123@@Z ; std::_Checked_base<Ogre::KeyFrameArray<float>::CONTROL_POINT_T *>
	add	esp, 4
	push	eax
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Copy_opt@PAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU123@Uforward_iterator_tag@std@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU123@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<Ogre::KeyFrameArray<float>::CONTROL_POINT_T *,Ogre::KeyFrameArray<float>::CONTROL_POINT_T *,std::forward_iterator_tag>
	add	esp, 24					; 00000018H

; 2486 : 	return _Result;

	mov	eax, DWORD PTR __Result$[ebp]

; 2487 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Copy_opt@PAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU123@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU123@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<Ogre::KeyFrameArray<float>::CONTROL_POINT_T *,Ogre::KeyFrameArray<float>::CONTROL_POINT_T *>
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU123@00AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Ogre::KeyFrameArray<float>::CONTROL_POINT_T *,Ogre::KeyFrameArray<float>::CONTROL_POINT_T *,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_copy@PAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@stdext@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU123@00AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@Z
_TEXT	SEGMENT
$T98346 = -2						; size = 1
$T98345 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@PAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@stdext@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU123@00AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<Ogre::KeyFrameArray<float>::CONTROL_POINT_T *,Ogre::KeyFrameArray<float>::CONTROL_POINT_T *,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T98345[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU123@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@0@Z ; std::_Ptr_cat<Ogre::KeyFrameArray<float>::CONTROL_POINT_T *,Ogre::KeyFrameArray<float>::CONTROL_POINT_T *>
	add	esp, 8
	mov	BYTE PTR $T98346[ebp], al
	movzx	eax, BYTE PTR $T98345[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T98346[ebp]
	push	ecx
	mov	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@PAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@AAPAU123@@Z ; std::_Checked_base<Ogre::KeyFrameArray<float>::CONTROL_POINT_T *>
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@PAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@AAPAU123@@Z ; std::_Checked_base<Ogre::KeyFrameArray<float>::CONTROL_POINT_T *>
	add	esp, 4
	push	eax
	call	??$_Uninit_copy@PAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU123@00AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Ogre::KeyFrameArray<float>::CONTROL_POINT_T *,Ogre::KeyFrameArray<float>::CONTROL_POINT_T *,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >
	add	esp, 24					; 00000018H

; 823  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_copy@PAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@stdext@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU123@00AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<Ogre::KeyFrameArray<float>::CONTROL_POINT_T *,Ogre::KeyFrameArray<float>::CONTROL_POINT_T *,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >
_TEXT	ENDS
PUBLIC	??$_Checked_base@PAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@AAPAU123@U_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Checked_base@PAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@AAPAU123@@Z
_TEXT	SEGMENT
__Base_tag$ = -1					; size = 1
__It$ = 8						; size = 4
??$_Checked_base@PAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@AAPAU123@@Z PROC ; std::_Checked_base<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T *>, COMDAT

; 1163 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1164 : 		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
; 1165 : 		return _Checked_base(_It, _Base_tag);

	movzx	eax, BYTE PTR __Base_tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR __It$[ebp]
	push	ecx
	call	??$_Checked_base@PAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@AAPAU123@U_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T *>
	add	esp, 8

; 1166 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Checked_base@PAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@AAPAU123@@Z ENDP ; std::_Checked_base<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Iter_random@PAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@0@Z PROC ; std::_Iter_random<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T *>, COMDAT

; 993  : 	{	// return category from iterator argument

	push	ebp
	mov	ebp, esp
	push	ecx

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 998  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Iter_random@PAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@0@Z ENDP ; std::_Iter_random<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@0@Z PROC ; std::_Ptr_cat<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T *>, COMDAT

; 1509 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 1512 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Ptr_cat@PAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@0@Z ENDP ; std::_Ptr_cat<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T *>
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@Uforward_iterator_tag@std@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T *,std::forward_iterator_tag>
; Function compile flags: /Odtp
;	COMDAT ??$_Copy_opt@PAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T98357 = -7						; size = 1
$T98356 = -6						; size = 1
$T98355 = -5						; size = 1
__Result$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T *>, COMDAT

; 2481 : 	{	// copy [_First, _Last) to [_Dest, ...), random_access iterators

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 2482 : 	// if _OutIt is range checked, this will make sure there is enough space for the copy
; 2483 : 	_OutIt _Result = _Dest + (_Last - _First);

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	cdq
	mov	ecx, 20					; 00000014H
	idiv	ecx
	imul	eax, 20					; 00000014H
	add	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Result$[ebp], eax

; 2484 : 	_Copy_opt(_First, _Last, _CHECKED_BASE(_Dest), 
; 2485 : 		forward_iterator_tag(), _Nonscalar_ptr_iterator_tag(), _Range_checked_iterator_tag());

	xor	edx, edx
	mov	BYTE PTR $T98355[ebp], dl
	xor	eax, eax
	mov	BYTE PTR $T98356[ebp], al
	movzx	ecx, BYTE PTR $T98355[ebp]
	push	ecx
	movzx	edx, BYTE PTR $T98356[ebp]
	push	edx
	movzx	eax, BYTE PTR $T98357[ebp]
	push	eax
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	??$_Checked_base@PAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@AAPAU123@@Z ; std::_Checked_base<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T *>
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Copy_opt@PAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@Uforward_iterator_tag@std@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T *,std::forward_iterator_tag>
	add	esp, 24					; 00000018H

; 2486 : 	return _Result;

	mov	eax, DWORD PTR __Result$[ebp]

; 2487 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Copy_opt@PAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T *>
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T *,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_copy@PAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@stdext@@YAPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@Z
_TEXT	SEGMENT
$T98361 = -2						; size = 1
$T98360 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@PAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@stdext@@YAPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T *,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T98360[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@0@Z ; std::_Ptr_cat<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T *>
	add	esp, 8
	mov	BYTE PTR $T98361[ebp], al
	movzx	eax, BYTE PTR $T98360[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T98361[ebp]
	push	ecx
	mov	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@PAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@AAPAU123@@Z ; std::_Checked_base<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T *>
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@PAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@AAPAU123@@Z ; std::_Checked_base<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T *>
	add	esp, 4
	push	eax
	call	??$_Uninit_copy@PAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T *,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >
	add	esp, 24					; 00000018H

; 823  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_copy@PAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@stdext@@YAPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T *,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >
_TEXT	ENDS
PUBLIC	??$_Checked_base@PAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@AAPAU123@U_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Checked_base@PAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@AAPAU123@@Z
_TEXT	SEGMENT
__Base_tag$ = -1					; size = 1
__It$ = 8						; size = 4
??$_Checked_base@PAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@AAPAU123@@Z PROC ; std::_Checked_base<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T *>, COMDAT

; 1163 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1164 : 		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
; 1165 : 		return _Checked_base(_It, _Base_tag);

	movzx	eax, BYTE PTR __Base_tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR __It$[ebp]
	push	ecx
	call	??$_Checked_base@PAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@AAPAU123@U_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T *>
	add	esp, 8

; 1166 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Checked_base@PAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@AAPAU123@@Z ENDP ; std::_Checked_base<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Iter_random@PAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@0@Z PROC ; std::_Iter_random<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T *>, COMDAT

; 993  : 	{	// return category from iterator argument

	push	ebp
	mov	ebp, esp
	push	ecx

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 998  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Iter_random@PAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@0@Z ENDP ; std::_Iter_random<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@0@Z PROC ; std::_Ptr_cat<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T *>, COMDAT

; 1509 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 1512 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Ptr_cat@PAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@0@Z ENDP ; std::_Ptr_cat<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T *>
_TEXT	ENDS
PUBLIC	??$_Copy_opt@PAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@Uforward_iterator_tag@std@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T *,std::forward_iterator_tag>
; Function compile flags: /Odtp
;	COMDAT ??$_Copy_opt@PAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T98372 = -7						; size = 1
$T98371 = -6						; size = 1
$T98370 = -5						; size = 1
__Result$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T *>, COMDAT

; 2481 : 	{	// copy [_First, _Last) to [_Dest, ...), random_access iterators

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 2482 : 	// if _OutIt is range checked, this will make sure there is enough space for the copy
; 2483 : 	_OutIt _Result = _Dest + (_Last - _First);

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 5
	shl	eax, 5
	add	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Result$[ebp], eax

; 2484 : 	_Copy_opt(_First, _Last, _CHECKED_BASE(_Dest), 
; 2485 : 		forward_iterator_tag(), _Nonscalar_ptr_iterator_tag(), _Range_checked_iterator_tag());

	xor	ecx, ecx
	mov	BYTE PTR $T98370[ebp], cl
	xor	edx, edx
	mov	BYTE PTR $T98371[ebp], dl
	movzx	eax, BYTE PTR $T98370[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T98371[ebp]
	push	ecx
	movzx	edx, BYTE PTR $T98372[ebp]
	push	edx
	lea	eax, DWORD PTR __Dest$[ebp]
	push	eax
	call	??$_Checked_base@PAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@AAPAU123@@Z ; std::_Checked_base<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T *>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Copy_opt@PAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@Uforward_iterator_tag@std@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T *,std::forward_iterator_tag>
	add	esp, 24					; 00000018H

; 2486 : 	return _Result;

	mov	eax, DWORD PTR __Result$[ebp]

; 2487 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Copy_opt@PAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T *>
_TEXT	ENDS
PUBLIC	??$_Uninit_copy@PAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T *,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_copy@PAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@stdext@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@Z
_TEXT	SEGMENT
$T98376 = -2						; size = 1
$T98375 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@PAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@stdext@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T *,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T98375[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@0@Z ; std::_Ptr_cat<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T *>
	add	esp, 8
	mov	BYTE PTR $T98376[ebp], al
	movzx	eax, BYTE PTR $T98375[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T98376[ebp]
	push	ecx
	mov	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@PAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@AAPAU123@@Z ; std::_Checked_base<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T *>
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@PAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@AAPAU123@@Z ; std::_Checked_base<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T *>
	add	esp, 4
	push	eax
	call	??$_Uninit_copy@PAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T *,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >
	add	esp, 24					; 00000018H

; 823  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_copy@PAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@stdext@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T *,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@YAXPAPAVShaderContext@Ogre@@0AAV?$allocator@PAVShaderContext@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@YAXPAPAVShaderContext@Ogre@@0AAV?$allocator@PAVShaderContext@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<Ogre::ShaderContext *> >, COMDAT

; 241  : 	{	// destroy [_First, _Last), scalar type (do nothing)

	push	ebp
	mov	ebp, esp

; 242  : 	}

	pop	ebp
	ret	0
??$_Destroy_range@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@YAXPAPAVShaderContext@Ogre@@0AAV?$allocator@PAVShaderContext@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<Ogre::ShaderContext *> >
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@UContextQueDesc@Ogre@@@std@@QAEXPAUContextQueDesc@Ogre@@@Z ; std::allocator<Ogre::ContextQueDesc>::destroy
; Function compile flags: /Odtp
;	COMDAT ??$_Destroy_range@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@YAXPAUContextQueDesc@Ogre@@0AAV?$allocator@UContextQueDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@YAXPAUContextQueDesc@Ogre@@0AAV?$allocator@UContextQueDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<Ogre::ContextQueDesc> >, COMDAT

; 232  : 	{	// destroy [_First, _Last), arbitrary type

	push	ebp
	mov	ebp, esp

; 233  : 	for (; _First != _Last; ++_First)

	jmp	SHORT $LN3@Destroy_ra
$LN2@Destroy_ra:
	mov	eax, DWORD PTR __First$[ebp]
	add	eax, 156				; 0000009cH
	mov	DWORD PTR __First$[ebp], eax
$LN3@Destroy_ra:
	mov	ecx, DWORD PTR __First$[ebp]
	cmp	ecx, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Destroy_ra

; 234  : 		_Al.destroy(_First);

	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?destroy@?$allocator@UContextQueDesc@Ogre@@@std@@QAEXPAUContextQueDesc@Ogre@@@Z ; std::allocator<Ogre::ContextQueDesc>::destroy
	jmp	SHORT $LN2@Destroy_ra
$LN4@Destroy_ra:

; 235  : 	}

	pop	ebp
	ret	0
??$_Destroy_range@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@YAXPAUContextQueDesc@Ogre@@0AAV?$allocator@UContextQueDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<Ogre::ContextQueDesc> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@V?$allocator@E@std@@@std@@YAXPAE0AAV?$allocator@E@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@E@std@@@std@@YAXPAE0AAV?$allocator@E@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<unsigned char> >, COMDAT

; 241  : 	{	// destroy [_First, _Last), scalar type (do nothing)

	push	ebp
	mov	ebp, esp

; 242  : 	}

	pop	ebp
	ret	0
??$_Destroy_range@V?$allocator@E@std@@@std@@YAXPAE0AAV?$allocator@E@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<unsigned char> >
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@QAEXPAUValueParam@ShaderContextPool@Ogre@@@Z ; std::allocator<Ogre::ShaderContextPool::ValueParam>::destroy
; Function compile flags: /Odtp
;	COMDAT ??$_Destroy_range@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@YAXPAUValueParam@ShaderContextPool@Ogre@@0AAV?$allocator@UValueParam@ShaderContextPool@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@YAXPAUValueParam@ShaderContextPool@Ogre@@0AAV?$allocator@UValueParam@ShaderContextPool@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<Ogre::ShaderContextPool::ValueParam> >, COMDAT

; 232  : 	{	// destroy [_First, _Last), arbitrary type

	push	ebp
	mov	ebp, esp

; 233  : 	for (; _First != _Last; ++_First)

	jmp	SHORT $LN3@Destroy_ra@2
$LN2@Destroy_ra@2:
	mov	eax, DWORD PTR __First$[ebp]
	add	eax, 16					; 00000010H
	mov	DWORD PTR __First$[ebp], eax
$LN3@Destroy_ra@2:
	mov	ecx, DWORD PTR __First$[ebp]
	cmp	ecx, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Destroy_ra@2

; 234  : 		_Al.destroy(_First);

	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?destroy@?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@QAEXPAUValueParam@ShaderContextPool@Ogre@@@Z ; std::allocator<Ogre::ShaderContextPool::ValueParam>::destroy
	jmp	SHORT $LN2@Destroy_ra@2
$LN4@Destroy_ra@2:

; 235  : 	}

	pop	ebp
	ret	0
??$_Destroy_range@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@YAXPAUValueParam@ShaderContextPool@Ogre@@0AAV?$allocator@UValueParam@ShaderContextPool@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<Ogre::ShaderContextPool::ValueParam> >
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@QAEXPAUTexParam@ShaderContextPool@Ogre@@@Z ; std::allocator<Ogre::ShaderContextPool::TexParam>::destroy
; Function compile flags: /Odtp
;	COMDAT ??$_Destroy_range@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@YAXPAUTexParam@ShaderContextPool@Ogre@@0AAV?$allocator@UTexParam@ShaderContextPool@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@YAXPAUTexParam@ShaderContextPool@Ogre@@0AAV?$allocator@UTexParam@ShaderContextPool@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<Ogre::ShaderContextPool::TexParam> >, COMDAT

; 232  : 	{	// destroy [_First, _Last), arbitrary type

	push	ebp
	mov	ebp, esp

; 233  : 	for (; _First != _Last; ++_First)

	jmp	SHORT $LN3@Destroy_ra@3
$LN2@Destroy_ra@3:
	mov	eax, DWORD PTR __First$[ebp]
	add	eax, 8
	mov	DWORD PTR __First$[ebp], eax
$LN3@Destroy_ra@3:
	mov	ecx, DWORD PTR __First$[ebp]
	cmp	ecx, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Destroy_ra@3

; 234  : 		_Al.destroy(_First);

	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?destroy@?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@QAEXPAUTexParam@ShaderContextPool@Ogre@@@Z ; std::allocator<Ogre::ShaderContextPool::TexParam>::destroy
	jmp	SHORT $LN2@Destroy_ra@3
$LN4@Destroy_ra@3:

; 235  : 	}

	pop	ebp
	ret	0
??$_Destroy_range@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@YAXPAUTexParam@ShaderContextPool@Ogre@@0AAV?$allocator@UTexParam@ShaderContextPool@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<Ogre::ShaderContextPool::TexParam> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@V?$allocator@PAVMaterialParam@Ogre@@@std@@@std@@YAXPAPAVMaterialParam@Ogre@@0AAV?$allocator@PAVMaterialParam@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@PAVMaterialParam@Ogre@@@std@@@std@@YAXPAPAVMaterialParam@Ogre@@0AAV?$allocator@PAVMaterialParam@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<Ogre::MaterialParam *> >, COMDAT

; 241  : 	{	// destroy [_First, _Last), scalar type (do nothing)

	push	ebp
	mov	ebp, esp

; 242  : 	}

	pop	ebp
	ret	0
??$_Destroy_range@V?$allocator@PAVMaterialParam@Ogre@@@std@@@std@@YAXPAPAVMaterialParam@Ogre@@0AAV?$allocator@PAVMaterialParam@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<Ogre::MaterialParam *> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@V?$allocator@D@std@@@std@@YAXPAD0AAV?$allocator@D@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@D@std@@@std@@YAXPAD0AAV?$allocator@D@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<char> >, COMDAT

; 241  : 	{	// destroy [_First, _Last), scalar type (do nothing)

	push	ebp
	mov	ebp, esp

; 242  : 	}

	pop	ebp
	ret	0
??$_Destroy_range@V?$allocator@D@std@@@std@@YAXPAD0AAV?$allocator@D@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<char> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@YAXPAPAVSurfaceData@Ogre@@0AAV?$allocator@PAVSurfaceData@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@YAXPAPAVSurfaceData@Ogre@@0AAV?$allocator@PAVSurfaceData@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<Ogre::SurfaceData *> >, COMDAT

; 241  : 	{	// destroy [_First, _Last), scalar type (do nothing)

	push	ebp
	mov	ebp, esp

; 242  : 	}

	pop	ebp
	ret	0
??$_Destroy_range@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@YAXPAPAVSurfaceData@Ogre@@0AAV?$allocator@PAVSurfaceData@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<Ogre::SurfaceData *> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@V?$allocator@G@std@@@std@@YAXPAG0AAV?$allocator@G@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@G@std@@@std@@YAXPAG0AAV?$allocator@G@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<unsigned short> >, COMDAT

; 241  : 	{	// destroy [_First, _Last), scalar type (do nothing)

	push	ebp
	mov	ebp, esp

; 242  : 	}

	pop	ebp
	ret	0
??$_Destroy_range@V?$allocator@G@std@@@std@@YAXPAG0AAV?$allocator@G@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<unsigned short> >
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@URecord@CullResult@Ogre@@@std@@QAEXPAURecord@CullResult@Ogre@@@Z ; std::allocator<Ogre::CullResult::Record>::destroy
; Function compile flags: /Odtp
;	COMDAT ??$_Destroy_range@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@YAXPAURecord@CullResult@Ogre@@0AAV?$allocator@URecord@CullResult@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@YAXPAURecord@CullResult@Ogre@@0AAV?$allocator@URecord@CullResult@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<Ogre::CullResult::Record> >, COMDAT

; 232  : 	{	// destroy [_First, _Last), arbitrary type

	push	ebp
	mov	ebp, esp

; 233  : 	for (; _First != _Last; ++_First)

	jmp	SHORT $LN3@Destroy_ra@4
$LN2@Destroy_ra@4:
	mov	eax, DWORD PTR __First$[ebp]
	add	eax, 16					; 00000010H
	mov	DWORD PTR __First$[ebp], eax
$LN3@Destroy_ra@4:
	mov	ecx, DWORD PTR __First$[ebp]
	cmp	ecx, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Destroy_ra@4

; 234  : 		_Al.destroy(_First);

	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?destroy@?$allocator@URecord@CullResult@Ogre@@@std@@QAEXPAURecord@CullResult@Ogre@@@Z ; std::allocator<Ogre::CullResult::Record>::destroy
	jmp	SHORT $LN2@Destroy_ra@4
$LN4@Destroy_ra@4:

; 235  : 	}

	pop	ebp
	ret	0
??$_Destroy_range@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@YAXPAURecord@CullResult@Ogre@@0AAV?$allocator@URecord@CullResult@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<Ogre::CullResult::Record> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@YAXPAPAVEffectObject@Ogre@@0AAV?$allocator@PAVEffectObject@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@YAXPAPAVEffectObject@Ogre@@0AAV?$allocator@PAVEffectObject@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<Ogre::EffectObject *> >, COMDAT

; 241  : 	{	// destroy [_First, _Last), scalar type (do nothing)

	push	ebp
	mov	ebp, esp

; 242  : 	}

	pop	ebp
	ret	0
??$_Destroy_range@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@YAXPAPAVEffectObject@Ogre@@0AAV?$allocator@PAVEffectObject@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<Ogre::EffectObject *> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@YAXPAPAVSoundNode@Ogre@@0AAV?$allocator@PAVSoundNode@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@YAXPAPAVSoundNode@Ogre@@0AAV?$allocator@PAVSoundNode@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<Ogre::SoundNode *> >, COMDAT

; 241  : 	{	// destroy [_First, _Last), scalar type (do nothing)

	push	ebp
	mov	ebp, esp

; 242  : 	}

	pop	ebp
	ret	0
??$_Destroy_range@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@YAXPAPAVSoundNode@Ogre@@0AAV?$allocator@PAVSoundNode@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<Ogre::SoundNode *> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@YAXPAPAVRenderableObject@Ogre@@0AAV?$allocator@PAVRenderableObject@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@YAXPAPAVRenderableObject@Ogre@@0AAV?$allocator@PAVRenderableObject@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<Ogre::RenderableObject *> >, COMDAT

; 241  : 	{	// destroy [_First, _Last), scalar type (do nothing)

	push	ebp
	mov	ebp, esp

; 242  : 	}

	pop	ebp
	ret	0
??$_Destroy_range@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@YAXPAPAVRenderableObject@Ogre@@0AAV?$allocator@PAVRenderableObject@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<Ogre::RenderableObject *> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@V?$allocator@PAVLight@Ogre@@@std@@@std@@YAXPAPAVLight@Ogre@@0AAV?$allocator@PAVLight@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@PAVLight@Ogre@@@std@@@std@@YAXPAPAVLight@Ogre@@0AAV?$allocator@PAVLight@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<Ogre::Light *> >, COMDAT

; 241  : 	{	// destroy [_First, _Last), scalar type (do nothing)

	push	ebp
	mov	ebp, esp

; 242  : 	}

	pop	ebp
	ret	0
??$_Destroy_range@V?$allocator@PAVLight@Ogre@@@std@@@std@@YAXPAPAVLight@Ogre@@0AAV?$allocator@PAVLight@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<Ogre::Light *> >
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@QAEXPAUAnimRange@BaseKeyFrameArray@Ogre@@@Z ; std::allocator<Ogre::BaseKeyFrameArray::AnimRange>::destroy
; Function compile flags: /Odtp
;	COMDAT ??$_Destroy_range@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@YAXPAUAnimRange@BaseKeyFrameArray@Ogre@@0AAV?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@YAXPAUAnimRange@BaseKeyFrameArray@Ogre@@0AAV?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >, COMDAT

; 232  : 	{	// destroy [_First, _Last), arbitrary type

	push	ebp
	mov	ebp, esp

; 233  : 	for (; _First != _Last; ++_First)

	jmp	SHORT $LN3@Destroy_ra@5
$LN2@Destroy_ra@5:
	mov	eax, DWORD PTR __First$[ebp]
	add	eax, 8
	mov	DWORD PTR __First$[ebp], eax
$LN3@Destroy_ra@5:
	mov	ecx, DWORD PTR __First$[ebp]
	cmp	ecx, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Destroy_ra@5

; 234  : 		_Al.destroy(_First);

	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?destroy@?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@QAEXPAUAnimRange@BaseKeyFrameArray@Ogre@@@Z ; std::allocator<Ogre::BaseKeyFrameArray::AnimRange>::destroy
	jmp	SHORT $LN2@Destroy_ra@5
$LN4@Destroy_ra@5:

; 235  : 	}

	pop	ebp
	ret	0
??$_Destroy_range@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@YAXPAUAnimRange@BaseKeyFrameArray@Ogre@@0AAV?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@QAEXPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@Z ; std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T>::destroy
; Function compile flags: /Odtp
;	COMDAT ??$_Destroy_range@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@0AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@0AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >, COMDAT

; 232  : 	{	// destroy [_First, _Last), arbitrary type

	push	ebp
	mov	ebp, esp

; 233  : 	for (; _First != _Last; ++_First)

	jmp	SHORT $LN3@Destroy_ra@6
$LN2@Destroy_ra@6:
	mov	eax, DWORD PTR __First$[ebp]
	add	eax, 8
	mov	DWORD PTR __First$[ebp], eax
$LN3@Destroy_ra@6:
	mov	ecx, DWORD PTR __First$[ebp]
	cmp	ecx, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Destroy_ra@6

; 234  : 		_Al.destroy(_First);

	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?destroy@?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@QAEXPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@Z ; std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T>::destroy
	jmp	SHORT $LN2@Destroy_ra@6
$LN4@Destroy_ra@6:

; 235  : 	}

	pop	ebp
	ret	0
??$_Destroy_range@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@0AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@QAEXPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@Z ; std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T>::destroy
; Function compile flags: /Odtp
;	COMDAT ??$_Destroy_range@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@0AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@0AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >, COMDAT

; 232  : 	{	// destroy [_First, _Last), arbitrary type

	push	ebp
	mov	ebp, esp

; 233  : 	for (; _First != _Last; ++_First)

	jmp	SHORT $LN3@Destroy_ra@7
$LN2@Destroy_ra@7:
	mov	eax, DWORD PTR __First$[ebp]
	add	eax, 8
	mov	DWORD PTR __First$[ebp], eax
$LN3@Destroy_ra@7:
	mov	ecx, DWORD PTR __First$[ebp]
	cmp	ecx, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Destroy_ra@7

; 234  : 		_Al.destroy(_First);

	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?destroy@?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@QAEXPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@Z ; std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T>::destroy
	jmp	SHORT $LN2@Destroy_ra@7
$LN4@Destroy_ra@7:

; 235  : 	}

	pop	ebp
	ret	0
??$_Destroy_range@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@0AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@QAEXPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@Z ; std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T>::destroy
; Function compile flags: /Odtp
;	COMDAT ??$_Destroy_range@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@0AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@0AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >, COMDAT

; 232  : 	{	// destroy [_First, _Last), arbitrary type

	push	ebp
	mov	ebp, esp

; 233  : 	for (; _First != _Last; ++_First)

	jmp	SHORT $LN3@Destroy_ra@8
$LN2@Destroy_ra@8:
	mov	eax, DWORD PTR __First$[ebp]
	add	eax, 20					; 00000014H
	mov	DWORD PTR __First$[ebp], eax
$LN3@Destroy_ra@8:
	mov	ecx, DWORD PTR __First$[ebp]
	cmp	ecx, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Destroy_ra@8

; 234  : 		_Al.destroy(_First);

	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?destroy@?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@QAEXPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@Z ; std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T>::destroy
	jmp	SHORT $LN2@Destroy_ra@8
$LN4@Destroy_ra@8:

; 235  : 	}

	pop	ebp
	ret	0
??$_Destroy_range@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@0AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >
_TEXT	ENDS
PUBLIC	?destroy@?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@QAEXPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@Z ; std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T>::destroy
; Function compile flags: /Odtp
;	COMDAT ??$_Destroy_range@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@0AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@0AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >, COMDAT

; 232  : 	{	// destroy [_First, _Last), arbitrary type

	push	ebp
	mov	ebp, esp

; 233  : 	for (; _First != _Last; ++_First)

	jmp	SHORT $LN3@Destroy_ra@9
$LN2@Destroy_ra@9:
	mov	eax, DWORD PTR __First$[ebp]
	add	eax, 32					; 00000020H
	mov	DWORD PTR __First$[ebp], eax
$LN3@Destroy_ra@9:
	mov	ecx, DWORD PTR __First$[ebp]
	cmp	ecx, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Destroy_ra@9

; 234  : 		_Al.destroy(_First);

	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?destroy@?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@QAEXPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@Z ; std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T>::destroy
	jmp	SHORT $LN2@Destroy_ra@9
$LN4@Destroy_ra@9:

; 235  : 	}

	pop	ebp
	ret	0
??$_Destroy_range@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@0AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >
_TEXT	ENDS
PUBLIC	??$_Unchecked_uninitialized_move@PAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@stdext@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@00AAV?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@Z ; stdext::_Unchecked_uninitialized_move<Ogre::BaseKeyFrameArray::AnimRange *,Ogre::BaseKeyFrameArray::AnimRange *,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??$_Umove@PAUAnimRange@BaseKeyFrameArray@Ogre@@@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAEPAUAnimRange@BaseKeyFrameArray@Ogre@@PAU234@00@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Umove@PAUAnimRange@BaseKeyFrameArray@Ogre@@@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAEPAUAnimRange@BaseKeyFrameArray@Ogre@@PAU234@00@Z PROC ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::_Umove<Ogre::BaseKeyFrameArray::AnimRange *>, COMDAT
; _this$ = ecx

; 1145 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1146 : 		{	// move initializing [_First, _Last), using allocator
; 1147 : 		return (_STDEXT _Unchecked_uninitialized_move(_First, _Last,
; 1148 : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Unchecked_uninitialized_move@PAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@stdext@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@00AAV?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@Z ; stdext::_Unchecked_uninitialized_move<Ogre::BaseKeyFrameArray::AnimRange *,Ogre::BaseKeyFrameArray::AnimRange *,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >
	add	esp, 16					; 00000010H

; 1149 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??$_Umove@PAUAnimRange@BaseKeyFrameArray@Ogre@@@?$vector@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@IAEPAUAnimRange@BaseKeyFrameArray@Ogre@@PAU234@00@Z ENDP ; std::vector<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::_Umove<Ogre::BaseKeyFrameArray::AnimRange *>
_TEXT	ENDS
PUBLIC	??$_Fill@PAUAnimRange@BaseKeyFrameArray@Ogre@@U123@@std@@YAXPAUAnimRange@BaseKeyFrameArray@Ogre@@0ABU123@@Z ; std::_Fill<Ogre::BaseKeyFrameArray::AnimRange *,Ogre::BaseKeyFrameArray::AnimRange>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$fill@PAUAnimRange@BaseKeyFrameArray@Ogre@@U123@@std@@YAXPAUAnimRange@BaseKeyFrameArray@Ogre@@0ABU123@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$fill@PAUAnimRange@BaseKeyFrameArray@Ogre@@U123@@std@@YAXPAUAnimRange@BaseKeyFrameArray@Ogre@@0ABU123@@Z PROC ; std::fill<Ogre::BaseKeyFrameArray::AnimRange *,Ogre::BaseKeyFrameArray::AnimRange>, COMDAT

; 3186 : 	{	// copy _Val through [_First, _Last)

	push	ebp
	mov	ebp, esp

; 3187 : 	_Fill(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@PAUAnimRange@BaseKeyFrameArray@Ogre@@@std@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@AAPAU123@@Z ; std::_Checked_base<Ogre::BaseKeyFrameArray::AnimRange *>
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@PAUAnimRange@BaseKeyFrameArray@Ogre@@@std@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@AAPAU123@@Z ; std::_Checked_base<Ogre::BaseKeyFrameArray::AnimRange *>
	add	esp, 4
	push	eax
	call	??$_Fill@PAUAnimRange@BaseKeyFrameArray@Ogre@@U123@@std@@YAXPAUAnimRange@BaseKeyFrameArray@Ogre@@0ABU123@@Z ; std::_Fill<Ogre::BaseKeyFrameArray::AnimRange *,Ogre::BaseKeyFrameArray::AnimRange>
	add	esp, 12					; 0000000cH

; 3188 : 	}

	pop	ebp
	ret	0
??$fill@PAUAnimRange@BaseKeyFrameArray@Ogre@@U123@@std@@YAXPAUAnimRange@BaseKeyFrameArray@Ogre@@0ABU123@@Z ENDP ; std::fill<Ogre::BaseKeyFrameArray::AnimRange *,Ogre::BaseKeyFrameArray::AnimRange>
_TEXT	ENDS
PUBLIC	??$_Move_backward_opt@PAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@5@@std@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Move_backward_opt<Ogre::BaseKeyFrameArray::AnimRange *,Ogre::BaseKeyFrameArray::AnimRange *,std::random_access_iterator_tag,std::_Undefined_move_tag>
PUBLIC	??$_Move_cat@PAUAnimRange@BaseKeyFrameArray@Ogre@@@std@@YA?AU_Undefined_move_tag@0@ABQAUAnimRange@BaseKeyFrameArray@Ogre@@@Z ; std::_Move_cat<Ogre::BaseKeyFrameArray::AnimRange *>
; Function compile flags: /Odtp
;	COMDAT ??$_Unchecked_move_backward@PAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@@stdext@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@00@Z
_TEXT	SEGMENT
$T98423 = -3						; size = 1
$T98422 = -2						; size = 1
$T98421 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Unchecked_move_backward@PAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@@stdext@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@00@Z PROC ; stdext::_Unchecked_move_backward<Ogre::BaseKeyFrameArray::AnimRange *,Ogre::BaseKeyFrameArray::AnimRange *>, COMDAT

; 3694 : 	{	// move [_First, _Last) backwards to [..., _Dest)

	push	ebp
	mov	ebp, esp
	push	ecx

; 3695 : 		return (_STD _Move_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3696 : 			_STD _Iter_random(_First, _Dest), _STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T98421[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	??$_Move_cat@PAUAnimRange@BaseKeyFrameArray@Ogre@@@std@@YA?AU_Undefined_move_tag@0@ABQAUAnimRange@BaseKeyFrameArray@Ogre@@@Z ; std::_Move_cat<Ogre::BaseKeyFrameArray::AnimRange *>
	add	esp, 4
	mov	BYTE PTR $T98422[ebp], al
	movzx	edx, BYTE PTR $T98421[ebp]
	push	edx
	movzx	eax, BYTE PTR $T98422[ebp]
	push	eax
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	lea	eax, DWORD PTR $T98423[ebp]
	push	eax
	call	??$_Iter_random@PAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUAnimRange@BaseKeyFrameArray@Ogre@@0@Z ; std::_Iter_random<Ogre::BaseKeyFrameArray::AnimRange *,Ogre::BaseKeyFrameArray::AnimRange *>
	add	esp, 12					; 0000000cH
	movzx	ecx, BYTE PTR [eax]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	call	??$_Checked_base@PAUAnimRange@BaseKeyFrameArray@Ogre@@@std@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@AAPAU123@@Z ; std::_Checked_base<Ogre::BaseKeyFrameArray::AnimRange *>
	add	esp, 4
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Checked_base@PAUAnimRange@BaseKeyFrameArray@Ogre@@@std@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@AAPAU123@@Z ; std::_Checked_base<Ogre::BaseKeyFrameArray::AnimRange *>
	add	esp, 4
	push	eax
	call	??$_Move_backward_opt@PAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@5@@std@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Move_backward_opt<Ogre::BaseKeyFrameArray::AnimRange *,Ogre::BaseKeyFrameArray::AnimRange *,std::random_access_iterator_tag,std::_Undefined_move_tag>
	add	esp, 24					; 00000018H

; 3697 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Unchecked_move_backward@PAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@@stdext@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@00@Z ENDP ; stdext::_Unchecked_move_backward<Ogre::BaseKeyFrameArray::AnimRange *,Ogre::BaseKeyFrameArray::AnimRange *>
_TEXT	ENDS
PUBLIC	??$_Unchecked_uninitialized_move@PAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@stdext@@YAPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU123@00AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@Z ; stdext::_Unchecked_uninitialized_move<Ogre::KeyFrameArray<float>::KEYFRAME_T *,Ogre::KeyFrameArray<float>::KEYFRAME_T *,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??$_Umove@PAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAEPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU234@00@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Umove@PAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAEPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU234@00@Z PROC ; std::vector<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::_Umove<Ogre::KeyFrameArray<float>::KEYFRAME_T *>, COMDAT
; _this$ = ecx

; 1145 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1146 : 		{	// move initializing [_First, _Last), using allocator
; 1147 : 		return (_STDEXT _Unchecked_uninitialized_move(_First, _Last,
; 1148 : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Unchecked_uninitialized_move@PAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@stdext@@YAPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU123@00AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@Z ; stdext::_Unchecked_uninitialized_move<Ogre::KeyFrameArray<float>::KEYFRAME_T *,Ogre::KeyFrameArray<float>::KEYFRAME_T *,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >
	add	esp, 16					; 00000010H

; 1149 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??$_Umove@PAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@?$vector@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAEPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU234@00@Z ENDP ; std::vector<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::_Umove<Ogre::KeyFrameArray<float>::KEYFRAME_T *>
_TEXT	ENDS
PUBLIC	??$_Fill@PAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@U123@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@0ABU123@@Z ; std::_Fill<Ogre::KeyFrameArray<float>::KEYFRAME_T *,Ogre::KeyFrameArray<float>::KEYFRAME_T>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$fill@PAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@U123@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@0ABU123@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$fill@PAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@U123@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@0ABU123@@Z PROC ; std::fill<Ogre::KeyFrameArray<float>::KEYFRAME_T *,Ogre::KeyFrameArray<float>::KEYFRAME_T>, COMDAT

; 3186 : 	{	// copy _Val through [_First, _Last)

	push	ebp
	mov	ebp, esp

; 3187 : 	_Fill(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@PAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@AAPAU123@@Z ; std::_Checked_base<Ogre::KeyFrameArray<float>::KEYFRAME_T *>
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@PAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@AAPAU123@@Z ; std::_Checked_base<Ogre::KeyFrameArray<float>::KEYFRAME_T *>
	add	esp, 4
	push	eax
	call	??$_Fill@PAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@U123@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@0ABU123@@Z ; std::_Fill<Ogre::KeyFrameArray<float>::KEYFRAME_T *,Ogre::KeyFrameArray<float>::KEYFRAME_T>
	add	esp, 12					; 0000000cH

; 3188 : 	}

	pop	ebp
	ret	0
??$fill@PAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@U123@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@0ABU123@@Z ENDP ; std::fill<Ogre::KeyFrameArray<float>::KEYFRAME_T *,Ogre::KeyFrameArray<float>::KEYFRAME_T>
_TEXT	ENDS
PUBLIC	??$_Move_backward_opt@PAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU123@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@5@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU123@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Move_backward_opt<Ogre::KeyFrameArray<float>::KEYFRAME_T *,Ogre::KeyFrameArray<float>::KEYFRAME_T *,std::random_access_iterator_tag,std::_Undefined_move_tag>
PUBLIC	??$_Move_cat@PAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@YA?AU_Undefined_move_tag@0@ABQAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@Z ; std::_Move_cat<Ogre::KeyFrameArray<float>::KEYFRAME_T *>
; Function compile flags: /Odtp
;	COMDAT ??$_Unchecked_move_backward@PAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU123@@stdext@@YAPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU123@00@Z
_TEXT	SEGMENT
$T98432 = -3						; size = 1
$T98431 = -2						; size = 1
$T98430 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Unchecked_move_backward@PAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU123@@stdext@@YAPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU123@00@Z PROC ; stdext::_Unchecked_move_backward<Ogre::KeyFrameArray<float>::KEYFRAME_T *,Ogre::KeyFrameArray<float>::KEYFRAME_T *>, COMDAT

; 3694 : 	{	// move [_First, _Last) backwards to [..., _Dest)

	push	ebp
	mov	ebp, esp
	push	ecx

; 3695 : 		return (_STD _Move_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3696 : 			_STD _Iter_random(_First, _Dest), _STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T98430[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	??$_Move_cat@PAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@YA?AU_Undefined_move_tag@0@ABQAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@Z ; std::_Move_cat<Ogre::KeyFrameArray<float>::KEYFRAME_T *>
	add	esp, 4
	mov	BYTE PTR $T98431[ebp], al
	movzx	edx, BYTE PTR $T98430[ebp]
	push	edx
	movzx	eax, BYTE PTR $T98431[ebp]
	push	eax
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	lea	eax, DWORD PTR $T98432[ebp]
	push	eax
	call	??$_Iter_random@PAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU123@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@0@Z ; std::_Iter_random<Ogre::KeyFrameArray<float>::KEYFRAME_T *,Ogre::KeyFrameArray<float>::KEYFRAME_T *>
	add	esp, 12					; 0000000cH
	movzx	ecx, BYTE PTR [eax]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	call	??$_Checked_base@PAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@AAPAU123@@Z ; std::_Checked_base<Ogre::KeyFrameArray<float>::KEYFRAME_T *>
	add	esp, 4
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Checked_base@PAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@AAPAU123@@Z ; std::_Checked_base<Ogre::KeyFrameArray<float>::KEYFRAME_T *>
	add	esp, 4
	push	eax
	call	??$_Move_backward_opt@PAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU123@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@5@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU123@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Move_backward_opt<Ogre::KeyFrameArray<float>::KEYFRAME_T *,Ogre::KeyFrameArray<float>::KEYFRAME_T *,std::random_access_iterator_tag,std::_Undefined_move_tag>
	add	esp, 24					; 00000018H

; 3697 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Unchecked_move_backward@PAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU123@@stdext@@YAPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU123@00@Z ENDP ; stdext::_Unchecked_move_backward<Ogre::KeyFrameArray<float>::KEYFRAME_T *,Ogre::KeyFrameArray<float>::KEYFRAME_T *>
_TEXT	ENDS
PUBLIC	??$_Unchecked_uninitialized_move@PAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@stdext@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU123@00AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@Z ; stdext::_Unchecked_uninitialized_move<Ogre::KeyFrameArray<float>::CONTROL_POINT_T *,Ogre::KeyFrameArray<float>::CONTROL_POINT_T *,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??$_Umove@PAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAEPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU234@00@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Umove@PAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAEPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU234@00@Z PROC ; std::vector<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::_Umove<Ogre::KeyFrameArray<float>::CONTROL_POINT_T *>, COMDAT
; _this$ = ecx

; 1145 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1146 : 		{	// move initializing [_First, _Last), using allocator
; 1147 : 		return (_STDEXT _Unchecked_uninitialized_move(_First, _Last,
; 1148 : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Unchecked_uninitialized_move@PAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@stdext@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU123@00AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@Z ; stdext::_Unchecked_uninitialized_move<Ogre::KeyFrameArray<float>::CONTROL_POINT_T *,Ogre::KeyFrameArray<float>::CONTROL_POINT_T *,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >
	add	esp, 16					; 00000010H

; 1149 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??$_Umove@PAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@IAEPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU234@00@Z ENDP ; std::vector<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::_Umove<Ogre::KeyFrameArray<float>::CONTROL_POINT_T *>
_TEXT	ENDS
PUBLIC	??$_Fill@PAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@U123@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@0ABU123@@Z ; std::_Fill<Ogre::KeyFrameArray<float>::CONTROL_POINT_T *,Ogre::KeyFrameArray<float>::CONTROL_POINT_T>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$fill@PAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@U123@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@0ABU123@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$fill@PAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@U123@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@0ABU123@@Z PROC ; std::fill<Ogre::KeyFrameArray<float>::CONTROL_POINT_T *,Ogre::KeyFrameArray<float>::CONTROL_POINT_T>, COMDAT

; 3186 : 	{	// copy _Val through [_First, _Last)

	push	ebp
	mov	ebp, esp

; 3187 : 	_Fill(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@PAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@AAPAU123@@Z ; std::_Checked_base<Ogre::KeyFrameArray<float>::CONTROL_POINT_T *>
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@PAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@AAPAU123@@Z ; std::_Checked_base<Ogre::KeyFrameArray<float>::CONTROL_POINT_T *>
	add	esp, 4
	push	eax
	call	??$_Fill@PAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@U123@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@0ABU123@@Z ; std::_Fill<Ogre::KeyFrameArray<float>::CONTROL_POINT_T *,Ogre::KeyFrameArray<float>::CONTROL_POINT_T>
	add	esp, 12					; 0000000cH

; 3188 : 	}

	pop	ebp
	ret	0
??$fill@PAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@U123@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@0ABU123@@Z ENDP ; std::fill<Ogre::KeyFrameArray<float>::CONTROL_POINT_T *,Ogre::KeyFrameArray<float>::CONTROL_POINT_T>
_TEXT	ENDS
PUBLIC	??$_Move_backward_opt@PAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU123@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@5@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU123@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Move_backward_opt<Ogre::KeyFrameArray<float>::CONTROL_POINT_T *,Ogre::KeyFrameArray<float>::CONTROL_POINT_T *,std::random_access_iterator_tag,std::_Undefined_move_tag>
PUBLIC	??$_Move_cat@PAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@YA?AU_Undefined_move_tag@0@ABQAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@Z ; std::_Move_cat<Ogre::KeyFrameArray<float>::CONTROL_POINT_T *>
; Function compile flags: /Odtp
;	COMDAT ??$_Unchecked_move_backward@PAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU123@@stdext@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU123@00@Z
_TEXT	SEGMENT
$T98441 = -3						; size = 1
$T98440 = -2						; size = 1
$T98439 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Unchecked_move_backward@PAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU123@@stdext@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU123@00@Z PROC ; stdext::_Unchecked_move_backward<Ogre::KeyFrameArray<float>::CONTROL_POINT_T *,Ogre::KeyFrameArray<float>::CONTROL_POINT_T *>, COMDAT

; 3694 : 	{	// move [_First, _Last) backwards to [..., _Dest)

	push	ebp
	mov	ebp, esp
	push	ecx

; 3695 : 		return (_STD _Move_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3696 : 			_STD _Iter_random(_First, _Dest), _STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T98439[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	??$_Move_cat@PAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@YA?AU_Undefined_move_tag@0@ABQAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@Z ; std::_Move_cat<Ogre::KeyFrameArray<float>::CONTROL_POINT_T *>
	add	esp, 4
	mov	BYTE PTR $T98440[ebp], al
	movzx	edx, BYTE PTR $T98439[ebp]
	push	edx
	movzx	eax, BYTE PTR $T98440[ebp]
	push	eax
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	lea	eax, DWORD PTR $T98441[ebp]
	push	eax
	call	??$_Iter_random@PAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU123@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@0@Z ; std::_Iter_random<Ogre::KeyFrameArray<float>::CONTROL_POINT_T *,Ogre::KeyFrameArray<float>::CONTROL_POINT_T *>
	add	esp, 12					; 0000000cH
	movzx	ecx, BYTE PTR [eax]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	call	??$_Checked_base@PAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@AAPAU123@@Z ; std::_Checked_base<Ogre::KeyFrameArray<float>::CONTROL_POINT_T *>
	add	esp, 4
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Checked_base@PAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@AAPAU123@@Z ; std::_Checked_base<Ogre::KeyFrameArray<float>::CONTROL_POINT_T *>
	add	esp, 4
	push	eax
	call	??$_Move_backward_opt@PAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU123@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@5@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU123@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Move_backward_opt<Ogre::KeyFrameArray<float>::CONTROL_POINT_T *,Ogre::KeyFrameArray<float>::CONTROL_POINT_T *,std::random_access_iterator_tag,std::_Undefined_move_tag>
	add	esp, 24					; 00000018H

; 3697 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Unchecked_move_backward@PAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU123@@stdext@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU123@00@Z ENDP ; stdext::_Unchecked_move_backward<Ogre::KeyFrameArray<float>::CONTROL_POINT_T *,Ogre::KeyFrameArray<float>::CONTROL_POINT_T *>
_TEXT	ENDS
PUBLIC	??$_Unchecked_uninitialized_move@PAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@stdext@@YAPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@Z ; stdext::_Unchecked_uninitialized_move<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T *,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??$_Umove@PAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAEPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU234@00@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Umove@PAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAEPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU234@00@Z PROC ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::_Umove<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T *>, COMDAT
; _this$ = ecx

; 1145 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1146 : 		{	// move initializing [_First, _Last), using allocator
; 1147 : 		return (_STDEXT _Unchecked_uninitialized_move(_First, _Last,
; 1148 : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Unchecked_uninitialized_move@PAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@stdext@@YAPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@Z ; stdext::_Unchecked_uninitialized_move<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T *,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >
	add	esp, 16					; 00000010H

; 1149 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??$_Umove@PAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@?$vector@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAEPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU234@00@Z ENDP ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::_Umove<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T *>
_TEXT	ENDS
PUBLIC	??$_Fill@PAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@U123@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@0ABU123@@Z ; std::_Fill<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$fill@PAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@U123@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@0ABU123@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$fill@PAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@U123@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@0ABU123@@Z PROC ; std::fill<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T>, COMDAT

; 3186 : 	{	// copy _Val through [_First, _Last)

	push	ebp
	mov	ebp, esp

; 3187 : 	_Fill(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@PAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@AAPAU123@@Z ; std::_Checked_base<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T *>
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@PAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@AAPAU123@@Z ; std::_Checked_base<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T *>
	add	esp, 4
	push	eax
	call	??$_Fill@PAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@U123@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@0ABU123@@Z ; std::_Fill<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T>
	add	esp, 12					; 0000000cH

; 3188 : 	}

	pop	ebp
	ret	0
??$fill@PAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@U123@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@0ABU123@@Z ENDP ; std::fill<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T>
_TEXT	ENDS
PUBLIC	??$_Move_backward_opt@PAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@5@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Move_backward_opt<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T *,std::random_access_iterator_tag,std::_Undefined_move_tag>
PUBLIC	??$_Move_cat@PAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@YA?AU_Undefined_move_tag@0@ABQAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@Z ; std::_Move_cat<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T *>
; Function compile flags: /Odtp
;	COMDAT ??$_Unchecked_move_backward@PAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@@stdext@@YAPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@00@Z
_TEXT	SEGMENT
$T98450 = -3						; size = 1
$T98449 = -2						; size = 1
$T98448 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Unchecked_move_backward@PAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@@stdext@@YAPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@00@Z PROC ; stdext::_Unchecked_move_backward<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T *>, COMDAT

; 3694 : 	{	// move [_First, _Last) backwards to [..., _Dest)

	push	ebp
	mov	ebp, esp
	push	ecx

; 3695 : 		return (_STD _Move_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3696 : 			_STD _Iter_random(_First, _Dest), _STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T98448[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	??$_Move_cat@PAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@YA?AU_Undefined_move_tag@0@ABQAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@Z ; std::_Move_cat<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T *>
	add	esp, 4
	mov	BYTE PTR $T98449[ebp], al
	movzx	edx, BYTE PTR $T98448[ebp]
	push	edx
	movzx	eax, BYTE PTR $T98449[ebp]
	push	eax
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	lea	eax, DWORD PTR $T98450[ebp]
	push	eax
	call	??$_Iter_random@PAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@0@Z ; std::_Iter_random<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T *>
	add	esp, 12					; 0000000cH
	movzx	ecx, BYTE PTR [eax]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	call	??$_Checked_base@PAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@AAPAU123@@Z ; std::_Checked_base<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T *>
	add	esp, 4
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Checked_base@PAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@AAPAU123@@Z ; std::_Checked_base<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T *>
	add	esp, 4
	push	eax
	call	??$_Move_backward_opt@PAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@5@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Move_backward_opt<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T *,std::random_access_iterator_tag,std::_Undefined_move_tag>
	add	esp, 24					; 00000018H

; 3697 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Unchecked_move_backward@PAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@@stdext@@YAPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@00@Z ENDP ; stdext::_Unchecked_move_backward<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T *>
_TEXT	ENDS
PUBLIC	??$_Unchecked_uninitialized_move@PAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@stdext@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@Z ; stdext::_Unchecked_uninitialized_move<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T *,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??$_Umove@PAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAEPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU234@00@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Umove@PAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAEPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU234@00@Z PROC ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::_Umove<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T *>, COMDAT
; _this$ = ecx

; 1145 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1146 : 		{	// move initializing [_First, _Last), using allocator
; 1147 : 		return (_STDEXT _Unchecked_uninitialized_move(_First, _Last,
; 1148 : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Unchecked_uninitialized_move@PAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@stdext@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@Z ; stdext::_Unchecked_uninitialized_move<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T *,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >
	add	esp, 16					; 00000010H

; 1149 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??$_Umove@PAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@?$vector@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@IAEPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU234@00@Z ENDP ; std::vector<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::_Umove<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T *>
_TEXT	ENDS
PUBLIC	??$_Fill@PAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@U123@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@0ABU123@@Z ; std::_Fill<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$fill@PAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@U123@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@0ABU123@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$fill@PAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@U123@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@0ABU123@@Z PROC ; std::fill<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T>, COMDAT

; 3186 : 	{	// copy _Val through [_First, _Last)

	push	ebp
	mov	ebp, esp

; 3187 : 	_Fill(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@PAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@AAPAU123@@Z ; std::_Checked_base<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T *>
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@PAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@AAPAU123@@Z ; std::_Checked_base<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T *>
	add	esp, 4
	push	eax
	call	??$_Fill@PAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@U123@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@0ABU123@@Z ; std::_Fill<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T>
	add	esp, 12					; 0000000cH

; 3188 : 	}

	pop	ebp
	ret	0
??$fill@PAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@U123@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@0ABU123@@Z ENDP ; std::fill<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T>
_TEXT	ENDS
PUBLIC	??$_Move_backward_opt@PAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@5@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Move_backward_opt<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T *,std::random_access_iterator_tag,std::_Undefined_move_tag>
PUBLIC	??$_Move_cat@PAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@YA?AU_Undefined_move_tag@0@ABQAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@Z ; std::_Move_cat<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T *>
; Function compile flags: /Odtp
;	COMDAT ??$_Unchecked_move_backward@PAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@@stdext@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@00@Z
_TEXT	SEGMENT
$T98459 = -3						; size = 1
$T98458 = -2						; size = 1
$T98457 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Unchecked_move_backward@PAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@@stdext@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@00@Z PROC ; stdext::_Unchecked_move_backward<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T *>, COMDAT

; 3694 : 	{	// move [_First, _Last) backwards to [..., _Dest)

	push	ebp
	mov	ebp, esp
	push	ecx

; 3695 : 		return (_STD _Move_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3696 : 			_STD _Iter_random(_First, _Dest), _STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T98457[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	??$_Move_cat@PAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@YA?AU_Undefined_move_tag@0@ABQAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@Z ; std::_Move_cat<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T *>
	add	esp, 4
	mov	BYTE PTR $T98458[ebp], al
	movzx	edx, BYTE PTR $T98457[ebp]
	push	edx
	movzx	eax, BYTE PTR $T98458[ebp]
	push	eax
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	lea	eax, DWORD PTR $T98459[ebp]
	push	eax
	call	??$_Iter_random@PAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@@std@@YA?AUrandom_access_iterator_tag@0@ABQAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@0@Z ; std::_Iter_random<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T *>
	add	esp, 12					; 0000000cH
	movzx	ecx, BYTE PTR [eax]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	call	??$_Checked_base@PAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@AAPAU123@@Z ; std::_Checked_base<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T *>
	add	esp, 4
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Checked_base@PAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@AAPAU123@@Z ; std::_Checked_base<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T *>
	add	esp, 4
	push	eax
	call	??$_Move_backward_opt@PAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@5@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Move_backward_opt<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T *,std::random_access_iterator_tag,std::_Undefined_move_tag>
	add	esp, 24					; 00000018H

; 3697 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Unchecked_move_backward@PAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@@stdext@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@00@Z ENDP ; stdext::_Unchecked_move_backward<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T *>
_TEXT	ENDS
PUBLIC	??$_Uninit_fill_n@PAUAnimRange@BaseKeyFrameArray@Ogre@@IU123@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@YAXPAUAnimRange@BaseKeyFrameArray@Ogre@@IABU123@AAV?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<Ogre::BaseKeyFrameArray::AnimRange *,unsigned int,Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$unchecked_uninitialized_fill_n@PAUAnimRange@BaseKeyFrameArray@Ogre@@IU123@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@stdext@@YAXPAUAnimRange@BaseKeyFrameArray@Ogre@@IABU123@AAV?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@Z
_TEXT	SEGMENT
$T98463 = -2						; size = 1
$T98462 = -1						; size = 1
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_fill_n@PAUAnimRange@BaseKeyFrameArray@Ogre@@IU123@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@stdext@@YAXPAUAnimRange@BaseKeyFrameArray@Ogre@@IABU123@AAV?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@Z PROC ; stdext::unchecked_uninitialized_fill_n<Ogre::BaseKeyFrameArray::AnimRange *,unsigned int,Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >, COMDAT

; 940  : 	{	// copy _Count *_Val to raw _First, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 941  : 	_STD _Uninit_fill_n(_First, _Count, _Val, _Al,
; 942  : 		_STD _Ptr_cat(_First, _First), _STD _Range_checked_iterator_tag());

	xor	eax, eax
	mov	BYTE PTR $T98462[ebp], al
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUAnimRange@BaseKeyFrameArray@Ogre@@0@Z ; std::_Ptr_cat<Ogre::BaseKeyFrameArray::AnimRange *,Ogre::BaseKeyFrameArray::AnimRange *>
	add	esp, 8
	mov	BYTE PTR $T98463[ebp], al
	movzx	eax, BYTE PTR $T98462[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T98463[ebp]
	push	ecx
	mov	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Uninit_fill_n@PAUAnimRange@BaseKeyFrameArray@Ogre@@IU123@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@YAXPAUAnimRange@BaseKeyFrameArray@Ogre@@IABU123@AAV?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<Ogre::BaseKeyFrameArray::AnimRange *,unsigned int,Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >
	add	esp, 24					; 00000018H

; 943  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_fill_n@PAUAnimRange@BaseKeyFrameArray@Ogre@@IU123@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@stdext@@YAXPAUAnimRange@BaseKeyFrameArray@Ogre@@IABU123@AAV?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_fill_n<Ogre::BaseKeyFrameArray::AnimRange *,unsigned int,Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >
_TEXT	ENDS
PUBLIC	??$_Uninit_fill_n@PAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@IU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@IABU123@AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<Ogre::KeyFrameArray<float>::KEYFRAME_T *,unsigned int,Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >
; Function compile flags: /Odtp
;	COMDAT ??$unchecked_uninitialized_fill_n@PAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@IU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@stdext@@YAXPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@IABU123@AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@Z
_TEXT	SEGMENT
$T98467 = -2						; size = 1
$T98466 = -1						; size = 1
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_fill_n@PAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@IU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@stdext@@YAXPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@IABU123@AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@Z PROC ; stdext::unchecked_uninitialized_fill_n<Ogre::KeyFrameArray<float>::KEYFRAME_T *,unsigned int,Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >, COMDAT

; 940  : 	{	// copy _Count *_Val to raw _First, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 941  : 	_STD _Uninit_fill_n(_First, _Count, _Val, _Al,
; 942  : 		_STD _Ptr_cat(_First, _First), _STD _Range_checked_iterator_tag());

	xor	eax, eax
	mov	BYTE PTR $T98466[ebp], al
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU123@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@0@Z ; std::_Ptr_cat<Ogre::KeyFrameArray<float>::KEYFRAME_T *,Ogre::KeyFrameArray<float>::KEYFRAME_T *>
	add	esp, 8
	mov	BYTE PTR $T98467[ebp], al
	movzx	eax, BYTE PTR $T98466[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T98467[ebp]
	push	ecx
	mov	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Uninit_fill_n@PAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@IU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@IABU123@AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<Ogre::KeyFrameArray<float>::KEYFRAME_T *,unsigned int,Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >
	add	esp, 24					; 00000018H

; 943  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_fill_n@PAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@IU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@stdext@@YAXPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@IABU123@AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_fill_n<Ogre::KeyFrameArray<float>::KEYFRAME_T *,unsigned int,Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >
_TEXT	ENDS
PUBLIC	??$_Uninit_fill_n@PAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@IU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@IABU123@AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<Ogre::KeyFrameArray<float>::CONTROL_POINT_T *,unsigned int,Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >
; Function compile flags: /Odtp
;	COMDAT ??$unchecked_uninitialized_fill_n@PAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@IU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@stdext@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@IABU123@AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@Z
_TEXT	SEGMENT
$T98471 = -2						; size = 1
$T98470 = -1						; size = 1
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_fill_n@PAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@IU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@stdext@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@IABU123@AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@Z PROC ; stdext::unchecked_uninitialized_fill_n<Ogre::KeyFrameArray<float>::CONTROL_POINT_T *,unsigned int,Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >, COMDAT

; 940  : 	{	// copy _Count *_Val to raw _First, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 941  : 	_STD _Uninit_fill_n(_First, _Count, _Val, _Al,
; 942  : 		_STD _Ptr_cat(_First, _First), _STD _Range_checked_iterator_tag());

	xor	eax, eax
	mov	BYTE PTR $T98470[ebp], al
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU123@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@0@Z ; std::_Ptr_cat<Ogre::KeyFrameArray<float>::CONTROL_POINT_T *,Ogre::KeyFrameArray<float>::CONTROL_POINT_T *>
	add	esp, 8
	mov	BYTE PTR $T98471[ebp], al
	movzx	eax, BYTE PTR $T98470[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T98471[ebp]
	push	ecx
	mov	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Uninit_fill_n@PAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@IU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@IABU123@AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<Ogre::KeyFrameArray<float>::CONTROL_POINT_T *,unsigned int,Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >
	add	esp, 24					; 00000018H

; 943  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_fill_n@PAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@IU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@stdext@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@IABU123@AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_fill_n<Ogre::KeyFrameArray<float>::CONTROL_POINT_T *,unsigned int,Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >
_TEXT	ENDS
PUBLIC	??$_Uninit_fill_n@PAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@IU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@IABU123@AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T *,unsigned int,Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >
; Function compile flags: /Odtp
;	COMDAT ??$unchecked_uninitialized_fill_n@PAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@IU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@stdext@@YAXPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@IABU123@AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@Z
_TEXT	SEGMENT
$T98475 = -2						; size = 1
$T98474 = -1						; size = 1
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_fill_n@PAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@IU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@stdext@@YAXPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@IABU123@AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@Z PROC ; stdext::unchecked_uninitialized_fill_n<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T *,unsigned int,Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >, COMDAT

; 940  : 	{	// copy _Count *_Val to raw _First, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 941  : 	_STD _Uninit_fill_n(_First, _Count, _Val, _Al,
; 942  : 		_STD _Ptr_cat(_First, _First), _STD _Range_checked_iterator_tag());

	xor	eax, eax
	mov	BYTE PTR $T98474[ebp], al
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@0@Z ; std::_Ptr_cat<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T *>
	add	esp, 8
	mov	BYTE PTR $T98475[ebp], al
	movzx	eax, BYTE PTR $T98474[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T98475[ebp]
	push	ecx
	mov	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Uninit_fill_n@PAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@IU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@IABU123@AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T *,unsigned int,Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >
	add	esp, 24					; 00000018H

; 943  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_fill_n@PAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@IU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@stdext@@YAXPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@IABU123@AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_fill_n<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T *,unsigned int,Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >
_TEXT	ENDS
PUBLIC	??$_Uninit_fill_n@PAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@IU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@IABU123@AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T *,unsigned int,Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >
; Function compile flags: /Odtp
;	COMDAT ??$unchecked_uninitialized_fill_n@PAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@IU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@stdext@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@IABU123@AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@Z
_TEXT	SEGMENT
$T98479 = -2						; size = 1
$T98478 = -1						; size = 1
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_fill_n@PAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@IU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@stdext@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@IABU123@AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@Z PROC ; stdext::unchecked_uninitialized_fill_n<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T *,unsigned int,Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >, COMDAT

; 940  : 	{	// copy _Count *_Val to raw _First, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 941  : 	_STD _Uninit_fill_n(_First, _Count, _Val, _Al,
; 942  : 		_STD _Ptr_cat(_First, _First), _STD _Range_checked_iterator_tag());

	xor	eax, eax
	mov	BYTE PTR $T98478[ebp], al
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@0@Z ; std::_Ptr_cat<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T *>
	add	esp, 8
	mov	BYTE PTR $T98479[ebp], al
	movzx	eax, BYTE PTR $T98478[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T98479[ebp]
	push	ecx
	mov	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Uninit_fill_n@PAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@IU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@IABU123@AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T *,unsigned int,Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >
	add	esp, 24					; 00000018H

; 943  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_fill_n@PAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@IU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@stdext@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@IABU123@AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_fill_n<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T *,unsigned int,Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >
_TEXT	ENDS
PUBLIC	??$_Destroy@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@YAXPAUAnimRange@BaseKeyFrameArray@Ogre@@@Z ; std::_Destroy<Ogre::BaseKeyFrameArray::AnimRange>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ?destroy@?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@QAEXPAUAnimRange@BaseKeyFrameArray@Ogre@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?destroy@?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@QAEXPAUAnimRange@BaseKeyFrameArray@Ogre@@@Z PROC ; std::allocator<Ogre::BaseKeyFrameArray::AnimRange>::destroy, COMDAT
; _this$ = ecx

; 159  : 		{	// destroy object at _Ptr

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 160  : 		_Destroy(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??$_Destroy@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@YAXPAUAnimRange@BaseKeyFrameArray@Ogre@@@Z ; std::_Destroy<Ogre::BaseKeyFrameArray::AnimRange>
	add	esp, 4

; 161  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?destroy@?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@QAEXPAUAnimRange@BaseKeyFrameArray@Ogre@@@Z ENDP ; std::allocator<Ogre::BaseKeyFrameArray::AnimRange>::destroy
_TEXT	ENDS
PUBLIC	??$_Destroy@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@Z ; std::_Destroy<Ogre::KeyFrameArray<float>::KEYFRAME_T>
; Function compile flags: /Odtp
;	COMDAT ?destroy@?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@QAEXPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?destroy@?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@QAEXPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@Z PROC ; std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T>::destroy, COMDAT
; _this$ = ecx

; 159  : 		{	// destroy object at _Ptr

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 160  : 		_Destroy(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??$_Destroy@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@Z ; std::_Destroy<Ogre::KeyFrameArray<float>::KEYFRAME_T>
	add	esp, 4

; 161  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?destroy@?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@QAEXPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@Z ENDP ; std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T>::destroy
_TEXT	ENDS
PUBLIC	??$_Destroy@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@Z ; std::_Destroy<Ogre::KeyFrameArray<float>::CONTROL_POINT_T>
; Function compile flags: /Odtp
;	COMDAT ?destroy@?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@QAEXPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?destroy@?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@QAEXPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@Z PROC ; std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T>::destroy, COMDAT
; _this$ = ecx

; 159  : 		{	// destroy object at _Ptr

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 160  : 		_Destroy(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??$_Destroy@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@Z ; std::_Destroy<Ogre::KeyFrameArray<float>::CONTROL_POINT_T>
	add	esp, 4

; 161  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?destroy@?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@QAEXPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@Z ENDP ; std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T>::destroy
_TEXT	ENDS
PUBLIC	??$_Destroy@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@Z ; std::_Destroy<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T>
; Function compile flags: /Odtp
;	COMDAT ?destroy@?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@QAEXPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?destroy@?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@QAEXPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@Z PROC ; std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T>::destroy, COMDAT
; _this$ = ecx

; 159  : 		{	// destroy object at _Ptr

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 160  : 		_Destroy(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??$_Destroy@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@Z ; std::_Destroy<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T>
	add	esp, 4

; 161  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?destroy@?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@QAEXPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@Z ENDP ; std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T>::destroy
_TEXT	ENDS
PUBLIC	??$_Destroy@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@Z ; std::_Destroy<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T>
; Function compile flags: /Odtp
;	COMDAT ?destroy@?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@QAEXPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?destroy@?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@QAEXPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@Z PROC ; std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T>::destroy, COMDAT
; _this$ = ecx

; 159  : 		{	// destroy object at _Ptr

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 160  : 		_Destroy(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??$_Destroy@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@Z ; std::_Destroy<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T>
	add	esp, 4

; 161  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?destroy@?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@QAEXPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@Z ENDP ; std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T>::destroy
_TEXT	ENDS
PUBLIC	??$_Destroy@UContextQueDesc@Ogre@@@std@@YAXPAUContextQueDesc@Ogre@@@Z ; std::_Destroy<Ogre::ContextQueDesc>
; Function compile flags: /Odtp
;	COMDAT ?destroy@?$allocator@UContextQueDesc@Ogre@@@std@@QAEXPAUContextQueDesc@Ogre@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?destroy@?$allocator@UContextQueDesc@Ogre@@@std@@QAEXPAUContextQueDesc@Ogre@@@Z PROC ; std::allocator<Ogre::ContextQueDesc>::destroy, COMDAT
; _this$ = ecx

; 159  : 		{	// destroy object at _Ptr

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 160  : 		_Destroy(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??$_Destroy@UContextQueDesc@Ogre@@@std@@YAXPAUContextQueDesc@Ogre@@@Z ; std::_Destroy<Ogre::ContextQueDesc>
	add	esp, 4

; 161  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?destroy@?$allocator@UContextQueDesc@Ogre@@@std@@QAEXPAUContextQueDesc@Ogre@@@Z ENDP ; std::allocator<Ogre::ContextQueDesc>::destroy
_TEXT	ENDS
PUBLIC	??$_Destroy@UValueParam@ShaderContextPool@Ogre@@@std@@YAXPAUValueParam@ShaderContextPool@Ogre@@@Z ; std::_Destroy<Ogre::ShaderContextPool::ValueParam>
; Function compile flags: /Odtp
;	COMDAT ?destroy@?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@QAEXPAUValueParam@ShaderContextPool@Ogre@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?destroy@?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@QAEXPAUValueParam@ShaderContextPool@Ogre@@@Z PROC ; std::allocator<Ogre::ShaderContextPool::ValueParam>::destroy, COMDAT
; _this$ = ecx

; 159  : 		{	// destroy object at _Ptr

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 160  : 		_Destroy(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??$_Destroy@UValueParam@ShaderContextPool@Ogre@@@std@@YAXPAUValueParam@ShaderContextPool@Ogre@@@Z ; std::_Destroy<Ogre::ShaderContextPool::ValueParam>
	add	esp, 4

; 161  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?destroy@?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@QAEXPAUValueParam@ShaderContextPool@Ogre@@@Z ENDP ; std::allocator<Ogre::ShaderContextPool::ValueParam>::destroy
_TEXT	ENDS
PUBLIC	??$_Destroy@UTexParam@ShaderContextPool@Ogre@@@std@@YAXPAUTexParam@ShaderContextPool@Ogre@@@Z ; std::_Destroy<Ogre::ShaderContextPool::TexParam>
; Function compile flags: /Odtp
;	COMDAT ?destroy@?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@QAEXPAUTexParam@ShaderContextPool@Ogre@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?destroy@?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@QAEXPAUTexParam@ShaderContextPool@Ogre@@@Z PROC ; std::allocator<Ogre::ShaderContextPool::TexParam>::destroy, COMDAT
; _this$ = ecx

; 159  : 		{	// destroy object at _Ptr

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 160  : 		_Destroy(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??$_Destroy@UTexParam@ShaderContextPool@Ogre@@@std@@YAXPAUTexParam@ShaderContextPool@Ogre@@@Z ; std::_Destroy<Ogre::ShaderContextPool::TexParam>
	add	esp, 4

; 161  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?destroy@?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@QAEXPAUTexParam@ShaderContextPool@Ogre@@@Z ENDP ; std::allocator<Ogre::ShaderContextPool::TexParam>::destroy
_TEXT	ENDS
PUBLIC	??$_Destroy@URecord@CullResult@Ogre@@@std@@YAXPAURecord@CullResult@Ogre@@@Z ; std::_Destroy<Ogre::CullResult::Record>
; Function compile flags: /Odtp
;	COMDAT ?destroy@?$allocator@URecord@CullResult@Ogre@@@std@@QAEXPAURecord@CullResult@Ogre@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?destroy@?$allocator@URecord@CullResult@Ogre@@@std@@QAEXPAURecord@CullResult@Ogre@@@Z PROC ; std::allocator<Ogre::CullResult::Record>::destroy, COMDAT
; _this$ = ecx

; 159  : 		{	// destroy object at _Ptr

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 160  : 		_Destroy(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??$_Destroy@URecord@CullResult@Ogre@@@std@@YAXPAURecord@CullResult@Ogre@@@Z ; std::_Destroy<Ogre::CullResult::Record>
	add	esp, 4

; 161  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?destroy@?$allocator@URecord@CullResult@Ogre@@@std@@QAEXPAURecord@CullResult@Ogre@@@Z ENDP ; std::allocator<Ogre::CullResult::Record>::destroy
_TEXT	ENDS
PUBLIC	??$_Checked_base@V?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBUAnimRange@BaseKeyFrameArray@Ogre@@AAV?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >,std::_Different_checked_iterator_base_type_tag>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Checked_base@V?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@@std@@YAPBUAnimRange@BaseKeyFrameArray@Ogre@@AAV?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@0@@Z
_TEXT	SEGMENT
__Base_tag$ = -1					; size = 1
__It$ = 8						; size = 4
??$_Checked_base@V?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@@std@@YAPBUAnimRange@BaseKeyFrameArray@Ogre@@AAV?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@0@@Z PROC ; std::_Checked_base<std::_Vector_const_iterator<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> > >, COMDAT

; 1163 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1164 : 		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
; 1165 : 		return _Checked_base(_It, _Base_tag);

	movzx	eax, BYTE PTR __Base_tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR __It$[ebp]
	push	ecx
	call	??$_Checked_base@V?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBUAnimRange@BaseKeyFrameArray@Ogre@@AAV?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >,std::_Different_checked_iterator_base_type_tag>
	add	esp, 8

; 1166 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Checked_base@V?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@@std@@YAPBUAnimRange@BaseKeyFrameArray@Ogre@@AAV?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@0@@Z ENDP ; std::_Checked_base<std::_Vector_const_iterator<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> > >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@V?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@PAUAnimRange@BaseKeyFrameArray@Ogre@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@0@AAPAUAnimRange@BaseKeyFrameArray@Ogre@@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@V?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@PAUAnimRange@BaseKeyFrameArray@Ogre@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@0@AAPAUAnimRange@BaseKeyFrameArray@Ogre@@@Z PROC ; std::_Ptr_cat<std::_Vector_const_iterator<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >,Ogre::BaseKeyFrameArray::AnimRange *>, COMDAT

; 1509 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 1512 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Ptr_cat@V?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@PAUAnimRange@BaseKeyFrameArray@Ogre@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@0@AAPAUAnimRange@BaseKeyFrameArray@Ogre@@@Z ENDP ; std::_Ptr_cat<std::_Vector_const_iterator<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >,Ogre::BaseKeyFrameArray::AnimRange *>
_TEXT	ENDS
PUBLIC	?construct@?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@QAEXPAUAnimRange@BaseKeyFrameArray@Ogre@@ABU345@@Z ; std::allocator<Ogre::BaseKeyFrameArray::AnimRange>::construct
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	SEGMENT
__catchsym$??$_Uninit_copy@PBUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@PBU123@0PAU123@AAV?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_copy@PBUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@PBU123@0PAU123@AAV?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__unwindtable$??$_Uninit_copy@PBUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@PBU123@0PAU123@AAV?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Uninit_copy@PBUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@PBU123@0PAU123@AAV?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_copy@PBUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@PBU123@0PAU123@AAV?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2
__ehfuncinfo$??$_Uninit_copy@PBUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@PBU123@0PAU123@AAV?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Uninit_copy@PBUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@PBU123@0PAU123@AAV?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_copy@PBUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@PBU123@0PAU123@AAV?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??$_Uninit_copy@PBUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@PBU123@0PAU123@AAV?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PBUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@PBU123@0PAU123@AAV?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<Ogre::BaseKeyFrameArray::AnimRange const *,Ogre::BaseKeyFrameArray::AnimRange *,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >, COMDAT

; 124  : 	{	// copy [_First, _Last) to raw _Dest, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_copy@PBUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@PBU123@0PAU123@AAV?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 125  : 	_DEBUG_RANGE(_First, _Last);
; 126  : 	_DEBUG_POINTER(_Dest);
; 127  : 	_FwdIt _Next = _Dest;

	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Next$[ebp], eax

; 128  : 
; 129  : 	_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 130  : 	for (; _First != _Last; ++_Dest, ++_First)

	jmp	SHORT $LN6@Uninit_cop
$LN5@Uninit_cop:
	mov	ecx, DWORD PTR __Dest$[ebp]
	add	ecx, 8
	mov	DWORD PTR __Dest$[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	add	edx, 8
	mov	DWORD PTR __First$[ebp], edx
$LN6@Uninit_cop:
	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Uninit_cop

; 131  : 		_Al.construct(_Dest, *_First);

	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?construct@?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@QAEXPAUAnimRange@BaseKeyFrameArray@Ogre@@ABU345@@Z ; std::allocator<Ogre::BaseKeyFrameArray::AnimRange>::construct
	jmp	SHORT $LN5@Uninit_cop
$LN4@Uninit_cop:
	jmp	SHORT $LN10@Uninit_cop
__catch$??$_Uninit_copy@PBUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@PBU123@0PAU123@AAV?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 132  : 	_CATCH_ALL
; 133  : 	for (; _Next != _Dest; ++_Next)

	jmp	SHORT $LN3@Uninit_cop
$LN2@Uninit_cop:
	mov	eax, DWORD PTR __Next$[ebp]
	add	eax, 8
	mov	DWORD PTR __Next$[ebp], eax
$LN3@Uninit_cop:
	mov	ecx, DWORD PTR __Next$[ebp]
	cmp	ecx, DWORD PTR __Dest$[ebp]
	je	SHORT $LN1@Uninit_cop

; 134  : 		_Al.destroy(_Next);

	mov	edx, DWORD PTR __Next$[ebp]
	push	edx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?destroy@?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@QAEXPAUAnimRange@BaseKeyFrameArray@Ogre@@@Z ; std::allocator<Ogre::BaseKeyFrameArray::AnimRange>::destroy
	jmp	SHORT $LN2@Uninit_cop
$LN1@Uninit_cop:

; 135  : 	_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 136  : 	_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$??$_Uninit_copy@PBUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@PBU123@0PAU123@AAV?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1
	ret	0
$LN10@Uninit_cop:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Uninit_copy@PBUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@PBU123@0PAU123@AAV?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1:

; 137  : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[ebp]
$LN9@Uninit_cop:

; 138  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_copy@PBUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@PBU123@0PAU123@AAV?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_copy@PBUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@PBU123@0PAU123@AAV?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_copy@PBUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@PBU123@0PAU123@AAV?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<Ogre::BaseKeyFrameArray::AnimRange const *,Ogre::BaseKeyFrameArray::AnimRange *,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >
PUBLIC	??$_Checked_base@V?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@AAV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >,std::_Different_checked_iterator_base_type_tag>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Checked_base@V?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@@std@@YAPBUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@AAV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@0@@Z
_TEXT	SEGMENT
__Base_tag$ = -1					; size = 1
__It$ = 8						; size = 4
??$_Checked_base@V?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@@std@@YAPBUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@AAV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@0@@Z PROC ; std::_Checked_base<std::_Vector_const_iterator<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> > >, COMDAT

; 1163 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1164 : 		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
; 1165 : 		return _Checked_base(_It, _Base_tag);

	movzx	eax, BYTE PTR __Base_tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR __It$[ebp]
	push	ecx
	call	??$_Checked_base@V?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@AAV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >,std::_Different_checked_iterator_base_type_tag>
	add	esp, 8

; 1166 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Checked_base@V?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@@std@@YAPBUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@AAV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@0@@Z ENDP ; std::_Checked_base<std::_Vector_const_iterator<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> > >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@V?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@PAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@0@AAPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@V?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@PAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@0@AAPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@Z PROC ; std::_Ptr_cat<std::_Vector_const_iterator<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >,Ogre::KeyFrameArray<float>::KEYFRAME_T *>, COMDAT

; 1509 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 1512 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Ptr_cat@V?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@PAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@0@AAPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@Z ENDP ; std::_Ptr_cat<std::_Vector_const_iterator<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >,Ogre::KeyFrameArray<float>::KEYFRAME_T *>
_TEXT	ENDS
PUBLIC	?construct@?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@QAEXPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@ABU345@@Z ; std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T>::construct
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	SEGMENT
__catchsym$??$_Uninit_copy@PBUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PBU123@0PAU123@AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_copy@PBUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PBU123@0PAU123@AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__unwindtable$??$_Uninit_copy@PBUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PBU123@0PAU123@AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Uninit_copy@PBUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PBU123@0PAU123@AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_copy@PBUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PBU123@0PAU123@AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2
__ehfuncinfo$??$_Uninit_copy@PBUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PBU123@0PAU123@AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Uninit_copy@PBUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PBU123@0PAU123@AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_copy@PBUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PBU123@0PAU123@AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??$_Uninit_copy@PBUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PBU123@0PAU123@AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PBUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PBU123@0PAU123@AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<Ogre::KeyFrameArray<float>::KEYFRAME_T const *,Ogre::KeyFrameArray<float>::KEYFRAME_T *,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >, COMDAT

; 124  : 	{	// copy [_First, _Last) to raw _Dest, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_copy@PBUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PBU123@0PAU123@AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 125  : 	_DEBUG_RANGE(_First, _Last);
; 126  : 	_DEBUG_POINTER(_Dest);
; 127  : 	_FwdIt _Next = _Dest;

	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Next$[ebp], eax

; 128  : 
; 129  : 	_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 130  : 	for (; _First != _Last; ++_Dest, ++_First)

	jmp	SHORT $LN6@Uninit_cop@2
$LN5@Uninit_cop@2:
	mov	ecx, DWORD PTR __Dest$[ebp]
	add	ecx, 8
	mov	DWORD PTR __Dest$[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	add	edx, 8
	mov	DWORD PTR __First$[ebp], edx
$LN6@Uninit_cop@2:
	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Uninit_cop@2

; 131  : 		_Al.construct(_Dest, *_First);

	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?construct@?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@QAEXPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@ABU345@@Z ; std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T>::construct
	jmp	SHORT $LN5@Uninit_cop@2
$LN4@Uninit_cop@2:
	jmp	SHORT $LN10@Uninit_cop@2
__catch$??$_Uninit_copy@PBUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PBU123@0PAU123@AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 132  : 	_CATCH_ALL
; 133  : 	for (; _Next != _Dest; ++_Next)

	jmp	SHORT $LN3@Uninit_cop@2
$LN2@Uninit_cop@2:
	mov	eax, DWORD PTR __Next$[ebp]
	add	eax, 8
	mov	DWORD PTR __Next$[ebp], eax
$LN3@Uninit_cop@2:
	mov	ecx, DWORD PTR __Next$[ebp]
	cmp	ecx, DWORD PTR __Dest$[ebp]
	je	SHORT $LN1@Uninit_cop@2

; 134  : 		_Al.destroy(_Next);

	mov	edx, DWORD PTR __Next$[ebp]
	push	edx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?destroy@?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@QAEXPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@Z ; std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T>::destroy
	jmp	SHORT $LN2@Uninit_cop@2
$LN1@Uninit_cop@2:

; 135  : 	_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 136  : 	_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$??$_Uninit_copy@PBUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PBU123@0PAU123@AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1
	ret	0
$LN10@Uninit_cop@2:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Uninit_copy@PBUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PBU123@0PAU123@AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1:

; 137  : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[ebp]
$LN9@Uninit_cop@2:

; 138  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_copy@PBUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PBU123@0PAU123@AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_copy@PBUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PBU123@0PAU123@AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_copy@PBUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PBU123@0PAU123@AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<Ogre::KeyFrameArray<float>::KEYFRAME_T const *,Ogre::KeyFrameArray<float>::KEYFRAME_T *,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >
PUBLIC	??$_Checked_base@V?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@AAV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >,std::_Different_checked_iterator_base_type_tag>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Checked_base@V?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@@std@@YAPBUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@AAV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@0@@Z
_TEXT	SEGMENT
__Base_tag$ = -1					; size = 1
__It$ = 8						; size = 4
??$_Checked_base@V?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@@std@@YAPBUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@AAV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@0@@Z PROC ; std::_Checked_base<std::_Vector_const_iterator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> > >, COMDAT

; 1163 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1164 : 		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
; 1165 : 		return _Checked_base(_It, _Base_tag);

	movzx	eax, BYTE PTR __Base_tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR __It$[ebp]
	push	ecx
	call	??$_Checked_base@V?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@AAV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >,std::_Different_checked_iterator_base_type_tag>
	add	esp, 8

; 1166 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Checked_base@V?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@@std@@YAPBUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@AAV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@0@@Z ENDP ; std::_Checked_base<std::_Vector_const_iterator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> > >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@V?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@PAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@0@AAPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@V?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@PAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@0@AAPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@Z PROC ; std::_Ptr_cat<std::_Vector_const_iterator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >,Ogre::KeyFrameArray<float>::CONTROL_POINT_T *>, COMDAT

; 1509 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 1512 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Ptr_cat@V?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@PAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@0@AAPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@Z ENDP ; std::_Ptr_cat<std::_Vector_const_iterator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >,Ogre::KeyFrameArray<float>::CONTROL_POINT_T *>
_TEXT	ENDS
PUBLIC	?construct@?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@QAEXPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@ABU345@@Z ; std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T>::construct
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	SEGMENT
__catchsym$??$_Uninit_copy@PBUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PBU123@0PAU123@AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_copy@PBUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PBU123@0PAU123@AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__unwindtable$??$_Uninit_copy@PBUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PBU123@0PAU123@AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Uninit_copy@PBUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PBU123@0PAU123@AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_copy@PBUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PBU123@0PAU123@AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2
__ehfuncinfo$??$_Uninit_copy@PBUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PBU123@0PAU123@AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Uninit_copy@PBUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PBU123@0PAU123@AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_copy@PBUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PBU123@0PAU123@AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??$_Uninit_copy@PBUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PBU123@0PAU123@AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PBUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PBU123@0PAU123@AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<Ogre::KeyFrameArray<float>::CONTROL_POINT_T const *,Ogre::KeyFrameArray<float>::CONTROL_POINT_T *,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >, COMDAT

; 124  : 	{	// copy [_First, _Last) to raw _Dest, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_copy@PBUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PBU123@0PAU123@AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 125  : 	_DEBUG_RANGE(_First, _Last);
; 126  : 	_DEBUG_POINTER(_Dest);
; 127  : 	_FwdIt _Next = _Dest;

	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Next$[ebp], eax

; 128  : 
; 129  : 	_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 130  : 	for (; _First != _Last; ++_Dest, ++_First)

	jmp	SHORT $LN6@Uninit_cop@3
$LN5@Uninit_cop@3:
	mov	ecx, DWORD PTR __Dest$[ebp]
	add	ecx, 8
	mov	DWORD PTR __Dest$[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	add	edx, 8
	mov	DWORD PTR __First$[ebp], edx
$LN6@Uninit_cop@3:
	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Uninit_cop@3

; 131  : 		_Al.construct(_Dest, *_First);

	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?construct@?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@QAEXPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@ABU345@@Z ; std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T>::construct
	jmp	SHORT $LN5@Uninit_cop@3
$LN4@Uninit_cop@3:
	jmp	SHORT $LN10@Uninit_cop@3
__catch$??$_Uninit_copy@PBUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PBU123@0PAU123@AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 132  : 	_CATCH_ALL
; 133  : 	for (; _Next != _Dest; ++_Next)

	jmp	SHORT $LN3@Uninit_cop@3
$LN2@Uninit_cop@3:
	mov	eax, DWORD PTR __Next$[ebp]
	add	eax, 8
	mov	DWORD PTR __Next$[ebp], eax
$LN3@Uninit_cop@3:
	mov	ecx, DWORD PTR __Next$[ebp]
	cmp	ecx, DWORD PTR __Dest$[ebp]
	je	SHORT $LN1@Uninit_cop@3

; 134  : 		_Al.destroy(_Next);

	mov	edx, DWORD PTR __Next$[ebp]
	push	edx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?destroy@?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@QAEXPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@Z ; std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T>::destroy
	jmp	SHORT $LN2@Uninit_cop@3
$LN1@Uninit_cop@3:

; 135  : 	_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 136  : 	_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$??$_Uninit_copy@PBUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PBU123@0PAU123@AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1
	ret	0
$LN10@Uninit_cop@3:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Uninit_copy@PBUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PBU123@0PAU123@AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1:

; 137  : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[ebp]
$LN9@Uninit_cop@3:

; 138  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_copy@PBUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PBU123@0PAU123@AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_copy@PBUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PBU123@0PAU123@AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_copy@PBUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PBU123@0PAU123@AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<Ogre::KeyFrameArray<float>::CONTROL_POINT_T const *,Ogre::KeyFrameArray<float>::CONTROL_POINT_T *,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >
PUBLIC	??$_Checked_base@V?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@AAV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >,std::_Different_checked_iterator_base_type_tag>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Checked_base@V?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@@std@@YAPBUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@AAV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@0@@Z
_TEXT	SEGMENT
__Base_tag$ = -1					; size = 1
__It$ = 8						; size = 4
??$_Checked_base@V?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@@std@@YAPBUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@AAV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@0@@Z PROC ; std::_Checked_base<std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> > >, COMDAT

; 1163 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1164 : 		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
; 1165 : 		return _Checked_base(_It, _Base_tag);

	movzx	eax, BYTE PTR __Base_tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR __It$[ebp]
	push	ecx
	call	??$_Checked_base@V?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@AAV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >,std::_Different_checked_iterator_base_type_tag>
	add	esp, 8

; 1166 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Checked_base@V?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@@std@@YAPBUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@AAV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@0@@Z ENDP ; std::_Checked_base<std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> > >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@V?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@PAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@0@AAPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@V?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@PAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@0@AAPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@Z PROC ; std::_Ptr_cat<std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >,Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T *>, COMDAT

; 1509 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 1512 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Ptr_cat@V?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@PAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@0@AAPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@Z ENDP ; std::_Ptr_cat<std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >,Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T *>
_TEXT	ENDS
PUBLIC	?construct@?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@QAEXPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@ABU345@@Z ; std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T>::construct
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	SEGMENT
__catchsym$??$_Uninit_copy@PBUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PBU123@0PAU123@AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_copy@PBUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PBU123@0PAU123@AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__unwindtable$??$_Uninit_copy@PBUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PBU123@0PAU123@AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Uninit_copy@PBUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PBU123@0PAU123@AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_copy@PBUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PBU123@0PAU123@AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2
__ehfuncinfo$??$_Uninit_copy@PBUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PBU123@0PAU123@AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Uninit_copy@PBUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PBU123@0PAU123@AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_copy@PBUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PBU123@0PAU123@AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??$_Uninit_copy@PBUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PBU123@0PAU123@AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PBUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PBU123@0PAU123@AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T const *,Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T *,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >, COMDAT

; 124  : 	{	// copy [_First, _Last) to raw _Dest, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_copy@PBUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PBU123@0PAU123@AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 125  : 	_DEBUG_RANGE(_First, _Last);
; 126  : 	_DEBUG_POINTER(_Dest);
; 127  : 	_FwdIt _Next = _Dest;

	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Next$[ebp], eax

; 128  : 
; 129  : 	_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 130  : 	for (; _First != _Last; ++_Dest, ++_First)

	jmp	SHORT $LN6@Uninit_cop@4
$LN5@Uninit_cop@4:
	mov	ecx, DWORD PTR __Dest$[ebp]
	add	ecx, 20					; 00000014H
	mov	DWORD PTR __Dest$[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	add	edx, 20					; 00000014H
	mov	DWORD PTR __First$[ebp], edx
$LN6@Uninit_cop@4:
	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Uninit_cop@4

; 131  : 		_Al.construct(_Dest, *_First);

	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?construct@?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@QAEXPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@ABU345@@Z ; std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T>::construct
	jmp	SHORT $LN5@Uninit_cop@4
$LN4@Uninit_cop@4:
	jmp	SHORT $LN10@Uninit_cop@4
__catch$??$_Uninit_copy@PBUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PBU123@0PAU123@AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 132  : 	_CATCH_ALL
; 133  : 	for (; _Next != _Dest; ++_Next)

	jmp	SHORT $LN3@Uninit_cop@4
$LN2@Uninit_cop@4:
	mov	eax, DWORD PTR __Next$[ebp]
	add	eax, 20					; 00000014H
	mov	DWORD PTR __Next$[ebp], eax
$LN3@Uninit_cop@4:
	mov	ecx, DWORD PTR __Next$[ebp]
	cmp	ecx, DWORD PTR __Dest$[ebp]
	je	SHORT $LN1@Uninit_cop@4

; 134  : 		_Al.destroy(_Next);

	mov	edx, DWORD PTR __Next$[ebp]
	push	edx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?destroy@?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@QAEXPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@Z ; std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T>::destroy
	jmp	SHORT $LN2@Uninit_cop@4
$LN1@Uninit_cop@4:

; 135  : 	_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 136  : 	_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$??$_Uninit_copy@PBUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PBU123@0PAU123@AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1
	ret	0
$LN10@Uninit_cop@4:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Uninit_copy@PBUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PBU123@0PAU123@AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1:

; 137  : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[ebp]
$LN9@Uninit_cop@4:

; 138  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_copy@PBUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PBU123@0PAU123@AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_copy@PBUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PBU123@0PAU123@AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_copy@PBUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PBU123@0PAU123@AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T const *,Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T *,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >
PUBLIC	??$_Checked_base@V?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@AAV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >,std::_Different_checked_iterator_base_type_tag>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Checked_base@V?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@@std@@YAPBUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@AAV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@0@@Z
_TEXT	SEGMENT
__Base_tag$ = -1					; size = 1
__It$ = 8						; size = 4
??$_Checked_base@V?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@@std@@YAPBUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@AAV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@0@@Z PROC ; std::_Checked_base<std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> > >, COMDAT

; 1163 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1164 : 		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
; 1165 : 		return _Checked_base(_It, _Base_tag);

	movzx	eax, BYTE PTR __Base_tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR __It$[ebp]
	push	ecx
	call	??$_Checked_base@V?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@AAV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >,std::_Different_checked_iterator_base_type_tag>
	add	esp, 8

; 1166 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Checked_base@V?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@@std@@YAPBUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@AAV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@0@@Z ENDP ; std::_Checked_base<std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> > >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@V?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@PAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@0@AAPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@V?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@PAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@0@AAPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@Z PROC ; std::_Ptr_cat<std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >,Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T *>, COMDAT

; 1509 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 1512 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Ptr_cat@V?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@PAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@0@AAPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@Z ENDP ; std::_Ptr_cat<std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >,Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T *>
_TEXT	ENDS
PUBLIC	?construct@?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@QAEXPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@ABU345@@Z ; std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T>::construct
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	SEGMENT
__catchsym$??$_Uninit_copy@PBUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PBU123@0PAU123@AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_copy@PBUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PBU123@0PAU123@AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__unwindtable$??$_Uninit_copy@PBUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PBU123@0PAU123@AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Uninit_copy@PBUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PBU123@0PAU123@AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_copy@PBUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PBU123@0PAU123@AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2
__ehfuncinfo$??$_Uninit_copy@PBUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PBU123@0PAU123@AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Uninit_copy@PBUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PBU123@0PAU123@AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_copy@PBUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PBU123@0PAU123@AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??$_Uninit_copy@PBUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PBU123@0PAU123@AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PBUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PBU123@0PAU123@AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T const *,Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T *,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >, COMDAT

; 124  : 	{	// copy [_First, _Last) to raw _Dest, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_copy@PBUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PBU123@0PAU123@AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 125  : 	_DEBUG_RANGE(_First, _Last);
; 126  : 	_DEBUG_POINTER(_Dest);
; 127  : 	_FwdIt _Next = _Dest;

	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Next$[ebp], eax

; 128  : 
; 129  : 	_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 130  : 	for (; _First != _Last; ++_Dest, ++_First)

	jmp	SHORT $LN6@Uninit_cop@5
$LN5@Uninit_cop@5:
	mov	ecx, DWORD PTR __Dest$[ebp]
	add	ecx, 32					; 00000020H
	mov	DWORD PTR __Dest$[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	add	edx, 32					; 00000020H
	mov	DWORD PTR __First$[ebp], edx
$LN6@Uninit_cop@5:
	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Uninit_cop@5

; 131  : 		_Al.construct(_Dest, *_First);

	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?construct@?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@QAEXPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@ABU345@@Z ; std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T>::construct
	jmp	SHORT $LN5@Uninit_cop@5
$LN4@Uninit_cop@5:
	jmp	SHORT $LN10@Uninit_cop@5
__catch$??$_Uninit_copy@PBUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PBU123@0PAU123@AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 132  : 	_CATCH_ALL
; 133  : 	for (; _Next != _Dest; ++_Next)

	jmp	SHORT $LN3@Uninit_cop@5
$LN2@Uninit_cop@5:
	mov	eax, DWORD PTR __Next$[ebp]
	add	eax, 32					; 00000020H
	mov	DWORD PTR __Next$[ebp], eax
$LN3@Uninit_cop@5:
	mov	ecx, DWORD PTR __Next$[ebp]
	cmp	ecx, DWORD PTR __Dest$[ebp]
	je	SHORT $LN1@Uninit_cop@5

; 134  : 		_Al.destroy(_Next);

	mov	edx, DWORD PTR __Next$[ebp]
	push	edx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?destroy@?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@QAEXPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@Z ; std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T>::destroy
	jmp	SHORT $LN2@Uninit_cop@5
$LN1@Uninit_cop@5:

; 135  : 	_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 136  : 	_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$??$_Uninit_copy@PBUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PBU123@0PAU123@AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1
	ret	0
$LN10@Uninit_cop@5:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Uninit_copy@PBUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PBU123@0PAU123@AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1:

; 137  : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[ebp]
$LN9@Uninit_cop@5:

; 138  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_copy@PBUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PBU123@0PAU123@AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_copy@PBUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PBU123@0PAU123@AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_copy@PBUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PBU123@0PAU123@AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T const *,Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T *,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >
PUBLIC	??$_Checked_base@V?$_Vector_const_iterator@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBQAVShaderContext@Ogre@@AAV?$_Vector_const_iterator@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::ShaderContext *,std::allocator<Ogre::ShaderContext *> >,std::_Different_checked_iterator_base_type_tag>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Checked_base@V?$_Vector_const_iterator@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@@std@@YAPBQAVShaderContext@Ogre@@AAV?$_Vector_const_iterator@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@0@@Z
_TEXT	SEGMENT
__Base_tag$ = -1					; size = 1
__It$ = 8						; size = 4
??$_Checked_base@V?$_Vector_const_iterator@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@@std@@YAPBQAVShaderContext@Ogre@@AAV?$_Vector_const_iterator@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@0@@Z PROC ; std::_Checked_base<std::_Vector_const_iterator<Ogre::ShaderContext *,std::allocator<Ogre::ShaderContext *> > >, COMDAT

; 1163 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1164 : 		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
; 1165 : 		return _Checked_base(_It, _Base_tag);

	movzx	eax, BYTE PTR __Base_tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR __It$[ebp]
	push	ecx
	call	??$_Checked_base@V?$_Vector_const_iterator@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBQAVShaderContext@Ogre@@AAV?$_Vector_const_iterator@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::ShaderContext *,std::allocator<Ogre::ShaderContext *> >,std::_Different_checked_iterator_base_type_tag>
	add	esp, 8

; 1166 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Checked_base@V?$_Vector_const_iterator@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@@std@@YAPBQAVShaderContext@Ogre@@AAV?$_Vector_const_iterator@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@0@@Z ENDP ; std::_Checked_base<std::_Vector_const_iterator<Ogre::ShaderContext *,std::allocator<Ogre::ShaderContext *> > >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@V?$_Vector_const_iterator@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@PAPAVShaderContext@Ogre@@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@0@AAPAPAVShaderContext@Ogre@@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@V?$_Vector_const_iterator@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@PAPAVShaderContext@Ogre@@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@0@AAPAPAVShaderContext@Ogre@@@Z PROC ; std::_Ptr_cat<std::_Vector_const_iterator<Ogre::ShaderContext *,std::allocator<Ogre::ShaderContext *> >,Ogre::ShaderContext * *>, COMDAT

; 1509 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 1512 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Ptr_cat@V?$_Vector_const_iterator@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@PAPAVShaderContext@Ogre@@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@0@AAPAPAVShaderContext@Ogre@@@Z ENDP ; std::_Ptr_cat<std::_Vector_const_iterator<Ogre::ShaderContext *,std::allocator<Ogre::ShaderContext *> >,Ogre::ShaderContext * *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@PBQAVShaderContext@Ogre@@PAPAV12@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@YAPAPAVShaderContext@Ogre@@PBQAV12@0PAPAV12@AAV?$allocator@PAVShaderContext@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Result$ = -8						; size = 4
__Count$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PBQAVShaderContext@Ogre@@PAPAV12@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@YAPAPAVShaderContext@Ogre@@PBQAV12@0PAPAV12@AAV?$allocator@PAVShaderContext@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<Ogre::ShaderContext * const *,Ogre::ShaderContext * *,std::allocator<Ogre::ShaderContext *> >, COMDAT

; 145  : 	{	// copy [_First, _Last) to raw _Dest, scalar type

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 146  : 	_DEBUG_RANGE(_First, _Last);
; 147  : 	_DEBUG_POINTER(_Dest);
; 148  : 	size_t _Count = (size_t)(_Last - _First);

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 2
	mov	DWORD PTR __Count$[ebp], eax

; 149  : 	_FwdIt _Result = _Dest + _Count;

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Dest$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR __Result$[ebp], eax

; 150  : 	if (_Count > 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN1@Uninit_cop@6

; 151  : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Count * sizeof (*_First), &*_First, _Count * sizeof (*_First));	// NB: non-overlapping move

	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN1@Uninit_cop@6:

; 152  : 	return (_Result);

	mov	eax, DWORD PTR __Result$[ebp]

; 153  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Uninit_copy@PBQAVShaderContext@Ogre@@PAPAV12@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@YAPAPAVShaderContext@Ogre@@PBQAV12@0PAPAV12@AAV?$allocator@PAVShaderContext@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<Ogre::ShaderContext * const *,Ogre::ShaderContext * *,std::allocator<Ogre::ShaderContext *> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Checked_base@PAPAVShaderContext@Ogre@@@std@@YAPAPAVShaderContext@Ogre@@AAPAPAV12@U_Unchanged_checked_iterator_base_type_tag@0@@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Checked_base@PAPAVShaderContext@Ogre@@@std@@YAPAPAVShaderContext@Ogre@@AAPAPAV12@U_Unchanged_checked_iterator_base_type_tag@0@@Z PROC ; std::_Checked_base<Ogre::ShaderContext * *>, COMDAT

; 1146 : 	{

	push	ebp
	mov	ebp, esp

; 1147 : 		return _It;

	mov	eax, DWORD PTR __It$[ebp]
	mov	eax, DWORD PTR [eax]

; 1148 : 	}

	pop	ebp
	ret	0
??$_Checked_base@PAPAVShaderContext@Ogre@@@std@@YAPAPAVShaderContext@Ogre@@AAPAPAV12@U_Unchanged_checked_iterator_base_type_tag@0@@Z ENDP ; std::_Checked_base<Ogre::ShaderContext * *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@PAPAVShaderContext@Ogre@@PAPAV12@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@YAPAPAVShaderContext@Ogre@@PAPAV12@00AAV?$allocator@PAVShaderContext@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Result$ = -8						; size = 4
__Count$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PAPAVShaderContext@Ogre@@PAPAV12@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@YAPAPAVShaderContext@Ogre@@PAPAV12@00AAV?$allocator@PAVShaderContext@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<Ogre::ShaderContext * *,Ogre::ShaderContext * *,std::allocator<Ogre::ShaderContext *> >, COMDAT

; 145  : 	{	// copy [_First, _Last) to raw _Dest, scalar type

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 146  : 	_DEBUG_RANGE(_First, _Last);
; 147  : 	_DEBUG_POINTER(_Dest);
; 148  : 	size_t _Count = (size_t)(_Last - _First);

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 2
	mov	DWORD PTR __Count$[ebp], eax

; 149  : 	_FwdIt _Result = _Dest + _Count;

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Dest$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR __Result$[ebp], eax

; 150  : 	if (_Count > 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN1@Uninit_cop@7

; 151  : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Count * sizeof (*_First), &*_First, _Count * sizeof (*_First));	// NB: non-overlapping move

	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN1@Uninit_cop@7:

; 152  : 	return (_Result);

	mov	eax, DWORD PTR __Result$[ebp]

; 153  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Uninit_copy@PAPAVShaderContext@Ogre@@PAPAV12@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@YAPAPAVShaderContext@Ogre@@PAPAV12@00AAV?$allocator@PAVShaderContext@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<Ogre::ShaderContext * *,Ogre::ShaderContext * *,std::allocator<Ogre::ShaderContext *> >
_TEXT	ENDS
PUBLIC	??$_Checked_base@V?$_Vector_const_iterator@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBUContextQueDesc@Ogre@@AAV?$_Vector_const_iterator@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::ContextQueDesc,std::allocator<Ogre::ContextQueDesc> >,std::_Different_checked_iterator_base_type_tag>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Checked_base@V?$_Vector_const_iterator@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@@std@@YAPBUContextQueDesc@Ogre@@AAV?$_Vector_const_iterator@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@0@@Z
_TEXT	SEGMENT
__Base_tag$ = -1					; size = 1
__It$ = 8						; size = 4
??$_Checked_base@V?$_Vector_const_iterator@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@@std@@YAPBUContextQueDesc@Ogre@@AAV?$_Vector_const_iterator@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@0@@Z PROC ; std::_Checked_base<std::_Vector_const_iterator<Ogre::ContextQueDesc,std::allocator<Ogre::ContextQueDesc> > >, COMDAT

; 1163 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1164 : 		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
; 1165 : 		return _Checked_base(_It, _Base_tag);

	movzx	eax, BYTE PTR __Base_tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR __It$[ebp]
	push	ecx
	call	??$_Checked_base@V?$_Vector_const_iterator@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBUContextQueDesc@Ogre@@AAV?$_Vector_const_iterator@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::ContextQueDesc,std::allocator<Ogre::ContextQueDesc> >,std::_Different_checked_iterator_base_type_tag>
	add	esp, 8

; 1166 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Checked_base@V?$_Vector_const_iterator@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@@std@@YAPBUContextQueDesc@Ogre@@AAV?$_Vector_const_iterator@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@0@@Z ENDP ; std::_Checked_base<std::_Vector_const_iterator<Ogre::ContextQueDesc,std::allocator<Ogre::ContextQueDesc> > >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@V?$_Vector_const_iterator@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@PAUContextQueDesc@Ogre@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@0@AAPAUContextQueDesc@Ogre@@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@V?$_Vector_const_iterator@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@PAUContextQueDesc@Ogre@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@0@AAPAUContextQueDesc@Ogre@@@Z PROC ; std::_Ptr_cat<std::_Vector_const_iterator<Ogre::ContextQueDesc,std::allocator<Ogre::ContextQueDesc> >,Ogre::ContextQueDesc *>, COMDAT

; 1509 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 1512 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Ptr_cat@V?$_Vector_const_iterator@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@PAUContextQueDesc@Ogre@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@0@AAPAUContextQueDesc@Ogre@@@Z ENDP ; std::_Ptr_cat<std::_Vector_const_iterator<Ogre::ContextQueDesc,std::allocator<Ogre::ContextQueDesc> >,Ogre::ContextQueDesc *>
_TEXT	ENDS
PUBLIC	?construct@?$allocator@UContextQueDesc@Ogre@@@std@@QAEXPAUContextQueDesc@Ogre@@ABU34@@Z ; std::allocator<Ogre::ContextQueDesc>::construct
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	SEGMENT
__catchsym$??$_Uninit_copy@PBUContextQueDesc@Ogre@@PAU12@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@YAPAUContextQueDesc@Ogre@@PBU12@0PAU12@AAV?$allocator@UContextQueDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_copy@PBUContextQueDesc@Ogre@@PAU12@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@YAPAUContextQueDesc@Ogre@@PBU12@0PAU12@AAV?$allocator@UContextQueDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__unwindtable$??$_Uninit_copy@PBUContextQueDesc@Ogre@@PAU12@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@YAPAUContextQueDesc@Ogre@@PBU12@0PAU12@AAV?$allocator@UContextQueDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Uninit_copy@PBUContextQueDesc@Ogre@@PAU12@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@YAPAUContextQueDesc@Ogre@@PBU12@0PAU12@AAV?$allocator@UContextQueDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_copy@PBUContextQueDesc@Ogre@@PAU12@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@YAPAUContextQueDesc@Ogre@@PBU12@0PAU12@AAV?$allocator@UContextQueDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2
__ehfuncinfo$??$_Uninit_copy@PBUContextQueDesc@Ogre@@PAU12@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@YAPAUContextQueDesc@Ogre@@PBU12@0PAU12@AAV?$allocator@UContextQueDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Uninit_copy@PBUContextQueDesc@Ogre@@PAU12@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@YAPAUContextQueDesc@Ogre@@PBU12@0PAU12@AAV?$allocator@UContextQueDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_copy@PBUContextQueDesc@Ogre@@PAU12@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@YAPAUContextQueDesc@Ogre@@PBU12@0PAU12@AAV?$allocator@UContextQueDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??$_Uninit_copy@PBUContextQueDesc@Ogre@@PAU12@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@YAPAUContextQueDesc@Ogre@@PBU12@0PAU12@AAV?$allocator@UContextQueDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PBUContextQueDesc@Ogre@@PAU12@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@YAPAUContextQueDesc@Ogre@@PBU12@0PAU12@AAV?$allocator@UContextQueDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<Ogre::ContextQueDesc const *,Ogre::ContextQueDesc *,std::allocator<Ogre::ContextQueDesc> >, COMDAT

; 124  : 	{	// copy [_First, _Last) to raw _Dest, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_copy@PBUContextQueDesc@Ogre@@PAU12@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@YAPAUContextQueDesc@Ogre@@PBU12@0PAU12@AAV?$allocator@UContextQueDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 125  : 	_DEBUG_RANGE(_First, _Last);
; 126  : 	_DEBUG_POINTER(_Dest);
; 127  : 	_FwdIt _Next = _Dest;

	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Next$[ebp], eax

; 128  : 
; 129  : 	_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 130  : 	for (; _First != _Last; ++_Dest, ++_First)

	jmp	SHORT $LN6@Uninit_cop@8
$LN5@Uninit_cop@8:
	mov	ecx, DWORD PTR __Dest$[ebp]
	add	ecx, 156				; 0000009cH
	mov	DWORD PTR __Dest$[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	add	edx, 156				; 0000009cH
	mov	DWORD PTR __First$[ebp], edx
$LN6@Uninit_cop@8:
	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Uninit_cop@8

; 131  : 		_Al.construct(_Dest, *_First);

	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?construct@?$allocator@UContextQueDesc@Ogre@@@std@@QAEXPAUContextQueDesc@Ogre@@ABU34@@Z ; std::allocator<Ogre::ContextQueDesc>::construct
	jmp	SHORT $LN5@Uninit_cop@8
$LN4@Uninit_cop@8:
	jmp	SHORT $LN10@Uninit_cop@8
__catch$??$_Uninit_copy@PBUContextQueDesc@Ogre@@PAU12@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@YAPAUContextQueDesc@Ogre@@PBU12@0PAU12@AAV?$allocator@UContextQueDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 132  : 	_CATCH_ALL
; 133  : 	for (; _Next != _Dest; ++_Next)

	jmp	SHORT $LN3@Uninit_cop@8
$LN2@Uninit_cop@8:
	mov	eax, DWORD PTR __Next$[ebp]
	add	eax, 156				; 0000009cH
	mov	DWORD PTR __Next$[ebp], eax
$LN3@Uninit_cop@8:
	mov	ecx, DWORD PTR __Next$[ebp]
	cmp	ecx, DWORD PTR __Dest$[ebp]
	je	SHORT $LN1@Uninit_cop@8

; 134  : 		_Al.destroy(_Next);

	mov	edx, DWORD PTR __Next$[ebp]
	push	edx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?destroy@?$allocator@UContextQueDesc@Ogre@@@std@@QAEXPAUContextQueDesc@Ogre@@@Z ; std::allocator<Ogre::ContextQueDesc>::destroy
	jmp	SHORT $LN2@Uninit_cop@8
$LN1@Uninit_cop@8:

; 135  : 	_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 136  : 	_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$??$_Uninit_copy@PBUContextQueDesc@Ogre@@PAU12@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@YAPAUContextQueDesc@Ogre@@PBU12@0PAU12@AAV?$allocator@UContextQueDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1
	ret	0
$LN10@Uninit_cop@8:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Uninit_copy@PBUContextQueDesc@Ogre@@PAU12@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@YAPAUContextQueDesc@Ogre@@PBU12@0PAU12@AAV?$allocator@UContextQueDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1:

; 137  : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[ebp]
$LN9@Uninit_cop@8:

; 138  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_copy@PBUContextQueDesc@Ogre@@PAU12@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@YAPAUContextQueDesc@Ogre@@PBU12@0PAU12@AAV?$allocator@UContextQueDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_copy@PBUContextQueDesc@Ogre@@PAU12@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@YAPAUContextQueDesc@Ogre@@PBU12@0PAU12@AAV?$allocator@UContextQueDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_copy@PBUContextQueDesc@Ogre@@PAU12@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@YAPAUContextQueDesc@Ogre@@PBU12@0PAU12@AAV?$allocator@UContextQueDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<Ogre::ContextQueDesc const *,Ogre::ContextQueDesc *,std::allocator<Ogre::ContextQueDesc> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Checked_base@PAUContextQueDesc@Ogre@@@std@@YAPAUContextQueDesc@Ogre@@AAPAU12@U_Unchanged_checked_iterator_base_type_tag@0@@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Checked_base@PAUContextQueDesc@Ogre@@@std@@YAPAUContextQueDesc@Ogre@@AAPAU12@U_Unchanged_checked_iterator_base_type_tag@0@@Z PROC ; std::_Checked_base<Ogre::ContextQueDesc *>, COMDAT

; 1146 : 	{

	push	ebp
	mov	ebp, esp

; 1147 : 		return _It;

	mov	eax, DWORD PTR __It$[ebp]
	mov	eax, DWORD PTR [eax]

; 1148 : 	}

	pop	ebp
	ret	0
??$_Checked_base@PAUContextQueDesc@Ogre@@@std@@YAPAUContextQueDesc@Ogre@@AAPAU12@U_Unchanged_checked_iterator_base_type_tag@0@@Z ENDP ; std::_Checked_base<Ogre::ContextQueDesc *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Copy_opt@PAUContextQueDesc@Ogre@@PAU12@Uforward_iterator_tag@std@@@std@@YAPAUContextQueDesc@Ogre@@PAU12@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAUContextQueDesc@Ogre@@PAU12@Uforward_iterator_tag@std@@@std@@YAPAUContextQueDesc@Ogre@@PAU12@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<Ogre::ContextQueDesc *,Ogre::ContextQueDesc *,std::forward_iterator_tag>, COMDAT

; 2469 : 	{	// copy [_First, _Last) to [_Dest, ...), arbitrary iterators

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi

; 2470 : 	_DEBUG_RANGE(_First, _Last);
; 2471 : 	for (; _First != _Last; ++_Dest, ++_First)

	jmp	SHORT $LN3@Copy_opt@11
$LN2@Copy_opt@11:
	mov	eax, DWORD PTR __Dest$[ebp]
	add	eax, 156				; 0000009cH
	mov	DWORD PTR __Dest$[ebp], eax
	mov	ecx, DWORD PTR __First$[ebp]
	add	ecx, 156				; 0000009cH
	mov	DWORD PTR __First$[ebp], ecx
$LN3@Copy_opt@11:
	mov	edx, DWORD PTR __First$[ebp]
	cmp	edx, DWORD PTR __Last$[ebp]
	je	SHORT $LN1@Copy_opt@11

; 2472 : 		*_Dest = *_First;

	mov	esi, DWORD PTR __First$[ebp]
	mov	ecx, 39					; 00000027H
	mov	edi, DWORD PTR __Dest$[ebp]
	rep movsd
	jmp	SHORT $LN2@Copy_opt@11
$LN1@Copy_opt@11:

; 2473 : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[ebp]

; 2474 : 	}

	pop	edi
	pop	esi
	pop	ebp
	ret	0
??$_Copy_opt@PAUContextQueDesc@Ogre@@PAU12@Uforward_iterator_tag@std@@@std@@YAPAUContextQueDesc@Ogre@@PAU12@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<Ogre::ContextQueDesc *,Ogre::ContextQueDesc *,std::forward_iterator_tag>
_TEXT	ENDS
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	SEGMENT
__catchsym$??$_Uninit_copy@PAUContextQueDesc@Ogre@@PAU12@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@YAPAUContextQueDesc@Ogre@@PAU12@00AAV?$allocator@UContextQueDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_copy@PAUContextQueDesc@Ogre@@PAU12@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@YAPAUContextQueDesc@Ogre@@PAU12@00AAV?$allocator@UContextQueDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__unwindtable$??$_Uninit_copy@PAUContextQueDesc@Ogre@@PAU12@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@YAPAUContextQueDesc@Ogre@@PAU12@00AAV?$allocator@UContextQueDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Uninit_copy@PAUContextQueDesc@Ogre@@PAU12@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@YAPAUContextQueDesc@Ogre@@PAU12@00AAV?$allocator@UContextQueDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_copy@PAUContextQueDesc@Ogre@@PAU12@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@YAPAUContextQueDesc@Ogre@@PAU12@00AAV?$allocator@UContextQueDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2
__ehfuncinfo$??$_Uninit_copy@PAUContextQueDesc@Ogre@@PAU12@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@YAPAUContextQueDesc@Ogre@@PAU12@00AAV?$allocator@UContextQueDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Uninit_copy@PAUContextQueDesc@Ogre@@PAU12@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@YAPAUContextQueDesc@Ogre@@PAU12@00AAV?$allocator@UContextQueDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_copy@PAUContextQueDesc@Ogre@@PAU12@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@YAPAUContextQueDesc@Ogre@@PAU12@00AAV?$allocator@UContextQueDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??$_Uninit_copy@PAUContextQueDesc@Ogre@@PAU12@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@YAPAUContextQueDesc@Ogre@@PAU12@00AAV?$allocator@UContextQueDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PAUContextQueDesc@Ogre@@PAU12@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@YAPAUContextQueDesc@Ogre@@PAU12@00AAV?$allocator@UContextQueDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<Ogre::ContextQueDesc *,Ogre::ContextQueDesc *,std::allocator<Ogre::ContextQueDesc> >, COMDAT

; 124  : 	{	// copy [_First, _Last) to raw _Dest, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_copy@PAUContextQueDesc@Ogre@@PAU12@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@YAPAUContextQueDesc@Ogre@@PAU12@00AAV?$allocator@UContextQueDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 125  : 	_DEBUG_RANGE(_First, _Last);
; 126  : 	_DEBUG_POINTER(_Dest);
; 127  : 	_FwdIt _Next = _Dest;

	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Next$[ebp], eax

; 128  : 
; 129  : 	_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 130  : 	for (; _First != _Last; ++_Dest, ++_First)

	jmp	SHORT $LN6@Uninit_cop@9
$LN5@Uninit_cop@9:
	mov	ecx, DWORD PTR __Dest$[ebp]
	add	ecx, 156				; 0000009cH
	mov	DWORD PTR __Dest$[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	add	edx, 156				; 0000009cH
	mov	DWORD PTR __First$[ebp], edx
$LN6@Uninit_cop@9:
	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Uninit_cop@9

; 131  : 		_Al.construct(_Dest, *_First);

	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?construct@?$allocator@UContextQueDesc@Ogre@@@std@@QAEXPAUContextQueDesc@Ogre@@ABU34@@Z ; std::allocator<Ogre::ContextQueDesc>::construct
	jmp	SHORT $LN5@Uninit_cop@9
$LN4@Uninit_cop@9:
	jmp	SHORT $LN10@Uninit_cop@9
__catch$??$_Uninit_copy@PAUContextQueDesc@Ogre@@PAU12@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@YAPAUContextQueDesc@Ogre@@PAU12@00AAV?$allocator@UContextQueDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 132  : 	_CATCH_ALL
; 133  : 	for (; _Next != _Dest; ++_Next)

	jmp	SHORT $LN3@Uninit_cop@9
$LN2@Uninit_cop@9:
	mov	eax, DWORD PTR __Next$[ebp]
	add	eax, 156				; 0000009cH
	mov	DWORD PTR __Next$[ebp], eax
$LN3@Uninit_cop@9:
	mov	ecx, DWORD PTR __Next$[ebp]
	cmp	ecx, DWORD PTR __Dest$[ebp]
	je	SHORT $LN1@Uninit_cop@9

; 134  : 		_Al.destroy(_Next);

	mov	edx, DWORD PTR __Next$[ebp]
	push	edx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?destroy@?$allocator@UContextQueDesc@Ogre@@@std@@QAEXPAUContextQueDesc@Ogre@@@Z ; std::allocator<Ogre::ContextQueDesc>::destroy
	jmp	SHORT $LN2@Uninit_cop@9
$LN1@Uninit_cop@9:

; 135  : 	_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 136  : 	_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$??$_Uninit_copy@PAUContextQueDesc@Ogre@@PAU12@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@YAPAUContextQueDesc@Ogre@@PAU12@00AAV?$allocator@UContextQueDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1
	ret	0
$LN10@Uninit_cop@9:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Uninit_copy@PAUContextQueDesc@Ogre@@PAU12@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@YAPAUContextQueDesc@Ogre@@PAU12@00AAV?$allocator@UContextQueDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1:

; 137  : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[ebp]
$LN9@Uninit_cop@9:

; 138  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_copy@PAUContextQueDesc@Ogre@@PAU12@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@YAPAUContextQueDesc@Ogre@@PAU12@00AAV?$allocator@UContextQueDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_copy@PAUContextQueDesc@Ogre@@PAU12@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@YAPAUContextQueDesc@Ogre@@PAU12@00AAV?$allocator@UContextQueDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_copy@PAUContextQueDesc@Ogre@@PAU12@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@YAPAUContextQueDesc@Ogre@@PAU12@00AAV?$allocator@UContextQueDesc@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<Ogre::ContextQueDesc *,Ogre::ContextQueDesc *,std::allocator<Ogre::ContextQueDesc> >
PUBLIC	??$_Checked_base@V?$_Vector_const_iterator@EV?$allocator@E@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBEAAV?$_Vector_const_iterator@EV?$allocator@E@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<unsigned char,std::allocator<unsigned char> >,std::_Different_checked_iterator_base_type_tag>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Checked_base@V?$_Vector_const_iterator@EV?$allocator@E@std@@@std@@@std@@YAPBEAAV?$_Vector_const_iterator@EV?$allocator@E@std@@@0@@Z
_TEXT	SEGMENT
__Base_tag$ = -1					; size = 1
__It$ = 8						; size = 4
??$_Checked_base@V?$_Vector_const_iterator@EV?$allocator@E@std@@@std@@@std@@YAPBEAAV?$_Vector_const_iterator@EV?$allocator@E@std@@@0@@Z PROC ; std::_Checked_base<std::_Vector_const_iterator<unsigned char,std::allocator<unsigned char> > >, COMDAT

; 1163 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1164 : 		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
; 1165 : 		return _Checked_base(_It, _Base_tag);

	movzx	eax, BYTE PTR __Base_tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR __It$[ebp]
	push	ecx
	call	??$_Checked_base@V?$_Vector_const_iterator@EV?$allocator@E@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBEAAV?$_Vector_const_iterator@EV?$allocator@E@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<unsigned char,std::allocator<unsigned char> >,std::_Different_checked_iterator_base_type_tag>
	add	esp, 8

; 1166 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Checked_base@V?$_Vector_const_iterator@EV?$allocator@E@std@@@std@@@std@@YAPBEAAV?$_Vector_const_iterator@EV?$allocator@E@std@@@0@@Z ENDP ; std::_Checked_base<std::_Vector_const_iterator<unsigned char,std::allocator<unsigned char> > >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@V?$_Vector_const_iterator@EV?$allocator@E@std@@@std@@PAE@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@EV?$allocator@E@std@@@0@AAPAE@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@V?$_Vector_const_iterator@EV?$allocator@E@std@@@std@@PAE@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@EV?$allocator@E@std@@@0@AAPAE@Z PROC ; std::_Ptr_cat<std::_Vector_const_iterator<unsigned char,std::allocator<unsigned char> >,unsigned char *>, COMDAT

; 1509 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 1512 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Ptr_cat@V?$_Vector_const_iterator@EV?$allocator@E@std@@@std@@PAE@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@EV?$allocator@E@std@@@0@AAPAE@Z ENDP ; std::_Ptr_cat<std::_Vector_const_iterator<unsigned char,std::allocator<unsigned char> >,unsigned char *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@PBEPAEV?$allocator@E@std@@@std@@YAPAEPBE0PAEAAV?$allocator@E@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Result$ = -8						; size = 4
__Count$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PBEPAEV?$allocator@E@std@@@std@@YAPAEPBE0PAEAAV?$allocator@E@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<unsigned char const *,unsigned char *,std::allocator<unsigned char> >, COMDAT

; 145  : 	{	// copy [_First, _Last) to raw _Dest, scalar type

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 146  : 	_DEBUG_RANGE(_First, _Last);
; 147  : 	_DEBUG_POINTER(_Dest);
; 148  : 	size_t _Count = (size_t)(_Last - _First);

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Count$[ebp], eax

; 149  : 	_FwdIt _Result = _Dest + _Count;

	mov	ecx, DWORD PTR __Dest$[ebp]
	add	ecx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Result$[ebp], ecx

; 150  : 	if (_Count > 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN1@Uninit_cop@10

; 151  : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Count * sizeof (*_First), &*_First, _Count * sizeof (*_First));	// NB: non-overlapping move

	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN1@Uninit_cop@10:

; 152  : 	return (_Result);

	mov	eax, DWORD PTR __Result$[ebp]

; 153  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Uninit_copy@PBEPAEV?$allocator@E@std@@@std@@YAPAEPBE0PAEAAV?$allocator@E@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<unsigned char const *,unsigned char *,std::allocator<unsigned char> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Checked_base@PAE@std@@YAPAEAAPAEU_Unchanged_checked_iterator_base_type_tag@0@@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Checked_base@PAE@std@@YAPAEAAPAEU_Unchanged_checked_iterator_base_type_tag@0@@Z PROC ; std::_Checked_base<unsigned char *>, COMDAT

; 1146 : 	{

	push	ebp
	mov	ebp, esp

; 1147 : 		return _It;

	mov	eax, DWORD PTR __It$[ebp]
	mov	eax, DWORD PTR [eax]

; 1148 : 	}

	pop	ebp
	ret	0
??$_Checked_base@PAE@std@@YAPAEAAPAEU_Unchanged_checked_iterator_base_type_tag@0@@Z ENDP ; std::_Checked_base<unsigned char *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@PAEPAEV?$allocator@E@std@@@std@@YAPAEPAE00AAV?$allocator@E@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Result$ = -8						; size = 4
__Count$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PAEPAEV?$allocator@E@std@@@std@@YAPAEPAE00AAV?$allocator@E@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<unsigned char *,unsigned char *,std::allocator<unsigned char> >, COMDAT

; 145  : 	{	// copy [_First, _Last) to raw _Dest, scalar type

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 146  : 	_DEBUG_RANGE(_First, _Last);
; 147  : 	_DEBUG_POINTER(_Dest);
; 148  : 	size_t _Count = (size_t)(_Last - _First);

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Count$[ebp], eax

; 149  : 	_FwdIt _Result = _Dest + _Count;

	mov	ecx, DWORD PTR __Dest$[ebp]
	add	ecx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Result$[ebp], ecx

; 150  : 	if (_Count > 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN1@Uninit_cop@11

; 151  : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Count * sizeof (*_First), &*_First, _Count * sizeof (*_First));	// NB: non-overlapping move

	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN1@Uninit_cop@11:

; 152  : 	return (_Result);

	mov	eax, DWORD PTR __Result$[ebp]

; 153  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Uninit_copy@PAEPAEV?$allocator@E@std@@@std@@YAPAEPAE00AAV?$allocator@E@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<unsigned char *,unsigned char *,std::allocator<unsigned char> >
_TEXT	ENDS
PUBLIC	??$_Checked_base@V?$_Vector_const_iterator@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBUValueParam@ShaderContextPool@Ogre@@AAV?$_Vector_const_iterator@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::ShaderContextPool::ValueParam,std::allocator<Ogre::ShaderContextPool::ValueParam> >,std::_Different_checked_iterator_base_type_tag>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Checked_base@V?$_Vector_const_iterator@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@@std@@YAPBUValueParam@ShaderContextPool@Ogre@@AAV?$_Vector_const_iterator@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@0@@Z
_TEXT	SEGMENT
__Base_tag$ = -1					; size = 1
__It$ = 8						; size = 4
??$_Checked_base@V?$_Vector_const_iterator@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@@std@@YAPBUValueParam@ShaderContextPool@Ogre@@AAV?$_Vector_const_iterator@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@0@@Z PROC ; std::_Checked_base<std::_Vector_const_iterator<Ogre::ShaderContextPool::ValueParam,std::allocator<Ogre::ShaderContextPool::ValueParam> > >, COMDAT

; 1163 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1164 : 		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
; 1165 : 		return _Checked_base(_It, _Base_tag);

	movzx	eax, BYTE PTR __Base_tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR __It$[ebp]
	push	ecx
	call	??$_Checked_base@V?$_Vector_const_iterator@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBUValueParam@ShaderContextPool@Ogre@@AAV?$_Vector_const_iterator@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::ShaderContextPool::ValueParam,std::allocator<Ogre::ShaderContextPool::ValueParam> >,std::_Different_checked_iterator_base_type_tag>
	add	esp, 8

; 1166 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Checked_base@V?$_Vector_const_iterator@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@@std@@YAPBUValueParam@ShaderContextPool@Ogre@@AAV?$_Vector_const_iterator@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@0@@Z ENDP ; std::_Checked_base<std::_Vector_const_iterator<Ogre::ShaderContextPool::ValueParam,std::allocator<Ogre::ShaderContextPool::ValueParam> > >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@V?$_Vector_const_iterator@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@PAUValueParam@ShaderContextPool@Ogre@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@0@AAPAUValueParam@ShaderContextPool@Ogre@@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@V?$_Vector_const_iterator@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@PAUValueParam@ShaderContextPool@Ogre@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@0@AAPAUValueParam@ShaderContextPool@Ogre@@@Z PROC ; std::_Ptr_cat<std::_Vector_const_iterator<Ogre::ShaderContextPool::ValueParam,std::allocator<Ogre::ShaderContextPool::ValueParam> >,Ogre::ShaderContextPool::ValueParam *>, COMDAT

; 1509 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 1512 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Ptr_cat@V?$_Vector_const_iterator@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@PAUValueParam@ShaderContextPool@Ogre@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@0@AAPAUValueParam@ShaderContextPool@Ogre@@@Z ENDP ; std::_Ptr_cat<std::_Vector_const_iterator<Ogre::ShaderContextPool::ValueParam,std::allocator<Ogre::ShaderContextPool::ValueParam> >,Ogre::ShaderContextPool::ValueParam *>
_TEXT	ENDS
PUBLIC	?construct@?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@QAEXPAUValueParam@ShaderContextPool@Ogre@@ABU345@@Z ; std::allocator<Ogre::ShaderContextPool::ValueParam>::construct
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	SEGMENT
__catchsym$??$_Uninit_copy@PBUValueParam@ShaderContextPool@Ogre@@PAU123@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@YAPAUValueParam@ShaderContextPool@Ogre@@PBU123@0PAU123@AAV?$allocator@UValueParam@ShaderContextPool@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_copy@PBUValueParam@ShaderContextPool@Ogre@@PAU123@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@YAPAUValueParam@ShaderContextPool@Ogre@@PBU123@0PAU123@AAV?$allocator@UValueParam@ShaderContextPool@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__unwindtable$??$_Uninit_copy@PBUValueParam@ShaderContextPool@Ogre@@PAU123@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@YAPAUValueParam@ShaderContextPool@Ogre@@PBU123@0PAU123@AAV?$allocator@UValueParam@ShaderContextPool@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Uninit_copy@PBUValueParam@ShaderContextPool@Ogre@@PAU123@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@YAPAUValueParam@ShaderContextPool@Ogre@@PBU123@0PAU123@AAV?$allocator@UValueParam@ShaderContextPool@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_copy@PBUValueParam@ShaderContextPool@Ogre@@PAU123@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@YAPAUValueParam@ShaderContextPool@Ogre@@PBU123@0PAU123@AAV?$allocator@UValueParam@ShaderContextPool@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2
__ehfuncinfo$??$_Uninit_copy@PBUValueParam@ShaderContextPool@Ogre@@PAU123@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@YAPAUValueParam@ShaderContextPool@Ogre@@PBU123@0PAU123@AAV?$allocator@UValueParam@ShaderContextPool@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Uninit_copy@PBUValueParam@ShaderContextPool@Ogre@@PAU123@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@YAPAUValueParam@ShaderContextPool@Ogre@@PBU123@0PAU123@AAV?$allocator@UValueParam@ShaderContextPool@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_copy@PBUValueParam@ShaderContextPool@Ogre@@PAU123@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@YAPAUValueParam@ShaderContextPool@Ogre@@PBU123@0PAU123@AAV?$allocator@UValueParam@ShaderContextPool@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??$_Uninit_copy@PBUValueParam@ShaderContextPool@Ogre@@PAU123@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@YAPAUValueParam@ShaderContextPool@Ogre@@PBU123@0PAU123@AAV?$allocator@UValueParam@ShaderContextPool@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PBUValueParam@ShaderContextPool@Ogre@@PAU123@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@YAPAUValueParam@ShaderContextPool@Ogre@@PBU123@0PAU123@AAV?$allocator@UValueParam@ShaderContextPool@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<Ogre::ShaderContextPool::ValueParam const *,Ogre::ShaderContextPool::ValueParam *,std::allocator<Ogre::ShaderContextPool::ValueParam> >, COMDAT

; 124  : 	{	// copy [_First, _Last) to raw _Dest, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_copy@PBUValueParam@ShaderContextPool@Ogre@@PAU123@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@YAPAUValueParam@ShaderContextPool@Ogre@@PBU123@0PAU123@AAV?$allocator@UValueParam@ShaderContextPool@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 125  : 	_DEBUG_RANGE(_First, _Last);
; 126  : 	_DEBUG_POINTER(_Dest);
; 127  : 	_FwdIt _Next = _Dest;

	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Next$[ebp], eax

; 128  : 
; 129  : 	_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 130  : 	for (; _First != _Last; ++_Dest, ++_First)

	jmp	SHORT $LN6@Uninit_cop@12
$LN5@Uninit_cop@12:
	mov	ecx, DWORD PTR __Dest$[ebp]
	add	ecx, 16					; 00000010H
	mov	DWORD PTR __Dest$[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	add	edx, 16					; 00000010H
	mov	DWORD PTR __First$[ebp], edx
$LN6@Uninit_cop@12:
	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Uninit_cop@12

; 131  : 		_Al.construct(_Dest, *_First);

	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?construct@?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@QAEXPAUValueParam@ShaderContextPool@Ogre@@ABU345@@Z ; std::allocator<Ogre::ShaderContextPool::ValueParam>::construct
	jmp	SHORT $LN5@Uninit_cop@12
$LN4@Uninit_cop@12:
	jmp	SHORT $LN10@Uninit_cop@12
__catch$??$_Uninit_copy@PBUValueParam@ShaderContextPool@Ogre@@PAU123@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@YAPAUValueParam@ShaderContextPool@Ogre@@PBU123@0PAU123@AAV?$allocator@UValueParam@ShaderContextPool@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 132  : 	_CATCH_ALL
; 133  : 	for (; _Next != _Dest; ++_Next)

	jmp	SHORT $LN3@Uninit_cop@12
$LN2@Uninit_cop@12:
	mov	eax, DWORD PTR __Next$[ebp]
	add	eax, 16					; 00000010H
	mov	DWORD PTR __Next$[ebp], eax
$LN3@Uninit_cop@12:
	mov	ecx, DWORD PTR __Next$[ebp]
	cmp	ecx, DWORD PTR __Dest$[ebp]
	je	SHORT $LN1@Uninit_cop@12

; 134  : 		_Al.destroy(_Next);

	mov	edx, DWORD PTR __Next$[ebp]
	push	edx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?destroy@?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@QAEXPAUValueParam@ShaderContextPool@Ogre@@@Z ; std::allocator<Ogre::ShaderContextPool::ValueParam>::destroy
	jmp	SHORT $LN2@Uninit_cop@12
$LN1@Uninit_cop@12:

; 135  : 	_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 136  : 	_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$??$_Uninit_copy@PBUValueParam@ShaderContextPool@Ogre@@PAU123@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@YAPAUValueParam@ShaderContextPool@Ogre@@PBU123@0PAU123@AAV?$allocator@UValueParam@ShaderContextPool@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1
	ret	0
$LN10@Uninit_cop@12:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Uninit_copy@PBUValueParam@ShaderContextPool@Ogre@@PAU123@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@YAPAUValueParam@ShaderContextPool@Ogre@@PBU123@0PAU123@AAV?$allocator@UValueParam@ShaderContextPool@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1:

; 137  : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[ebp]
$LN9@Uninit_cop@12:

; 138  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_copy@PBUValueParam@ShaderContextPool@Ogre@@PAU123@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@YAPAUValueParam@ShaderContextPool@Ogre@@PBU123@0PAU123@AAV?$allocator@UValueParam@ShaderContextPool@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_copy@PBUValueParam@ShaderContextPool@Ogre@@PAU123@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@YAPAUValueParam@ShaderContextPool@Ogre@@PBU123@0PAU123@AAV?$allocator@UValueParam@ShaderContextPool@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_copy@PBUValueParam@ShaderContextPool@Ogre@@PAU123@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@YAPAUValueParam@ShaderContextPool@Ogre@@PBU123@0PAU123@AAV?$allocator@UValueParam@ShaderContextPool@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<Ogre::ShaderContextPool::ValueParam const *,Ogre::ShaderContextPool::ValueParam *,std::allocator<Ogre::ShaderContextPool::ValueParam> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Checked_base@PAUValueParam@ShaderContextPool@Ogre@@@std@@YAPAUValueParam@ShaderContextPool@Ogre@@AAPAU123@U_Unchanged_checked_iterator_base_type_tag@0@@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Checked_base@PAUValueParam@ShaderContextPool@Ogre@@@std@@YAPAUValueParam@ShaderContextPool@Ogre@@AAPAU123@U_Unchanged_checked_iterator_base_type_tag@0@@Z PROC ; std::_Checked_base<Ogre::ShaderContextPool::ValueParam *>, COMDAT

; 1146 : 	{

	push	ebp
	mov	ebp, esp

; 1147 : 		return _It;

	mov	eax, DWORD PTR __It$[ebp]
	mov	eax, DWORD PTR [eax]

; 1148 : 	}

	pop	ebp
	ret	0
??$_Checked_base@PAUValueParam@ShaderContextPool@Ogre@@@std@@YAPAUValueParam@ShaderContextPool@Ogre@@AAPAU123@U_Unchanged_checked_iterator_base_type_tag@0@@Z ENDP ; std::_Checked_base<Ogre::ShaderContextPool::ValueParam *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Copy_opt@PAUValueParam@ShaderContextPool@Ogre@@PAU123@Uforward_iterator_tag@std@@@std@@YAPAUValueParam@ShaderContextPool@Ogre@@PAU123@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAUValueParam@ShaderContextPool@Ogre@@PAU123@Uforward_iterator_tag@std@@@std@@YAPAUValueParam@ShaderContextPool@Ogre@@PAU123@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<Ogre::ShaderContextPool::ValueParam *,Ogre::ShaderContextPool::ValueParam *,std::forward_iterator_tag>, COMDAT

; 2469 : 	{	// copy [_First, _Last) to [_Dest, ...), arbitrary iterators

	push	ebp
	mov	ebp, esp

; 2470 : 	_DEBUG_RANGE(_First, _Last);
; 2471 : 	for (; _First != _Last; ++_Dest, ++_First)

	jmp	SHORT $LN3@Copy_opt@12
$LN2@Copy_opt@12:
	mov	eax, DWORD PTR __Dest$[ebp]
	add	eax, 16					; 00000010H
	mov	DWORD PTR __Dest$[ebp], eax
	mov	ecx, DWORD PTR __First$[ebp]
	add	ecx, 16					; 00000010H
	mov	DWORD PTR __First$[ebp], ecx
$LN3@Copy_opt@12:
	mov	edx, DWORD PTR __First$[ebp]
	cmp	edx, DWORD PTR __Last$[ebp]
	je	SHORT $LN1@Copy_opt@12

; 2472 : 		*_Dest = *_First;

	mov	eax, DWORD PTR __First$[ebp]
	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], eax
	jmp	SHORT $LN2@Copy_opt@12
$LN1@Copy_opt@12:

; 2473 : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[ebp]

; 2474 : 	}

	pop	ebp
	ret	0
??$_Copy_opt@PAUValueParam@ShaderContextPool@Ogre@@PAU123@Uforward_iterator_tag@std@@@std@@YAPAUValueParam@ShaderContextPool@Ogre@@PAU123@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<Ogre::ShaderContextPool::ValueParam *,Ogre::ShaderContextPool::ValueParam *,std::forward_iterator_tag>
_TEXT	ENDS
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	SEGMENT
__catchsym$??$_Uninit_copy@PAUValueParam@ShaderContextPool@Ogre@@PAU123@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@YAPAUValueParam@ShaderContextPool@Ogre@@PAU123@00AAV?$allocator@UValueParam@ShaderContextPool@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_copy@PAUValueParam@ShaderContextPool@Ogre@@PAU123@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@YAPAUValueParam@ShaderContextPool@Ogre@@PAU123@00AAV?$allocator@UValueParam@ShaderContextPool@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__unwindtable$??$_Uninit_copy@PAUValueParam@ShaderContextPool@Ogre@@PAU123@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@YAPAUValueParam@ShaderContextPool@Ogre@@PAU123@00AAV?$allocator@UValueParam@ShaderContextPool@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Uninit_copy@PAUValueParam@ShaderContextPool@Ogre@@PAU123@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@YAPAUValueParam@ShaderContextPool@Ogre@@PAU123@00AAV?$allocator@UValueParam@ShaderContextPool@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_copy@PAUValueParam@ShaderContextPool@Ogre@@PAU123@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@YAPAUValueParam@ShaderContextPool@Ogre@@PAU123@00AAV?$allocator@UValueParam@ShaderContextPool@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2
__ehfuncinfo$??$_Uninit_copy@PAUValueParam@ShaderContextPool@Ogre@@PAU123@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@YAPAUValueParam@ShaderContextPool@Ogre@@PAU123@00AAV?$allocator@UValueParam@ShaderContextPool@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Uninit_copy@PAUValueParam@ShaderContextPool@Ogre@@PAU123@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@YAPAUValueParam@ShaderContextPool@Ogre@@PAU123@00AAV?$allocator@UValueParam@ShaderContextPool@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_copy@PAUValueParam@ShaderContextPool@Ogre@@PAU123@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@YAPAUValueParam@ShaderContextPool@Ogre@@PAU123@00AAV?$allocator@UValueParam@ShaderContextPool@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??$_Uninit_copy@PAUValueParam@ShaderContextPool@Ogre@@PAU123@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@YAPAUValueParam@ShaderContextPool@Ogre@@PAU123@00AAV?$allocator@UValueParam@ShaderContextPool@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PAUValueParam@ShaderContextPool@Ogre@@PAU123@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@YAPAUValueParam@ShaderContextPool@Ogre@@PAU123@00AAV?$allocator@UValueParam@ShaderContextPool@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<Ogre::ShaderContextPool::ValueParam *,Ogre::ShaderContextPool::ValueParam *,std::allocator<Ogre::ShaderContextPool::ValueParam> >, COMDAT

; 124  : 	{	// copy [_First, _Last) to raw _Dest, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_copy@PAUValueParam@ShaderContextPool@Ogre@@PAU123@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@YAPAUValueParam@ShaderContextPool@Ogre@@PAU123@00AAV?$allocator@UValueParam@ShaderContextPool@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 125  : 	_DEBUG_RANGE(_First, _Last);
; 126  : 	_DEBUG_POINTER(_Dest);
; 127  : 	_FwdIt _Next = _Dest;

	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Next$[ebp], eax

; 128  : 
; 129  : 	_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 130  : 	for (; _First != _Last; ++_Dest, ++_First)

	jmp	SHORT $LN6@Uninit_cop@13
$LN5@Uninit_cop@13:
	mov	ecx, DWORD PTR __Dest$[ebp]
	add	ecx, 16					; 00000010H
	mov	DWORD PTR __Dest$[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	add	edx, 16					; 00000010H
	mov	DWORD PTR __First$[ebp], edx
$LN6@Uninit_cop@13:
	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Uninit_cop@13

; 131  : 		_Al.construct(_Dest, *_First);

	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?construct@?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@QAEXPAUValueParam@ShaderContextPool@Ogre@@ABU345@@Z ; std::allocator<Ogre::ShaderContextPool::ValueParam>::construct
	jmp	SHORT $LN5@Uninit_cop@13
$LN4@Uninit_cop@13:
	jmp	SHORT $LN10@Uninit_cop@13
__catch$??$_Uninit_copy@PAUValueParam@ShaderContextPool@Ogre@@PAU123@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@YAPAUValueParam@ShaderContextPool@Ogre@@PAU123@00AAV?$allocator@UValueParam@ShaderContextPool@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 132  : 	_CATCH_ALL
; 133  : 	for (; _Next != _Dest; ++_Next)

	jmp	SHORT $LN3@Uninit_cop@13
$LN2@Uninit_cop@13:
	mov	eax, DWORD PTR __Next$[ebp]
	add	eax, 16					; 00000010H
	mov	DWORD PTR __Next$[ebp], eax
$LN3@Uninit_cop@13:
	mov	ecx, DWORD PTR __Next$[ebp]
	cmp	ecx, DWORD PTR __Dest$[ebp]
	je	SHORT $LN1@Uninit_cop@13

; 134  : 		_Al.destroy(_Next);

	mov	edx, DWORD PTR __Next$[ebp]
	push	edx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?destroy@?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@QAEXPAUValueParam@ShaderContextPool@Ogre@@@Z ; std::allocator<Ogre::ShaderContextPool::ValueParam>::destroy
	jmp	SHORT $LN2@Uninit_cop@13
$LN1@Uninit_cop@13:

; 135  : 	_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 136  : 	_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$??$_Uninit_copy@PAUValueParam@ShaderContextPool@Ogre@@PAU123@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@YAPAUValueParam@ShaderContextPool@Ogre@@PAU123@00AAV?$allocator@UValueParam@ShaderContextPool@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1
	ret	0
$LN10@Uninit_cop@13:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Uninit_copy@PAUValueParam@ShaderContextPool@Ogre@@PAU123@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@YAPAUValueParam@ShaderContextPool@Ogre@@PAU123@00AAV?$allocator@UValueParam@ShaderContextPool@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1:

; 137  : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[ebp]
$LN9@Uninit_cop@13:

; 138  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_copy@PAUValueParam@ShaderContextPool@Ogre@@PAU123@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@YAPAUValueParam@ShaderContextPool@Ogre@@PAU123@00AAV?$allocator@UValueParam@ShaderContextPool@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_copy@PAUValueParam@ShaderContextPool@Ogre@@PAU123@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@YAPAUValueParam@ShaderContextPool@Ogre@@PAU123@00AAV?$allocator@UValueParam@ShaderContextPool@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_copy@PAUValueParam@ShaderContextPool@Ogre@@PAU123@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@YAPAUValueParam@ShaderContextPool@Ogre@@PAU123@00AAV?$allocator@UValueParam@ShaderContextPool@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<Ogre::ShaderContextPool::ValueParam *,Ogre::ShaderContextPool::ValueParam *,std::allocator<Ogre::ShaderContextPool::ValueParam> >
PUBLIC	??$_Checked_base@V?$_Vector_const_iterator@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBUTexParam@ShaderContextPool@Ogre@@AAV?$_Vector_const_iterator@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::ShaderContextPool::TexParam,std::allocator<Ogre::ShaderContextPool::TexParam> >,std::_Different_checked_iterator_base_type_tag>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Checked_base@V?$_Vector_const_iterator@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@@std@@YAPBUTexParam@ShaderContextPool@Ogre@@AAV?$_Vector_const_iterator@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@0@@Z
_TEXT	SEGMENT
__Base_tag$ = -1					; size = 1
__It$ = 8						; size = 4
??$_Checked_base@V?$_Vector_const_iterator@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@@std@@YAPBUTexParam@ShaderContextPool@Ogre@@AAV?$_Vector_const_iterator@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@0@@Z PROC ; std::_Checked_base<std::_Vector_const_iterator<Ogre::ShaderContextPool::TexParam,std::allocator<Ogre::ShaderContextPool::TexParam> > >, COMDAT

; 1163 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1164 : 		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
; 1165 : 		return _Checked_base(_It, _Base_tag);

	movzx	eax, BYTE PTR __Base_tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR __It$[ebp]
	push	ecx
	call	??$_Checked_base@V?$_Vector_const_iterator@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBUTexParam@ShaderContextPool@Ogre@@AAV?$_Vector_const_iterator@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::ShaderContextPool::TexParam,std::allocator<Ogre::ShaderContextPool::TexParam> >,std::_Different_checked_iterator_base_type_tag>
	add	esp, 8

; 1166 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Checked_base@V?$_Vector_const_iterator@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@@std@@YAPBUTexParam@ShaderContextPool@Ogre@@AAV?$_Vector_const_iterator@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@0@@Z ENDP ; std::_Checked_base<std::_Vector_const_iterator<Ogre::ShaderContextPool::TexParam,std::allocator<Ogre::ShaderContextPool::TexParam> > >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@V?$_Vector_const_iterator@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@PAUTexParam@ShaderContextPool@Ogre@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@0@AAPAUTexParam@ShaderContextPool@Ogre@@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@V?$_Vector_const_iterator@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@PAUTexParam@ShaderContextPool@Ogre@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@0@AAPAUTexParam@ShaderContextPool@Ogre@@@Z PROC ; std::_Ptr_cat<std::_Vector_const_iterator<Ogre::ShaderContextPool::TexParam,std::allocator<Ogre::ShaderContextPool::TexParam> >,Ogre::ShaderContextPool::TexParam *>, COMDAT

; 1509 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 1512 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Ptr_cat@V?$_Vector_const_iterator@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@PAUTexParam@ShaderContextPool@Ogre@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@0@AAPAUTexParam@ShaderContextPool@Ogre@@@Z ENDP ; std::_Ptr_cat<std::_Vector_const_iterator<Ogre::ShaderContextPool::TexParam,std::allocator<Ogre::ShaderContextPool::TexParam> >,Ogre::ShaderContextPool::TexParam *>
_TEXT	ENDS
PUBLIC	?construct@?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@QAEXPAUTexParam@ShaderContextPool@Ogre@@ABU345@@Z ; std::allocator<Ogre::ShaderContextPool::TexParam>::construct
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	SEGMENT
__catchsym$??$_Uninit_copy@PBUTexParam@ShaderContextPool@Ogre@@PAU123@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@YAPAUTexParam@ShaderContextPool@Ogre@@PBU123@0PAU123@AAV?$allocator@UTexParam@ShaderContextPool@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_copy@PBUTexParam@ShaderContextPool@Ogre@@PAU123@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@YAPAUTexParam@ShaderContextPool@Ogre@@PBU123@0PAU123@AAV?$allocator@UTexParam@ShaderContextPool@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__unwindtable$??$_Uninit_copy@PBUTexParam@ShaderContextPool@Ogre@@PAU123@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@YAPAUTexParam@ShaderContextPool@Ogre@@PBU123@0PAU123@AAV?$allocator@UTexParam@ShaderContextPool@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Uninit_copy@PBUTexParam@ShaderContextPool@Ogre@@PAU123@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@YAPAUTexParam@ShaderContextPool@Ogre@@PBU123@0PAU123@AAV?$allocator@UTexParam@ShaderContextPool@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_copy@PBUTexParam@ShaderContextPool@Ogre@@PAU123@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@YAPAUTexParam@ShaderContextPool@Ogre@@PBU123@0PAU123@AAV?$allocator@UTexParam@ShaderContextPool@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2
__ehfuncinfo$??$_Uninit_copy@PBUTexParam@ShaderContextPool@Ogre@@PAU123@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@YAPAUTexParam@ShaderContextPool@Ogre@@PBU123@0PAU123@AAV?$allocator@UTexParam@ShaderContextPool@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Uninit_copy@PBUTexParam@ShaderContextPool@Ogre@@PAU123@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@YAPAUTexParam@ShaderContextPool@Ogre@@PBU123@0PAU123@AAV?$allocator@UTexParam@ShaderContextPool@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_copy@PBUTexParam@ShaderContextPool@Ogre@@PAU123@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@YAPAUTexParam@ShaderContextPool@Ogre@@PBU123@0PAU123@AAV?$allocator@UTexParam@ShaderContextPool@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??$_Uninit_copy@PBUTexParam@ShaderContextPool@Ogre@@PAU123@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@YAPAUTexParam@ShaderContextPool@Ogre@@PBU123@0PAU123@AAV?$allocator@UTexParam@ShaderContextPool@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PBUTexParam@ShaderContextPool@Ogre@@PAU123@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@YAPAUTexParam@ShaderContextPool@Ogre@@PBU123@0PAU123@AAV?$allocator@UTexParam@ShaderContextPool@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<Ogre::ShaderContextPool::TexParam const *,Ogre::ShaderContextPool::TexParam *,std::allocator<Ogre::ShaderContextPool::TexParam> >, COMDAT

; 124  : 	{	// copy [_First, _Last) to raw _Dest, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_copy@PBUTexParam@ShaderContextPool@Ogre@@PAU123@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@YAPAUTexParam@ShaderContextPool@Ogre@@PBU123@0PAU123@AAV?$allocator@UTexParam@ShaderContextPool@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 125  : 	_DEBUG_RANGE(_First, _Last);
; 126  : 	_DEBUG_POINTER(_Dest);
; 127  : 	_FwdIt _Next = _Dest;

	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Next$[ebp], eax

; 128  : 
; 129  : 	_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 130  : 	for (; _First != _Last; ++_Dest, ++_First)

	jmp	SHORT $LN6@Uninit_cop@14
$LN5@Uninit_cop@14:
	mov	ecx, DWORD PTR __Dest$[ebp]
	add	ecx, 8
	mov	DWORD PTR __Dest$[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	add	edx, 8
	mov	DWORD PTR __First$[ebp], edx
$LN6@Uninit_cop@14:
	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Uninit_cop@14

; 131  : 		_Al.construct(_Dest, *_First);

	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?construct@?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@QAEXPAUTexParam@ShaderContextPool@Ogre@@ABU345@@Z ; std::allocator<Ogre::ShaderContextPool::TexParam>::construct
	jmp	SHORT $LN5@Uninit_cop@14
$LN4@Uninit_cop@14:
	jmp	SHORT $LN10@Uninit_cop@14
__catch$??$_Uninit_copy@PBUTexParam@ShaderContextPool@Ogre@@PAU123@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@YAPAUTexParam@ShaderContextPool@Ogre@@PBU123@0PAU123@AAV?$allocator@UTexParam@ShaderContextPool@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 132  : 	_CATCH_ALL
; 133  : 	for (; _Next != _Dest; ++_Next)

	jmp	SHORT $LN3@Uninit_cop@14
$LN2@Uninit_cop@14:
	mov	eax, DWORD PTR __Next$[ebp]
	add	eax, 8
	mov	DWORD PTR __Next$[ebp], eax
$LN3@Uninit_cop@14:
	mov	ecx, DWORD PTR __Next$[ebp]
	cmp	ecx, DWORD PTR __Dest$[ebp]
	je	SHORT $LN1@Uninit_cop@14

; 134  : 		_Al.destroy(_Next);

	mov	edx, DWORD PTR __Next$[ebp]
	push	edx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?destroy@?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@QAEXPAUTexParam@ShaderContextPool@Ogre@@@Z ; std::allocator<Ogre::ShaderContextPool::TexParam>::destroy
	jmp	SHORT $LN2@Uninit_cop@14
$LN1@Uninit_cop@14:

; 135  : 	_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 136  : 	_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$??$_Uninit_copy@PBUTexParam@ShaderContextPool@Ogre@@PAU123@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@YAPAUTexParam@ShaderContextPool@Ogre@@PBU123@0PAU123@AAV?$allocator@UTexParam@ShaderContextPool@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1
	ret	0
$LN10@Uninit_cop@14:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Uninit_copy@PBUTexParam@ShaderContextPool@Ogre@@PAU123@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@YAPAUTexParam@ShaderContextPool@Ogre@@PBU123@0PAU123@AAV?$allocator@UTexParam@ShaderContextPool@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1:

; 137  : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[ebp]
$LN9@Uninit_cop@14:

; 138  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_copy@PBUTexParam@ShaderContextPool@Ogre@@PAU123@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@YAPAUTexParam@ShaderContextPool@Ogre@@PBU123@0PAU123@AAV?$allocator@UTexParam@ShaderContextPool@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_copy@PBUTexParam@ShaderContextPool@Ogre@@PAU123@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@YAPAUTexParam@ShaderContextPool@Ogre@@PBU123@0PAU123@AAV?$allocator@UTexParam@ShaderContextPool@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_copy@PBUTexParam@ShaderContextPool@Ogre@@PAU123@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@YAPAUTexParam@ShaderContextPool@Ogre@@PBU123@0PAU123@AAV?$allocator@UTexParam@ShaderContextPool@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<Ogre::ShaderContextPool::TexParam const *,Ogre::ShaderContextPool::TexParam *,std::allocator<Ogre::ShaderContextPool::TexParam> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Checked_base@PAUTexParam@ShaderContextPool@Ogre@@@std@@YAPAUTexParam@ShaderContextPool@Ogre@@AAPAU123@U_Unchanged_checked_iterator_base_type_tag@0@@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Checked_base@PAUTexParam@ShaderContextPool@Ogre@@@std@@YAPAUTexParam@ShaderContextPool@Ogre@@AAPAU123@U_Unchanged_checked_iterator_base_type_tag@0@@Z PROC ; std::_Checked_base<Ogre::ShaderContextPool::TexParam *>, COMDAT

; 1146 : 	{

	push	ebp
	mov	ebp, esp

; 1147 : 		return _It;

	mov	eax, DWORD PTR __It$[ebp]
	mov	eax, DWORD PTR [eax]

; 1148 : 	}

	pop	ebp
	ret	0
??$_Checked_base@PAUTexParam@ShaderContextPool@Ogre@@@std@@YAPAUTexParam@ShaderContextPool@Ogre@@AAPAU123@U_Unchanged_checked_iterator_base_type_tag@0@@Z ENDP ; std::_Checked_base<Ogre::ShaderContextPool::TexParam *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Copy_opt@PAUTexParam@ShaderContextPool@Ogre@@PAU123@Uforward_iterator_tag@std@@@std@@YAPAUTexParam@ShaderContextPool@Ogre@@PAU123@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAUTexParam@ShaderContextPool@Ogre@@PAU123@Uforward_iterator_tag@std@@@std@@YAPAUTexParam@ShaderContextPool@Ogre@@PAU123@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<Ogre::ShaderContextPool::TexParam *,Ogre::ShaderContextPool::TexParam *,std::forward_iterator_tag>, COMDAT

; 2469 : 	{	// copy [_First, _Last) to [_Dest, ...), arbitrary iterators

	push	ebp
	mov	ebp, esp

; 2470 : 	_DEBUG_RANGE(_First, _Last);
; 2471 : 	for (; _First != _Last; ++_Dest, ++_First)

	jmp	SHORT $LN3@Copy_opt@13
$LN2@Copy_opt@13:
	mov	eax, DWORD PTR __Dest$[ebp]
	add	eax, 8
	mov	DWORD PTR __Dest$[ebp], eax
	mov	ecx, DWORD PTR __First$[ebp]
	add	ecx, 8
	mov	DWORD PTR __First$[ebp], ecx
$LN3@Copy_opt@13:
	mov	edx, DWORD PTR __First$[ebp]
	cmp	edx, DWORD PTR __Last$[ebp]
	je	SHORT $LN1@Copy_opt@13

; 2472 : 		*_Dest = *_First;

	mov	eax, DWORD PTR __First$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	jmp	SHORT $LN2@Copy_opt@13
$LN1@Copy_opt@13:

; 2473 : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[ebp]

; 2474 : 	}

	pop	ebp
	ret	0
??$_Copy_opt@PAUTexParam@ShaderContextPool@Ogre@@PAU123@Uforward_iterator_tag@std@@@std@@YAPAUTexParam@ShaderContextPool@Ogre@@PAU123@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<Ogre::ShaderContextPool::TexParam *,Ogre::ShaderContextPool::TexParam *,std::forward_iterator_tag>
_TEXT	ENDS
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	SEGMENT
__catchsym$??$_Uninit_copy@PAUTexParam@ShaderContextPool@Ogre@@PAU123@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@YAPAUTexParam@ShaderContextPool@Ogre@@PAU123@00AAV?$allocator@UTexParam@ShaderContextPool@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_copy@PAUTexParam@ShaderContextPool@Ogre@@PAU123@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@YAPAUTexParam@ShaderContextPool@Ogre@@PAU123@00AAV?$allocator@UTexParam@ShaderContextPool@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__unwindtable$??$_Uninit_copy@PAUTexParam@ShaderContextPool@Ogre@@PAU123@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@YAPAUTexParam@ShaderContextPool@Ogre@@PAU123@00AAV?$allocator@UTexParam@ShaderContextPool@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Uninit_copy@PAUTexParam@ShaderContextPool@Ogre@@PAU123@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@YAPAUTexParam@ShaderContextPool@Ogre@@PAU123@00AAV?$allocator@UTexParam@ShaderContextPool@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_copy@PAUTexParam@ShaderContextPool@Ogre@@PAU123@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@YAPAUTexParam@ShaderContextPool@Ogre@@PAU123@00AAV?$allocator@UTexParam@ShaderContextPool@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2
__ehfuncinfo$??$_Uninit_copy@PAUTexParam@ShaderContextPool@Ogre@@PAU123@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@YAPAUTexParam@ShaderContextPool@Ogre@@PAU123@00AAV?$allocator@UTexParam@ShaderContextPool@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Uninit_copy@PAUTexParam@ShaderContextPool@Ogre@@PAU123@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@YAPAUTexParam@ShaderContextPool@Ogre@@PAU123@00AAV?$allocator@UTexParam@ShaderContextPool@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_copy@PAUTexParam@ShaderContextPool@Ogre@@PAU123@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@YAPAUTexParam@ShaderContextPool@Ogre@@PAU123@00AAV?$allocator@UTexParam@ShaderContextPool@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??$_Uninit_copy@PAUTexParam@ShaderContextPool@Ogre@@PAU123@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@YAPAUTexParam@ShaderContextPool@Ogre@@PAU123@00AAV?$allocator@UTexParam@ShaderContextPool@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PAUTexParam@ShaderContextPool@Ogre@@PAU123@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@YAPAUTexParam@ShaderContextPool@Ogre@@PAU123@00AAV?$allocator@UTexParam@ShaderContextPool@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<Ogre::ShaderContextPool::TexParam *,Ogre::ShaderContextPool::TexParam *,std::allocator<Ogre::ShaderContextPool::TexParam> >, COMDAT

; 124  : 	{	// copy [_First, _Last) to raw _Dest, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_copy@PAUTexParam@ShaderContextPool@Ogre@@PAU123@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@YAPAUTexParam@ShaderContextPool@Ogre@@PAU123@00AAV?$allocator@UTexParam@ShaderContextPool@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 125  : 	_DEBUG_RANGE(_First, _Last);
; 126  : 	_DEBUG_POINTER(_Dest);
; 127  : 	_FwdIt _Next = _Dest;

	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Next$[ebp], eax

; 128  : 
; 129  : 	_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 130  : 	for (; _First != _Last; ++_Dest, ++_First)

	jmp	SHORT $LN6@Uninit_cop@15
$LN5@Uninit_cop@15:
	mov	ecx, DWORD PTR __Dest$[ebp]
	add	ecx, 8
	mov	DWORD PTR __Dest$[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	add	edx, 8
	mov	DWORD PTR __First$[ebp], edx
$LN6@Uninit_cop@15:
	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Uninit_cop@15

; 131  : 		_Al.construct(_Dest, *_First);

	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?construct@?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@QAEXPAUTexParam@ShaderContextPool@Ogre@@ABU345@@Z ; std::allocator<Ogre::ShaderContextPool::TexParam>::construct
	jmp	SHORT $LN5@Uninit_cop@15
$LN4@Uninit_cop@15:
	jmp	SHORT $LN10@Uninit_cop@15
__catch$??$_Uninit_copy@PAUTexParam@ShaderContextPool@Ogre@@PAU123@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@YAPAUTexParam@ShaderContextPool@Ogre@@PAU123@00AAV?$allocator@UTexParam@ShaderContextPool@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 132  : 	_CATCH_ALL
; 133  : 	for (; _Next != _Dest; ++_Next)

	jmp	SHORT $LN3@Uninit_cop@15
$LN2@Uninit_cop@15:
	mov	eax, DWORD PTR __Next$[ebp]
	add	eax, 8
	mov	DWORD PTR __Next$[ebp], eax
$LN3@Uninit_cop@15:
	mov	ecx, DWORD PTR __Next$[ebp]
	cmp	ecx, DWORD PTR __Dest$[ebp]
	je	SHORT $LN1@Uninit_cop@15

; 134  : 		_Al.destroy(_Next);

	mov	edx, DWORD PTR __Next$[ebp]
	push	edx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?destroy@?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@QAEXPAUTexParam@ShaderContextPool@Ogre@@@Z ; std::allocator<Ogre::ShaderContextPool::TexParam>::destroy
	jmp	SHORT $LN2@Uninit_cop@15
$LN1@Uninit_cop@15:

; 135  : 	_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 136  : 	_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$??$_Uninit_copy@PAUTexParam@ShaderContextPool@Ogre@@PAU123@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@YAPAUTexParam@ShaderContextPool@Ogre@@PAU123@00AAV?$allocator@UTexParam@ShaderContextPool@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1
	ret	0
$LN10@Uninit_cop@15:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Uninit_copy@PAUTexParam@ShaderContextPool@Ogre@@PAU123@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@YAPAUTexParam@ShaderContextPool@Ogre@@PAU123@00AAV?$allocator@UTexParam@ShaderContextPool@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1:

; 137  : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[ebp]
$LN9@Uninit_cop@15:

; 138  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_copy@PAUTexParam@ShaderContextPool@Ogre@@PAU123@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@YAPAUTexParam@ShaderContextPool@Ogre@@PAU123@00AAV?$allocator@UTexParam@ShaderContextPool@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_copy@PAUTexParam@ShaderContextPool@Ogre@@PAU123@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@YAPAUTexParam@ShaderContextPool@Ogre@@PAU123@00AAV?$allocator@UTexParam@ShaderContextPool@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_copy@PAUTexParam@ShaderContextPool@Ogre@@PAU123@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@YAPAUTexParam@ShaderContextPool@Ogre@@PAU123@00AAV?$allocator@UTexParam@ShaderContextPool@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<Ogre::ShaderContextPool::TexParam *,Ogre::ShaderContextPool::TexParam *,std::allocator<Ogre::ShaderContextPool::TexParam> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Checked_base@PAPAVMaterialParam@Ogre@@@std@@YAPAPAVMaterialParam@Ogre@@AAPAPAV12@U_Unchanged_checked_iterator_base_type_tag@0@@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Checked_base@PAPAVMaterialParam@Ogre@@@std@@YAPAPAVMaterialParam@Ogre@@AAPAPAV12@U_Unchanged_checked_iterator_base_type_tag@0@@Z PROC ; std::_Checked_base<Ogre::MaterialParam * *>, COMDAT

; 1146 : 	{

	push	ebp
	mov	ebp, esp

; 1147 : 		return _It;

	mov	eax, DWORD PTR __It$[ebp]
	mov	eax, DWORD PTR [eax]

; 1148 : 	}

	pop	ebp
	ret	0
??$_Checked_base@PAPAVMaterialParam@Ogre@@@std@@YAPAPAVMaterialParam@Ogre@@AAPAPAV12@U_Unchanged_checked_iterator_base_type_tag@0@@Z ENDP ; std::_Checked_base<Ogre::MaterialParam * *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@PAPAVMaterialParam@Ogre@@PAPAV12@V?$allocator@PAVMaterialParam@Ogre@@@std@@@std@@YAPAPAVMaterialParam@Ogre@@PAPAV12@00AAV?$allocator@PAVMaterialParam@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Result$ = -8						; size = 4
__Count$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PAPAVMaterialParam@Ogre@@PAPAV12@V?$allocator@PAVMaterialParam@Ogre@@@std@@@std@@YAPAPAVMaterialParam@Ogre@@PAPAV12@00AAV?$allocator@PAVMaterialParam@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<Ogre::MaterialParam * *,Ogre::MaterialParam * *,std::allocator<Ogre::MaterialParam *> >, COMDAT

; 145  : 	{	// copy [_First, _Last) to raw _Dest, scalar type

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 146  : 	_DEBUG_RANGE(_First, _Last);
; 147  : 	_DEBUG_POINTER(_Dest);
; 148  : 	size_t _Count = (size_t)(_Last - _First);

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 2
	mov	DWORD PTR __Count$[ebp], eax

; 149  : 	_FwdIt _Result = _Dest + _Count;

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Dest$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR __Result$[ebp], eax

; 150  : 	if (_Count > 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN1@Uninit_cop@16

; 151  : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Count * sizeof (*_First), &*_First, _Count * sizeof (*_First));	// NB: non-overlapping move

	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN1@Uninit_cop@16:

; 152  : 	return (_Result);

	mov	eax, DWORD PTR __Result$[ebp]

; 153  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Uninit_copy@PAPAVMaterialParam@Ogre@@PAPAV12@V?$allocator@PAVMaterialParam@Ogre@@@std@@@std@@YAPAPAVMaterialParam@Ogre@@PAPAV12@00AAV?$allocator@PAVMaterialParam@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<Ogre::MaterialParam * *,Ogre::MaterialParam * *,std::allocator<Ogre::MaterialParam *> >
_TEXT	ENDS
PUBLIC	??$_Checked_base@V?$_Vector_const_iterator@DV?$allocator@D@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBDAAV?$_Vector_const_iterator@DV?$allocator@D@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<char,std::allocator<char> >,std::_Different_checked_iterator_base_type_tag>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Checked_base@V?$_Vector_const_iterator@DV?$allocator@D@std@@@std@@@std@@YAPBDAAV?$_Vector_const_iterator@DV?$allocator@D@std@@@0@@Z
_TEXT	SEGMENT
__Base_tag$ = -1					; size = 1
__It$ = 8						; size = 4
??$_Checked_base@V?$_Vector_const_iterator@DV?$allocator@D@std@@@std@@@std@@YAPBDAAV?$_Vector_const_iterator@DV?$allocator@D@std@@@0@@Z PROC ; std::_Checked_base<std::_Vector_const_iterator<char,std::allocator<char> > >, COMDAT

; 1163 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1164 : 		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
; 1165 : 		return _Checked_base(_It, _Base_tag);

	movzx	eax, BYTE PTR __Base_tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR __It$[ebp]
	push	ecx
	call	??$_Checked_base@V?$_Vector_const_iterator@DV?$allocator@D@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBDAAV?$_Vector_const_iterator@DV?$allocator@D@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<char,std::allocator<char> >,std::_Different_checked_iterator_base_type_tag>
	add	esp, 8

; 1166 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Checked_base@V?$_Vector_const_iterator@DV?$allocator@D@std@@@std@@@std@@YAPBDAAV?$_Vector_const_iterator@DV?$allocator@D@std@@@0@@Z ENDP ; std::_Checked_base<std::_Vector_const_iterator<char,std::allocator<char> > >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@V?$_Vector_const_iterator@DV?$allocator@D@std@@@std@@PAD@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@DV?$allocator@D@std@@@0@AAPAD@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@V?$_Vector_const_iterator@DV?$allocator@D@std@@@std@@PAD@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@DV?$allocator@D@std@@@0@AAPAD@Z PROC ; std::_Ptr_cat<std::_Vector_const_iterator<char,std::allocator<char> >,char *>, COMDAT

; 1509 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 1512 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Ptr_cat@V?$_Vector_const_iterator@DV?$allocator@D@std@@@std@@PAD@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@DV?$allocator@D@std@@@0@AAPAD@Z ENDP ; std::_Ptr_cat<std::_Vector_const_iterator<char,std::allocator<char> >,char *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@PBDPADV?$allocator@D@std@@@std@@YAPADPBD0PADAAV?$allocator@D@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Result$ = -8						; size = 4
__Count$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PBDPADV?$allocator@D@std@@@std@@YAPADPBD0PADAAV?$allocator@D@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<char const *,char *,std::allocator<char> >, COMDAT

; 145  : 	{	// copy [_First, _Last) to raw _Dest, scalar type

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 146  : 	_DEBUG_RANGE(_First, _Last);
; 147  : 	_DEBUG_POINTER(_Dest);
; 148  : 	size_t _Count = (size_t)(_Last - _First);

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Count$[ebp], eax

; 149  : 	_FwdIt _Result = _Dest + _Count;

	mov	ecx, DWORD PTR __Dest$[ebp]
	add	ecx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Result$[ebp], ecx

; 150  : 	if (_Count > 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN1@Uninit_cop@17

; 151  : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Count * sizeof (*_First), &*_First, _Count * sizeof (*_First));	// NB: non-overlapping move

	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN1@Uninit_cop@17:

; 152  : 	return (_Result);

	mov	eax, DWORD PTR __Result$[ebp]

; 153  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Uninit_copy@PBDPADV?$allocator@D@std@@@std@@YAPADPBD0PADAAV?$allocator@D@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<char const *,char *,std::allocator<char> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Checked_base@PAD@std@@YAPADAAPADU_Unchanged_checked_iterator_base_type_tag@0@@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Checked_base@PAD@std@@YAPADAAPADU_Unchanged_checked_iterator_base_type_tag@0@@Z PROC ; std::_Checked_base<char *>, COMDAT

; 1146 : 	{

	push	ebp
	mov	ebp, esp

; 1147 : 		return _It;

	mov	eax, DWORD PTR __It$[ebp]
	mov	eax, DWORD PTR [eax]

; 1148 : 	}

	pop	ebp
	ret	0
??$_Checked_base@PAD@std@@YAPADAAPADU_Unchanged_checked_iterator_base_type_tag@0@@Z ENDP ; std::_Checked_base<char *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@PADPADV?$allocator@D@std@@@std@@YAPADPAD00AAV?$allocator@D@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Result$ = -8						; size = 4
__Count$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PADPADV?$allocator@D@std@@@std@@YAPADPAD00AAV?$allocator@D@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<char *,char *,std::allocator<char> >, COMDAT

; 145  : 	{	// copy [_First, _Last) to raw _Dest, scalar type

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 146  : 	_DEBUG_RANGE(_First, _Last);
; 147  : 	_DEBUG_POINTER(_Dest);
; 148  : 	size_t _Count = (size_t)(_Last - _First);

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Count$[ebp], eax

; 149  : 	_FwdIt _Result = _Dest + _Count;

	mov	ecx, DWORD PTR __Dest$[ebp]
	add	ecx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Result$[ebp], ecx

; 150  : 	if (_Count > 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN1@Uninit_cop@18

; 151  : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Count * sizeof (*_First), &*_First, _Count * sizeof (*_First));	// NB: non-overlapping move

	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN1@Uninit_cop@18:

; 152  : 	return (_Result);

	mov	eax, DWORD PTR __Result$[ebp]

; 153  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Uninit_copy@PADPADV?$allocator@D@std@@@std@@YAPADPAD00AAV?$allocator@D@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<char *,char *,std::allocator<char> >
_TEXT	ENDS
PUBLIC	??$_Checked_base@V?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBQAVSurfaceData@Ogre@@AAV?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >,std::_Different_checked_iterator_base_type_tag>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Checked_base@V?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@@std@@YAPBQAVSurfaceData@Ogre@@AAV?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@0@@Z
_TEXT	SEGMENT
__Base_tag$ = -1					; size = 1
__It$ = 8						; size = 4
??$_Checked_base@V?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@@std@@YAPBQAVSurfaceData@Ogre@@AAV?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@0@@Z PROC ; std::_Checked_base<std::_Vector_const_iterator<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> > >, COMDAT

; 1163 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1164 : 		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
; 1165 : 		return _Checked_base(_It, _Base_tag);

	movzx	eax, BYTE PTR __Base_tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR __It$[ebp]
	push	ecx
	call	??$_Checked_base@V?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBQAVSurfaceData@Ogre@@AAV?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >,std::_Different_checked_iterator_base_type_tag>
	add	esp, 8

; 1166 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Checked_base@V?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@@std@@YAPBQAVSurfaceData@Ogre@@AAV?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@0@@Z ENDP ; std::_Checked_base<std::_Vector_const_iterator<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> > >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@V?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@PAPAVSurfaceData@Ogre@@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@0@AAPAPAVSurfaceData@Ogre@@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@V?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@PAPAVSurfaceData@Ogre@@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@0@AAPAPAVSurfaceData@Ogre@@@Z PROC ; std::_Ptr_cat<std::_Vector_const_iterator<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >,Ogre::SurfaceData * *>, COMDAT

; 1509 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 1512 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Ptr_cat@V?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@PAPAVSurfaceData@Ogre@@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@0@AAPAPAVSurfaceData@Ogre@@@Z ENDP ; std::_Ptr_cat<std::_Vector_const_iterator<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >,Ogre::SurfaceData * *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@PBQAVSurfaceData@Ogre@@PAPAV12@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@YAPAPAVSurfaceData@Ogre@@PBQAV12@0PAPAV12@AAV?$allocator@PAVSurfaceData@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Result$ = -8						; size = 4
__Count$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PBQAVSurfaceData@Ogre@@PAPAV12@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@YAPAPAVSurfaceData@Ogre@@PBQAV12@0PAPAV12@AAV?$allocator@PAVSurfaceData@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<Ogre::SurfaceData * const *,Ogre::SurfaceData * *,std::allocator<Ogre::SurfaceData *> >, COMDAT

; 145  : 	{	// copy [_First, _Last) to raw _Dest, scalar type

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 146  : 	_DEBUG_RANGE(_First, _Last);
; 147  : 	_DEBUG_POINTER(_Dest);
; 148  : 	size_t _Count = (size_t)(_Last - _First);

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 2
	mov	DWORD PTR __Count$[ebp], eax

; 149  : 	_FwdIt _Result = _Dest + _Count;

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Dest$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR __Result$[ebp], eax

; 150  : 	if (_Count > 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN1@Uninit_cop@19

; 151  : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Count * sizeof (*_First), &*_First, _Count * sizeof (*_First));	// NB: non-overlapping move

	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN1@Uninit_cop@19:

; 152  : 	return (_Result);

	mov	eax, DWORD PTR __Result$[ebp]

; 153  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Uninit_copy@PBQAVSurfaceData@Ogre@@PAPAV12@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@YAPAPAVSurfaceData@Ogre@@PBQAV12@0PAPAV12@AAV?$allocator@PAVSurfaceData@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<Ogre::SurfaceData * const *,Ogre::SurfaceData * *,std::allocator<Ogre::SurfaceData *> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Checked_base@PAPAVSurfaceData@Ogre@@@std@@YAPAPAVSurfaceData@Ogre@@AAPAPAV12@U_Unchanged_checked_iterator_base_type_tag@0@@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Checked_base@PAPAVSurfaceData@Ogre@@@std@@YAPAPAVSurfaceData@Ogre@@AAPAPAV12@U_Unchanged_checked_iterator_base_type_tag@0@@Z PROC ; std::_Checked_base<Ogre::SurfaceData * *>, COMDAT

; 1146 : 	{

	push	ebp
	mov	ebp, esp

; 1147 : 		return _It;

	mov	eax, DWORD PTR __It$[ebp]
	mov	eax, DWORD PTR [eax]

; 1148 : 	}

	pop	ebp
	ret	0
??$_Checked_base@PAPAVSurfaceData@Ogre@@@std@@YAPAPAVSurfaceData@Ogre@@AAPAPAV12@U_Unchanged_checked_iterator_base_type_tag@0@@Z ENDP ; std::_Checked_base<Ogre::SurfaceData * *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@PAPAVSurfaceData@Ogre@@PAPAV12@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@YAPAPAVSurfaceData@Ogre@@PAPAV12@00AAV?$allocator@PAVSurfaceData@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Result$ = -8						; size = 4
__Count$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PAPAVSurfaceData@Ogre@@PAPAV12@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@YAPAPAVSurfaceData@Ogre@@PAPAV12@00AAV?$allocator@PAVSurfaceData@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<Ogre::SurfaceData * *,Ogre::SurfaceData * *,std::allocator<Ogre::SurfaceData *> >, COMDAT

; 145  : 	{	// copy [_First, _Last) to raw _Dest, scalar type

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 146  : 	_DEBUG_RANGE(_First, _Last);
; 147  : 	_DEBUG_POINTER(_Dest);
; 148  : 	size_t _Count = (size_t)(_Last - _First);

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 2
	mov	DWORD PTR __Count$[ebp], eax

; 149  : 	_FwdIt _Result = _Dest + _Count;

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Dest$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR __Result$[ebp], eax

; 150  : 	if (_Count > 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN1@Uninit_cop@20

; 151  : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Count * sizeof (*_First), &*_First, _Count * sizeof (*_First));	// NB: non-overlapping move

	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN1@Uninit_cop@20:

; 152  : 	return (_Result);

	mov	eax, DWORD PTR __Result$[ebp]

; 153  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Uninit_copy@PAPAVSurfaceData@Ogre@@PAPAV12@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@YAPAPAVSurfaceData@Ogre@@PAPAV12@00AAV?$allocator@PAVSurfaceData@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<Ogre::SurfaceData * *,Ogre::SurfaceData * *,std::allocator<Ogre::SurfaceData *> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Checked_base@PAG@std@@YAPAGAAPAGU_Unchanged_checked_iterator_base_type_tag@0@@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Checked_base@PAG@std@@YAPAGAAPAGU_Unchanged_checked_iterator_base_type_tag@0@@Z PROC ; std::_Checked_base<unsigned short *>, COMDAT

; 1146 : 	{

	push	ebp
	mov	ebp, esp

; 1147 : 		return _It;

	mov	eax, DWORD PTR __It$[ebp]
	mov	eax, DWORD PTR [eax]

; 1148 : 	}

	pop	ebp
	ret	0
??$_Checked_base@PAG@std@@YAPAGAAPAGU_Unchanged_checked_iterator_base_type_tag@0@@Z ENDP ; std::_Checked_base<unsigned short *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@PAGPAGV?$allocator@G@std@@@std@@YAPAGPAG00AAV?$allocator@G@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Result$ = -8						; size = 4
__Count$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PAGPAGV?$allocator@G@std@@@std@@YAPAGPAG00AAV?$allocator@G@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<unsigned short *,unsigned short *,std::allocator<unsigned short> >, COMDAT

; 145  : 	{	// copy [_First, _Last) to raw _Dest, scalar type

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 146  : 	_DEBUG_RANGE(_First, _Last);
; 147  : 	_DEBUG_POINTER(_Dest);
; 148  : 	size_t _Count = (size_t)(_Last - _First);

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 1
	mov	DWORD PTR __Count$[ebp], eax

; 149  : 	_FwdIt _Result = _Dest + _Count;

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Dest$[ebp]
	lea	eax, DWORD PTR [edx+ecx*2]
	mov	DWORD PTR __Result$[ebp], eax

; 150  : 	if (_Count > 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN1@Uninit_cop@21

; 151  : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Count * sizeof (*_First), &*_First, _Count * sizeof (*_First));	// NB: non-overlapping move

	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 1
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 1
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN1@Uninit_cop@21:

; 152  : 	return (_Result);

	mov	eax, DWORD PTR __Result$[ebp]

; 153  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Uninit_copy@PAGPAGV?$allocator@G@std@@@std@@YAPAGPAG00AAV?$allocator@G@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<unsigned short *,unsigned short *,std::allocator<unsigned short> >
_TEXT	ENDS
PUBLIC	??$_Checked_base@V?$_Vector_const_iterator@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBURecord@CullResult@Ogre@@AAV?$_Vector_const_iterator@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::CullResult::Record,std::allocator<Ogre::CullResult::Record> >,std::_Different_checked_iterator_base_type_tag>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Checked_base@V?$_Vector_const_iterator@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@@std@@YAPBURecord@CullResult@Ogre@@AAV?$_Vector_const_iterator@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@0@@Z
_TEXT	SEGMENT
__Base_tag$ = -1					; size = 1
__It$ = 8						; size = 4
??$_Checked_base@V?$_Vector_const_iterator@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@@std@@YAPBURecord@CullResult@Ogre@@AAV?$_Vector_const_iterator@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@0@@Z PROC ; std::_Checked_base<std::_Vector_const_iterator<Ogre::CullResult::Record,std::allocator<Ogre::CullResult::Record> > >, COMDAT

; 1163 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1164 : 		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
; 1165 : 		return _Checked_base(_It, _Base_tag);

	movzx	eax, BYTE PTR __Base_tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR __It$[ebp]
	push	ecx
	call	??$_Checked_base@V?$_Vector_const_iterator@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBURecord@CullResult@Ogre@@AAV?$_Vector_const_iterator@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::CullResult::Record,std::allocator<Ogre::CullResult::Record> >,std::_Different_checked_iterator_base_type_tag>
	add	esp, 8

; 1166 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Checked_base@V?$_Vector_const_iterator@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@@std@@YAPBURecord@CullResult@Ogre@@AAV?$_Vector_const_iterator@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@0@@Z ENDP ; std::_Checked_base<std::_Vector_const_iterator<Ogre::CullResult::Record,std::allocator<Ogre::CullResult::Record> > >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@V?$_Vector_const_iterator@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@PAURecord@CullResult@Ogre@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@0@AAPAURecord@CullResult@Ogre@@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@V?$_Vector_const_iterator@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@PAURecord@CullResult@Ogre@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@0@AAPAURecord@CullResult@Ogre@@@Z PROC ; std::_Ptr_cat<std::_Vector_const_iterator<Ogre::CullResult::Record,std::allocator<Ogre::CullResult::Record> >,Ogre::CullResult::Record *>, COMDAT

; 1509 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 1512 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Ptr_cat@V?$_Vector_const_iterator@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@PAURecord@CullResult@Ogre@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@0@AAPAURecord@CullResult@Ogre@@@Z ENDP ; std::_Ptr_cat<std::_Vector_const_iterator<Ogre::CullResult::Record,std::allocator<Ogre::CullResult::Record> >,Ogre::CullResult::Record *>
_TEXT	ENDS
PUBLIC	?construct@?$allocator@URecord@CullResult@Ogre@@@std@@QAEXPAURecord@CullResult@Ogre@@ABU345@@Z ; std::allocator<Ogre::CullResult::Record>::construct
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	SEGMENT
__catchsym$??$_Uninit_copy@PBURecord@CullResult@Ogre@@PAU123@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@YAPAURecord@CullResult@Ogre@@PBU123@0PAU123@AAV?$allocator@URecord@CullResult@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_copy@PBURecord@CullResult@Ogre@@PAU123@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@YAPAURecord@CullResult@Ogre@@PBU123@0PAU123@AAV?$allocator@URecord@CullResult@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__unwindtable$??$_Uninit_copy@PBURecord@CullResult@Ogre@@PAU123@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@YAPAURecord@CullResult@Ogre@@PBU123@0PAU123@AAV?$allocator@URecord@CullResult@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Uninit_copy@PBURecord@CullResult@Ogre@@PAU123@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@YAPAURecord@CullResult@Ogre@@PBU123@0PAU123@AAV?$allocator@URecord@CullResult@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_copy@PBURecord@CullResult@Ogre@@PAU123@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@YAPAURecord@CullResult@Ogre@@PBU123@0PAU123@AAV?$allocator@URecord@CullResult@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2
__ehfuncinfo$??$_Uninit_copy@PBURecord@CullResult@Ogre@@PAU123@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@YAPAURecord@CullResult@Ogre@@PBU123@0PAU123@AAV?$allocator@URecord@CullResult@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Uninit_copy@PBURecord@CullResult@Ogre@@PAU123@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@YAPAURecord@CullResult@Ogre@@PBU123@0PAU123@AAV?$allocator@URecord@CullResult@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_copy@PBURecord@CullResult@Ogre@@PAU123@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@YAPAURecord@CullResult@Ogre@@PBU123@0PAU123@AAV?$allocator@URecord@CullResult@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??$_Uninit_copy@PBURecord@CullResult@Ogre@@PAU123@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@YAPAURecord@CullResult@Ogre@@PBU123@0PAU123@AAV?$allocator@URecord@CullResult@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PBURecord@CullResult@Ogre@@PAU123@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@YAPAURecord@CullResult@Ogre@@PBU123@0PAU123@AAV?$allocator@URecord@CullResult@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<Ogre::CullResult::Record const *,Ogre::CullResult::Record *,std::allocator<Ogre::CullResult::Record> >, COMDAT

; 124  : 	{	// copy [_First, _Last) to raw _Dest, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_copy@PBURecord@CullResult@Ogre@@PAU123@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@YAPAURecord@CullResult@Ogre@@PBU123@0PAU123@AAV?$allocator@URecord@CullResult@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 125  : 	_DEBUG_RANGE(_First, _Last);
; 126  : 	_DEBUG_POINTER(_Dest);
; 127  : 	_FwdIt _Next = _Dest;

	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Next$[ebp], eax

; 128  : 
; 129  : 	_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 130  : 	for (; _First != _Last; ++_Dest, ++_First)

	jmp	SHORT $LN6@Uninit_cop@22
$LN5@Uninit_cop@22:
	mov	ecx, DWORD PTR __Dest$[ebp]
	add	ecx, 16					; 00000010H
	mov	DWORD PTR __Dest$[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	add	edx, 16					; 00000010H
	mov	DWORD PTR __First$[ebp], edx
$LN6@Uninit_cop@22:
	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Uninit_cop@22

; 131  : 		_Al.construct(_Dest, *_First);

	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?construct@?$allocator@URecord@CullResult@Ogre@@@std@@QAEXPAURecord@CullResult@Ogre@@ABU345@@Z ; std::allocator<Ogre::CullResult::Record>::construct
	jmp	SHORT $LN5@Uninit_cop@22
$LN4@Uninit_cop@22:
	jmp	SHORT $LN10@Uninit_cop@22
__catch$??$_Uninit_copy@PBURecord@CullResult@Ogre@@PAU123@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@YAPAURecord@CullResult@Ogre@@PBU123@0PAU123@AAV?$allocator@URecord@CullResult@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 132  : 	_CATCH_ALL
; 133  : 	for (; _Next != _Dest; ++_Next)

	jmp	SHORT $LN3@Uninit_cop@22
$LN2@Uninit_cop@22:
	mov	eax, DWORD PTR __Next$[ebp]
	add	eax, 16					; 00000010H
	mov	DWORD PTR __Next$[ebp], eax
$LN3@Uninit_cop@22:
	mov	ecx, DWORD PTR __Next$[ebp]
	cmp	ecx, DWORD PTR __Dest$[ebp]
	je	SHORT $LN1@Uninit_cop@22

; 134  : 		_Al.destroy(_Next);

	mov	edx, DWORD PTR __Next$[ebp]
	push	edx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?destroy@?$allocator@URecord@CullResult@Ogre@@@std@@QAEXPAURecord@CullResult@Ogre@@@Z ; std::allocator<Ogre::CullResult::Record>::destroy
	jmp	SHORT $LN2@Uninit_cop@22
$LN1@Uninit_cop@22:

; 135  : 	_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 136  : 	_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$??$_Uninit_copy@PBURecord@CullResult@Ogre@@PAU123@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@YAPAURecord@CullResult@Ogre@@PBU123@0PAU123@AAV?$allocator@URecord@CullResult@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1
	ret	0
$LN10@Uninit_cop@22:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Uninit_copy@PBURecord@CullResult@Ogre@@PAU123@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@YAPAURecord@CullResult@Ogre@@PBU123@0PAU123@AAV?$allocator@URecord@CullResult@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1:

; 137  : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[ebp]
$LN9@Uninit_cop@22:

; 138  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_copy@PBURecord@CullResult@Ogre@@PAU123@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@YAPAURecord@CullResult@Ogre@@PBU123@0PAU123@AAV?$allocator@URecord@CullResult@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_copy@PBURecord@CullResult@Ogre@@PAU123@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@YAPAURecord@CullResult@Ogre@@PBU123@0PAU123@AAV?$allocator@URecord@CullResult@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_copy@PBURecord@CullResult@Ogre@@PAU123@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@YAPAURecord@CullResult@Ogre@@PBU123@0PAU123@AAV?$allocator@URecord@CullResult@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<Ogre::CullResult::Record const *,Ogre::CullResult::Record *,std::allocator<Ogre::CullResult::Record> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Checked_base@PAURecord@CullResult@Ogre@@@std@@YAPAURecord@CullResult@Ogre@@AAPAU123@U_Unchanged_checked_iterator_base_type_tag@0@@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Checked_base@PAURecord@CullResult@Ogre@@@std@@YAPAURecord@CullResult@Ogre@@AAPAU123@U_Unchanged_checked_iterator_base_type_tag@0@@Z PROC ; std::_Checked_base<Ogre::CullResult::Record *>, COMDAT

; 1146 : 	{

	push	ebp
	mov	ebp, esp

; 1147 : 		return _It;

	mov	eax, DWORD PTR __It$[ebp]
	mov	eax, DWORD PTR [eax]

; 1148 : 	}

	pop	ebp
	ret	0
??$_Checked_base@PAURecord@CullResult@Ogre@@@std@@YAPAURecord@CullResult@Ogre@@AAPAU123@U_Unchanged_checked_iterator_base_type_tag@0@@Z ENDP ; std::_Checked_base<Ogre::CullResult::Record *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Copy_opt@PAURecord@CullResult@Ogre@@PAU123@Uforward_iterator_tag@std@@@std@@YAPAURecord@CullResult@Ogre@@PAU123@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAURecord@CullResult@Ogre@@PAU123@Uforward_iterator_tag@std@@@std@@YAPAURecord@CullResult@Ogre@@PAU123@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<Ogre::CullResult::Record *,Ogre::CullResult::Record *,std::forward_iterator_tag>, COMDAT

; 2469 : 	{	// copy [_First, _Last) to [_Dest, ...), arbitrary iterators

	push	ebp
	mov	ebp, esp

; 2470 : 	_DEBUG_RANGE(_First, _Last);
; 2471 : 	for (; _First != _Last; ++_Dest, ++_First)

	jmp	SHORT $LN3@Copy_opt@14
$LN2@Copy_opt@14:
	mov	eax, DWORD PTR __Dest$[ebp]
	add	eax, 16					; 00000010H
	mov	DWORD PTR __Dest$[ebp], eax
	mov	ecx, DWORD PTR __First$[ebp]
	add	ecx, 16					; 00000010H
	mov	DWORD PTR __First$[ebp], ecx
$LN3@Copy_opt@14:
	mov	edx, DWORD PTR __First$[ebp]
	cmp	edx, DWORD PTR __Last$[ebp]
	je	SHORT $LN1@Copy_opt@14

; 2472 : 		*_Dest = *_First;

	mov	eax, DWORD PTR __First$[ebp]
	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], eax
	jmp	SHORT $LN2@Copy_opt@14
$LN1@Copy_opt@14:

; 2473 : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[ebp]

; 2474 : 	}

	pop	ebp
	ret	0
??$_Copy_opt@PAURecord@CullResult@Ogre@@PAU123@Uforward_iterator_tag@std@@@std@@YAPAURecord@CullResult@Ogre@@PAU123@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<Ogre::CullResult::Record *,Ogre::CullResult::Record *,std::forward_iterator_tag>
_TEXT	ENDS
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	SEGMENT
__catchsym$??$_Uninit_copy@PAURecord@CullResult@Ogre@@PAU123@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@YAPAURecord@CullResult@Ogre@@PAU123@00AAV?$allocator@URecord@CullResult@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_copy@PAURecord@CullResult@Ogre@@PAU123@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@YAPAURecord@CullResult@Ogre@@PAU123@00AAV?$allocator@URecord@CullResult@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__unwindtable$??$_Uninit_copy@PAURecord@CullResult@Ogre@@PAU123@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@YAPAURecord@CullResult@Ogre@@PAU123@00AAV?$allocator@URecord@CullResult@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Uninit_copy@PAURecord@CullResult@Ogre@@PAU123@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@YAPAURecord@CullResult@Ogre@@PAU123@00AAV?$allocator@URecord@CullResult@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_copy@PAURecord@CullResult@Ogre@@PAU123@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@YAPAURecord@CullResult@Ogre@@PAU123@00AAV?$allocator@URecord@CullResult@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2
__ehfuncinfo$??$_Uninit_copy@PAURecord@CullResult@Ogre@@PAU123@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@YAPAURecord@CullResult@Ogre@@PAU123@00AAV?$allocator@URecord@CullResult@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Uninit_copy@PAURecord@CullResult@Ogre@@PAU123@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@YAPAURecord@CullResult@Ogre@@PAU123@00AAV?$allocator@URecord@CullResult@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_copy@PAURecord@CullResult@Ogre@@PAU123@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@YAPAURecord@CullResult@Ogre@@PAU123@00AAV?$allocator@URecord@CullResult@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??$_Uninit_copy@PAURecord@CullResult@Ogre@@PAU123@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@YAPAURecord@CullResult@Ogre@@PAU123@00AAV?$allocator@URecord@CullResult@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PAURecord@CullResult@Ogre@@PAU123@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@YAPAURecord@CullResult@Ogre@@PAU123@00AAV?$allocator@URecord@CullResult@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<Ogre::CullResult::Record *,Ogre::CullResult::Record *,std::allocator<Ogre::CullResult::Record> >, COMDAT

; 124  : 	{	// copy [_First, _Last) to raw _Dest, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_copy@PAURecord@CullResult@Ogre@@PAU123@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@YAPAURecord@CullResult@Ogre@@PAU123@00AAV?$allocator@URecord@CullResult@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 125  : 	_DEBUG_RANGE(_First, _Last);
; 126  : 	_DEBUG_POINTER(_Dest);
; 127  : 	_FwdIt _Next = _Dest;

	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Next$[ebp], eax

; 128  : 
; 129  : 	_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 130  : 	for (; _First != _Last; ++_Dest, ++_First)

	jmp	SHORT $LN6@Uninit_cop@23
$LN5@Uninit_cop@23:
	mov	ecx, DWORD PTR __Dest$[ebp]
	add	ecx, 16					; 00000010H
	mov	DWORD PTR __Dest$[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	add	edx, 16					; 00000010H
	mov	DWORD PTR __First$[ebp], edx
$LN6@Uninit_cop@23:
	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Uninit_cop@23

; 131  : 		_Al.construct(_Dest, *_First);

	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?construct@?$allocator@URecord@CullResult@Ogre@@@std@@QAEXPAURecord@CullResult@Ogre@@ABU345@@Z ; std::allocator<Ogre::CullResult::Record>::construct
	jmp	SHORT $LN5@Uninit_cop@23
$LN4@Uninit_cop@23:
	jmp	SHORT $LN10@Uninit_cop@23
__catch$??$_Uninit_copy@PAURecord@CullResult@Ogre@@PAU123@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@YAPAURecord@CullResult@Ogre@@PAU123@00AAV?$allocator@URecord@CullResult@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 132  : 	_CATCH_ALL
; 133  : 	for (; _Next != _Dest; ++_Next)

	jmp	SHORT $LN3@Uninit_cop@23
$LN2@Uninit_cop@23:
	mov	eax, DWORD PTR __Next$[ebp]
	add	eax, 16					; 00000010H
	mov	DWORD PTR __Next$[ebp], eax
$LN3@Uninit_cop@23:
	mov	ecx, DWORD PTR __Next$[ebp]
	cmp	ecx, DWORD PTR __Dest$[ebp]
	je	SHORT $LN1@Uninit_cop@23

; 134  : 		_Al.destroy(_Next);

	mov	edx, DWORD PTR __Next$[ebp]
	push	edx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?destroy@?$allocator@URecord@CullResult@Ogre@@@std@@QAEXPAURecord@CullResult@Ogre@@@Z ; std::allocator<Ogre::CullResult::Record>::destroy
	jmp	SHORT $LN2@Uninit_cop@23
$LN1@Uninit_cop@23:

; 135  : 	_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 136  : 	_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$??$_Uninit_copy@PAURecord@CullResult@Ogre@@PAU123@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@YAPAURecord@CullResult@Ogre@@PAU123@00AAV?$allocator@URecord@CullResult@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1
	ret	0
$LN10@Uninit_cop@23:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Uninit_copy@PAURecord@CullResult@Ogre@@PAU123@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@YAPAURecord@CullResult@Ogre@@PAU123@00AAV?$allocator@URecord@CullResult@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1:

; 137  : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[ebp]
$LN9@Uninit_cop@23:

; 138  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_copy@PAURecord@CullResult@Ogre@@PAU123@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@YAPAURecord@CullResult@Ogre@@PAU123@00AAV?$allocator@URecord@CullResult@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_copy@PAURecord@CullResult@Ogre@@PAU123@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@YAPAURecord@CullResult@Ogre@@PAU123@00AAV?$allocator@URecord@CullResult@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_copy@PAURecord@CullResult@Ogre@@PAU123@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@YAPAURecord@CullResult@Ogre@@PAU123@00AAV?$allocator@URecord@CullResult@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<Ogre::CullResult::Record *,Ogre::CullResult::Record *,std::allocator<Ogre::CullResult::Record> >
PUBLIC	??$_Checked_base@V?$_Vector_const_iterator@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBQAVEffectObject@Ogre@@AAV?$_Vector_const_iterator@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::EffectObject *,std::allocator<Ogre::EffectObject *> >,std::_Different_checked_iterator_base_type_tag>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Checked_base@V?$_Vector_const_iterator@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@@std@@YAPBQAVEffectObject@Ogre@@AAV?$_Vector_const_iterator@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@0@@Z
_TEXT	SEGMENT
__Base_tag$ = -1					; size = 1
__It$ = 8						; size = 4
??$_Checked_base@V?$_Vector_const_iterator@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@@std@@YAPBQAVEffectObject@Ogre@@AAV?$_Vector_const_iterator@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@0@@Z PROC ; std::_Checked_base<std::_Vector_const_iterator<Ogre::EffectObject *,std::allocator<Ogre::EffectObject *> > >, COMDAT

; 1163 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1164 : 		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
; 1165 : 		return _Checked_base(_It, _Base_tag);

	movzx	eax, BYTE PTR __Base_tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR __It$[ebp]
	push	ecx
	call	??$_Checked_base@V?$_Vector_const_iterator@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBQAVEffectObject@Ogre@@AAV?$_Vector_const_iterator@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::EffectObject *,std::allocator<Ogre::EffectObject *> >,std::_Different_checked_iterator_base_type_tag>
	add	esp, 8

; 1166 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Checked_base@V?$_Vector_const_iterator@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@@std@@YAPBQAVEffectObject@Ogre@@AAV?$_Vector_const_iterator@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@0@@Z ENDP ; std::_Checked_base<std::_Vector_const_iterator<Ogre::EffectObject *,std::allocator<Ogre::EffectObject *> > >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@V?$_Vector_const_iterator@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@PAPAVEffectObject@Ogre@@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@0@AAPAPAVEffectObject@Ogre@@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@V?$_Vector_const_iterator@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@PAPAVEffectObject@Ogre@@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@0@AAPAPAVEffectObject@Ogre@@@Z PROC ; std::_Ptr_cat<std::_Vector_const_iterator<Ogre::EffectObject *,std::allocator<Ogre::EffectObject *> >,Ogre::EffectObject * *>, COMDAT

; 1509 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 1512 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Ptr_cat@V?$_Vector_const_iterator@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@PAPAVEffectObject@Ogre@@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@0@AAPAPAVEffectObject@Ogre@@@Z ENDP ; std::_Ptr_cat<std::_Vector_const_iterator<Ogre::EffectObject *,std::allocator<Ogre::EffectObject *> >,Ogre::EffectObject * *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@PBQAVEffectObject@Ogre@@PAPAV12@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@YAPAPAVEffectObject@Ogre@@PBQAV12@0PAPAV12@AAV?$allocator@PAVEffectObject@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Result$ = -8						; size = 4
__Count$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PBQAVEffectObject@Ogre@@PAPAV12@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@YAPAPAVEffectObject@Ogre@@PBQAV12@0PAPAV12@AAV?$allocator@PAVEffectObject@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<Ogre::EffectObject * const *,Ogre::EffectObject * *,std::allocator<Ogre::EffectObject *> >, COMDAT

; 145  : 	{	// copy [_First, _Last) to raw _Dest, scalar type

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 146  : 	_DEBUG_RANGE(_First, _Last);
; 147  : 	_DEBUG_POINTER(_Dest);
; 148  : 	size_t _Count = (size_t)(_Last - _First);

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 2
	mov	DWORD PTR __Count$[ebp], eax

; 149  : 	_FwdIt _Result = _Dest + _Count;

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Dest$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR __Result$[ebp], eax

; 150  : 	if (_Count > 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN1@Uninit_cop@24

; 151  : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Count * sizeof (*_First), &*_First, _Count * sizeof (*_First));	// NB: non-overlapping move

	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN1@Uninit_cop@24:

; 152  : 	return (_Result);

	mov	eax, DWORD PTR __Result$[ebp]

; 153  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Uninit_copy@PBQAVEffectObject@Ogre@@PAPAV12@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@YAPAPAVEffectObject@Ogre@@PBQAV12@0PAPAV12@AAV?$allocator@PAVEffectObject@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<Ogre::EffectObject * const *,Ogre::EffectObject * *,std::allocator<Ogre::EffectObject *> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Checked_base@PAPAVEffectObject@Ogre@@@std@@YAPAPAVEffectObject@Ogre@@AAPAPAV12@U_Unchanged_checked_iterator_base_type_tag@0@@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Checked_base@PAPAVEffectObject@Ogre@@@std@@YAPAPAVEffectObject@Ogre@@AAPAPAV12@U_Unchanged_checked_iterator_base_type_tag@0@@Z PROC ; std::_Checked_base<Ogre::EffectObject * *>, COMDAT

; 1146 : 	{

	push	ebp
	mov	ebp, esp

; 1147 : 		return _It;

	mov	eax, DWORD PTR __It$[ebp]
	mov	eax, DWORD PTR [eax]

; 1148 : 	}

	pop	ebp
	ret	0
??$_Checked_base@PAPAVEffectObject@Ogre@@@std@@YAPAPAVEffectObject@Ogre@@AAPAPAV12@U_Unchanged_checked_iterator_base_type_tag@0@@Z ENDP ; std::_Checked_base<Ogre::EffectObject * *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@PAPAVEffectObject@Ogre@@PAPAV12@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@YAPAPAVEffectObject@Ogre@@PAPAV12@00AAV?$allocator@PAVEffectObject@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Result$ = -8						; size = 4
__Count$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PAPAVEffectObject@Ogre@@PAPAV12@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@YAPAPAVEffectObject@Ogre@@PAPAV12@00AAV?$allocator@PAVEffectObject@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<Ogre::EffectObject * *,Ogre::EffectObject * *,std::allocator<Ogre::EffectObject *> >, COMDAT

; 145  : 	{	// copy [_First, _Last) to raw _Dest, scalar type

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 146  : 	_DEBUG_RANGE(_First, _Last);
; 147  : 	_DEBUG_POINTER(_Dest);
; 148  : 	size_t _Count = (size_t)(_Last - _First);

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 2
	mov	DWORD PTR __Count$[ebp], eax

; 149  : 	_FwdIt _Result = _Dest + _Count;

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Dest$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR __Result$[ebp], eax

; 150  : 	if (_Count > 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN1@Uninit_cop@25

; 151  : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Count * sizeof (*_First), &*_First, _Count * sizeof (*_First));	// NB: non-overlapping move

	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN1@Uninit_cop@25:

; 152  : 	return (_Result);

	mov	eax, DWORD PTR __Result$[ebp]

; 153  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Uninit_copy@PAPAVEffectObject@Ogre@@PAPAV12@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@YAPAPAVEffectObject@Ogre@@PAPAV12@00AAV?$allocator@PAVEffectObject@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<Ogre::EffectObject * *,Ogre::EffectObject * *,std::allocator<Ogre::EffectObject *> >
_TEXT	ENDS
PUBLIC	??$_Checked_base@V?$_Vector_const_iterator@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBQAVSoundNode@Ogre@@AAV?$_Vector_const_iterator@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::SoundNode *,std::allocator<Ogre::SoundNode *> >,std::_Different_checked_iterator_base_type_tag>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Checked_base@V?$_Vector_const_iterator@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@@std@@YAPBQAVSoundNode@Ogre@@AAV?$_Vector_const_iterator@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@0@@Z
_TEXT	SEGMENT
__Base_tag$ = -1					; size = 1
__It$ = 8						; size = 4
??$_Checked_base@V?$_Vector_const_iterator@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@@std@@YAPBQAVSoundNode@Ogre@@AAV?$_Vector_const_iterator@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@0@@Z PROC ; std::_Checked_base<std::_Vector_const_iterator<Ogre::SoundNode *,std::allocator<Ogre::SoundNode *> > >, COMDAT

; 1163 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1164 : 		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
; 1165 : 		return _Checked_base(_It, _Base_tag);

	movzx	eax, BYTE PTR __Base_tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR __It$[ebp]
	push	ecx
	call	??$_Checked_base@V?$_Vector_const_iterator@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBQAVSoundNode@Ogre@@AAV?$_Vector_const_iterator@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::SoundNode *,std::allocator<Ogre::SoundNode *> >,std::_Different_checked_iterator_base_type_tag>
	add	esp, 8

; 1166 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Checked_base@V?$_Vector_const_iterator@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@@std@@YAPBQAVSoundNode@Ogre@@AAV?$_Vector_const_iterator@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@0@@Z ENDP ; std::_Checked_base<std::_Vector_const_iterator<Ogre::SoundNode *,std::allocator<Ogre::SoundNode *> > >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@V?$_Vector_const_iterator@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@PAPAVSoundNode@Ogre@@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@0@AAPAPAVSoundNode@Ogre@@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@V?$_Vector_const_iterator@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@PAPAVSoundNode@Ogre@@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@0@AAPAPAVSoundNode@Ogre@@@Z PROC ; std::_Ptr_cat<std::_Vector_const_iterator<Ogre::SoundNode *,std::allocator<Ogre::SoundNode *> >,Ogre::SoundNode * *>, COMDAT

; 1509 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 1512 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Ptr_cat@V?$_Vector_const_iterator@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@PAPAVSoundNode@Ogre@@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@0@AAPAPAVSoundNode@Ogre@@@Z ENDP ; std::_Ptr_cat<std::_Vector_const_iterator<Ogre::SoundNode *,std::allocator<Ogre::SoundNode *> >,Ogre::SoundNode * *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@PBQAVSoundNode@Ogre@@PAPAV12@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@YAPAPAVSoundNode@Ogre@@PBQAV12@0PAPAV12@AAV?$allocator@PAVSoundNode@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Result$ = -8						; size = 4
__Count$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PBQAVSoundNode@Ogre@@PAPAV12@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@YAPAPAVSoundNode@Ogre@@PBQAV12@0PAPAV12@AAV?$allocator@PAVSoundNode@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<Ogre::SoundNode * const *,Ogre::SoundNode * *,std::allocator<Ogre::SoundNode *> >, COMDAT

; 145  : 	{	// copy [_First, _Last) to raw _Dest, scalar type

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 146  : 	_DEBUG_RANGE(_First, _Last);
; 147  : 	_DEBUG_POINTER(_Dest);
; 148  : 	size_t _Count = (size_t)(_Last - _First);

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 2
	mov	DWORD PTR __Count$[ebp], eax

; 149  : 	_FwdIt _Result = _Dest + _Count;

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Dest$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR __Result$[ebp], eax

; 150  : 	if (_Count > 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN1@Uninit_cop@26

; 151  : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Count * sizeof (*_First), &*_First, _Count * sizeof (*_First));	// NB: non-overlapping move

	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN1@Uninit_cop@26:

; 152  : 	return (_Result);

	mov	eax, DWORD PTR __Result$[ebp]

; 153  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Uninit_copy@PBQAVSoundNode@Ogre@@PAPAV12@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@YAPAPAVSoundNode@Ogre@@PBQAV12@0PAPAV12@AAV?$allocator@PAVSoundNode@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<Ogre::SoundNode * const *,Ogre::SoundNode * *,std::allocator<Ogre::SoundNode *> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Checked_base@PAPAVSoundNode@Ogre@@@std@@YAPAPAVSoundNode@Ogre@@AAPAPAV12@U_Unchanged_checked_iterator_base_type_tag@0@@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Checked_base@PAPAVSoundNode@Ogre@@@std@@YAPAPAVSoundNode@Ogre@@AAPAPAV12@U_Unchanged_checked_iterator_base_type_tag@0@@Z PROC ; std::_Checked_base<Ogre::SoundNode * *>, COMDAT

; 1146 : 	{

	push	ebp
	mov	ebp, esp

; 1147 : 		return _It;

	mov	eax, DWORD PTR __It$[ebp]
	mov	eax, DWORD PTR [eax]

; 1148 : 	}

	pop	ebp
	ret	0
??$_Checked_base@PAPAVSoundNode@Ogre@@@std@@YAPAPAVSoundNode@Ogre@@AAPAPAV12@U_Unchanged_checked_iterator_base_type_tag@0@@Z ENDP ; std::_Checked_base<Ogre::SoundNode * *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@PAPAVSoundNode@Ogre@@PAPAV12@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@YAPAPAVSoundNode@Ogre@@PAPAV12@00AAV?$allocator@PAVSoundNode@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Result$ = -8						; size = 4
__Count$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PAPAVSoundNode@Ogre@@PAPAV12@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@YAPAPAVSoundNode@Ogre@@PAPAV12@00AAV?$allocator@PAVSoundNode@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<Ogre::SoundNode * *,Ogre::SoundNode * *,std::allocator<Ogre::SoundNode *> >, COMDAT

; 145  : 	{	// copy [_First, _Last) to raw _Dest, scalar type

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 146  : 	_DEBUG_RANGE(_First, _Last);
; 147  : 	_DEBUG_POINTER(_Dest);
; 148  : 	size_t _Count = (size_t)(_Last - _First);

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 2
	mov	DWORD PTR __Count$[ebp], eax

; 149  : 	_FwdIt _Result = _Dest + _Count;

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Dest$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR __Result$[ebp], eax

; 150  : 	if (_Count > 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN1@Uninit_cop@27

; 151  : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Count * sizeof (*_First), &*_First, _Count * sizeof (*_First));	// NB: non-overlapping move

	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN1@Uninit_cop@27:

; 152  : 	return (_Result);

	mov	eax, DWORD PTR __Result$[ebp]

; 153  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Uninit_copy@PAPAVSoundNode@Ogre@@PAPAV12@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@YAPAPAVSoundNode@Ogre@@PAPAV12@00AAV?$allocator@PAVSoundNode@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<Ogre::SoundNode * *,Ogre::SoundNode * *,std::allocator<Ogre::SoundNode *> >
_TEXT	ENDS
PUBLIC	??$_Checked_base@V?$_Vector_const_iterator@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBQAVRenderableObject@Ogre@@AAV?$_Vector_const_iterator@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::RenderableObject *,std::allocator<Ogre::RenderableObject *> >,std::_Different_checked_iterator_base_type_tag>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Checked_base@V?$_Vector_const_iterator@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@@std@@YAPBQAVRenderableObject@Ogre@@AAV?$_Vector_const_iterator@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@0@@Z
_TEXT	SEGMENT
__Base_tag$ = -1					; size = 1
__It$ = 8						; size = 4
??$_Checked_base@V?$_Vector_const_iterator@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@@std@@YAPBQAVRenderableObject@Ogre@@AAV?$_Vector_const_iterator@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@0@@Z PROC ; std::_Checked_base<std::_Vector_const_iterator<Ogre::RenderableObject *,std::allocator<Ogre::RenderableObject *> > >, COMDAT

; 1163 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1164 : 		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
; 1165 : 		return _Checked_base(_It, _Base_tag);

	movzx	eax, BYTE PTR __Base_tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR __It$[ebp]
	push	ecx
	call	??$_Checked_base@V?$_Vector_const_iterator@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBQAVRenderableObject@Ogre@@AAV?$_Vector_const_iterator@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::RenderableObject *,std::allocator<Ogre::RenderableObject *> >,std::_Different_checked_iterator_base_type_tag>
	add	esp, 8

; 1166 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Checked_base@V?$_Vector_const_iterator@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@@std@@YAPBQAVRenderableObject@Ogre@@AAV?$_Vector_const_iterator@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@0@@Z ENDP ; std::_Checked_base<std::_Vector_const_iterator<Ogre::RenderableObject *,std::allocator<Ogre::RenderableObject *> > >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@V?$_Vector_const_iterator@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@PAPAVRenderableObject@Ogre@@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@0@AAPAPAVRenderableObject@Ogre@@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@V?$_Vector_const_iterator@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@PAPAVRenderableObject@Ogre@@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@0@AAPAPAVRenderableObject@Ogre@@@Z PROC ; std::_Ptr_cat<std::_Vector_const_iterator<Ogre::RenderableObject *,std::allocator<Ogre::RenderableObject *> >,Ogre::RenderableObject * *>, COMDAT

; 1509 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 1512 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Ptr_cat@V?$_Vector_const_iterator@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@PAPAVRenderableObject@Ogre@@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@0@AAPAPAVRenderableObject@Ogre@@@Z ENDP ; std::_Ptr_cat<std::_Vector_const_iterator<Ogre::RenderableObject *,std::allocator<Ogre::RenderableObject *> >,Ogre::RenderableObject * *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@PBQAVRenderableObject@Ogre@@PAPAV12@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@YAPAPAVRenderableObject@Ogre@@PBQAV12@0PAPAV12@AAV?$allocator@PAVRenderableObject@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Result$ = -8						; size = 4
__Count$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PBQAVRenderableObject@Ogre@@PAPAV12@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@YAPAPAVRenderableObject@Ogre@@PBQAV12@0PAPAV12@AAV?$allocator@PAVRenderableObject@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<Ogre::RenderableObject * const *,Ogre::RenderableObject * *,std::allocator<Ogre::RenderableObject *> >, COMDAT

; 145  : 	{	// copy [_First, _Last) to raw _Dest, scalar type

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 146  : 	_DEBUG_RANGE(_First, _Last);
; 147  : 	_DEBUG_POINTER(_Dest);
; 148  : 	size_t _Count = (size_t)(_Last - _First);

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 2
	mov	DWORD PTR __Count$[ebp], eax

; 149  : 	_FwdIt _Result = _Dest + _Count;

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Dest$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR __Result$[ebp], eax

; 150  : 	if (_Count > 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN1@Uninit_cop@28

; 151  : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Count * sizeof (*_First), &*_First, _Count * sizeof (*_First));	// NB: non-overlapping move

	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN1@Uninit_cop@28:

; 152  : 	return (_Result);

	mov	eax, DWORD PTR __Result$[ebp]

; 153  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Uninit_copy@PBQAVRenderableObject@Ogre@@PAPAV12@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@YAPAPAVRenderableObject@Ogre@@PBQAV12@0PAPAV12@AAV?$allocator@PAVRenderableObject@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<Ogre::RenderableObject * const *,Ogre::RenderableObject * *,std::allocator<Ogre::RenderableObject *> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Checked_base@PAPAVRenderableObject@Ogre@@@std@@YAPAPAVRenderableObject@Ogre@@AAPAPAV12@U_Unchanged_checked_iterator_base_type_tag@0@@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Checked_base@PAPAVRenderableObject@Ogre@@@std@@YAPAPAVRenderableObject@Ogre@@AAPAPAV12@U_Unchanged_checked_iterator_base_type_tag@0@@Z PROC ; std::_Checked_base<Ogre::RenderableObject * *>, COMDAT

; 1146 : 	{

	push	ebp
	mov	ebp, esp

; 1147 : 		return _It;

	mov	eax, DWORD PTR __It$[ebp]
	mov	eax, DWORD PTR [eax]

; 1148 : 	}

	pop	ebp
	ret	0
??$_Checked_base@PAPAVRenderableObject@Ogre@@@std@@YAPAPAVRenderableObject@Ogre@@AAPAPAV12@U_Unchanged_checked_iterator_base_type_tag@0@@Z ENDP ; std::_Checked_base<Ogre::RenderableObject * *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@PAPAVRenderableObject@Ogre@@PAPAV12@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@YAPAPAVRenderableObject@Ogre@@PAPAV12@00AAV?$allocator@PAVRenderableObject@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Result$ = -8						; size = 4
__Count$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PAPAVRenderableObject@Ogre@@PAPAV12@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@YAPAPAVRenderableObject@Ogre@@PAPAV12@00AAV?$allocator@PAVRenderableObject@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<Ogre::RenderableObject * *,Ogre::RenderableObject * *,std::allocator<Ogre::RenderableObject *> >, COMDAT

; 145  : 	{	// copy [_First, _Last) to raw _Dest, scalar type

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 146  : 	_DEBUG_RANGE(_First, _Last);
; 147  : 	_DEBUG_POINTER(_Dest);
; 148  : 	size_t _Count = (size_t)(_Last - _First);

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 2
	mov	DWORD PTR __Count$[ebp], eax

; 149  : 	_FwdIt _Result = _Dest + _Count;

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Dest$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR __Result$[ebp], eax

; 150  : 	if (_Count > 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN1@Uninit_cop@29

; 151  : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Count * sizeof (*_First), &*_First, _Count * sizeof (*_First));	// NB: non-overlapping move

	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN1@Uninit_cop@29:

; 152  : 	return (_Result);

	mov	eax, DWORD PTR __Result$[ebp]

; 153  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Uninit_copy@PAPAVRenderableObject@Ogre@@PAPAV12@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@YAPAPAVRenderableObject@Ogre@@PAPAV12@00AAV?$allocator@PAVRenderableObject@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<Ogre::RenderableObject * *,Ogre::RenderableObject * *,std::allocator<Ogre::RenderableObject *> >
_TEXT	ENDS
PUBLIC	??$_Checked_base@V?$_Vector_const_iterator@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBQAVLight@Ogre@@AAV?$_Vector_const_iterator@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::Light *,std::allocator<Ogre::Light *> >,std::_Different_checked_iterator_base_type_tag>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Checked_base@V?$_Vector_const_iterator@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@@std@@YAPBQAVLight@Ogre@@AAV?$_Vector_const_iterator@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@0@@Z
_TEXT	SEGMENT
__Base_tag$ = -1					; size = 1
__It$ = 8						; size = 4
??$_Checked_base@V?$_Vector_const_iterator@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@@std@@YAPBQAVLight@Ogre@@AAV?$_Vector_const_iterator@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@0@@Z PROC ; std::_Checked_base<std::_Vector_const_iterator<Ogre::Light *,std::allocator<Ogre::Light *> > >, COMDAT

; 1163 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1164 : 		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
; 1165 : 		return _Checked_base(_It, _Base_tag);

	movzx	eax, BYTE PTR __Base_tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR __It$[ebp]
	push	ecx
	call	??$_Checked_base@V?$_Vector_const_iterator@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBQAVLight@Ogre@@AAV?$_Vector_const_iterator@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Ogre::Light *,std::allocator<Ogre::Light *> >,std::_Different_checked_iterator_base_type_tag>
	add	esp, 8

; 1166 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Checked_base@V?$_Vector_const_iterator@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@@std@@YAPBQAVLight@Ogre@@AAV?$_Vector_const_iterator@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@0@@Z ENDP ; std::_Checked_base<std::_Vector_const_iterator<Ogre::Light *,std::allocator<Ogre::Light *> > >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@V?$_Vector_const_iterator@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@PAPAVLight@Ogre@@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@0@AAPAPAVLight@Ogre@@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@V?$_Vector_const_iterator@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@PAPAVLight@Ogre@@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@0@AAPAPAVLight@Ogre@@@Z PROC ; std::_Ptr_cat<std::_Vector_const_iterator<Ogre::Light *,std::allocator<Ogre::Light *> >,Ogre::Light * *>, COMDAT

; 1509 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 1512 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Ptr_cat@V?$_Vector_const_iterator@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@PAPAVLight@Ogre@@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@0@AAPAPAVLight@Ogre@@@Z ENDP ; std::_Ptr_cat<std::_Vector_const_iterator<Ogre::Light *,std::allocator<Ogre::Light *> >,Ogre::Light * *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@PBQAVLight@Ogre@@PAPAV12@V?$allocator@PAVLight@Ogre@@@std@@@std@@YAPAPAVLight@Ogre@@PBQAV12@0PAPAV12@AAV?$allocator@PAVLight@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Result$ = -8						; size = 4
__Count$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PBQAVLight@Ogre@@PAPAV12@V?$allocator@PAVLight@Ogre@@@std@@@std@@YAPAPAVLight@Ogre@@PBQAV12@0PAPAV12@AAV?$allocator@PAVLight@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<Ogre::Light * const *,Ogre::Light * *,std::allocator<Ogre::Light *> >, COMDAT

; 145  : 	{	// copy [_First, _Last) to raw _Dest, scalar type

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 146  : 	_DEBUG_RANGE(_First, _Last);
; 147  : 	_DEBUG_POINTER(_Dest);
; 148  : 	size_t _Count = (size_t)(_Last - _First);

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 2
	mov	DWORD PTR __Count$[ebp], eax

; 149  : 	_FwdIt _Result = _Dest + _Count;

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Dest$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR __Result$[ebp], eax

; 150  : 	if (_Count > 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN1@Uninit_cop@30

; 151  : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Count * sizeof (*_First), &*_First, _Count * sizeof (*_First));	// NB: non-overlapping move

	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN1@Uninit_cop@30:

; 152  : 	return (_Result);

	mov	eax, DWORD PTR __Result$[ebp]

; 153  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Uninit_copy@PBQAVLight@Ogre@@PAPAV12@V?$allocator@PAVLight@Ogre@@@std@@@std@@YAPAPAVLight@Ogre@@PBQAV12@0PAPAV12@AAV?$allocator@PAVLight@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<Ogre::Light * const *,Ogre::Light * *,std::allocator<Ogre::Light *> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Checked_base@PAPAVLight@Ogre@@@std@@YAPAPAVLight@Ogre@@AAPAPAV12@U_Unchanged_checked_iterator_base_type_tag@0@@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Checked_base@PAPAVLight@Ogre@@@std@@YAPAPAVLight@Ogre@@AAPAPAV12@U_Unchanged_checked_iterator_base_type_tag@0@@Z PROC ; std::_Checked_base<Ogre::Light * *>, COMDAT

; 1146 : 	{

	push	ebp
	mov	ebp, esp

; 1147 : 		return _It;

	mov	eax, DWORD PTR __It$[ebp]
	mov	eax, DWORD PTR [eax]

; 1148 : 	}

	pop	ebp
	ret	0
??$_Checked_base@PAPAVLight@Ogre@@@std@@YAPAPAVLight@Ogre@@AAPAPAV12@U_Unchanged_checked_iterator_base_type_tag@0@@Z ENDP ; std::_Checked_base<Ogre::Light * *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@PAPAVLight@Ogre@@PAPAV12@V?$allocator@PAVLight@Ogre@@@std@@@std@@YAPAPAVLight@Ogre@@PAPAV12@00AAV?$allocator@PAVLight@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Result$ = -8						; size = 4
__Count$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PAPAVLight@Ogre@@PAPAV12@V?$allocator@PAVLight@Ogre@@@std@@@std@@YAPAPAVLight@Ogre@@PAPAV12@00AAV?$allocator@PAVLight@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<Ogre::Light * *,Ogre::Light * *,std::allocator<Ogre::Light *> >, COMDAT

; 145  : 	{	// copy [_First, _Last) to raw _Dest, scalar type

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 146  : 	_DEBUG_RANGE(_First, _Last);
; 147  : 	_DEBUG_POINTER(_Dest);
; 148  : 	size_t _Count = (size_t)(_Last - _First);

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 2
	mov	DWORD PTR __Count$[ebp], eax

; 149  : 	_FwdIt _Result = _Dest + _Count;

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Dest$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR __Result$[ebp], eax

; 150  : 	if (_Count > 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN1@Uninit_cop@31

; 151  : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Count * sizeof (*_First), &*_First, _Count * sizeof (*_First));	// NB: non-overlapping move

	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN1@Uninit_cop@31:

; 152  : 	return (_Result);

	mov	eax, DWORD PTR __Result$[ebp]

; 153  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Uninit_copy@PAPAVLight@Ogre@@PAPAV12@V?$allocator@PAVLight@Ogre@@@std@@@std@@YAPAPAVLight@Ogre@@PAPAV12@00AAV?$allocator@PAVLight@Ogre@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<Ogre::Light * *,Ogre::Light * *,std::allocator<Ogre::Light *> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Checked_base@PAUAnimRange@BaseKeyFrameArray@Ogre@@@std@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@AAPAU123@U_Unchanged_checked_iterator_base_type_tag@0@@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Checked_base@PAUAnimRange@BaseKeyFrameArray@Ogre@@@std@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@AAPAU123@U_Unchanged_checked_iterator_base_type_tag@0@@Z PROC ; std::_Checked_base<Ogre::BaseKeyFrameArray::AnimRange *>, COMDAT

; 1146 : 	{

	push	ebp
	mov	ebp, esp

; 1147 : 		return _It;

	mov	eax, DWORD PTR __It$[ebp]
	mov	eax, DWORD PTR [eax]

; 1148 : 	}

	pop	ebp
	ret	0
??$_Checked_base@PAUAnimRange@BaseKeyFrameArray@Ogre@@@std@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@AAPAU123@U_Unchanged_checked_iterator_base_type_tag@0@@Z ENDP ; std::_Checked_base<Ogre::BaseKeyFrameArray::AnimRange *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Copy_opt@PAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@Uforward_iterator_tag@std@@@std@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@Uforward_iterator_tag@std@@@std@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<Ogre::BaseKeyFrameArray::AnimRange *,Ogre::BaseKeyFrameArray::AnimRange *,std::forward_iterator_tag>, COMDAT

; 2469 : 	{	// copy [_First, _Last) to [_Dest, ...), arbitrary iterators

	push	ebp
	mov	ebp, esp

; 2470 : 	_DEBUG_RANGE(_First, _Last);
; 2471 : 	for (; _First != _Last; ++_Dest, ++_First)

	jmp	SHORT $LN3@Copy_opt@15
$LN2@Copy_opt@15:
	mov	eax, DWORD PTR __Dest$[ebp]
	add	eax, 8
	mov	DWORD PTR __Dest$[ebp], eax
	mov	ecx, DWORD PTR __First$[ebp]
	add	ecx, 8
	mov	DWORD PTR __First$[ebp], ecx
$LN3@Copy_opt@15:
	mov	edx, DWORD PTR __First$[ebp]
	cmp	edx, DWORD PTR __Last$[ebp]
	je	SHORT $LN1@Copy_opt@15

; 2472 : 		*_Dest = *_First;

	mov	eax, DWORD PTR __First$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	jmp	SHORT $LN2@Copy_opt@15
$LN1@Copy_opt@15:

; 2473 : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[ebp]

; 2474 : 	}

	pop	ebp
	ret	0
??$_Copy_opt@PAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@Uforward_iterator_tag@std@@@std@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<Ogre::BaseKeyFrameArray::AnimRange *,Ogre::BaseKeyFrameArray::AnimRange *,std::forward_iterator_tag>
_TEXT	ENDS
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	SEGMENT
__catchsym$??$_Uninit_copy@PAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@00AAV?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_copy@PAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@00AAV?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__unwindtable$??$_Uninit_copy@PAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@00AAV?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Uninit_copy@PAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@00AAV?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_copy@PAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@00AAV?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2
__ehfuncinfo$??$_Uninit_copy@PAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@00AAV?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Uninit_copy@PAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@00AAV?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_copy@PAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@00AAV?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??$_Uninit_copy@PAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@00AAV?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@00AAV?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<Ogre::BaseKeyFrameArray::AnimRange *,Ogre::BaseKeyFrameArray::AnimRange *,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >, COMDAT

; 124  : 	{	// copy [_First, _Last) to raw _Dest, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_copy@PAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@00AAV?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 125  : 	_DEBUG_RANGE(_First, _Last);
; 126  : 	_DEBUG_POINTER(_Dest);
; 127  : 	_FwdIt _Next = _Dest;

	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Next$[ebp], eax

; 128  : 
; 129  : 	_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 130  : 	for (; _First != _Last; ++_Dest, ++_First)

	jmp	SHORT $LN6@Uninit_cop@32
$LN5@Uninit_cop@32:
	mov	ecx, DWORD PTR __Dest$[ebp]
	add	ecx, 8
	mov	DWORD PTR __Dest$[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	add	edx, 8
	mov	DWORD PTR __First$[ebp], edx
$LN6@Uninit_cop@32:
	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Uninit_cop@32

; 131  : 		_Al.construct(_Dest, *_First);

	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?construct@?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@QAEXPAUAnimRange@BaseKeyFrameArray@Ogre@@ABU345@@Z ; std::allocator<Ogre::BaseKeyFrameArray::AnimRange>::construct
	jmp	SHORT $LN5@Uninit_cop@32
$LN4@Uninit_cop@32:
	jmp	SHORT $LN10@Uninit_cop@32
__catch$??$_Uninit_copy@PAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@00AAV?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 132  : 	_CATCH_ALL
; 133  : 	for (; _Next != _Dest; ++_Next)

	jmp	SHORT $LN3@Uninit_cop@32
$LN2@Uninit_cop@32:
	mov	eax, DWORD PTR __Next$[ebp]
	add	eax, 8
	mov	DWORD PTR __Next$[ebp], eax
$LN3@Uninit_cop@32:
	mov	ecx, DWORD PTR __Next$[ebp]
	cmp	ecx, DWORD PTR __Dest$[ebp]
	je	SHORT $LN1@Uninit_cop@32

; 134  : 		_Al.destroy(_Next);

	mov	edx, DWORD PTR __Next$[ebp]
	push	edx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?destroy@?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@QAEXPAUAnimRange@BaseKeyFrameArray@Ogre@@@Z ; std::allocator<Ogre::BaseKeyFrameArray::AnimRange>::destroy
	jmp	SHORT $LN2@Uninit_cop@32
$LN1@Uninit_cop@32:

; 135  : 	_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 136  : 	_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$??$_Uninit_copy@PAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@00AAV?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1
	ret	0
$LN10@Uninit_cop@32:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Uninit_copy@PAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@00AAV?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1:

; 137  : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[ebp]
$LN9@Uninit_cop@32:

; 138  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_copy@PAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@00AAV?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_copy@PAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@00AAV?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_copy@PAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@00AAV?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<Ogre::BaseKeyFrameArray::AnimRange *,Ogre::BaseKeyFrameArray::AnimRange *,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Checked_base@PAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@AAPAU123@U_Unchanged_checked_iterator_base_type_tag@0@@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Checked_base@PAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@AAPAU123@U_Unchanged_checked_iterator_base_type_tag@0@@Z PROC ; std::_Checked_base<Ogre::KeyFrameArray<float>::KEYFRAME_T *>, COMDAT

; 1146 : 	{

	push	ebp
	mov	ebp, esp

; 1147 : 		return _It;

	mov	eax, DWORD PTR __It$[ebp]
	mov	eax, DWORD PTR [eax]

; 1148 : 	}

	pop	ebp
	ret	0
??$_Checked_base@PAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@AAPAU123@U_Unchanged_checked_iterator_base_type_tag@0@@Z ENDP ; std::_Checked_base<Ogre::KeyFrameArray<float>::KEYFRAME_T *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Copy_opt@PAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU123@Uforward_iterator_tag@std@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU123@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU123@Uforward_iterator_tag@std@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU123@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<Ogre::KeyFrameArray<float>::KEYFRAME_T *,Ogre::KeyFrameArray<float>::KEYFRAME_T *,std::forward_iterator_tag>, COMDAT

; 2469 : 	{	// copy [_First, _Last) to [_Dest, ...), arbitrary iterators

	push	ebp
	mov	ebp, esp

; 2470 : 	_DEBUG_RANGE(_First, _Last);
; 2471 : 	for (; _First != _Last; ++_Dest, ++_First)

	jmp	SHORT $LN3@Copy_opt@16
$LN2@Copy_opt@16:
	mov	eax, DWORD PTR __Dest$[ebp]
	add	eax, 8
	mov	DWORD PTR __Dest$[ebp], eax
	mov	ecx, DWORD PTR __First$[ebp]
	add	ecx, 8
	mov	DWORD PTR __First$[ebp], ecx
$LN3@Copy_opt@16:
	mov	edx, DWORD PTR __First$[ebp]
	cmp	edx, DWORD PTR __Last$[ebp]
	je	SHORT $LN1@Copy_opt@16

; 2472 : 		*_Dest = *_First;

	mov	eax, DWORD PTR __First$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	jmp	SHORT $LN2@Copy_opt@16
$LN1@Copy_opt@16:

; 2473 : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[ebp]

; 2474 : 	}

	pop	ebp
	ret	0
??$_Copy_opt@PAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU123@Uforward_iterator_tag@std@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU123@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<Ogre::KeyFrameArray<float>::KEYFRAME_T *,Ogre::KeyFrameArray<float>::KEYFRAME_T *,std::forward_iterator_tag>
_TEXT	ENDS
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	SEGMENT
__catchsym$??$_Uninit_copy@PAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU123@00AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_copy@PAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU123@00AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__unwindtable$??$_Uninit_copy@PAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU123@00AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Uninit_copy@PAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU123@00AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_copy@PAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU123@00AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2
__ehfuncinfo$??$_Uninit_copy@PAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU123@00AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Uninit_copy@PAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU123@00AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_copy@PAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU123@00AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??$_Uninit_copy@PAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU123@00AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU123@00AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<Ogre::KeyFrameArray<float>::KEYFRAME_T *,Ogre::KeyFrameArray<float>::KEYFRAME_T *,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >, COMDAT

; 124  : 	{	// copy [_First, _Last) to raw _Dest, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_copy@PAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU123@00AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 125  : 	_DEBUG_RANGE(_First, _Last);
; 126  : 	_DEBUG_POINTER(_Dest);
; 127  : 	_FwdIt _Next = _Dest;

	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Next$[ebp], eax

; 128  : 
; 129  : 	_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 130  : 	for (; _First != _Last; ++_Dest, ++_First)

	jmp	SHORT $LN6@Uninit_cop@33
$LN5@Uninit_cop@33:
	mov	ecx, DWORD PTR __Dest$[ebp]
	add	ecx, 8
	mov	DWORD PTR __Dest$[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	add	edx, 8
	mov	DWORD PTR __First$[ebp], edx
$LN6@Uninit_cop@33:
	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Uninit_cop@33

; 131  : 		_Al.construct(_Dest, *_First);

	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?construct@?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@QAEXPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@ABU345@@Z ; std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T>::construct
	jmp	SHORT $LN5@Uninit_cop@33
$LN4@Uninit_cop@33:
	jmp	SHORT $LN10@Uninit_cop@33
__catch$??$_Uninit_copy@PAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU123@00AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 132  : 	_CATCH_ALL
; 133  : 	for (; _Next != _Dest; ++_Next)

	jmp	SHORT $LN3@Uninit_cop@33
$LN2@Uninit_cop@33:
	mov	eax, DWORD PTR __Next$[ebp]
	add	eax, 8
	mov	DWORD PTR __Next$[ebp], eax
$LN3@Uninit_cop@33:
	mov	ecx, DWORD PTR __Next$[ebp]
	cmp	ecx, DWORD PTR __Dest$[ebp]
	je	SHORT $LN1@Uninit_cop@33

; 134  : 		_Al.destroy(_Next);

	mov	edx, DWORD PTR __Next$[ebp]
	push	edx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?destroy@?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@QAEXPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@Z ; std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T>::destroy
	jmp	SHORT $LN2@Uninit_cop@33
$LN1@Uninit_cop@33:

; 135  : 	_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 136  : 	_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$??$_Uninit_copy@PAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU123@00AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1
	ret	0
$LN10@Uninit_cop@33:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Uninit_copy@PAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU123@00AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1:

; 137  : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[ebp]
$LN9@Uninit_cop@33:

; 138  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_copy@PAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU123@00AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_copy@PAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU123@00AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_copy@PAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU123@00AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<Ogre::KeyFrameArray<float>::KEYFRAME_T *,Ogre::KeyFrameArray<float>::KEYFRAME_T *,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Checked_base@PAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@AAPAU123@U_Unchanged_checked_iterator_base_type_tag@0@@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Checked_base@PAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@AAPAU123@U_Unchanged_checked_iterator_base_type_tag@0@@Z PROC ; std::_Checked_base<Ogre::KeyFrameArray<float>::CONTROL_POINT_T *>, COMDAT

; 1146 : 	{

	push	ebp
	mov	ebp, esp

; 1147 : 		return _It;

	mov	eax, DWORD PTR __It$[ebp]
	mov	eax, DWORD PTR [eax]

; 1148 : 	}

	pop	ebp
	ret	0
??$_Checked_base@PAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@AAPAU123@U_Unchanged_checked_iterator_base_type_tag@0@@Z ENDP ; std::_Checked_base<Ogre::KeyFrameArray<float>::CONTROL_POINT_T *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Copy_opt@PAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU123@Uforward_iterator_tag@std@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU123@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU123@Uforward_iterator_tag@std@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU123@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<Ogre::KeyFrameArray<float>::CONTROL_POINT_T *,Ogre::KeyFrameArray<float>::CONTROL_POINT_T *,std::forward_iterator_tag>, COMDAT

; 2469 : 	{	// copy [_First, _Last) to [_Dest, ...), arbitrary iterators

	push	ebp
	mov	ebp, esp

; 2470 : 	_DEBUG_RANGE(_First, _Last);
; 2471 : 	for (; _First != _Last; ++_Dest, ++_First)

	jmp	SHORT $LN3@Copy_opt@17
$LN2@Copy_opt@17:
	mov	eax, DWORD PTR __Dest$[ebp]
	add	eax, 8
	mov	DWORD PTR __Dest$[ebp], eax
	mov	ecx, DWORD PTR __First$[ebp]
	add	ecx, 8
	mov	DWORD PTR __First$[ebp], ecx
$LN3@Copy_opt@17:
	mov	edx, DWORD PTR __First$[ebp]
	cmp	edx, DWORD PTR __Last$[ebp]
	je	SHORT $LN1@Copy_opt@17

; 2472 : 		*_Dest = *_First;

	mov	eax, DWORD PTR __First$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	jmp	SHORT $LN2@Copy_opt@17
$LN1@Copy_opt@17:

; 2473 : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[ebp]

; 2474 : 	}

	pop	ebp
	ret	0
??$_Copy_opt@PAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU123@Uforward_iterator_tag@std@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU123@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<Ogre::KeyFrameArray<float>::CONTROL_POINT_T *,Ogre::KeyFrameArray<float>::CONTROL_POINT_T *,std::forward_iterator_tag>
_TEXT	ENDS
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	SEGMENT
__catchsym$??$_Uninit_copy@PAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU123@00AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_copy@PAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU123@00AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__unwindtable$??$_Uninit_copy@PAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU123@00AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Uninit_copy@PAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU123@00AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_copy@PAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU123@00AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2
__ehfuncinfo$??$_Uninit_copy@PAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU123@00AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Uninit_copy@PAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU123@00AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_copy@PAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU123@00AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??$_Uninit_copy@PAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU123@00AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU123@00AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<Ogre::KeyFrameArray<float>::CONTROL_POINT_T *,Ogre::KeyFrameArray<float>::CONTROL_POINT_T *,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >, COMDAT

; 124  : 	{	// copy [_First, _Last) to raw _Dest, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_copy@PAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU123@00AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 125  : 	_DEBUG_RANGE(_First, _Last);
; 126  : 	_DEBUG_POINTER(_Dest);
; 127  : 	_FwdIt _Next = _Dest;

	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Next$[ebp], eax

; 128  : 
; 129  : 	_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 130  : 	for (; _First != _Last; ++_Dest, ++_First)

	jmp	SHORT $LN6@Uninit_cop@34
$LN5@Uninit_cop@34:
	mov	ecx, DWORD PTR __Dest$[ebp]
	add	ecx, 8
	mov	DWORD PTR __Dest$[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	add	edx, 8
	mov	DWORD PTR __First$[ebp], edx
$LN6@Uninit_cop@34:
	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Uninit_cop@34

; 131  : 		_Al.construct(_Dest, *_First);

	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?construct@?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@QAEXPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@ABU345@@Z ; std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T>::construct
	jmp	SHORT $LN5@Uninit_cop@34
$LN4@Uninit_cop@34:
	jmp	SHORT $LN10@Uninit_cop@34
__catch$??$_Uninit_copy@PAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU123@00AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 132  : 	_CATCH_ALL
; 133  : 	for (; _Next != _Dest; ++_Next)

	jmp	SHORT $LN3@Uninit_cop@34
$LN2@Uninit_cop@34:
	mov	eax, DWORD PTR __Next$[ebp]
	add	eax, 8
	mov	DWORD PTR __Next$[ebp], eax
$LN3@Uninit_cop@34:
	mov	ecx, DWORD PTR __Next$[ebp]
	cmp	ecx, DWORD PTR __Dest$[ebp]
	je	SHORT $LN1@Uninit_cop@34

; 134  : 		_Al.destroy(_Next);

	mov	edx, DWORD PTR __Next$[ebp]
	push	edx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?destroy@?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@QAEXPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@Z ; std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T>::destroy
	jmp	SHORT $LN2@Uninit_cop@34
$LN1@Uninit_cop@34:

; 135  : 	_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 136  : 	_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$??$_Uninit_copy@PAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU123@00AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1
	ret	0
$LN10@Uninit_cop@34:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Uninit_copy@PAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU123@00AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1:

; 137  : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[ebp]
$LN9@Uninit_cop@34:

; 138  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_copy@PAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU123@00AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_copy@PAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU123@00AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_copy@PAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU123@00AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<Ogre::KeyFrameArray<float>::CONTROL_POINT_T *,Ogre::KeyFrameArray<float>::CONTROL_POINT_T *,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Checked_base@PAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@AAPAU123@U_Unchanged_checked_iterator_base_type_tag@0@@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Checked_base@PAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@AAPAU123@U_Unchanged_checked_iterator_base_type_tag@0@@Z PROC ; std::_Checked_base<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T *>, COMDAT

; 1146 : 	{

	push	ebp
	mov	ebp, esp

; 1147 : 		return _It;

	mov	eax, DWORD PTR __It$[ebp]
	mov	eax, DWORD PTR [eax]

; 1148 : 	}

	pop	ebp
	ret	0
??$_Checked_base@PAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@AAPAU123@U_Unchanged_checked_iterator_base_type_tag@0@@Z ENDP ; std::_Checked_base<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Copy_opt@PAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@Uforward_iterator_tag@std@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@Uforward_iterator_tag@std@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T *,std::forward_iterator_tag>, COMDAT

; 2469 : 	{	// copy [_First, _Last) to [_Dest, ...), arbitrary iterators

	push	ebp
	mov	ebp, esp

; 2470 : 	_DEBUG_RANGE(_First, _Last);
; 2471 : 	for (; _First != _Last; ++_Dest, ++_First)

	jmp	SHORT $LN3@Copy_opt@18
$LN2@Copy_opt@18:
	mov	eax, DWORD PTR __Dest$[ebp]
	add	eax, 20					; 00000014H
	mov	DWORD PTR __Dest$[ebp], eax
	mov	ecx, DWORD PTR __First$[ebp]
	add	ecx, 20					; 00000014H
	mov	DWORD PTR __First$[ebp], ecx
$LN3@Copy_opt@18:
	mov	edx, DWORD PTR __First$[ebp]
	cmp	edx, DWORD PTR __Last$[ebp]
	je	SHORT $LN1@Copy_opt@18

; 2472 : 		*_Dest = *_First;

	mov	eax, DWORD PTR __First$[ebp]
	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], edx
	mov	eax, DWORD PTR [eax+16]
	mov	DWORD PTR [ecx+16], eax
	jmp	SHORT $LN2@Copy_opt@18
$LN1@Copy_opt@18:

; 2473 : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[ebp]

; 2474 : 	}

	pop	ebp
	ret	0
??$_Copy_opt@PAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@Uforward_iterator_tag@std@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T *,std::forward_iterator_tag>
_TEXT	ENDS
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	SEGMENT
__catchsym$??$_Uninit_copy@PAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_copy@PAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__unwindtable$??$_Uninit_copy@PAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Uninit_copy@PAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_copy@PAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2
__ehfuncinfo$??$_Uninit_copy@PAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Uninit_copy@PAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_copy@PAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??$_Uninit_copy@PAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T *,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >, COMDAT

; 124  : 	{	// copy [_First, _Last) to raw _Dest, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_copy@PAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 125  : 	_DEBUG_RANGE(_First, _Last);
; 126  : 	_DEBUG_POINTER(_Dest);
; 127  : 	_FwdIt _Next = _Dest;

	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Next$[ebp], eax

; 128  : 
; 129  : 	_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 130  : 	for (; _First != _Last; ++_Dest, ++_First)

	jmp	SHORT $LN6@Uninit_cop@35
$LN5@Uninit_cop@35:
	mov	ecx, DWORD PTR __Dest$[ebp]
	add	ecx, 20					; 00000014H
	mov	DWORD PTR __Dest$[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	add	edx, 20					; 00000014H
	mov	DWORD PTR __First$[ebp], edx
$LN6@Uninit_cop@35:
	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Uninit_cop@35

; 131  : 		_Al.construct(_Dest, *_First);

	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?construct@?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@QAEXPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@ABU345@@Z ; std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T>::construct
	jmp	SHORT $LN5@Uninit_cop@35
$LN4@Uninit_cop@35:
	jmp	SHORT $LN10@Uninit_cop@35
__catch$??$_Uninit_copy@PAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 132  : 	_CATCH_ALL
; 133  : 	for (; _Next != _Dest; ++_Next)

	jmp	SHORT $LN3@Uninit_cop@35
$LN2@Uninit_cop@35:
	mov	eax, DWORD PTR __Next$[ebp]
	add	eax, 20					; 00000014H
	mov	DWORD PTR __Next$[ebp], eax
$LN3@Uninit_cop@35:
	mov	ecx, DWORD PTR __Next$[ebp]
	cmp	ecx, DWORD PTR __Dest$[ebp]
	je	SHORT $LN1@Uninit_cop@35

; 134  : 		_Al.destroy(_Next);

	mov	edx, DWORD PTR __Next$[ebp]
	push	edx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?destroy@?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@QAEXPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@Z ; std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T>::destroy
	jmp	SHORT $LN2@Uninit_cop@35
$LN1@Uninit_cop@35:

; 135  : 	_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 136  : 	_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$??$_Uninit_copy@PAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1
	ret	0
$LN10@Uninit_cop@35:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Uninit_copy@PAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1:

; 137  : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[ebp]
$LN9@Uninit_cop@35:

; 138  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_copy@PAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_copy@PAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_copy@PAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T *,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Checked_base@PAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@AAPAU123@U_Unchanged_checked_iterator_base_type_tag@0@@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Checked_base@PAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@AAPAU123@U_Unchanged_checked_iterator_base_type_tag@0@@Z PROC ; std::_Checked_base<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T *>, COMDAT

; 1146 : 	{

	push	ebp
	mov	ebp, esp

; 1147 : 		return _It;

	mov	eax, DWORD PTR __It$[ebp]
	mov	eax, DWORD PTR [eax]

; 1148 : 	}

	pop	ebp
	ret	0
??$_Checked_base@PAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@AAPAU123@U_Unchanged_checked_iterator_base_type_tag@0@@Z ENDP ; std::_Checked_base<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Copy_opt@PAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@Uforward_iterator_tag@std@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@Uforward_iterator_tag@std@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T *,std::forward_iterator_tag>, COMDAT

; 2469 : 	{	// copy [_First, _Last) to [_Dest, ...), arbitrary iterators

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi

; 2470 : 	_DEBUG_RANGE(_First, _Last);
; 2471 : 	for (; _First != _Last; ++_Dest, ++_First)

	jmp	SHORT $LN3@Copy_opt@19
$LN2@Copy_opt@19:
	mov	eax, DWORD PTR __Dest$[ebp]
	add	eax, 32					; 00000020H
	mov	DWORD PTR __Dest$[ebp], eax
	mov	ecx, DWORD PTR __First$[ebp]
	add	ecx, 32					; 00000020H
	mov	DWORD PTR __First$[ebp], ecx
$LN3@Copy_opt@19:
	mov	edx, DWORD PTR __First$[ebp]
	cmp	edx, DWORD PTR __Last$[ebp]
	je	SHORT $LN1@Copy_opt@19

; 2472 : 		*_Dest = *_First;

	mov	esi, DWORD PTR __First$[ebp]
	mov	ecx, 8
	mov	edi, DWORD PTR __Dest$[ebp]
	rep movsd
	jmp	SHORT $LN2@Copy_opt@19
$LN1@Copy_opt@19:

; 2473 : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[ebp]

; 2474 : 	}

	pop	edi
	pop	esi
	pop	ebp
	ret	0
??$_Copy_opt@PAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@Uforward_iterator_tag@std@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T *,std::forward_iterator_tag>
_TEXT	ENDS
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	SEGMENT
__catchsym$??$_Uninit_copy@PAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_copy@PAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__unwindtable$??$_Uninit_copy@PAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Uninit_copy@PAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_copy@PAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2
__ehfuncinfo$??$_Uninit_copy@PAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Uninit_copy@PAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_copy@PAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??$_Uninit_copy@PAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T *,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >, COMDAT

; 124  : 	{	// copy [_First, _Last) to raw _Dest, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_copy@PAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 125  : 	_DEBUG_RANGE(_First, _Last);
; 126  : 	_DEBUG_POINTER(_Dest);
; 127  : 	_FwdIt _Next = _Dest;

	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Next$[ebp], eax

; 128  : 
; 129  : 	_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 130  : 	for (; _First != _Last; ++_Dest, ++_First)

	jmp	SHORT $LN6@Uninit_cop@36
$LN5@Uninit_cop@36:
	mov	ecx, DWORD PTR __Dest$[ebp]
	add	ecx, 32					; 00000020H
	mov	DWORD PTR __Dest$[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	add	edx, 32					; 00000020H
	mov	DWORD PTR __First$[ebp], edx
$LN6@Uninit_cop@36:
	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Uninit_cop@36

; 131  : 		_Al.construct(_Dest, *_First);

	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?construct@?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@QAEXPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@ABU345@@Z ; std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T>::construct
	jmp	SHORT $LN5@Uninit_cop@36
$LN4@Uninit_cop@36:
	jmp	SHORT $LN10@Uninit_cop@36
__catch$??$_Uninit_copy@PAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 132  : 	_CATCH_ALL
; 133  : 	for (; _Next != _Dest; ++_Next)

	jmp	SHORT $LN3@Uninit_cop@36
$LN2@Uninit_cop@36:
	mov	eax, DWORD PTR __Next$[ebp]
	add	eax, 32					; 00000020H
	mov	DWORD PTR __Next$[ebp], eax
$LN3@Uninit_cop@36:
	mov	ecx, DWORD PTR __Next$[ebp]
	cmp	ecx, DWORD PTR __Dest$[ebp]
	je	SHORT $LN1@Uninit_cop@36

; 134  : 		_Al.destroy(_Next);

	mov	edx, DWORD PTR __Next$[ebp]
	push	edx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?destroy@?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@QAEXPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@Z ; std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T>::destroy
	jmp	SHORT $LN2@Uninit_cop@36
$LN1@Uninit_cop@36:

; 135  : 	_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 136  : 	_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$??$_Uninit_copy@PAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1
	ret	0
$LN10@Uninit_cop@36:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Uninit_copy@PAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1:

; 137  : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[ebp]
$LN9@Uninit_cop@36:

; 138  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_copy@PAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_copy@PAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_copy@PAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T *,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >
PUBLIC	??$_Uninit_move@PAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@U_Undefined_move_tag@5@@std@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@00AAV?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<Ogre::BaseKeyFrameArray::AnimRange *,Ogre::BaseKeyFrameArray::AnimRange *,std::allocator<Ogre::BaseKeyFrameArray::AnimRange>,std::_Undefined_move_tag>
; Function compile flags: /Odtp
;	COMDAT ??$_Unchecked_uninitialized_move@PAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@stdext@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@00AAV?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@Z
_TEXT	SEGMENT
$T98931 = -2						; size = 1
$T98930 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Unchecked_uninitialized_move@PAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@stdext@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@00AAV?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@Z PROC ; stdext::_Unchecked_uninitialized_move<Ogre::BaseKeyFrameArray::AnimRange *,Ogre::BaseKeyFrameArray::AnimRange *,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >, COMDAT

; 861  : 	{	// move [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 862  : 	return (_STD _Uninit_move(_CHECKED_BASE(_First),
; 863  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 864  : 		_STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T98930[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	??$_Move_cat@PAUAnimRange@BaseKeyFrameArray@Ogre@@@std@@YA?AU_Undefined_move_tag@0@ABQAUAnimRange@BaseKeyFrameArray@Ogre@@@Z ; std::_Move_cat<Ogre::BaseKeyFrameArray::AnimRange *>
	add	esp, 4
	mov	BYTE PTR $T98931[ebp], al
	movzx	edx, BYTE PTR $T98930[ebp]
	push	edx
	movzx	eax, BYTE PTR $T98931[ebp]
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	call	??$_Checked_base@PAUAnimRange@BaseKeyFrameArray@Ogre@@@std@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@AAPAU123@@Z ; std::_Checked_base<Ogre::BaseKeyFrameArray::AnimRange *>
	add	esp, 4
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Checked_base@PAUAnimRange@BaseKeyFrameArray@Ogre@@@std@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@AAPAU123@@Z ; std::_Checked_base<Ogre::BaseKeyFrameArray::AnimRange *>
	add	esp, 4
	push	eax
	call	??$_Uninit_move@PAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@U_Undefined_move_tag@5@@std@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@00AAV?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<Ogre::BaseKeyFrameArray::AnimRange *,Ogre::BaseKeyFrameArray::AnimRange *,std::allocator<Ogre::BaseKeyFrameArray::AnimRange>,std::_Undefined_move_tag>
	add	esp, 24					; 00000018H

; 865  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Unchecked_uninitialized_move@PAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@stdext@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@00AAV?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@Z ENDP ; stdext::_Unchecked_uninitialized_move<Ogre::BaseKeyFrameArray::AnimRange *,Ogre::BaseKeyFrameArray::AnimRange *,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Fill@PAUAnimRange@BaseKeyFrameArray@Ogre@@U123@@std@@YAXPAUAnimRange@BaseKeyFrameArray@Ogre@@0ABU123@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$_Fill@PAUAnimRange@BaseKeyFrameArray@Ogre@@U123@@std@@YAXPAUAnimRange@BaseKeyFrameArray@Ogre@@0ABU123@@Z PROC ; std::_Fill<Ogre::BaseKeyFrameArray::AnimRange *,Ogre::BaseKeyFrameArray::AnimRange>, COMDAT

; 3156 : 	{	// copy _Val through [_First, _Last)

	push	ebp
	mov	ebp, esp

; 3157 : 	_DEBUG_RANGE(_First, _Last);
; 3158 : 	for (; _First != _Last; ++_First)

	jmp	SHORT $LN3@Fill
$LN2@Fill:
	mov	eax, DWORD PTR __First$[ebp]
	add	eax, 8
	mov	DWORD PTR __First$[ebp], eax
$LN3@Fill:
	mov	ecx, DWORD PTR __First$[ebp]
	cmp	ecx, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Fill

; 3159 : 		*_First = _Val;

	mov	edx, DWORD PTR __Val$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR [edx], eax
	mov	DWORD PTR [edx+4], ecx
	jmp	SHORT $LN2@Fill
$LN4@Fill:

; 3160 : 	}

	pop	ebp
	ret	0
??$_Fill@PAUAnimRange@BaseKeyFrameArray@Ogre@@U123@@std@@YAXPAUAnimRange@BaseKeyFrameArray@Ogre@@0ABU123@@Z ENDP ; std::_Fill<Ogre::BaseKeyFrameArray::AnimRange *,Ogre::BaseKeyFrameArray::AnimRange>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Move_cat@PAUAnimRange@BaseKeyFrameArray@Ogre@@@std@@YA?AU_Undefined_move_tag@0@ABQAUAnimRange@BaseKeyFrameArray@Ogre@@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
??$_Move_cat@PAUAnimRange@BaseKeyFrameArray@Ogre@@@std@@YA?AU_Undefined_move_tag@0@ABQAUAnimRange@BaseKeyFrameArray@Ogre@@@Z PROC ; std::_Move_cat<Ogre::BaseKeyFrameArray::AnimRange *>, COMDAT

; 1200 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1201 : 		typename _Move_operation_category<typename iterator_traits<_Iter>::value_type>::_Move_cat _Cat;
; 1202 : 		return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 1203 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Move_cat@PAUAnimRange@BaseKeyFrameArray@Ogre@@@std@@YA?AU_Undefined_move_tag@0@ABQAUAnimRange@BaseKeyFrameArray@Ogre@@@Z ENDP ; std::_Move_cat<Ogre::BaseKeyFrameArray::AnimRange *>
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@PAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@@std@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<Ogre::BaseKeyFrameArray::AnimRange *,Ogre::BaseKeyFrameArray::AnimRange *>
; Function compile flags: /Odtp
;	COMDAT ??$_Move_backward_opt@PAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@5@@std@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T98939 = -2						; size = 1
$T98938 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__First_dest_cat$ = 20					; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Move_backward_opt@PAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@5@@std@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Move_backward_opt<Ogre::BaseKeyFrameArray::AnimRange *,Ogre::BaseKeyFrameArray::AnimRange *,std::random_access_iterator_tag,std::_Undefined_move_tag>, COMDAT

; 2752 : 	{	// move defaults to copy if there is not a more effecient way

	push	ebp
	mov	ebp, esp
	push	ecx

; 2753 : 	return _Copy_backward_opt(_First, _Last, _Dest,
; 2754 : 		_First_dest_cat, _Ptr_cat(_First, _Dest), _Range_checked_iterator_tag());

	xor	eax, eax
	mov	BYTE PTR $T98938[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUAnimRange@BaseKeyFrameArray@Ogre@@0@Z ; std::_Ptr_cat<Ogre::BaseKeyFrameArray::AnimRange *,Ogre::BaseKeyFrameArray::AnimRange *>
	add	esp, 8
	mov	BYTE PTR $T98939[ebp], al
	movzx	eax, BYTE PTR $T98938[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T98939[ebp]
	push	ecx
	movzx	edx, BYTE PTR __First_dest_cat$[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Copy_backward_opt@PAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@@std@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<Ogre::BaseKeyFrameArray::AnimRange *,Ogre::BaseKeyFrameArray::AnimRange *>
	add	esp, 24					; 00000018H

; 2755 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Move_backward_opt@PAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@5@@std@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Move_backward_opt<Ogre::BaseKeyFrameArray::AnimRange *,Ogre::BaseKeyFrameArray::AnimRange *,std::random_access_iterator_tag,std::_Undefined_move_tag>
_TEXT	ENDS
PUBLIC	??$_Uninit_move@PAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@U_Undefined_move_tag@5@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU123@00AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<Ogre::KeyFrameArray<float>::KEYFRAME_T *,Ogre::KeyFrameArray<float>::KEYFRAME_T *,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T>,std::_Undefined_move_tag>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Unchecked_uninitialized_move@PAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@stdext@@YAPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU123@00AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@Z
_TEXT	SEGMENT
$T98943 = -2						; size = 1
$T98942 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Unchecked_uninitialized_move@PAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@stdext@@YAPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU123@00AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@Z PROC ; stdext::_Unchecked_uninitialized_move<Ogre::KeyFrameArray<float>::KEYFRAME_T *,Ogre::KeyFrameArray<float>::KEYFRAME_T *,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >, COMDAT

; 861  : 	{	// move [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 862  : 	return (_STD _Uninit_move(_CHECKED_BASE(_First),
; 863  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 864  : 		_STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T98942[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	??$_Move_cat@PAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@YA?AU_Undefined_move_tag@0@ABQAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@Z ; std::_Move_cat<Ogre::KeyFrameArray<float>::KEYFRAME_T *>
	add	esp, 4
	mov	BYTE PTR $T98943[ebp], al
	movzx	edx, BYTE PTR $T98942[ebp]
	push	edx
	movzx	eax, BYTE PTR $T98943[ebp]
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	call	??$_Checked_base@PAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@AAPAU123@@Z ; std::_Checked_base<Ogre::KeyFrameArray<float>::KEYFRAME_T *>
	add	esp, 4
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Checked_base@PAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@AAPAU123@@Z ; std::_Checked_base<Ogre::KeyFrameArray<float>::KEYFRAME_T *>
	add	esp, 4
	push	eax
	call	??$_Uninit_move@PAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@U_Undefined_move_tag@5@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU123@00AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<Ogre::KeyFrameArray<float>::KEYFRAME_T *,Ogre::KeyFrameArray<float>::KEYFRAME_T *,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T>,std::_Undefined_move_tag>
	add	esp, 24					; 00000018H

; 865  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Unchecked_uninitialized_move@PAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@stdext@@YAPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU123@00AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@Z ENDP ; stdext::_Unchecked_uninitialized_move<Ogre::KeyFrameArray<float>::KEYFRAME_T *,Ogre::KeyFrameArray<float>::KEYFRAME_T *,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Fill@PAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@U123@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@0ABU123@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$_Fill@PAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@U123@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@0ABU123@@Z PROC ; std::_Fill<Ogre::KeyFrameArray<float>::KEYFRAME_T *,Ogre::KeyFrameArray<float>::KEYFRAME_T>, COMDAT

; 3156 : 	{	// copy _Val through [_First, _Last)

	push	ebp
	mov	ebp, esp

; 3157 : 	_DEBUG_RANGE(_First, _Last);
; 3158 : 	for (; _First != _Last; ++_First)

	jmp	SHORT $LN3@Fill@2
$LN2@Fill@2:
	mov	eax, DWORD PTR __First$[ebp]
	add	eax, 8
	mov	DWORD PTR __First$[ebp], eax
$LN3@Fill@2:
	mov	ecx, DWORD PTR __First$[ebp]
	cmp	ecx, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Fill@2

; 3159 : 		*_First = _Val;

	mov	edx, DWORD PTR __Val$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR [edx], eax
	mov	DWORD PTR [edx+4], ecx
	jmp	SHORT $LN2@Fill@2
$LN4@Fill@2:

; 3160 : 	}

	pop	ebp
	ret	0
??$_Fill@PAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@U123@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@0ABU123@@Z ENDP ; std::_Fill<Ogre::KeyFrameArray<float>::KEYFRAME_T *,Ogre::KeyFrameArray<float>::KEYFRAME_T>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Move_cat@PAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@YA?AU_Undefined_move_tag@0@ABQAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
??$_Move_cat@PAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@YA?AU_Undefined_move_tag@0@ABQAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@Z PROC ; std::_Move_cat<Ogre::KeyFrameArray<float>::KEYFRAME_T *>, COMDAT

; 1200 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1201 : 		typename _Move_operation_category<typename iterator_traits<_Iter>::value_type>::_Move_cat _Cat;
; 1202 : 		return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 1203 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Move_cat@PAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@YA?AU_Undefined_move_tag@0@ABQAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@Z ENDP ; std::_Move_cat<Ogre::KeyFrameArray<float>::KEYFRAME_T *>
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@PAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU123@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU123@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<Ogre::KeyFrameArray<float>::KEYFRAME_T *,Ogre::KeyFrameArray<float>::KEYFRAME_T *>
; Function compile flags: /Odtp
;	COMDAT ??$_Move_backward_opt@PAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU123@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@5@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU123@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T98951 = -2						; size = 1
$T98950 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__First_dest_cat$ = 20					; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Move_backward_opt@PAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU123@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@5@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU123@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Move_backward_opt<Ogre::KeyFrameArray<float>::KEYFRAME_T *,Ogre::KeyFrameArray<float>::KEYFRAME_T *,std::random_access_iterator_tag,std::_Undefined_move_tag>, COMDAT

; 2752 : 	{	// move defaults to copy if there is not a more effecient way

	push	ebp
	mov	ebp, esp
	push	ecx

; 2753 : 	return _Copy_backward_opt(_First, _Last, _Dest,
; 2754 : 		_First_dest_cat, _Ptr_cat(_First, _Dest), _Range_checked_iterator_tag());

	xor	eax, eax
	mov	BYTE PTR $T98950[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU123@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@0@Z ; std::_Ptr_cat<Ogre::KeyFrameArray<float>::KEYFRAME_T *,Ogre::KeyFrameArray<float>::KEYFRAME_T *>
	add	esp, 8
	mov	BYTE PTR $T98951[ebp], al
	movzx	eax, BYTE PTR $T98950[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T98951[ebp]
	push	ecx
	movzx	edx, BYTE PTR __First_dest_cat$[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Copy_backward_opt@PAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU123@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU123@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<Ogre::KeyFrameArray<float>::KEYFRAME_T *,Ogre::KeyFrameArray<float>::KEYFRAME_T *>
	add	esp, 24					; 00000018H

; 2755 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Move_backward_opt@PAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU123@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@5@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU123@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Move_backward_opt<Ogre::KeyFrameArray<float>::KEYFRAME_T *,Ogre::KeyFrameArray<float>::KEYFRAME_T *,std::random_access_iterator_tag,std::_Undefined_move_tag>
_TEXT	ENDS
PUBLIC	??$_Uninit_move@PAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@U_Undefined_move_tag@5@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU123@00AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<Ogre::KeyFrameArray<float>::CONTROL_POINT_T *,Ogre::KeyFrameArray<float>::CONTROL_POINT_T *,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T>,std::_Undefined_move_tag>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Unchecked_uninitialized_move@PAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@stdext@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU123@00AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@Z
_TEXT	SEGMENT
$T98955 = -2						; size = 1
$T98954 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Unchecked_uninitialized_move@PAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@stdext@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU123@00AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@Z PROC ; stdext::_Unchecked_uninitialized_move<Ogre::KeyFrameArray<float>::CONTROL_POINT_T *,Ogre::KeyFrameArray<float>::CONTROL_POINT_T *,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >, COMDAT

; 861  : 	{	// move [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 862  : 	return (_STD _Uninit_move(_CHECKED_BASE(_First),
; 863  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 864  : 		_STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T98954[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	??$_Move_cat@PAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@YA?AU_Undefined_move_tag@0@ABQAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@Z ; std::_Move_cat<Ogre::KeyFrameArray<float>::CONTROL_POINT_T *>
	add	esp, 4
	mov	BYTE PTR $T98955[ebp], al
	movzx	edx, BYTE PTR $T98954[ebp]
	push	edx
	movzx	eax, BYTE PTR $T98955[ebp]
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	call	??$_Checked_base@PAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@AAPAU123@@Z ; std::_Checked_base<Ogre::KeyFrameArray<float>::CONTROL_POINT_T *>
	add	esp, 4
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Checked_base@PAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@AAPAU123@@Z ; std::_Checked_base<Ogre::KeyFrameArray<float>::CONTROL_POINT_T *>
	add	esp, 4
	push	eax
	call	??$_Uninit_move@PAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@U_Undefined_move_tag@5@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU123@00AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<Ogre::KeyFrameArray<float>::CONTROL_POINT_T *,Ogre::KeyFrameArray<float>::CONTROL_POINT_T *,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T>,std::_Undefined_move_tag>
	add	esp, 24					; 00000018H

; 865  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Unchecked_uninitialized_move@PAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@stdext@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU123@00AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@Z ENDP ; stdext::_Unchecked_uninitialized_move<Ogre::KeyFrameArray<float>::CONTROL_POINT_T *,Ogre::KeyFrameArray<float>::CONTROL_POINT_T *,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Fill@PAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@U123@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@0ABU123@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$_Fill@PAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@U123@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@0ABU123@@Z PROC ; std::_Fill<Ogre::KeyFrameArray<float>::CONTROL_POINT_T *,Ogre::KeyFrameArray<float>::CONTROL_POINT_T>, COMDAT

; 3156 : 	{	// copy _Val through [_First, _Last)

	push	ebp
	mov	ebp, esp

; 3157 : 	_DEBUG_RANGE(_First, _Last);
; 3158 : 	for (; _First != _Last; ++_First)

	jmp	SHORT $LN3@Fill@3
$LN2@Fill@3:
	mov	eax, DWORD PTR __First$[ebp]
	add	eax, 8
	mov	DWORD PTR __First$[ebp], eax
$LN3@Fill@3:
	mov	ecx, DWORD PTR __First$[ebp]
	cmp	ecx, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Fill@3

; 3159 : 		*_First = _Val;

	mov	edx, DWORD PTR __Val$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR __First$[ebp]
	mov	DWORD PTR [edx], eax
	mov	DWORD PTR [edx+4], ecx
	jmp	SHORT $LN2@Fill@3
$LN4@Fill@3:

; 3160 : 	}

	pop	ebp
	ret	0
??$_Fill@PAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@U123@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@0ABU123@@Z ENDP ; std::_Fill<Ogre::KeyFrameArray<float>::CONTROL_POINT_T *,Ogre::KeyFrameArray<float>::CONTROL_POINT_T>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Move_cat@PAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@YA?AU_Undefined_move_tag@0@ABQAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
??$_Move_cat@PAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@YA?AU_Undefined_move_tag@0@ABQAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@Z PROC ; std::_Move_cat<Ogre::KeyFrameArray<float>::CONTROL_POINT_T *>, COMDAT

; 1200 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1201 : 		typename _Move_operation_category<typename iterator_traits<_Iter>::value_type>::_Move_cat _Cat;
; 1202 : 		return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 1203 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Move_cat@PAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@YA?AU_Undefined_move_tag@0@ABQAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@Z ENDP ; std::_Move_cat<Ogre::KeyFrameArray<float>::CONTROL_POINT_T *>
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@PAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU123@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU123@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<Ogre::KeyFrameArray<float>::CONTROL_POINT_T *,Ogre::KeyFrameArray<float>::CONTROL_POINT_T *>
; Function compile flags: /Odtp
;	COMDAT ??$_Move_backward_opt@PAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU123@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@5@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU123@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T98963 = -2						; size = 1
$T98962 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__First_dest_cat$ = 20					; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Move_backward_opt@PAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU123@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@5@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU123@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Move_backward_opt<Ogre::KeyFrameArray<float>::CONTROL_POINT_T *,Ogre::KeyFrameArray<float>::CONTROL_POINT_T *,std::random_access_iterator_tag,std::_Undefined_move_tag>, COMDAT

; 2752 : 	{	// move defaults to copy if there is not a more effecient way

	push	ebp
	mov	ebp, esp
	push	ecx

; 2753 : 	return _Copy_backward_opt(_First, _Last, _Dest,
; 2754 : 		_First_dest_cat, _Ptr_cat(_First, _Dest), _Range_checked_iterator_tag());

	xor	eax, eax
	mov	BYTE PTR $T98962[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU123@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@0@Z ; std::_Ptr_cat<Ogre::KeyFrameArray<float>::CONTROL_POINT_T *,Ogre::KeyFrameArray<float>::CONTROL_POINT_T *>
	add	esp, 8
	mov	BYTE PTR $T98963[ebp], al
	movzx	eax, BYTE PTR $T98962[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T98963[ebp]
	push	ecx
	movzx	edx, BYTE PTR __First_dest_cat$[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Copy_backward_opt@PAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU123@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU123@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<Ogre::KeyFrameArray<float>::CONTROL_POINT_T *,Ogre::KeyFrameArray<float>::CONTROL_POINT_T *>
	add	esp, 24					; 00000018H

; 2755 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Move_backward_opt@PAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU123@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@5@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU123@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Move_backward_opt<Ogre::KeyFrameArray<float>::CONTROL_POINT_T *,Ogre::KeyFrameArray<float>::CONTROL_POINT_T *,std::random_access_iterator_tag,std::_Undefined_move_tag>
_TEXT	ENDS
PUBLIC	??$_Uninit_move@PAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@U_Undefined_move_tag@5@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T *,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T>,std::_Undefined_move_tag>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Unchecked_uninitialized_move@PAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@stdext@@YAPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@Z
_TEXT	SEGMENT
$T98967 = -2						; size = 1
$T98966 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Unchecked_uninitialized_move@PAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@stdext@@YAPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@Z PROC ; stdext::_Unchecked_uninitialized_move<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T *,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >, COMDAT

; 861  : 	{	// move [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 862  : 	return (_STD _Uninit_move(_CHECKED_BASE(_First),
; 863  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 864  : 		_STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T98966[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	??$_Move_cat@PAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@YA?AU_Undefined_move_tag@0@ABQAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@Z ; std::_Move_cat<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T *>
	add	esp, 4
	mov	BYTE PTR $T98967[ebp], al
	movzx	edx, BYTE PTR $T98966[ebp]
	push	edx
	movzx	eax, BYTE PTR $T98967[ebp]
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	call	??$_Checked_base@PAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@AAPAU123@@Z ; std::_Checked_base<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T *>
	add	esp, 4
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Checked_base@PAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@AAPAU123@@Z ; std::_Checked_base<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T *>
	add	esp, 4
	push	eax
	call	??$_Uninit_move@PAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@U_Undefined_move_tag@5@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T *,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T>,std::_Undefined_move_tag>
	add	esp, 24					; 00000018H

; 865  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Unchecked_uninitialized_move@PAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@stdext@@YAPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@Z ENDP ; stdext::_Unchecked_uninitialized_move<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T *,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Fill@PAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@U123@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@0ABU123@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$_Fill@PAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@U123@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@0ABU123@@Z PROC ; std::_Fill<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T>, COMDAT

; 3156 : 	{	// copy _Val through [_First, _Last)

	push	ebp
	mov	ebp, esp

; 3157 : 	_DEBUG_RANGE(_First, _Last);
; 3158 : 	for (; _First != _Last; ++_First)

	jmp	SHORT $LN3@Fill@4
$LN2@Fill@4:
	mov	eax, DWORD PTR __First$[ebp]
	add	eax, 20					; 00000014H
	mov	DWORD PTR __First$[ebp], eax
$LN3@Fill@4:
	mov	ecx, DWORD PTR __First$[ebp]
	cmp	ecx, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Fill@4

; 3159 : 		*_First = _Val;

	mov	edx, DWORD PTR __Val$[ebp]
	mov	eax, DWORD PTR __First$[ebp]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], ecx
	mov	ecx, DWORD PTR [edx+12]
	mov	DWORD PTR [eax+12], ecx
	mov	edx, DWORD PTR [edx+16]
	mov	DWORD PTR [eax+16], edx
	jmp	SHORT $LN2@Fill@4
$LN4@Fill@4:

; 3160 : 	}

	pop	ebp
	ret	0
??$_Fill@PAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@U123@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@0ABU123@@Z ENDP ; std::_Fill<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Move_cat@PAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@YA?AU_Undefined_move_tag@0@ABQAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
??$_Move_cat@PAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@YA?AU_Undefined_move_tag@0@ABQAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@Z PROC ; std::_Move_cat<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T *>, COMDAT

; 1200 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1201 : 		typename _Move_operation_category<typename iterator_traits<_Iter>::value_type>::_Move_cat _Cat;
; 1202 : 		return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 1203 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Move_cat@PAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@YA?AU_Undefined_move_tag@0@ABQAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@Z ENDP ; std::_Move_cat<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T *>
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@PAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T *>
; Function compile flags: /Odtp
;	COMDAT ??$_Move_backward_opt@PAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@5@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T98975 = -2						; size = 1
$T98974 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__First_dest_cat$ = 20					; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Move_backward_opt@PAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@5@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Move_backward_opt<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T *,std::random_access_iterator_tag,std::_Undefined_move_tag>, COMDAT

; 2752 : 	{	// move defaults to copy if there is not a more effecient way

	push	ebp
	mov	ebp, esp
	push	ecx

; 2753 : 	return _Copy_backward_opt(_First, _Last, _Dest,
; 2754 : 		_First_dest_cat, _Ptr_cat(_First, _Dest), _Range_checked_iterator_tag());

	xor	eax, eax
	mov	BYTE PTR $T98974[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@0@Z ; std::_Ptr_cat<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T *>
	add	esp, 8
	mov	BYTE PTR $T98975[ebp], al
	movzx	eax, BYTE PTR $T98974[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T98975[ebp]
	push	ecx
	movzx	edx, BYTE PTR __First_dest_cat$[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Copy_backward_opt@PAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T *>
	add	esp, 24					; 00000018H

; 2755 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Move_backward_opt@PAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@5@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Move_backward_opt<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T *,std::random_access_iterator_tag,std::_Undefined_move_tag>
_TEXT	ENDS
PUBLIC	??$_Uninit_move@PAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@U_Undefined_move_tag@5@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T *,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T>,std::_Undefined_move_tag>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
;	COMDAT ??$_Unchecked_uninitialized_move@PAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@stdext@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@Z
_TEXT	SEGMENT
$T98979 = -2						; size = 1
$T98978 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Unchecked_uninitialized_move@PAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@stdext@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@Z PROC ; stdext::_Unchecked_uninitialized_move<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T *,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >, COMDAT

; 861  : 	{	// move [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 862  : 	return (_STD _Uninit_move(_CHECKED_BASE(_First),
; 863  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 864  : 		_STD _Move_cat(_Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T98978[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	??$_Move_cat@PAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@YA?AU_Undefined_move_tag@0@ABQAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@Z ; std::_Move_cat<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T *>
	add	esp, 4
	mov	BYTE PTR $T98979[ebp], al
	movzx	edx, BYTE PTR $T98978[ebp]
	push	edx
	movzx	eax, BYTE PTR $T98979[ebp]
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	call	??$_Checked_base@PAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@AAPAU123@@Z ; std::_Checked_base<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T *>
	add	esp, 4
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Checked_base@PAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@AAPAU123@@Z ; std::_Checked_base<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T *>
	add	esp, 4
	push	eax
	call	??$_Uninit_move@PAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@U_Undefined_move_tag@5@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_move<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T *,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T>,std::_Undefined_move_tag>
	add	esp, 24					; 00000018H

; 865  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Unchecked_uninitialized_move@PAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@stdext@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@Z ENDP ; stdext::_Unchecked_uninitialized_move<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T *,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Fill@PAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@U123@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@0ABU123@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$_Fill@PAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@U123@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@0ABU123@@Z PROC ; std::_Fill<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T>, COMDAT

; 3156 : 	{	// copy _Val through [_First, _Last)

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi

; 3157 : 	_DEBUG_RANGE(_First, _Last);
; 3158 : 	for (; _First != _Last; ++_First)

	jmp	SHORT $LN3@Fill@5
$LN2@Fill@5:
	mov	eax, DWORD PTR __First$[ebp]
	add	eax, 32					; 00000020H
	mov	DWORD PTR __First$[ebp], eax
$LN3@Fill@5:
	mov	ecx, DWORD PTR __First$[ebp]
	cmp	ecx, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Fill@5

; 3159 : 		*_First = _Val;

	mov	esi, DWORD PTR __Val$[ebp]
	mov	ecx, 8
	mov	edi, DWORD PTR __First$[ebp]
	rep movsd
	jmp	SHORT $LN2@Fill@5
$LN4@Fill@5:

; 3160 : 	}

	pop	edi
	pop	esi
	pop	ebp
	ret	0
??$_Fill@PAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@U123@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@0ABU123@@Z ENDP ; std::_Fill<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Move_cat@PAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@YA?AU_Undefined_move_tag@0@ABQAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
??$_Move_cat@PAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@YA?AU_Undefined_move_tag@0@ABQAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@Z PROC ; std::_Move_cat<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T *>, COMDAT

; 1200 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1201 : 		typename _Move_operation_category<typename iterator_traits<_Iter>::value_type>::_Move_cat _Cat;
; 1202 : 		return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 1203 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Move_cat@PAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@YA?AU_Undefined_move_tag@0@ABQAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@Z ENDP ; std::_Move_cat<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T *>
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@PAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T *>
; Function compile flags: /Odtp
;	COMDAT ??$_Move_backward_opt@PAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@5@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T98987 = -2						; size = 1
$T98986 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__First_dest_cat$ = 20					; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Move_backward_opt@PAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@5@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Move_backward_opt<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T *,std::random_access_iterator_tag,std::_Undefined_move_tag>, COMDAT

; 2752 : 	{	// move defaults to copy if there is not a more effecient way

	push	ebp
	mov	ebp, esp
	push	ecx

; 2753 : 	return _Copy_backward_opt(_First, _Last, _Dest,
; 2754 : 		_First_dest_cat, _Ptr_cat(_First, _Dest), _Range_checked_iterator_tag());

	xor	eax, eax
	mov	BYTE PTR $T98986[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@0@Z ; std::_Ptr_cat<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T *>
	add	esp, 8
	mov	BYTE PTR $T98987[ebp], al
	movzx	eax, BYTE PTR $T98986[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T98987[ebp]
	push	ecx
	movzx	edx, BYTE PTR __First_dest_cat$[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Copy_backward_opt@PAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T *>
	add	esp, 24					; 00000018H

; 2755 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Move_backward_opt@PAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@Urandom_access_iterator_tag@std@@U_Undefined_move_tag@5@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@00Urandom_access_iterator_tag@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Move_backward_opt<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T *,std::random_access_iterator_tag,std::_Undefined_move_tag>
_TEXT	ENDS
;	COMDAT xdata$x
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	SEGMENT
__catchsym$??$_Uninit_fill_n@PAUAnimRange@BaseKeyFrameArray@Ogre@@IU123@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@YAXPAUAnimRange@BaseKeyFrameArray@Ogre@@IABU123@AAV?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_fill_n@PAUAnimRange@BaseKeyFrameArray@Ogre@@IU123@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@YAXPAUAnimRange@BaseKeyFrameArray@Ogre@@IABU123@AAV?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__unwindtable$??$_Uninit_fill_n@PAUAnimRange@BaseKeyFrameArray@Ogre@@IU123@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@YAXPAUAnimRange@BaseKeyFrameArray@Ogre@@IABU123@AAV?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Uninit_fill_n@PAUAnimRange@BaseKeyFrameArray@Ogre@@IU123@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@YAXPAUAnimRange@BaseKeyFrameArray@Ogre@@IABU123@AAV?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_fill_n@PAUAnimRange@BaseKeyFrameArray@Ogre@@IU123@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@YAXPAUAnimRange@BaseKeyFrameArray@Ogre@@IABU123@AAV?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2
__ehfuncinfo$??$_Uninit_fill_n@PAUAnimRange@BaseKeyFrameArray@Ogre@@IU123@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@YAXPAUAnimRange@BaseKeyFrameArray@Ogre@@IABU123@AAV?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Uninit_fill_n@PAUAnimRange@BaseKeyFrameArray@Ogre@@IU123@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@YAXPAUAnimRange@BaseKeyFrameArray@Ogre@@IABU123@AAV?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_fill_n@PAUAnimRange@BaseKeyFrameArray@Ogre@@IU123@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@YAXPAUAnimRange@BaseKeyFrameArray@Ogre@@IABU123@AAV?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??$_Uninit_fill_n@PAUAnimRange@BaseKeyFrameArray@Ogre@@IU123@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@YAXPAUAnimRange@BaseKeyFrameArray@Ogre@@IABU123@AAV?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_fill_n@PAUAnimRange@BaseKeyFrameArray@Ogre@@IU123@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@YAXPAUAnimRange@BaseKeyFrameArray@Ogre@@IABU123@AAV?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<Ogre::BaseKeyFrameArray::AnimRange *,unsigned int,Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >, COMDAT

; 393  : 	{	// copy _Count *_Val to raw _First, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_fill_n@PAUAnimRange@BaseKeyFrameArray@Ogre@@IU123@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@YAXPAUAnimRange@BaseKeyFrameArray@Ogre@@IABU123@AAV?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 394  : 
; 395  :  #if _HAS_ITERATOR_DEBUGGING
; 396  : //	if (_Count < 0)
; 397  : //		_DEBUG_ERROR("negative count in uninitialized fill");
; 398  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 399  : 
; 400  : 	_FwdIt _Next = _First;

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Next$[ebp], eax

; 401  : 
; 402  : 	_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 403  : 	for (; 0 < _Count; --_Count, ++_First)

	jmp	SHORT $LN6@Uninit_fil
$LN5@Uninit_fil:
	mov	ecx, DWORD PTR __Count$[ebp]
	sub	ecx, 1
	mov	DWORD PTR __Count$[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	add	edx, 8
	mov	DWORD PTR __First$[ebp], edx
$LN6@Uninit_fil:
	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN4@Uninit_fil

; 404  : 		_Al.construct(_First, _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?construct@?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@QAEXPAUAnimRange@BaseKeyFrameArray@Ogre@@ABU345@@Z ; std::allocator<Ogre::BaseKeyFrameArray::AnimRange>::construct
	jmp	SHORT $LN5@Uninit_fil
$LN4@Uninit_fil:
	jmp	SHORT $LN10@Uninit_fil
__catch$??$_Uninit_fill_n@PAUAnimRange@BaseKeyFrameArray@Ogre@@IU123@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@YAXPAUAnimRange@BaseKeyFrameArray@Ogre@@IABU123@AAV?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 405  : 	_CATCH_ALL
; 406  : 	for (; _Next != _First; ++_Next)

	jmp	SHORT $LN3@Uninit_fil
$LN2@Uninit_fil:
	mov	edx, DWORD PTR __Next$[ebp]
	add	edx, 8
	mov	DWORD PTR __Next$[ebp], edx
$LN3@Uninit_fil:
	mov	eax, DWORD PTR __Next$[ebp]
	cmp	eax, DWORD PTR __First$[ebp]
	je	SHORT $LN1@Uninit_fil

; 407  : 		_Al.destroy(_Next);

	mov	ecx, DWORD PTR __Next$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?destroy@?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@QAEXPAUAnimRange@BaseKeyFrameArray@Ogre@@@Z ; std::allocator<Ogre::BaseKeyFrameArray::AnimRange>::destroy
	jmp	SHORT $LN2@Uninit_fil
$LN1@Uninit_fil:

; 408  : 	_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 409  : 	_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, $LN9@Uninit_fil
	ret	0
$LN10@Uninit_fil:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
$LN9@Uninit_fil:

; 410  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_fill_n@PAUAnimRange@BaseKeyFrameArray@Ogre@@IU123@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@YAXPAUAnimRange@BaseKeyFrameArray@Ogre@@IABU123@AAV?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_fill_n@PAUAnimRange@BaseKeyFrameArray@Ogre@@IU123@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@YAXPAUAnimRange@BaseKeyFrameArray@Ogre@@IABU123@AAV?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_fill_n@PAUAnimRange@BaseKeyFrameArray@Ogre@@IU123@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@YAXPAUAnimRange@BaseKeyFrameArray@Ogre@@IABU123@AAV?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<Ogre::BaseKeyFrameArray::AnimRange *,unsigned int,Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$_Uninit_fill_n@PAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@IU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@IABU123@AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_fill_n@PAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@IU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@IABU123@AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__unwindtable$??$_Uninit_fill_n@PAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@IU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@IABU123@AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Uninit_fill_n@PAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@IU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@IABU123@AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_fill_n@PAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@IU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@IABU123@AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2
__ehfuncinfo$??$_Uninit_fill_n@PAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@IU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@IABU123@AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Uninit_fill_n@PAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@IU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@IABU123@AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_fill_n@PAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@IU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@IABU123@AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??$_Uninit_fill_n@PAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@IU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@IABU123@AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_fill_n@PAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@IU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@IABU123@AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<Ogre::KeyFrameArray<float>::KEYFRAME_T *,unsigned int,Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >, COMDAT

; 393  : 	{	// copy _Count *_Val to raw _First, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_fill_n@PAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@IU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@IABU123@AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 394  : 
; 395  :  #if _HAS_ITERATOR_DEBUGGING
; 396  : //	if (_Count < 0)
; 397  : //		_DEBUG_ERROR("negative count in uninitialized fill");
; 398  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 399  : 
; 400  : 	_FwdIt _Next = _First;

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Next$[ebp], eax

; 401  : 
; 402  : 	_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 403  : 	for (; 0 < _Count; --_Count, ++_First)

	jmp	SHORT $LN6@Uninit_fil@2
$LN5@Uninit_fil@2:
	mov	ecx, DWORD PTR __Count$[ebp]
	sub	ecx, 1
	mov	DWORD PTR __Count$[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	add	edx, 8
	mov	DWORD PTR __First$[ebp], edx
$LN6@Uninit_fil@2:
	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN4@Uninit_fil@2

; 404  : 		_Al.construct(_First, _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?construct@?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@QAEXPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@ABU345@@Z ; std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T>::construct
	jmp	SHORT $LN5@Uninit_fil@2
$LN4@Uninit_fil@2:
	jmp	SHORT $LN10@Uninit_fil@2
__catch$??$_Uninit_fill_n@PAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@IU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@IABU123@AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 405  : 	_CATCH_ALL
; 406  : 	for (; _Next != _First; ++_Next)

	jmp	SHORT $LN3@Uninit_fil@2
$LN2@Uninit_fil@2:
	mov	edx, DWORD PTR __Next$[ebp]
	add	edx, 8
	mov	DWORD PTR __Next$[ebp], edx
$LN3@Uninit_fil@2:
	mov	eax, DWORD PTR __Next$[ebp]
	cmp	eax, DWORD PTR __First$[ebp]
	je	SHORT $LN1@Uninit_fil@2

; 407  : 		_Al.destroy(_Next);

	mov	ecx, DWORD PTR __Next$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?destroy@?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@QAEXPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@Z ; std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T>::destroy
	jmp	SHORT $LN2@Uninit_fil@2
$LN1@Uninit_fil@2:

; 408  : 	_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 409  : 	_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, $LN9@Uninit_fil@2
	ret	0
$LN10@Uninit_fil@2:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
$LN9@Uninit_fil@2:

; 410  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_fill_n@PAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@IU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@IABU123@AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_fill_n@PAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@IU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@IABU123@AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_fill_n@PAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@IU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@IABU123@AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<Ogre::KeyFrameArray<float>::KEYFRAME_T *,unsigned int,Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$_Uninit_fill_n@PAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@IU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@IABU123@AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_fill_n@PAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@IU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@IABU123@AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__unwindtable$??$_Uninit_fill_n@PAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@IU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@IABU123@AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Uninit_fill_n@PAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@IU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@IABU123@AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_fill_n@PAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@IU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@IABU123@AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2
__ehfuncinfo$??$_Uninit_fill_n@PAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@IU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@IABU123@AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Uninit_fill_n@PAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@IU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@IABU123@AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_fill_n@PAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@IU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@IABU123@AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??$_Uninit_fill_n@PAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@IU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@IABU123@AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_fill_n@PAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@IU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@IABU123@AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<Ogre::KeyFrameArray<float>::CONTROL_POINT_T *,unsigned int,Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >, COMDAT

; 393  : 	{	// copy _Count *_Val to raw _First, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_fill_n@PAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@IU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@IABU123@AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 394  : 
; 395  :  #if _HAS_ITERATOR_DEBUGGING
; 396  : //	if (_Count < 0)
; 397  : //		_DEBUG_ERROR("negative count in uninitialized fill");
; 398  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 399  : 
; 400  : 	_FwdIt _Next = _First;

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Next$[ebp], eax

; 401  : 
; 402  : 	_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 403  : 	for (; 0 < _Count; --_Count, ++_First)

	jmp	SHORT $LN6@Uninit_fil@3
$LN5@Uninit_fil@3:
	mov	ecx, DWORD PTR __Count$[ebp]
	sub	ecx, 1
	mov	DWORD PTR __Count$[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	add	edx, 8
	mov	DWORD PTR __First$[ebp], edx
$LN6@Uninit_fil@3:
	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN4@Uninit_fil@3

; 404  : 		_Al.construct(_First, _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?construct@?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@QAEXPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@ABU345@@Z ; std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T>::construct
	jmp	SHORT $LN5@Uninit_fil@3
$LN4@Uninit_fil@3:
	jmp	SHORT $LN10@Uninit_fil@3
__catch$??$_Uninit_fill_n@PAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@IU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@IABU123@AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 405  : 	_CATCH_ALL
; 406  : 	for (; _Next != _First; ++_Next)

	jmp	SHORT $LN3@Uninit_fil@3
$LN2@Uninit_fil@3:
	mov	edx, DWORD PTR __Next$[ebp]
	add	edx, 8
	mov	DWORD PTR __Next$[ebp], edx
$LN3@Uninit_fil@3:
	mov	eax, DWORD PTR __Next$[ebp]
	cmp	eax, DWORD PTR __First$[ebp]
	je	SHORT $LN1@Uninit_fil@3

; 407  : 		_Al.destroy(_Next);

	mov	ecx, DWORD PTR __Next$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?destroy@?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@QAEXPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@Z ; std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T>::destroy
	jmp	SHORT $LN2@Uninit_fil@3
$LN1@Uninit_fil@3:

; 408  : 	_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 409  : 	_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, $LN9@Uninit_fil@3
	ret	0
$LN10@Uninit_fil@3:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
$LN9@Uninit_fil@3:

; 410  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_fill_n@PAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@IU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@IABU123@AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_fill_n@PAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@IU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@IABU123@AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_fill_n@PAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@IU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@IABU123@AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<Ogre::KeyFrameArray<float>::CONTROL_POINT_T *,unsigned int,Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$_Uninit_fill_n@PAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@IU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@IABU123@AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_fill_n@PAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@IU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@IABU123@AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__unwindtable$??$_Uninit_fill_n@PAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@IU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@IABU123@AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Uninit_fill_n@PAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@IU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@IABU123@AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_fill_n@PAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@IU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@IABU123@AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2
__ehfuncinfo$??$_Uninit_fill_n@PAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@IU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@IABU123@AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Uninit_fill_n@PAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@IU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@IABU123@AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_fill_n@PAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@IU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@IABU123@AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??$_Uninit_fill_n@PAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@IU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@IABU123@AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_fill_n@PAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@IU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@IABU123@AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T *,unsigned int,Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >, COMDAT

; 393  : 	{	// copy _Count *_Val to raw _First, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_fill_n@PAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@IU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@IABU123@AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 394  : 
; 395  :  #if _HAS_ITERATOR_DEBUGGING
; 396  : //	if (_Count < 0)
; 397  : //		_DEBUG_ERROR("negative count in uninitialized fill");
; 398  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 399  : 
; 400  : 	_FwdIt _Next = _First;

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Next$[ebp], eax

; 401  : 
; 402  : 	_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 403  : 	for (; 0 < _Count; --_Count, ++_First)

	jmp	SHORT $LN6@Uninit_fil@4
$LN5@Uninit_fil@4:
	mov	ecx, DWORD PTR __Count$[ebp]
	sub	ecx, 1
	mov	DWORD PTR __Count$[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	add	edx, 20					; 00000014H
	mov	DWORD PTR __First$[ebp], edx
$LN6@Uninit_fil@4:
	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN4@Uninit_fil@4

; 404  : 		_Al.construct(_First, _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?construct@?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@QAEXPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@ABU345@@Z ; std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T>::construct
	jmp	SHORT $LN5@Uninit_fil@4
$LN4@Uninit_fil@4:
	jmp	SHORT $LN10@Uninit_fil@4
__catch$??$_Uninit_fill_n@PAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@IU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@IABU123@AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 405  : 	_CATCH_ALL
; 406  : 	for (; _Next != _First; ++_Next)

	jmp	SHORT $LN3@Uninit_fil@4
$LN2@Uninit_fil@4:
	mov	edx, DWORD PTR __Next$[ebp]
	add	edx, 20					; 00000014H
	mov	DWORD PTR __Next$[ebp], edx
$LN3@Uninit_fil@4:
	mov	eax, DWORD PTR __Next$[ebp]
	cmp	eax, DWORD PTR __First$[ebp]
	je	SHORT $LN1@Uninit_fil@4

; 407  : 		_Al.destroy(_Next);

	mov	ecx, DWORD PTR __Next$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?destroy@?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@QAEXPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@Z ; std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T>::destroy
	jmp	SHORT $LN2@Uninit_fil@4
$LN1@Uninit_fil@4:

; 408  : 	_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 409  : 	_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, $LN9@Uninit_fil@4
	ret	0
$LN10@Uninit_fil@4:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
$LN9@Uninit_fil@4:

; 410  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_fill_n@PAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@IU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@IABU123@AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_fill_n@PAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@IU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@IABU123@AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_fill_n@PAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@IU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@IABU123@AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T *,unsigned int,Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$_Uninit_fill_n@PAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@IU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@IABU123@AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_fill_n@PAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@IU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@IABU123@AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__unwindtable$??$_Uninit_fill_n@PAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@IU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@IABU123@AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Uninit_fill_n@PAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@IU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@IABU123@AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_fill_n@PAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@IU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@IABU123@AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2
__ehfuncinfo$??$_Uninit_fill_n@PAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@IU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@IABU123@AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Uninit_fill_n@PAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@IU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@IABU123@AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_fill_n@PAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@IU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@IABU123@AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??$_Uninit_fill_n@PAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@IU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@IABU123@AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_fill_n@PAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@IU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@IABU123@AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T *,unsigned int,Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >, COMDAT

; 393  : 	{	// copy _Count *_Val to raw _First, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_fill_n@PAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@IU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@IABU123@AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 394  : 
; 395  :  #if _HAS_ITERATOR_DEBUGGING
; 396  : //	if (_Count < 0)
; 397  : //		_DEBUG_ERROR("negative count in uninitialized fill");
; 398  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 399  : 
; 400  : 	_FwdIt _Next = _First;

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Next$[ebp], eax

; 401  : 
; 402  : 	_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 403  : 	for (; 0 < _Count; --_Count, ++_First)

	jmp	SHORT $LN6@Uninit_fil@5
$LN5@Uninit_fil@5:
	mov	ecx, DWORD PTR __Count$[ebp]
	sub	ecx, 1
	mov	DWORD PTR __Count$[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	add	edx, 32					; 00000020H
	mov	DWORD PTR __First$[ebp], edx
$LN6@Uninit_fil@5:
	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN4@Uninit_fil@5

; 404  : 		_Al.construct(_First, _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?construct@?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@QAEXPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@ABU345@@Z ; std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T>::construct
	jmp	SHORT $LN5@Uninit_fil@5
$LN4@Uninit_fil@5:
	jmp	SHORT $LN10@Uninit_fil@5
__catch$??$_Uninit_fill_n@PAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@IU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@IABU123@AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 405  : 	_CATCH_ALL
; 406  : 	for (; _Next != _First; ++_Next)

	jmp	SHORT $LN3@Uninit_fil@5
$LN2@Uninit_fil@5:
	mov	edx, DWORD PTR __Next$[ebp]
	add	edx, 32					; 00000020H
	mov	DWORD PTR __Next$[ebp], edx
$LN3@Uninit_fil@5:
	mov	eax, DWORD PTR __Next$[ebp]
	cmp	eax, DWORD PTR __First$[ebp]
	je	SHORT $LN1@Uninit_fil@5

; 407  : 		_Al.destroy(_Next);

	mov	ecx, DWORD PTR __Next$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?destroy@?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@QAEXPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@Z ; std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T>::destroy
	jmp	SHORT $LN2@Uninit_fil@5
$LN1@Uninit_fil@5:

; 408  : 	_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 409  : 	_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, $LN9@Uninit_fil@5
	ret	0
$LN10@Uninit_fil@5:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
$LN9@Uninit_fil@5:

; 410  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_fill_n@PAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@IU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@IABU123@AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_fill_n@PAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@IU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@IABU123@AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_fill_n@PAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@IU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@IABU123@AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T *,unsigned int,Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
;	COMDAT ??$_Destroy@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@YAXPAUAnimRange@BaseKeyFrameArray@Ogre@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@YAXPAUAnimRange@BaseKeyFrameArray@Ogre@@@Z PROC ; std::_Destroy<Ogre::BaseKeyFrameArray::AnimRange>, COMDAT

; 58   : 	{	// destroy object at _Ptr

	push	ebp
	mov	ebp, esp

; 59   : 	_DESTRUCTOR(_Ty, _Ptr);
; 60   : 	}

	pop	ebp
	ret	0
??$_Destroy@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@YAXPAUAnimRange@BaseKeyFrameArray@Ogre@@@Z ENDP ; std::_Destroy<Ogre::BaseKeyFrameArray::AnimRange>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Destroy@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@Z PROC ; std::_Destroy<Ogre::KeyFrameArray<float>::KEYFRAME_T>, COMDAT

; 58   : 	{	// destroy object at _Ptr

	push	ebp
	mov	ebp, esp

; 59   : 	_DESTRUCTOR(_Ty, _Ptr);
; 60   : 	}

	pop	ebp
	ret	0
??$_Destroy@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@Z ENDP ; std::_Destroy<Ogre::KeyFrameArray<float>::KEYFRAME_T>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Destroy@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@Z PROC ; std::_Destroy<Ogre::KeyFrameArray<float>::CONTROL_POINT_T>, COMDAT

; 58   : 	{	// destroy object at _Ptr

	push	ebp
	mov	ebp, esp

; 59   : 	_DESTRUCTOR(_Ty, _Ptr);
; 60   : 	}

	pop	ebp
	ret	0
??$_Destroy@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@Z ENDP ; std::_Destroy<Ogre::KeyFrameArray<float>::CONTROL_POINT_T>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Destroy@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@Z PROC ; std::_Destroy<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T>, COMDAT

; 58   : 	{	// destroy object at _Ptr

	push	ebp
	mov	ebp, esp

; 59   : 	_DESTRUCTOR(_Ty, _Ptr);
; 60   : 	}

	pop	ebp
	ret	0
??$_Destroy@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@Z ENDP ; std::_Destroy<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Destroy@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@Z PROC ; std::_Destroy<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T>, COMDAT

; 58   : 	{	// destroy object at _Ptr

	push	ebp
	mov	ebp, esp

; 59   : 	_DESTRUCTOR(_Ty, _Ptr);
; 60   : 	}

	pop	ebp
	ret	0
??$_Destroy@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@Z ENDP ; std::_Destroy<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Destroy@UContextQueDesc@Ogre@@@std@@YAXPAUContextQueDesc@Ogre@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@UContextQueDesc@Ogre@@@std@@YAXPAUContextQueDesc@Ogre@@@Z PROC ; std::_Destroy<Ogre::ContextQueDesc>, COMDAT

; 58   : 	{	// destroy object at _Ptr

	push	ebp
	mov	ebp, esp

; 59   : 	_DESTRUCTOR(_Ty, _Ptr);
; 60   : 	}

	pop	ebp
	ret	0
??$_Destroy@UContextQueDesc@Ogre@@@std@@YAXPAUContextQueDesc@Ogre@@@Z ENDP ; std::_Destroy<Ogre::ContextQueDesc>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Destroy@UValueParam@ShaderContextPool@Ogre@@@std@@YAXPAUValueParam@ShaderContextPool@Ogre@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@UValueParam@ShaderContextPool@Ogre@@@std@@YAXPAUValueParam@ShaderContextPool@Ogre@@@Z PROC ; std::_Destroy<Ogre::ShaderContextPool::ValueParam>, COMDAT

; 58   : 	{	// destroy object at _Ptr

	push	ebp
	mov	ebp, esp

; 59   : 	_DESTRUCTOR(_Ty, _Ptr);
; 60   : 	}

	pop	ebp
	ret	0
??$_Destroy@UValueParam@ShaderContextPool@Ogre@@@std@@YAXPAUValueParam@ShaderContextPool@Ogre@@@Z ENDP ; std::_Destroy<Ogre::ShaderContextPool::ValueParam>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Destroy@UTexParam@ShaderContextPool@Ogre@@@std@@YAXPAUTexParam@ShaderContextPool@Ogre@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@UTexParam@ShaderContextPool@Ogre@@@std@@YAXPAUTexParam@ShaderContextPool@Ogre@@@Z PROC ; std::_Destroy<Ogre::ShaderContextPool::TexParam>, COMDAT

; 58   : 	{	// destroy object at _Ptr

	push	ebp
	mov	ebp, esp

; 59   : 	_DESTRUCTOR(_Ty, _Ptr);
; 60   : 	}

	pop	ebp
	ret	0
??$_Destroy@UTexParam@ShaderContextPool@Ogre@@@std@@YAXPAUTexParam@ShaderContextPool@Ogre@@@Z ENDP ; std::_Destroy<Ogre::ShaderContextPool::TexParam>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Destroy@URecord@CullResult@Ogre@@@std@@YAXPAURecord@CullResult@Ogre@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@URecord@CullResult@Ogre@@@std@@YAXPAURecord@CullResult@Ogre@@@Z PROC ; std::_Destroy<Ogre::CullResult::Record>, COMDAT

; 58   : 	{	// destroy object at _Ptr

	push	ebp
	mov	ebp, esp

; 59   : 	_DESTRUCTOR(_Ty, _Ptr);
; 60   : 	}

	pop	ebp
	ret	0
??$_Destroy@URecord@CullResult@Ogre@@@std@@YAXPAURecord@CullResult@Ogre@@@Z ENDP ; std::_Destroy<Ogre::CullResult::Record>
_TEXT	ENDS
PUBLIC	??$_Construct@UAnimRange@BaseKeyFrameArray@Ogre@@U123@@std@@YAXPAUAnimRange@BaseKeyFrameArray@Ogre@@ABU123@@Z ; std::_Construct<Ogre::BaseKeyFrameArray::AnimRange,Ogre::BaseKeyFrameArray::AnimRange>
; Function compile flags: /Odtp
;	COMDAT ?construct@?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@QAEXPAUAnimRange@BaseKeyFrameArray@Ogre@@ABU345@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@QAEXPAUAnimRange@BaseKeyFrameArray@Ogre@@ABU345@@Z PROC ; std::allocator<Ogre::BaseKeyFrameArray::AnimRange>::construct, COMDAT
; _this$ = ecx

; 154  : 		{	// construct object at _Ptr with value _Val

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 155  : 		_Construct(_Ptr, _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	call	??$_Construct@UAnimRange@BaseKeyFrameArray@Ogre@@U123@@std@@YAXPAUAnimRange@BaseKeyFrameArray@Ogre@@ABU123@@Z ; std::_Construct<Ogre::BaseKeyFrameArray::AnimRange,Ogre::BaseKeyFrameArray::AnimRange>
	add	esp, 8

; 156  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?construct@?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@QAEXPAUAnimRange@BaseKeyFrameArray@Ogre@@ABU345@@Z ENDP ; std::allocator<Ogre::BaseKeyFrameArray::AnimRange>::construct
_TEXT	ENDS
PUBLIC	??$_Construct@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@U123@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@ABU123@@Z ; std::_Construct<Ogre::KeyFrameArray<float>::KEYFRAME_T,Ogre::KeyFrameArray<float>::KEYFRAME_T>
; Function compile flags: /Odtp
;	COMDAT ?construct@?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@QAEXPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@ABU345@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@QAEXPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@ABU345@@Z PROC ; std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T>::construct, COMDAT
; _this$ = ecx

; 154  : 		{	// construct object at _Ptr with value _Val

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 155  : 		_Construct(_Ptr, _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	call	??$_Construct@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@U123@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@ABU123@@Z ; std::_Construct<Ogre::KeyFrameArray<float>::KEYFRAME_T,Ogre::KeyFrameArray<float>::KEYFRAME_T>
	add	esp, 8

; 156  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?construct@?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@QAEXPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@ABU345@@Z ENDP ; std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T>::construct
_TEXT	ENDS
PUBLIC	??$_Construct@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@U123@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@ABU123@@Z ; std::_Construct<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,Ogre::KeyFrameArray<float>::CONTROL_POINT_T>
; Function compile flags: /Odtp
;	COMDAT ?construct@?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@QAEXPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@ABU345@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@QAEXPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@ABU345@@Z PROC ; std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T>::construct, COMDAT
; _this$ = ecx

; 154  : 		{	// construct object at _Ptr with value _Val

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 155  : 		_Construct(_Ptr, _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	call	??$_Construct@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@U123@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@ABU123@@Z ; std::_Construct<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,Ogre::KeyFrameArray<float>::CONTROL_POINT_T>
	add	esp, 8

; 156  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?construct@?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@QAEXPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@ABU345@@Z ENDP ; std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T>::construct
_TEXT	ENDS
PUBLIC	??$_Construct@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@U123@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@ABU123@@Z ; std::_Construct<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T>
; Function compile flags: /Odtp
;	COMDAT ?construct@?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@QAEXPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@ABU345@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@QAEXPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@ABU345@@Z PROC ; std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T>::construct, COMDAT
; _this$ = ecx

; 154  : 		{	// construct object at _Ptr with value _Val

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 155  : 		_Construct(_Ptr, _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	call	??$_Construct@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@U123@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@ABU123@@Z ; std::_Construct<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T>
	add	esp, 8

; 156  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?construct@?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@QAEXPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@ABU345@@Z ENDP ; std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T>::construct
_TEXT	ENDS
PUBLIC	??$_Construct@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@U123@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@ABU123@@Z ; std::_Construct<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T>
; Function compile flags: /Odtp
;	COMDAT ?construct@?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@QAEXPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@ABU345@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@QAEXPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@ABU345@@Z PROC ; std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T>::construct, COMDAT
; _this$ = ecx

; 154  : 		{	// construct object at _Ptr with value _Val

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 155  : 		_Construct(_Ptr, _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	call	??$_Construct@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@U123@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@ABU123@@Z ; std::_Construct<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T>
	add	esp, 8

; 156  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?construct@?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@QAEXPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@ABU345@@Z ENDP ; std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T>::construct
_TEXT	ENDS
PUBLIC	??$_Construct@UContextQueDesc@Ogre@@U12@@std@@YAXPAUContextQueDesc@Ogre@@ABU12@@Z ; std::_Construct<Ogre::ContextQueDesc,Ogre::ContextQueDesc>
; Function compile flags: /Odtp
;	COMDAT ?construct@?$allocator@UContextQueDesc@Ogre@@@std@@QAEXPAUContextQueDesc@Ogre@@ABU34@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@UContextQueDesc@Ogre@@@std@@QAEXPAUContextQueDesc@Ogre@@ABU34@@Z PROC ; std::allocator<Ogre::ContextQueDesc>::construct, COMDAT
; _this$ = ecx

; 154  : 		{	// construct object at _Ptr with value _Val

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 155  : 		_Construct(_Ptr, _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	call	??$_Construct@UContextQueDesc@Ogre@@U12@@std@@YAXPAUContextQueDesc@Ogre@@ABU12@@Z ; std::_Construct<Ogre::ContextQueDesc,Ogre::ContextQueDesc>
	add	esp, 8

; 156  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?construct@?$allocator@UContextQueDesc@Ogre@@@std@@QAEXPAUContextQueDesc@Ogre@@ABU34@@Z ENDP ; std::allocator<Ogre::ContextQueDesc>::construct
_TEXT	ENDS
PUBLIC	??$_Construct@UValueParam@ShaderContextPool@Ogre@@U123@@std@@YAXPAUValueParam@ShaderContextPool@Ogre@@ABU123@@Z ; std::_Construct<Ogre::ShaderContextPool::ValueParam,Ogre::ShaderContextPool::ValueParam>
; Function compile flags: /Odtp
;	COMDAT ?construct@?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@QAEXPAUValueParam@ShaderContextPool@Ogre@@ABU345@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@QAEXPAUValueParam@ShaderContextPool@Ogre@@ABU345@@Z PROC ; std::allocator<Ogre::ShaderContextPool::ValueParam>::construct, COMDAT
; _this$ = ecx

; 154  : 		{	// construct object at _Ptr with value _Val

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 155  : 		_Construct(_Ptr, _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	call	??$_Construct@UValueParam@ShaderContextPool@Ogre@@U123@@std@@YAXPAUValueParam@ShaderContextPool@Ogre@@ABU123@@Z ; std::_Construct<Ogre::ShaderContextPool::ValueParam,Ogre::ShaderContextPool::ValueParam>
	add	esp, 8

; 156  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?construct@?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@QAEXPAUValueParam@ShaderContextPool@Ogre@@ABU345@@Z ENDP ; std::allocator<Ogre::ShaderContextPool::ValueParam>::construct
_TEXT	ENDS
PUBLIC	??$_Construct@UTexParam@ShaderContextPool@Ogre@@U123@@std@@YAXPAUTexParam@ShaderContextPool@Ogre@@ABU123@@Z ; std::_Construct<Ogre::ShaderContextPool::TexParam,Ogre::ShaderContextPool::TexParam>
; Function compile flags: /Odtp
;	COMDAT ?construct@?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@QAEXPAUTexParam@ShaderContextPool@Ogre@@ABU345@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@QAEXPAUTexParam@ShaderContextPool@Ogre@@ABU345@@Z PROC ; std::allocator<Ogre::ShaderContextPool::TexParam>::construct, COMDAT
; _this$ = ecx

; 154  : 		{	// construct object at _Ptr with value _Val

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 155  : 		_Construct(_Ptr, _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	call	??$_Construct@UTexParam@ShaderContextPool@Ogre@@U123@@std@@YAXPAUTexParam@ShaderContextPool@Ogre@@ABU123@@Z ; std::_Construct<Ogre::ShaderContextPool::TexParam,Ogre::ShaderContextPool::TexParam>
	add	esp, 8

; 156  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?construct@?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@QAEXPAUTexParam@ShaderContextPool@Ogre@@ABU345@@Z ENDP ; std::allocator<Ogre::ShaderContextPool::TexParam>::construct
_TEXT	ENDS
PUBLIC	??$_Construct@URecord@CullResult@Ogre@@U123@@std@@YAXPAURecord@CullResult@Ogre@@ABU123@@Z ; std::_Construct<Ogre::CullResult::Record,Ogre::CullResult::Record>
; Function compile flags: /Odtp
;	COMDAT ?construct@?$allocator@URecord@CullResult@Ogre@@@std@@QAEXPAURecord@CullResult@Ogre@@ABU345@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@URecord@CullResult@Ogre@@@std@@QAEXPAURecord@CullResult@Ogre@@ABU345@@Z PROC ; std::allocator<Ogre::CullResult::Record>::construct, COMDAT
; _this$ = ecx

; 154  : 		{	// construct object at _Ptr with value _Val

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 155  : 		_Construct(_Ptr, _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	call	??$_Construct@URecord@CullResult@Ogre@@U123@@std@@YAXPAURecord@CullResult@Ogre@@ABU123@@Z ; std::_Construct<Ogre::CullResult::Record,Ogre::CullResult::Record>
	add	esp, 8

; 156  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?construct@?$allocator@URecord@CullResult@Ogre@@@std@@QAEXPAURecord@CullResult@Ogre@@ABU345@@Z ENDP ; std::allocator<Ogre::CullResult::Record>::construct
_TEXT	ENDS
PUBLIC	?_Checked_iterator_base@?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QBEPBUAnimRange@BaseKeyFrameArray@Ogre@@XZ ; std::_Vector_const_iterator<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::_Checked_iterator_base
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Checked_base@V?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBUAnimRange@BaseKeyFrameArray@Ogre@@AAV?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Checked_base@V?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBUAnimRange@BaseKeyFrameArray@Ogre@@AAV?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z PROC ; std::_Checked_base<std::_Vector_const_iterator<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >,std::_Different_checked_iterator_base_type_tag>, COMDAT

; 1138 : 	{

	push	ebp
	mov	ebp, esp

; 1139 : 		return _It._Checked_iterator_base();

	mov	ecx, DWORD PTR __It$[ebp]
	call	?_Checked_iterator_base@?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QBEPBUAnimRange@BaseKeyFrameArray@Ogre@@XZ ; std::_Vector_const_iterator<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::_Checked_iterator_base

; 1140 : 	}

	pop	ebp
	ret	0
??$_Checked_base@V?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBUAnimRange@BaseKeyFrameArray@Ogre@@AAV?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z ENDP ; std::_Checked_base<std::_Vector_const_iterator<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >,std::_Different_checked_iterator_base_type_tag>
_TEXT	ENDS
PUBLIC	?_Checked_iterator_base@?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QBEPBUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@XZ ; std::_Vector_const_iterator<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::_Checked_iterator_base
; Function compile flags: /Odtp
;	COMDAT ??$_Checked_base@V?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@AAV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Checked_base@V?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@AAV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z PROC ; std::_Checked_base<std::_Vector_const_iterator<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >,std::_Different_checked_iterator_base_type_tag>, COMDAT

; 1138 : 	{

	push	ebp
	mov	ebp, esp

; 1139 : 		return _It._Checked_iterator_base();

	mov	ecx, DWORD PTR __It$[ebp]
	call	?_Checked_iterator_base@?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QBEPBUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@XZ ; std::_Vector_const_iterator<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::_Checked_iterator_base

; 1140 : 	}

	pop	ebp
	ret	0
??$_Checked_base@V?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@AAV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z ENDP ; std::_Checked_base<std::_Vector_const_iterator<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >,std::_Different_checked_iterator_base_type_tag>
_TEXT	ENDS
PUBLIC	?_Checked_iterator_base@?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QBEPBUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@XZ ; std::_Vector_const_iterator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::_Checked_iterator_base
; Function compile flags: /Odtp
;	COMDAT ??$_Checked_base@V?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@AAV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Checked_base@V?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@AAV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z PROC ; std::_Checked_base<std::_Vector_const_iterator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >,std::_Different_checked_iterator_base_type_tag>, COMDAT

; 1138 : 	{

	push	ebp
	mov	ebp, esp

; 1139 : 		return _It._Checked_iterator_base();

	mov	ecx, DWORD PTR __It$[ebp]
	call	?_Checked_iterator_base@?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QBEPBUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@XZ ; std::_Vector_const_iterator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::_Checked_iterator_base

; 1140 : 	}

	pop	ebp
	ret	0
??$_Checked_base@V?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@AAV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z ENDP ; std::_Checked_base<std::_Vector_const_iterator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >,std::_Different_checked_iterator_base_type_tag>
_TEXT	ENDS
PUBLIC	?_Checked_iterator_base@?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QBEPBUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@XZ ; std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::_Checked_iterator_base
; Function compile flags: /Odtp
;	COMDAT ??$_Checked_base@V?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@AAV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Checked_base@V?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@AAV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z PROC ; std::_Checked_base<std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >,std::_Different_checked_iterator_base_type_tag>, COMDAT

; 1138 : 	{

	push	ebp
	mov	ebp, esp

; 1139 : 		return _It._Checked_iterator_base();

	mov	ecx, DWORD PTR __It$[ebp]
	call	?_Checked_iterator_base@?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QBEPBUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@XZ ; std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::_Checked_iterator_base

; 1140 : 	}

	pop	ebp
	ret	0
??$_Checked_base@V?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@AAV?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z ENDP ; std::_Checked_base<std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >,std::_Different_checked_iterator_base_type_tag>
_TEXT	ENDS
PUBLIC	?_Checked_iterator_base@?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QBEPBUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@XZ ; std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::_Checked_iterator_base
; Function compile flags: /Odtp
;	COMDAT ??$_Checked_base@V?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@AAV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Checked_base@V?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@AAV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z PROC ; std::_Checked_base<std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >,std::_Different_checked_iterator_base_type_tag>, COMDAT

; 1138 : 	{

	push	ebp
	mov	ebp, esp

; 1139 : 		return _It._Checked_iterator_base();

	mov	ecx, DWORD PTR __It$[ebp]
	call	?_Checked_iterator_base@?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QBEPBUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@XZ ; std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::_Checked_iterator_base

; 1140 : 	}

	pop	ebp
	ret	0
??$_Checked_base@V?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@AAV?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z ENDP ; std::_Checked_base<std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >,std::_Different_checked_iterator_base_type_tag>
_TEXT	ENDS
PUBLIC	?_Checked_iterator_base@?$_Vector_const_iterator@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@QBEPBQAVShaderContext@Ogre@@XZ ; std::_Vector_const_iterator<Ogre::ShaderContext *,std::allocator<Ogre::ShaderContext *> >::_Checked_iterator_base
; Function compile flags: /Odtp
;	COMDAT ??$_Checked_base@V?$_Vector_const_iterator@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBQAVShaderContext@Ogre@@AAV?$_Vector_const_iterator@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Checked_base@V?$_Vector_const_iterator@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBQAVShaderContext@Ogre@@AAV?$_Vector_const_iterator@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z PROC ; std::_Checked_base<std::_Vector_const_iterator<Ogre::ShaderContext *,std::allocator<Ogre::ShaderContext *> >,std::_Different_checked_iterator_base_type_tag>, COMDAT

; 1138 : 	{

	push	ebp
	mov	ebp, esp

; 1139 : 		return _It._Checked_iterator_base();

	mov	ecx, DWORD PTR __It$[ebp]
	call	?_Checked_iterator_base@?$_Vector_const_iterator@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@QBEPBQAVShaderContext@Ogre@@XZ ; std::_Vector_const_iterator<Ogre::ShaderContext *,std::allocator<Ogre::ShaderContext *> >::_Checked_iterator_base

; 1140 : 	}

	pop	ebp
	ret	0
??$_Checked_base@V?$_Vector_const_iterator@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBQAVShaderContext@Ogre@@AAV?$_Vector_const_iterator@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z ENDP ; std::_Checked_base<std::_Vector_const_iterator<Ogre::ShaderContext *,std::allocator<Ogre::ShaderContext *> >,std::_Different_checked_iterator_base_type_tag>
_TEXT	ENDS
PUBLIC	?_Checked_iterator_base@?$_Vector_const_iterator@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@QBEPBUContextQueDesc@Ogre@@XZ ; std::_Vector_const_iterator<Ogre::ContextQueDesc,std::allocator<Ogre::ContextQueDesc> >::_Checked_iterator_base
; Function compile flags: /Odtp
;	COMDAT ??$_Checked_base@V?$_Vector_const_iterator@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBUContextQueDesc@Ogre@@AAV?$_Vector_const_iterator@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Checked_base@V?$_Vector_const_iterator@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBUContextQueDesc@Ogre@@AAV?$_Vector_const_iterator@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z PROC ; std::_Checked_base<std::_Vector_const_iterator<Ogre::ContextQueDesc,std::allocator<Ogre::ContextQueDesc> >,std::_Different_checked_iterator_base_type_tag>, COMDAT

; 1138 : 	{

	push	ebp
	mov	ebp, esp

; 1139 : 		return _It._Checked_iterator_base();

	mov	ecx, DWORD PTR __It$[ebp]
	call	?_Checked_iterator_base@?$_Vector_const_iterator@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@QBEPBUContextQueDesc@Ogre@@XZ ; std::_Vector_const_iterator<Ogre::ContextQueDesc,std::allocator<Ogre::ContextQueDesc> >::_Checked_iterator_base

; 1140 : 	}

	pop	ebp
	ret	0
??$_Checked_base@V?$_Vector_const_iterator@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBUContextQueDesc@Ogre@@AAV?$_Vector_const_iterator@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z ENDP ; std::_Checked_base<std::_Vector_const_iterator<Ogre::ContextQueDesc,std::allocator<Ogre::ContextQueDesc> >,std::_Different_checked_iterator_base_type_tag>
_TEXT	ENDS
PUBLIC	?_Checked_iterator_base@?$_Vector_const_iterator@EV?$allocator@E@std@@@std@@QBEPBEXZ ; std::_Vector_const_iterator<unsigned char,std::allocator<unsigned char> >::_Checked_iterator_base
; Function compile flags: /Odtp
;	COMDAT ??$_Checked_base@V?$_Vector_const_iterator@EV?$allocator@E@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBEAAV?$_Vector_const_iterator@EV?$allocator@E@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Checked_base@V?$_Vector_const_iterator@EV?$allocator@E@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBEAAV?$_Vector_const_iterator@EV?$allocator@E@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z PROC ; std::_Checked_base<std::_Vector_const_iterator<unsigned char,std::allocator<unsigned char> >,std::_Different_checked_iterator_base_type_tag>, COMDAT

; 1138 : 	{

	push	ebp
	mov	ebp, esp

; 1139 : 		return _It._Checked_iterator_base();

	mov	ecx, DWORD PTR __It$[ebp]
	call	?_Checked_iterator_base@?$_Vector_const_iterator@EV?$allocator@E@std@@@std@@QBEPBEXZ ; std::_Vector_const_iterator<unsigned char,std::allocator<unsigned char> >::_Checked_iterator_base

; 1140 : 	}

	pop	ebp
	ret	0
??$_Checked_base@V?$_Vector_const_iterator@EV?$allocator@E@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBEAAV?$_Vector_const_iterator@EV?$allocator@E@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z ENDP ; std::_Checked_base<std::_Vector_const_iterator<unsigned char,std::allocator<unsigned char> >,std::_Different_checked_iterator_base_type_tag>
_TEXT	ENDS
PUBLIC	?_Checked_iterator_base@?$_Vector_const_iterator@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@QBEPBUValueParam@ShaderContextPool@Ogre@@XZ ; std::_Vector_const_iterator<Ogre::ShaderContextPool::ValueParam,std::allocator<Ogre::ShaderContextPool::ValueParam> >::_Checked_iterator_base
; Function compile flags: /Odtp
;	COMDAT ??$_Checked_base@V?$_Vector_const_iterator@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBUValueParam@ShaderContextPool@Ogre@@AAV?$_Vector_const_iterator@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Checked_base@V?$_Vector_const_iterator@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBUValueParam@ShaderContextPool@Ogre@@AAV?$_Vector_const_iterator@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z PROC ; std::_Checked_base<std::_Vector_const_iterator<Ogre::ShaderContextPool::ValueParam,std::allocator<Ogre::ShaderContextPool::ValueParam> >,std::_Different_checked_iterator_base_type_tag>, COMDAT

; 1138 : 	{

	push	ebp
	mov	ebp, esp

; 1139 : 		return _It._Checked_iterator_base();

	mov	ecx, DWORD PTR __It$[ebp]
	call	?_Checked_iterator_base@?$_Vector_const_iterator@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@QBEPBUValueParam@ShaderContextPool@Ogre@@XZ ; std::_Vector_const_iterator<Ogre::ShaderContextPool::ValueParam,std::allocator<Ogre::ShaderContextPool::ValueParam> >::_Checked_iterator_base

; 1140 : 	}

	pop	ebp
	ret	0
??$_Checked_base@V?$_Vector_const_iterator@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBUValueParam@ShaderContextPool@Ogre@@AAV?$_Vector_const_iterator@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z ENDP ; std::_Checked_base<std::_Vector_const_iterator<Ogre::ShaderContextPool::ValueParam,std::allocator<Ogre::ShaderContextPool::ValueParam> >,std::_Different_checked_iterator_base_type_tag>
_TEXT	ENDS
PUBLIC	?_Checked_iterator_base@?$_Vector_const_iterator@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@QBEPBUTexParam@ShaderContextPool@Ogre@@XZ ; std::_Vector_const_iterator<Ogre::ShaderContextPool::TexParam,std::allocator<Ogre::ShaderContextPool::TexParam> >::_Checked_iterator_base
; Function compile flags: /Odtp
;	COMDAT ??$_Checked_base@V?$_Vector_const_iterator@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBUTexParam@ShaderContextPool@Ogre@@AAV?$_Vector_const_iterator@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Checked_base@V?$_Vector_const_iterator@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBUTexParam@ShaderContextPool@Ogre@@AAV?$_Vector_const_iterator@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z PROC ; std::_Checked_base<std::_Vector_const_iterator<Ogre::ShaderContextPool::TexParam,std::allocator<Ogre::ShaderContextPool::TexParam> >,std::_Different_checked_iterator_base_type_tag>, COMDAT

; 1138 : 	{

	push	ebp
	mov	ebp, esp

; 1139 : 		return _It._Checked_iterator_base();

	mov	ecx, DWORD PTR __It$[ebp]
	call	?_Checked_iterator_base@?$_Vector_const_iterator@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@QBEPBUTexParam@ShaderContextPool@Ogre@@XZ ; std::_Vector_const_iterator<Ogre::ShaderContextPool::TexParam,std::allocator<Ogre::ShaderContextPool::TexParam> >::_Checked_iterator_base

; 1140 : 	}

	pop	ebp
	ret	0
??$_Checked_base@V?$_Vector_const_iterator@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBUTexParam@ShaderContextPool@Ogre@@AAV?$_Vector_const_iterator@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z ENDP ; std::_Checked_base<std::_Vector_const_iterator<Ogre::ShaderContextPool::TexParam,std::allocator<Ogre::ShaderContextPool::TexParam> >,std::_Different_checked_iterator_base_type_tag>
_TEXT	ENDS
PUBLIC	?_Checked_iterator_base@?$_Vector_const_iterator@DV?$allocator@D@std@@@std@@QBEPBDXZ ; std::_Vector_const_iterator<char,std::allocator<char> >::_Checked_iterator_base
; Function compile flags: /Odtp
;	COMDAT ??$_Checked_base@V?$_Vector_const_iterator@DV?$allocator@D@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBDAAV?$_Vector_const_iterator@DV?$allocator@D@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Checked_base@V?$_Vector_const_iterator@DV?$allocator@D@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBDAAV?$_Vector_const_iterator@DV?$allocator@D@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z PROC ; std::_Checked_base<std::_Vector_const_iterator<char,std::allocator<char> >,std::_Different_checked_iterator_base_type_tag>, COMDAT

; 1138 : 	{

	push	ebp
	mov	ebp, esp

; 1139 : 		return _It._Checked_iterator_base();

	mov	ecx, DWORD PTR __It$[ebp]
	call	?_Checked_iterator_base@?$_Vector_const_iterator@DV?$allocator@D@std@@@std@@QBEPBDXZ ; std::_Vector_const_iterator<char,std::allocator<char> >::_Checked_iterator_base

; 1140 : 	}

	pop	ebp
	ret	0
??$_Checked_base@V?$_Vector_const_iterator@DV?$allocator@D@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBDAAV?$_Vector_const_iterator@DV?$allocator@D@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z ENDP ; std::_Checked_base<std::_Vector_const_iterator<char,std::allocator<char> >,std::_Different_checked_iterator_base_type_tag>
_TEXT	ENDS
PUBLIC	?_Checked_iterator_base@?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QBEPBQAVSurfaceData@Ogre@@XZ ; std::_Vector_const_iterator<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::_Checked_iterator_base
; Function compile flags: /Odtp
;	COMDAT ??$_Checked_base@V?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBQAVSurfaceData@Ogre@@AAV?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Checked_base@V?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBQAVSurfaceData@Ogre@@AAV?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z PROC ; std::_Checked_base<std::_Vector_const_iterator<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >,std::_Different_checked_iterator_base_type_tag>, COMDAT

; 1138 : 	{

	push	ebp
	mov	ebp, esp

; 1139 : 		return _It._Checked_iterator_base();

	mov	ecx, DWORD PTR __It$[ebp]
	call	?_Checked_iterator_base@?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QBEPBQAVSurfaceData@Ogre@@XZ ; std::_Vector_const_iterator<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::_Checked_iterator_base

; 1140 : 	}

	pop	ebp
	ret	0
??$_Checked_base@V?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBQAVSurfaceData@Ogre@@AAV?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z ENDP ; std::_Checked_base<std::_Vector_const_iterator<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >,std::_Different_checked_iterator_base_type_tag>
_TEXT	ENDS
PUBLIC	?_Checked_iterator_base@?$_Vector_const_iterator@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@QBEPBURecord@CullResult@Ogre@@XZ ; std::_Vector_const_iterator<Ogre::CullResult::Record,std::allocator<Ogre::CullResult::Record> >::_Checked_iterator_base
; Function compile flags: /Odtp
;	COMDAT ??$_Checked_base@V?$_Vector_const_iterator@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBURecord@CullResult@Ogre@@AAV?$_Vector_const_iterator@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Checked_base@V?$_Vector_const_iterator@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBURecord@CullResult@Ogre@@AAV?$_Vector_const_iterator@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z PROC ; std::_Checked_base<std::_Vector_const_iterator<Ogre::CullResult::Record,std::allocator<Ogre::CullResult::Record> >,std::_Different_checked_iterator_base_type_tag>, COMDAT

; 1138 : 	{

	push	ebp
	mov	ebp, esp

; 1139 : 		return _It._Checked_iterator_base();

	mov	ecx, DWORD PTR __It$[ebp]
	call	?_Checked_iterator_base@?$_Vector_const_iterator@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@QBEPBURecord@CullResult@Ogre@@XZ ; std::_Vector_const_iterator<Ogre::CullResult::Record,std::allocator<Ogre::CullResult::Record> >::_Checked_iterator_base

; 1140 : 	}

	pop	ebp
	ret	0
??$_Checked_base@V?$_Vector_const_iterator@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBURecord@CullResult@Ogre@@AAV?$_Vector_const_iterator@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z ENDP ; std::_Checked_base<std::_Vector_const_iterator<Ogre::CullResult::Record,std::allocator<Ogre::CullResult::Record> >,std::_Different_checked_iterator_base_type_tag>
_TEXT	ENDS
PUBLIC	?_Checked_iterator_base@?$_Vector_const_iterator@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@QBEPBQAVEffectObject@Ogre@@XZ ; std::_Vector_const_iterator<Ogre::EffectObject *,std::allocator<Ogre::EffectObject *> >::_Checked_iterator_base
; Function compile flags: /Odtp
;	COMDAT ??$_Checked_base@V?$_Vector_const_iterator@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBQAVEffectObject@Ogre@@AAV?$_Vector_const_iterator@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Checked_base@V?$_Vector_const_iterator@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBQAVEffectObject@Ogre@@AAV?$_Vector_const_iterator@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z PROC ; std::_Checked_base<std::_Vector_const_iterator<Ogre::EffectObject *,std::allocator<Ogre::EffectObject *> >,std::_Different_checked_iterator_base_type_tag>, COMDAT

; 1138 : 	{

	push	ebp
	mov	ebp, esp

; 1139 : 		return _It._Checked_iterator_base();

	mov	ecx, DWORD PTR __It$[ebp]
	call	?_Checked_iterator_base@?$_Vector_const_iterator@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@QBEPBQAVEffectObject@Ogre@@XZ ; std::_Vector_const_iterator<Ogre::EffectObject *,std::allocator<Ogre::EffectObject *> >::_Checked_iterator_base

; 1140 : 	}

	pop	ebp
	ret	0
??$_Checked_base@V?$_Vector_const_iterator@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBQAVEffectObject@Ogre@@AAV?$_Vector_const_iterator@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z ENDP ; std::_Checked_base<std::_Vector_const_iterator<Ogre::EffectObject *,std::allocator<Ogre::EffectObject *> >,std::_Different_checked_iterator_base_type_tag>
_TEXT	ENDS
PUBLIC	?_Checked_iterator_base@?$_Vector_const_iterator@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@QBEPBQAVSoundNode@Ogre@@XZ ; std::_Vector_const_iterator<Ogre::SoundNode *,std::allocator<Ogre::SoundNode *> >::_Checked_iterator_base
; Function compile flags: /Odtp
;	COMDAT ??$_Checked_base@V?$_Vector_const_iterator@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBQAVSoundNode@Ogre@@AAV?$_Vector_const_iterator@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Checked_base@V?$_Vector_const_iterator@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBQAVSoundNode@Ogre@@AAV?$_Vector_const_iterator@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z PROC ; std::_Checked_base<std::_Vector_const_iterator<Ogre::SoundNode *,std::allocator<Ogre::SoundNode *> >,std::_Different_checked_iterator_base_type_tag>, COMDAT

; 1138 : 	{

	push	ebp
	mov	ebp, esp

; 1139 : 		return _It._Checked_iterator_base();

	mov	ecx, DWORD PTR __It$[ebp]
	call	?_Checked_iterator_base@?$_Vector_const_iterator@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@QBEPBQAVSoundNode@Ogre@@XZ ; std::_Vector_const_iterator<Ogre::SoundNode *,std::allocator<Ogre::SoundNode *> >::_Checked_iterator_base

; 1140 : 	}

	pop	ebp
	ret	0
??$_Checked_base@V?$_Vector_const_iterator@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBQAVSoundNode@Ogre@@AAV?$_Vector_const_iterator@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z ENDP ; std::_Checked_base<std::_Vector_const_iterator<Ogre::SoundNode *,std::allocator<Ogre::SoundNode *> >,std::_Different_checked_iterator_base_type_tag>
_TEXT	ENDS
PUBLIC	?_Checked_iterator_base@?$_Vector_const_iterator@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@QBEPBQAVRenderableObject@Ogre@@XZ ; std::_Vector_const_iterator<Ogre::RenderableObject *,std::allocator<Ogre::RenderableObject *> >::_Checked_iterator_base
; Function compile flags: /Odtp
;	COMDAT ??$_Checked_base@V?$_Vector_const_iterator@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBQAVRenderableObject@Ogre@@AAV?$_Vector_const_iterator@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Checked_base@V?$_Vector_const_iterator@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBQAVRenderableObject@Ogre@@AAV?$_Vector_const_iterator@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z PROC ; std::_Checked_base<std::_Vector_const_iterator<Ogre::RenderableObject *,std::allocator<Ogre::RenderableObject *> >,std::_Different_checked_iterator_base_type_tag>, COMDAT

; 1138 : 	{

	push	ebp
	mov	ebp, esp

; 1139 : 		return _It._Checked_iterator_base();

	mov	ecx, DWORD PTR __It$[ebp]
	call	?_Checked_iterator_base@?$_Vector_const_iterator@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@QBEPBQAVRenderableObject@Ogre@@XZ ; std::_Vector_const_iterator<Ogre::RenderableObject *,std::allocator<Ogre::RenderableObject *> >::_Checked_iterator_base

; 1140 : 	}

	pop	ebp
	ret	0
??$_Checked_base@V?$_Vector_const_iterator@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBQAVRenderableObject@Ogre@@AAV?$_Vector_const_iterator@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z ENDP ; std::_Checked_base<std::_Vector_const_iterator<Ogre::RenderableObject *,std::allocator<Ogre::RenderableObject *> >,std::_Different_checked_iterator_base_type_tag>
_TEXT	ENDS
PUBLIC	?_Checked_iterator_base@?$_Vector_const_iterator@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@QBEPBQAVLight@Ogre@@XZ ; std::_Vector_const_iterator<Ogre::Light *,std::allocator<Ogre::Light *> >::_Checked_iterator_base
; Function compile flags: /Odtp
;	COMDAT ??$_Checked_base@V?$_Vector_const_iterator@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBQAVLight@Ogre@@AAV?$_Vector_const_iterator@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Checked_base@V?$_Vector_const_iterator@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBQAVLight@Ogre@@AAV?$_Vector_const_iterator@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z PROC ; std::_Checked_base<std::_Vector_const_iterator<Ogre::Light *,std::allocator<Ogre::Light *> >,std::_Different_checked_iterator_base_type_tag>, COMDAT

; 1138 : 	{

	push	ebp
	mov	ebp, esp

; 1139 : 		return _It._Checked_iterator_base();

	mov	ecx, DWORD PTR __It$[ebp]
	call	?_Checked_iterator_base@?$_Vector_const_iterator@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@QBEPBQAVLight@Ogre@@XZ ; std::_Vector_const_iterator<Ogre::Light *,std::allocator<Ogre::Light *> >::_Checked_iterator_base

; 1140 : 	}

	pop	ebp
	ret	0
??$_Checked_base@V?$_Vector_const_iterator@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBQAVLight@Ogre@@AAV?$_Vector_const_iterator@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z ENDP ; std::_Checked_base<std::_Vector_const_iterator<Ogre::Light *,std::allocator<Ogre::Light *> >,std::_Different_checked_iterator_base_type_tag>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$_Uninit_move@PAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@U_Undefined_move_tag@5@@std@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@00AAV?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_move@PAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@U_Undefined_move_tag@5@@std@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@00AAV?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_move<Ogre::BaseKeyFrameArray::AnimRange *,Ogre::BaseKeyFrameArray::AnimRange *,std::allocator<Ogre::BaseKeyFrameArray::AnimRange>,std::_Undefined_move_tag>, COMDAT

; 206  : 	{	// move defaults to copy if there is not a more effecient way

	push	ebp
	mov	ebp, esp

; 207  : 	return (_STDEXT unchecked_uninitialized_copy(_First, _Last, _Dest, _Al));

	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$unchecked_uninitialized_copy@PAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@stdext@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@00AAV?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@Z ; stdext::unchecked_uninitialized_copy<Ogre::BaseKeyFrameArray::AnimRange *,Ogre::BaseKeyFrameArray::AnimRange *,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >
	add	esp, 16					; 00000010H

; 208  : 	}

	pop	ebp
	ret	0
??$_Uninit_move@PAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@U_Undefined_move_tag@5@@std@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@00AAV?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_move<Ogre::BaseKeyFrameArray::AnimRange *,Ogre::BaseKeyFrameArray::AnimRange *,std::allocator<Ogre::BaseKeyFrameArray::AnimRange>,std::_Undefined_move_tag>
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@PAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@Uforward_iterator_tag@std@@@std@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<Ogre::BaseKeyFrameArray::AnimRange *,Ogre::BaseKeyFrameArray::AnimRange *,std::forward_iterator_tag>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Copy_backward_opt@PAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@@std@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T99139 = -7						; size = 1
$T99138 = -6						; size = 1
$T99137 = -5						; size = 1
__Result$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_backward_opt@PAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@@std@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<Ogre::BaseKeyFrameArray::AnimRange *,Ogre::BaseKeyFrameArray::AnimRange *>, COMDAT

; 2685 : 	{	// copy [_First, _Last) backwards to [..., _Dest), arbitrary iterators

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 2686 : 	// if _OutIt is range checked, this will make sure there is enough space for the copy
; 2687 : 	_OutIt _Result = _Dest - (_Last - _First);

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 3
	shl	eax, 3
	mov	ecx, DWORD PTR __Dest$[ebp]
	sub	ecx, eax
	mov	DWORD PTR __Result$[ebp], ecx

; 2688 : 	_Copy_backward_opt(_First, _Last, _CHECKED_BASE(_Dest),
; 2689 : 		forward_iterator_tag(), _Nonscalar_ptr_iterator_tag(), _Range_checked_iterator_tag());

	xor	edx, edx
	mov	BYTE PTR $T99137[ebp], dl
	xor	eax, eax
	mov	BYTE PTR $T99138[ebp], al
	movzx	ecx, BYTE PTR $T99137[ebp]
	push	ecx
	movzx	edx, BYTE PTR $T99138[ebp]
	push	edx
	movzx	eax, BYTE PTR $T99139[ebp]
	push	eax
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	??$_Checked_base@PAUAnimRange@BaseKeyFrameArray@Ogre@@@std@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@AAPAU123@@Z ; std::_Checked_base<Ogre::BaseKeyFrameArray::AnimRange *>
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Copy_backward_opt@PAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@Uforward_iterator_tag@std@@@std@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<Ogre::BaseKeyFrameArray::AnimRange *,Ogre::BaseKeyFrameArray::AnimRange *,std::forward_iterator_tag>
	add	esp, 24					; 00000018H

; 2690 : 	return _Result;

	mov	eax, DWORD PTR __Result$[ebp]

; 2691 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Copy_backward_opt@PAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@@std@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<Ogre::BaseKeyFrameArray::AnimRange *,Ogre::BaseKeyFrameArray::AnimRange *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$_Uninit_move@PAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@U_Undefined_move_tag@5@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU123@00AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_move@PAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@U_Undefined_move_tag@5@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU123@00AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_move<Ogre::KeyFrameArray<float>::KEYFRAME_T *,Ogre::KeyFrameArray<float>::KEYFRAME_T *,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T>,std::_Undefined_move_tag>, COMDAT

; 206  : 	{	// move defaults to copy if there is not a more effecient way

	push	ebp
	mov	ebp, esp

; 207  : 	return (_STDEXT unchecked_uninitialized_copy(_First, _Last, _Dest, _Al));

	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$unchecked_uninitialized_copy@PAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@stdext@@YAPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU123@00AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@Z ; stdext::unchecked_uninitialized_copy<Ogre::KeyFrameArray<float>::KEYFRAME_T *,Ogre::KeyFrameArray<float>::KEYFRAME_T *,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >
	add	esp, 16					; 00000010H

; 208  : 	}

	pop	ebp
	ret	0
??$_Uninit_move@PAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@U_Undefined_move_tag@5@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU123@00AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_move<Ogre::KeyFrameArray<float>::KEYFRAME_T *,Ogre::KeyFrameArray<float>::KEYFRAME_T *,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T>,std::_Undefined_move_tag>
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@PAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU123@Uforward_iterator_tag@std@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU123@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<Ogre::KeyFrameArray<float>::KEYFRAME_T *,Ogre::KeyFrameArray<float>::KEYFRAME_T *,std::forward_iterator_tag>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Copy_backward_opt@PAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU123@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU123@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T99146 = -7						; size = 1
$T99145 = -6						; size = 1
$T99144 = -5						; size = 1
__Result$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_backward_opt@PAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU123@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU123@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<Ogre::KeyFrameArray<float>::KEYFRAME_T *,Ogre::KeyFrameArray<float>::KEYFRAME_T *>, COMDAT

; 2685 : 	{	// copy [_First, _Last) backwards to [..., _Dest), arbitrary iterators

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 2686 : 	// if _OutIt is range checked, this will make sure there is enough space for the copy
; 2687 : 	_OutIt _Result = _Dest - (_Last - _First);

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 3
	shl	eax, 3
	mov	ecx, DWORD PTR __Dest$[ebp]
	sub	ecx, eax
	mov	DWORD PTR __Result$[ebp], ecx

; 2688 : 	_Copy_backward_opt(_First, _Last, _CHECKED_BASE(_Dest),
; 2689 : 		forward_iterator_tag(), _Nonscalar_ptr_iterator_tag(), _Range_checked_iterator_tag());

	xor	edx, edx
	mov	BYTE PTR $T99144[ebp], dl
	xor	eax, eax
	mov	BYTE PTR $T99145[ebp], al
	movzx	ecx, BYTE PTR $T99144[ebp]
	push	ecx
	movzx	edx, BYTE PTR $T99145[ebp]
	push	edx
	movzx	eax, BYTE PTR $T99146[ebp]
	push	eax
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	??$_Checked_base@PAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@AAPAU123@@Z ; std::_Checked_base<Ogre::KeyFrameArray<float>::KEYFRAME_T *>
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Copy_backward_opt@PAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU123@Uforward_iterator_tag@std@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU123@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<Ogre::KeyFrameArray<float>::KEYFRAME_T *,Ogre::KeyFrameArray<float>::KEYFRAME_T *,std::forward_iterator_tag>
	add	esp, 24					; 00000018H

; 2690 : 	return _Result;

	mov	eax, DWORD PTR __Result$[ebp]

; 2691 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Copy_backward_opt@PAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU123@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU123@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<Ogre::KeyFrameArray<float>::KEYFRAME_T *,Ogre::KeyFrameArray<float>::KEYFRAME_T *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$_Uninit_move@PAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@U_Undefined_move_tag@5@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU123@00AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_move@PAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@U_Undefined_move_tag@5@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU123@00AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_move<Ogre::KeyFrameArray<float>::CONTROL_POINT_T *,Ogre::KeyFrameArray<float>::CONTROL_POINT_T *,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T>,std::_Undefined_move_tag>, COMDAT

; 206  : 	{	// move defaults to copy if there is not a more effecient way

	push	ebp
	mov	ebp, esp

; 207  : 	return (_STDEXT unchecked_uninitialized_copy(_First, _Last, _Dest, _Al));

	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$unchecked_uninitialized_copy@PAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@stdext@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU123@00AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@Z ; stdext::unchecked_uninitialized_copy<Ogre::KeyFrameArray<float>::CONTROL_POINT_T *,Ogre::KeyFrameArray<float>::CONTROL_POINT_T *,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >
	add	esp, 16					; 00000010H

; 208  : 	}

	pop	ebp
	ret	0
??$_Uninit_move@PAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@U_Undefined_move_tag@5@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU123@00AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_move<Ogre::KeyFrameArray<float>::CONTROL_POINT_T *,Ogre::KeyFrameArray<float>::CONTROL_POINT_T *,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T>,std::_Undefined_move_tag>
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@PAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU123@Uforward_iterator_tag@std@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU123@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<Ogre::KeyFrameArray<float>::CONTROL_POINT_T *,Ogre::KeyFrameArray<float>::CONTROL_POINT_T *,std::forward_iterator_tag>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Copy_backward_opt@PAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU123@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU123@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T99153 = -7						; size = 1
$T99152 = -6						; size = 1
$T99151 = -5						; size = 1
__Result$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_backward_opt@PAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU123@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU123@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<Ogre::KeyFrameArray<float>::CONTROL_POINT_T *,Ogre::KeyFrameArray<float>::CONTROL_POINT_T *>, COMDAT

; 2685 : 	{	// copy [_First, _Last) backwards to [..., _Dest), arbitrary iterators

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 2686 : 	// if _OutIt is range checked, this will make sure there is enough space for the copy
; 2687 : 	_OutIt _Result = _Dest - (_Last - _First);

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 3
	shl	eax, 3
	mov	ecx, DWORD PTR __Dest$[ebp]
	sub	ecx, eax
	mov	DWORD PTR __Result$[ebp], ecx

; 2688 : 	_Copy_backward_opt(_First, _Last, _CHECKED_BASE(_Dest),
; 2689 : 		forward_iterator_tag(), _Nonscalar_ptr_iterator_tag(), _Range_checked_iterator_tag());

	xor	edx, edx
	mov	BYTE PTR $T99151[ebp], dl
	xor	eax, eax
	mov	BYTE PTR $T99152[ebp], al
	movzx	ecx, BYTE PTR $T99151[ebp]
	push	ecx
	movzx	edx, BYTE PTR $T99152[ebp]
	push	edx
	movzx	eax, BYTE PTR $T99153[ebp]
	push	eax
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	??$_Checked_base@PAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@AAPAU123@@Z ; std::_Checked_base<Ogre::KeyFrameArray<float>::CONTROL_POINT_T *>
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Copy_backward_opt@PAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU123@Uforward_iterator_tag@std@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU123@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<Ogre::KeyFrameArray<float>::CONTROL_POINT_T *,Ogre::KeyFrameArray<float>::CONTROL_POINT_T *,std::forward_iterator_tag>
	add	esp, 24					; 00000018H

; 2690 : 	return _Result;

	mov	eax, DWORD PTR __Result$[ebp]

; 2691 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Copy_backward_opt@PAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU123@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU123@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<Ogre::KeyFrameArray<float>::CONTROL_POINT_T *,Ogre::KeyFrameArray<float>::CONTROL_POINT_T *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$_Uninit_move@PAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@U_Undefined_move_tag@5@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_move@PAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@U_Undefined_move_tag@5@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_move<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T *,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T>,std::_Undefined_move_tag>, COMDAT

; 206  : 	{	// move defaults to copy if there is not a more effecient way

	push	ebp
	mov	ebp, esp

; 207  : 	return (_STDEXT unchecked_uninitialized_copy(_First, _Last, _Dest, _Al));

	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$unchecked_uninitialized_copy@PAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@stdext@@YAPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@Z ; stdext::unchecked_uninitialized_copy<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T *,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >
	add	esp, 16					; 00000010H

; 208  : 	}

	pop	ebp
	ret	0
??$_Uninit_move@PAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@U_Undefined_move_tag@5@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_move<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T *,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T>,std::_Undefined_move_tag>
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@PAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@Uforward_iterator_tag@std@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T *,std::forward_iterator_tag>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Copy_backward_opt@PAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T99160 = -7						; size = 1
$T99159 = -6						; size = 1
$T99158 = -5						; size = 1
__Result$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_backward_opt@PAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T *>, COMDAT

; 2685 : 	{	// copy [_First, _Last) backwards to [..., _Dest), arbitrary iterators

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 2686 : 	// if _OutIt is range checked, this will make sure there is enough space for the copy
; 2687 : 	_OutIt _Result = _Dest - (_Last - _First);

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	cdq
	mov	ecx, 20					; 00000014H
	idiv	ecx
	imul	eax, 20					; 00000014H
	mov	edx, DWORD PTR __Dest$[ebp]
	sub	edx, eax
	mov	DWORD PTR __Result$[ebp], edx

; 2688 : 	_Copy_backward_opt(_First, _Last, _CHECKED_BASE(_Dest),
; 2689 : 		forward_iterator_tag(), _Nonscalar_ptr_iterator_tag(), _Range_checked_iterator_tag());

	xor	eax, eax
	mov	BYTE PTR $T99158[ebp], al
	xor	ecx, ecx
	mov	BYTE PTR $T99159[ebp], cl
	movzx	edx, BYTE PTR $T99158[ebp]
	push	edx
	movzx	eax, BYTE PTR $T99159[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T99160[ebp]
	push	ecx
	lea	edx, DWORD PTR __Dest$[ebp]
	push	edx
	call	??$_Checked_base@PAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@AAPAU123@@Z ; std::_Checked_base<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T *>
	add	esp, 4
	push	eax
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Copy_backward_opt@PAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@Uforward_iterator_tag@std@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T *,std::forward_iterator_tag>
	add	esp, 24					; 00000018H

; 2690 : 	return _Result;

	mov	eax, DWORD PTR __Result$[ebp]

; 2691 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Copy_backward_opt@PAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$_Uninit_move@PAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@U_Undefined_move_tag@5@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_move@PAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@U_Undefined_move_tag@5@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_move<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T *,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T>,std::_Undefined_move_tag>, COMDAT

; 206  : 	{	// move defaults to copy if there is not a more effecient way

	push	ebp
	mov	ebp, esp

; 207  : 	return (_STDEXT unchecked_uninitialized_copy(_First, _Last, _Dest, _Al));

	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$unchecked_uninitialized_copy@PAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@stdext@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@Z ; stdext::unchecked_uninitialized_copy<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T *,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >
	add	esp, 16					; 00000010H

; 208  : 	}

	pop	ebp
	ret	0
??$_Uninit_move@PAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@U_Undefined_move_tag@5@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@00AAV?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@0@U_Undefined_move_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_move<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T *,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T>,std::_Undefined_move_tag>
_TEXT	ENDS
PUBLIC	??$_Copy_backward_opt@PAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@Uforward_iterator_tag@std@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T *,std::forward_iterator_tag>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Copy_backward_opt@PAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T99167 = -7						; size = 1
$T99166 = -6						; size = 1
$T99165 = -5						; size = 1
__Result$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_backward_opt@PAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T *>, COMDAT

; 2685 : 	{	// copy [_First, _Last) backwards to [..., _Dest), arbitrary iterators

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 2686 : 	// if _OutIt is range checked, this will make sure there is enough space for the copy
; 2687 : 	_OutIt _Result = _Dest - (_Last - _First);

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 5
	shl	eax, 5
	mov	ecx, DWORD PTR __Dest$[ebp]
	sub	ecx, eax
	mov	DWORD PTR __Result$[ebp], ecx

; 2688 : 	_Copy_backward_opt(_First, _Last, _CHECKED_BASE(_Dest),
; 2689 : 		forward_iterator_tag(), _Nonscalar_ptr_iterator_tag(), _Range_checked_iterator_tag());

	xor	edx, edx
	mov	BYTE PTR $T99165[ebp], dl
	xor	eax, eax
	mov	BYTE PTR $T99166[ebp], al
	movzx	ecx, BYTE PTR $T99165[ebp]
	push	ecx
	movzx	edx, BYTE PTR $T99166[ebp]
	push	edx
	movzx	eax, BYTE PTR $T99167[ebp]
	push	eax
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	??$_Checked_base@PAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@AAPAU123@@Z ; std::_Checked_base<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T *>
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Copy_backward_opt@PAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@Uforward_iterator_tag@std@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T *,std::forward_iterator_tag>
	add	esp, 24					; 00000018H

; 2690 : 	return _Result;

	mov	eax, DWORD PTR __Result$[ebp]

; 2691 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Copy_backward_opt@PAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T *>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Construct@UAnimRange@BaseKeyFrameArray@Ogre@@U123@@std@@YAXPAUAnimRange@BaseKeyFrameArray@Ogre@@ABU123@@Z
_TEXT	SEGMENT
tv69 = -12						; size = 4
$T99170 = -8						; size = 4
__Vptr$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@UAnimRange@BaseKeyFrameArray@Ogre@@U123@@std@@YAXPAUAnimRange@BaseKeyFrameArray@Ogre@@ABU123@@Z PROC ; std::_Construct<Ogre::BaseKeyFrameArray::AnimRange,Ogre::BaseKeyFrameArray::AnimRange>, COMDAT

; 50   : 	{	// construct object at _Ptr with value _Val

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 51   : 	void _FARQ *_Vptr = _Ptr;

	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR __Vptr$[ebp], eax

; 52   : 	::new (_Vptr) _T1(_Val);

	mov	ecx, DWORD PTR __Vptr$[ebp]
	push	ecx
	push	8
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T99170[ebp], eax
	cmp	DWORD PTR $T99170[ebp], 0
	je	SHORT $LN3@Construct
	mov	edx, DWORD PTR __Val$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR $T99170[ebp]
	mov	DWORD PTR [edx], eax
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR $T99170[ebp]
	mov	DWORD PTR tv69[ebp], eax
	jmp	SHORT $LN1@Construct
$LN3@Construct:
	mov	DWORD PTR tv69[ebp], 0
$LN1@Construct:

; 53   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Construct@UAnimRange@BaseKeyFrameArray@Ogre@@U123@@std@@YAXPAUAnimRange@BaseKeyFrameArray@Ogre@@ABU123@@Z ENDP ; std::_Construct<Ogre::BaseKeyFrameArray::AnimRange,Ogre::BaseKeyFrameArray::AnimRange>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Construct@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@U123@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@ABU123@@Z
_TEXT	SEGMENT
tv69 = -12						; size = 4
$T99175 = -8						; size = 4
__Vptr$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@U123@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@ABU123@@Z PROC ; std::_Construct<Ogre::KeyFrameArray<float>::KEYFRAME_T,Ogre::KeyFrameArray<float>::KEYFRAME_T>, COMDAT

; 50   : 	{	// construct object at _Ptr with value _Val

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 51   : 	void _FARQ *_Vptr = _Ptr;

	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR __Vptr$[ebp], eax

; 52   : 	::new (_Vptr) _T1(_Val);

	mov	ecx, DWORD PTR __Vptr$[ebp]
	push	ecx
	push	8
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T99175[ebp], eax
	cmp	DWORD PTR $T99175[ebp], 0
	je	SHORT $LN3@Construct@2
	mov	edx, DWORD PTR __Val$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR $T99175[ebp]
	mov	DWORD PTR [edx], eax
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR $T99175[ebp]
	mov	DWORD PTR tv69[ebp], eax
	jmp	SHORT $LN1@Construct@2
$LN3@Construct@2:
	mov	DWORD PTR tv69[ebp], 0
$LN1@Construct@2:

; 53   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Construct@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@U123@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@ABU123@@Z ENDP ; std::_Construct<Ogre::KeyFrameArray<float>::KEYFRAME_T,Ogre::KeyFrameArray<float>::KEYFRAME_T>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Construct@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@U123@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@ABU123@@Z
_TEXT	SEGMENT
tv69 = -12						; size = 4
$T99180 = -8						; size = 4
__Vptr$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@U123@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@ABU123@@Z PROC ; std::_Construct<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,Ogre::KeyFrameArray<float>::CONTROL_POINT_T>, COMDAT

; 50   : 	{	// construct object at _Ptr with value _Val

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 51   : 	void _FARQ *_Vptr = _Ptr;

	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR __Vptr$[ebp], eax

; 52   : 	::new (_Vptr) _T1(_Val);

	mov	ecx, DWORD PTR __Vptr$[ebp]
	push	ecx
	push	8
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T99180[ebp], eax
	cmp	DWORD PTR $T99180[ebp], 0
	je	SHORT $LN3@Construct@3
	mov	edx, DWORD PTR __Val$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR $T99180[ebp]
	mov	DWORD PTR [edx], eax
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR $T99180[ebp]
	mov	DWORD PTR tv69[ebp], eax
	jmp	SHORT $LN1@Construct@3
$LN3@Construct@3:
	mov	DWORD PTR tv69[ebp], 0
$LN1@Construct@3:

; 53   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Construct@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@U123@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@ABU123@@Z ENDP ; std::_Construct<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,Ogre::KeyFrameArray<float>::CONTROL_POINT_T>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Construct@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@U123@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@ABU123@@Z
_TEXT	SEGMENT
tv69 = -12						; size = 4
$T99185 = -8						; size = 4
__Vptr$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@U123@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@ABU123@@Z PROC ; std::_Construct<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T>, COMDAT

; 50   : 	{	// construct object at _Ptr with value _Val

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 51   : 	void _FARQ *_Vptr = _Ptr;

	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR __Vptr$[ebp], eax

; 52   : 	::new (_Vptr) _T1(_Val);

	mov	ecx, DWORD PTR __Vptr$[ebp]
	push	ecx
	push	20					; 00000014H
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T99185[ebp], eax
	cmp	DWORD PTR $T99185[ebp], 0
	je	SHORT $LN3@Construct@4
	mov	edx, DWORD PTR __Val$[ebp]
	mov	eax, DWORD PTR $T99185[ebp]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], ecx
	mov	ecx, DWORD PTR [edx+12]
	mov	DWORD PTR [eax+12], ecx
	mov	edx, DWORD PTR [edx+16]
	mov	DWORD PTR [eax+16], edx
	mov	eax, DWORD PTR $T99185[ebp]
	mov	DWORD PTR tv69[ebp], eax
	jmp	SHORT $LN1@Construct@4
$LN3@Construct@4:
	mov	DWORD PTR tv69[ebp], 0
$LN1@Construct@4:

; 53   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Construct@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@U123@@std@@YAXPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@ABU123@@Z ENDP ; std::_Construct<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Construct@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@U123@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@ABU123@@Z
_TEXT	SEGMENT
tv69 = -12						; size = 4
$T99190 = -8						; size = 4
__Vptr$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@U123@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@ABU123@@Z PROC ; std::_Construct<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T>, COMDAT

; 50   : 	{	// construct object at _Ptr with value _Val

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi
	push	edi

; 51   : 	void _FARQ *_Vptr = _Ptr;

	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR __Vptr$[ebp], eax

; 52   : 	::new (_Vptr) _T1(_Val);

	mov	ecx, DWORD PTR __Vptr$[ebp]
	push	ecx
	push	32					; 00000020H
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T99190[ebp], eax
	cmp	DWORD PTR $T99190[ebp], 0
	je	SHORT $LN3@Construct@5
	mov	esi, DWORD PTR __Val$[ebp]
	mov	ecx, 8
	mov	edi, DWORD PTR $T99190[ebp]
	rep movsd
	mov	edx, DWORD PTR $T99190[ebp]
	mov	DWORD PTR tv69[ebp], edx
	jmp	SHORT $LN1@Construct@5
$LN3@Construct@5:
	mov	DWORD PTR tv69[ebp], 0
$LN1@Construct@5:

; 53   : 	}

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Construct@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@U123@@std@@YAXPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@ABU123@@Z ENDP ; std::_Construct<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Construct@UContextQueDesc@Ogre@@U12@@std@@YAXPAUContextQueDesc@Ogre@@ABU12@@Z
_TEXT	SEGMENT
tv69 = -12						; size = 4
$T99195 = -8						; size = 4
__Vptr$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@UContextQueDesc@Ogre@@U12@@std@@YAXPAUContextQueDesc@Ogre@@ABU12@@Z PROC ; std::_Construct<Ogre::ContextQueDesc,Ogre::ContextQueDesc>, COMDAT

; 50   : 	{	// construct object at _Ptr with value _Val

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi
	push	edi

; 51   : 	void _FARQ *_Vptr = _Ptr;

	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR __Vptr$[ebp], eax

; 52   : 	::new (_Vptr) _T1(_Val);

	mov	ecx, DWORD PTR __Vptr$[ebp]
	push	ecx
	push	156					; 0000009cH
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T99195[ebp], eax
	cmp	DWORD PTR $T99195[ebp], 0
	je	SHORT $LN3@Construct@6
	mov	esi, DWORD PTR __Val$[ebp]
	mov	ecx, 39					; 00000027H
	mov	edi, DWORD PTR $T99195[ebp]
	rep movsd
	mov	edx, DWORD PTR $T99195[ebp]
	mov	DWORD PTR tv69[ebp], edx
	jmp	SHORT $LN1@Construct@6
$LN3@Construct@6:
	mov	DWORD PTR tv69[ebp], 0
$LN1@Construct@6:

; 53   : 	}

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Construct@UContextQueDesc@Ogre@@U12@@std@@YAXPAUContextQueDesc@Ogre@@ABU12@@Z ENDP ; std::_Construct<Ogre::ContextQueDesc,Ogre::ContextQueDesc>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Construct@UValueParam@ShaderContextPool@Ogre@@U123@@std@@YAXPAUValueParam@ShaderContextPool@Ogre@@ABU123@@Z
_TEXT	SEGMENT
tv69 = -12						; size = 4
$T99200 = -8						; size = 4
__Vptr$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@UValueParam@ShaderContextPool@Ogre@@U123@@std@@YAXPAUValueParam@ShaderContextPool@Ogre@@ABU123@@Z PROC ; std::_Construct<Ogre::ShaderContextPool::ValueParam,Ogre::ShaderContextPool::ValueParam>, COMDAT

; 50   : 	{	// construct object at _Ptr with value _Val

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 51   : 	void _FARQ *_Vptr = _Ptr;

	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR __Vptr$[ebp], eax

; 52   : 	::new (_Vptr) _T1(_Val);

	mov	ecx, DWORD PTR __Vptr$[ebp]
	push	ecx
	push	16					; 00000010H
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T99200[ebp], eax
	cmp	DWORD PTR $T99200[ebp], 0
	je	SHORT $LN3@Construct@7
	mov	edx, DWORD PTR __Val$[ebp]
	mov	eax, DWORD PTR $T99200[ebp]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR [edx+12]
	mov	DWORD PTR [eax+12], edx
	mov	eax, DWORD PTR $T99200[ebp]
	mov	DWORD PTR tv69[ebp], eax
	jmp	SHORT $LN1@Construct@7
$LN3@Construct@7:
	mov	DWORD PTR tv69[ebp], 0
$LN1@Construct@7:

; 53   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Construct@UValueParam@ShaderContextPool@Ogre@@U123@@std@@YAXPAUValueParam@ShaderContextPool@Ogre@@ABU123@@Z ENDP ; std::_Construct<Ogre::ShaderContextPool::ValueParam,Ogre::ShaderContextPool::ValueParam>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Construct@UTexParam@ShaderContextPool@Ogre@@U123@@std@@YAXPAUTexParam@ShaderContextPool@Ogre@@ABU123@@Z
_TEXT	SEGMENT
tv69 = -12						; size = 4
$T99205 = -8						; size = 4
__Vptr$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@UTexParam@ShaderContextPool@Ogre@@U123@@std@@YAXPAUTexParam@ShaderContextPool@Ogre@@ABU123@@Z PROC ; std::_Construct<Ogre::ShaderContextPool::TexParam,Ogre::ShaderContextPool::TexParam>, COMDAT

; 50   : 	{	// construct object at _Ptr with value _Val

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 51   : 	void _FARQ *_Vptr = _Ptr;

	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR __Vptr$[ebp], eax

; 52   : 	::new (_Vptr) _T1(_Val);

	mov	ecx, DWORD PTR __Vptr$[ebp]
	push	ecx
	push	8
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T99205[ebp], eax
	cmp	DWORD PTR $T99205[ebp], 0
	je	SHORT $LN3@Construct@8
	mov	edx, DWORD PTR __Val$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR $T99205[ebp]
	mov	DWORD PTR [edx], eax
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR $T99205[ebp]
	mov	DWORD PTR tv69[ebp], eax
	jmp	SHORT $LN1@Construct@8
$LN3@Construct@8:
	mov	DWORD PTR tv69[ebp], 0
$LN1@Construct@8:

; 53   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Construct@UTexParam@ShaderContextPool@Ogre@@U123@@std@@YAXPAUTexParam@ShaderContextPool@Ogre@@ABU123@@Z ENDP ; std::_Construct<Ogre::ShaderContextPool::TexParam,Ogre::ShaderContextPool::TexParam>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Construct@URecord@CullResult@Ogre@@U123@@std@@YAXPAURecord@CullResult@Ogre@@ABU123@@Z
_TEXT	SEGMENT
tv69 = -12						; size = 4
$T99210 = -8						; size = 4
__Vptr$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@URecord@CullResult@Ogre@@U123@@std@@YAXPAURecord@CullResult@Ogre@@ABU123@@Z PROC ; std::_Construct<Ogre::CullResult::Record,Ogre::CullResult::Record>, COMDAT

; 50   : 	{	// construct object at _Ptr with value _Val

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 51   : 	void _FARQ *_Vptr = _Ptr;

	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR __Vptr$[ebp], eax

; 52   : 	::new (_Vptr) _T1(_Val);

	mov	ecx, DWORD PTR __Vptr$[ebp]
	push	ecx
	push	16					; 00000010H
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T99210[ebp], eax
	cmp	DWORD PTR $T99210[ebp], 0
	je	SHORT $LN3@Construct@9
	mov	edx, DWORD PTR __Val$[ebp]
	mov	eax, DWORD PTR $T99210[ebp]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], ecx
	mov	edx, DWORD PTR [edx+12]
	mov	DWORD PTR [eax+12], edx
	mov	eax, DWORD PTR $T99210[ebp]
	mov	DWORD PTR tv69[ebp], eax
	jmp	SHORT $LN1@Construct@9
$LN3@Construct@9:
	mov	DWORD PTR tv69[ebp], 0
$LN1@Construct@9:

; 53   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Construct@URecord@CullResult@Ogre@@U123@@std@@YAXPAURecord@CullResult@Ogre@@ABU123@@Z ENDP ; std::_Construct<Ogre::CullResult::Record,Ogre::CullResult::Record>
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?_Checked_iterator_base@?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QBEPBUAnimRange@BaseKeyFrameArray@Ogre@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Checked_iterator_base@?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QBEPBUAnimRange@BaseKeyFrameArray@Ogre@@XZ PROC ; std::_Vector_const_iterator<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::_Checked_iterator_base, COMDAT
; _this$ = ecx

; 46   : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 47   : 		return _Myptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 48   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Checked_iterator_base@?$_Vector_const_iterator@UAnimRange@BaseKeyFrameArray@Ogre@@V?$allocator@UAnimRange@BaseKeyFrameArray@Ogre@@@std@@@std@@QBEPBUAnimRange@BaseKeyFrameArray@Ogre@@XZ ENDP ; std::_Vector_const_iterator<Ogre::BaseKeyFrameArray::AnimRange,std::allocator<Ogre::BaseKeyFrameArray::AnimRange> >::_Checked_iterator_base
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Checked_iterator_base@?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QBEPBUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Checked_iterator_base@?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QBEPBUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@XZ PROC ; std::_Vector_const_iterator<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::_Checked_iterator_base, COMDAT
; _this$ = ecx

; 46   : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 47   : 		return _Myptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 48   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Checked_iterator_base@?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QBEPBUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@XZ ENDP ; std::_Vector_const_iterator<Ogre::KeyFrameArray<float>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<float>::KEYFRAME_T> >::_Checked_iterator_base
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Checked_iterator_base@?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QBEPBUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Checked_iterator_base@?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QBEPBUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@XZ PROC ; std::_Vector_const_iterator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::_Checked_iterator_base, COMDAT
; _this$ = ecx

; 46   : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 47   : 		return _Myptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 48   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Checked_iterator_base@?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@@std@@@std@@QBEPBUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@XZ ENDP ; std::_Vector_const_iterator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<float>::CONTROL_POINT_T> >::_Checked_iterator_base
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Checked_iterator_base@?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QBEPBUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Checked_iterator_base@?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QBEPBUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@XZ PROC ; std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::_Checked_iterator_base, COMDAT
; _this$ = ecx

; 46   : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 47   : 		return _Myptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 48   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Checked_iterator_base@?$_Vector_const_iterator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QBEPBUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@XZ ENDP ; std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T> >::_Checked_iterator_base
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Checked_iterator_base@?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QBEPBUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Checked_iterator_base@?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QBEPBUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@XZ PROC ; std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::_Checked_iterator_base, COMDAT
; _this$ = ecx

; 46   : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 47   : 		return _Myptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 48   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Checked_iterator_base@?$_Vector_const_iterator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@V?$allocator@UCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@@std@@@std@@QBEPBUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@XZ ENDP ; std::_Vector_const_iterator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T,std::allocator<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T> >::_Checked_iterator_base
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Checked_iterator_base@?$_Vector_const_iterator@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@QBEPBQAVShaderContext@Ogre@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Checked_iterator_base@?$_Vector_const_iterator@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@QBEPBQAVShaderContext@Ogre@@XZ PROC ; std::_Vector_const_iterator<Ogre::ShaderContext *,std::allocator<Ogre::ShaderContext *> >::_Checked_iterator_base, COMDAT
; _this$ = ecx

; 46   : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 47   : 		return _Myptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 48   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Checked_iterator_base@?$_Vector_const_iterator@PAVShaderContext@Ogre@@V?$allocator@PAVShaderContext@Ogre@@@std@@@std@@QBEPBQAVShaderContext@Ogre@@XZ ENDP ; std::_Vector_const_iterator<Ogre::ShaderContext *,std::allocator<Ogre::ShaderContext *> >::_Checked_iterator_base
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Checked_iterator_base@?$_Vector_const_iterator@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@QBEPBUContextQueDesc@Ogre@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Checked_iterator_base@?$_Vector_const_iterator@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@QBEPBUContextQueDesc@Ogre@@XZ PROC ; std::_Vector_const_iterator<Ogre::ContextQueDesc,std::allocator<Ogre::ContextQueDesc> >::_Checked_iterator_base, COMDAT
; _this$ = ecx

; 46   : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 47   : 		return _Myptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 48   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Checked_iterator_base@?$_Vector_const_iterator@UContextQueDesc@Ogre@@V?$allocator@UContextQueDesc@Ogre@@@std@@@std@@QBEPBUContextQueDesc@Ogre@@XZ ENDP ; std::_Vector_const_iterator<Ogre::ContextQueDesc,std::allocator<Ogre::ContextQueDesc> >::_Checked_iterator_base
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Checked_iterator_base@?$_Vector_const_iterator@EV?$allocator@E@std@@@std@@QBEPBEXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Checked_iterator_base@?$_Vector_const_iterator@EV?$allocator@E@std@@@std@@QBEPBEXZ PROC ; std::_Vector_const_iterator<unsigned char,std::allocator<unsigned char> >::_Checked_iterator_base, COMDAT
; _this$ = ecx

; 46   : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 47   : 		return _Myptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 48   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Checked_iterator_base@?$_Vector_const_iterator@EV?$allocator@E@std@@@std@@QBEPBEXZ ENDP ; std::_Vector_const_iterator<unsigned char,std::allocator<unsigned char> >::_Checked_iterator_base
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Checked_iterator_base@?$_Vector_const_iterator@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@QBEPBUValueParam@ShaderContextPool@Ogre@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Checked_iterator_base@?$_Vector_const_iterator@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@QBEPBUValueParam@ShaderContextPool@Ogre@@XZ PROC ; std::_Vector_const_iterator<Ogre::ShaderContextPool::ValueParam,std::allocator<Ogre::ShaderContextPool::ValueParam> >::_Checked_iterator_base, COMDAT
; _this$ = ecx

; 46   : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 47   : 		return _Myptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 48   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Checked_iterator_base@?$_Vector_const_iterator@UValueParam@ShaderContextPool@Ogre@@V?$allocator@UValueParam@ShaderContextPool@Ogre@@@std@@@std@@QBEPBUValueParam@ShaderContextPool@Ogre@@XZ ENDP ; std::_Vector_const_iterator<Ogre::ShaderContextPool::ValueParam,std::allocator<Ogre::ShaderContextPool::ValueParam> >::_Checked_iterator_base
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Checked_iterator_base@?$_Vector_const_iterator@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@QBEPBUTexParam@ShaderContextPool@Ogre@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Checked_iterator_base@?$_Vector_const_iterator@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@QBEPBUTexParam@ShaderContextPool@Ogre@@XZ PROC ; std::_Vector_const_iterator<Ogre::ShaderContextPool::TexParam,std::allocator<Ogre::ShaderContextPool::TexParam> >::_Checked_iterator_base, COMDAT
; _this$ = ecx

; 46   : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 47   : 		return _Myptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 48   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Checked_iterator_base@?$_Vector_const_iterator@UTexParam@ShaderContextPool@Ogre@@V?$allocator@UTexParam@ShaderContextPool@Ogre@@@std@@@std@@QBEPBUTexParam@ShaderContextPool@Ogre@@XZ ENDP ; std::_Vector_const_iterator<Ogre::ShaderContextPool::TexParam,std::allocator<Ogre::ShaderContextPool::TexParam> >::_Checked_iterator_base
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Checked_iterator_base@?$_Vector_const_iterator@DV?$allocator@D@std@@@std@@QBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Checked_iterator_base@?$_Vector_const_iterator@DV?$allocator@D@std@@@std@@QBEPBDXZ PROC ; std::_Vector_const_iterator<char,std::allocator<char> >::_Checked_iterator_base, COMDAT
; _this$ = ecx

; 46   : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 47   : 		return _Myptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 48   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Checked_iterator_base@?$_Vector_const_iterator@DV?$allocator@D@std@@@std@@QBEPBDXZ ENDP ; std::_Vector_const_iterator<char,std::allocator<char> >::_Checked_iterator_base
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Checked_iterator_base@?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QBEPBQAVSurfaceData@Ogre@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Checked_iterator_base@?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QBEPBQAVSurfaceData@Ogre@@XZ PROC ; std::_Vector_const_iterator<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::_Checked_iterator_base, COMDAT
; _this$ = ecx

; 46   : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 47   : 		return _Myptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 48   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Checked_iterator_base@?$_Vector_const_iterator@PAVSurfaceData@Ogre@@V?$allocator@PAVSurfaceData@Ogre@@@std@@@std@@QBEPBQAVSurfaceData@Ogre@@XZ ENDP ; std::_Vector_const_iterator<Ogre::SurfaceData *,std::allocator<Ogre::SurfaceData *> >::_Checked_iterator_base
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Checked_iterator_base@?$_Vector_const_iterator@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@QBEPBURecord@CullResult@Ogre@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Checked_iterator_base@?$_Vector_const_iterator@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@QBEPBURecord@CullResult@Ogre@@XZ PROC ; std::_Vector_const_iterator<Ogre::CullResult::Record,std::allocator<Ogre::CullResult::Record> >::_Checked_iterator_base, COMDAT
; _this$ = ecx

; 46   : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 47   : 		return _Myptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 48   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Checked_iterator_base@?$_Vector_const_iterator@URecord@CullResult@Ogre@@V?$allocator@URecord@CullResult@Ogre@@@std@@@std@@QBEPBURecord@CullResult@Ogre@@XZ ENDP ; std::_Vector_const_iterator<Ogre::CullResult::Record,std::allocator<Ogre::CullResult::Record> >::_Checked_iterator_base
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Checked_iterator_base@?$_Vector_const_iterator@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@QBEPBQAVEffectObject@Ogre@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Checked_iterator_base@?$_Vector_const_iterator@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@QBEPBQAVEffectObject@Ogre@@XZ PROC ; std::_Vector_const_iterator<Ogre::EffectObject *,std::allocator<Ogre::EffectObject *> >::_Checked_iterator_base, COMDAT
; _this$ = ecx

; 46   : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 47   : 		return _Myptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 48   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Checked_iterator_base@?$_Vector_const_iterator@PAVEffectObject@Ogre@@V?$allocator@PAVEffectObject@Ogre@@@std@@@std@@QBEPBQAVEffectObject@Ogre@@XZ ENDP ; std::_Vector_const_iterator<Ogre::EffectObject *,std::allocator<Ogre::EffectObject *> >::_Checked_iterator_base
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Checked_iterator_base@?$_Vector_const_iterator@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@QBEPBQAVSoundNode@Ogre@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Checked_iterator_base@?$_Vector_const_iterator@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@QBEPBQAVSoundNode@Ogre@@XZ PROC ; std::_Vector_const_iterator<Ogre::SoundNode *,std::allocator<Ogre::SoundNode *> >::_Checked_iterator_base, COMDAT
; _this$ = ecx

; 46   : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 47   : 		return _Myptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 48   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Checked_iterator_base@?$_Vector_const_iterator@PAVSoundNode@Ogre@@V?$allocator@PAVSoundNode@Ogre@@@std@@@std@@QBEPBQAVSoundNode@Ogre@@XZ ENDP ; std::_Vector_const_iterator<Ogre::SoundNode *,std::allocator<Ogre::SoundNode *> >::_Checked_iterator_base
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Checked_iterator_base@?$_Vector_const_iterator@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@QBEPBQAVRenderableObject@Ogre@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Checked_iterator_base@?$_Vector_const_iterator@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@QBEPBQAVRenderableObject@Ogre@@XZ PROC ; std::_Vector_const_iterator<Ogre::RenderableObject *,std::allocator<Ogre::RenderableObject *> >::_Checked_iterator_base, COMDAT
; _this$ = ecx

; 46   : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 47   : 		return _Myptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 48   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Checked_iterator_base@?$_Vector_const_iterator@PAVRenderableObject@Ogre@@V?$allocator@PAVRenderableObject@Ogre@@@std@@@std@@QBEPBQAVRenderableObject@Ogre@@XZ ENDP ; std::_Vector_const_iterator<Ogre::RenderableObject *,std::allocator<Ogre::RenderableObject *> >::_Checked_iterator_base
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Checked_iterator_base@?$_Vector_const_iterator@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@QBEPBQAVLight@Ogre@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Checked_iterator_base@?$_Vector_const_iterator@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@QBEPBQAVLight@Ogre@@XZ PROC ; std::_Vector_const_iterator<Ogre::Light *,std::allocator<Ogre::Light *> >::_Checked_iterator_base, COMDAT
; _this$ = ecx

; 46   : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 47   : 		return _Myptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 48   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Checked_iterator_base@?$_Vector_const_iterator@PAVLight@Ogre@@V?$allocator@PAVLight@Ogre@@@std@@@std@@QBEPBQAVLight@Ogre@@XZ ENDP ; std::_Vector_const_iterator<Ogre::Light *,std::allocator<Ogre::Light *> >::_Checked_iterator_base
; Function compile flags: /Odtp
; File d:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Copy_backward_opt@PAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@Uforward_iterator_tag@std@@@std@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_backward_opt@PAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@Uforward_iterator_tag@std@@@std@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<Ogre::BaseKeyFrameArray::AnimRange *,Ogre::BaseKeyFrameArray::AnimRange *,std::forward_iterator_tag>, COMDAT

; 2673 : 	{	// copy [_First, _Last) backwards to [..., _Dest), arbitrary iterators

	push	ebp
	mov	ebp, esp
$LN2@Copy_backw:

; 2674 : 	_DEBUG_RANGE(_First, _Last);
; 2675 : 	while (_First != _Last)

	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	SHORT $LN1@Copy_backw

; 2676 : 		*--_Dest = *--_Last;

	mov	ecx, DWORD PTR __Last$[ebp]
	sub	ecx, 8
	mov	DWORD PTR __Last$[ebp], ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	sub	edx, 8
	mov	DWORD PTR __Dest$[ebp], edx
	mov	eax, DWORD PTR __Last$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	jmp	SHORT $LN2@Copy_backw
$LN1@Copy_backw:

; 2677 : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[ebp]

; 2678 : 	}

	pop	ebp
	ret	0
??$_Copy_backward_opt@PAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@Uforward_iterator_tag@std@@@std@@YAPAUAnimRange@BaseKeyFrameArray@Ogre@@PAU123@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<Ogre::BaseKeyFrameArray::AnimRange *,Ogre::BaseKeyFrameArray::AnimRange *,std::forward_iterator_tag>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Copy_backward_opt@PAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU123@Uforward_iterator_tag@std@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU123@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_backward_opt@PAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU123@Uforward_iterator_tag@std@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU123@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<Ogre::KeyFrameArray<float>::KEYFRAME_T *,Ogre::KeyFrameArray<float>::KEYFRAME_T *,std::forward_iterator_tag>, COMDAT

; 2673 : 	{	// copy [_First, _Last) backwards to [..., _Dest), arbitrary iterators

	push	ebp
	mov	ebp, esp
$LN2@Copy_backw@2:

; 2674 : 	_DEBUG_RANGE(_First, _Last);
; 2675 : 	while (_First != _Last)

	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	SHORT $LN1@Copy_backw@2

; 2676 : 		*--_Dest = *--_Last;

	mov	ecx, DWORD PTR __Last$[ebp]
	sub	ecx, 8
	mov	DWORD PTR __Last$[ebp], ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	sub	edx, 8
	mov	DWORD PTR __Dest$[ebp], edx
	mov	eax, DWORD PTR __Last$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	jmp	SHORT $LN2@Copy_backw@2
$LN1@Copy_backw@2:

; 2677 : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[ebp]

; 2678 : 	}

	pop	ebp
	ret	0
??$_Copy_backward_opt@PAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU123@Uforward_iterator_tag@std@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@M@Ogre@@PAU123@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<Ogre::KeyFrameArray<float>::KEYFRAME_T *,Ogre::KeyFrameArray<float>::KEYFRAME_T *,std::forward_iterator_tag>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Copy_backward_opt@PAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU123@Uforward_iterator_tag@std@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU123@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_backward_opt@PAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU123@Uforward_iterator_tag@std@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU123@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<Ogre::KeyFrameArray<float>::CONTROL_POINT_T *,Ogre::KeyFrameArray<float>::CONTROL_POINT_T *,std::forward_iterator_tag>, COMDAT

; 2673 : 	{	// copy [_First, _Last) backwards to [..., _Dest), arbitrary iterators

	push	ebp
	mov	ebp, esp
$LN2@Copy_backw@3:

; 2674 : 	_DEBUG_RANGE(_First, _Last);
; 2675 : 	while (_First != _Last)

	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	SHORT $LN1@Copy_backw@3

; 2676 : 		*--_Dest = *--_Last;

	mov	ecx, DWORD PTR __Last$[ebp]
	sub	ecx, 8
	mov	DWORD PTR __Last$[ebp], ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	sub	edx, 8
	mov	DWORD PTR __Dest$[ebp], edx
	mov	eax, DWORD PTR __Last$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	jmp	SHORT $LN2@Copy_backw@3
$LN1@Copy_backw@3:

; 2677 : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[ebp]

; 2678 : 	}

	pop	ebp
	ret	0
??$_Copy_backward_opt@PAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU123@Uforward_iterator_tag@std@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@M@Ogre@@PAU123@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<Ogre::KeyFrameArray<float>::CONTROL_POINT_T *,Ogre::KeyFrameArray<float>::CONTROL_POINT_T *,std::forward_iterator_tag>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Copy_backward_opt@PAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@Uforward_iterator_tag@std@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_backward_opt@PAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@Uforward_iterator_tag@std@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T *,std::forward_iterator_tag>, COMDAT

; 2673 : 	{	// copy [_First, _Last) backwards to [..., _Dest), arbitrary iterators

	push	ebp
	mov	ebp, esp
$LN2@Copy_backw@4:

; 2674 : 	_DEBUG_RANGE(_First, _Last);
; 2675 : 	while (_First != _Last)

	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	SHORT $LN1@Copy_backw@4

; 2676 : 		*--_Dest = *--_Last;

	mov	ecx, DWORD PTR __Last$[ebp]
	sub	ecx, 20					; 00000014H
	mov	DWORD PTR __Last$[ebp], ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	sub	edx, 20					; 00000014H
	mov	DWORD PTR __Dest$[ebp], edx
	mov	eax, DWORD PTR __Last$[ebp]
	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], edx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR [ecx+12], edx
	mov	eax, DWORD PTR [eax+16]
	mov	DWORD PTR [ecx+16], eax
	jmp	SHORT $LN2@Copy_backw@4
$LN1@Copy_backw@4:

; 2677 : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[ebp]

; 2678 : 	}

	pop	ebp
	ret	0
??$_Copy_backward_opt@PAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@Uforward_iterator_tag@std@@@std@@YAPAUKEYFRAME_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T *,Ogre::KeyFrameArray<Ogre::ColourValue>::KEYFRAME_T *,std::forward_iterator_tag>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Copy_backward_opt@PAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@Uforward_iterator_tag@std@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_backward_opt@PAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@Uforward_iterator_tag@std@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T *,std::forward_iterator_tag>, COMDAT

; 2673 : 	{	// copy [_First, _Last) backwards to [..., _Dest), arbitrary iterators

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
$LN2@Copy_backw@5:

; 2674 : 	_DEBUG_RANGE(_First, _Last);
; 2675 : 	while (_First != _Last)

	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	SHORT $LN1@Copy_backw@5

; 2676 : 		*--_Dest = *--_Last;

	mov	ecx, DWORD PTR __Last$[ebp]
	sub	ecx, 32					; 00000020H
	mov	DWORD PTR __Last$[ebp], ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	sub	edx, 32					; 00000020H
	mov	DWORD PTR __Dest$[ebp], edx
	mov	esi, DWORD PTR __Last$[ebp]
	mov	ecx, 8
	mov	edi, DWORD PTR __Dest$[ebp]
	rep movsd
	jmp	SHORT $LN2@Copy_backw@5
$LN1@Copy_backw@5:

; 2677 : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[ebp]

; 2678 : 	}

	pop	edi
	pop	esi
	pop	ebp
	ret	0
??$_Copy_backward_opt@PAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@Uforward_iterator_tag@std@@@std@@YAPAUCONTROL_POINT_T@?$KeyFrameArray@VColourValue@Ogre@@@Ogre@@PAU123@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T *,Ogre::KeyFrameArray<Ogre::ColourValue>::CONTROL_POINT_T *,std::forward_iterator_tag>
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogremath.h
_TEXT	ENDS
;	COMDAT ??__ETWO_PI@Ogre@@YAXXZ
text$yc	SEGMENT
??__ETWO_PI@Ogre@@YAXXZ PROC				; Ogre::`dynamic initializer for 'TWO_PI'', COMDAT

; 10   : 	const float TWO_PI = ONE_PI*2;

	push	ebp
	mov	ebp, esp
	fld	DWORD PTR _ONE_PI
	fadd	ST(0), ST(0)
	fstp	DWORD PTR _TWO_PI
	pop	ebp
	ret	0
??__ETWO_PI@Ogre@@YAXXZ ENDP				; Ogre::`dynamic initializer for 'TWO_PI''
text$yc	ENDS
PUBLIC	__real@3fe0000000000000
;	COMDAT __real@3fe0000000000000
CONST	SEGMENT
__real@3fe0000000000000 DQ 03fe0000000000000r	; 0.5
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ??__EHALF_PI@Ogre@@YAXXZ
text$yc	SEGMENT
??__EHALF_PI@Ogre@@YAXXZ PROC				; Ogre::`dynamic initializer for 'HALF_PI'', COMDAT

; 11   : 	const float	HALF_PI = ONE_PI*0.5f;

	push	ebp
	mov	ebp, esp
	fld	DWORD PTR _ONE_PI
	fmul	QWORD PTR __real@3fe0000000000000
	fstp	DWORD PTR _HALF_PI
	pop	ebp
	ret	0
??__EHALF_PI@Ogre@@YAXXZ ENDP				; Ogre::`dynamic initializer for 'HALF_PI''
text$yc	ENDS
EXTRN	??0RuntimeClass@Ogre@@QAE@PBDPBV01@HP6APAVBaseObject@1@XZ@Z:PROC ; Ogre::RuntimeClass::RuntimeClass
; Function compile flags: /Odtp
; File i:\svnroot\client\ogremain\ogreparametricshape.cpp
;	COMDAT ??__E?m_RTTI@ParametricShape@Ogre@@2VRuntimeClass@2@B@@YAXXZ
text$yc	SEGMENT
??__E?m_RTTI@ParametricShape@Ogre@@2VRuntimeClass@2@B@@YAXXZ PROC ; `dynamic initializer for 'Ogre::ParametricShape::m_RTTI'', COMDAT

; 13   : 	IMPLEMENT_RTTI(ParametricShape, RenderableObject, 100);

	push	ebp
	mov	ebp, esp
	push	OFFSET ?newObject@ParametricShape@Ogre@@SAPAVBaseObject@2@XZ ; Ogre::ParametricShape::newObject
	push	100					; 00000064H
	push	OFFSET ?m_RTTI@RenderableObject@Ogre@@2VRuntimeClass@2@B ; Ogre::RenderableObject::m_RTTI
	push	OFFSET $SG69859
	mov	ecx, OFFSET ?m_RTTI@ParametricShape@Ogre@@2VRuntimeClass@2@B ; Ogre::ParametricShape::m_RTTI
	call	??0RuntimeClass@Ogre@@QAE@PBDPBV01@HP6APAVBaseObject@1@XZ@Z ; Ogre::RuntimeClass::RuntimeClass
	pop	ebp
	ret	0
??__E?m_RTTI@ParametricShape@Ogre@@2VRuntimeClass@2@B@@YAXXZ ENDP ; `dynamic initializer for 'Ogre::ParametricShape::m_RTTI''
text$yc	ENDS
PUBLIC	?m_RTTI@ParametricShape@Ogre@@2VRuntimeClass@2@B ; Ogre::ParametricShape::m_RTTI
_BSS	SEGMENT
_TWO_PI	DD	01H DUP (?)
_HALF_PI DD	01H DUP (?)
?m_RTTI@ParametricShape@Ogre@@2VRuntimeClass@2@B DB 014H DUP (?) ; Ogre::ParametricShape::m_RTTI
_BSS	ENDS
CRT$XCU	SEGMENT
_TWO_PI$initializer$ DD FLAT:??__ETWO_PI@Ogre@@YAXXZ
_HALF_PI$initializer$ DD FLAT:??__EHALF_PI@Ogre@@YAXXZ
?m_RTTI$initializer$@ParametricShape@Ogre@@2P6AXXZA DD FLAT:??__E?m_RTTI@ParametricShape@Ogre@@2VRuntimeClass@2@B@@YAXXZ ; Ogre::ParametricShape::m_RTTI$initializer$
CRT$XCU	ENDS
END
